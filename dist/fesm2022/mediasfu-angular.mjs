import * as i0 from '@angular/core';
import { Component, Input, ContentChildren, Injectable, Optional, Inject, ViewChild, EventEmitter, Output, ViewEncapsulation, Injector, HostListener } from '@angular/core';
import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i2 from '@fortawesome/angular-fontawesome';
import { FontAwesomeModule } from '@fortawesome/angular-fontawesome';
import { faSpinner, faCopy, faEnvelope, faBars, faTimes, faCheck, faPlay, faMicrophone, faDesktop, faVideo, faComments, faMicrophoneSlash, faComment, faTrash, faDotCircle, faCircle, faPaperPlane, faReply, faSyncAlt, faCamera, faPhotoFilm, faQrcode, faPen, faUsers, faPlus, faDoorOpen, faRandom, faHandPointer, faSave, faStop, faUndo, faRedo, faEraser, faShapes, faMousePointer, faHandPaper, faTextHeight, faFont, faPencilAlt, faPaintBrush, faSearch, faSearchMinus, faSearchPlus, faChevronLeft, faUpload, faChevronRight, faStar, faLock, faVideoSlash, faBan, faRecordVinyl, faPlayCircle, faPauseCircle, faStopCircle, faCog, faClock, faUserPlus, faTools, faPoll, faUserFriends, faChalkboardTeacher, faSync, faPhone, faShareAlt, faChartBar } from '@fortawesome/free-solid-svg-icons';
import * as i2$1 from '@angular/forms';
import { FormsModule, Validators, ReactiveFormsModule } from '@angular/forms';
import { faFacebook, faWhatsapp, faTelegram } from '@fortawesome/free-brands-svg-icons';
import * as i2$2 from 'ngx-cookie-service';
import { CookieService } from 'ngx-cookie-service';
import * as i3 from '@zxing/ngx-scanner';
import { ZXingScannerModule } from '@zxing/ngx-scanner';
import io, { Socket } from 'socket.io-client';
import * as i2$3 from '@angular/common/http';
import { HttpHeaders } from '@angular/common/http';
import { SelfieSegmentation } from '@mediapipe/selfie_segmentation';
import * as mediasoupClient from 'mediasoup-client';
import { RouterOutlet } from '@angular/router';
import { BehaviorSubject, combineLatest } from 'rxjs';

const initialValuesState = {
    // The following are the initial values
    roomName: '',
    member: '',
    adminPasscode: '',
    islevel: '1',
    coHost: 'No coHost',
    coHostResponsibility: [
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ],
    youAreCoHost: false,
    youAreHost: false,
    confirmedToRecord: false,
    meetingDisplayType: 'media',
    meetingVideoOptimized: false,
    eventType: 'webinar',
    participants: [],
    filteredParticipants: [],
    participantsCounter: 0,
    participantsFilter: '',
    validated: false,
    localUIMode: false,
    socket: {},
    roomData: null,
    device: null,
    apiKey: '',
    apiUserName: '',
    apiToken: '',
    link: '',
    consume_sockets: [],
    rtpCapabilities: null,
    roomRecvIPs: [],
    meetingRoomParams: null,
    itemPageLimit: 4,
    audioOnlyRoom: false,
    addForBasic: false,
    screenPageLimit: 4,
    shareScreenStarted: false,
    shared: false,
    targetOrientation: 'landscape',
    targetResolution: 'sd',
    targetResolutionHost: 'sd',
    vidCons: { width: 640, height: 360 },
    frameRate: 10,
    hParams: {},
    vParams: {},
    screenParams: {},
    aParams: {},
    // Initial Values for New Recording Fields
    recordingAudioPausesLimit: 0,
    recordingAudioPausesCount: 0,
    recordingAudioSupport: false,
    recordingAudioPeopleLimit: 0,
    recordingAudioParticipantsTimeLimit: 0,
    recordingVideoPausesCount: 0,
    recordingVideoPausesLimit: 0,
    recordingVideoSupport: false,
    recordingVideoPeopleLimit: 0,
    recordingVideoParticipantsTimeLimit: 0,
    recordingAllParticipantsSupport: false,
    recordingVideoParticipantsSupport: false,
    recordingAllParticipantsFullRoomSupport: false,
    recordingVideoParticipantsFullRoomSupport: false,
    recordingPreferredOrientation: 'landscape',
    recordingSupportForOtherOrientation: false,
    recordingMultiFormatsSupport: false,
    userRecordingParams: {
        mainSpecs: {
            mediaOptions: 'video',
            audioOptions: 'all',
            videoOptions: 'all',
            videoType: 'fullDisplay',
            videoOptimized: false,
            recordingDisplayType: 'media',
            addHLS: false,
        },
        dispSpecs: {
            nameTags: true,
            backgroundColor: '#000000',
            nameTagsColor: '#ffffff',
            orientationVideo: 'portrait',
        },
    },
    canRecord: false,
    startReport: false,
    endReport: false,
    recordTimerInterval: null,
    recordStartTime: 0,
    recordElapsedTime: 0,
    isTimerRunning: false,
    canPauseResume: false,
    recordChangeSeconds: 15000,
    pauseLimit: 0,
    pauseRecordCount: 0,
    canLaunchRecord: true,
    stopLaunchRecord: false,
    // Room properties
    participantsAll: [],
    firstAll: false,
    updateMainWindow: false,
    first_round: false,
    landScaped: false,
    lock_screen: false,
    screenId: '',
    allVideoStreams: [],
    newLimitedStreams: [],
    newLimitedStreamsIDs: [],
    activeSounds: [],
    screenShareIDStream: '',
    screenShareNameStream: '',
    adminIDStream: '',
    adminNameStream: '',
    youYouStream: [],
    youYouStreamIDs: [],
    localStream: null,
    recordStarted: false,
    recordResumed: false,
    recordPaused: false,
    recordStopped: false,
    adminRestrictSetting: false,
    videoRequestState: null,
    videoRequestTime: 0,
    videoAction: false,
    localStreamVideo: null,
    userDefaultVideoInputDevice: '',
    currentFacingMode: 'user',
    prevFacingMode: 'user',
    defVideoID: '',
    allowed: false,
    dispActiveNames: [],
    activeNames: [],
    prevActiveNames: [],
    p_activeNames: [],
    p_dispActiveNames: [],
    membersReceived: false,
    deferScreenReceived: false,
    hostFirstSwitch: false,
    micAction: false,
    screenAction: false,
    chatAction: false,
    audioRequestState: null,
    screenRequestState: null,
    chatRequestState: null,
    audioRequestTime: 0,
    screenRequestTime: 0,
    chatRequestTime: 0,
    updateRequestIntervalSeconds: 240,
    oldSoundIds: [],
    hostLabel: 'Host',
    mainScreenFilled: false,
    localStreamScreen: null,
    screenAlreadyOn: false,
    chatAlreadyOn: false,
    redirectURL: '',
    oldAllStreams: [],
    adminVidID: '',
    streamNames: [],
    non_alVideoStreams: [],
    sortAudioLoudness: false,
    audioDecibels: [],
    mixed_alVideoStreams: [],
    non_alVideoStreams_muted: [],
    paginatedStreams: [],
    localStreamAudio: null,
    defAudioID: '',
    userDefaultAudioInputDevice: '',
    userDefaultAudioOutputDevice: '',
    prevAudioInputDevice: '',
    prevVideoInputDevice: '',
    audioPaused: false,
    mainScreenPerson: '',
    adminOnMainScreen: false,
    screenStates: [],
    prevScreenStates: [],
    updateDateState: null,
    lastUpdate: null,
    nForReadjustRecord: 0,
    fixedPageLimit: 4,
    removeAltGrid: false,
    nForReadjust: 0,
    reorderInterval: 30000,
    fastReorderInterval: 10000,
    lastReorderTime: 0,
    audStreamNames: [],
    currentUserPage: 0,
    mainHeightWidth: 0,
    prevMainHeightWidth: 0,
    prevDoPaginate: false,
    doPaginate: false,
    shareEnded: false,
    lStreams: [],
    chatRefStreams: [],
    controlHeight: 0,
    isWideScreen: false,
    isMediumScreen: false,
    isSmallScreen: false,
    addGrid: false,
    addAltGrid: false,
    gridRows: 0,
    gridCols: 0,
    altGridRows: 0,
    altGridCols: 0,
    numberPages: 0,
    currentStreams: [],
    showMiniView: false,
    nStream: null,
    defer_receive: false,
    allAudioStreams: [],
    remoteScreenStream: [],
    screenProducer: null,
    gotAllVids: false,
    paginationHeightWidth: 40,
    paginationDirection: 'horizontal',
    gridSizes: { gridWidth: 0, gridHeight: 0, altGridWidth: 0, altGridHeight: 0 },
    screenForceFullDisplay: false,
    mainGridStream: [],
    otherGridStreams: [[], []],
    audioOnlyStreams: [],
    videoInputs: [],
    audioInputs: [],
    meetingProgressTime: '00:00:00',
    meetingElapsedTime: 0,
    ref_participants: [],
    // Messaging, event, modals, and other UI states
    messages: [],
    startDirectMessage: false,
    directMessageDetails: null,
    showMessagesBadge: false,
    audioSetting: 'allow',
    videoSetting: 'allow',
    screenshareSetting: 'allow',
    chatSetting: 'allow',
    displayOption: 'media',
    autoWave: true,
    forceFullDisplay: true,
    prevForceFullDisplay: false,
    prevMeetingDisplayType: 'video',
    waitingRoomFilter: '',
    waitingRoomList: [],
    waitingRoomCounter: 0,
    filteredWaitingRoomList: [],
    requestFilter: '',
    requestList: [],
    requestCounter: 0,
    filteredRequestList: [],
    totalReqWait: 0,
    alertVisible: false,
    alertMessage: '',
    alertType: 'success',
    alertDuration: 3000,
    progressTimerVisible: true,
    progressTimerValue: 0,
    isMenuModalVisible: false,
    isRecordingModalVisible: false,
    isSettingsModalVisible: false,
    isRequestsModalVisible: false,
    isWaitingModalVisible: false,
    isCoHostModalVisible: false,
    isMediaSettingsModalVisible: false,
    isDisplaySettingsModalVisible: false,
    isParticipantsModalVisible: false,
    isMessagesModalVisible: false,
    isConfirmExitModalVisible: false,
    isConfirmHereModalVisible: false,
    isShareEventModalVisible: false,
    isLoadingModalVisible: false,
    recordingMediaOptions: 'video',
    recordingAudioOptions: 'all',
    recordingVideoOptions: 'all',
    recordingVideoType: 'fullDisplay',
    recordingVideoOptimized: false,
    recordingDisplayType: 'video',
    recordingAddHLS: true,
    recordingNameTags: true,
    recordingBackgroundColor: '#83c0e9',
    recordingNameTagsColor: '#ffffff',
    recordingAddText: false,
    recordingCustomText: 'Add Text',
    recordingCustomTextPosition: 'top',
    recordingCustomTextColor: '#ffffff',
    recordingOrientationVideo: 'landscape',
    clearedToResume: true,
    clearedToRecord: true,
    recordState: 'green',
    showRecordButtons: false,
    recordingProgressTime: '00:00:00',
    audioSwitching: false,
    videoSwitching: false,
    videoAlreadyOn: false,
    audioAlreadyOn: false,
    componentSizes: { mainHeight: 0, otherHeight: 0, mainWidth: 0, otherWidth: 0 },
    hasCameraPermission: false,
    hasAudioPermission: false,
    transportCreated: false,
    transportCreatedVideo: false,
    transportCreatedAudio: false,
    transportCreatedScreen: false,
    producerTransport: null,
    videoProducer: null,
    params: {},
    videoParams: {},
    audioParams: {},
    audioProducer: null,
    consumerTransports: [],
    consumingTransports: [],
    // Polls
    polls: [],
    poll: null,
    isPollModalVisible: false,
    // Background
    customImage: '',
    selectedImage: '',
    segmentVideo: null,
    selfieSegmentation: null,
    pauseSegmentation: false,
    processedStream: null,
    keepBackground: false,
    backgroundHasChanged: false,
    virtualStream: null,
    mainCanvas: null,
    prevKeepBackground: false,
    appliedBackground: false,
    isBackgroundModalVisible: false,
    autoClickBackground: false,
    // Breakout Rooms
    breakoutRooms: [],
    currentRoomIndex: 0,
    canStartBreakout: false,
    breakOutRoomStarted: false,
    breakOutRoomEnded: false,
    hostNewRoom: -1,
    limitedBreakRoom: [],
    mainRoomsLength: 0,
    memberRoom: -1,
    isBreakoutRoomsModalVisible: false,
    // Whiteboard
    whiteboardUsers: [],
    currentWhiteboardIndex: 0,
    canStartWhiteboard: false,
    whiteboardStarted: false,
    whiteboardEnded: false,
    whiteboardLimit: 4,
    isWhiteboardModalVisible: false,
    isConfigureWhiteboardModalVisible: false,
    shapes: [],
    useImageBackground: true,
    redoStack: [],
    undoStack: [],
    canvasStream: null,
    canvasWhiteboard: null,
    // Screenboard
    canvasScreenboard: null,
    processedScreenStream: null,
    annotateScreenStream: false,
    mainScreenCanvas: null,
    isScreenboardModalVisible: false,
    // Control Buttons
    micActive: false,
    videoActive: false,
    screenShareActive: false,
    endCallActive: false,
    participantsActive: false,
    menuActive: false,
    commentsActive: false,
};

/**
 * Component representing a loading modal.
 *
 * @selector app-loading-modal
 * @standalone true
 * @imports CommonModule
 *
 * @description
 * This component displays a loading modal with a spinner and a loading text.
 * It is designed to be displayed as an overlay with customizable background and text colors.
 *
 * @example
 * <app-loading-modal [isVisible]="true" [backgroundColor]="'rgba(0, 0, 0, 0.5)'" [displayColor]="'white'"></app-loading-modal>
 *
 * @styles
 * - .spinner: Styles for the loading spinner.
 * - @keyframes spin: Keyframes for the spinner animation.
 * - .modal-content: Styles for the modal content container.
 * - .loading-text: Styles for the loading text.
 *
 * @inputs
 * - `isVisible` (boolean): Determines if the modal is visible. Default is `false`.
 * - `backgroundColor` (string): Background color of the modal. Default is `'rgba(0, 0, 0, 0.5)'`.
 * - `displayColor` (string): Color of the loading text. Default is `'white'`.
 *
 * @properties
 * - `modalContainerStyle` (object): Computed styles for the modal container.
 * - `modalContentStyle` (object): Computed styles for the modal content.
 * - `spinnerContainerStyle` (object): Computed styles for the spinner container.
 * - `loadingTextStyle` (object): Computed styles for the loading text.
 */
class LoadingModal {
    isVisible = false;
    backgroundColor = 'rgba(0, 0, 0, 0.5)';
    displayColor = 'white';
    get modalContainerStyle() {
        return {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: this.backgroundColor,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: '999',
        };
    }
    get modalContentStyle() {
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            maxWidth: '200px',
            textAlign: 'center',
        };
    }
    get spinnerContainerStyle() {
        return {
            marginBottom: '20px',
        };
    }
    get loadingTextStyle() {
        return {
            color: this.displayColor,
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LoadingModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: LoadingModal, isStandalone: true, selector: "app-loading-modal", inputs: { isVisible: "isVisible", backgroundColor: "backgroundColor", displayColor: "displayColor" }, ngImport: i0, template: `
    <div *ngIf="isVisible" [ngStyle]="modalContainerStyle">
      <div [ngStyle]="modalContentStyle" class="modal-content">
        <div class="spinner" [ngStyle]="spinnerContainerStyle"></div>
        <div [ngStyle]="loadingTextStyle" class="loading-text">Loading...</div>
      </div>
    </div>
  `, isInline: true, styles: [".spinner{border:12px solid #f3f3f3;border-top:12px solid black;border-radius:50%;width:50px;height:50px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.modal-content{display:flex;flex-direction:column;align-items:center}.loading-text{margin-top:10px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LoadingModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-loading-modal', standalone: true, imports: [CommonModule], template: `
    <div *ngIf="isVisible" [ngStyle]="modalContainerStyle">
      <div [ngStyle]="modalContentStyle" class="modal-content">
        <div class="spinner" [ngStyle]="spinnerContainerStyle"></div>
        <div [ngStyle]="loadingTextStyle" class="loading-text">Loading...</div>
      </div>
    </div>
  `, styles: [".spinner{border:12px solid #f3f3f3;border-top:12px solid black;border-radius:50%;width:50px;height:50px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.modal-content{display:flex;flex-direction:column;align-items:center}.loading-text{margin-top:10px}\n"] }]
        }], propDecorators: { isVisible: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], displayColor: [{
                type: Input
            }] } });

/**
 * MainAspectComponent is a standalone Angular component that adjusts its aspect ratio
 * based on the window size and other input properties. It listens to window resize
 * and orientation change events to dynamically update its styles.
 *
 * @selector app-main-aspect-component
 * @standalone true
 * @imports [CommonModule]
 *
 * @template
 * ```html
 * <div [ngStyle]="aspectStyles" [style.backgroundColor]="backgroundColor" class="aspect-container">
 *   <ng-content></ng-content>
 * </div>
 * ```
 *
 * @styles
 * ```css
 * .aspect-container {
 *   overflow: hidden;
 * }
 * ```
 *
 * @class MainAspectComponent
 * @implements OnInit, OnDestroy, OnChanges
 *
 * @property {string} backgroundColor - The background color of the aspect container.
 * @property {boolean} showControls - Flag to show or hide controls.
 * @property {number} containerWidthFraction - Fraction of the window width for the container.
 * @property {number} containerHeightFraction - Fraction of the window height for the container.
 * @property {number} defaultFraction - Default fraction to adjust the height when controls are shown.
 * @property {(isWideScreen: boolean) => void} updateIsWideScreen - Callback to update wide screen status.
 * @property {(isMediumScreen: boolean) => void} updateIsMediumScreen - Callback to update medium screen status.
 * @property {(isSmallScreen: boolean) => void} updateIsSmallScreen - Callback to update small screen status.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes.
 * @method ngOnDestroy - Lifecycle hook that is called just before the component is destroyed.
 * @method private updateAspectStyles - Updates the aspect styles based on the window size and input properties.
 */
class MainAspectComponent {
    backgroundColor = '';
    showControls = true;
    containerWidthFraction = 1;
    containerHeightFraction = 1;
    defaultFraction = 0.94;
    updateIsWideScreen;
    updateIsMediumScreen;
    updateIsSmallScreen;
    aspectStyles = {};
    ngOnInit() {
        this.updateAspectStyles();
        window.addEventListener('resize', this.updateAspectStyles);
        window.addEventListener('orientationchange', this.updateAspectStyles);
    }
    ngOnChanges(changes) {
        if (changes['showControls'] ||
            changes['containerWidthFraction'] ||
            changes['containerHeightFraction'] ||
            changes['defaultFraction']) {
            this.updateAspectStyles();
        }
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.updateAspectStyles);
        window.removeEventListener('orientationchange', this.updateAspectStyles);
    }
    updateAspectStyles = () => {
        const windowHeight = window.innerHeight;
        const windowWidth = window.innerWidth;
        const parentWidth = Math.floor(this.containerWidthFraction * windowWidth);
        const parentHeight = this.showControls
            ? Math.floor(this.containerHeightFraction * windowHeight * this.defaultFraction)
            : Math.floor(this.containerHeightFraction * windowHeight);
        let isWideScreen = parentWidth >= 768;
        const isMediumScreen = parentWidth >= 576 && parentWidth < 768;
        const isSmallScreen = parentWidth < 576;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        this.updateIsMediumScreen(isMediumScreen);
        this.updateIsSmallScreen(isSmallScreen);
        this.aspectStyles = {
            height: parentHeight + 'px',
            width: parentWidth + 'px',
        };
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MainAspectComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MainAspectComponent, isStandalone: true, selector: "app-main-aspect-component", inputs: { backgroundColor: "backgroundColor", showControls: "showControls", containerWidthFraction: "containerWidthFraction", containerHeightFraction: "containerHeightFraction", defaultFraction: "defaultFraction", updateIsWideScreen: "updateIsWideScreen", updateIsMediumScreen: "updateIsMediumScreen", updateIsSmallScreen: "updateIsSmallScreen" }, usesOnChanges: true, ngImport: i0, template: `
    <div
      [ngStyle]="aspectStyles"
      [style.backgroundColor]="backgroundColor"
      class="aspect-container"
    >
      <ng-content></ng-content>
    </div>
  `, isInline: true, styles: [".aspect-container{overflow:hidden}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MainAspectComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-main-aspect-component', standalone: true, imports: [CommonModule], template: `
    <div
      [ngStyle]="aspectStyles"
      [style.backgroundColor]="backgroundColor"
      class="aspect-container"
    >
      <ng-content></ng-content>
    </div>
  `, styles: [".aspect-container{overflow:hidden}\n"] }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], showControls: [{
                type: Input
            }], containerWidthFraction: [{
                type: Input
            }], containerHeightFraction: [{
                type: Input
            }], defaultFraction: [{
                type: Input
            }], updateIsWideScreen: [{
                type: Input
            }], updateIsMediumScreen: [{
                type: Input
            }], updateIsSmallScreen: [{
                type: Input
            }] } });

class ControlButtonsComponent {
    buttons = [];
    buttonColor = '';
    buttonBackgroundColor = {};
    alignment = 'flex-start';
    vertical = false;
    buttonsContainerStyle = {};
    // Function to get the alignment styles dynamically
    getAlignmentStyle() {
        const alignmentMap = {
            center: { 'justify-content': 'center' },
            'flex-end': { 'justify-content': 'flex-end' },
            'space-between': { 'justify-content': 'space-between' },
            'space-around': { 'justify-content': 'space-around' },
            'space-evenly': { 'justify-content': 'space-evenly' },
            'flex-start': { 'justify-content': 'flex-start' },
        };
        return {
            display: 'flex',
            flexDirection: this.vertical ? 'column' : 'row',
            ...alignmentMap[this.alignment],
        };
    }
    // Utility function to merge multiple styles into one object
    mergeStyles(...styles) {
        return Object.assign({}, ...styles);
    }
    isCustomComponent(comp) {
        return (comp &&
            typeof comp === 'object' &&
            'component' in comp &&
            typeof comp.component === 'function' &&
            'injector' in comp);
    }
    isFunctionComponent(comp) {
        return typeof comp === 'function';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlButtonsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ControlButtonsComponent, isStandalone: true, selector: "app-control-buttons-component", inputs: { buttons: "buttons", buttonColor: "buttonColor", buttonBackgroundColor: "buttonBackgroundColor", alignment: "alignment", vertical: "vertical", buttonsContainerStyle: "buttonsContainerStyle" }, ngImport: i0, template: `
    <div class="container" [ngStyle]="mergeStyles(getAlignmentStyle(), buttonsContainerStyle)">
      <button
        *ngFor="let button of buttons; let i = index"
        class="buttonContainer"
        [ngClass]="{ verticalButton: vertical }"
        [ngStyle]="{
          'background-color': button.show
            ? buttonBackgroundColor?.default || 'transparent'
            : 'transparent',
          display: button.show ? 'flex' : 'none'
        }"
        [disabled]="button.disabled"
        (click)="button.onPress ? button.onPress() : null"
      >
        <!-- Custom component when defined -->
        <ng-container *ngIf="button.customComponent; else iconTemplate">
          <ng-container *ngIf="isCustomComponent(button.customComponent)">
            <ng-container
              *ngComponentOutlet="
                button.customComponent.component;
                injector: button.customComponent.injector
              "
            ></ng-container>
          </ng-container>
          <ng-container
            *ngIf="
              !isCustomComponent(button.customComponent) &&
              !isFunctionComponent(button.customComponent)
            "
          >
            <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
            <div [innerHTML]="button.customComponent.outerHTML"></div>
          </ng-container>
        </ng-container>

        <!-- Icon logic for active/inactive states -->
        <ng-template #iconTemplate>
          <ng-container *ngIf="button.active && button.alternateIconComponent; else defaultIcon">
            <!-- Alternate icon component when button is active -->
            <ng-container *ngIf="isCustomComponent(button.alternateIconComponent)">
              <ng-container
                *ngComponentOutlet="
                  button.alternateIconComponent.component;
                  injector: button.alternateIconComponent.injector
                "
              ></ng-container>
            </ng-container>
            <ng-container
              *ngIf="
                !isCustomComponent(button.alternateIconComponent) &&
                !isFunctionComponent(button.alternateIconComponent)
              "
            >
              <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
              <div [innerHTML]="button.alternateIconComponent.outerHTML"></div>
            </ng-container>
          </ng-container>

          <!-- Default icon fallback for active/inactive states -->
          <ng-template #defaultIcon>
            <fa-icon
              *ngIf="button.active"
              [icon]="button.alternateIcon! || button.icon"
              [style.color]="button.activeColor || 'transparent'"
            ></fa-icon>
            <fa-icon
              *ngIf="!button.active"
              [icon]="button.icon!"
              [style.color]="button.inActiveColor || '#ffffff'"
            ></fa-icon>
          </ng-template>
        </ng-template>

        <!-- Button text -->
        <span
          *ngIf="button.name"
          class="buttonText"
          [ngStyle]="{ color: button.color || '#ffffff' }"
        >
          {{ button.name }}
        </span>
      </button>
    </div>
  `, isInline: true, styles: [".container{display:flex;width:100%;flex-direction:row;margin-top:0}.buttonContainer{display:flex;align-items:center;justify-content:center;padding:8px;border-radius:5px;margin-right:4px;font-size:medium;border:none}.buttonContainer:hover{cursor:pointer}.verticalButton{flex-direction:column}.buttonText{font-size:12px;margin-top:5px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlButtonsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-control-buttons-component', standalone: true, imports: [CommonModule, FontAwesomeModule], template: `
    <div class="container" [ngStyle]="mergeStyles(getAlignmentStyle(), buttonsContainerStyle)">
      <button
        *ngFor="let button of buttons; let i = index"
        class="buttonContainer"
        [ngClass]="{ verticalButton: vertical }"
        [ngStyle]="{
          'background-color': button.show
            ? buttonBackgroundColor?.default || 'transparent'
            : 'transparent',
          display: button.show ? 'flex' : 'none'
        }"
        [disabled]="button.disabled"
        (click)="button.onPress ? button.onPress() : null"
      >
        <!-- Custom component when defined -->
        <ng-container *ngIf="button.customComponent; else iconTemplate">
          <ng-container *ngIf="isCustomComponent(button.customComponent)">
            <ng-container
              *ngComponentOutlet="
                button.customComponent.component;
                injector: button.customComponent.injector
              "
            ></ng-container>
          </ng-container>
          <ng-container
            *ngIf="
              !isCustomComponent(button.customComponent) &&
              !isFunctionComponent(button.customComponent)
            "
          >
            <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
            <div [innerHTML]="button.customComponent.outerHTML"></div>
          </ng-container>
        </ng-container>

        <!-- Icon logic for active/inactive states -->
        <ng-template #iconTemplate>
          <ng-container *ngIf="button.active && button.alternateIconComponent; else defaultIcon">
            <!-- Alternate icon component when button is active -->
            <ng-container *ngIf="isCustomComponent(button.alternateIconComponent)">
              <ng-container
                *ngComponentOutlet="
                  button.alternateIconComponent.component;
                  injector: button.alternateIconComponent.injector
                "
              ></ng-container>
            </ng-container>
            <ng-container
              *ngIf="
                !isCustomComponent(button.alternateIconComponent) &&
                !isFunctionComponent(button.alternateIconComponent)
              "
            >
              <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
              <div [innerHTML]="button.alternateIconComponent.outerHTML"></div>
            </ng-container>
          </ng-container>

          <!-- Default icon fallback for active/inactive states -->
          <ng-template #defaultIcon>
            <fa-icon
              *ngIf="button.active"
              [icon]="button.alternateIcon! || button.icon"
              [style.color]="button.activeColor || 'transparent'"
            ></fa-icon>
            <fa-icon
              *ngIf="!button.active"
              [icon]="button.icon!"
              [style.color]="button.inActiveColor || '#ffffff'"
            ></fa-icon>
          </ng-template>
        </ng-template>

        <!-- Button text -->
        <span
          *ngIf="button.name"
          class="buttonText"
          [ngStyle]="{ color: button.color || '#ffffff' }"
        >
          {{ button.name }}
        </span>
      </button>
    </div>
  `, styles: [".container{display:flex;width:100%;flex-direction:row;margin-top:0}.buttonContainer{display:flex;align-items:center;justify-content:center;padding:8px;border-radius:5px;margin-right:4px;font-size:medium;border:none}.buttonContainer:hover{cursor:pointer}.verticalButton{flex-direction:column}.buttonText{font-size:12px;margin-top:5px}\n"] }]
        }], propDecorators: { buttons: [{
                type: Input
            }], buttonColor: [{
                type: Input
            }], buttonBackgroundColor: [{
                type: Input
            }], alignment: [{
                type: Input
            }], vertical: [{
                type: Input
            }], buttonsContainerStyle: [{
                type: Input
            }] } });

class ControlButtonsAltComponent {
    buttons = [];
    position = 'left';
    location = 'top';
    direction = 'horizontal';
    buttonsContainerStyle = {};
    showAspect = false;
    getAlignmentStyle() {
        let alignmentStyle = {};
        if (this.position === 'left' || this.position === 'right' || this.position === 'middle') {
            alignmentStyle.justifyContent =
                this.position === 'left' ? 'flex-start' : this.position === 'right' ? 'flex-end' : 'center';
        }
        if (this.location === 'top' || this.location === 'bottom' || this.location === 'center') {
            alignmentStyle.alignItems =
                this.location === 'top' ? 'flex-start' : this.location === 'bottom' ? 'flex-end' : 'center';
        }
        alignmentStyle.flexDirection = this.direction === 'vertical' ? 'column' : 'row';
        return alignmentStyle;
    }
    getContainerStyle() {
        return {
            ...this.styles.container,
            ...this.getAlignmentStyle(),
            ...this.buttonsContainerStyle,
            display: this.showAspect ? 'flex' : 'none',
        };
    }
    getButtonStyle(button) {
        return {
            ...this.styles.buttonContainer,
            backgroundColor: button.backgroundColor?.default || 'transparent',
            ...(this.direction === 'vertical' ? this.styles.verticalButton : {}),
        };
    }
    getTextStyle(button) {
        return {
            ...this.styles.buttonText,
            color: button.color || '#ffffff',
        };
    }
    isCustomComponent(comp) {
        return (comp &&
            typeof comp === 'object' &&
            'component' in comp &&
            typeof comp.component === 'function' &&
            'injector' in comp);
    }
    isFunctionComponent(comp) {
        return typeof comp === 'function';
    }
    styles = {
        container: {
            marginTop: '5px',
            marginBottom: '5px',
            zIndex: 9,
        },
        buttonContainer: {
            display: 'flex',
            alignItems: 'center',
            padding: '10px',
            borderRadius: '5px',
            marginLeft: '5px',
            marginRight: '5px',
            cursor: 'pointer',
        },
        verticalButton: {
            flexDirection: 'column',
        },
        buttonText: {
            fontSize: '12px',
            marginTop: '5px',
        },
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlButtonsAltComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ControlButtonsAltComponent, isStandalone: true, selector: "app-control-buttons-alt-component", inputs: { buttons: "buttons", position: "position", location: "location", direction: "direction", buttonsContainerStyle: "buttonsContainerStyle", showAspect: "showAspect" }, ngImport: i0, template: "<div [ngStyle]=\"getContainerStyle()\">\r\n  <div\r\n    *ngFor=\"let button of buttons; let i = index\"\r\n    [ngStyle]=\"getButtonStyle(button)\"\r\n    (click)=\"button.onPress && button.onPress()\"\r\n  >\r\n    <ng-container *ngIf=\"button.icon\">\r\n      <fa-icon\r\n        *ngIf=\"button.active\"\r\n        [icon]=\"button.alternateIcon || button.icon\"\r\n        [style.color]=\"button.inActiveColor || 'transparent'\"\r\n      ></fa-icon>\r\n      <fa-icon\r\n        *ngIf=\"!button.active\"\r\n        [icon]=\"button.icon\"\r\n        [style.color]=\"button.inActiveColor || 'transparent'\"\r\n      ></fa-icon>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"!button.icon\">\r\n      <ng-container *ngIf=\"button.customComponent\">\r\n        <ng-container *ngIf=\"isCustomComponent(button.customComponent)\">\r\n          <ng-container\r\n            *ngComponentOutlet=\"\r\n              button.customComponent.component;\r\n              injector: button.customComponent.injector\r\n            \"\r\n          ></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!isCustomComponent(button.customComponent) && !isFunctionComponent(button.customComponent)\">\r\n          <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->\r\n          <div [innerHTML]=\"button.customComponent.outerHTML\"></div>\r\n        </ng-container>\r\n      </ng-container>\r\n    </ng-container>\r\n    <span *ngIf=\"button.name\" [ngStyle]=\"getTextStyle(button)\">{{\r\n      button.name\r\n    }}</span>\r\n  </div>\r\n</div>\r\n", styles: [".container{margin-top:5px;margin-bottom:5px;z-index:9}.buttonContainer{display:flex;align-items:center;padding:10px;border-radius:5px;margin-left:5px;margin-right:5px;cursor:pointer}.verticalButton{flex-direction:column}.buttonText{font-size:12px;margin-top:5px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlButtonsAltComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-control-buttons-alt-component', standalone: true, imports: [CommonModule, FontAwesomeModule], template: "<div [ngStyle]=\"getContainerStyle()\">\r\n  <div\r\n    *ngFor=\"let button of buttons; let i = index\"\r\n    [ngStyle]=\"getButtonStyle(button)\"\r\n    (click)=\"button.onPress && button.onPress()\"\r\n  >\r\n    <ng-container *ngIf=\"button.icon\">\r\n      <fa-icon\r\n        *ngIf=\"button.active\"\r\n        [icon]=\"button.alternateIcon || button.icon\"\r\n        [style.color]=\"button.inActiveColor || 'transparent'\"\r\n      ></fa-icon>\r\n      <fa-icon\r\n        *ngIf=\"!button.active\"\r\n        [icon]=\"button.icon\"\r\n        [style.color]=\"button.inActiveColor || 'transparent'\"\r\n      ></fa-icon>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"!button.icon\">\r\n      <ng-container *ngIf=\"button.customComponent\">\r\n        <ng-container *ngIf=\"isCustomComponent(button.customComponent)\">\r\n          <ng-container\r\n            *ngComponentOutlet=\"\r\n              button.customComponent.component;\r\n              injector: button.customComponent.injector\r\n            \"\r\n          ></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!isCustomComponent(button.customComponent) && !isFunctionComponent(button.customComponent)\">\r\n          <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->\r\n          <div [innerHTML]=\"button.customComponent.outerHTML\"></div>\r\n        </ng-container>\r\n      </ng-container>\r\n    </ng-container>\r\n    <span *ngIf=\"button.name\" [ngStyle]=\"getTextStyle(button)\">{{\r\n      button.name\r\n    }}</span>\r\n  </div>\r\n</div>\r\n", styles: [".container{margin-top:5px;margin-bottom:5px;z-index:9}.buttonContainer{display:flex;align-items:center;padding:10px;border-radius:5px;margin-left:5px;margin-right:5px;cursor:pointer}.verticalButton{flex-direction:column}.buttonText{font-size:12px;margin-top:5px}\n"] }]
        }], propDecorators: { buttons: [{
                type: Input
            }], position: [{
                type: Input
            }], location: [{
                type: Input
            }], direction: [{
                type: Input
            }], buttonsContainerStyle: [{
                type: Input
            }], showAspect: [{
                type: Input
            }] } });

/**
 * ControlButtonsComponentTouch is an Angular component that displays a set of control buttons.
 * The buttons can be customized with various styles, icons, and actions.
 *
 * @component
 * @selector app-control-buttons-component-touch
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule]
 *
 * @template
 * The template includes a container div that holds the buttons. Each button can display an icon,
 * a custom component, or a name. The styles and visibility of the buttons are controlled by the
 * component's inputs.
 *
 * @styles
 * The host element is styled to be a flex container centered both horizontally and vertically.
 *
 * @class ControlButtonsComponentTouch
 *
 * @property {any[]} buttons - An array of button configurations. Each button can have properties like
 * `show`, `backgroundColor`, `onPress`, `icon`, `alternateIcon`, `active`, `activeColor`, `inActiveColor`,
 * `customComponent`, and `name`.
 *
 * @property {string} position - The horizontal alignment of the buttons container. Can be 'left', 'right', or 'middle'.
 * Default is 'left'.
 *
 * @property {string} location - The vertical alignment of the buttons container. Can be 'top', 'bottom', or 'center'.
 * Default is 'top'.
 *
 * @property {string} direction - The direction of the buttons layout. Can be 'horizontal' or 'vertical'.
 * Default is 'horizontal'.
 *
 * @property {any} buttonsContainerStyle - Additional styles for the buttons container.
 *
 * @property {boolean} showAspect - A flag to control the visibility of the buttons container.
 *
 * @method getAlignmentStyle
 * Returns the alignment styles based on the `position`, `location`, and `direction` inputs.
 *
 * @method mergeStyles
 * Merges multiple style objects into one.
 *
 * @example
 * <app-control-buttons-component-touch
 *   [buttons]="buttonsArray"
 *   position="right"
 *   location="bottom"
 *   direction="vertical"
 *   [buttonsContainerStyle]="customStyles"
 *   [showAspect]="true">
 * </app-control-buttons-component-touch>
 */
class ControlButtonsComponentTouch {
    buttons = [];
    position = 'left';
    location = 'top';
    direction = 'horizontal';
    buttonsContainerStyle = {};
    showAspect = false;
    getAlignmentStyle() {
        let alignmentStyle = {};
        if (this.position === 'left' || this.position === 'right' || this.position === 'middle') {
            alignmentStyle['justify-content'] =
                this.position === 'left' ? 'flex-start' : this.position === 'right' ? 'flex-end' : 'center';
        }
        if (this.location === 'top' || this.location === 'bottom' || this.location === 'center') {
            alignmentStyle['align-items'] =
                this.location === 'top' ? 'flex-start' : this.location === 'bottom' ? 'flex-end' : 'center';
        }
        if (this.direction === 'vertical') {
            alignmentStyle['flex-direction'] = 'column';
        }
        else {
            alignmentStyle['flex-direction'] = 'row';
        }
        return alignmentStyle;
    }
    mergeStyles(...styles) {
        return Object.assign({}, ...styles);
    }
    isCustomComponent(comp) {
        return (comp &&
            typeof comp === 'object' &&
            'component' in comp &&
            typeof comp.component === 'function' &&
            'injector' in comp);
    }
    isFunctionComponent(comp) {
        return typeof comp === 'function';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlButtonsComponentTouch, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ControlButtonsComponentTouch, isStandalone: true, selector: "app-control-buttons-component-touch", inputs: { buttons: "buttons", position: "position", location: "location", direction: "direction", buttonsContainerStyle: "buttonsContainerStyle", showAspect: "showAspect" }, ngImport: i0, template: `
    <div
      [ngStyle]="
        mergeStyles(getAlignmentStyle(), buttonsContainerStyle, {
          position: 'absolute',
          bottom: '0',
          left: '0',
          right: '0',
          'margin-top': '5px',
          'margin-bottom': '5px',
          elevation: '9',
          'z-index': '9',
          'background-color': 'transparent',
          display: showAspect ? 'flex' : 'none'
        })
      "
    >
      <button
        *ngFor="let button of buttons"
        [ngStyle]="
          mergeStyles(
            {
              'align-items': 'center',
              padding: '10px',
              'border-radius': '5px',
              'margin-right': '5px',
              'margin-left': '5px',
              'margin-bottom': '5px',
              'margin-top': '5px',
              cursor: 'pointer',
              'background-color': button.show
                ? button.backgroundColor?.default || 'rgba(255, 255, 255, 0.25)'
                : 'transparent',
              border: 'none',
              display: button.show
                ? 'flex'
                : button.inActiveColor === 'transparent' && button.activeColor === 'transparent'
                ? 'flex'
                : 'none'
            },
            direction === 'vertical' ? { 'flex-direction': 'column' } : {}
          )
        "
        (click)="button.onPress ? button.onPress() : null"
        [disabled]="button.disabled"
      >
        <ng-container *ngIf="button.icon">
          <fa-icon
            *ngIf="button.active"
            [icon]="button.alternateIcon || button.icon"
            [style.color]="button.activeColor || 'transparent'"
          ></fa-icon>
          <fa-icon
            *ngIf="!button.active"
            [icon]="button.icon"
            [style.color]="button.inActiveColor || 'transparent'"
          ></fa-icon>
        </ng-container>
        <ng-container *ngIf="!button.icon">
          <ng-container *ngIf="button.customComponent">
            <ng-container *ngIf="isCustomComponent(button.customComponent)">
              <ng-container
                *ngComponentOutlet="
                  button.customComponent.component;
                  injector: button.customComponent.injector
                "
              ></ng-container>
            </ng-container>
            <ng-container
              *ngIf="
                !isCustomComponent(button.customComponent) &&
                !isFunctionComponent(button.customComponent)
              "
            >
              <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
              <div [innerHTML]="button.customComponent.outerHTML"></div>
            </ng-container>
          </ng-container>
        </ng-container>
        <span
          *ngIf="button.name"
          [ngStyle]="{
            color: button.color || 'transparent',
            'font-size': '12px',
            'margin-top': '5px'
          }"
        >
          {{ button.name }}
        </span>
      </button>
    </div>
  `, isInline: true, styles: [":host{display:flex;justify-content:center;align-items:center}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlButtonsComponentTouch, decorators: [{
            type: Component,
            args: [{ selector: 'app-control-buttons-component-touch', standalone: true, imports: [CommonModule, FontAwesomeModule], template: `
    <div
      [ngStyle]="
        mergeStyles(getAlignmentStyle(), buttonsContainerStyle, {
          position: 'absolute',
          bottom: '0',
          left: '0',
          right: '0',
          'margin-top': '5px',
          'margin-bottom': '5px',
          elevation: '9',
          'z-index': '9',
          'background-color': 'transparent',
          display: showAspect ? 'flex' : 'none'
        })
      "
    >
      <button
        *ngFor="let button of buttons"
        [ngStyle]="
          mergeStyles(
            {
              'align-items': 'center',
              padding: '10px',
              'border-radius': '5px',
              'margin-right': '5px',
              'margin-left': '5px',
              'margin-bottom': '5px',
              'margin-top': '5px',
              cursor: 'pointer',
              'background-color': button.show
                ? button.backgroundColor?.default || 'rgba(255, 255, 255, 0.25)'
                : 'transparent',
              border: 'none',
              display: button.show
                ? 'flex'
                : button.inActiveColor === 'transparent' && button.activeColor === 'transparent'
                ? 'flex'
                : 'none'
            },
            direction === 'vertical' ? { 'flex-direction': 'column' } : {}
          )
        "
        (click)="button.onPress ? button.onPress() : null"
        [disabled]="button.disabled"
      >
        <ng-container *ngIf="button.icon">
          <fa-icon
            *ngIf="button.active"
            [icon]="button.alternateIcon || button.icon"
            [style.color]="button.activeColor || 'transparent'"
          ></fa-icon>
          <fa-icon
            *ngIf="!button.active"
            [icon]="button.icon"
            [style.color]="button.inActiveColor || 'transparent'"
          ></fa-icon>
        </ng-container>
        <ng-container *ngIf="!button.icon">
          <ng-container *ngIf="button.customComponent">
            <ng-container *ngIf="isCustomComponent(button.customComponent)">
              <ng-container
                *ngComponentOutlet="
                  button.customComponent.component;
                  injector: button.customComponent.injector
                "
              ></ng-container>
            </ng-container>
            <ng-container
              *ngIf="
                !isCustomComponent(button.customComponent) &&
                !isFunctionComponent(button.customComponent)
              "
            >
              <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
              <div [innerHTML]="button.customComponent.outerHTML"></div>
            </ng-container>
          </ng-container>
        </ng-container>
        <span
          *ngIf="button.name"
          [ngStyle]="{
            color: button.color || 'transparent',
            'font-size': '12px',
            'margin-top': '5px'
          }"
        >
          {{ button.name }}
        </span>
      </button>
    </div>
  `, styles: [":host{display:flex;justify-content:center;align-items:center}\n"] }]
        }], propDecorators: { buttons: [{
                type: Input
            }], position: [{
                type: Input
            }], location: [{
                type: Input
            }], direction: [{
                type: Input
            }], buttonsContainerStyle: [{
                type: Input
            }], showAspect: [{
                type: Input
            }] } });

/**
 * Component to display a meeting progress timer.
 *s
 * @selector app-meeting-progress-timer
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * ```html
 * <div [ngStyle]="positions[position]" class="badge-container">
 *   <div [ngStyle]="{ backgroundColor: initialBackgroundColor, display: showTimer ? 'block' : 'none' }" class="progress-timer">
 *     <span [ngStyle]="textStyle" class="progress-timer-text">{{ meetingProgressTime }}</span>
 *   </div>
 * </div>
 * ```
 *
 * @styles
 * ```css
 * .badge-container {
 *   padding: 5px;
 *   position: relative;
 *   z-index: 1000;
 * }
 * .progress-timer {
 *   background-color: green;
 *   padding: 5px;
 *   border-radius: 5px;
 *   color: white;
 * }
 * .progress-timer-text {
 *   color: black;
 * }
 * ```
 *
 * @class MeetingProgressTimer
 * @implements OnInit, OnChanges
 *
 * @property {string} meetingProgressTime - The time to be displayed in the timer.
 * @property {string} [initialBackgroundColor='green'] - The initial background color of the timer.
 * @property {'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight'} [position='topLeft'] - The position of the timer on the screen.
 * @property {{ [key: string]: string | number }} [textStyle={}] - The style to be applied to the timer text.
 * @property {boolean} [showTimer=true] - Flag to show or hide the timer.
 *
 * @property {{ [key: string]: { position: string, top?: string, bottom?: string, left?: string, right?: string } }} positions - The possible positions for the timer.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property of a directive changes.
 * @param {SimpleChanges} changes - The changed properties.
 */
class MeetingProgressTimer {
    meetingProgressTime;
    initialBackgroundColor = 'green';
    position = 'topLeft';
    textStyle = {};
    showTimer = true;
    positions = {
        topLeft: { position: 'absolute', top: '0', left: '0' },
        topRight: { position: 'absolute', top: '0', right: '0' },
        bottomLeft: { position: 'absolute', bottom: '0', left: '0' },
        bottomRight: { position: 'absolute', bottom: '0', right: '0' },
    };
    ngOnChanges(changes) {
        if (changes['position']) {
            this.positions = {
                topLeft: { position: 'absolute', top: '0', left: '0' },
                topRight: { position: 'absolute', top: '0', right: '0' },
                bottomLeft: { position: 'absolute', bottom: '0', left: '0' },
                bottomRight: { position: 'absolute', bottom: '0', right: '0' },
            };
        }
        if (changes['showTimer']) {
            this.showTimer = changes['showTimer'].currentValue;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingProgressTimer, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MeetingProgressTimer, isStandalone: true, selector: "app-meeting-progress-timer", inputs: { meetingProgressTime: "meetingProgressTime", initialBackgroundColor: "initialBackgroundColor", position: "position", textStyle: "textStyle", showTimer: "showTimer" }, usesOnChanges: true, ngImport: i0, template: `
    <div [ngStyle]="positions[position]" class="badge-container">
      <div
        [ngStyle]="{
          backgroundColor: initialBackgroundColor,
          display: showTimer ? 'block' : 'none'
        }"
        class="progress-timer"
      >
        <span [ngStyle]="textStyle" class="progress-timer-text">{{ meetingProgressTime }}</span>
      </div>
    </div>
  `, isInline: true, styles: [".badge-container{padding:5px;position:relative;z-index:1000}.progress-timer{background-color:green;padding:5px;border-radius:5px;color:#fff}.progress-timer-text{color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingProgressTimer, decorators: [{
            type: Component,
            args: [{ selector: 'app-meeting-progress-timer', standalone: true, imports: [CommonModule], template: `
    <div [ngStyle]="positions[position]" class="badge-container">
      <div
        [ngStyle]="{
          backgroundColor: initialBackgroundColor,
          display: showTimer ? 'block' : 'none'
        }"
        class="progress-timer"
      >
        <span [ngStyle]="textStyle" class="progress-timer-text">{{ meetingProgressTime }}</span>
      </div>
    </div>
  `, styles: [".badge-container{padding:5px;position:relative;z-index:1000}.progress-timer{background-color:green;padding:5px;border-radius:5px;color:#fff}.progress-timer-text{color:#000}\n"] }]
        }], propDecorators: { meetingProgressTime: [{
                type: Input
            }], initialBackgroundColor: [{
                type: Input
            }], position: [{
                type: Input
            }], textStyle: [{
                type: Input
            }], showTimer: [{
                type: Input
            }] } });

/**
 * Component representing a customizable grid with an optional timer.
 *
 * @selector app-other-grid-component
 * @standalone true
 * @imports CommonModule, MeetingProgressTimer
 *
 * @template
 * <div [ngStyle]="{...}">
 *   <app-meeting-progress-timer *ngIf="showTimer" [meetingProgressTime]="meetingProgressTime" [initialBackgroundColor]="timeBackgroundColor" [showTimer]="showTimer"></app-meeting-progress-timer>
 *   <ng-content></ng-content>
 * </div>
 *
 * @class OtherGridComponent
 *
 * @property {string} backgroundColor - The background color of the grid. Default is 'transparent'.
 * @property {number} width - The width of the grid in pixels. Default is 0.
 * @property {number} height - The height of the grid in pixels. Default is 0.
 * @property {boolean} showAspect - Flag to show or hide the grid. Default is true.
 * @property {string} timeBackgroundColor - The background color of the timer. Default is 'green'.
 * @property {boolean} showTimer - Flag to show or hide the timer. Default is false.
 * @property {string} meetingProgressTime - The meeting progress time to be displayed in the timer. Default is '00:00:00'.
 */
class OtherGridComponent {
    backgroundColor = 'transparent';
    width = 0;
    height = 0;
    showAspect = true;
    timeBackgroundColor = 'green';
    showTimer = false;
    meetingProgressTime = '00:00:00';
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: OtherGridComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: OtherGridComponent, isStandalone: true, selector: "app-other-grid-component", inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", showAspect: "showAspect", timeBackgroundColor: "timeBackgroundColor", showTimer: "showTimer", meetingProgressTime: "meetingProgressTime" }, ngImport: i0, template: `
    <div
      [ngStyle]="{
        'background-color': backgroundColor,
        width: width + 'px',
        height: height + 'px',
        display: showAspect ? 'block' : 'none',
        overflow: 'hidden',
        'border-style': 'solid',
        'border-color': 'black',
        'border-width': '2px',
        'border-radius': '0',
        margin: '0',
        padding: '0'
      }"
    >
      <app-meeting-progress-timer
        *ngIf="showTimer"
        [meetingProgressTime]="meetingProgressTime"
        [initialBackgroundColor]="timeBackgroundColor"
        [showTimer]="showTimer"
      ></app-meeting-progress-timer>
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: MeetingProgressTimer, selector: "app-meeting-progress-timer", inputs: ["meetingProgressTime", "initialBackgroundColor", "position", "textStyle", "showTimer"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: OtherGridComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-other-grid-component',
                    standalone: true,
                    imports: [CommonModule, MeetingProgressTimer],
                    template: `
    <div
      [ngStyle]="{
        'background-color': backgroundColor,
        width: width + 'px',
        height: height + 'px',
        display: showAspect ? 'block' : 'none',
        overflow: 'hidden',
        'border-style': 'solid',
        'border-color': 'black',
        'border-width': '2px',
        'border-radius': '0',
        margin: '0',
        padding: '0'
      }"
    >
      <app-meeting-progress-timer
        *ngIf="showTimer"
        [meetingProgressTime]="meetingProgressTime"
        [initialBackgroundColor]="timeBackgroundColor"
        [showTimer]="showTimer"
      ></app-meeting-progress-timer>
      <ng-content></ng-content>
    </div>
  `,
                }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], width: [{
                type: Input
            }], height: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], timeBackgroundColor: [{
                type: Input
            }], showTimer: [{
                type: Input
            }], meetingProgressTime: [{
                type: Input
            }] } });

/**
 * MainScreenComponent is responsible for displaying a main screen with dynamic dimensions
 * and layout based on the input properties and screen size.
 *
 * @selector app-main-screen-component
 * @standalone true
 * @imports CommonModule
 *
 * @property {number} mainSize - The size of the main component as a percentage.
 * @property {boolean} doStack - Determines if the components should be stacked.
 * @property {number} containerWidthFraction - Fraction of the container width.
 * @property {number} containerHeightFraction - Fraction of the container height.
 * @property {number} defaultFraction - Default fraction for height calculation.
 * @property {boolean} showControls - Flag to show or hide controls.
 * @property {(sizes: ComponentSizes) => void} updateComponentSizes - Callback to update component sizes.
 *
 * @ContentChildren('child') children - Query list of child elements.
 *
 * @property {number} parentWidth - The width of the parent container.
 * @property {number} parentHeight - The height of the parent container.
 * @property {boolean} isWideScreen - Flag to determine if the screen is wide.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnDestroy - Lifecycle hook that is called when the component is destroyed.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes.
 * @method ngAfterViewInit - Lifecycle hook that is called after the component's view has been fully initialized.
 * @method computeDimensions - Computes the dimensions of the main and other components based on the input properties.
 * @method updateDimensions - Updates the dimensions of the parent container and child components.
 * @method get containerStyle - Returns the style object for the container.
 * @method applyChildStyles - Applies the computed styles to the child components.
 */
class MainScreenComponent {
    renderer;
    mainSize = 40; // percentage
    doStack = true;
    containerWidthFraction = 1;
    containerHeightFraction = 1;
    defaultFraction = 0.94;
    showControls = true;
    updateComponentSizes = (sizes) => {
        console.log(sizes);
    };
    children;
    parentWidth;
    parentHeight;
    isWideScreen;
    constructor(renderer) {
        this.renderer = renderer;
    }
    ngOnInit() {
        this.updateDimensions();
        window.addEventListener('resize', this.updateDimensions);
        window.addEventListener('orientationchange', this.updateDimensions);
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.updateDimensions);
        window.removeEventListener('orientationchange', this.updateDimensions);
    }
    ngOnChanges(changes) {
        if (changes['mainSize'] ||
            changes['doStack'] ||
            changes['parentWidth'] ||
            changes['parentHeight'] ||
            changes['showControls'] ||
            changes['defaultFraction']) {
            this.updateDimensions();
        }
    }
    ngAfterViewInit() {
        this.applyChildStyles();
    }
    computeDimensions() {
        if (this.doStack) {
            return this.isWideScreen
                ? {
                    mainHeight: Math.floor(this.parentHeight),
                    otherHeight: Math.floor(this.parentHeight),
                    mainWidth: Math.floor((this.mainSize / 100) * this.parentWidth),
                    otherWidth: Math.floor(((100 - this.mainSize) / 100) * this.parentWidth),
                }
                : {
                    mainHeight: Math.floor((this.mainSize / 100) * this.parentHeight),
                    otherHeight: Math.floor(((100 - this.mainSize) / 100) * this.parentHeight),
                    mainWidth: Math.floor(this.parentWidth),
                    otherWidth: Math.floor(this.parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(this.parentHeight),
                otherHeight: Math.floor(this.parentHeight),
                mainWidth: Math.floor(this.parentWidth),
                otherWidth: Math.floor(this.parentWidth),
            };
        }
    }
    updateDimensions = () => {
        this.parentWidth = window.innerWidth * this.containerWidthFraction;
        this.parentHeight = this.showControls
            ? window.innerHeight * this.containerHeightFraction * this.defaultFraction
            : window.innerHeight * this.containerHeightFraction;
        this.isWideScreen = this.parentWidth >= 768;
        if (!this.isWideScreen && this.parentWidth > 1.5 * this.parentHeight) {
            this.isWideScreen = true;
        }
        const { mainHeight, otherHeight, mainWidth, otherWidth } = this.computeDimensions();
        this.updateComponentSizes({ mainHeight, otherHeight, mainWidth, otherWidth });
        this.applyChildStyles();
    };
    get containerStyle() {
        return {
            display: 'flex',
            flex: 1,
            flexDirection: this.isWideScreen ? 'row' : 'column',
            width: `${this.parentWidth}px`,
            height: `${this.parentHeight}px`,
            padding: 0,
            margin: 0,
        };
    }
    applyChildStyles() {
        if (this.children) {
            const { mainHeight, otherHeight, mainWidth, otherWidth } = this.computeDimensions();
            this.children.forEach((child, index) => {
                const childStyle = this.doStack
                    ? {
                        height: index === 0 ? mainHeight : otherHeight,
                        width: index === 0 ? mainWidth : otherWidth,
                    }
                    : {
                        height: mainHeight,
                        width: mainWidth,
                    };
                this.renderer.setStyle(child.nativeElement, 'height', `${childStyle.height}px`);
                this.renderer.setStyle(child.nativeElement, 'width', `${childStyle.width}px`);
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MainScreenComponent, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MainScreenComponent, isStandalone: true, selector: "app-main-screen-component", inputs: { mainSize: "mainSize", doStack: "doStack", containerWidthFraction: "containerWidthFraction", containerHeightFraction: "containerHeightFraction", defaultFraction: "defaultFraction", showControls: "showControls", updateComponentSizes: "updateComponentSizes" }, queries: [{ propertyName: "children", predicate: ["child"] }], usesOnChanges: true, ngImport: i0, template: `
    <div [ngStyle]="containerStyle">
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MainScreenComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-main-screen-component',
                    standalone: true,
                    imports: [CommonModule],
                    template: `
    <div [ngStyle]="containerStyle">
      <ng-content></ng-content>
    </div>
  `,
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }], propDecorators: { mainSize: [{
                type: Input
            }], doStack: [{
                type: Input
            }], containerWidthFraction: [{
                type: Input
            }], containerHeightFraction: [{
                type: Input
            }], defaultFraction: [{
                type: Input
            }], showControls: [{
                type: Input
            }], updateComponentSizes: [{
                type: Input
            }], children: [{
                type: ContentChildren,
                args: ['child']
            }] } });

/**
 * MainGridComponent is a standalone Angular component that displays a grid container
 * with optional meeting progress timer and customizable styles.
 *
 * @selector app-main-grid-component
 * @standalone true
 * @imports CommonModule, MeetingProgressTimer
 *
 * @template
 * <div [ngStyle]="maingridContainerStyle">
 *   <app-meeting-progress-timer
 *     *ngIf="showTimer"
 *     [meetingProgressTime]="meetingProgressTime"
 *     [initialBackgroundColor]="timeBackgroundColor"
 *   ></app-meeting-progress-timer>
 *   <ng-content></ng-content>
 * </div>
 *
 * @Inputs
 * @property {string} backgroundColor - The background color of the grid container.
 * @property {number} mainSize - The main size of the grid container.
 * @property {number} height - The height of the grid container in pixels.
 * @property {number} width - The width of the grid container in pixels.
 * @property {boolean} showAspect - Determines if the grid container should be displayed as flex.
 * @property {string} timeBackgroundColor - The background color of the meeting progress timer.
 * @property {boolean} showTimer - Determines if the meeting progress timer should be displayed.
 * @property {string} meetingProgressTime - The progress time to be displayed in the meeting progress timer.
 *
 * @getter maingridContainerStyle - Returns the style object for the grid container.
 * @returns {Object} The style object for the grid container.
 */
class MainGridComponent {
    backgroundColor = '';
    mainSize = 0;
    height = 0;
    width = 0;
    showAspect = true;
    timeBackgroundColor = 'green';
    showTimer = true;
    meetingProgressTime = '0';
    get maingridContainerStyle() {
        return {
            display: this.showAspect ? 'flex' : 'none',
            backgroundColor: this.backgroundColor,
            height: `${this.height}px`,
            width: `${this.width}px`,
            flexDirection: 'row',
            justifyContent: 'center',
            alignItems: 'center',
            borderStyle: 'solid',
            borderColor: '#000',
            borderWidth: '4px',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MainGridComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MainGridComponent, isStandalone: true, selector: "app-main-grid-component", inputs: { backgroundColor: "backgroundColor", mainSize: "mainSize", height: "height", width: "width", showAspect: "showAspect", timeBackgroundColor: "timeBackgroundColor", showTimer: "showTimer", meetingProgressTime: "meetingProgressTime" }, ngImport: i0, template: `
    <div [ngStyle]="maingridContainerStyle">
      <app-meeting-progress-timer
        *ngIf="showTimer"
        [meetingProgressTime]="meetingProgressTime"
        [initialBackgroundColor]="timeBackgroundColor"
      ></app-meeting-progress-timer>
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: MeetingProgressTimer, selector: "app-meeting-progress-timer", inputs: ["meetingProgressTime", "initialBackgroundColor", "position", "textStyle", "showTimer"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MainGridComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-main-grid-component',
                    standalone: true,
                    imports: [CommonModule, MeetingProgressTimer],
                    template: `
    <div [ngStyle]="maingridContainerStyle">
      <app-meeting-progress-timer
        *ngIf="showTimer"
        [meetingProgressTime]="meetingProgressTime"
        [initialBackgroundColor]="timeBackgroundColor"
      ></app-meeting-progress-timer>
      <ng-content></ng-content>
    </div>
  `,
                }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], mainSize: [{
                type: Input
            }], height: [{
                type: Input
            }], width: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], timeBackgroundColor: [{
                type: Input
            }], showTimer: [{
                type: Input
            }], meetingProgressTime: [{
                type: Input
            }] } });

/**
 * @fileoverview SubAspectComponent is an Angular component that displays a sub-aspect of a media element.
 * It adjusts its size and visibility based on input properties and window events.
 *
 * @component
 * @selector app-sub-aspect-component
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * <div *ngIf="showControls" [ngStyle]="{ position: 'absolute', bottom: '0', margin: '0', backgroundColor: backgroundColor, height: aspectStyles.height + 'px', width: aspectStyles.width + 'px' }">
 *   <ng-content></ng-content>
 * </div>
 *
 * @styles []
 *
 * @class SubAspectComponent
 * @implements OnInit, OnDestroy, OnChanges
 *
 * @property {string} backgroundColor - The background color of the component. Default is 'transparent'.
 * @property {boolean} showControls - Determines whether the controls are shown. Default is true.
 * @property {number} containerWidthFraction - The fraction of the container's width. Default is 1.
 * @property {number} containerHeightFraction - The fraction of the container's height. Default is 1.
 * @property {number} defaultFractionSub - The default fraction for the sub-aspect. Default is 0.0.
 * @property {object} aspectStyles - The styles for the aspect, including height and width.
 * @property {number} aspectStyles.height - The height of the aspect.
 * @property {number} aspectStyles.width - The width of the aspect.
 * @property {number} subAspectFraction - The fraction of the sub-aspect.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized. Adds event listeners for window resize and orientation change.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes. Updates aspect styles if relevant properties change.
 * @method ngOnDestroy - Lifecycle hook that is called just before the component is destroyed. Removes event listeners for window resize and orientation change.
 * @method updateAspectStyles - Updates the aspect styles based on the current window size and input properties.
 */
class SubAspectComponent {
    backgroundColor = 'transparent';
    showControls = true;
    containerWidthFraction = 1;
    containerHeightFraction = 1;
    defaultFractionSub = 0.0;
    aspectStyles = {
        height: 0,
        width: 0,
    };
    ngOnInit() {
        this.updateAspectStyles();
        window.addEventListener('resize', this.updateAspectStyles.bind(this));
        window.addEventListener('orientationchange', this.updateAspectStyles.bind(this));
    }
    ngOnChanges(changes) {
        if (changes['showControls'] ||
            changes['containerWidthFraction'] ||
            changes['containerHeightFraction'] ||
            changes['defaultFractionSub']) {
            this.updateAspectStyles();
        }
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.updateAspectStyles.bind(this));
        window.removeEventListener('orientationchange', this.updateAspectStyles.bind(this));
    }
    updateAspectStyles() {
        const windowWidth = window.innerWidth;
        this.aspectStyles = {
            height: this.showControls ? 40 : 0,
            width: this.containerWidthFraction ? this.containerWidthFraction * windowWidth : windowWidth,
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SubAspectComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: SubAspectComponent, isStandalone: true, selector: "app-sub-aspect-component", inputs: { backgroundColor: "backgroundColor", showControls: "showControls", containerWidthFraction: "containerWidthFraction", containerHeightFraction: "containerHeightFraction", defaultFractionSub: "defaultFractionSub" }, usesOnChanges: true, ngImport: i0, template: `
    <div
      *ngIf="showControls"
      [ngStyle]="{
        position: 'absolute',
        bottom: '0',
        margin: '0',
        backgroundColor: backgroundColor,
        height: aspectStyles.height + 'px',
        width: aspectStyles.width + 'px'
      }"
    >
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SubAspectComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-sub-aspect-component', standalone: true, imports: [CommonModule], template: `
    <div
      *ngIf="showControls"
      [ngStyle]="{
        position: 'absolute',
        bottom: '0',
        margin: '0',
        backgroundColor: backgroundColor,
        height: aspectStyles.height + 'px',
        width: aspectStyles.width + 'px'
      }"
    >
      <ng-content></ng-content>
    </div>
  ` }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], showControls: [{
                type: Input
            }], containerWidthFraction: [{
                type: Input
            }], containerHeightFraction: [{
                type: Input
            }], defaultFractionSub: [{
                type: Input
            }] } });

/**
 * MainContainerComponent is a standalone Angular component that dynamically adjusts its styles
 * based on the provided input properties and window size changes.
 *
 * @selector app-main-container-component
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * ```html
 * <div [ngStyle]="containerStyles">
 *   <ng-content></ng-content>
 * </div>
 * ```
 *
 * @class MainContainerComponent
 * @implements OnInit, OnDestroy, OnChanges
 *
 * @property {string} backgroundColor - The background color of the container.
 * @property {number} containerWidthFraction - The fraction of the window width the container should occupy.
 * @property {number} containerHeightFraction - The fraction of the window height the container should occupy.
 * @property {number} marginLeft - The left margin of the container in pixels.
 * @property {number} marginRight - The right margin of the container in pixels.
 * @property {number} marginTop - The top margin of the container in pixels.
 * @property {number} marginBottom - The bottom margin of the container in pixels.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized. Sets up event listeners for window resize and orientation change.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes. Updates the container styles accordingly.
 * @method ngOnDestroy - Lifecycle hook that is called just before the component is destroyed. Removes event listeners for window resize and orientation change.
 * @method updateContainerStyles - Updates the container styles based on the current input properties and window size.
 */
class MainContainerComponent {
    backgroundColor = '';
    containerWidthFraction = 1;
    containerHeightFraction = 1;
    marginLeft = 0;
    marginRight = 0;
    marginTop = 0;
    marginBottom = 0;
    padding = 0;
    containerStyles = {};
    ngOnInit() {
        this.updateContainerStyles();
        window.addEventListener('resize', this.updateContainerStyles);
        window.addEventListener('orientationchange', this.updateContainerStyles);
    }
    ngOnChanges(changes) {
        if (changes['containerHeightFraction'] ||
            changes['containerWidthFraction'] ||
            changes['backgroundColor'] ||
            changes['marginLeft'] ||
            changes['marginRight'] ||
            changes['marginTop'] ||
            changes['marginBottom']) {
            this.updateContainerStyles();
        }
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.updateContainerStyles);
        window.removeEventListener('orientationchange', this.updateContainerStyles);
    }
    updateContainerStyles = () => {
        const windowHeight = window.innerHeight;
        const windowWidth = window.innerWidth;
        this.containerStyles = {
            backgroundColor: this.backgroundColor,
            marginLeft: `${this.marginLeft}px`,
            marginRight: `${this.marginRight}px`,
            marginTop: `${this.marginTop}px`,
            marginBottom: `${this.marginBottom}px`,
            height: Math.floor(this.containerHeightFraction * windowHeight) + 'px',
            maxHeight: Math.floor(this.containerHeightFraction * windowHeight) + 'px',
            width: Math.floor(this.containerWidthFraction * windowWidth) + 'px',
            maxWidth: Math.floor(this.containerWidthFraction * windowWidth) + 'px',
            padding: `${this.padding}px`,
            overflow: 'hidden',
        };
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MainContainerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MainContainerComponent, isStandalone: true, selector: "app-main-container-component", inputs: { backgroundColor: "backgroundColor", containerWidthFraction: "containerWidthFraction", containerHeightFraction: "containerHeightFraction", marginLeft: "marginLeft", marginRight: "marginRight", marginTop: "marginTop", marginBottom: "marginBottom", padding: "padding" }, usesOnChanges: true, ngImport: i0, template: `
    <div [ngStyle]="containerStyles">
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MainContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-main-container-component',
                    standalone: true,
                    imports: [CommonModule],
                    template: `
    <div [ngStyle]="containerStyles">
      <ng-content></ng-content>
    </div>
  `,
                }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], containerWidthFraction: [{
                type: Input
            }], containerHeightFraction: [{
                type: Input
            }], marginLeft: [{
                type: Input
            }], marginRight: [{
                type: Input
            }], marginTop: [{
                type: Input
            }], marginBottom: [{
                type: Input
            }], padding: [{
                type: Input
            }] } });

/**
 * AlertComponent is a standalone Angular component that displays an alert message.
 * It supports different types of alerts such as 'success' and 'danger', and can be configured
 * to automatically hide after a specified duration.
 *
 * @selector app-alert-component
 * @standalone true
 * @imports CommonModule
 * @templateUrl ./alert.component.html
 * @styleUrls ./alert.component.css
 *
 * @class AlertComponent
 * @implements OnChanges
 *
 * @property {boolean} visible - Determines if the alert is visible.
 * @property {string} message - The message to be displayed in the alert.
 * @property {'success' | 'danger'} type - The type of alert, either 'success' or 'danger'.
 * @property {number} duration - The duration (in milliseconds) for which the alert is visible before hiding.
 * @property {string} textColor - The color of the text in the alert.
 * @property {() => void} onHide - A callback function that is called when the alert is hidden.
 *
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property of a directive changes.
 * @param {SimpleChanges} changes - An object of changes to the data-bound properties.
 *
 * @method handlePress - Manually hides the alert by calling the onHide callback.
 */
class AlertComponent {
    visible = false;
    message = '';
    type = 'success';
    duration = 4000;
    textColor = 'black';
    onHide;
    alertType = 'success';
    ngOnChanges(changes) {
        if (changes['type']) {
            this.alertType = this.type;
        }
        if (changes['visible']) {
            if (this.visible) {
                setTimeout(() => {
                    this.onHide();
                }, this.duration);
            }
        }
    }
    handlePress() {
        this.onHide();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AlertComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: AlertComponent, isStandalone: true, selector: "app-alert-component", inputs: { visible: "visible", message: "message", type: "type", duration: "duration", textColor: "textColor", onHide: "onHide" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"visible\" (click)=\"handlePress()\" class=\"centeredView\">\r\n  <div [ngStyle]=\"{ 'background-color': alertType === 'success' ? 'green' : 'red' }\" class=\"modalView\">\r\n    <p [ngStyle]=\"{ color: textColor }\" class=\"modalText\">{{ message }}</p>\r\n  </div>\r\n</div>\r\n", styles: [".centeredView{display:flex;justify-content:center;align-items:center;position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;z-index:1000}.modalView{background-color:#fff;border-radius:10px;padding:20px;max-width:400px;box-shadow:0 4px 6px #0000001a}.modalText{color:#000;font-size:16px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AlertComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-alert-component', standalone: true, imports: [CommonModule], template: "<div *ngIf=\"visible\" (click)=\"handlePress()\" class=\"centeredView\">\r\n  <div [ngStyle]=\"{ 'background-color': alertType === 'success' ? 'green' : 'red' }\" class=\"modalView\">\r\n    <p [ngStyle]=\"{ color: textColor }\" class=\"modalText\">{{ message }}</p>\r\n  </div>\r\n</div>\r\n", styles: [".centeredView{display:flex;justify-content:center;align-items:center;position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;z-index:1000}.modalView{background-color:#fff;border-radius:10px;padding:20px;max-width:400px;box-shadow:0 4px 6px #0000001a}.modalText{color:#000;font-size:16px}\n"] }]
        }], propDecorators: { visible: [{
                type: Input
            }], message: [{
                type: Input
            }], type: [{
                type: Input
            }], duration: [{
                type: Input
            }], textColor: [{
                type: Input
            }], onHide: [{
                type: Input
            }] } });

class CustomButtons {
    /**
     * CustomButtons component renders a list of customizable buttons.
     *
     * @component
     * @param {CustomButtonsOptions} props - The properties for the CustomButtons component.
     * @param {Array} props.buttons - An array of button configurations.
     * @param {Object} props.buttons[].action - The function to be called when the button is clicked.
     * @param {boolean} props.buttons[].show - Determines if the button should be displayed.
     * @param {string} props.buttons[].backgroundColor - The background color of the button.
     * @param {boolean} props.buttons[].disabled - Determines if the button should be disabled.
     * @param {Object} [props.buttons[].icon] - The icon to be displayed on the button.
     * @param {Object} [props.buttons[].iconStyle] - The style to be applied to the icon.
     * @param {string} [props.buttons[].text] - The text to be displayed on the button.
     * @param {Object} [props.buttons[].textStyle] - The style to be applied to the text.
     * @param {React.ReactNode} [props.buttons[].customComponent] - A custom component to be rendered inside the button.
     * @param {Injector} [props.buttons[].injector] - The injector to be used for the custom component.
     * @returns {HTMLElement} The CustomButtons component.
     * @example
     * ```html
     * <app-custom-buttons [buttons]="buttons"></app-custom-buttons>
     * ```
     * @example
     * ```typescript
     * const buttons = [
     *  {
     *   action: () => console.log('Button 1 clicked'),
     *  show: true,
     * backgroundColor: 'blue',
     * disabled: false,
     * icon: faCoffee,
     * iconStyle: { color: 'white' },
     * text: 'Button 1',
     * textStyle: { color: 'white' },
     * customComponent: <CustomComponent />,
     * injector: Injector.create({ providers: [{ provide: 'customProp', useValue: 'customValue' }] }),
     * },
     * {
     *  action: () => console.log('Button 2 clicked'),
     * show: true,
     * backgroundColor: 'red',
     * disabled: false,
     * icon: faCoffee,
     * iconStyle: { color: 'white' },
     * text: 'Button 2',
     * textStyle: { color: 'white' },
     * customComponent: <CustomComponent />,
     * injector: Injector.create({ providers: [{ provide: 'customProp', useValue: 'customValue' }] }),
     * },
     * ];
     * ```
     */
    buttons;
    faSpinner = faSpinner;
    mergeStyles(defaultStyle, customStyle) {
        return { ...defaultStyle, ...customStyle };
    }
    get customButtonIcon() {
        return {
            fontSize: '20px',
            marginRight: '5px',
        };
    }
    // Type guard to check if customComponent is of type CustomComponentConfig
    isCustomComponentConfig(obj) {
        return obj && typeof obj === 'object' && 'component' in obj && 'injector' in obj;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CustomButtons, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: CustomButtons, isStandalone: true, selector: "app-custom-buttons", inputs: { buttons: "buttons" }, ngImport: i0, template: "<div class=\"customButtonsContainer\">\r\n  <button\r\n    *ngFor=\"let button of buttons; let i = index\"\r\n    (click)=\"button.action()\"\r\n    class=\"customButton\"\r\n    [ngStyle]=\"{\r\n      'background-color': button.show ? button.backgroundColor : 'transparent',\r\n      'display': button.show ? 'flex' : 'none'\r\n    }\"\r\n    [disabled]=\"button.disabled\"\r\n  >\r\n    <div class=\"buttonContent\">\r\n      <ng-container *ngIf=\"button.icon; else customOrSpinner\">\r\n        <fa-icon [icon]=\"button.icon\" [ngStyle]=\"mergeStyles(customButtonIcon, button.iconStyle)\"></fa-icon>\r\n        <span *ngIf=\"button.text\" class=\"customButtonText\" [ngStyle]=\"button.textStyle\">{{ button.text }}</span>\r\n      </ng-container>\r\n      <ng-template #customOrSpinner>\r\n        <ng-container *ngIf=\"isCustomComponentConfig(button.customComponent)\">\r\n          <ng-container *ngComponentOutlet=\"button.customComponent.component; injector: button.customComponent.injector\"></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"button.customComponent && !isCustomComponentConfig(button.customComponent)\">\r\n          <div #customElementContainer></div>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!button.customComponent\">\r\n          <fa-icon [icon]=\"faSpinner\"></fa-icon>\r\n        </ng-container>\r\n      </ng-template>\r\n    </div>\r\n  </button>\r\n</div>\r\n", styles: [".customButtonsContainer{display:flex;flex-direction:column;flex-wrap:wrap;justify-content:space-between;align-items:left}.customButton{width:100%;margin:10px 0;padding:10px;border-radius:5px;background-color:transparent;align-items:left;justify-content:left;border:none}.buttonContent{display:flex;align-items:left;justify-content:left}.customButtonIcon{font-size:20px;color:#000;margin-right:4px}.customButtonText{color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FormsModule }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CustomButtons, decorators: [{
            type: Component,
            args: [{ selector: 'app-custom-buttons', standalone: true, imports: [CommonModule, FormsModule, FontAwesomeModule], template: "<div class=\"customButtonsContainer\">\r\n  <button\r\n    *ngFor=\"let button of buttons; let i = index\"\r\n    (click)=\"button.action()\"\r\n    class=\"customButton\"\r\n    [ngStyle]=\"{\r\n      'background-color': button.show ? button.backgroundColor : 'transparent',\r\n      'display': button.show ? 'flex' : 'none'\r\n    }\"\r\n    [disabled]=\"button.disabled\"\r\n  >\r\n    <div class=\"buttonContent\">\r\n      <ng-container *ngIf=\"button.icon; else customOrSpinner\">\r\n        <fa-icon [icon]=\"button.icon\" [ngStyle]=\"mergeStyles(customButtonIcon, button.iconStyle)\"></fa-icon>\r\n        <span *ngIf=\"button.text\" class=\"customButtonText\" [ngStyle]=\"button.textStyle\">{{ button.text }}</span>\r\n      </ng-container>\r\n      <ng-template #customOrSpinner>\r\n        <ng-container *ngIf=\"isCustomComponentConfig(button.customComponent)\">\r\n          <ng-container *ngComponentOutlet=\"button.customComponent.component; injector: button.customComponent.injector\"></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"button.customComponent && !isCustomComponentConfig(button.customComponent)\">\r\n          <div #customElementContainer></div>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!button.customComponent\">\r\n          <fa-icon [icon]=\"faSpinner\"></fa-icon>\r\n        </ng-container>\r\n      </ng-template>\r\n    </div>\r\n  </button>\r\n</div>\r\n", styles: [".customButtonsContainer{display:flex;flex-direction:column;flex-wrap:wrap;justify-content:space-between;align-items:left}.customButton{width:100%;margin:10px 0;padding:10px;border-radius:5px;background-color:transparent;align-items:left;justify-content:left;border:none}.buttonContent{display:flex;align-items:left;justify-content:left}.customButtonIcon{font-size:20px;color:#000;margin-right:4px}.customButtonText{color:#000}\n"] }]
        }], propDecorators: { buttons: [{
                type: Input
            }] } });

/**
 * Component representing a meeting ID.
 *
 * @selector app-meeting-id-component
 * @templateUrl ./meeting-id-component.component.html
 * @styleUrls ./meeting-id-component.component.css
 * @standalone true
 */
class MeetingIdComponent {
    meetingID = '';
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingIdComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MeetingIdComponent, isStandalone: true, selector: "app-meeting-id-component", inputs: { meetingID: "meetingID" }, ngImport: i0, template: "<div class=\"form-group\">\r\n  <label class=\"label\">Event ID:</label>\r\n  <input\r\n    class=\"disabled-input\"\r\n    [value]=\"meetingID\"\r\n    readonly\r\n  />\r\n</div>\r\n", styles: [".form-group{margin-top:10px;max-width:300px}.label{font-weight:700}.disabled-input{border-width:1px;border-color:gray;padding:10px;margin-top:5px;background-color:#f0f0f0;color:#000;width:100%;border-radius:5px}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingIdComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-meeting-id-component', standalone: true, template: "<div class=\"form-group\">\r\n  <label class=\"label\">Event ID:</label>\r\n  <input\r\n    class=\"disabled-input\"\r\n    [value]=\"meetingID\"\r\n    readonly\r\n  />\r\n</div>\r\n", styles: [".form-group{margin-top:10px;max-width:300px}.label{font-weight:700}.disabled-input{border-width:1px;border-color:gray;padding:10px;margin-top:5px;background-color:#f0f0f0;color:#000;width:100%;border-radius:5px}\n"] }]
        }], propDecorators: { meetingID: [{
                type: Input
            }] } });

/**
 * Component for displaying and managing a meeting passcode.
 *
 * @selector app-meeting-passcode-component
 * @standalone true
 * @templateUrl ./meeting-passcode-component.component.html
 * @styleUrls ./meeting-passcode-component.component.css
 */
class MeetingPasscodeComponent {
    meetingPasscode = '';
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingPasscodeComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MeetingPasscodeComponent, isStandalone: true, selector: "app-meeting-passcode-component", inputs: { meetingPasscode: "meetingPasscode" }, ngImport: i0, template: "<div class=\"form-group\">\r\n  <label class=\"label\">Event Passcode (Host):</label>\r\n  <input\r\n    class=\"disabled-input\"\r\n    [value]=\"meetingPasscode\"\r\n    readonly\r\n  />\r\n</div>\r\n", styles: [".form-group{margin-top:10px;max-width:300px}.label{font-weight:700}.disabled-input{border-width:1px;border-color:gray;padding:10px;margin-top:5px;background-color:#f0f0f0;color:#000;width:100%;border-radius:5px}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingPasscodeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-meeting-passcode-component', standalone: true, template: "<div class=\"form-group\">\r\n  <label class=\"label\">Event Passcode (Host):</label>\r\n  <input\r\n    class=\"disabled-input\"\r\n    [value]=\"meetingPasscode\"\r\n    readonly\r\n  />\r\n</div>\r\n", styles: [".form-group{margin-top:10px;max-width:300px}.label{font-weight:700}.disabled-input{border-width:1px;border-color:gray;padding:10px;margin-top:5px;background-color:#f0f0f0;color:#000;width:100%;border-radius:5px}\n"] }]
        }], propDecorators: { meetingPasscode: [{
                type: Input
            }] } });

/**
 * @component ShareButtonsComponent
 * @description This component provides a set of share buttons for different social media platforms and email.
 * It allows users to share a meeting link via various channels.
 *
 * @selector app-share-buttons-component
 * @templateUrl ./share-buttons-component.component.html
 * @styleUrls ./share-buttons-component.component.css
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule]
 *
 * @input {string} meetingID - The ID of the meeting to be shared.
 * @input {ShareButton[]} shareButtons - An array of custom share buttons.
 * @input {string} eventType - The type of event (e.g., 'chat', 'broadcast', 'webinar').
 *
 * @property {ShareButton[]} defaultShareButtons - The default set of share buttons.
 *
 * @getter {string} shareName - Determines the share name based on the event type.
 * @getter {ShareButton[]} filteredShareButtons - Returns the filtered share buttons based on visibility.
 */
class ShareButtonsComponent {
    meetingID;
    shareButtons = [];
    eventType;
    defaultShareButtons = [
        {
            icon: faCopy,
            action: async () => {
                try {
                    await navigator.clipboard.writeText(`https://${this.shareName}.mediasfu.com/${this.shareName}/${this.meetingID}`);
                }
                catch (error) {
                    console.error('Failed to copy to clipboard:', error);
                }
            },
            show: true,
        },
        {
            icon: faEnvelope,
            action: () => {
                const emailUrl = `mailto:?subject=Join my meeting&body=Here's the link to the meeting: https://${this.shareName}.mediasfu.com/${this.shareName}/${this.meetingID}`;
                window.open(emailUrl, '_blank');
            },
            show: true,
        },
        {
            icon: faFacebook,
            action: () => {
                const facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(`https://${this.shareName}.mediasfu.com/${this.shareName}/${this.meetingID}`)}`;
                window.open(facebookUrl, '_blank');
            },
            show: true,
        },
        {
            icon: faWhatsapp,
            action: () => {
                const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(`https://${this.shareName}.mediasfu.com/${this.shareName}/${this.meetingID}`)}`;
                window.open(whatsappUrl, '_blank');
            },
            show: true,
        },
        {
            icon: faTelegram,
            action: () => {
                const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(`https://${this.shareName}.mediasfu.com/${this.shareName}/${this.meetingID}`)}`;
                window.open(telegramUrl, '_blank');
            },
            show: true,
        },
    ];
    get shareName() {
        return this.eventType === 'chat'
            ? 'chat'
            : this.eventType === 'broadcast'
                ? 'broadcast'
                : 'meeting';
    }
    get filteredShareButtons() {
        return this.shareButtons.length > 0
            ? this.shareButtons.filter((button) => button.show)
            : this.defaultShareButtons.filter((button) => button.show);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ShareButtonsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ShareButtonsComponent, isStandalone: true, selector: "app-share-buttons-component", inputs: { meetingID: "meetingID", shareButtons: "shareButtons", eventType: "eventType" }, ngImport: i0, template: "<div class=\"share-buttons-container\">\r\n  <div\r\n    *ngFor=\"let button of filteredShareButtons; let i = index\"\r\n    (click)=\"button.action()\"\r\n    [ngStyle]=\"{\r\n      'background-color': button.color || 'black',\r\n      'margin-right': i !== filteredShareButtons.length - 1 ? '10px' : '0'\r\n    }\"\r\n    class=\"share-button\"\r\n  >\r\n    <fa-icon [icon]=\"button.icon\" [ngStyle]=\"{ color: button.iconColor || '#ffffff', 'font-size': '24px' }\"></fa-icon>\r\n  </div>\r\n</div>\r\n", styles: [".share-buttons-container{display:flex;flex-direction:row;margin:10px 0}.share-button{display:flex;align-items:center;justify-content:center;padding:10px;border-radius:5px;margin:0 5px;cursor:pointer}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ShareButtonsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-share-buttons-component', standalone: true, imports: [CommonModule, FontAwesomeModule], template: "<div class=\"share-buttons-container\">\r\n  <div\r\n    *ngFor=\"let button of filteredShareButtons; let i = index\"\r\n    (click)=\"button.action()\"\r\n    [ngStyle]=\"{\r\n      'background-color': button.color || 'black',\r\n      'margin-right': i !== filteredShareButtons.length - 1 ? '10px' : '0'\r\n    }\"\r\n    class=\"share-button\"\r\n  >\r\n    <fa-icon [icon]=\"button.icon\" [ngStyle]=\"{ color: button.iconColor || '#ffffff', 'font-size': '24px' }\"></fa-icon>\r\n  </div>\r\n</div>\r\n", styles: [".share-buttons-container{display:flex;flex-direction:row;margin:10px 0}.share-button{display:flex;align-items:center;justify-content:center;padding:10px;border-radius:5px;margin:0 5px;cursor:pointer}\n"] }]
        }], propDecorators: { meetingID: [{
                type: Input
            }], shareButtons: [{
                type: Input
            }], eventType: [{
                type: Input
            }] } });

/**
 * @component MenuModal
 *
 * @description
 * The MenuModal component is a standalone Angular component that displays a modal dialog.
 * It includes various customizable properties and imports necessary modules and components.
 *
 * @selector app-menu-modal
 * @templateUrl ./menu-modal.component.html
 * @styleUrls ./menu-modal.component.css
 *
 * @inputs
 * @input {string} backgroundColor - The background color of the modal content. Default is '#83c0e9'.
 * @input {boolean} isVisible - Determines whether the modal is visible.
 * @input {CustomButton[]} customButtons - An array of custom buttons to be displayed in the modal.
 * @input {boolean} shareButtons - Determines whether share buttons are displayed. Default is true.
 * @input {string} position - The position of the modal on the screen. Default is 'bottomRight'.
 * @input {string} roomName - The name of the room.
 * @input {string} adminPasscode - The admin passcode for the room.
 * @input {string} islevel - The level of the user.
 * @input {() => void} onClose - A function to be called when the modal is closed.
 *
 * @methods
 * @method modalContainerStyle - Returns the style object for the modal container.
 * @method modalContentStyle - Returns the style object for the modal content.
 * @method handleClose - Calls the onClose function to handle closing the modal.
 *
 * @dependencies
 * - CommonModule
 * - FontAwesomeModule
 * - FormsModule
 * - CustomButtons
 * - MeetingIdComponent
 * - MeetingPasscodeComponent
 * - ShareButtonsComponent
 */
class MenuModal {
    backgroundColor = '#83c0e9';
    isVisible;
    customButtons = [];
    shareButtons = true;
    position = 'bottomRight';
    roomName;
    adminPasscode;
    islevel;
    eventType;
    // Define inputs for functions
    onClose;
    faBars = faBars;
    faTimes = faTimes;
    modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isVisible ? 'block' : 'none',
            zIndex: 999,
        };
    }
    modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.7 * screenWidth;
        if (modalWidth > 400) {
            modalWidth = 400;
        }
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '5px',
            width: `${modalWidth}px`,
            maxHeight: '80%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    handleClose() {
        this.onClose();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MenuModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MenuModal, isStandalone: true, selector: "app-menu-modal", inputs: { backgroundColor: "backgroundColor", isVisible: "isVisible", customButtons: "customButtons", shareButtons: "shareButtons", position: "position", roomName: "roomName", adminPasscode: "adminPasscode", islevel: "islevel", eventType: "eventType", onClose: "onClose" }, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;\">\r\n      <div style=\"font-size: 18px; font-weight: bold; color: black;\">\r\n        <fa-icon [icon]=\"faBars\" style=\"font-size: 20px; color: black;\"></fa-icon> Menu\r\n      </div>\r\n      <div (click)=\"handleClose()\" style=\"padding: 5px;\">\r\n        <fa-icon [icon]=\"faTimes\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n    <div style=\"flex: 1;\">\r\n      <div style=\"max-height: calc(70% - 70px); overflow-y: auto;\">\r\n        <app-custom-buttons [buttons]=\"customButtons\"></app-custom-buttons>\r\n        <div style=\"height: 1px; background-color: #ffffff; margin: 10px 0;\"></div>\r\n        <ng-container *ngIf=\"islevel === '2'\">\r\n          <app-meeting-passcode-component\r\n            [meetingPasscode]=\"adminPasscode\"\r\n          ></app-meeting-passcode-component>\r\n        </ng-container>\r\n        <div style=\"margin-bottom: 10px;\">\r\n          <app-meeting-id-component [meetingID]=\"roomName\"></app-meeting-id-component>\r\n        </div>\r\n        <ng-container *ngIf=\"true\">\r\n          <app-share-buttons-component [meetingID]=\"roomName\" [eventType]=\"eventType\"></app-share-buttons-component>\r\n        </ng-container>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:9}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "component", type: CustomButtons, selector: "app-custom-buttons", inputs: ["buttons"] }, { kind: "component", type: MeetingIdComponent, selector: "app-meeting-id-component", inputs: ["meetingID"] }, { kind: "component", type: MeetingPasscodeComponent, selector: "app-meeting-passcode-component", inputs: ["meetingPasscode"] }, { kind: "component", type: ShareButtonsComponent, selector: "app-share-buttons-component", inputs: ["meetingID", "shareButtons", "eventType"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MenuModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-menu-modal', standalone: true, imports: [
                        CommonModule,
                        FontAwesomeModule,
                        FormsModule,
                        CustomButtons,
                        MeetingIdComponent,
                        MeetingPasscodeComponent,
                        ShareButtonsComponent,
                    ], template: "<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;\">\r\n      <div style=\"font-size: 18px; font-weight: bold; color: black;\">\r\n        <fa-icon [icon]=\"faBars\" style=\"font-size: 20px; color: black;\"></fa-icon> Menu\r\n      </div>\r\n      <div (click)=\"handleClose()\" style=\"padding: 5px;\">\r\n        <fa-icon [icon]=\"faTimes\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n    <div style=\"flex: 1;\">\r\n      <div style=\"max-height: calc(70% - 70px); overflow-y: auto;\">\r\n        <app-custom-buttons [buttons]=\"customButtons\"></app-custom-buttons>\r\n        <div style=\"height: 1px; background-color: #ffffff; margin: 10px 0;\"></div>\r\n        <ng-container *ngIf=\"islevel === '2'\">\r\n          <app-meeting-passcode-component\r\n            [meetingPasscode]=\"adminPasscode\"\r\n          ></app-meeting-passcode-component>\r\n        </ng-container>\r\n        <div style=\"margin-bottom: 10px;\">\r\n          <app-meeting-id-component [meetingID]=\"roomName\"></app-meeting-id-component>\r\n        </div>\r\n        <ng-container *ngIf=\"true\">\r\n          <app-share-buttons-component [meetingID]=\"roomName\" [eventType]=\"eventType\"></app-share-buttons-component>\r\n        </ng-container>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:9}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}\n"] }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], isVisible: [{
                type: Input
            }], customButtons: [{
                type: Input
            }], shareButtons: [{
                type: Input
            }], position: [{
                type: Input
            }], roomName: [{
                type: Input
            }], adminPasscode: [{
                type: Input
            }], islevel: [{
                type: Input
            }], eventType: [{
                type: Input
            }], onClose: [{
                type: Input
            }] } });

/**
 * @component StandardPanelComponent
 * @description This component represents a standard panel for recording options.
 * It allows users to select media, audio, and video options, as well as toggle HLS recording.
 *
 * @selector app-standard-panel-component
 * @standalone true
 * @templateUrl ./standard-panel-component.component.html
 * @styleUrls ./standard-panel-component.component.css
 * @imports [CommonModule, FormsModule]
 *
 * @input {StandardPanelParameters} parameters - The parameters for the standard panel component.
 *
 * @property {string} selectedRecordingMediaOptions - The selected media options for recording.
 * @property {string} selectedRecordingAudioOptions - The selected audio options for recording.
 * @property {string} selectedRecordingVideoOptions - The selected video options for recording.
 * @property {boolean} selectedRecordingAddHLS - The flag indicating whether HLS recording is enabled.
 *
 * @method ngOnInit - Initializes the component and sets the initial values for recording options.
 * @method ngOnChanges - Handles changes to the input parameters and updates the recording options accordingly.
 * @method handleMediaOptionsChange - Handles changes to the media options and updates the parameters.
 * @method handleAudioOptionsChange - Handles changes to the audio options and updates the parameters.
 * @method handleVideoOptionsChange - Handles changes to the video options and updates the parameters.
 * @method handleAddHLSChange - Handles changes to the HLS recording option and updates the parameters.
 *
 * @param {SimpleChanges} changes - The changes to the input properties.
 * @param {any} event - The event object from the change event.
 */
class StandardPanelComponent {
    parameters = {};
    selectedRecordingMediaOptions;
    selectedRecordingAudioOptions;
    selectedRecordingVideoOptions;
    selectedRecordingAddHLS;
    ngOnInit() {
        this.selectedRecordingMediaOptions = this.parameters.recordingMediaOptions;
        this.selectedRecordingAudioOptions = this.parameters.recordingAudioOptions;
        this.selectedRecordingVideoOptions = this.parameters.recordingVideoOptions;
        this.selectedRecordingAddHLS = this.parameters.recordingAddHLS;
    }
    ngOnChanges(changes) {
        if (changes['parameters']) {
            this.parameters = changes['parameters'].currentValue;
            this.selectedRecordingMediaOptions = this.parameters.recordingMediaOptions;
            this.selectedRecordingAudioOptions = this.parameters.recordingAudioOptions;
            this.selectedRecordingVideoOptions = this.parameters.recordingVideoOptions;
            this.selectedRecordingAddHLS = this.parameters.recordingAddHLS;
        }
    }
    handleMediaOptionsChange(event) {
        const value = event.target.value;
        this.selectedRecordingMediaOptions = value;
        this.parameters.updateRecordingMediaOptions(value);
    }
    handleAudioOptionsChange(event) {
        const value = event.target.value;
        this.selectedRecordingAudioOptions = value;
        this.parameters.updateRecordingAudioOptions(value);
    }
    handleVideoOptionsChange(event) {
        const value = event.target.value;
        this.selectedRecordingVideoOptions = value;
        this.parameters.updateRecordingVideoOptions(value);
    }
    handleAddHLSChange(event) {
        const value = event.target.value === 'true';
        this.selectedRecordingAddHLS = value;
        this.parameters.updateRecordingAddHLS(value);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StandardPanelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: StandardPanelComponent, isStandalone: true, selector: "app-standard-panel-component", inputs: { parameters: "parameters" }, usesOnChanges: true, ngImport: i0, template: "<div>\r\n  <!-- Media Options -->\r\n  <div>\r\n    <label style=\"margin-right:10px; font-weight: bold;\">Media Options:</label>\r\n    <select [(ngModel)]=\"selectedRecordingMediaOptions\" (change)=\"handleMediaOptionsChange($event)\">\r\n      <option value=\"video\">Record Video</option>\r\n      <option value=\"audio\">Record Audio Only</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Specific Audios -->\r\n  <div *ngIf=\"parameters.eventType !== 'broadcast'\">\r\n    <div>\r\n      <label style=\"margin-right:10px; font-weight: bold;\">Specific Audios:</label>\r\n      <select [(ngModel)]=\"selectedRecordingAudioOptions\" (change)=\"handleAudioOptionsChange($event)\">\r\n        <option value=\"all\">Add All</option>\r\n        <option value=\"onScreen\">Add All On Screen</option>\r\n        <option value=\"host\">Add Host Only</option>\r\n      </select>\r\n    </div>\r\n    <hr />\r\n\r\n    <!-- Specific Videos -->\r\n    <div id=\"conditionalConference\">\r\n      <label style=\"margin-right:10px; font-weight: bold;\">Specific Videos:</label>\r\n      <select [(ngModel)]=\"selectedRecordingVideoOptions\" (change)=\"handleVideoOptionsChange($event)\">\r\n        <option value=\"all\">Add All</option>\r\n        <option value=\"mainScreen\">Big Screen Only (includes screenshare)</option>\r\n      </select>\r\n    </div>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Add HLS -->\r\n  <div id=\"addHLSPart\">\r\n    <label style=\"margin-right:10px; font-weight: bold;\">Add HLS:</label>\r\n    <select [(ngModel)]=\"selectedRecordingAddHLS\" (change)=\"handleAddHLSChange($event)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$1.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StandardPanelComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-standard-panel-component', standalone: true, imports: [CommonModule, FormsModule], template: "<div>\r\n  <!-- Media Options -->\r\n  <div>\r\n    <label style=\"margin-right:10px; font-weight: bold;\">Media Options:</label>\r\n    <select [(ngModel)]=\"selectedRecordingMediaOptions\" (change)=\"handleMediaOptionsChange($event)\">\r\n      <option value=\"video\">Record Video</option>\r\n      <option value=\"audio\">Record Audio Only</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Specific Audios -->\r\n  <div *ngIf=\"parameters.eventType !== 'broadcast'\">\r\n    <div>\r\n      <label style=\"margin-right:10px; font-weight: bold;\">Specific Audios:</label>\r\n      <select [(ngModel)]=\"selectedRecordingAudioOptions\" (change)=\"handleAudioOptionsChange($event)\">\r\n        <option value=\"all\">Add All</option>\r\n        <option value=\"onScreen\">Add All On Screen</option>\r\n        <option value=\"host\">Add Host Only</option>\r\n      </select>\r\n    </div>\r\n    <hr />\r\n\r\n    <!-- Specific Videos -->\r\n    <div id=\"conditionalConference\">\r\n      <label style=\"margin-right:10px; font-weight: bold;\">Specific Videos:</label>\r\n      <select [(ngModel)]=\"selectedRecordingVideoOptions\" (change)=\"handleVideoOptionsChange($event)\">\r\n        <option value=\"all\">Add All</option>\r\n        <option value=\"mainScreen\">Big Screen Only (includes screenshare)</option>\r\n      </select>\r\n    </div>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Add HLS -->\r\n  <div id=\"addHLSPart\">\r\n    <label style=\"margin-right:10px; font-weight: bold;\">Add HLS:</label>\r\n    <select [(ngModel)]=\"selectedRecordingAddHLS\" (change)=\"handleAddHLSChange($event)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n</div>\r\n" }]
        }], propDecorators: { parameters: [{
                type: Input
            }] } });

class AdvancedPanelComponent {
    parameters = {};
    selectedOrientationVideo;
    selectedRecordingNameTags;
    selectedRecordingVideoType;
    selectedRecordingDisplayType;
    showBackgroundColorModal = false;
    showNameTagsColorModal = false;
    selectedColorType = '';
    recordingText;
    customText;
    recordingPosition;
    ngOnInit() {
        this.selectedOrientationVideo = this.parameters?.recordingOrientationVideo ?? '';
        this.selectedRecordingNameTags = this.parameters?.recordingNameTags ?? false;
        this.selectedRecordingVideoType = this.parameters?.recordingVideoType ?? '';
        this.selectedRecordingDisplayType = this.parameters?.recordingDisplayType ?? 'media';
        this.recordingText = this.parameters?.recordingAddText ?? false;
        this.customText = this.parameters?.recordingCustomText ?? '';
        this.recordingPosition = this.parameters?.recordingCustomTextPosition ?? '';
    }
    ngOnChanges(changes) {
        if (changes['parameters']) {
            this.parameters = changes['parameters'].currentValue;
            this.selectedOrientationVideo = this.parameters.recordingOrientationVideo;
            this.selectedRecordingNameTags = this.parameters.recordingNameTags;
            this.selectedRecordingVideoType = this.parameters.recordingVideoType;
            this.selectedRecordingDisplayType = this.parameters.recordingDisplayType;
            this.recordingText = this.parameters.recordingAddText;
            this.customText = this.parameters.recordingCustomText;
            this.recordingPosition = this.parameters.recordingCustomTextPosition;
        }
    }
    validateTextInput(input) {
        const regex = /^[a-zA-Z0-9\s]{1,40}$/;
        return regex.test(input);
    }
    handleTextChange(value) {
        this.recordingText = value;
        this.parameters.updateRecordingAddText(value);
    }
    onChangeTextHandler(text) {
        if (text && text.length > 0 && !this.validateTextInput(text)) {
            return;
        }
        this.parameters.updateRecordingCustomText(text);
        this.customText = text;
    }
    handleColorChange(selectedColor, event) {
        const input = event.target;
        const color = input.value;
        if (selectedColor === 'backgroundColor') {
            this.parameters.updateRecordingBackgroundColor(color);
        }
        else if (selectedColor === 'customTextColor') {
            this.parameters.updateRecordingCustomTextColor(color);
        }
        else if (selectedColor === 'nameTagsColor') {
            this.parameters.updateRecordingNameTagsColor(color);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AdvancedPanelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: AdvancedPanelComponent, isStandalone: true, selector: "app-advanced-panel-component", inputs: { parameters: "parameters" }, usesOnChanges: true, ngImport: i0, template: "<div>\r\n  <!-- Video Type -->\r\n  <div>\r\n    <label class=\"label\">Video Type:</label>\r\n    <select [(ngModel)]=\"selectedRecordingVideoType\" (change)=\"parameters.updateRecordingVideoType(selectedRecordingVideoType)\">\r\n      <option value=\"fullDisplay\">Full Display (no background)</option>\r\n      <option value=\"bestDisplay\">Full Video</option>\r\n      <option value=\"all\">All</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Display Type -->\r\n  <div *ngIf=\"parameters.eventType !== 'broadcast'\">\r\n    <label class=\"label\">Display Type:</label>\r\n    <select [(ngModel)]=\"selectedRecordingDisplayType\" (change)=\"parameters.updateRecordingDisplayType(selectedRecordingDisplayType)\">\r\n      <option value=\"video\">Only Video Participants</option>\r\n      <option value=\"videoOpt\">Only Video Participants (optimized)</option>\r\n      <option value=\"media\">Participants with media</option>\r\n      <option value=\"all\">All Participants</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Background Color -->\r\n  <div>\r\n    <label class=\"label\">Background Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingBackgroundColor}\">\r\n      {{ parameters.recordingBackgroundColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingBackgroundColor\" (change)=\"handleColorChange('backgroundColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Add Text -->\r\n  <div>\r\n    <label class=\"label\">Add Text:</label>\r\n    <select [(ngModel)]=\"recordingText\" (change)=\"handleTextChange(recordingText)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Custom Text -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text:</label>\r\n    <input type=\"text\" [(ngModel)]=\"customText\" (input)=\"onChangeTextHandler(customText)\" />\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Custom Text Position -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text Position:</label>\r\n    <select [(ngModel)]=\"recordingPosition\" (change)=\"parameters.updateRecordingCustomTextPosition(recordingPosition)\">\r\n      <option value=\"top\">Top</option>\r\n      <option value=\"middle\">Middle</option>\r\n      <option value=\"bottom\">Bottom</option>\r\n    </select>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Custom Text Color -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingCustomTextColor}\">\r\n      {{ parameters.recordingCustomTextColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingCustomTextColor\" (change)=\"handleColorChange('customTextColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Add Name Tags -->\r\n  <div>\r\n    <label class=\"label\">Add Name Tags:</label>\r\n    <select [(ngModel)]=\"selectedRecordingNameTags\" (change)=\"parameters.updateRecordingNameTags(selectedRecordingNameTags)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Name Tags Color -->\r\n  <div>\r\n    <label class=\"label\">Name Tags Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingNameTagsColor}\">\r\n      {{ parameters.recordingNameTagsColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingNameTagsColor\" (change)=\"handleColorChange('nameTagsColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Orientation (Video) -->\r\n  <div>\r\n    <label class=\"label\">Orientation (Video):</label>\r\n    <select [(ngModel)]=\"selectedOrientationVideo\" (change)=\"parameters.updateRecordingOrientationVideo(selectedOrientationVideo)\">\r\n      <option value=\"landscape\">Landscape</option>\r\n      <option value=\"portrait\">Portrait</option>\r\n      <option value=\"all\">All</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$1.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AdvancedPanelComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-advanced-panel-component', standalone: true, imports: [CommonModule, FormsModule], template: "<div>\r\n  <!-- Video Type -->\r\n  <div>\r\n    <label class=\"label\">Video Type:</label>\r\n    <select [(ngModel)]=\"selectedRecordingVideoType\" (change)=\"parameters.updateRecordingVideoType(selectedRecordingVideoType)\">\r\n      <option value=\"fullDisplay\">Full Display (no background)</option>\r\n      <option value=\"bestDisplay\">Full Video</option>\r\n      <option value=\"all\">All</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Display Type -->\r\n  <div *ngIf=\"parameters.eventType !== 'broadcast'\">\r\n    <label class=\"label\">Display Type:</label>\r\n    <select [(ngModel)]=\"selectedRecordingDisplayType\" (change)=\"parameters.updateRecordingDisplayType(selectedRecordingDisplayType)\">\r\n      <option value=\"video\">Only Video Participants</option>\r\n      <option value=\"videoOpt\">Only Video Participants (optimized)</option>\r\n      <option value=\"media\">Participants with media</option>\r\n      <option value=\"all\">All Participants</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Background Color -->\r\n  <div>\r\n    <label class=\"label\">Background Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingBackgroundColor}\">\r\n      {{ parameters.recordingBackgroundColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingBackgroundColor\" (change)=\"handleColorChange('backgroundColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Add Text -->\r\n  <div>\r\n    <label class=\"label\">Add Text:</label>\r\n    <select [(ngModel)]=\"recordingText\" (change)=\"handleTextChange(recordingText)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Custom Text -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text:</label>\r\n    <input type=\"text\" [(ngModel)]=\"customText\" (input)=\"onChangeTextHandler(customText)\" />\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Custom Text Position -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text Position:</label>\r\n    <select [(ngModel)]=\"recordingPosition\" (change)=\"parameters.updateRecordingCustomTextPosition(recordingPosition)\">\r\n      <option value=\"top\">Top</option>\r\n      <option value=\"middle\">Middle</option>\r\n      <option value=\"bottom\">Bottom</option>\r\n    </select>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Custom Text Color -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingCustomTextColor}\">\r\n      {{ parameters.recordingCustomTextColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingCustomTextColor\" (change)=\"handleColorChange('customTextColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Add Name Tags -->\r\n  <div>\r\n    <label class=\"label\">Add Name Tags:</label>\r\n    <select [(ngModel)]=\"selectedRecordingNameTags\" (change)=\"parameters.updateRecordingNameTags(selectedRecordingNameTags)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Name Tags Color -->\r\n  <div>\r\n    <label class=\"label\">Name Tags Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingNameTagsColor}\">\r\n      {{ parameters.recordingNameTagsColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingNameTagsColor\" (change)=\"handleColorChange('nameTagsColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Orientation (Video) -->\r\n  <div>\r\n    <label class=\"label\">Orientation (Video):</label>\r\n    <select [(ngModel)]=\"selectedOrientationVideo\" (change)=\"parameters.updateRecordingOrientationVideo(selectedOrientationVideo)\">\r\n      <option value=\"landscape\">Landscape</option>\r\n      <option value=\"portrait\">Portrait</option>\r\n      <option value=\"all\">All</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n</div>\r\n" }]
        }], propDecorators: { parameters: [{
                type: Input
            }] } });

/**
 * Component representing a recording modal.
 *
 * @selector app-recording-modal
 * @standalone true
 * @imports CommonModule, FontAwesomeModule, StandardPanelComponent, AdvancedPanelComponent
 * @templateUrl ./recording-modal.component.html
 * @styleUrls ./recording-modal.component.css
 *
 * @class RecordingModal
 * @implements OnChanges
 *
 * @property {boolean} isRecordingModalVisible - Determines if the recording modal is visible.
 * @property {() => void} onClose - Callback function to close the modal.
 * @property {string} backgroundColor - Background color of the modal.
 * @property {string} position - Position of the modal on the screen.
 * @property {(options: ConfirmRecordingOptions) => void} confirmRecording - Callback function to confirm recording.
 * @property {(options: StartRecordingOptions) => void} startRecording - Callback function to start recording.
 * @property {RecordingModalParameters} parameters - Parameters for the recording modal.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for times (close).
 * @property {IconDefinition} faCheck - FontAwesome icon for check (confirm).
 * @property {IconDefinition} faPlay - FontAwesome icon for play (start).
 *
 * @method modalContainerStyle - Returns the style object for the modal container.
 * @method modalContentStyle - Returns the style object for the modal content.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property of a directive changes.
 * @method confirm - Calls the confirmRecording callback with the current parameters.
 * @method start - Calls the startRecording callback with the current parameters.
 */
class RecordingModal {
    isRecordingModalVisible = false;
    onClose;
    backgroundColor = '#83c0e9';
    position = 'bottomRight';
    confirmRecording;
    startRecording;
    parameters = {};
    faTimes = faTimes;
    faCheck = faCheck;
    faPlay = faPlay;
    get modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isRecordingModalVisible ? 'block' : 'none',
            zIndex: 999,
        };
    }
    get modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        return {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxHeight: '85%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    ngOnChanges(changes) {
        if (changes['isRecordingModalVisible']) {
            if (this.parameters) {
                this.parameters = this.parameters.getUpdatedAllParams();
            }
        }
    }
    confirm() {
        this.confirmRecording({
            parameters: { ...this.parameters },
        });
    }
    start() {
        this.startRecording({
            parameters: { ...this.parameters },
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordingModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: RecordingModal, isStandalone: true, selector: "app-recording-modal", inputs: { isRecordingModalVisible: "isRecordingModalVisible", onClose: "onClose", backgroundColor: "backgroundColor", position: "position", confirmRecording: "confirmRecording", startRecording: "startRecording", parameters: "parameters" }, usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div style=\"display: flex; flex-direction: column;\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">\r\n          Recording Settings\r\n        </h2>\r\n        <button (click)=\"onClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n      <div style=\"flex: 1;\">\r\n        <div style=\"overflow-y: auto; max-height: calc(100% - 120px); padding: 0;\">\r\n          <div style=\"margin: 0; padding: 0;\">\r\n            <app-standard-panel-component [parameters]=\"parameters\"></app-standard-panel-component>\r\n            <app-advanced-panel-component [parameters]=\"parameters\"></app-advanced-panel-component>\r\n          </div>\r\n        </div>\r\n        <div style=\"height: 1px; background-color: white; \"></div>\r\n        <div style=\"display: flex; justify-content: space-between; margin-top: 20px;\">\r\n          <button\r\n            (click)=\"confirm()\"\r\n            style=\"flex: 1; padding: 5px; border-radius: 5px; justify-content: center; align-items: center; margin: 0 10px; background: #4CAF50; cursor: pointer;\">\r\n            <span style=\"color: black; font-size: 14px;\">Confirm</span>\r\n          </button>\r\n          <button *ngIf=\"!parameters.recordPaused\"\r\n            (click)=\"start()\"\r\n            style=\"flex: 1; padding: 5px; border-radius: 5px; justify-content: center; align-items: center; margin: 0 10px; background: #f44336; cursor: pointer;\">\r\n            <span style=\"color: black; font-size: 14px;\">Start <fa-icon [icon]=\"faPlay\"></fa-icon></span>\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: StandardPanelComponent, selector: "app-standard-panel-component", inputs: ["parameters"] }, { kind: "component", type: AdvancedPanelComponent, selector: "app-advanced-panel-component", inputs: ["parameters"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordingModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-recording-modal', standalone: true, imports: [CommonModule, FontAwesomeModule, StandardPanelComponent, AdvancedPanelComponent], template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div style=\"display: flex; flex-direction: column;\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">\r\n          Recording Settings\r\n        </h2>\r\n        <button (click)=\"onClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n      <div style=\"flex: 1;\">\r\n        <div style=\"overflow-y: auto; max-height: calc(100% - 120px); padding: 0;\">\r\n          <div style=\"margin: 0; padding: 0;\">\r\n            <app-standard-panel-component [parameters]=\"parameters\"></app-standard-panel-component>\r\n            <app-advanced-panel-component [parameters]=\"parameters\"></app-advanced-panel-component>\r\n          </div>\r\n        </div>\r\n        <div style=\"height: 1px; background-color: white; \"></div>\r\n        <div style=\"display: flex; justify-content: space-between; margin-top: 20px;\">\r\n          <button\r\n            (click)=\"confirm()\"\r\n            style=\"flex: 1; padding: 5px; border-radius: 5px; justify-content: center; align-items: center; margin: 0 10px; background: #4CAF50; cursor: pointer;\">\r\n            <span style=\"color: black; font-size: 14px;\">Confirm</span>\r\n          </button>\r\n          <button *ngIf=\"!parameters.recordPaused\"\r\n            (click)=\"start()\"\r\n            style=\"flex: 1; padding: 5px; border-radius: 5px; justify-content: center; align-items: center; margin: 0 10px; background: #f44336; cursor: pointer;\">\r\n            <span style=\"color: black; font-size: 14px;\">Start <fa-icon [icon]=\"faPlay\"></fa-icon></span>\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n" }]
        }], propDecorators: { isRecordingModalVisible: [{
                type: Input
            }], onClose: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], position: [{
                type: Input
            }], confirmRecording: [{
                type: Input
            }], startRecording: [{
                type: Input
            }], parameters: [{
                type: Input
            }] } });

class RenderRequestComponent {
    request = {};
    requestList = [];
    roomName;
    socket = {};
    onRequestItemPress;
    updateRequestList;
    faMicrophone = faMicrophone;
    faDesktop = faDesktop;
    faVideo = faVideo;
    faComments = faComments;
    faCheck = faCheck;
    faTimes = faTimes;
    keyMap = {
        'fa-microphone': this.faMicrophone,
        'fa-desktop': this.faDesktop,
        'fa-video': this.faVideo,
        'fa-comments': this.faComments,
    };
    getIcon(iconName) {
        return this.keyMap[iconName];
    }
    handleRequestAction = (action) => {
        this.onRequestItemPress({
            request: this.request,
            updateRequestList: this.updateRequestList,
            requestList: this.requestList,
            action: action,
            roomName: this.roomName,
            socket: this.socket,
        });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RenderRequestComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: RenderRequestComponent, isStandalone: true, selector: "app-render-request-component", inputs: { request: "request", requestList: "requestList", roomName: "roomName", socket: "socket", onRequestItemPress: "onRequestItemPress", updateRequestList: "updateRequestList" }, ngImport: i0, template: "<div class=\"request-container\" *ngIf=\"request\">\r\n  <div class=\"request-name\">{{ request.name }}</div>\r\n  <div class=\"request-icon\">\r\n    <fa-icon [icon]=\"getIcon(request.icon)\" size=\"lg\" color=\"black\"></fa-icon>\r\n  </div>\r\n  <div class=\"request-action accept\">\r\n    <button (click)=\"handleRequestAction('accepted')\">\r\n      <fa-icon [icon]=\"faCheck\" size=\"lg\" style=\"color: green;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div class=\"request-action reject\">\r\n    <button (click)=\"handleRequestAction('rejected')\">\r\n      <fa-icon [icon]=\"faTimes\" size=\"lg\" style=\"color: red;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".request-container{display:flex;flex-direction:row;align-items:center;margin:10px 0;padding-bottom:5px}.request-name{flex:5}.request-icon,.request-action{flex:2;display:flex;justify-content:center;align-items:center}.request-action{padding-right:10px}.request-action.accept,.request-action.reject{margin-right:10px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RenderRequestComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-render-request-component', standalone: true, imports: [CommonModule, FontAwesomeModule], template: "<div class=\"request-container\" *ngIf=\"request\">\r\n  <div class=\"request-name\">{{ request.name }}</div>\r\n  <div class=\"request-icon\">\r\n    <fa-icon [icon]=\"getIcon(request.icon)\" size=\"lg\" color=\"black\"></fa-icon>\r\n  </div>\r\n  <div class=\"request-action accept\">\r\n    <button (click)=\"handleRequestAction('accepted')\">\r\n      <fa-icon [icon]=\"faCheck\" size=\"lg\" style=\"color: green;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div class=\"request-action reject\">\r\n    <button (click)=\"handleRequestAction('rejected')\">\r\n      <fa-icon [icon]=\"faTimes\" size=\"lg\" style=\"color: red;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".request-container{display:flex;flex-direction:row;align-items:center;margin:10px 0;padding-bottom:5px}.request-name{flex:5}.request-icon,.request-action{flex:2;display:flex;justify-content:center;align-items:center}.request-action{padding-right:10px}.request-action.accept,.request-action.reject{margin-right:10px}\n"] }]
        }], propDecorators: { request: [{
                type: Input
            }], requestList: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], onRequestItemPress: [{
                type: Input
            }], updateRequestList: [{
                type: Input
            }] } });

class RespondToRequests {
    /**
     * Responds to incoming requests by updating the request list and emitting a response to the server.
     *
     * @param {Object} options - The options for responding to requests.
     * @param {Socket} options.socket - The socket instance used to emit the response.
     * @param {Request} options.request - The request object containing details of the request.
     * @param {Function} options.updateRequestList - The function to update the request list.
     * @param {Request[]} options.requestList - The current list of requests.
     * @param {string} options.action - The action to be taken on the request.
     * @param {string} options.roomName - The name of the room to which the response should be emitted.
     *
     * @returns {Promise<void>} A promise that resolves when the response has been emitted.
     */
    async respondToRequests({ socket, request, updateRequestList, requestList, action, roomName, }) {
        // Filter out the request that is being responded to
        let newRequestList = requestList.filter((request_) => {
            return !(request_.id === request.id &&
                request_.icon === request.icon &&
                request_.name === request.name);
        });
        // Update the request list
        updateRequestList(newRequestList);
        // Prepare the request response object
        let requestResponse = {
            id: request.id,
            name: request.name,
            type: request.icon,
            action: action,
        };
        // Emit the response via the socket
        socket.emit('updateUserofRequestStatus', { requestResponse, roomName });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RespondToRequests, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RespondToRequests, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RespondToRequests, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * @component RequestsModal
 * @description A modal component to display and manage requests.
 *
 * @selector app-requests-modal
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule, RenderRequestComponent]
 * @templateUrl ./requests-modal.component.html
 * @styleUrls ./requests-modal.component.css
 *
 * @property {boolean} isRequestsModalVisible - Determines if the requests modal is visible.
 * @property {number} requestCounter - Counter for the number of requests.
 * @property {Request[]} requestList - List of requests.
 * @property {string} roomName - Name of the room.
 * @property {Socket} socket - Socket instance for communication.
 * @property {string} backgroundColor - Background color of the modal.
 * @property {string} position - Position of the modal.
 * @property {any} parameters - Additional parameters for the modal.
 * @property {Function} onRequestClose - Callback function when the modal is closed.
 * @property {Function} onRequestFilterChange - Callback function when the request filter changes.
 * @property {Function} onRequestItemPress - Callback function when a request item is pressed.
 * @property {Function} updateRequestList - Function to update the request list.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for closing the modal.
 * @property {any[]} requestList_s - Filtered list of requests.
 * @property {number} requestCounter_s - Counter for the filtered list of requests.
 * @property {boolean} reRender - Flag to trigger re-rendering.
 *
 * @constructor
 * @param {RespondToRequests} respondToRequestsService - Service to handle request responses.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes.
 * @param {SimpleChanges} changes - Object of current and previous property values.
 *
 * @method updateRequests - Updates the request list and counter based on the current parameters.
 * @method handleModalClose - Handles the modal close action.
 * @method handleFilterChange - Handles the filter change event.
 * @param {Event} event - The filter change event.
 */
class RequestsModal {
    respondToRequestsService;
    isRequestsModalVisible = false;
    requestCounter = 0;
    requestList = [];
    roomName;
    socket = {};
    backgroundColor = '#83c0e9';
    position = 'topRight';
    parameters;
    onRequestClose;
    onRequestFilterChange;
    onRequestItemPress;
    updateRequestList;
    faTimes = faTimes;
    requestList_s = [];
    requestCounter_s = 0;
    reRender = false;
    constructor(respondToRequestsService) {
        this.respondToRequestsService = respondToRequestsService;
    }
    ngOnInit() {
        if (!this.onRequestItemPress) {
            this.onRequestItemPress = (params) => this.respondToRequestsService.respondToRequests(params);
        }
    }
    ngOnChanges(changes) {
        if (changes['requestList'] || changes['reRender'] || changes['requestCounter']) {
            this.updateRequests();
        }
        if (changes['isRequestsModalVisible'] && this.isRequestsModalVisible) {
            this.parameters = this.parameters.getUpdatedAllParams();
            this.updateRequests();
        }
    }
    updateRequests() {
        this.parameters = this.parameters.getUpdatedAllParams();
        this.requestList_s = this.parameters.filteredRequestList || [];
        this.requestCounter_s = this.parameters.filteredRequestList.length;
    }
    handleModalClose() {
        this.onRequestClose();
    }
    handleFilterChange(event) {
        const input = event.target;
        this.onRequestFilterChange(input.value);
        this.parameters = this.parameters.getUpdatedAllParams();
        this.reRender = !this.reRender;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RequestsModal, deps: [{ token: RespondToRequests }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: RequestsModal, isStandalone: true, selector: "app-requests-modal", inputs: { isRequestsModalVisible: "isRequestsModalVisible", requestCounter: "requestCounter", requestList: "requestList", roomName: "roomName", socket: "socket", backgroundColor: "backgroundColor", position: "position", parameters: "parameters", onRequestClose: "onRequestClose", onRequestFilterChange: "onRequestFilterChange", onRequestItemPress: "onRequestItemPress", updateRequestList: "updateRequestList" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isRequestsModalVisible\" class=\"modal-container\" [ngStyle]=\"{'background-color': 'rgba(0, 0, 0, 0.5)'}\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{'background-color': backgroundColor, 'top': position.includes('top') ? '10px' : 'auto', 'bottom': position.includes('bottom') ? '10px' : 'auto', 'left': position.includes('Left') ? '10px' : 'auto', 'right': position.includes('Right') ? '10px' : 'auto'}\">\r\n    <div class=\"modal-header\">\r\n      <div>\r\n        Requests <span class=\"badge text-dark\">{{ requestCounter_s }}</span>\r\n      </div>\r\n      <div class=\"close-icon\" (click)=\"handleModalClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"lg\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"separator\" />\r\n    <div class=\"modal-body\">\r\n      <input type=\"text\" class=\"filter-input\" placeholder=\"Search ...\" (input)=\"handleFilterChange($event)\">\r\n      <div class=\"request-list\">\r\n        <ng-container *ngFor=\"let requestItem of requestList_s; let i = index\">\r\n          <app-render-request-component\r\n            [request]=\"requestItem\"\r\n            [requestList]=\"requestList\"\r\n            [roomName]=\"roomName\"\r\n            [socket]=\"socket\"\r\n            [onRequestItemPress]=\"onRequestItemPress\"\r\n            [updateRequestList]=\"updateRequestList\">\r\n          </app-render-request-component>\r\n        </ng-container>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:350px;max-height:65%;overflow-y:auto;top:10px;right:10px}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.close-button{border:none;background:none;cursor:pointer}.separator{height:1px;background-color:#000;margin:5px 0}.modal-body{margin-bottom:20px}.filter-input{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}.request-list{max-height:calc(100% - 150px);overflow-y:auto}.icon{font-size:20px;color:#000}.text-dark{color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: RenderRequestComponent, selector: "app-render-request-component", inputs: ["request", "requestList", "roomName", "socket", "onRequestItemPress", "updateRequestList"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RequestsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-requests-modal', standalone: true, imports: [CommonModule, FontAwesomeModule, RenderRequestComponent], template: "<div *ngIf=\"isRequestsModalVisible\" class=\"modal-container\" [ngStyle]=\"{'background-color': 'rgba(0, 0, 0, 0.5)'}\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{'background-color': backgroundColor, 'top': position.includes('top') ? '10px' : 'auto', 'bottom': position.includes('bottom') ? '10px' : 'auto', 'left': position.includes('Left') ? '10px' : 'auto', 'right': position.includes('Right') ? '10px' : 'auto'}\">\r\n    <div class=\"modal-header\">\r\n      <div>\r\n        Requests <span class=\"badge text-dark\">{{ requestCounter_s }}</span>\r\n      </div>\r\n      <div class=\"close-icon\" (click)=\"handleModalClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"lg\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"separator\" />\r\n    <div class=\"modal-body\">\r\n      <input type=\"text\" class=\"filter-input\" placeholder=\"Search ...\" (input)=\"handleFilterChange($event)\">\r\n      <div class=\"request-list\">\r\n        <ng-container *ngFor=\"let requestItem of requestList_s; let i = index\">\r\n          <app-render-request-component\r\n            [request]=\"requestItem\"\r\n            [requestList]=\"requestList\"\r\n            [roomName]=\"roomName\"\r\n            [socket]=\"socket\"\r\n            [onRequestItemPress]=\"onRequestItemPress\"\r\n            [updateRequestList]=\"updateRequestList\">\r\n          </app-render-request-component>\r\n        </ng-container>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:350px;max-height:65%;overflow-y:auto;top:10px;right:10px}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.close-button{border:none;background:none;cursor:pointer}.separator{height:1px;background-color:#000;margin:5px 0}.modal-body{margin-bottom:20px}.filter-input{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}.request-list{max-height:calc(100% - 150px);overflow-y:auto}.icon{font-size:20px;color:#000}.text-dark{color:#000}\n"] }]
        }], ctorParameters: () => [{ type: RespondToRequests }], propDecorators: { isRequestsModalVisible: [{
                type: Input
            }], requestCounter: [{
                type: Input
            }], requestList: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], position: [{
                type: Input
            }], parameters: [{
                type: Input
            }], onRequestClose: [{
                type: Input
            }], onRequestFilterChange: [{
                type: Input
            }], onRequestItemPress: [{
                type: Input
            }], updateRequestList: [{
                type: Input
            }] } });

class RespondToWaiting {
    /**
     * Responds to a participant waiting to join a room by either allowing or denying their entry.
     *
     * @param {Object} options - The options for responding to the waiting participant.
     * @param {string} options.participantId - The ID of the participant.
     * @param {string} options.participantName - The name of the participant.
     * @param {Function} options.updateWaitingList - The function to update the waiting list.
     * @param {Array} options.waitingList - The current waiting list of participants.
     * @param {boolean | string} options.type - The type of response, either "true" or "false".
     * @param {string} options.roomName - The name of the room.
     * @param {Object} options.socket - The socket instance to emit events.
     * @returns {Promise<void>} - A promise that resolves when the response has been processed.
     */
    async respondToWaiting({ participantId, participantName, updateWaitingList, waitingList, type, roomName, socket, }) {
        // Filter out the participant from the waiting list
        const newWaitingList = waitingList.filter((item) => item.name !== participantName);
        // Update the waiting list
        updateWaitingList(newWaitingList);
        const responseType = type === 'true' || type === true ? 'true' : 'false';
        // Emit an event to allow or deny the participant based on the response type
        await socket.emit('allowUserIn', {
            participantId,
            participantName,
            type: responseType,
            roomName,
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RespondToWaiting, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RespondToWaiting, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RespondToWaiting, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/* eslint-disable @typescript-eslint/no-empty-function */
class WaitingRoomModal {
    respondToWaitingService;
    constructor(respondToWaitingService) {
        this.respondToWaitingService = respondToWaitingService;
    }
    isWaitingModalVisible = false;
    waitingRoomCounter = 0;
    waitingRoomList = [];
    roomName = '';
    socket = {};
    position = 'topRight';
    backgroundColor = '#83c0e9';
    parameters = {};
    onWaitingRoomClose = () => { };
    onWaitingRoomFilterChange = () => { };
    updateWaitingList = () => { };
    onWaitingRoomItemPress;
    faTimes = faTimes;
    faCheck = faCheck;
    waitingRoomList_s = [];
    waitingRoomCounter_s = 0;
    reRender = false;
    ngOnInit() {
        if (!this.onWaitingRoomItemPress) {
            this.onWaitingRoomItemPress = (data) => this.respondToWaitingService.respondToWaiting(data);
        }
    }
    ngOnChanges(changes) {
        if (changes['waitingRoomList'] || changes['reRender']) {
            this.updateParameters();
        }
    }
    updateParameters() {
        let { getUpdatedAllParams } = this.parameters;
        this.parameters = getUpdatedAllParams();
        this.waitingRoomList_s = this.parameters.filteredWaitingRoomList;
        this.waitingRoomCounter_s = this.parameters.filteredWaitingRoomList.length;
    }
    handleModalClose() {
        this.onWaitingRoomClose();
    }
    handleFilterChange(event) {
        const inputElement = event.target;
        const value = inputElement?.value || '';
        this.onWaitingRoomFilterChange(value);
        this.reRender = !this.reRender;
    }
    handleItemPress(participant, type) {
        this.onWaitingRoomItemPress({
            participantId: participant.id,
            participantName: participant.name,
            updateWaitingList: this.updateWaitingList,
            waitingList: this.waitingRoomList,
            roomName: this.roomName,
            type: type, // true for accepted, false for rejected
            socket: this.socket,
        });
    }
    get modalContainerStyle() {
        return {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isWaitingModalVisible ? 'block' : 'none',
            zIndex: '999',
        };
    }
    get modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        return {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxHeight: '65%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    get inputStyle() {
        return {
            width: '90%',
            padding: '10px',
            borderRadius: '5px',
            border: '1px solid #000',
            fontSize: '16px',
            marginBottom: '10px',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: WaitingRoomModal, deps: [{ token: RespondToWaiting }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: WaitingRoomModal, isStandalone: true, selector: "app-waiting-room-modal", inputs: { isWaitingModalVisible: "isWaitingModalVisible", waitingRoomCounter: "waitingRoomCounter", waitingRoomList: "waitingRoomList", roomName: "roomName", socket: "socket", position: "position", backgroundColor: "backgroundColor", parameters: "parameters", onWaitingRoomClose: "onWaitingRoomClose", onWaitingRoomFilterChange: "onWaitingRoomFilterChange", updateWaitingList: "updateWaitingList", onWaitingRoomItemPress: "onWaitingRoomItemPress" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isWaitingModalVisible\" [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">\r\n        Waiting <span class=\"badge\">{{ waitingRoomCounter_s }}</span>\r\n      </div>\r\n      <div (click)=\"handleModalClose()\" class=\"btn-close-waitings\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <input\r\n          class=\"form-control\"\r\n          [ngStyle]=\"inputStyle\"\r\n          placeholder=\"Search ...\"\r\n          (input)=\"handleFilterChange($event)\"\r\n        />\r\n      </div>\r\n      <div class=\"waiting-list\">\r\n        <div\r\n          *ngFor=\"let participant of waitingRoomList_s\"\r\n          class=\"waiting-item\"\r\n        >\r\n          <div class=\"col7\">{{ participant.name }}</div>\r\n          <div class=\"col2\">\r\n            <button (click)=\"handleItemPress(participant, true)\">\r\n              <fa-icon [icon]=\"faCheck\" size=\"lg\" color=\"green\"></fa-icon>\r\n            </button>\r\n          </div>\r\n          <div class=\"col2\">\r\n            <button (click)=\"handleItemPress(participant, false)\">\r\n              <fa-icon [icon]=\"faTimes\" size=\"lg\" color=\"red\"></fa-icon>\r\n            </button>\r\n          </div>\r\n          <div class=\"col1\"></div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;max-height:65%;overflow-y:auto;top:10px;right:10px;width:80vw;max-width:350px}.form-control{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}.modal-header{display:flex;justify-content:space-between;align-items:center}.modal-title{font-size:1.2em}.badge{background-color:#fff;color:#000;border-radius:10px;padding:5px}.btn-close-waitings{cursor:pointer}.waiting-list{display:flex;flex-direction:column}.waiting-item{display:flex;flex-direction:row;margin-top:5px}.col7{flex:5;display:flex;align-items:center}.col2{flex:2;display:flex;align-items:center;justify-content:center}.col1{flex:1}.hr{margin:.5em 0;border:0;border-top:1px solid #ccc}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: WaitingRoomModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-waiting-room-modal', standalone: true, imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div *ngIf=\"isWaitingModalVisible\" [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">\r\n        Waiting <span class=\"badge\">{{ waitingRoomCounter_s }}</span>\r\n      </div>\r\n      <div (click)=\"handleModalClose()\" class=\"btn-close-waitings\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <input\r\n          class=\"form-control\"\r\n          [ngStyle]=\"inputStyle\"\r\n          placeholder=\"Search ...\"\r\n          (input)=\"handleFilterChange($event)\"\r\n        />\r\n      </div>\r\n      <div class=\"waiting-list\">\r\n        <div\r\n          *ngFor=\"let participant of waitingRoomList_s\"\r\n          class=\"waiting-item\"\r\n        >\r\n          <div class=\"col7\">{{ participant.name }}</div>\r\n          <div class=\"col2\">\r\n            <button (click)=\"handleItemPress(participant, true)\">\r\n              <fa-icon [icon]=\"faCheck\" size=\"lg\" color=\"green\"></fa-icon>\r\n            </button>\r\n          </div>\r\n          <div class=\"col2\">\r\n            <button (click)=\"handleItemPress(participant, false)\">\r\n              <fa-icon [icon]=\"faTimes\" size=\"lg\" color=\"red\"></fa-icon>\r\n            </button>\r\n          </div>\r\n          <div class=\"col1\"></div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;max-height:65%;overflow-y:auto;top:10px;right:10px;width:80vw;max-width:350px}.form-control{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}.modal-header{display:flex;justify-content:space-between;align-items:center}.modal-title{font-size:1.2em}.badge{background-color:#fff;color:#000;border-radius:10px;padding:5px}.btn-close-waitings{cursor:pointer}.waiting-list{display:flex;flex-direction:column}.waiting-item{display:flex;flex-direction:row;margin-top:5px}.col7{flex:5;display:flex;align-items:center}.col2{flex:2;display:flex;align-items:center;justify-content:center}.col1{flex:1}.hr{margin:.5em 0;border:0;border-top:1px solid #ccc}\n"] }]
        }], ctorParameters: () => [{ type: RespondToWaiting }], propDecorators: { isWaitingModalVisible: [{
                type: Input
            }], waitingRoomCounter: [{
                type: Input
            }], waitingRoomList: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], parameters: [{
                type: Input
            }], onWaitingRoomClose: [{
                type: Input
            }], onWaitingRoomFilterChange: [{
                type: Input
            }], updateWaitingList: [{
                type: Input
            }], onWaitingRoomItemPress: [{
                type: Input
            }] } });

class ModifyDisplaySettings {
    /**
     * Modifies the display settings based on the provided parameters.
     *
     * @param {ModifyDisplaySettingsOptions} options - The options containing the parameters to modify the display settings.
     * @param {Object} options.parameters - The parameters for modifying the display settings.
     * @param {Function} options.parameters.showAlert - Function to show alert messages.
     * @param {string} options.parameters.meetingDisplayType - The current meeting display type.
     * @param {boolean} options.parameters.autoWave - Flag indicating if auto wave is enabled.
     * @param {boolean} options.parameters.forceFullDisplay - Flag indicating if full display is forced.
     * @param {boolean} options.parameters.meetingVideoOptimized - Flag indicating if the meeting video is optimized.
     * @param {string} options.parameters.islevel - The current level of the meeting.
     * @param {boolean} options.parameters.recordStarted - Flag indicating if recording has started.
     * @param {boolean} options.parameters.recordResumed - Flag indicating if recording has resumed.
     * @param {boolean} options.parameters.recordStopped - Flag indicating if recording has stopped.
     * @param {boolean} options.parameters.recordPaused - Flag indicating if recording is paused.
     * @param {string} options.parameters.recordingDisplayType - The current recording display type.
     * @param {boolean} options.parameters.recordingVideoOptimized - Flag indicating if the recording video is optimized.
     * @param {string} options.parameters.prevForceFullDisplay - The previous force full display value.
     * @param {string} options.parameters.prevMeetingDisplayType - The previous meeting display type.
     * @param {Function} options.parameters.updateMeetingDisplayType - Function to update the meeting display type.
     * @param {Function} options.parameters.updateAutoWave - Function to update the auto wave setting.
     * @param {Function} options.parameters.updateForceFullDisplay - Function to update the force full display setting.
     * @param {Function} options.parameters.updateMeetingVideoOptimized - Function to update the meeting video optimization setting.
     * @param {Function} options.parameters.updatePrevForceFullDisplay - Function to update the previous force full display setting.
     * @param {Function} options.parameters.updatePrevMeetingDisplayType - Function to update the previous meeting display type.
     * @param {Function} options.parameters.updateIsDisplaySettingsModalVisible - Function to update the visibility of the display settings modal.
     * @param {Function} options.parameters.updateFirstAll - Function to update the first all setting.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
     * @param {boolean} options.parameters.breakOutRoomStarted - Flag indicating if a breakout room has started.
     * @param {boolean} options.parameters.breakOutRoomEnded - Flag indicating if a breakout room has ended.
     * @param {Function} options.parameters.onScreenChanges - Function to handle screen changes.
     *
     * @returns {Promise<void>} A promise that resolves when the display settings have been modified.
     */
    modifyDisplaySettings = async ({ parameters }) => {
        // Destructure the parameters
        let { showAlert, meetingDisplayType, autoWave, forceFullDisplay, meetingVideoOptimized, islevel, recordStarted, recordResumed, recordStopped, recordPaused, recordingDisplayType, recordingVideoOptimized, prevForceFullDisplay, prevMeetingDisplayType, updateMeetingDisplayType, updateAutoWave, updateForceFullDisplay, updateMeetingVideoOptimized, updatePrevForceFullDisplay, updatePrevMeetingDisplayType, updateIsDisplaySettingsModalVisible, updateFirstAll, updateUpdateMainWindow, breakOutRoomStarted, breakOutRoomEnded, onScreenChanges, } = parameters;
        // Update previous states
        updateAutoWave(autoWave);
        updateForceFullDisplay(forceFullDisplay);
        if (islevel === '2' && (recordStarted || recordResumed) && !recordStopped && !recordPaused) {
            if (recordingDisplayType === 'video' &&
                meetingDisplayType === 'video' &&
                meetingVideoOptimized &&
                !recordingVideoOptimized) {
                showAlert?.({
                    message: 'Meeting display type can be either video, media, or all when recording display type is non-optimized video.',
                    type: 'danger',
                    duration: 3000,
                });
                // Reset to previous values or handle as needed
                meetingDisplayType = recordingDisplayType;
                updateMeetingDisplayType(meetingDisplayType);
                meetingVideoOptimized = recordingVideoOptimized;
                updateMeetingVideoOptimized(meetingVideoOptimized);
                return;
            }
            else if (recordingDisplayType === 'media' && meetingDisplayType === 'video') {
                showAlert?.({
                    message: 'Meeting display type can be either media or all when recording display type is media.',
                    type: 'danger',
                    duration: 3000,
                });
                // Reset to previous values or handle as needed
                meetingDisplayType = recordingDisplayType;
                updateMeetingDisplayType(meetingDisplayType);
                return;
            }
            else if (recordingDisplayType === 'all' &&
                (meetingDisplayType === 'video' || meetingDisplayType === 'media')) {
                showAlert?.({
                    message: 'Meeting display type can be only all when recording display type is all.',
                    type: 'danger',
                    duration: 3000,
                });
                // Reset to previous values or handle as needed
                meetingDisplayType = recordingDisplayType;
                updateMeetingDisplayType(meetingDisplayType);
                return;
            }
        }
        updateMeetingDisplayType(meetingDisplayType);
        updateMeetingVideoOptimized(meetingVideoOptimized);
        // Close the modal or perform additional actions
        updateIsDisplaySettingsModalVisible(false);
        if (prevMeetingDisplayType !== meetingDisplayType ||
            prevForceFullDisplay !== forceFullDisplay) {
            if (breakOutRoomStarted && !breakOutRoomEnded && meetingDisplayType !== 'all') {
                showAlert?.({
                    message: 'Breakout room is active. Display type can only be all.',
                    type: 'danger',
                });
                meetingDisplayType = prevMeetingDisplayType;
                updateMeetingDisplayType(prevMeetingDisplayType);
                return;
            }
            updateFirstAll(meetingDisplayType !== 'all' ? true : false);
            updateUpdateMainWindow(true);
            await onScreenChanges({
                changed: true,
                parameters: { ...parameters, meetingDisplayType, forceFullDisplay },
            });
            updatePrevForceFullDisplay(forceFullDisplay);
            updatePrevMeetingDisplayType(meetingDisplayType);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ModifyDisplaySettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ModifyDisplaySettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ModifyDisplaySettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Component for displaying and modifying display settings in a modal.
 *
 * @selector app-display-settings-modal
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule, FormsModule]
 * @templateUrl ./display-settings-modal.component.html
 * @styleUrls ['./display-settings-modal.component.css']
 *
 * @property {boolean} isDisplaySettingsModalVisible - Determines if the display settings modal is visible.
 * @property {() => void} onDisplaySettingsClose - Callback function to handle closing the display settings modal.
 * @property {(params: any) => void} onModifyDisplaySettings - Callback function to handle modifying display settings.
 * @property {DisplaySettingsModalParameters} parameters - Parameters for the display settings modal.
 * @property {string} position - Position of the modal on the screen. Default is 'topRight'.
 * @property {string} backgroundColor - Background color of the modal. Default is '#83c0e9'.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for the close button.
 *
 * @property {string} meetingDisplayTypeState - State for the meeting display type.
 * @property {boolean} autoWaveState - State for the auto wave setting. Default is false.
 * @property {boolean} forceFullDisplayState - State for the force full display setting. Default is false.
 * @property {boolean} meetingVideoOptimizedState - State for the meeting video optimized setting. Default is false.
 *
 * @constructor
 * @param {ModifyDisplaySettings} modifyDisplaySettingsService - Service to modify display settings.
 *
 * @method ngOnInit - Initializes the component and sets the initial state based on the input parameters.
 * @method handleSaveSettings - Handles saving the modified display settings.
 */
class DisplaySettingsModal {
    modifyDisplaySettingsService;
    isDisplaySettingsModalVisible = false;
    onDisplaySettingsClose;
    onModifyDisplaySettings;
    parameters;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    faTimes = faTimes;
    meetingDisplayTypeState;
    autoWaveState = false;
    forceFullDisplayState = false;
    meetingVideoOptimizedState = false;
    constructor(modifyDisplaySettingsService) {
        this.modifyDisplaySettingsService = modifyDisplaySettingsService;
    }
    ngOnInit() {
        this.meetingDisplayTypeState = this.parameters.meetingDisplayType;
        this.autoWaveState = this.parameters.autoWave;
        this.forceFullDisplayState = this.parameters.forceFullDisplay;
        this.meetingVideoOptimizedState = this.parameters.meetingVideoOptimized;
        if (!this.onModifyDisplaySettings) {
            this.onModifyDisplaySettings = this.modifyDisplaySettingsService.modifyDisplaySettings.bind(this.modifyDisplaySettingsService);
        }
    }
    handleSaveSettings = async () => {
        await this.onModifyDisplaySettings({
            parameters: {
                ...this.parameters,
                meetingDisplayType: this.meetingDisplayTypeState,
                autoWave: this.autoWaveState,
                forceFullDisplay: this.forceFullDisplayState,
                meetingVideoOptimized: this.meetingVideoOptimizedState,
            },
        });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisplaySettingsModal, deps: [{ token: ModifyDisplaySettings }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: DisplaySettingsModal, isStandalone: true, selector: "app-display-settings-modal", inputs: { isDisplaySettingsModalVisible: "isDisplaySettingsModalVisible", onDisplaySettingsClose: "onDisplaySettingsClose", onModifyDisplaySettings: "onModifyDisplaySettings", parameters: "parameters", position: "position", backgroundColor: "backgroundColor" }, ngImport: i0, template: "<div *ngIf=\"isDisplaySettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{ 'background-color': backgroundColor }\">\r\n    <div class=\"modal-header\">\r\n      <h2>Display Settings</h2>\r\n      <div class=\"btn-close-media-settings\" (click)=\"onDisplaySettingsClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"modal-divider\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"setting-group\">\r\n        <label>Display Option:</label>\r\n        <select [(ngModel)]=\"meetingDisplayTypeState\" class=\"select-control\">\r\n          <option value=\"video\">Video Participants Only</option>\r\n          <option value=\"media\">Media Participants Only</option>\r\n          <option value=\"all\">Show All Participants</option>\r\n        </select>\r\n      </div>\r\n      <hr class=\"modal-divider\" />\r\n      <div class=\"setting-group\">\r\n        <div class=\"setting-toggle\">\r\n          <label>Display Audiographs</label>\r\n          <button (click)=\"autoWaveState = !autoWaveState\" [ngClass]=\"{ 'active': autoWaveState }\">\r\n            <span class=\"toggle-icon\">{{ autoWaveState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n        <div class=\"setting-toggle\">\r\n          <label>Force Full Display</label>\r\n          <button (click)=\"forceFullDisplayState = !forceFullDisplayState\" [ngClass]=\"{ 'active': forceFullDisplayState }\">\r\n            <span class=\"toggle-icon\">{{ forceFullDisplayState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n        <div class=\"setting-toggle\">\r\n          <label>Force Video Participants</label>\r\n          <button (click)=\"meetingVideoOptimizedState = !meetingVideoOptimizedState\" [ngClass]=\"{ 'active': meetingVideoOptimizedState }\">\r\n            <span class=\"toggle-icon\">{{ meetingVideoOptimizedState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"save-button\" (click)=\"handleSaveSettings()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:80vw;max-width:350px;max-height:65%;overflow-y:auto;top:10px;right:10px}.modal-header{display:flex;flex-direction:row;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-divider{height:1px;background-color:#000;margin:5px 0}.modal-body{flex:1}.setting-group{margin-bottom:10px}.setting-toggle{display:flex;flex-direction:row;justify-content:space-between;align-items:center;margin-bottom:10px}.select-control{font-size:medium;padding:12px 30px 12px 10px;border:1px solid gray;border-radius:4px;color:#000;background-color:#fff}.toggle-icon{font-size:large;font-weight:bolder}.active{color:green}.inactive{color:red}.modal-footer{margin-top:10px;display:flex;justify-content:flex-end}.save-button{padding:5px;border-radius:5px;background-color:#000;color:#fff;font-size:medium}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$1.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisplaySettingsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-display-settings-modal', standalone: true, imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div *ngIf=\"isDisplaySettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{ 'background-color': backgroundColor }\">\r\n    <div class=\"modal-header\">\r\n      <h2>Display Settings</h2>\r\n      <div class=\"btn-close-media-settings\" (click)=\"onDisplaySettingsClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"modal-divider\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"setting-group\">\r\n        <label>Display Option:</label>\r\n        <select [(ngModel)]=\"meetingDisplayTypeState\" class=\"select-control\">\r\n          <option value=\"video\">Video Participants Only</option>\r\n          <option value=\"media\">Media Participants Only</option>\r\n          <option value=\"all\">Show All Participants</option>\r\n        </select>\r\n      </div>\r\n      <hr class=\"modal-divider\" />\r\n      <div class=\"setting-group\">\r\n        <div class=\"setting-toggle\">\r\n          <label>Display Audiographs</label>\r\n          <button (click)=\"autoWaveState = !autoWaveState\" [ngClass]=\"{ 'active': autoWaveState }\">\r\n            <span class=\"toggle-icon\">{{ autoWaveState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n        <div class=\"setting-toggle\">\r\n          <label>Force Full Display</label>\r\n          <button (click)=\"forceFullDisplayState = !forceFullDisplayState\" [ngClass]=\"{ 'active': forceFullDisplayState }\">\r\n            <span class=\"toggle-icon\">{{ forceFullDisplayState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n        <div class=\"setting-toggle\">\r\n          <label>Force Video Participants</label>\r\n          <button (click)=\"meetingVideoOptimizedState = !meetingVideoOptimizedState\" [ngClass]=\"{ 'active': meetingVideoOptimizedState }\">\r\n            <span class=\"toggle-icon\">{{ meetingVideoOptimizedState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"save-button\" (click)=\"handleSaveSettings()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:80vw;max-width:350px;max-height:65%;overflow-y:auto;top:10px;right:10px}.modal-header{display:flex;flex-direction:row;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-divider{height:1px;background-color:#000;margin:5px 0}.modal-body{flex:1}.setting-group{margin-bottom:10px}.setting-toggle{display:flex;flex-direction:row;justify-content:space-between;align-items:center;margin-bottom:10px}.select-control{font-size:medium;padding:12px 30px 12px 10px;border:1px solid gray;border-radius:4px;color:#000;background-color:#fff}.toggle-icon{font-size:large;font-weight:bolder}.active{color:green}.inactive{color:red}.modal-footer{margin-top:10px;display:flex;justify-content:flex-end}.save-button{padding:5px;border-radius:5px;background-color:#000;color:#fff;font-size:medium}\n"] }]
        }], ctorParameters: () => [{ type: ModifyDisplaySettings }], propDecorators: { isDisplaySettingsModalVisible: [{
                type: Input
            }], onDisplaySettingsClose: [{
                type: Input
            }], onModifyDisplaySettings: [{
                type: Input
            }], parameters: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }] } });

class ModifySettings {
    /**
     * Modifies the settings for a given room and updates the state accordingly.
     *
     * @param {Object} options - The options for modifying settings.
     * @param {Function} options.showAlert - Function to show alert messages.
     * @param {string} options.roomName - The name of the room.
     * @param {string} options.audioSet - The audio setting to be applied.
     * @param {string} options.videoSet - The video setting to be applied.
     * @param {string} options.screenshareSet - The screenshare setting to be applied.
     * @param {string} options.chatSet - The chat setting to be applied.
     * @param {Object} options.socket - The socket instance for emitting events.
     * @param {Function} options.updateAudioSetting - Function to update the audio setting state.
     * @param {Function} options.updateVideoSetting - Function to update the video setting state.
     * @param {Function} options.updateScreenshareSetting - Function to update the screenshare setting state.
     * @param {Function} options.updateChatSetting - Function to update the chat setting state.
     * @param {Function} options.updateIsSettingsModalVisible - Function to update the visibility of the settings modal.
     *
     * @returns {Promise<void>} A promise that resolves when the settings have been modified.
     *
     * @throws Will show an alert if any setting is set to "approval" in demo mode (room name starts with "d").
     */
    modifySettings = async ({ showAlert, roomName, audioSet, videoSet, screenshareSet, chatSet, socket, updateAudioSetting, updateVideoSetting, updateScreenshareSetting, updateChatSetting, updateIsSettingsModalVisible, }) => {
        if (roomName.toLowerCase().startsWith('d')) {
            // none should be approval
            if (audioSet === 'approval' ||
                videoSet === 'approval' ||
                screenshareSet === 'approval' ||
                chatSet === 'approval') {
                showAlert?.({
                    message: 'You cannot set approval for demo mode.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        // Check and update state variables based on the provided logic
        if (audioSet) {
            updateAudioSetting(audioSet);
        }
        if (videoSet) {
            updateVideoSetting(videoSet);
        }
        if (screenshareSet) {
            updateScreenshareSetting(screenshareSet);
        }
        if (chatSet) {
            updateChatSetting(chatSet);
        }
        const settings = [audioSet, videoSet, screenshareSet, chatSet];
        socket.emit('updateSettingsForRequests', { settings, roomName });
        // Close modal
        updateIsSettingsModalVisible(false);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ModifySettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ModifySettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ModifySettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// event-settings-modal.component.ts
/**
 * Component for managing event settings modal.
 *
 * @selector app-event-settings-modal
 * @standalone true
 * @imports CommonModule, FontAwesomeModule, FormsModule
 * @templateUrl ./event-settings-modal.component.html
 * @styleUrls ./event-settings-modal.component.css
 *
 * @class EventSettingsModal
 * @implements OnInit, OnChanges
 *
 * @property {boolean} isEventSettingsModalVisible - Indicates if the event settings modal is visible.
 * @property {() => void} onEventSettingsClose - Callback function to close the event settings modal.
 * @property {(options: ModifySettingsOptions) => Promise<void>} onModifyEventSettings - Callback function to modify event settings.
 * @property {string} position - Position of the modal on the screen.
 * @property {string} backgroundColor - Background color of the modal.
 * @property {string} audioSetting - Current audio setting.
 * @property {string} videoSetting - Current video setting.
 * @property {string} screenshareSetting - Current screenshare setting.
 * @property {string} chatSetting - Current chat setting.
 * @property {(setting: string) => void} updateAudioSetting - Callback function to update audio setting.
 * @property {(setting: string) => void} updateVideoSetting - Callback function to update video setting.
 * @property {(setting: string) => void} updateScreenshareSetting - Callback function to update screenshare setting.
 * @property {(setting: string) => void} updateChatSetting - Callback function to update chat setting.
 * @property {(isVisible: boolean) => void} updateIsSettingsModalVisible - Callback function to update modal visibility.
 * @property {string} roomName - Name of the room.
 * @property {Socket} socket - Socket instance for communication.
 * @property {ShowAlert} [showAlert] - Optional alert function.
 *
 * @property {string} audioState - State of the audio setting.
 * @property {string} videoState - State of the video setting.
 * @property {string} screenshareState - State of the screenshare setting.
 * @property {string} chatState - State of the chat setting.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for close button.
 *
 * @constructor
 * @param {ModifySettings} modifySettingsService - Service for modifying settings.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes.
 * @param {SimpleChanges} changes - Object of current and previous property values.
 *
 * @method updateStatesFromParameters - Updates the state variables from the input parameters.
 *
 * @method getModalContentStyle - Returns the style object for the modal content.
 * @returns {Object} Style object for the modal content.
 *
 * @method handleSaveSettings - Handles the save settings action.
 * @returns {Promise<void>} Promise that resolves when settings are saved.
 *
 * @method closeModal - Closes the modal.
 */
class EventSettingsModal {
    modifySettingsService;
    isEventSettingsModalVisible = false;
    onEventSettingsClose;
    onModifyEventSettings;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    audioSetting = '';
    videoSetting = '';
    screenshareSetting = '';
    chatSetting = '';
    updateAudioSetting;
    updateVideoSetting;
    updateScreenshareSetting;
    updateChatSetting;
    updateIsSettingsModalVisible;
    roomName = '';
    socket = {};
    showAlert;
    audioState;
    videoState;
    screenshareState;
    chatState;
    faTimes = faTimes;
    constructor(modifySettingsService) {
        this.modifySettingsService = modifySettingsService;
    }
    ngOnInit() {
        if (!this.onModifyEventSettings) {
            this.onModifyEventSettings = this.modifySettingsService.modifySettings.bind(this.modifySettingsService);
        }
    }
    ngOnChanges(changes) {
        if (changes['isEventSettingsModalVisible']) {
            if (this.isEventSettingsModalVisible) {
                this.updateStatesFromParameters();
            }
        }
    }
    updateStatesFromParameters() {
        this.audioState = this.audioSetting;
        this.videoState = this.videoSetting;
        this.screenshareState = this.screenshareSetting;
        this.chatState = this.chatSetting;
    }
    getModalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxHeight: '65%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    async handleSaveSettings() {
        await this.onModifyEventSettings({
            audioSet: this.audioState,
            videoSet: this.videoState,
            screenshareSet: this.screenshareState,
            chatSet: this.chatState,
            updateAudioSetting: this.updateAudioSetting,
            updateVideoSetting: this.updateVideoSetting,
            updateScreenshareSetting: this.updateScreenshareSetting,
            updateChatSetting: this.updateChatSetting,
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible,
            roomName: this.roomName,
            socket: this.socket,
            showAlert: this.showAlert,
        });
    }
    closeModal() {
        this.onEventSettingsClose();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: EventSettingsModal, deps: [{ token: ModifySettings }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: EventSettingsModal, isStandalone: true, selector: "app-event-settings-modal", inputs: { isEventSettingsModalVisible: "isEventSettingsModalVisible", onEventSettingsClose: "onEventSettingsClose", onModifyEventSettings: "onModifyEventSettings", position: "position", backgroundColor: "backgroundColor", audioSetting: "audioSetting", videoSetting: "videoSetting", screenshareSetting: "screenshareSetting", chatSetting: "chatSetting", updateAudioSetting: "updateAudioSetting", updateVideoSetting: "updateVideoSetting", updateScreenshareSetting: "updateScreenshareSetting", updateChatSetting: "updateChatSetting", updateIsSettingsModalVisible: "updateIsSettingsModalVisible", roomName: "roomName", socket: "socket", showAlert: "showAlert" }, usesOnChanges: true, ngImport: i0, template: "<!-- event-settings-modal.component.html -->\r\n\r\n<div *ngIf=\"isEventSettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"getModalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Event Settings</div>\r\n      <div (click)=\"closeModal()\" class=\"icon-close\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User audio:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"audioState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User video:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"videoState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User screenshare:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"screenshareState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User chat:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"chatState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n        </select>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"btn-apply-settings\" (click)=\"handleSaveSettings()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:999}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.icon-close{cursor:pointer}.hr{height:1px;background-color:#000;margin:5px 0}.modal-body .form-group{margin-bottom:10px}.label{font-size:medium;color:#000;margin-bottom:5px;font-weight:700;margin-right:10px}.picker-select{font-size:medium;padding:6px 5px;border:1px solid gray;border-radius:4px;color:#000;background-color:#fff}.sep{height:1px;background-color:#fff;margin:2px 0}.modal-footer{margin-top:10px;display:flex;justify-content:flex-end}.btn-apply-settings{padding:5px 10px;border-radius:5px;background-color:#000;color:#fff;font-size:medium;cursor:pointer}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$1.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: EventSettingsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-event-settings-modal', standalone: true, imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<!-- event-settings-modal.component.html -->\r\n\r\n<div *ngIf=\"isEventSettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"getModalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Event Settings</div>\r\n      <div (click)=\"closeModal()\" class=\"icon-close\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User audio:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"audioState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User video:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"videoState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User screenshare:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"screenshareState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User chat:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"chatState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n        </select>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"btn-apply-settings\" (click)=\"handleSaveSettings()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:999}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.icon-close{cursor:pointer}.hr{height:1px;background-color:#000;margin:5px 0}.modal-body .form-group{margin-bottom:10px}.label{font-size:medium;color:#000;margin-bottom:5px;font-weight:700;margin-right:10px}.picker-select{font-size:medium;padding:6px 5px;border:1px solid gray;border-radius:4px;color:#000;background-color:#fff}.sep{height:1px;background-color:#fff;margin:2px 0}.modal-footer{margin-top:10px;display:flex;justify-content:flex-end}.btn-apply-settings{padding:5px 10px;border-radius:5px;background-color:#000;color:#fff;font-size:medium;cursor:pointer}\n"] }]
        }], ctorParameters: () => [{ type: ModifySettings }], propDecorators: { isEventSettingsModalVisible: [{
                type: Input
            }], onEventSettingsClose: [{
                type: Input
            }], onModifyEventSettings: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], audioSetting: [{
                type: Input
            }], videoSetting: [{
                type: Input
            }], screenshareSetting: [{
                type: Input
            }], chatSetting: [{
                type: Input
            }], updateAudioSetting: [{
                type: Input
            }], updateVideoSetting: [{
                type: Input
            }], updateScreenshareSetting: [{
                type: Input
            }], updateChatSetting: [{
                type: Input
            }], updateIsSettingsModalVisible: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], showAlert: [{
                type: Input
            }] } });

// This method is used to modify the co-host settings in the chat room.
class ModifyCoHostSettings {
    /**
     * Modifies the co-host settings for a given room.
     *
     * @param {Object} options - The options for modifying co-host settings.
     * @param {string} options.roomName - The name of the room.
     * @param {Function} options.showAlert - Function to show an alert message.
     * @param {string} options.selectedParticipant - The participant selected to be co-host.
     * @param {string} options.coHost - The current co-host.
     * @param {string} options.coHostResponsibility - The responsibility assigned to the co-host.
     * @param {Function} options.updateIsCoHostModalVisible - Function to update the visibility of the co-host modal.
     * @param {Function} options.updateCoHostResponsibility - Function to update the co-host responsibility.
     * @param {Function} options.updateCoHost - Function to update the co-host.
     * @param {Object} options.socket - The socket instance for emitting events.
     * @returns {Promise<void>} A promise that resolves when the co-host settings have been modified.
     *
     * @remarks
     * - If the room is in demo mode (room name starts with "d"), co-host cannot be added and an alert is shown.
     * - If a valid participant is selected, they are set as the new co-host.
     * - The co-host responsibility is updated.
     * - A socket event is emitted to update the co-host information.
     * - The co-host modal is closed after updating the settings.
     */
    async modifyCoHostSettings({ roomName, showAlert, selectedParticipant, coHost, coHostResponsibility, updateIsCoHostModalVisible, updateCoHostResponsibility, updateCoHost, socket, }) {
        // Check if the chat room is in demo mode
        if (roomName.toLowerCase().startsWith('d')) {
            showAlert?.({
                message: 'You cannot add co-host in demo mode.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        let newCoHost = coHost;
        if (coHost != 'No coHost' ||
            (selectedParticipant && selectedParticipant != 'Select a participant')) {
            if (selectedParticipant && selectedParticipant != 'Select a participant') {
                newCoHost = selectedParticipant;
                updateCoHost(newCoHost);
            }
            updateCoHostResponsibility(coHostResponsibility);
            // Emit a socket event to update co-host information
            socket.emit('updateCoHost', { roomName, coHost: newCoHost, coHostResponsibility });
        }
        // Close the co-host modal
        updateIsCoHostModalVisible(false);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ModifyCoHostSettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ModifyCoHostSettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ModifyCoHostSettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/* eslint-disable @typescript-eslint/no-empty-function */
/**
 * CoHostModal component allows managing co-host settings for an event.
 *
 * @selector app-co-host-modal
 * @inputs
 * - `isCoHostModalVisible` (boolean): A boolean value that determines whether the modal is visible. Default is false.
 * - `currentCohost` (string): The current co-host for the event. Default is 'No coHost'.
 * - `participants` (Participant[]): An array of participants in the event.
 * - `coHostResponsibility` (CoHostResponsibility[]): An array of co-host responsibilities.
 * - `position` (string): The position of the modal. Default is 'topRight'.
 * - `backgroundColor` (string): The background color of the modal. Default is '#83c0e9'.
 * - `roomName` (string): The name of the room.
 * - `showAlert` (ShowAlert): A function to show alerts.
 *
 * @outputs
 * - `updateCoHostResponsibility` (coHostResponsibility: CoHostResponsibility[]): A function to update co-host responsibilities.
 * - `updateCoHost` (coHost: string): A function to update the co-host.
 * - `updateIsCoHostModalVisible` (isCoHostModalVisible: boolean): A function to update the visibility of the modal.
 * - `socket` (Socket): The socket object.
 *
 * @methods
 * - `ngOnInit()`: Lifecycle hook that is called after the component is initialized. It sets the default value for `onModifyCoHost` if not provided.
 * - `ngOnChanges(changes: SimpleChanges)`: Lifecycle hook that is called when any data-bound property of the component changes. It initializes the responsibilities and calculates the modal width.
 * - `initializeResponsibilities()`: Initializes the responsibilities.
 * - `get filteredParticipants()`: Returns the filtered participants.
 * - `handleToggleSwitch(key: string)`: Handles the toggle switch for the given key.
 * - `handleSave()`: Handles the save action.
 * - `handleClose()`: Handles the close action.
 * - `calculateModalWidth()`: Calculates the modal width.
 * - `modalContainerStyle()`: Returns the modal container style.
 * - `modalContentStyle()`: Returns the modal content style.
 *
 * @dependencies
 * - `CommonModule`: Angular's common module is imported for common directives.
 * - `FontAwesomeModule`: Angular's font awesome module is imported for icons.
 * - `FormsModule`: Angular's forms module is imported for form-related directives.
 * - `ModifyCoHostSettings`: The ModifyCoHostSettings service is used to modify co-host settings.
 *
 * @styles
 * - `.container`: The container style.
 *
 * @example
 * ```html
 * <app-co-host-modal
 *  [isCoHostModalVisible]="isCoHostModalVisible"
 * [currentCohost]="currentCohost"
 * [participants]="participants"
 * [coHostResponsibility]="coHostResponsibility"
 * [position]="position"
 * [backgroundColor]="backgroundColor"
 * [roomName]="roomName"
 * [showAlert]="showAlert"
 * [updateCoHostResponsibility]="updateCoHostResponsibility"
 * [updateCoHost]="updateCoHost"
 * [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
 * [socket]="socket"
 * [onCoHostClose]="onCoHostClose"
 * [onModifyCoHost]="onModifyCoHost">
 * </app-co-host-modal>
 * ```
 *
 **/
class CoHostModal {
    modifyCoHostSettingsService;
    isCoHostModalVisible = false;
    currentCohost = 'No coHost';
    participants = [];
    coHostResponsibility = [];
    position = 'topRight';
    backgroundColor = '#83c0e9';
    roomName = '';
    showAlert = () => { };
    updateCoHostResponsibility = () => { };
    updateCoHost = () => { };
    updateIsCoHostModalVisible = () => { };
    socket = {};
    onCoHostClose;
    onModifyCoHost;
    faTimes = faTimes;
    selectedCohost = this.currentCohost;
    CoHostResponsibilityCopy = [];
    CoHostResponsibilityCopyAlt = [];
    responsibilities = {};
    responsibilityKeys = [];
    modalWidth;
    constructor(modifyCoHostSettingsService) {
        this.modifyCoHostSettingsService = modifyCoHostSettingsService;
    }
    ngOnInit() {
        // Set default value for onModifyCoHost if not provided
        if (!this.onModifyCoHost) {
            this.onModifyCoHost = (params) => this.modifyCoHostSettingsService.modifyCoHostSettings(params);
        }
    }
    ngOnChanges(changes) {
        if (changes['isCoHostModalVisible'] && this.isCoHostModalVisible) {
            this.initializeResponsibilities();
            this.calculateModalWidth();
        }
    }
    initializeResponsibilities() {
        this.CoHostResponsibilityCopy = [...this.coHostResponsibility];
        this.CoHostResponsibilityCopyAlt = [...this.coHostResponsibility];
        this.responsibilityKeys = this.coHostResponsibility.map((item) => {
            const manageKey = `manage${item.name.charAt(0).toUpperCase() + item.name.slice(1)}`;
            const dedicateKey = `dedicateToManage${item.name.charAt(0).toUpperCase() + item.name.slice(1)}`;
            return { manageKey, dedicateKey };
        });
        const initialResponsibilities = this.CoHostResponsibilityCopyAlt.reduce((acc, item) => {
            const str2 = item.name.charAt(0).toUpperCase() + item.name.slice(1);
            acc[`manage${str2}`] = item.value;
            acc[`dedicateToManage${str2}`] = item.dedicated;
            return acc;
        }, {});
        this.responsibilities = initialResponsibilities;
    }
    get filteredParticipants() {
        return this.participants.filter((participant) => participant.name !== this.currentCohost && participant.islevel !== '2');
    }
    handleToggleSwitch(key) {
        if (key.startsWith('dedicateTo')) {
            const responsibilityName = key.replace('dedicateToManage', '').toLowerCase();
            const manageKey = `manage${responsibilityName.charAt(0).toUpperCase() + responsibilityName.slice(1)}`;
            // Ensure that the 'dedicated' checkbox can only be toggled if the corresponding 'responsibility' is checked
            if (this.responsibilities[manageKey]) {
                const responsibilityDedicated = this.CoHostResponsibilityCopy.find((item) => item.name === responsibilityName).dedicated;
                this.responsibilities[key] = !responsibilityDedicated;
                this.CoHostResponsibilityCopy.find((item) => item.name === responsibilityName).dedicated =
                    !responsibilityDedicated;
            }
        }
        else if (key.startsWith('manage')) {
            const responsibilityName = key.replace('manage', '').toLowerCase();
            const responsibilityValue = this.CoHostResponsibilityCopy.find((item) => item.name === responsibilityName).value;
            // Toggle the 'responsibility' checkbox and ensure the corresponding 'dedicated' checkbox is also disabled if unchecked
            this.responsibilities[key] = !responsibilityValue;
            this.CoHostResponsibilityCopy.find((item) => item.name === responsibilityName).value =
                !responsibilityValue;
            if (!this.responsibilities[key]) {
                const dedicateKey = `dedicateToManage${responsibilityName.charAt(0).toUpperCase() + responsibilityName.slice(1)}`;
                this.responsibilities[dedicateKey] = false;
                this.CoHostResponsibilityCopy.find((item) => item.name === responsibilityName).dedicated =
                    false;
            }
        }
    }
    handleSave() {
        console.log('handleSave');
        this.onModifyCoHost({
            roomName: this.roomName,
            showAlert: this.showAlert,
            selectedParticipant: this.selectedCohost,
            coHost: this.currentCohost,
            coHostResponsibility: this.CoHostResponsibilityCopy,
            updateCoHostResponsibility: this.updateCoHostResponsibility,
            updateCoHost: this.updateCoHost,
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible,
            socket: this.socket,
        });
    }
    handleClose() {
        this.onCoHostClose();
    }
    calculateModalWidth() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 400) {
            modalWidth = 400;
        }
        this.modalWidth = modalWidth;
    }
    modalContainerStyle() {
        return {
            display: this.isCoHostModalVisible ? 'block' : 'none',
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            zIndex: '999',
        };
    }
    modalContentStyle() {
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${this.modalWidth}px`,
            maxHeight: '65%',
            overflowX: 'hidden',
            overflowY: 'auto',
            position: 'fixed',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CoHostModal, deps: [{ token: ModifyCoHostSettings }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: CoHostModal, isStandalone: true, selector: "app-co-host-modal", inputs: { isCoHostModalVisible: "isCoHostModalVisible", currentCohost: "currentCohost", participants: "participants", coHostResponsibility: "coHostResponsibility", position: "position", backgroundColor: "backgroundColor", roomName: "roomName", showAlert: "showAlert", updateCoHostResponsibility: "updateCoHostResponsibility", updateCoHost: "updateCoHost", updateIsCoHostModalVisible: "updateIsCoHostModalVisible", socket: "socket", onCoHostClose: "onCoHostClose", onModifyCoHost: "onModifyCoHost" }, usesOnChanges: true, ngImport: i0, template: "<!-- co-host-modal.component.html -->\r\n<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Manage Co-Host</div>\r\n      <div class=\"btn-close-settings\" (click)=\"handleClose()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label class=\"font-weight-bold\">Current Co-host:</label>\r\n        <input class=\"form-control\" [value]=\"currentCohost\" readonly />\r\n      </div>\r\n      <div class=\"form-group\">\r\n        <label class=\"font-weight-bold\">Select New Co-host:</label>\r\n        <select class=\"form-control\" [(ngModel)]=\"selectedCohost\">\r\n          <option value=\"\">Select a participant</option>\r\n          <option *ngFor=\"let participant of filteredParticipants\" [value]=\"participant.name\">\r\n            {{ participant.name }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <div class=\"row\">\r\n        <div class=\"col-5\">\r\n          <label style=\"font-weight: bold\">Responsibility</label>\r\n        </div>\r\n        <div class=\"col-3\">\r\n          <label style=\"font-weight: bold\">Select</label>\r\n        </div>\r\n        <div class=\"col-4\">\r\n          <label style=\"font-weight: bold\">Dedicated</label>\r\n        </div>\r\n      </div>\r\n      <div *ngFor=\"let key of responsibilityKeys\" class=\"row\" style=\"margin-bottom: 10px;\">\r\n        <div class=\"col-5\" style=\"font-weight: bold\">{{ key.manageKey.replace('manage', '') }}</div>\r\n        <div class=\"col-3\">\r\n          <input type=\"checkbox\" [(ngModel)]=\"responsibilities[key.manageKey]\" (change)=\"handleToggleSwitch(key.manageKey)\">\r\n        </div>\r\n        <div class=\"col-4\">\r\n          <input type=\"checkbox\" [(ngModel)]=\"responsibilities[key.dedicateKey]\" (change)=\"handleToggleSwitch(key.dedicateKey)\" [disabled]=\"!responsibilities[key.manageKey]\">\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"btn-apply-settings\" (click)=\"handleSave()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#e7caca80;z-index:999;display:flex;justify-content:center;align-items:center}.modal-content{background-color:#83c0e9;border-radius:10px;padding:10px;width:400px;max-height:65%;overflow-x:hidden;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center}.modal-title{font-size:1.25rem;font-weight:700}.btn-close-settings{cursor:pointer}.hr{margin:10px 0}.form-group{margin-bottom:15px}.modal-footer{display:flex;justify-content:flex-end}.btn-apply-settings{background-color:#007bff;color:#fff;border:none;padding:10px 20px;border-radius:5px;cursor:pointer}.btn-apply-settings:hover{background-color:#0056b3}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$1.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i2$1.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CoHostModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-co-host-modal', standalone: true, imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<!-- co-host-modal.component.html -->\r\n<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Manage Co-Host</div>\r\n      <div class=\"btn-close-settings\" (click)=\"handleClose()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label class=\"font-weight-bold\">Current Co-host:</label>\r\n        <input class=\"form-control\" [value]=\"currentCohost\" readonly />\r\n      </div>\r\n      <div class=\"form-group\">\r\n        <label class=\"font-weight-bold\">Select New Co-host:</label>\r\n        <select class=\"form-control\" [(ngModel)]=\"selectedCohost\">\r\n          <option value=\"\">Select a participant</option>\r\n          <option *ngFor=\"let participant of filteredParticipants\" [value]=\"participant.name\">\r\n            {{ participant.name }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <div class=\"row\">\r\n        <div class=\"col-5\">\r\n          <label style=\"font-weight: bold\">Responsibility</label>\r\n        </div>\r\n        <div class=\"col-3\">\r\n          <label style=\"font-weight: bold\">Select</label>\r\n        </div>\r\n        <div class=\"col-4\">\r\n          <label style=\"font-weight: bold\">Dedicated</label>\r\n        </div>\r\n      </div>\r\n      <div *ngFor=\"let key of responsibilityKeys\" class=\"row\" style=\"margin-bottom: 10px;\">\r\n        <div class=\"col-5\" style=\"font-weight: bold\">{{ key.manageKey.replace('manage', '') }}</div>\r\n        <div class=\"col-3\">\r\n          <input type=\"checkbox\" [(ngModel)]=\"responsibilities[key.manageKey]\" (change)=\"handleToggleSwitch(key.manageKey)\">\r\n        </div>\r\n        <div class=\"col-4\">\r\n          <input type=\"checkbox\" [(ngModel)]=\"responsibilities[key.dedicateKey]\" (change)=\"handleToggleSwitch(key.dedicateKey)\" [disabled]=\"!responsibilities[key.manageKey]\">\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"btn-apply-settings\" (click)=\"handleSave()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#e7caca80;z-index:999;display:flex;justify-content:center;align-items:center}.modal-content{background-color:#83c0e9;border-radius:10px;padding:10px;width:400px;max-height:65%;overflow-x:hidden;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center}.modal-title{font-size:1.25rem;font-weight:700}.btn-close-settings{cursor:pointer}.hr{margin:10px 0}.form-group{margin-bottom:15px}.modal-footer{display:flex;justify-content:flex-end}.btn-apply-settings{background-color:#007bff;color:#fff;border:none;padding:10px 20px;border-radius:5px;cursor:pointer}.btn-apply-settings:hover{background-color:#0056b3}\n"] }]
        }], ctorParameters: () => [{ type: ModifyCoHostSettings }], propDecorators: { isCoHostModalVisible: [{
                type: Input
            }], currentCohost: [{
                type: Input
            }], participants: [{
                type: Input
            }], coHostResponsibility: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], roomName: [{
                type: Input
            }], showAlert: [{
                type: Input
            }], updateCoHostResponsibility: [{
                type: Input
            }], updateCoHost: [{
                type: Input
            }], updateIsCoHostModalVisible: [{
                type: Input
            }], socket: [{
                type: Input
            }], onCoHostClose: [{
                type: Input
            }], onModifyCoHost: [{
                type: Input
            }] } });

class ParticipantListItem {
    participant;
    isBroadcast;
    onMuteParticipants;
    onMessageParticipants;
    onRemoveParticipants;
    socket;
    coHostResponsibility;
    member;
    islevel;
    showAlert;
    coHost;
    roomName;
    updateIsMessagesModalVisible;
    updateDirectMessageDetails;
    updateStartDirectMessage;
    participants;
    updateParticipants;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faComment = faComment;
    faTrash = faTrash;
    faDotCircle = faDotCircle;
    getIconName() {
        return this.participant.muted ? this.faMicrophoneSlash : this.faMicrophone;
    }
    muteParticipant() {
        if (this.onMuteParticipants) {
            this.onMuteParticipants({
                socket: this.socket,
                participant: this.participant,
                coHostResponsibility: this.coHostResponsibility,
                member: this.member,
                islevel: this.islevel,
                showAlert: this.showAlert,
                coHost: this.coHost,
                roomName: this.roomName,
            });
        }
    }
    messageParticipant() {
        if (this.onMessageParticipants) {
            this.onMessageParticipants({
                participant: this.participant,
                coHostResponsibility: this.coHostResponsibility,
                member: this.member,
                islevel: this.islevel,
                showAlert: this.showAlert,
                coHost: this.coHost,
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible,
                updateDirectMessageDetails: this.updateDirectMessageDetails,
                updateStartDirectMessage: this.updateStartDirectMessage,
            });
        }
    }
    removeParticipant() {
        if (this.onRemoveParticipants) {
            this.onRemoveParticipants({
                socket: this.socket,
                participant: this.participant,
                coHostResponsibility: this.coHostResponsibility,
                member: this.member,
                islevel: this.islevel,
                showAlert: this.showAlert,
                coHost: this.coHost,
                roomName: this.roomName,
                participants: this.participants,
                updateParticipants: this.updateParticipants,
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantListItem, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ParticipantListItem, isStandalone: true, selector: "app-participant-list-item", inputs: { participant: "participant", isBroadcast: "isBroadcast", onMuteParticipants: "onMuteParticipants", onMessageParticipants: "onMessageParticipants", onRemoveParticipants: "onRemoveParticipants", socket: "socket", coHostResponsibility: "coHostResponsibility", member: "member", islevel: "islevel", showAlert: "showAlert", coHost: "coHost", roomName: "roomName", updateIsMessagesModalVisible: "updateIsMessagesModalVisible", updateDirectMessageDetails: "updateDirectMessageDetails", updateStartDirectMessage: "updateStartDirectMessage", participants: "participants", updateParticipants: "updateParticipants" }, ngImport: i0, template: "<div class=\"container\" style=\"display: flex; flex-direction: row; align-items: center; margin-bottom: 0px; margin-top: 0px;\">\r\n  <div class=\"nameContainer\" style=\"flex: 4;\">\r\n    <p class=\"nameText\" style=\"font-size: 16px;\">\r\n      {{ participant.islevel === '2' ? participant.name + ' (host)' : participant.name }}\r\n    </p>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"iconContainer\" style=\"flex: 1; align-items: center;\">\r\n    <fa-icon [icon]=\"participant.muted ? faDotCircle : faDotCircle\" [style.font-size.px]=\"20\" [style.color]=\"participant.muted ? 'red' : 'green'\"></fa-icon>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"muteParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #007bff; color: white;\">\r\n      <fa-icon [icon]=\"getIconName()\" style=\"font-size: 20px;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"messageParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #007bff; color: white;\">\r\n      <fa-icon [icon]=\"faComment\" style=\"font-size: 20px; color: white;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"removeParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #dc3545; color: white;\">\r\n      <fa-icon [icon]=\"faTrash\" style=\"font-size: 20px; color: white;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:row;align-items:center;margin-bottom:0;margin-top:0}.nameContainer{flex:4}.nameText{font-size:16px}.iconContainer,.buttonContainer{flex:2;align-items:center}button{padding:5px;border-radius:5px;background-color:#007bff;color:#fff}button.remove{background-color:#dc3545}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantListItem, decorators: [{
            type: Component,
            args: [{ selector: 'app-participant-list-item', standalone: true, imports: [CommonModule, FontAwesomeModule], template: "<div class=\"container\" style=\"display: flex; flex-direction: row; align-items: center; margin-bottom: 0px; margin-top: 0px;\">\r\n  <div class=\"nameContainer\" style=\"flex: 4;\">\r\n    <p class=\"nameText\" style=\"font-size: 16px;\">\r\n      {{ participant.islevel === '2' ? participant.name + ' (host)' : participant.name }}\r\n    </p>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"iconContainer\" style=\"flex: 1; align-items: center;\">\r\n    <fa-icon [icon]=\"participant.muted ? faDotCircle : faDotCircle\" [style.font-size.px]=\"20\" [style.color]=\"participant.muted ? 'red' : 'green'\"></fa-icon>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"muteParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #007bff; color: white;\">\r\n      <fa-icon [icon]=\"getIconName()\" style=\"font-size: 20px;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"messageParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #007bff; color: white;\">\r\n      <fa-icon [icon]=\"faComment\" style=\"font-size: 20px; color: white;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"removeParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #dc3545; color: white;\">\r\n      <fa-icon [icon]=\"faTrash\" style=\"font-size: 20px; color: white;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:row;align-items:center;margin-bottom:0;margin-top:0}.nameContainer{flex:4}.nameText{font-size:16px}.iconContainer,.buttonContainer{flex:2;align-items:center}button{padding:5px;border-radius:5px;background-color:#007bff;color:#fff}button.remove{background-color:#dc3545}\n"] }]
        }], propDecorators: { participant: [{
                type: Input
            }], isBroadcast: [{
                type: Input
            }], onMuteParticipants: [{
                type: Input
            }], onMessageParticipants: [{
                type: Input
            }], onRemoveParticipants: [{
                type: Input
            }], socket: [{
                type: Input
            }], coHostResponsibility: [{
                type: Input
            }], member: [{
                type: Input
            }], islevel: [{
                type: Input
            }], showAlert: [{
                type: Input
            }], coHost: [{
                type: Input
            }], roomName: [{
                type: Input
            }], updateIsMessagesModalVisible: [{
                type: Input
            }], updateDirectMessageDetails: [{
                type: Input
            }], updateStartDirectMessage: [{
                type: Input
            }], participants: [{
                type: Input
            }], updateParticipants: [{
                type: Input
            }] } });

/* eslint-disable @typescript-eslint/no-empty-function */
class ParticipantList {
    participants = [];
    isBroadcast = false;
    onMuteParticipants;
    onMessageParticipants;
    onRemoveParticipants;
    socket = {};
    coHostResponsibility = [];
    member = '';
    islevel = '';
    showAlert;
    coHost = '';
    roomName = '';
    updateIsMessagesModalVisible = () => { };
    updateDirectMessageDetails = () => { };
    updateStartDirectMessage = () => { };
    updateParticipants = () => { };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantList, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ParticipantList, isStandalone: true, selector: "app-participant-list", inputs: { participants: "participants", isBroadcast: "isBroadcast", onMuteParticipants: "onMuteParticipants", onMessageParticipants: "onMessageParticipants", onRemoveParticipants: "onRemoveParticipants", socket: "socket", coHostResponsibility: "coHostResponsibility", member: "member", islevel: "islevel", showAlert: "showAlert", coHost: "coHost", roomName: "roomName", updateIsMessagesModalVisible: "updateIsMessagesModalVisible", updateDirectMessageDetails: "updateDirectMessageDetails", updateStartDirectMessage: "updateStartDirectMessage", updateParticipants: "updateParticipants" }, ngImport: i0, template: "<div *ngFor=\"let participant of participants; let i = index\">\r\n  <app-participant-list-item\r\n    [participant]=\"participant\"\r\n    [isBroadcast]=\"isBroadcast\"\r\n    [onMuteParticipants]=\"onMuteParticipants\"\r\n    [onMessageParticipants]=\"onMessageParticipants\"\r\n    [onRemoveParticipants]=\"onRemoveParticipants\"\r\n    [socket]=\"socket\"\r\n    [coHostResponsibility]=\"coHostResponsibility\"\r\n    [coHost]=\"coHost\"\r\n    [member]=\"member\"\r\n    [islevel]=\"islevel\"\r\n    [roomName]=\"roomName\"\r\n    [participants]=\"participants\"\r\n    [updateIsMessagesModalVisible]=\"updateIsMessagesModalVisible\"\r\n    [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n    [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n    [updateParticipants]=\"updateParticipants\"\r\n  ></app-participant-list-item>\r\n  <hr *ngIf=\"i < participants.length - 1\" class=\"separator\" />\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ParticipantListItem, selector: "app-participant-list-item", inputs: ["participant", "isBroadcast", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "socket", "coHostResponsibility", "member", "islevel", "showAlert", "coHost", "roomName", "updateIsMessagesModalVisible", "updateDirectMessageDetails", "updateStartDirectMessage", "participants", "updateParticipants"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantList, decorators: [{
            type: Component,
            args: [{ selector: 'app-participant-list', standalone: true, imports: [CommonModule, ParticipantListItem], template: "<div *ngFor=\"let participant of participants; let i = index\">\r\n  <app-participant-list-item\r\n    [participant]=\"participant\"\r\n    [isBroadcast]=\"isBroadcast\"\r\n    [onMuteParticipants]=\"onMuteParticipants\"\r\n    [onMessageParticipants]=\"onMessageParticipants\"\r\n    [onRemoveParticipants]=\"onRemoveParticipants\"\r\n    [socket]=\"socket\"\r\n    [coHostResponsibility]=\"coHostResponsibility\"\r\n    [coHost]=\"coHost\"\r\n    [member]=\"member\"\r\n    [islevel]=\"islevel\"\r\n    [roomName]=\"roomName\"\r\n    [participants]=\"participants\"\r\n    [updateIsMessagesModalVisible]=\"updateIsMessagesModalVisible\"\r\n    [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n    [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n    [updateParticipants]=\"updateParticipants\"\r\n  ></app-participant-list-item>\r\n  <hr *ngIf=\"i < participants.length - 1\" class=\"separator\" />\r\n</div>\r\n" }]
        }], propDecorators: { participants: [{
                type: Input
            }], isBroadcast: [{
                type: Input
            }], onMuteParticipants: [{
                type: Input
            }], onMessageParticipants: [{
                type: Input
            }], onRemoveParticipants: [{
                type: Input
            }], socket: [{
                type: Input
            }], coHostResponsibility: [{
                type: Input
            }], member: [{
                type: Input
            }], islevel: [{
                type: Input
            }], showAlert: [{
                type: Input
            }], coHost: [{
                type: Input
            }], roomName: [{
                type: Input
            }], updateIsMessagesModalVisible: [{
                type: Input
            }], updateDirectMessageDetails: [{
                type: Input
            }], updateStartDirectMessage: [{
                type: Input
            }], updateParticipants: [{
                type: Input
            }] } });

class ParticipantListOthersItem {
    participant;
    member;
    coHost;
    faCircle = faCircle;
    getParticipantDisplayName() {
        if (this.participant.islevel === '2') {
            return this.participant.name === this.member
                ? `${this.participant.name} (you)`
                : `${this.participant.name} (host)`;
        }
        else {
            if (this.participant.name === this.member) {
                return `${this.participant.name} (you)`;
            }
            else if (this.coHost === this.participant.name) {
                return `${this.participant.name} (co-host)`;
            }
            else {
                return this.participant.name;
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantListOthersItem, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ParticipantListOthersItem, isStandalone: true, selector: "app-participant-list-others-item", inputs: { participant: "participant", member: "member", coHost: "coHost" }, ngImport: i0, template: "<div class=\"container\">\r\n  <div class=\"name-container\">\r\n    <span class=\"name-text\">\r\n      {{ getParticipantDisplayName() }}\r\n    </span>\r\n  </div>\r\n  <div class=\"icon-container\">\r\n    <fa-icon [icon]=\"faCircle\" [style.color]=\"participant.muted ? 'red' : 'green'\"></fa-icon>\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:row;align-items:center;margin-bottom:10px}.name-container{flex:8}.name-text{font-size:16px}.icon-container{flex:4;display:flex;align-items:center}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantListOthersItem, decorators: [{
            type: Component,
            args: [{ selector: 'app-participant-list-others-item', standalone: true, imports: [CommonModule, FontAwesomeModule], template: "<div class=\"container\">\r\n  <div class=\"name-container\">\r\n    <span class=\"name-text\">\r\n      {{ getParticipantDisplayName() }}\r\n    </span>\r\n  </div>\r\n  <div class=\"icon-container\">\r\n    <fa-icon [icon]=\"faCircle\" [style.color]=\"participant.muted ? 'red' : 'green'\"></fa-icon>\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:row;align-items:center;margin-bottom:10px}.name-container{flex:8}.name-text{font-size:16px}.icon-container{flex:4;display:flex;align-items:center}\n"] }]
        }], propDecorators: { participant: [{
                type: Input
            }], member: [{
                type: Input
            }], coHost: [{
                type: Input
            }] } });

class ParticipantListOthers {
    participants = [];
    coHost = '';
    member = '';
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantListOthers, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ParticipantListOthers, isStandalone: true, selector: "app-participant-list-others", inputs: { participants: "participants", coHost: "coHost", member: "member" }, ngImport: i0, template: "<div *ngFor=\"let participant of participants; let i = index\">\r\n  <app-participant-list-others-item\r\n    [participant]=\"participant\"\r\n    [coHost]=\"coHost\"\r\n    [member]=\"member\"\r\n  ></app-participant-list-others-item>\r\n  <hr *ngIf=\"i < participants.length - 1\" class=\"separator\" />\r\n</div>\r\n", styles: [".separator{border:none;border-top:1px solid #e0e0e0;margin:10px 0}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ParticipantListOthersItem, selector: "app-participant-list-others-item", inputs: ["participant", "member", "coHost"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantListOthers, decorators: [{
            type: Component,
            args: [{ selector: 'app-participant-list-others', standalone: true, imports: [CommonModule, ParticipantListOthersItem], template: "<div *ngFor=\"let participant of participants; let i = index\">\r\n  <app-participant-list-others-item\r\n    [participant]=\"participant\"\r\n    [coHost]=\"coHost\"\r\n    [member]=\"member\"\r\n  ></app-participant-list-others-item>\r\n  <hr *ngIf=\"i < participants.length - 1\" class=\"separator\" />\r\n</div>\r\n", styles: [".separator{border:none;border-top:1px solid #e0e0e0;margin:10px 0}\n"] }]
        }], propDecorators: { participants: [{
                type: Input
            }], coHost: [{
                type: Input
            }], member: [{
                type: Input
            }] } });

class MuteParticipants {
    /**
     * Mutes a participant in a media session if certain conditions are met.
     *
     * @param {Object} options - The options for muting participants.
     * @param {Socket} options.socket - The socket instance for communication.
     * @param {Array} options.coHostResponsibility - List of co-host responsibilities.
     * @param {Object} options.participant - The participant to be muted.
     * @param {Object} options.member - The current member attempting to mute.
     * @param {string} options.islevel - The level of the current member.
     * @param {Function} [options.showAlert] - Optional function to show alerts.
     * @param {Object} options.coHost - The co-host information.
     * @param {string} options.roomName - The name of the room.
     *
     * @returns {Promise<void>} A promise that resolves when the participant is muted.
     *
     * @throws Will log an error if there is an issue accessing co-host responsibilities.
     */
    async muteParticipants({ socket, coHostResponsibility, participant, member, islevel, showAlert, coHost, roomName, }) {
        let mediaValue = false;
        try {
            mediaValue = coHostResponsibility.find((item) => item.name === 'media')?.value ?? false;
        }
        catch (error) {
            console.error(error);
        }
        if (islevel === '2' || (coHost === member && mediaValue === true)) {
            if (!participant.muted && participant.islevel !== '2') {
                const participantId = participant.id;
                socket.emit('controlMedia', {
                    participantId,
                    participantName: participant.name,
                    type: 'all',
                    roomName,
                });
            }
        }
        else {
            showAlert?.({
                message: 'You are not allowed to mute other participants',
                type: 'danger',
                duration: 3000,
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MuteParticipants, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MuteParticipants, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MuteParticipants, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class MessageParticipants {
    /**
     * Sends a direct message to a participant if certain conditions are met.
     *s
     * @param coHostResponsibility - Array of responsibilities assigned to the co-host.
     * @param participant - The participant to whom the message is to be sent.
     * @param member - The current member attempting to send the message.
     * @param islevel - The level of the current member.
     * @param showAlert - Function to show an alert message.
     * @param coHost - The co-host member.
     * @param updateIsMessagesModalVisible - Function to update the visibility of the messages modal.
     * @param updateDirectMessageDetails - Function to update the details of the direct message.
     * @param updateStartDirectMessage - Function to start the direct message.
     *
     * @returns void
     */
    messageParticipants({ coHostResponsibility, participant, member, islevel, showAlert, coHost, updateIsMessagesModalVisible, updateDirectMessageDetails, updateStartDirectMessage, }) {
        let chatValue = false;
        try {
            chatValue = coHostResponsibility.find((item) => item.name === 'chat')?.value ?? false;
        }
        catch (error) {
            console.error(error);
        }
        if (islevel === '2' || (coHost === member && chatValue === true)) {
            if (participant.islevel !== '2') {
                updateDirectMessageDetails(participant);
                updateStartDirectMessage(true);
                updateIsMessagesModalVisible(true);
            }
        }
        else {
            showAlert?.({
                message: 'You are not allowed to send this message',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MessageParticipants, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MessageParticipants, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MessageParticipants, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class RemoveParticipants {
    /**
     * Removes a participant from the room if the user has the appropriate permissions.
     *
     * @param {RemoveParticipantsOptions} options - The options for removing a participant.
     * @param {Array} options.coHostResponsibility - The responsibilities of the co-host.
     * @param {Object} options.participant - The participant to be removed.
     * @param {Object} options.member - The current member attempting to remove the participant.
     * @param {string} options.islevel - The level of the current member.
     * @param {Function} [options.showAlert] - Function to show an alert message.
     * @param {Object} options.coHost - The co-host information.
     * @param {Array} options.participants - The list of current participants.
     * @param {Object} options.socket - The socket instance for emitting events.
     * @param {string} options.roomName - The name of the room.
     * @param {Function} options.updateParticipants - Function to update the participants list.
     *
     * @returns {Promise<void>} - A promise that resolves when the participant is removed.
     */
    async removeParticipants({ coHostResponsibility, participant, member, islevel, showAlert, coHost, participants, socket, roomName, updateParticipants, }) {
        let participantsValue = false;
        try {
            participantsValue =
                coHostResponsibility.find((item) => item.name === 'participants')?.value ?? false;
        }
        catch (error) {
            participantsValue = false;
        }
        if (islevel === '2' || (coHost === member && participantsValue === true)) {
            if (participant.islevel !== '2') {
                const participantId = participant.id;
                // Emit a socket event to disconnect the user
                socket.emit('disconnectUserInitiate', {
                    member: participant.name,
                    roomName,
                    id: participantId,
                });
                // Remove the participant from the local array
                participants.splice(participants.findIndex((obj) => obj.name === participant.name), 1);
                // Update the participants array
                updateParticipants(participants);
            }
        }
        else {
            showAlert?.({
                message: 'You are not allowed to remove other participants',
                type: 'danger',
                duration: 3000,
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RemoveParticipants, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RemoveParticipants, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RemoveParticipants, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ParticipantsModal {
    muteParticipantsService;
    messageParticipantsService;
    removeParticipantsService;
    isParticipantsModalVisible = false;
    onParticipantsClose;
    onParticipantsFilterChange;
    participantsCounter = 0;
    onMuteParticipants;
    onMessageParticipants;
    onRemoveParticipants;
    parameters = {};
    position = 'topRight';
    backgroundColor = '#83c0e9';
    participant_s = [];
    participantsCounter_s = 0;
    reRender = false;
    faTimes = faTimes;
    constructor(muteParticipantsService, messageParticipantsService, removeParticipantsService) {
        this.muteParticipantsService = muteParticipantsService;
        this.messageParticipantsService = messageParticipantsService;
        this.removeParticipantsService = removeParticipantsService;
    }
    ngOnInit() {
        this.updateParticipantsData();
        if (!this.onMuteParticipants) {
            this.onMuteParticipants = this.muteParticipantsService.muteParticipants.bind(this.muteParticipantsService);
        }
        if (!this.onMessageParticipants) {
            this.onMessageParticipants = this.messageParticipantsService.messageParticipants.bind(this.messageParticipantsService);
        }
        if (!this.onRemoveParticipants) {
            this.onRemoveParticipants = this.removeParticipantsService.removeParticipants.bind(this.removeParticipantsService);
        }
    }
    ngOnChanges(changes) {
        if (changes['parameters'] || changes['participantsCounter']) {
            this.updateParticipantsData();
        }
    }
    updateParticipantsData() {
        let { getUpdatedAllParams } = this.parameters;
        this.parameters = getUpdatedAllParams();
        this.participant_s = this.parameters.filteredParticipants;
        this.participantsCounter_s = this.parameters.filteredParticipants.length;
    }
    handleFilterChange(event) {
        const inputElement = event.target;
        const filterValue = inputElement.value;
        this.onParticipantsFilterChange(filterValue);
        this.reRender = !this.reRender;
    }
    handleClose() {
        this.onParticipantsClose();
    }
    canShowParticipantList() {
        const participantsValue = this.parameters.coHostResponsibility?.find((item) => item.name === 'participants')?.value;
        return (this.parameters.islevel === '2' ||
            (this.parameters.coHost === this.parameters.member && participantsValue === true));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantsModal, deps: [{ token: MuteParticipants }, { token: MessageParticipants }, { token: RemoveParticipants }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ParticipantsModal, isStandalone: true, selector: "app-participants-modal", inputs: { isParticipantsModalVisible: "isParticipantsModalVisible", onParticipantsClose: "onParticipantsClose", onParticipantsFilterChange: "onParticipantsFilterChange", participantsCounter: "participantsCounter", onMuteParticipants: "onMuteParticipants", onMessageParticipants: "onMessageParticipants", onRemoveParticipants: "onRemoveParticipants", parameters: "parameters", position: "position", backgroundColor: "backgroundColor" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isParticipantsModalVisible\" class=\"modal-container\" [ngStyle]=\"{'background-color': 'rgba(0, 0, 0, 0.5)'}\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{'background-color': backgroundColor, 'top': position.includes('top') ? '10px' : 'auto', 'bottom': position.includes('bottom') ? '10px' : 'auto', 'left': position.includes('Left') ? '10px' : 'auto', 'right': position.includes('Right') ? '10px' : 'auto'}\">\r\n    <div class=\"modal-header\">\r\n      <div>\r\n        Participants <span class=\"badge\">{{ participantsCounter_s }}</span>\r\n      </div>\r\n      <div class=\"close-icon\" (click)=\"handleClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-body\">\r\n      <input type=\"text\" class=\"filter-input\" placeholder=\"Search ...\" (input)=\"handleFilterChange($event)\">\r\n      <ng-container *ngIf=\"parameters.participants\">\r\n        <ng-container *ngIf=\"canShowParticipantList()\">\r\n          <app-participant-list\r\n            [participants]=\"participant_s\"\r\n            [isBroadcast]=\"parameters.eventType === 'broadcast'\"\r\n            [onMuteParticipants]=\"onMuteParticipants\"\r\n            [onMessageParticipants]=\"onMessageParticipants\"\r\n            [onRemoveParticipants]=\"onRemoveParticipants\"\r\n            [socket]=\"parameters.socket\"\r\n            [coHostResponsibility]=\"parameters.coHostResponsibility\"\r\n            [coHost]=\"parameters.coHost\"\r\n            [member]=\"parameters.member\"\r\n            [islevel]=\"parameters.islevel\"\r\n            [roomName]=\"parameters.roomName\"\r\n            [updateIsMessagesModalVisible]=\"parameters.updateIsMessagesModalVisible\"\r\n            [updateStartDirectMessage]=\"parameters.updateStartDirectMessage\"\r\n            [updateDirectMessageDetails]=\"parameters.updateDirectMessageDetails\"\r\n            [updateParticipants]=\"parameters.updateParticipants\"\r\n          >\r\n          </app-participant-list>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!canShowParticipantList()\">\r\n          <app-participant-list-others\r\n            [participants]=\"participant_s\"\r\n            [coHost]=\"parameters.coHost\"\r\n            [member]=\"parameters.member\"\r\n            >\r\n          </app-participant-list-others>\r\n        </ng-container>\r\n      </ng-container>\r\n      <div *ngIf=\"!parameters.participants\">No participants</div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:80%;max-width:400px;max-height:75%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center}.badge{background-color:#fff;color:#000;border-radius:10px;padding:5px}.close-icon{padding:5px;cursor:pointer}.modal-body{margin-top:10px}.filter-input{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: ParticipantList, selector: "app-participant-list", inputs: ["participants", "isBroadcast", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "socket", "coHostResponsibility", "member", "islevel", "showAlert", "coHost", "roomName", "updateIsMessagesModalVisible", "updateDirectMessageDetails", "updateStartDirectMessage", "updateParticipants"] }, { kind: "component", type: ParticipantListOthers, selector: "app-participant-list-others", inputs: ["participants", "coHost", "member"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-participants-modal', standalone: true, imports: [CommonModule, FontAwesomeModule, ParticipantList, ParticipantListOthers], template: "<div *ngIf=\"isParticipantsModalVisible\" class=\"modal-container\" [ngStyle]=\"{'background-color': 'rgba(0, 0, 0, 0.5)'}\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{'background-color': backgroundColor, 'top': position.includes('top') ? '10px' : 'auto', 'bottom': position.includes('bottom') ? '10px' : 'auto', 'left': position.includes('Left') ? '10px' : 'auto', 'right': position.includes('Right') ? '10px' : 'auto'}\">\r\n    <div class=\"modal-header\">\r\n      <div>\r\n        Participants <span class=\"badge\">{{ participantsCounter_s }}</span>\r\n      </div>\r\n      <div class=\"close-icon\" (click)=\"handleClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-body\">\r\n      <input type=\"text\" class=\"filter-input\" placeholder=\"Search ...\" (input)=\"handleFilterChange($event)\">\r\n      <ng-container *ngIf=\"parameters.participants\">\r\n        <ng-container *ngIf=\"canShowParticipantList()\">\r\n          <app-participant-list\r\n            [participants]=\"participant_s\"\r\n            [isBroadcast]=\"parameters.eventType === 'broadcast'\"\r\n            [onMuteParticipants]=\"onMuteParticipants\"\r\n            [onMessageParticipants]=\"onMessageParticipants\"\r\n            [onRemoveParticipants]=\"onRemoveParticipants\"\r\n            [socket]=\"parameters.socket\"\r\n            [coHostResponsibility]=\"parameters.coHostResponsibility\"\r\n            [coHost]=\"parameters.coHost\"\r\n            [member]=\"parameters.member\"\r\n            [islevel]=\"parameters.islevel\"\r\n            [roomName]=\"parameters.roomName\"\r\n            [updateIsMessagesModalVisible]=\"parameters.updateIsMessagesModalVisible\"\r\n            [updateStartDirectMessage]=\"parameters.updateStartDirectMessage\"\r\n            [updateDirectMessageDetails]=\"parameters.updateDirectMessageDetails\"\r\n            [updateParticipants]=\"parameters.updateParticipants\"\r\n          >\r\n          </app-participant-list>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!canShowParticipantList()\">\r\n          <app-participant-list-others\r\n            [participants]=\"participant_s\"\r\n            [coHost]=\"parameters.coHost\"\r\n            [member]=\"parameters.member\"\r\n            >\r\n          </app-participant-list-others>\r\n        </ng-container>\r\n      </ng-container>\r\n      <div *ngIf=\"!parameters.participants\">No participants</div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:80%;max-width:400px;max-height:75%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center}.badge{background-color:#fff;color:#000;border-radius:10px;padding:5px}.close-icon{padding:5px;cursor:pointer}.modal-body{margin-top:10px}.filter-input{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}\n"] }]
        }], ctorParameters: () => [{ type: MuteParticipants }, { type: MessageParticipants }, { type: RemoveParticipants }], propDecorators: { isParticipantsModalVisible: [{
                type: Input
            }], onParticipantsClose: [{
                type: Input
            }], onParticipantsFilterChange: [{
                type: Input
            }], participantsCounter: [{
                type: Input
            }], onMuteParticipants: [{
                type: Input
            }], onMessageParticipants: [{
                type: Input
            }], onRemoveParticipants: [{
                type: Input
            }], parameters: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }] } });

/**
 * @fileoverview MessagePanel component for handling message interactions in the MediaSFU-Angular application.
 *
 * @component
 * @selector app-message-panel
 * @templateUrl ./message-panel.component.html
 * @styleUrls ['./message-panel.component.css']
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule, FormsModule]
 *
 * @description
 * The MessagePanel component is responsible for displaying and managing messages in a chat interface.
 * It supports both group and direct messaging, and includes various input properties to customize its behavior.
 *
 * @property {Array<any>} messages - Array of messages to be displayed.
 * @property {number} messagesLength - The length of the messages array.
 * @property {string} type - The type of chat, either 'group' or 'direct'.
 * @property {string} username - The username of the current user.
 * @property {(options: SendMessageOptions) => Promise<void>} onSendMessagePress - Function to handle sending messages.
 * @property {string} backgroundColor - Background color of the message panel.
 * @property {boolean} focusedInput - Indicates if the input field is focused.
 * @property {EventType} eventType - The type of event, e.g., 'webinar'.
 * @property {string} member - The member associated with the chat.
 * @property {string} islevel - The level of the user.
 * @property {boolean} startDirectMessage - Indicates if a direct message should be started.
 * @property {(start: boolean) => void} updateStartDirectMessage - Function to update the startDirectMessage state.
 * @property {Participant | null} directMessageDetails - Details of the participant for direct messaging.
 * @property {(participant: Participant | null) => void} updateDirectMessageDetails - Function to update directMessageDetails.
 * @property {CoHostResponsibility[]} coHostResponsibility - Array of co-host responsibilities.
 * @property {string} coHost - The co-host of the chat.
 * @property {string} roomName - The name of the chat room.
 * @property {Socket} socket - The socket connection for real-time communication.
 * @property {string} chatSetting - Settings for the chat.
 * @property {ShowAlert} [showAlert] - Optional function to show alerts.
 *
 * @property {IconDefinition} faPaperPlane - FontAwesome icon for paper plane.
 * @property {IconDefinition} faReply - FontAwesome icon for reply.
 *
 * @property {any} replyInfo - Information about the reply.
 * @property {string | null} senderId - ID of the sender.
 * @property {string} directMessageText - Text of the direct message.
 * @property {string} groupMessageText - Text of the group message.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method defaultSendMessage - Default implementation for sending a message.
 * @method handleTextInputChange - Handles changes in the text input field.
 * @method openReplyInput - Opens the reply input for a specific sender.
 * @method handleSendButton - Handles the send button click event.
 */
class MessagePanel {
    messages = [];
    messagesLength = 0;
    type = 'group';
    username = '';
    onSendMessagePress;
    backgroundColor = '#f5f5f5';
    focusedInput = false;
    eventType = 'webinar';
    member = '';
    islevel = '';
    startDirectMessage = false;
    updateStartDirectMessage;
    directMessageDetails = null;
    updateDirectMessageDetails;
    coHostResponsibility = [];
    coHost = '';
    roomName = '';
    socket = {};
    chatSetting = '';
    showAlert;
    faPaperPlane = faPaperPlane;
    faReply = faReply;
    replyInfo = null;
    senderId = null;
    directMessageText = '';
    groupMessageText = '';
    ngOnInit() {
        if (!this.onSendMessagePress) {
            this.onSendMessagePress = this.defaultSendMessage.bind(this);
        }
    }
    defaultSendMessage() {
        // Default send message implementation
        return Promise.resolve();
    }
    handleTextInputChange(event) {
        const text = event.target.value;
        if (this.type === 'direct') {
            this.directMessageText = text;
        }
        else {
            this.groupMessageText = text;
        }
    }
    ngOnChanges() {
        if (this.startDirectMessage && this.directMessageDetails) {
            this.openReplyInput(this.directMessageDetails['name']);
        }
    }
    openReplyInput(senderId) {
        this.replyInfo = {
            text: 'Replying to: ',
            username: senderId,
        };
        this.senderId = senderId;
    }
    async handleSendButton() {
        const message = this.type === 'direct' ? this.directMessageText : this.groupMessageText;
        if (!message) {
            this.showAlert?.({ message: 'Please enter a message', type: 'danger' });
            return;
        }
        if (message.length > 350) {
            this.showAlert?.({ message: 'Message is too long.', type: 'danger' });
            return;
        }
        if (message.trim() === '') {
            this.showAlert?.({ message: 'Message cannot be empty.', type: 'danger' });
            return;
        }
        if (this.type === 'direct' && !this.senderId && this.islevel == '2') {
            this.showAlert?.({ message: 'Please select a user to send a message to.', type: 'danger' });
            return;
        }
        await this.onSendMessagePress({
            message,
            receivers: this.type === 'direct' && this.senderId ? [this.senderId] : [],
            group: this.type === 'group',
            messagesLength: this.messagesLength,
            member: this.member,
            sender: this.username,
            islevel: this.islevel,
            showAlert: this.showAlert,
            coHostResponsibility: this.coHostResponsibility,
            coHost: this.coHost,
            roomName: this.roomName,
            socket: this.socket,
            chatSetting: this.chatSetting,
        });
        if (this.type === 'direct') {
            this.directMessageText = '';
        }
        else {
            this.groupMessageText = '';
        }
        this.replyInfo = null;
        this.senderId = null;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MessagePanel, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MessagePanel, isStandalone: true, selector: "app-message-panel", inputs: { messages: "messages", messagesLength: "messagesLength", type: "type", username: "username", onSendMessagePress: "onSendMessagePress", backgroundColor: "backgroundColor", focusedInput: "focusedInput", eventType: "eventType", member: "member", islevel: "islevel", startDirectMessage: "startDirectMessage", updateStartDirectMessage: "updateStartDirectMessage", directMessageDetails: "directMessageDetails", updateDirectMessageDetails: "updateDirectMessageDetails", coHostResponsibility: "coHostResponsibility", coHost: "coHost", roomName: "roomName", socket: "socket", chatSetting: "chatSetting", showAlert: "showAlert" }, usesOnChanges: true, ngImport: i0, template: "<div [style.maxHeight]=\"'100%'\" [style.backgroundColor]=\"backgroundColor\" style=\"overflow-y: auto;\">\r\n  <!-- Message rendering logic -->\r\n  <div *ngFor=\"let message of messages; let index = index\" [ngStyle]=\"{ marginBottom: '10px' }\">\r\n    <div [ngStyle]=\"{ display: 'flex', flexDirection: 'column', alignItems: message.sender === username ? 'flex-end' : 'flex-start', marginBottom: '10px' }\">\r\n      <div [ngStyle]=\"{ display: 'flex', flexDirection: 'row', justifyContent: 'space-between', marginBottom: '3px' }\">\r\n        <span *ngIf=\"message.sender === username && !message.group\" [ngStyle]=\"{ fontWeight: 'bold', color: 'black', fontSize: '8px', marginLeft: '6px' }\">To: {{ message.receivers.join(', ') }}</span>\r\n        <span [ngStyle]=\"{ fontWeight: 'bold', color: 'black', fontSize: '8px', marginRight: '10px' }\">{{ message.sender === username ? '' : message.sender }}</span>\r\n        <span [ngStyle]=\"{ fontSize: '8px', color: '#0D0D0DFF' }\">{{ message.timestamp }}</span>\r\n        <div *ngIf=\"message.sender !== username && !message.group\" (click)=\"openReplyInput(message.sender)\" [ngStyle]=\"{ padding: '1px', marginLeft: '5px', borderRadius: '2px', backgroundColor: 'transparent' }\">\r\n          <fa-icon [icon]=\"faReply\" size=\"xs\" color=\"black\"></fa-icon>\r\n        </div>\r\n      </div>\r\n      <div [ngStyle]=\"{ backgroundColor: message.sender === member ? '#DCF8C6' : '#1ce5c7', padding: '10px', borderRadius: '10px' }\">\r\n        <span [ngStyle]=\"{ color: 'black' }\">{{ message.message }}</span>\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n  <!-- Reply info -->\r\n  <div *ngIf=\"replyInfo\" [ngStyle]=\"{ flexDirection: 'row', alignItems: 'center', padding: '2px', backgroundColor: '#e6e6e6', borderRadius: '5px', marginBottom: '1px' }\">\r\n    <span [ngStyle]=\"{ fontWeight: 'bold', marginRight: '2px', fontSize: '8px' }\">Replying to: </span>\r\n    <span [ngStyle]=\"{ color: 'red', fontSize: '8px' }\">{{ replyInfo.username }}</span>\r\n  </div>\r\n\r\n  <!-- Input area -->\r\n  <div [ngStyle]=\"{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '10px', marginTop: 'auto' }\">\r\n    <input\r\n      type=\"text\"\r\n      [ngStyle]=\"{ flex: 1, minHeight: '40px', maxHeight: '80px', resize: 'vertical', border: '1px solid gray', borderRadius: '5px', padding: '10px', overflowY: 'auto' }\"\r\n      placeholder=\"{{ type === 'direct' ? (focusedInput && startDirectMessage && directMessageDetails ? 'Send a direct message to ' + directMessageDetails.name : 'Select a message to reply to') : (eventType === 'chat' ? 'Send a message' : 'Send a message to everyone') }}\"\r\n      maxLength=\"350\"\r\n      (input)=\"handleTextInputChange($event)\"\r\n      [value]=\"type === 'direct' ? directMessageText : groupMessageText\"\r\n    />\r\n    <button [ngStyle]=\"{ backgroundColor: '#83c0e9', padding: '10px', borderRadius: '5px', display: 'flex', alignItems: 'center' }\" (click)=\"handleSendButton()\">\r\n      <fa-icon [icon]=\"faPaperPlane\" size=\"sm\" color=\"white\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MessagePanel, decorators: [{
            type: Component,
            args: [{ selector: 'app-message-panel', standalone: true, imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div [style.maxHeight]=\"'100%'\" [style.backgroundColor]=\"backgroundColor\" style=\"overflow-y: auto;\">\r\n  <!-- Message rendering logic -->\r\n  <div *ngFor=\"let message of messages; let index = index\" [ngStyle]=\"{ marginBottom: '10px' }\">\r\n    <div [ngStyle]=\"{ display: 'flex', flexDirection: 'column', alignItems: message.sender === username ? 'flex-end' : 'flex-start', marginBottom: '10px' }\">\r\n      <div [ngStyle]=\"{ display: 'flex', flexDirection: 'row', justifyContent: 'space-between', marginBottom: '3px' }\">\r\n        <span *ngIf=\"message.sender === username && !message.group\" [ngStyle]=\"{ fontWeight: 'bold', color: 'black', fontSize: '8px', marginLeft: '6px' }\">To: {{ message.receivers.join(', ') }}</span>\r\n        <span [ngStyle]=\"{ fontWeight: 'bold', color: 'black', fontSize: '8px', marginRight: '10px' }\">{{ message.sender === username ? '' : message.sender }}</span>\r\n        <span [ngStyle]=\"{ fontSize: '8px', color: '#0D0D0DFF' }\">{{ message.timestamp }}</span>\r\n        <div *ngIf=\"message.sender !== username && !message.group\" (click)=\"openReplyInput(message.sender)\" [ngStyle]=\"{ padding: '1px', marginLeft: '5px', borderRadius: '2px', backgroundColor: 'transparent' }\">\r\n          <fa-icon [icon]=\"faReply\" size=\"xs\" color=\"black\"></fa-icon>\r\n        </div>\r\n      </div>\r\n      <div [ngStyle]=\"{ backgroundColor: message.sender === member ? '#DCF8C6' : '#1ce5c7', padding: '10px', borderRadius: '10px' }\">\r\n        <span [ngStyle]=\"{ color: 'black' }\">{{ message.message }}</span>\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n  <!-- Reply info -->\r\n  <div *ngIf=\"replyInfo\" [ngStyle]=\"{ flexDirection: 'row', alignItems: 'center', padding: '2px', backgroundColor: '#e6e6e6', borderRadius: '5px', marginBottom: '1px' }\">\r\n    <span [ngStyle]=\"{ fontWeight: 'bold', marginRight: '2px', fontSize: '8px' }\">Replying to: </span>\r\n    <span [ngStyle]=\"{ color: 'red', fontSize: '8px' }\">{{ replyInfo.username }}</span>\r\n  </div>\r\n\r\n  <!-- Input area -->\r\n  <div [ngStyle]=\"{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '10px', marginTop: 'auto' }\">\r\n    <input\r\n      type=\"text\"\r\n      [ngStyle]=\"{ flex: 1, minHeight: '40px', maxHeight: '80px', resize: 'vertical', border: '1px solid gray', borderRadius: '5px', padding: '10px', overflowY: 'auto' }\"\r\n      placeholder=\"{{ type === 'direct' ? (focusedInput && startDirectMessage && directMessageDetails ? 'Send a direct message to ' + directMessageDetails.name : 'Select a message to reply to') : (eventType === 'chat' ? 'Send a message' : 'Send a message to everyone') }}\"\r\n      maxLength=\"350\"\r\n      (input)=\"handleTextInputChange($event)\"\r\n      [value]=\"type === 'direct' ? directMessageText : groupMessageText\"\r\n    />\r\n    <button [ngStyle]=\"{ backgroundColor: '#83c0e9', padding: '10px', borderRadius: '5px', display: 'flex', alignItems: 'center' }\" (click)=\"handleSendButton()\">\r\n      <fa-icon [icon]=\"faPaperPlane\" size=\"sm\" color=\"white\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n" }]
        }], propDecorators: { messages: [{
                type: Input
            }], messagesLength: [{
                type: Input
            }], type: [{
                type: Input
            }], username: [{
                type: Input
            }], onSendMessagePress: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], focusedInput: [{
                type: Input
            }], eventType: [{
                type: Input
            }], member: [{
                type: Input
            }], islevel: [{
                type: Input
            }], startDirectMessage: [{
                type: Input
            }], updateStartDirectMessage: [{
                type: Input
            }], directMessageDetails: [{
                type: Input
            }], updateDirectMessageDetails: [{
                type: Input
            }], coHostResponsibility: [{
                type: Input
            }], coHost: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], chatSetting: [{
                type: Input
            }], showAlert: [{
                type: Input
            }] } });

class SendMessage {
    /**
     * Sends a message to the specified room.
     *
     * @param {Object} options - The options for sending the message.
     * @param {string} options.member - The member sending the message.
     * @param {string} options.islevel - The level of the member.
     * @param {Function} options.showAlert - Function to show alert messages.
     * @param {Array} options.coHostResponsibility - List of co-host responsibilities.
     * @param {string} options.coHost - The co-host of the room.
     * @param {boolean} options.chatSetting - Chat setting for the room.
     * @param {string} options.message - The message to be sent.
     * @param {string} options.roomName - The name of the room.
     * @param {number} options.messagesLength - The current number of messages in the room.
     * @param {Array} options.receivers - List of receivers for the message.
     * @param {boolean} options.group - Indicates if the message is for a group.
     * @param {string} options.sender - The sender of the message.
     * @param {Object} options.socket - The socket instance for communication.
     *
     * @returns {Promise<void>} A promise that resolves when the message is sent.
     *
     * @throws Will throw an error if the message count limit is exceeded.
     * @throws Will throw an error if the message, sender, or receivers are not valid.
     * @throws Will throw an error if the user is not allowed to send a message in the event room.
     */
    async sendMessage({ member, islevel, showAlert, coHostResponsibility, coHost, chatSetting, message, roomName, messagesLength, receivers, group, sender, socket, }) {
        let chatValue = false;
        // Check message count limit based on the room type
        if ((messagesLength > 100 && roomName.startsWith('d')) ||
            (messagesLength > 500 && roomName.startsWith('s')) ||
            (messagesLength > 100000 && roomName.startsWith('p'))) {
            showAlert?.({
                message: 'You have reached the maximum number of messages allowed.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Validate message, sender, and receivers
        if (!message || !receivers || (!member && !sender)) {
            showAlert?.({
                message: 'Message is not valid.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Create the message object
        const messageObject = {
            sender: sender ? sender : member,
            receivers: receivers,
            message: message,
            timestamp: new Date().toLocaleTimeString(),
            group: group !== undefined && group !== null ? group : false,
        };
        try {
            // Check co-host responsibility for chat
            chatValue = coHostResponsibility.find((item) => item.name === 'chat')?.value ?? false;
        }
        catch (error) {
            console.error(error);
        }
        if (islevel === '2' || (coHost === member && chatValue === true)) {
            // Allow sending message
        }
        else {
            // Check if user is allowed to send a message in the event room
            if (!chatSetting) {
                showAlert?.({
                    message: 'You are not allowed to send a message in this event room',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        // Send the message to the server
        socket.emit('sendMessage', {
            messageObject: messageObject,
            roomName: roomName,
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SendMessage, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SendMessage, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SendMessage, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/* eslint-disable @typescript-eslint/no-empty-function */
class MessagesModal {
    SendMessageService;
    constructor(SendMessageService) {
        this.SendMessageService = SendMessageService;
    }
    isMessagesModalVisible = false;
    onMessagesClose = () => { };
    onSendMessagePress;
    messages = [];
    position = 'topRight';
    backgroundColor = '#f5f5f5';
    activeTabBackgroundColor = '#2b7ce5';
    eventType = 'webinar';
    member = '';
    islevel = '';
    coHostResponsibility = [];
    coHost = '';
    startDirectMessage = false;
    directMessageDetails = null;
    updateStartDirectMessage = (start) => {
        console.log(start);
    };
    updateDirectMessageDetails = (participant) => {
        console.log(participant);
    };
    showAlert;
    roomName = '';
    socket = {};
    chatSetting = '';
    faTimes = faTimes;
    directMessages = [];
    groupMessages = [];
    activeTab = 'group';
    focusedInput = false;
    reRender = false;
    modalContainerStyle;
    modalContentStyle;
    ngOnInit() {
        if (!this.onSendMessagePress) {
            this.onSendMessagePress = this.SendMessageService.sendMessage.bind(this.SendMessageService);
        }
        if (this.eventType == 'webinar' || this.eventType == 'conference') {
            this.activeTab = 'direct';
        }
        else {
            this.activeTab = 'group';
            this.switchToGroupTab();
        }
        this.updateModalStyles();
    }
    ngOnChanges(changes) {
        if (changes['isMessagesModalVisible']) {
            this.updateModalStyles();
            if (this.eventType != 'webinar' &&
                this.eventType != 'conference' &&
                this.activeTab == 'direct') {
                this.activeTab = 'group';
                this.focusedInput = false;
                this.switchToGroupTab();
            }
            else if (this.eventType == 'webinar' || this.eventType == 'conference') {
                if (this.startDirectMessage && this.directMessageDetails) {
                    this.activeTab = 'direct';
                    this.focusedInput = true;
                    this.switchToDirectTab();
                }
            }
            if (this.isMessagesModalVisible) {
                this.populateMessages();
            }
        }
        if (changes['messages']) {
            this.populateMessages();
        }
    }
    switchToDirectTab() {
        this.activeTab = 'direct';
        this.reRender = !this.reRender;
    }
    switchToGroupTab() {
        this.activeTab = 'group';
        this.reRender = !this.reRender;
    }
    populateMessages() {
        let chatValue = false;
        try {
            chatValue =
                this.coHostResponsibility?.find((item) => item.name == 'chat')?.value || false;
        }
        catch {
            /* handle error */
        }
        let directMsgs = this.messages ? this.messages.filter((message) => !message.group) : [];
        directMsgs = directMsgs.filter((message) => message.sender == this.member ||
            message.receivers.includes(this.member) ||
            this.islevel == '2' ||
            (this.coHost == this.member && chatValue == true));
        this.directMessages = directMsgs;
        const groupMsgs = this.messages ? this.messages.filter((message) => message.group) : [];
        this.groupMessages = groupMsgs;
    }
    closeMessagesModal() {
        this.onMessagesClose();
    }
    updateModalStyles() {
        const screenWidth = window.innerWidth;
        const modalWidth = Math.min(0.8 * screenWidth, 400);
        this.modalContainerStyle = {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isMessagesModalVisible ? 'block' : 'none',
            zIndex: 999,
        };
        this.modalContentStyle = {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxWidth: `${modalWidth}px`,
            maxHeight: '75%',
            overflowY: 'auto',
            overflowX: 'hidden',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    getTabStyle(tab) {
        return {
            ...this.styles.tabText,
            ...(this.activeTab == tab ? this.styles.activeTabText : {}),
            ...(this.activeTab == tab ? { backgroundColor: this.activeTabBackgroundColor } : {}),
        };
    }
    getButtonCloseStyle() {
        return {
            ...this.styles.btnCloseMessages,
            marginLeft: this.eventType == 'webinar' || this.eventType == 'conference' ? '20%' : '65%',
        };
    }
    get styles() {
        return {
            modalContent: {
                borderRadius: '10px',
                padding: '10px',
            },
            modalBody: {
                marginTop: '10px',
            },
            tabText: {
                paddingRight: '10px',
                paddingLeft: '10px',
                paddingTop: '5px',
                paddingBottom: '5px',
                fontWeight: 'bold',
                marginRight: '10px',
                marginLeft: '10px',
            },
            activeTabText: {
                color: '#ffffff',
                backgroundColor: '#2b7ce5',
                borderRadius: '4px',
            },
            separator: {
                height: '1px',
                backgroundColor: 'black',
                marginVertical: '1px',
            },
            btnCloseMessages: {
                padding: '5px',
                marginRight: '0',
                paddingRight: '0',
            },
            icon: {
                fontSize: '24px',
                color: 'black',
            },
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MessagesModal, deps: [{ token: SendMessage }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MessagesModal, isStandalone: true, selector: "app-messages-modal", inputs: { isMessagesModalVisible: "isMessagesModalVisible", onMessagesClose: "onMessagesClose", onSendMessagePress: "onSendMessagePress", messages: "messages", position: "position", backgroundColor: "backgroundColor", activeTabBackgroundColor: "activeTabBackgroundColor", eventType: "eventType", member: "member", islevel: "islevel", coHostResponsibility: "coHostResponsibility", coHost: "coHost", startDirectMessage: "startDirectMessage", directMessageDetails: "directMessageDetails", updateStartDirectMessage: "updateStartDirectMessage", updateDirectMessageDetails: "updateDirectMessageDetails", showAlert: "showAlert", roomName: "roomName", socket: "socket", chatSetting: "chatSetting" }, usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div\r\n      [ngStyle]=\"{\r\n        flexDirection: 'row',\r\n        justifyContent: 'space-between',\r\n        alignItems: 'center'\r\n      }\"\r\n    >\r\n      <button\r\n        *ngIf=\"eventType === 'webinar' || eventType === 'conference'\"\r\n        (click)=\"switchToDirectTab()\"\r\n        [ngStyle]=\"getTabStyle('direct')\"\r\n      >\r\n        Direct\r\n      </button>\r\n      <button\r\n        *ngIf=\"eventType === 'webinar' || eventType === 'conference'\"\r\n        (click)=\"switchToGroupTab()\"\r\n        [ngStyle]=\"getTabStyle('group')\"\r\n      >\r\n        Group\r\n      </button>\r\n      <span (click)=\"closeMessagesModal()\" [ngStyle]=\"getButtonCloseStyle()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\" size=\"xl\"></fa-icon>\r\n      </span>\r\n    </div>\r\n    <hr [ngStyle]=\"styles.separator\" />\r\n    <div [ngStyle]=\"styles.modalBody\">\r\n      <app-message-panel\r\n        *ngIf=\"\r\n          activeTab === 'direct' &&\r\n          (eventType === 'webinar' || eventType === 'conference')\r\n        \"\r\n        [messages]=\"directMessages\"\r\n        [messagesLength]=\"messages.length\"\r\n        type=\"direct\"\r\n        [onSendMessagePress]=\"onSendMessagePress\"\r\n        [username]=\"member\"\r\n        [backgroundColor]=\"backgroundColor\"\r\n        [focusedInput]=\"focusedInput\"\r\n        [showAlert]=\"showAlert\"\r\n        [eventType]=\"eventType\"\r\n        [member]=\"member\"\r\n        [islevel]=\"islevel\"\r\n        [coHostResponsibility]=\"coHostResponsibility\"\r\n        [coHost]=\"coHost\"\r\n        [directMessageDetails]=\"directMessageDetails\"\r\n        [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n        [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n        [roomName]=\"roomName\"\r\n        [socket]=\"socket\"\r\n        [chatSetting]=\"chatSetting\"\r\n        [startDirectMessage]=\"startDirectMessage\"\r\n      >\r\n      </app-message-panel>\r\n\r\n      <app-message-panel\r\n        *ngIf=\"activeTab === 'group'\"\r\n        [messages]=\"groupMessages\"\r\n        [messagesLength]=\"messages.length\"\r\n        type=\"group\"\r\n        [onSendMessagePress]=\"onSendMessagePress\"\r\n        [username]=\"member\"\r\n        [backgroundColor]=\"backgroundColor\"\r\n        [focusedInput]=\"focusedInput\"\r\n        [showAlert]=\"showAlert\"\r\n        [eventType]=\"eventType\"\r\n        [member]=\"member\"\r\n        [islevel]=\"islevel\"\r\n        [coHostResponsibility]=\"coHostResponsibility\"\r\n        [coHost]=\"coHost\"\r\n        [directMessageDetails]=\"directMessageDetails\"\r\n        [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n        [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n        [roomName]=\"roomName\"\r\n        [socket]=\"socket\"\r\n        [chatSetting]=\"chatSetting\"\r\n        [startDirectMessage]=\"startDirectMessage\"\r\n      >\r\n      </app-message-panel>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modalContent{border-radius:10px;padding:10px}.modalBody{margin-top:10px}.tabText{padding:5px 10px;font-weight:700;margin-right:10px;margin-left:10px}.activeTabText{color:#fff;background-color:#2b7ce5;border-radius:4px}.separator{height:1px;background-color:#000;margin-top:1px;margin-bottom:1px}.btnCloseMessages{padding:5px 0 5px 5px;margin-right:0}.icon{font-size:24px;color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: MessagePanel, selector: "app-message-panel", inputs: ["messages", "messagesLength", "type", "username", "onSendMessagePress", "backgroundColor", "focusedInput", "eventType", "member", "islevel", "startDirectMessage", "updateStartDirectMessage", "directMessageDetails", "updateDirectMessageDetails", "coHostResponsibility", "coHost", "roomName", "socket", "chatSetting", "showAlert"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MessagesModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-messages-modal', standalone: true, imports: [CommonModule, FontAwesomeModule, MessagePanel], template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div\r\n      [ngStyle]=\"{\r\n        flexDirection: 'row',\r\n        justifyContent: 'space-between',\r\n        alignItems: 'center'\r\n      }\"\r\n    >\r\n      <button\r\n        *ngIf=\"eventType === 'webinar' || eventType === 'conference'\"\r\n        (click)=\"switchToDirectTab()\"\r\n        [ngStyle]=\"getTabStyle('direct')\"\r\n      >\r\n        Direct\r\n      </button>\r\n      <button\r\n        *ngIf=\"eventType === 'webinar' || eventType === 'conference'\"\r\n        (click)=\"switchToGroupTab()\"\r\n        [ngStyle]=\"getTabStyle('group')\"\r\n      >\r\n        Group\r\n      </button>\r\n      <span (click)=\"closeMessagesModal()\" [ngStyle]=\"getButtonCloseStyle()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\" size=\"xl\"></fa-icon>\r\n      </span>\r\n    </div>\r\n    <hr [ngStyle]=\"styles.separator\" />\r\n    <div [ngStyle]=\"styles.modalBody\">\r\n      <app-message-panel\r\n        *ngIf=\"\r\n          activeTab === 'direct' &&\r\n          (eventType === 'webinar' || eventType === 'conference')\r\n        \"\r\n        [messages]=\"directMessages\"\r\n        [messagesLength]=\"messages.length\"\r\n        type=\"direct\"\r\n        [onSendMessagePress]=\"onSendMessagePress\"\r\n        [username]=\"member\"\r\n        [backgroundColor]=\"backgroundColor\"\r\n        [focusedInput]=\"focusedInput\"\r\n        [showAlert]=\"showAlert\"\r\n        [eventType]=\"eventType\"\r\n        [member]=\"member\"\r\n        [islevel]=\"islevel\"\r\n        [coHostResponsibility]=\"coHostResponsibility\"\r\n        [coHost]=\"coHost\"\r\n        [directMessageDetails]=\"directMessageDetails\"\r\n        [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n        [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n        [roomName]=\"roomName\"\r\n        [socket]=\"socket\"\r\n        [chatSetting]=\"chatSetting\"\r\n        [startDirectMessage]=\"startDirectMessage\"\r\n      >\r\n      </app-message-panel>\r\n\r\n      <app-message-panel\r\n        *ngIf=\"activeTab === 'group'\"\r\n        [messages]=\"groupMessages\"\r\n        [messagesLength]=\"messages.length\"\r\n        type=\"group\"\r\n        [onSendMessagePress]=\"onSendMessagePress\"\r\n        [username]=\"member\"\r\n        [backgroundColor]=\"backgroundColor\"\r\n        [focusedInput]=\"focusedInput\"\r\n        [showAlert]=\"showAlert\"\r\n        [eventType]=\"eventType\"\r\n        [member]=\"member\"\r\n        [islevel]=\"islevel\"\r\n        [coHostResponsibility]=\"coHostResponsibility\"\r\n        [coHost]=\"coHost\"\r\n        [directMessageDetails]=\"directMessageDetails\"\r\n        [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n        [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n        [roomName]=\"roomName\"\r\n        [socket]=\"socket\"\r\n        [chatSetting]=\"chatSetting\"\r\n        [startDirectMessage]=\"startDirectMessage\"\r\n      >\r\n      </app-message-panel>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modalContent{border-radius:10px;padding:10px}.modalBody{margin-top:10px}.tabText{padding:5px 10px;font-weight:700;margin-right:10px;margin-left:10px}.activeTabText{color:#fff;background-color:#2b7ce5;border-radius:4px}.separator{height:1px;background-color:#000;margin-top:1px;margin-bottom:1px}.btnCloseMessages{padding:5px 0 5px 5px;margin-right:0}.icon{font-size:24px;color:#000}\n"] }]
        }], ctorParameters: () => [{ type: SendMessage }], propDecorators: { isMessagesModalVisible: [{
                type: Input
            }], onMessagesClose: [{
                type: Input
            }], onSendMessagePress: [{
                type: Input
            }], messages: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], activeTabBackgroundColor: [{
                type: Input
            }], eventType: [{
                type: Input
            }], member: [{
                type: Input
            }], islevel: [{
                type: Input
            }], coHostResponsibility: [{
                type: Input
            }], coHost: [{
                type: Input
            }], startDirectMessage: [{
                type: Input
            }], directMessageDetails: [{
                type: Input
            }], updateStartDirectMessage: [{
                type: Input
            }], updateDirectMessageDetails: [{
                type: Input
            }], showAlert: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], chatSetting: [{
                type: Input
            }] } });

class SwitchAudio {
    /**
     * Switches the audio input device based on user preference.
     *
     * @param {SwitchAudioParams} options - The function parameters.
     * @returns {Promise<void>}
     */
    async switchAudio({ audioPreference, parameters }) {
        let { defAudioID, userDefaultAudioInputDevice, prevAudioInputDevice, updateUserDefaultAudioInputDevice, updatePrevAudioInputDevice, 
        //mediasfu functions
        switchUserAudio, } = parameters;
        if (audioPreference !== defAudioID) {
            prevAudioInputDevice = userDefaultAudioInputDevice;
            updatePrevAudioInputDevice(prevAudioInputDevice);
            userDefaultAudioInputDevice = audioPreference;
            updateUserDefaultAudioInputDevice(userDefaultAudioInputDevice);
            if (defAudioID) {
                await switchUserAudio({ audioPreference, parameters });
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class SwitchVideo {
    /**
     * Switches the user's video device based on the provided video preference.
     *
     * @param {SwitchVideoParams} options - The function parameters.
     */
    async switchVideo({ videoPreference, parameters }) {
        let { recordStarted, recordResumed, recordStopped, recordPaused, recordingMediaOptions, videoAlreadyOn, userDefaultVideoInputDevice, defVideoID, allowed, updateDefVideoID, updatePrevVideoInputDevice, updateUserDefaultVideoInputDevice, updateIsMediaSettingsModalVisible, 
        //mediasfu functions
        showAlert, switchUserVideo, } = parameters;
        // Check if recording is in progress and whether the selected video device is the default one
        let checkoff = false;
        if ((recordStarted || recordResumed) && !recordStopped && !recordPaused) {
            if (recordingMediaOptions === 'video') {
                checkoff = true;
            }
        }
        // Check camera access permission
        if (!allowed) {
            showAlert?.({
                message: 'Allow access to your camera by starting it for the first time.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Check video state and display appropriate alert messages
        if (checkoff) {
            if (videoAlreadyOn) {
                showAlert?.({
                    message: 'Please turn off your video before switching.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        else {
            if (!videoAlreadyOn) {
                showAlert?.({
                    message: 'Please turn on your video before switching.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        // Set default video ID if not already set
        if (!defVideoID) {
            defVideoID = userDefaultVideoInputDevice ?? 'default';
            updateDefVideoID(defVideoID);
        }
        // Switch video only if the selected video device is different from the default
        if (videoPreference !== defVideoID) {
            const prevVideoInputDevice = userDefaultVideoInputDevice;
            updatePrevVideoInputDevice(prevVideoInputDevice);
            userDefaultVideoInputDevice = videoPreference;
            updateUserDefaultVideoInputDevice(userDefaultVideoInputDevice);
            if (defVideoID) {
                updateIsMediaSettingsModalVisible(false);
                await switchUserVideo({ videoPreference, checkoff, parameters });
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchVideo, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class SwitchVideoAlt {
    async switchVideoAlt({ parameters }) {
        let { recordStarted, recordResumed, recordStopped, recordPaused, recordingMediaOptions, videoAlreadyOn, currentFacingMode, allowed, audioOnlyRoom, updateCurrentFacingMode, updateIsMediaSettingsModalVisible, showAlert, 
        //media functions
        switchUserVideoAlt, } = parameters;
        if (audioOnlyRoom) {
            showAlert?.({
                message: 'You cannot turn on your camera in an audio-only event.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        let checkoff = false;
        if ((recordStarted || recordResumed) &&
            !recordStopped &&
            !recordPaused &&
            recordingMediaOptions === 'video') {
            checkoff = true;
        }
        if (!allowed) {
            showAlert?.({
                message: 'Allow access to your camera by starting it for the first time.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (checkoff) {
            if (videoAlreadyOn) {
                showAlert?.({
                    message: 'Please turn off your video before switching.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        else {
            if (!videoAlreadyOn) {
                showAlert?.({
                    message: 'Please turn on your video before switching.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        // Camera switching logic here
        let newFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
        updateCurrentFacingMode(newFacingMode);
        updateIsMediaSettingsModalVisible(false);
        await switchUserVideoAlt({ videoPreference: newFacingMode, checkoff, parameters });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchVideoAlt, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchVideoAlt, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchVideoAlt, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Component for displaying and managing media settings in a modal.
 *
 * @selector app-media-settings-modal
 * @templateUrl ./media-settings-modal.component.html
 * @styleUrls ./media-settings-modal.component.css
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule, FormsModule]
 *
 * @class MediaSettingsModal
 * @implements OnInit, OnChanges
 *
 * @property {boolean} isMediaSettingsModalVisible - Determines if the media settings modal is visible.
 * @property {() => void} onMediaSettingsClose - Callback function to close the media settings modal.
 * @property {(params: any) => Promise<void>} switchCameraOnPress - Callback function to switch the camera.
 * @property {(params: any) => Promise<void>} switchVideoOnPress - Callback function to switch the video.
 * @property {(params: any) => Promise<void>} switchAudioOnPress - Callback function to switch the audio.
 * @property {MediaSettingsModalParameters} parameters - Parameters for the media settings modal.
 * @property {string} position - Position of the modal on the screen. Default is 'topRight'.
 * @property {string} backgroundColor - Background color of the modal. Default is '#83c0e9'.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for closing the modal.
 * @property {IconDefinition} faSyncAlt - FontAwesome icon for sync.
 * @property {IconDefinition} faCamera - FontAwesome icon for camera.
 * @property {IconDefinition} faMicrophone - FontAwesome icon for microphone.
 * @property {IconDefinition} faPhotoFilm - FontAwesome icon for photo film.
 *
 * @property {string} selectedVideoInput - Currently selected video input device ID.
 * @property {string} selectedAudioInput - Currently selected audio input device ID.
 * @property {string} prevSelectedVideoInput - Previously selected video input device ID.
 * @property {string} prevSelectedAudioInput - Previously selected audio input device ID.
 *
 * @constructor
 * @param {SwitchAudio} switchAudioService - Service for switching audio.
 * @param {SwitchVideo} switchVideoService - Service for switching video.
 * @param {SwitchVideoAlt} switchVideoAltService - Alternative service for switching video.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes.
 * @method setupDefaultServices - Sets up default services for switching camera, video, and audio if not provided.
 * @method updateParameters - Updates the parameters for the modal.
 * @method ensureDefaultSelections - Ensures that default selections for video and audio inputs are set.
 * @method initializeModalSettings - Initializes settings for the modal.
 * @method modalContentStyle - Returns the style object for the modal content.
 * @method handleSwitchCamera - Handles the action to switch the camera.
 * @method handleVideoSwitch - Handles the action to switch the video input.
 * @method handleAudioSwitch - Handles the action to switch the audio input.
 * @method handleModalClose - Handles the action to close the modal.
 * @method showVirtual - Toggles the visibility of the virtual background modal.
 */
class MediaSettingsModal {
    switchAudioService;
    switchVideoService;
    switchVideoAltService;
    isMediaSettingsModalVisible = false;
    onMediaSettingsClose;
    switchCameraOnPress;
    switchVideoOnPress;
    switchAudioOnPress;
    parameters;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    faTimes = faTimes;
    faSyncAlt = faSyncAlt;
    faCamera = faCamera;
    faMicrophone = faMicrophone;
    faPhotoFilm = faPhotoFilm;
    selectedVideoInput;
    selectedAudioInput;
    prevSelectedVideoInput;
    prevSelectedAudioInput;
    constructor(switchAudioService, switchVideoService, switchVideoAltService) {
        this.switchAudioService = switchAudioService;
        this.switchVideoService = switchVideoService;
        this.switchVideoAltService = switchVideoAltService;
    }
    ngOnInit() {
        if (this.isMediaSettingsModalVisible) {
            this.updateParameters();
            this.setupDefaultServices();
            this.initializeModalSettings();
            this.ensureDefaultSelections();
        }
    }
    ngOnChanges(changes) {
        if (changes['isMediaSettingsModalVisible'] &&
            this.isMediaSettingsModalVisible &&
            this.parameters) {
            this.updateParameters();
            this.setupDefaultServices();
            this.ensureDefaultSelections();
        }
    }
    setupDefaultServices() {
        if (!this.switchCameraOnPress) {
            this.switchCameraOnPress = (params) => this.switchVideoAltService.switchVideoAlt(params);
        }
        if (!this.switchVideoOnPress) {
            this.switchVideoOnPress = (params) => this.switchVideoService.switchVideo(params);
        }
        if (!this.switchAudioOnPress) {
            this.switchAudioOnPress = (params) => this.switchAudioService.switchAudio(params);
        }
    }
    updateParameters() {
        this.parameters = {
            ...this.parameters,
            ...this.parameters.getUpdatedAllParams(),
        };
    }
    ensureDefaultSelections() {
        if (!this.selectedVideoInput && this.parameters.videoInputs.length > 0) {
            this.selectedVideoInput = this.parameters.videoInputs[0].deviceId;
            this.prevSelectedVideoInput = this.selectedVideoInput;
            this.handleVideoSwitch({ target: { value: this.selectedVideoInput } });
        }
        if (!this.selectedAudioInput && this.parameters.audioInputs.length > 0) {
            this.selectedAudioInput = this.parameters.audioInputs[0].deviceId;
            this.prevSelectedAudioInput = this.selectedAudioInput;
            this.handleAudioSwitch({ target: { value: this.selectedAudioInput } });
        }
    }
    initializeModalSettings() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.7 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
    }
    modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxHeight: '65%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    handleSwitchCamera = async () => {
        await this.switchCameraOnPress({ parameters: this.parameters });
    };
    handleVideoSwitch = async (event) => {
        const value = event.target.value;
        if (value !== this.prevSelectedVideoInput) {
            this.selectedVideoInput = value;
            this.prevSelectedVideoInput = this.selectedVideoInput;
            await this.switchVideoOnPress({ videoPreference: value, parameters: this.parameters });
        }
    };
    handleAudioSwitch = async (event) => {
        const value = event.target.value;
        if (value !== this.prevSelectedAudioInput) {
            this.selectedAudioInput = value;
            this.prevSelectedAudioInput = this.selectedAudioInput;
            await this.switchAudioOnPress({ audioPreference: value, parameters: this.parameters });
        }
    };
    handleModalClose() {
        this.onMediaSettingsClose();
    }
    showVirtual() {
        this.parameters.updateIsBackgroundModalVisible(!this.parameters.isBackgroundModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediaSettingsModal, deps: [{ token: SwitchAudio }, { token: SwitchVideo }, { token: SwitchVideoAlt }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MediaSettingsModal, isStandalone: true, selector: "app-media-settings-modal", inputs: { isMediaSettingsModalVisible: "isMediaSettingsModalVisible", onMediaSettingsClose: "onMediaSettingsClose", switchCameraOnPress: "switchCameraOnPress", switchVideoOnPress: "switchVideoOnPress", switchAudioOnPress: "switchAudioOnPress", parameters: "parameters", position: "position", backgroundColor: "backgroundColor" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isMediaSettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Media Settings</div>\r\n      <div (click)=\"handleModalClose()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label>\r\n          <fa-icon [icon]=\"faCamera\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Select Camera:\r\n        </label>\r\n        <select [(ngModel)]=\"selectedVideoInput\" (change)=\"handleVideoSwitch($event)\" class=\"form-control\">\r\n          <option *ngFor=\"let input of parameters.videoInputs\" [value]=\"input.deviceId\">\r\n            {{ input.label }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <div class=\"form-group\">\r\n        <label>\r\n          <fa-icon [icon]=\"faMicrophone\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Select Microphone:\r\n        </label>\r\n        <select [(ngModel)]=\"selectedAudioInput\" (change)=\"handleAudioSwitch($event)\" class=\"form-control\">\r\n          <option *ngFor=\"let input of parameters.audioInputs\" [value]=\"input.deviceId\">\r\n            {{ input.label }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <hr class=\"hr\" />\r\n      <div class=\"form-group\">\r\n        <button (click)=\"handleSwitchCamera()\" class=\"btn-switch\">\r\n          <fa-icon [icon]=\"faSyncAlt\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Switch Camera\r\n        </button>\r\n      </div>\r\n      <hr class=\"hr\" />\r\n      <div class=\"form-group\">\r\n        <button (click)=\"showVirtual()\" class=\"btn-virtual\">\r\n          <fa-icon [icon]=\"faPhotoFilm\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Virtual Background\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:999}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:5px}.modal-title{font-size:18px;font-weight:700;color:#000}.icon{cursor:pointer;color:#000;font-size:24px;font-weight:700}.form-group{margin-bottom:15px}.form-group label{display:flex;align-items:center;font-size:16px;margin-bottom:5px}.form-control{width:100%;padding:8px;font-size:16px;border:1px solid #ccc;border-radius:4px}.hr{margin:10px 0;border:none;border-top:1px solid #ccc}.btn-switch,.btn-virtual{width:100%;padding:10px;border:none;border-radius:5px;cursor:pointer;font-size:16px;margin-bottom:10px}.btn-switch,.btn-virtual{background-color:#83c0e9;color:#000}.btn-switch:hover,.btn-virtual:hover{background-color:#6aa6d1}.btn-switch:focus,.btn-virtual:focus{outline:none}.button{border-radius:5px;color:#fff;padding:5px 10px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$1.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediaSettingsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-media-settings-modal', standalone: true, imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div *ngIf=\"isMediaSettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Media Settings</div>\r\n      <div (click)=\"handleModalClose()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label>\r\n          <fa-icon [icon]=\"faCamera\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Select Camera:\r\n        </label>\r\n        <select [(ngModel)]=\"selectedVideoInput\" (change)=\"handleVideoSwitch($event)\" class=\"form-control\">\r\n          <option *ngFor=\"let input of parameters.videoInputs\" [value]=\"input.deviceId\">\r\n            {{ input.label }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <div class=\"form-group\">\r\n        <label>\r\n          <fa-icon [icon]=\"faMicrophone\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Select Microphone:\r\n        </label>\r\n        <select [(ngModel)]=\"selectedAudioInput\" (change)=\"handleAudioSwitch($event)\" class=\"form-control\">\r\n          <option *ngFor=\"let input of parameters.audioInputs\" [value]=\"input.deviceId\">\r\n            {{ input.label }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <hr class=\"hr\" />\r\n      <div class=\"form-group\">\r\n        <button (click)=\"handleSwitchCamera()\" class=\"btn-switch\">\r\n          <fa-icon [icon]=\"faSyncAlt\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Switch Camera\r\n        </button>\r\n      </div>\r\n      <hr class=\"hr\" />\r\n      <div class=\"form-group\">\r\n        <button (click)=\"showVirtual()\" class=\"btn-virtual\">\r\n          <fa-icon [icon]=\"faPhotoFilm\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Virtual Background\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:999}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:5px}.modal-title{font-size:18px;font-weight:700;color:#000}.icon{cursor:pointer;color:#000;font-size:24px;font-weight:700}.form-group{margin-bottom:15px}.form-group label{display:flex;align-items:center;font-size:16px;margin-bottom:5px}.form-control{width:100%;padding:8px;font-size:16px;border:1px solid #ccc;border-radius:4px}.hr{margin:10px 0;border:none;border-top:1px solid #ccc}.btn-switch,.btn-virtual{width:100%;padding:10px;border:none;border-radius:5px;cursor:pointer;font-size:16px;margin-bottom:10px}.btn-switch,.btn-virtual{background-color:#83c0e9;color:#000}.btn-switch:hover,.btn-virtual:hover{background-color:#6aa6d1}.btn-switch:focus,.btn-virtual:focus{outline:none}.button{border-radius:5px;color:#fff;padding:5px 10px}\n"] }]
        }], ctorParameters: () => [{ type: SwitchAudio }, { type: SwitchVideo }, { type: SwitchVideoAlt }], propDecorators: { isMediaSettingsModalVisible: [{
                type: Input
            }], onMediaSettingsClose: [{
                type: Input
            }], switchCameraOnPress: [{
                type: Input
            }], switchVideoOnPress: [{
                type: Input
            }], switchAudioOnPress: [{
                type: Input
            }], parameters: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }] } });

// confirm-exit.service.ts
class ConfirmExit {
    /**
     * Confirms the exit of a member from a room and optionally bans them.
     *
     * @param {Object} options - The options for confirming the exit.
     * @param {Socket} options.socket - The socket instance to emit the event.
     * @param {string} options.member - The member who is exiting.
     * @param {string} options.roomName - The name of the room the member is exiting from.
     * @param {boolean} [options.ban=false] - Whether to ban the member from the room.
     * @returns {Promise<void>} A promise that resolves when the exit is confirmed.
     */
    async confirmExit({ socket, member, roomName, ban = false }) {
        // Emit a socket event to disconnect the user from the room
        socket.emit('disconnectUser', { member: member, roomName: roomName, ban: ban });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfirmExit, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfirmExit, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfirmExit, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Component for displaying a confirmation modal when exiting.
 *
 * @selector app-confirm-exit-modal
 * @templateUrl ./confirm-exit-modal.component.html
 * @styleUrls ./confirm-exit-modal.component.css
 * @standalone true
 * @imports [CommonModule, FormsModule, FontAwesomeModule]
 *
 * @class ConfirmExitModal
 * @implements OnInit, OnChanges
 *
 * @property {boolean} isConfirmExitModalVisible - Visibility state of the confirmation modal.
 * @property {() => void} onConfirmExitClose - Callback function to close the modal.
 * @property {string} position - Position of the modal on the screen.
 * @property {string} backgroundColor - Background color of the modal.
 * @property {(options: ConfirmExitOptions) => void} exitEventOnConfirm - Event triggered on confirming exit.
 * @property {string} member - Member information.
 * @property {boolean} ban - Ban status.
 * @property {string} roomName - Name of the room.
 * @property {Socket} socket - Socket instance.
 * @property {string} islevel - Level information.
 * @property {IconDefinition} faTimes - FontAwesome icon for close button.
 * @property {any} modalContentStyle - Style object for modal content.
 *
 * @constructor
 * @param {ConfirmExit} confirmExitService - Service for handling exit confirmation.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes.
 * @param {SimpleChanges} changes - Object of current and previous property values.
 * @method handleConfirmExit - Handles the exit confirmation event.
 */
class ConfirmExitModal {
    confirmExitService;
    isConfirmExitModalVisible = false;
    onConfirmExitClose;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    exitEventOnConfirm;
    member = '';
    ban = false;
    roomName = '';
    socket = {};
    islevel = '';
    faTimes = faTimes;
    modalContentStyle;
    constructor(confirmExitService) {
        this.confirmExitService = confirmExitService;
    }
    ngOnInit() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        this.modalContentStyle = {
            backgroundColor: this.backgroundColor,
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
            width: `${modalWidth}px`,
        };
        if (!this.exitEventOnConfirm) {
            this.exitEventOnConfirm = this.confirmExitService.confirmExit.bind(this.confirmExitService);
        }
    }
    ngOnChanges(changes) {
        if (changes['isConfirmExitModalVisible'] && changes['islevel']) {
            this.islevel = changes['islevel'].currentValue;
        }
    }
    handleConfirmExit() {
        this.exitEventOnConfirm({
            socket: this.socket,
            member: this.member,
            roomName: this.roomName,
            ban: this.ban,
        });
        this.onConfirmExitClose();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfirmExitModal, deps: [{ token: ConfirmExit }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ConfirmExitModal, isStandalone: true, selector: "app-confirm-exit-modal", inputs: { isConfirmExitModalVisible: "isConfirmExitModalVisible", onConfirmExitClose: "onConfirmExitClose", position: "position", backgroundColor: "backgroundColor", exitEventOnConfirm: "exitEventOnConfirm", member: "member", ban: "ban", roomName: "roomName", socket: "socket", islevel: "islevel" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isConfirmExitModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\" style=\"display: flex; justify-content: space-between;\">\r\n      <h2 class=\"modal-title\">Confirm Exit</h2>\r\n      <span class=\"close-icon\" (click)=\"onConfirmExitClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"lg\"></fa-icon>\r\n      </span>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <p class=\"confirm-exit-text\">\r\n        {{ islevel === '2' ? 'This will end the event for all. Confirm exit.' : 'Are you sure you want to exit?' }}\r\n      </p>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-footer\">\r\n      <button class=\"cancel-button\" (click)=\"onConfirmExitClose()\">Cancel</button>\r\n      <button class=\"confirm-button\" (click)=\"handleConfirmExit()\">\r\n        {{ islevel === '2' ? 'End Event' : 'Exit' }}\r\n      </button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:350px;max-height:65%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between}.close-icon{cursor:pointer;color:#000;font-size:large;font-weight:700;margin-right:20px}.modal-footer{display:flex;justify-content:flex-end}.cancel-button,.confirm-button{border-radius:5px;color:#fff;padding:5px 10px}.cancel-button{background-color:#000;margin-right:20px}.confirm-button{background-color:red}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FormsModule }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfirmExitModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-confirm-exit-modal', standalone: true, imports: [CommonModule, FormsModule, FontAwesomeModule], template: "<div *ngIf=\"isConfirmExitModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\" style=\"display: flex; justify-content: space-between;\">\r\n      <h2 class=\"modal-title\">Confirm Exit</h2>\r\n      <span class=\"close-icon\" (click)=\"onConfirmExitClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"lg\"></fa-icon>\r\n      </span>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <p class=\"confirm-exit-text\">\r\n        {{ islevel === '2' ? 'This will end the event for all. Confirm exit.' : 'Are you sure you want to exit?' }}\r\n      </p>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-footer\">\r\n      <button class=\"cancel-button\" (click)=\"onConfirmExitClose()\">Cancel</button>\r\n      <button class=\"confirm-button\" (click)=\"handleConfirmExit()\">\r\n        {{ islevel === '2' ? 'End Event' : 'Exit' }}\r\n      </button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:350px;max-height:65%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between}.close-icon{cursor:pointer;color:#000;font-size:large;font-weight:700;margin-right:20px}.modal-footer{display:flex;justify-content:flex-end}.cancel-button,.confirm-button{border-radius:5px;color:#fff;padding:5px 10px}.cancel-button{background-color:#000;margin-right:20px}.confirm-button{background-color:red}\n"] }]
        }], ctorParameters: () => [{ type: ConfirmExit }], propDecorators: { isConfirmExitModalVisible: [{
                type: Input
            }], onConfirmExitClose: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], exitEventOnConfirm: [{
                type: Input
            }], member: [{
                type: Input
            }], ban: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], islevel: [{
                type: Input
            }] } });

/**
 * Component representing a confirmation modal with a countdown timer.
 *
 * @selector app-confirm-here-modal
 * @templateUrl ./confirm-here-modal.component.html
 * @styleUrls ./confirm-here-modal.component.css
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule]
 *
 * @styles
 * - .spinner: Styles for the loading spinner.
 * - @keyframes spin: Keyframes for spinner animation.
 * - .modal-content: Styles for the modal content container.
 * - .loading-text: Styles for the loading text.
 *
 * @class ConfirmHereModal
 * @implements OnInit, OnDestroy
 *
 * @property {boolean} isConfirmHereModalVisible - Determines if the modal is visible.
 * @property {string} position - Position of the modal.
 * @property {string} backgroundColor - Background color of the modal.
 * @property {string} displayColor - Display color of the modal.
 * @property {Function} onConfirmHereClose - Callback function to execute when the modal is closed.
 * @property {number} [countdownDuration=120] - Duration of the countdown in seconds.
 * @property {Socket} socket - Socket instance for communication.
 * @property {string} roomName - Name of the room for socket communication.
 * @property {string} member - Member identifier for socket communication.
 * @property {IconDefinition} faSpinner - FontAwesome spinner icon.
 * @property {number} counter - Countdown counter.
 * @property {any} countdownInterval - Interval ID for the countdown timer.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes.
 * @method ngOnDestroy - Lifecycle hook that is called just before the component is destroyed.
 * @method startCountdown - Starts the countdown timer.
 * @method clearCountdown - Clears the countdown timer.
 * @method handleConfirmHere - Handles the confirmation action and closes the modal.
 *
 * @getter spinnerContainerStyle - Returns the style object for the spinner container.
 * @getter modalContainerStyle - Returns the style object for the modal container.
 * @getter modalContentStyle - Returns the style object for the modal content.
 */
class ConfirmHereModal {
    isConfirmHereModalVisible = false;
    position = 'center';
    backgroundColor = '#83c0e9';
    displayColor = '#000000';
    onConfirmHereClose;
    countdownDuration = 120;
    socket;
    roomName;
    member;
    faSpinner = faSpinner;
    counter;
    countdownInterval;
    ngOnInit() {
        this.counter = this.countdownDuration ? this.countdownDuration : 120;
        if (this.isConfirmHereModalVisible) {
            this.startCountdown();
        }
    }
    ngOnChanges(changes) {
        if (changes['isConfirmHereModalVisible'] && changes['isConfirmHereModalVisible'].currentValue) {
            this.counter = this.countdownDuration ? this.countdownDuration : 120;
            this.startCountdown();
        }
        else {
            this.clearCountdown();
        }
    }
    ngOnDestroy() {
        this.clearCountdown();
    }
    startCountdown = () => {
        this.countdownInterval = setInterval(() => {
            this.counter--;
            if (this.counter <= 0) {
                this.clearCountdown();
                this.socket.emit('disconnectUser', {
                    member: this.member,
                    roomName: this.roomName,
                    ban: false,
                });
                this.onConfirmHereClose();
            }
        }, 1000);
    };
    clearCountdown = () => {
        if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
        }
    };
    handleConfirmHere() {
        this.clearCountdown();
        this.onConfirmHereClose();
    }
    get spinnerContainerStyle() {
        return {
            marginBottom: '20px',
        };
    }
    get modalContainerStyle() {
        return {
            'background-color': this.backgroundColor || 'rgba(0, 0, 0, 0.5)',
            display: this.isConfirmHereModalVisible ? 'block' : 'none',
        };
    }
    get modalContentStyle() {
        return {
            'background-color': this.backgroundColor,
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfirmHereModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ConfirmHereModal, isStandalone: true, selector: "app-confirm-here-modal", inputs: { isConfirmHereModalVisible: "isConfirmHereModalVisible", position: "position", backgroundColor: "backgroundColor", displayColor: "displayColor", onConfirmHereClose: "onConfirmHereClose", countdownDuration: "countdownDuration", socket: "socket", roomName: "roomName", member: "member" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isConfirmHereModalVisible\" [ngStyle]=\"modalContainerStyle\" class=\"modal-container\">\r\n  <div [ngStyle]=\"modalContentStyle\" class=\"modal-content\">\r\n    <div class=\"spinner\" [ngStyle]=\"spinnerContainerStyle\"></div>\r\n    <h2 style=\"font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem; color: black;\">Are you still there?</h2>\r\n    <p style=\"font-size: 1rem; color: black; margin-bottom: 1.5rem;\">Please confirm if you are still present.</p>\r\n    <p style=\"font-size: 0.9rem; color: black; margin-bottom: 1rem;\">Time remaining: <strong>{{ counter }}</strong></p>\r\n    <button (click)=\"handleConfirmHere()\" style=\"background-color: #dc3545; color: white; padding: 0.5rem 1rem; border-radius: 5px; border: none; cursor: pointer; font-weight: bold; font-size: 1rem;\">\r\n      Yes\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:100%;max-height:100%;overflow-y:auto}\n", ".spinner{border:12px solid #f3f3f3;border-top:12px solid black;border-radius:50%;width:50px;height:50px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.modal-content{display:flex;flex-direction:column;align-items:center}.loading-text{margin-top:10px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfirmHereModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-confirm-here-modal', standalone: true, imports: [CommonModule, FontAwesomeModule], template: "<div *ngIf=\"isConfirmHereModalVisible\" [ngStyle]=\"modalContainerStyle\" class=\"modal-container\">\r\n  <div [ngStyle]=\"modalContentStyle\" class=\"modal-content\">\r\n    <div class=\"spinner\" [ngStyle]=\"spinnerContainerStyle\"></div>\r\n    <h2 style=\"font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem; color: black;\">Are you still there?</h2>\r\n    <p style=\"font-size: 1rem; color: black; margin-bottom: 1.5rem;\">Please confirm if you are still present.</p>\r\n    <p style=\"font-size: 0.9rem; color: black; margin-bottom: 1rem;\">Time remaining: <strong>{{ counter }}</strong></p>\r\n    <button (click)=\"handleConfirmHere()\" style=\"background-color: #dc3545; color: white; padding: 0.5rem 1rem; border-radius: 5px; border: none; cursor: pointer; font-weight: bold; font-size: 1rem;\">\r\n      Yes\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:100%;max-height:100%;overflow-y:auto}\n", ".spinner{border:12px solid #f3f3f3;border-top:12px solid black;border-radius:50%;width:50px;height:50px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.modal-content{display:flex;flex-direction:column;align-items:center}.loading-text{margin-top:10px}\n"] }]
        }], propDecorators: { isConfirmHereModalVisible: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], displayColor: [{
                type: Input
            }], onConfirmHereClose: [{
                type: Input
            }], countdownDuration: [{
                type: Input
            }], socket: [{
                type: Input
            }], roomName: [{
                type: Input
            }], member: [{
                type: Input
            }] } });

/**
 * Component for displaying a modal to share event details.
 *
 * @component
 * @selector app-share-event-modal
 * @templateUrl ./share-event-modal.component.html
 * @styleUrls ./share-event-modal.component.css
 *
 * @imports CommonModule, FontAwesomeModule, MeetingIdComponent, MeetingPasscodeComponent, ShareButtonsComponent
 *
 * @property {string} backgroundColor - Background color of the modal content.
 * @property {boolean} isShareEventModalVisible - Visibility state of the share event modal.
 * @property {Function} onShareEventClose - Callback function to handle modal close event.
 * @property {string} roomName - Name of the room to be shared.
 * @property {string} adminPasscode - Admin passcode for the room.
 * @property {string} islevel - Level of the event (e.g., admin, user).
 * @property {string} position - Position of the modal on the screen (e.g., topRight, bottomLeft).
 * @property {boolean} shareButtons - Flag to display share buttons in the modal.
 * @property {EventType} eventType - Type of event (e.g., chat, broadcast, webinar).
 *
 * @method handleClose - Closes the share event modal by invoking the onShareEventClose callback.
 *
 * @getter modalContainerStyle - Returns the style object for the modal container.
 * @getter modalContentStyle - Returns the style object for the modal content.
 */
class ShareEventModal {
    backgroundColor = 'rgba(255, 255, 255, 0.25)';
    isShareEventModalVisible = false;
    onShareEventClose;
    roomName;
    adminPasscode;
    islevel;
    position = 'topRight';
    shareButtons = true;
    eventType;
    faTimes = faTimes;
    handleClose() {
        this.onShareEventClose();
    }
    get modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isShareEventModalVisible ? 'block' : 'none',
            zIndex: 999,
        };
    }
    get modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        return {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxHeight: '60%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ShareEventModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ShareEventModal, isStandalone: true, selector: "app-share-event-modal", inputs: { backgroundColor: "backgroundColor", isShareEventModalVisible: "isShareEventModalVisible", onShareEventClose: "onShareEventClose", roomName: "roomName", adminPasscode: "adminPasscode", islevel: "islevel", position: "position", shareButtons: "shareButtons", eventType: "eventType" }, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div style=\"display: flex; flex-direction: row-reverse; margin-bottom: 15px;\">\r\n      <div (click)=\"handleClose()\" style=\"padding: 5px;\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n    <div style=\"flex: 1;\">\r\n      <div style=\"margin-bottom: 10px;\" *ngIf=\"islevel === '2'\">\r\n        <app-meeting-passcode-component [meetingPasscode]=\"adminPasscode\"></app-meeting-passcode-component>\r\n      </div>\r\n      <div style=\"margin-bottom: 10px;\">\r\n        <app-meeting-id-component [meetingID]=\"roomName\"></app-meeting-id-component>\r\n      </div>\r\n      <div *ngIf=\"shareButtons\">\r\n        <app-share-buttons-component [meetingID]=\"roomName\" [eventType]=\"eventType\"></app-share-buttons-component>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: MeetingIdComponent, selector: "app-meeting-id-component", inputs: ["meetingID"] }, { kind: "component", type: MeetingPasscodeComponent, selector: "app-meeting-passcode-component", inputs: ["meetingPasscode"] }, { kind: "component", type: ShareButtonsComponent, selector: "app-share-buttons-component", inputs: ["meetingID", "shareButtons", "eventType"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ShareEventModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-share-event-modal', standalone: true, imports: [
                        CommonModule,
                        FontAwesomeModule,
                        MeetingIdComponent,
                        MeetingPasscodeComponent,
                        ShareButtonsComponent,
                    ], template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div style=\"display: flex; flex-direction: row-reverse; margin-bottom: 15px;\">\r\n      <div (click)=\"handleClose()\" style=\"padding: 5px;\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n    <div style=\"flex: 1;\">\r\n      <div style=\"margin-bottom: 10px;\" *ngIf=\"islevel === '2'\">\r\n        <app-meeting-passcode-component [meetingPasscode]=\"adminPasscode\"></app-meeting-passcode-component>\r\n      </div>\r\n      <div style=\"margin-bottom: 10px;\">\r\n        <app-meeting-id-component [meetingID]=\"roomName\"></app-meeting-id-component>\r\n      </div>\r\n      <div *ngIf=\"shareButtons\">\r\n        <app-share-buttons-component [meetingID]=\"roomName\" [eventType]=\"eventType\"></app-share-buttons-component>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n" }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], isShareEventModalVisible: [{
                type: Input
            }], onShareEventClose: [{
                type: Input
            }], roomName: [{
                type: Input
            }], adminPasscode: [{
                type: Input
            }], islevel: [{
                type: Input
            }], position: [{
                type: Input
            }], shareButtons: [{
                type: Input
            }], eventType: [{
                type: Input
            }] } });

const MAX_ATTEMPTS$1 = 10; // Maximum number of unsuccessful attempts before rate limiting
const RATE_LIMIT_DURATION$1 = 3 * 60 * 60 * 1000; // 3 hours in milliseconds
class WelcomePage {
    fb;
    cookieService;
    welcomeForm;
    error = '';
    isScannerVisible = false;
    scannedData = null;
    parameters = {};
    faQrcode = faQrcode;
    allowedCameras = []; // List of allowed cameras
    currentDevice = null; // Active camera device
    imgSrc = '';
    constructor(fb, cookieService, injectedParameters) {
        this.fb = fb;
        this.cookieService = cookieService;
        this.welcomeForm = this.fb.group({
            name: [
                '',
                [Validators.required, Validators.pattern('^[a-zA-Z0-9]+$'), Validators.maxLength(12)],
            ],
            secret: [
                '',
                [Validators.required, Validators.pattern('^[a-zA-Z0-9]+$'), Validators.maxLength(64)],
            ],
            eventID: [
                '',
                [Validators.required, Validators.pattern('^[a-zA-Z0-9]+$'), Validators.maxLength(32)],
            ],
            link: ['', [Validators.required, Validators.pattern('^https?://.+mediasfu\\.com.+$')]],
        });
        this.parameters = injectedParameters || this.parameters;
    }
    ngOnInit() {
        this.askForCameraPermission();
    }
    async checkLimitsAndMakeRequest(apiUserName, apiToken, link, userName) {
        const TIMEOUT_DURATION = 10000; // 10 seconds
        let unsuccessfulAttempts = parseInt(this.cookieService.get('unsuccessfulAttempts')) || 0;
        let lastRequestTimestamp = parseInt(this.cookieService.get('lastRequestTimestamp')) || 0;
        if (unsuccessfulAttempts >= MAX_ATTEMPTS$1) {
            if (Date.now() - lastRequestTimestamp < RATE_LIMIT_DURATION$1) {
                this.parameters.showAlert?.({
                    message: 'Too many unsuccessful attempts. Please try again later.',
                    type: 'danger',
                    duration: 3000,
                });
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
                return;
            }
            else {
                unsuccessfulAttempts = 0;
                this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
            }
        }
        try {
            this.parameters.updateIsLoadingModalVisible(true);
            const socketPromise = this.parameters.connectSocket({ apiUserName, apiToken, link });
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Request timed out')), TIMEOUT_DURATION));
            const socket = await Promise.race([socketPromise, timeoutPromise]);
            if (socket && socket instanceof Socket && socket.id) {
                unsuccessfulAttempts = 0;
                this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
                this.parameters.updateSocket(socket);
                this.parameters.updateApiUserName(apiUserName);
                this.parameters.updateApiToken(apiToken);
                this.parameters.updateLink(link);
                this.parameters.updateRoomName(apiUserName);
                this.parameters.updateMember(userName);
                this.parameters.updateValidated(true);
            }
            else {
                unsuccessfulAttempts += 1;
                this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
                this.parameters.updateIsLoadingModalVisible(false);
                if (unsuccessfulAttempts >= MAX_ATTEMPTS$1) {
                    this.parameters.showAlert?.({
                        message: 'Too many unsuccessful attempts. Please try again later.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
                else {
                    this.parameters.showAlert?.({
                        message: 'Invalid credentials.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
        }
        catch (error) {
            this.parameters.showAlert?.({
                message: 'Unable to connect. Check your credentials and try again.',
                type: 'danger',
                duration: 3000,
            });
            unsuccessfulAttempts += 1;
            this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
            this.cookieService.set('lastRequestTimestamp', Date.now().toString());
            this.parameters.updateIsLoadingModalVisible(false);
        }
    }
    handleScanSuccess(data) {
        try {
            const scannedText = data;
            const parts = scannedText.split(';');
            if (parts.length === 5) {
                const [userName, link, userSecret, passWord, meetingID] = parts;
                if (!userName.length ||
                    !link.length ||
                    !userSecret.length ||
                    !passWord.length ||
                    !meetingID.length ||
                    !this.validateAlphanumeric(userName) ||
                    !this.validateAlphanumeric(userSecret) ||
                    !this.validateAlphanumeric(passWord) ||
                    !this.validateAlphanumeric(meetingID) ||
                    userSecret.length !== 64 ||
                    userName.length > 12 ||
                    userName.length < 2 ||
                    meetingID.length > 32 ||
                    meetingID.length < 8 ||
                    !link.includes('mediasfu.com') ||
                    meetingID.toLowerCase().startsWith('d')) {
                    this.parameters.showAlert?.({
                        message: 'Invalid scanned data.',
                        type: 'danger',
                        duration: 3000,
                    });
                    return;
                }
                this.welcomeForm.setValue({
                    name: userName,
                    secret: userSecret,
                    eventID: meetingID,
                    link: link,
                });
                this.isScannerVisible = false;
                this.scannedData = null;
                this.checkLimitsAndMakeRequest(meetingID, userSecret, link, userName);
            }
            else {
                this.parameters.showAlert?.({
                    message: 'Invalid scanned data.',
                    type: 'danger',
                    duration: 3000,
                });
            }
        }
        catch (error) {
            this.parameters.showAlert?.({
                message: 'Invalid scanned data.',
                type: 'danger',
                duration: 3000,
            });
        }
    }
    validateAlphanumeric(str) {
        const alphanumericRegex = /^[a-zA-Z0-9]+$/;
        return alphanumericRegex.test(str);
    }
    // Method to list available cameras
    askForCameraPermission() {
        navigator.mediaDevices
            .enumerateDevices()
            .then((devices) => {
            this.allowedCameras = devices.filter((device) => device.kind === 'videoinput');
            if (this.allowedCameras.length > 0) {
                this.currentDevice = this.allowedCameras[0]; // Set the first available camera as the default
            }
        })
            .catch((err) => {
            console.error(err);
            this.parameters.showAlert?.({
                message: 'Camera access denied.',
                type: 'danger',
                duration: 3000,
            });
        });
    }
    toggleScanner() {
        this.isScannerVisible = !this.isScannerVisible;
        if (this.isScannerVisible) {
            this.askForCameraPermission();
        }
    }
    async handleConfirm() {
        if (this.welcomeForm.invalid) {
            this.error = 'Please fill all the fields correctly.';
            return;
        }
        const { name, secret, eventID, link } = this.welcomeForm.value;
        await this.checkLimitsAndMakeRequest(eventID, secret, link, name);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: WelcomePage, deps: [{ token: i2$1.FormBuilder }, { token: i2$2.CookieService }, { token: 'parameters', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: WelcomePage, isStandalone: true, selector: "app-welcome-page", providers: [CookieService], ngImport: i0, template: "<div class=\"container\">\r\n  <div class=\"logo-container\">\r\n    <img [src]=\"imgSrc || 'https://mediasfu.com/images/logo192.png'\" class=\"logo-image\" alt=\"Logo\" />\r\n  </div>\r\n  <form [formGroup]=\"welcomeForm\" (ngSubmit)=\"handleConfirm()\">\r\n    <div class=\"input-container\">\r\n      <input\r\n        formControlName=\"name\"\r\n        type=\"text\"\r\n        placeholder=\"Event Display Name\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"secret\"\r\n        type=\"text\"\r\n        placeholder=\"Event Token (Secret)\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"eventID\"\r\n        type=\"text\"\r\n        placeholder=\"Event ID\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"link\"\r\n        type=\"text\"\r\n        placeholder=\"Event Link\"\r\n        class=\"input-field\"\r\n      />\r\n    </div>\r\n    <button type=\"submit\" class=\"confirm-button\">Confirm</button>\r\n  </form>\r\n\r\n  <div class=\"scanner-container\">\r\n    <div class=\"or-container\">\r\n      <hr class=\"horizontal-line\" />\r\n      <span class=\"or-text\">OR</span>\r\n      <hr class=\"horizontal-line\" />\r\n    </div>\r\n    <div *ngIf=\"isScannerVisible\" class=\"scanner-wrapper\">\r\n      <zxing-scanner\r\n        [device]=\"currentDevice!\"\r\n        (scanSuccess)=\"handleScanSuccess($event)\"\r\n        [tryHarder]=\"true\"\r\n      ></zxing-scanner>\r\n    </div>\r\n    <div class=\"scan-button-container\" *ngIf=\"!isScannerVisible\">\r\n      <button (click)=\"toggleScanner()\" class=\"scan-button\">\r\n        <fa-icon [icon]=\"faQrcode\" style=\"margin-right: 5px\"></fa-icon>\r\n        Scan QR Code\r\n      </button>\r\n    </div>\r\n  </div>\r\n\r\n  <div class=\"additional-options-container\">\r\n    <p>\r\n      Provide the event details either by typing manually or scanning the\r\n      QR-code to autofill.\r\n    </p>\r\n    <p>Don't have a secret?</p>\r\n    <a\r\n      href=\"https://meeting.mediasfu.com/meeting/start/\"\r\n      target=\"_blank\"\r\n      class=\"link\"\r\n      >Get one from mediasfu.com</a\r\n    >\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100vw;height:100vh;max-width:100vw;max-height:100vh;margin:0;padding:0;background-color:#53c6e0;overflow:auto}.logo-container{margin-top:30px;padding-top:10px;margin-bottom:10px}.logo-image{width:100px;height:100px;border-radius:50%}.input-container{margin-bottom:10px;display:flex;flex-direction:column;align-items:center;justify-content:center}.input-field{height:30px;border-color:gray;border-width:1px;margin-bottom:10px;padding:0 5px;border-radius:5px}.confirm-button{background-color:#000;color:#fff;padding:5px;border-radius:5px;margin-bottom:10px;width:100%}.scanner-container{margin-bottom:10px;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}.additional-options-container{text-align:center}.link{color:#00f;text-decoration:none;font-weight:700;margin-left:5px}.scan-button{background-color:#000;color:#fff;padding:10px 20px;border-radius:5px;margin-bottom:20px}.scan-button-container{display:flex;justify-content:center;align-items:center}.or-container{display:flex;align-items:center;justify-content:center;width:100%;margin:10px 0}.horizontal-line{flex-grow:1;height:1px;background-color:gray;margin:0 10px}.or-text{color:#000;font-size:medium;font-weight:700}.scanner-wrapper{width:300px;height:300px;max-width:300px;max-height:300px;overflow:hidden;position:relative}zxing-scanner{width:100%;height:100%;object-fit:cover}\n"], dependencies: [{ kind: "ngmodule", type: ZXingScannerModule }, { kind: "component", type: i3.ZXingScannerComponent, selector: "zxing-scanner", inputs: ["autofocusEnabled", "timeBetweenScans", "delayBetweenScanSuccess", "autostart", "previewFitMode", "poster", "device", "formats", "videoConstraints", "torch", "enable", "tryHarder"], outputs: ["autostarted", "autostarting", "torchCompatible", "scanSuccess", "scanFailure", "scanError", "scanComplete", "camerasFound", "camerasNotFound", "permissionResponse", "hasDevices", "deviceChange"] }, { kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i2$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: WelcomePage, decorators: [{
            type: Component,
            args: [{ selector: 'app-welcome-page', standalone: true, imports: [ZXingScannerModule, CommonModule, FontAwesomeModule, ReactiveFormsModule], providers: [CookieService], template: "<div class=\"container\">\r\n  <div class=\"logo-container\">\r\n    <img [src]=\"imgSrc || 'https://mediasfu.com/images/logo192.png'\" class=\"logo-image\" alt=\"Logo\" />\r\n  </div>\r\n  <form [formGroup]=\"welcomeForm\" (ngSubmit)=\"handleConfirm()\">\r\n    <div class=\"input-container\">\r\n      <input\r\n        formControlName=\"name\"\r\n        type=\"text\"\r\n        placeholder=\"Event Display Name\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"secret\"\r\n        type=\"text\"\r\n        placeholder=\"Event Token (Secret)\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"eventID\"\r\n        type=\"text\"\r\n        placeholder=\"Event ID\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"link\"\r\n        type=\"text\"\r\n        placeholder=\"Event Link\"\r\n        class=\"input-field\"\r\n      />\r\n    </div>\r\n    <button type=\"submit\" class=\"confirm-button\">Confirm</button>\r\n  </form>\r\n\r\n  <div class=\"scanner-container\">\r\n    <div class=\"or-container\">\r\n      <hr class=\"horizontal-line\" />\r\n      <span class=\"or-text\">OR</span>\r\n      <hr class=\"horizontal-line\" />\r\n    </div>\r\n    <div *ngIf=\"isScannerVisible\" class=\"scanner-wrapper\">\r\n      <zxing-scanner\r\n        [device]=\"currentDevice!\"\r\n        (scanSuccess)=\"handleScanSuccess($event)\"\r\n        [tryHarder]=\"true\"\r\n      ></zxing-scanner>\r\n    </div>\r\n    <div class=\"scan-button-container\" *ngIf=\"!isScannerVisible\">\r\n      <button (click)=\"toggleScanner()\" class=\"scan-button\">\r\n        <fa-icon [icon]=\"faQrcode\" style=\"margin-right: 5px\"></fa-icon>\r\n        Scan QR Code\r\n      </button>\r\n    </div>\r\n  </div>\r\n\r\n  <div class=\"additional-options-container\">\r\n    <p>\r\n      Provide the event details either by typing manually or scanning the\r\n      QR-code to autofill.\r\n    </p>\r\n    <p>Don't have a secret?</p>\r\n    <a\r\n      href=\"https://meeting.mediasfu.com/meeting/start/\"\r\n      target=\"_blank\"\r\n      class=\"link\"\r\n      >Get one from mediasfu.com</a\r\n    >\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100vw;height:100vh;max-width:100vw;max-height:100vh;margin:0;padding:0;background-color:#53c6e0;overflow:auto}.logo-container{margin-top:30px;padding-top:10px;margin-bottom:10px}.logo-image{width:100px;height:100px;border-radius:50%}.input-container{margin-bottom:10px;display:flex;flex-direction:column;align-items:center;justify-content:center}.input-field{height:30px;border-color:gray;border-width:1px;margin-bottom:10px;padding:0 5px;border-radius:5px}.confirm-button{background-color:#000;color:#fff;padding:5px;border-radius:5px;margin-bottom:10px;width:100%}.scanner-container{margin-bottom:10px;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}.additional-options-container{text-align:center}.link{color:#00f;text-decoration:none;font-weight:700;margin-left:5px}.scan-button{background-color:#000;color:#fff;padding:10px 20px;border-radius:5px;margin-bottom:20px}.scan-button-container{display:flex;justify-content:center;align-items:center}.or-container{display:flex;align-items:center;justify-content:center;width:100%;margin:10px 0}.horizontal-line{flex-grow:1;height:1px;background-color:gray;margin:0 10px}.or-text{color:#000;font-size:medium;font-weight:700}.scanner-wrapper{width:300px;height:300px;max-width:300px;max-height:300px;overflow:hidden;position:relative}zxing-scanner{width:100%;height:100%;object-fit:cover}\n"] }]
        }], ctorParameters: () => [{ type: i2$1.FormBuilder }, { type: i2$2.CookieService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }] });

const MAX_ATTEMPTS = 20; // Maximum number of unsuccessful attempts before rate limiting
const RATE_LIMIT_DURATION = 3 * 60 * 60 * 1000; // 3 hours in milliseconds
const TIMEOUT_DURATION = 10000; // 5 seconds in milliseconds
/**
 * @fileoverview PreJoinPage component for handling room creation and joining on MediaSFU.
 *
 * @component
 * @selector app-pre-join-page
 * @standalone true
 * @templateUrl ./pre-join-page.component.html
 * @styleUrls ./pre-join-page.component.css
 * @imports [CommonModule, ReactiveFormsModule]
 *
 * @description
 * This component provides functionality for users to create or join a room on MediaSFU.
 * It includes form validation, error handling, and API requests to the MediaSFU service.
 *
 * @property {any} parameters - Input parameters for the component.
 * @property {Object} credentials - API credentials for MediaSFU.
 * @property {string} credentials.apiUserName - API username.
 * @property {string} credentials.apiKey - API key.
 * @property {boolean} isCreateMode - Flag to toggle between create and join modes.
 * @property {FormGroup} preJoinForm - Form group for pre-join form.
 * @property {string} error - Error message to display.
 *
 * @constructor
 * @param {FormBuilder} fb - FormBuilder service for creating form groups.
 * @param {HttpClient} http - HttpClient service for making HTTP requests.
 * @param {CookieService} cookieService - CookieService for managing cookies.
 *
 * @method ngOnInit
 * @description Lifecycle hook that is called after data-bound properties are initialized.
 *
 * @method toggleMode
 * @description Toggles between create and join modes and resets the error message.
 *
 * @method handleCreateRoom
 * @description Handles the creation of a room on MediaSFU. Validates form inputs, sends a request to create a room, and handles the response.
 *
 * @method handleJoinRoom
 * @description Handles joining a room on MediaSFU. Validates form inputs, sends a request to join a room, and handles the response.
 *
 * @method checkLimitsAndMakeRequest
 * @description Checks rate limits and makes a request to connect to a room. Handles unsuccessful attempts and updates the state accordingly.
 *
 * @method createRoomOnMediaSFU
 * @description Sends a request to create a room on MediaSFU.
 * @param {Object} params - Parameters for the request.
 * @param {any} params.payload - Payload for the request.
 * @param {string} params.apiUserName - API username.
 * @param {string} params.apiKey - API key.
 * @returns {Promise<{ data: CreateJoinRoomResponse | CreateJoinRoomError | null; success: boolean }>} Response from the API.
 *
 * @method joinRoomOnMediaSFU
 * @description Sends a request to join a room on MediaSFU.
 * @param {Object} params - Parameters for the request.
 * @param {any} params.payload - Payload for the request.
 * @param {string} params.apiUserName - API username.
 * @param {string} params.apiKey - API key.
 * @returns {Promise<{ data: CreateJoinRoomResponse | CreateJoinRoomError | null; success: boolean }>} Response from the API.
 */
class PreJoinPage {
    fb;
    http;
    cookieService;
    parameters = {};
    credentials = { apiUserName: 'yourAPIUSERNAME', apiKey: 'yourAPIKEY' };
    isCreateMode = false;
    preJoinForm;
    error = '';
    imgSrc = this.parameters.imgSrc || '';
    constructor(fb, http, cookieService, injectedParameters, injectedCredentials) {
        this.fb = fb;
        this.http = http;
        this.cookieService = cookieService;
        this.preJoinForm = this.fb.group({
            name: ['', Validators.required],
            duration: [''],
            eventType: [''],
            capacity: [''],
            eventID: [''],
        });
        this.parameters = injectedParameters || this.parameters;
        this.credentials = injectedCredentials || this.credentials;
    }
    toggleMode() {
        this.isCreateMode = !this.isCreateMode;
        this.error = '';
    }
    async handleCreateRoom() {
        if (this.preJoinForm.invalid) {
            this.error = 'Please fill all the fields.';
            return;
        }
        const { name, duration, eventType, capacity } = this.preJoinForm.value;
        if (!name || !duration || !eventType || !capacity) {
            this.error = 'Please fill all the fields.';
            return;
        }
        const payload = {
            action: 'create',
            duration: parseInt(duration),
            capacity: parseInt(capacity),
            eventType,
            userName: name,
        };
        this.parameters.updateIsLoadingModalVisible(true);
        try {
            const response = await this.createRoomOnMediaSFU({
                payload,
                apiUserName: this.credentials.apiUserName,
                apiKey: this.credentials.apiKey,
            });
            if (response.success && response.data && 'roomName' in response.data) {
                await this.checkLimitsAndMakeRequest({
                    apiUserName: response.data.roomName,
                    apiToken: response.data.secret,
                    link: response.data.link,
                    userName: name,
                });
                this.error = '';
            }
            else {
                this.parameters.updateIsLoadingModalVisible(false);
                this.error = `${response.data ? ('error' in response.data ? response.data.error : '') : ''}`;
            }
        }
        catch (error) {
            this.parameters.updateIsLoadingModalVisible(false);
            this.error = `Unable to connect. ${error.message}`;
        }
    }
    async handleJoinRoom() {
        if (this.preJoinForm.invalid) {
            this.error = 'Please fill all the fields.';
            return;
        }
        const { name, eventID } = this.preJoinForm.value;
        if (!name || !eventID) {
            this.error = 'Please fill all the fields.';
            return;
        }
        const payload = {
            action: 'join',
            meetingID: eventID,
            userName: name,
        };
        this.parameters.updateIsLoadingModalVisible(true);
        try {
            const response = await this.joinRoomOnMediaSFU({
                payload,
                apiUserName: this.credentials.apiUserName,
                apiKey: this.credentials.apiKey,
            });
            if (response.success && response.data && 'roomName' in response.data) {
                await this.checkLimitsAndMakeRequest({
                    apiUserName: response.data.roomName,
                    apiToken: response.data.secret,
                    link: response.data.link,
                    userName: name,
                });
                this.error = '';
            }
            else {
                this.parameters.updateIsLoadingModalVisible(false);
                this.error = `Unable to connect to room. ${response.data ? ('error' in response.data ? response.data.error : '') : ''}`;
            }
        }
        catch (error) {
            this.parameters.updateIsLoadingModalVisible(false);
            this.error = `Unable to connect. ${error.message}`;
        }
    }
    async checkLimitsAndMakeRequest({ apiUserName, apiToken, link, apiKey = '', userName, }) {
        let unsuccessfulAttempts = parseInt(this.cookieService.get('unsuccessfulAttempts')) || 0;
        let lastRequestTimestamp = parseInt(this.cookieService.get('lastRequestTimestamp')) || 0;
        if (unsuccessfulAttempts >= MAX_ATTEMPTS) {
            if (Date.now() - lastRequestTimestamp < RATE_LIMIT_DURATION) {
                this.parameters.showAlert?.({
                    message: 'Too many unsuccessful attempts. Please try again later.',
                    type: 'danger',
                    duration: 3000,
                });
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
                return;
            }
            else {
                unsuccessfulAttempts = 0;
                this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
            }
        }
        try {
            this.parameters.updateIsLoadingModalVisible(true);
            const socketPromise = await this.parameters.connectSocket({
                apiUserName,
                apiKey,
                apiToken,
                link,
            });
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Request timed out')), TIMEOUT_DURATION));
            const socket = await Promise.race([socketPromise, timeoutPromise]);
            if (socket && socket instanceof Socket && socket.id) {
                unsuccessfulAttempts = 0;
                this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
                this.parameters.updateSocket(socket);
                this.parameters.updateApiUserName(apiUserName);
                this.parameters.updateApiToken(apiToken);
                this.parameters.updateLink(link);
                this.parameters.updateRoomName(apiUserName);
                this.parameters.updateMember(userName);
                this.parameters.updateValidated(true);
            }
            else {
                unsuccessfulAttempts += 1;
                this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
                this.parameters.updateIsLoadingModalVisible(false);
                if (unsuccessfulAttempts >= MAX_ATTEMPTS) {
                    this.parameters.showAlert?.({
                        message: 'Too many unsuccessful attempts. Please try again later.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
                else {
                    this.parameters.showAlert?.({
                        message: 'Invalid credentials.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
        }
        catch (error) {
            this.parameters.showAlert?.({
                message: 'Unable to connect. Check your credentials and try again.',
                type: 'danger',
                duration: 3000,
            });
            unsuccessfulAttempts += 1;
            this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
            this.cookieService.set('lastRequestTimestamp', Date.now().toString());
            this.parameters.updateIsLoadingModalVisible(false);
        }
    }
    async createRoomOnMediaSFU({ payload, apiUserName, apiKey, }) {
        try {
            if (!apiUserName ||
                !apiKey ||
                apiUserName === 'yourAPIUSERNAME' ||
                apiKey === 'yourAPIKEY' ||
                apiKey.length !== 64 ||
                apiUserName.length < 6) {
                return { data: { error: 'Invalid credentials' }, success: false };
            }
            const response = await this.http
                .post('https://mediasfu.com/v1/rooms/', payload, {
                headers: new HttpHeaders({
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${apiUserName}:${apiKey}`,
                }),
            })
                .toPromise();
            return { data: response, success: true };
        }
        catch (error) {
            const errorMessage = error.reason ? error.reason : 'unknown error';
            return {
                data: { error: `Unable to create room; something went wrong ${errorMessage}` },
                success: false,
            };
        }
    }
    async joinRoomOnMediaSFU({ payload, apiUserName, apiKey, }) {
        try {
            if (!apiUserName ||
                !apiKey ||
                apiUserName === 'yourAPIUSERNAME' ||
                apiKey === 'yourAPIKEY' ||
                apiKey.length !== 64 ||
                apiUserName.length < 6) {
                return { data: { error: 'Invalid credentials' }, success: false };
            }
            const response = await this.http
                .post('https://mediasfu.com/v1/rooms/', payload, {
                headers: new HttpHeaders({
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${apiUserName}:${apiKey}`,
                }),
            })
                .toPromise();
            return { data: response, success: true };
        }
        catch (error) {
            const errorMessage = error.reason ? error.reason : 'unknown error';
            return {
                data: { error: `Unable to join room; something went wrong ${errorMessage}` },
                success: false,
            };
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PreJoinPage, deps: [{ token: i2$1.FormBuilder }, { token: i2$3.HttpClient }, { token: i2$2.CookieService }, { token: 'parameters', optional: true }, { token: 'credentials', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: PreJoinPage, isStandalone: true, selector: "app-pre-join-page", inputs: { parameters: "parameters", credentials: "credentials" }, ngImport: i0, template: "<div class=\"container-fluid\">\r\n  <div class=\"logo-container\">\r\n    <img [src]=\"imgSrc || 'https://mediasfu.com/images/logo192.png'\" class=\"logo-image\" alt=\"Logo\" />\r\n  </div>\r\n  <div class=\"input-container\">\r\n    <form [formGroup]=\"preJoinForm\">\r\n      <input type=\"text\" placeholder=\"Display Name\" formControlName=\"name\" class=\"input-field\" />\r\n      <div *ngIf=\"isCreateMode\">\r\n        <input type=\"text\" placeholder=\"Duration (minutes)\" formControlName=\"duration\" class=\"input-field\" />\r\n        <select formControlName=\"eventType\" class=\"select-field\">\r\n          <option value=\"\">Select Event Type</option>\r\n          <option value=\"chat\">Chat</option>\r\n          <option value=\"broadcast\">Broadcast</option>\r\n          <option value=\"webinar\">Webinar</option>\r\n          <option value=\"conference\">Conference</option>\r\n        </select>\r\n        <input type=\"text\" placeholder=\"Room Capacity\" formControlName=\"capacity\" class=\"input-field\" />\r\n        <button type=\"button\" (click)=\"handleCreateRoom()\" class=\"action-button\">Create Room</button>\r\n      </div>\r\n      <div *ngIf=\"!isCreateMode\">\r\n        <input type=\"text\" placeholder=\"Event ID\" formControlName=\"eventID\" class=\"input-field\" />\r\n        <button type=\"button\" (click)=\"handleJoinRoom()\" class=\"action-button\">Join Room</button>\r\n      </div>\r\n      <p *ngIf=\"error\" class=\"error\">{{ error }}</p>\r\n    </form>\r\n  </div>\r\n  <div class=\"or-container\">\r\n    <span class=\"or-text\">OR</span>\r\n  </div>\r\n  <div class=\"toggle-container\">\r\n    <button type=\"button\" (click)=\"toggleMode()\" class=\"toggle-button\">\r\n      {{ isCreateMode ? 'Switch to Join Mode' : 'Switch to Create Mode' }}\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".container-fluid{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:20px;height:100vh;background-color:#53c6e0;overflow:auto}.logo-container{display:flex;flex-direction:column;align-items:center;justify-content:center;margin-top:30px;padding-top:10px;margin-bottom:10px}.logo-image{width:100px;height:100px;border-radius:50%}.input-container{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%}.input-field,.select-field{display:block;width:100%;max-width:300px;height:30px;border:1px solid gray;margin-bottom:10px;padding:0 5px;border-radius:5px}.action-button,.toggle-button{display:block;width:100%;max-width:300px;background-color:#000;color:#fff;padding:5px 20px;border-radius:5px;margin-bottom:10px;margin-top:10px;text-align:center;cursor:pointer}.error{color:red;margin-bottom:10px;width:100%;max-width:300px;text-align:center}.or-container{display:flex;flex-direction:column;align-items:center;justify-content:center;margin:10px 0}.or-text{color:#000;font-size:medium;font-weight:700;text-align:center}.toggle-container{display:flex;flex-direction:column;align-items:center;justify-content:center}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i2$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$1.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PreJoinPage, decorators: [{
            type: Component,
            args: [{ selector: 'app-pre-join-page', standalone: true, imports: [CommonModule, ReactiveFormsModule], template: "<div class=\"container-fluid\">\r\n  <div class=\"logo-container\">\r\n    <img [src]=\"imgSrc || 'https://mediasfu.com/images/logo192.png'\" class=\"logo-image\" alt=\"Logo\" />\r\n  </div>\r\n  <div class=\"input-container\">\r\n    <form [formGroup]=\"preJoinForm\">\r\n      <input type=\"text\" placeholder=\"Display Name\" formControlName=\"name\" class=\"input-field\" />\r\n      <div *ngIf=\"isCreateMode\">\r\n        <input type=\"text\" placeholder=\"Duration (minutes)\" formControlName=\"duration\" class=\"input-field\" />\r\n        <select formControlName=\"eventType\" class=\"select-field\">\r\n          <option value=\"\">Select Event Type</option>\r\n          <option value=\"chat\">Chat</option>\r\n          <option value=\"broadcast\">Broadcast</option>\r\n          <option value=\"webinar\">Webinar</option>\r\n          <option value=\"conference\">Conference</option>\r\n        </select>\r\n        <input type=\"text\" placeholder=\"Room Capacity\" formControlName=\"capacity\" class=\"input-field\" />\r\n        <button type=\"button\" (click)=\"handleCreateRoom()\" class=\"action-button\">Create Room</button>\r\n      </div>\r\n      <div *ngIf=\"!isCreateMode\">\r\n        <input type=\"text\" placeholder=\"Event ID\" formControlName=\"eventID\" class=\"input-field\" />\r\n        <button type=\"button\" (click)=\"handleJoinRoom()\" class=\"action-button\">Join Room</button>\r\n      </div>\r\n      <p *ngIf=\"error\" class=\"error\">{{ error }}</p>\r\n    </form>\r\n  </div>\r\n  <div class=\"or-container\">\r\n    <span class=\"or-text\">OR</span>\r\n  </div>\r\n  <div class=\"toggle-container\">\r\n    <button type=\"button\" (click)=\"toggleMode()\" class=\"toggle-button\">\r\n      {{ isCreateMode ? 'Switch to Join Mode' : 'Switch to Create Mode' }}\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".container-fluid{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:20px;height:100vh;background-color:#53c6e0;overflow:auto}.logo-container{display:flex;flex-direction:column;align-items:center;justify-content:center;margin-top:30px;padding-top:10px;margin-bottom:10px}.logo-image{width:100px;height:100px;border-radius:50%}.input-container{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%}.input-field,.select-field{display:block;width:100%;max-width:300px;height:30px;border:1px solid gray;margin-bottom:10px;padding:0 5px;border-radius:5px}.action-button,.toggle-button{display:block;width:100%;max-width:300px;background-color:#000;color:#fff;padding:5px 20px;border-radius:5px;margin-bottom:10px;margin-top:10px;text-align:center;cursor:pointer}.error{color:red;margin-bottom:10px;width:100%;max-width:300px;text-align:center}.or-container{display:flex;flex-direction:column;align-items:center;justify-content:center;margin:10px 0}.or-text{color:#000;font-size:medium;font-weight:700;text-align:center}.toggle-container{display:flex;flex-direction:column;align-items:center;justify-content:center}\n"] }]
        }], ctorParameters: () => [{ type: i2$1.FormBuilder }, { type: i2$3.HttpClient }, { type: i2$2.CookieService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['credentials']
                }] }], propDecorators: { parameters: [{
                type: Input
            }], credentials: [{
                type: Input
            }] } });

/* eslint-disable @typescript-eslint/no-empty-function */
class PollModal {
    isPollModalVisible = false;
    onClose;
    position = 'topRight';
    backgroundColor = '#f5f5f5';
    member = '';
    islevel = '';
    polls = [];
    poll = null;
    socket = {};
    roomName = '';
    showAlert = () => { };
    updateIsPollModalVisible = () => { };
    handleCreatePoll;
    handleEndPoll;
    handleVotePoll;
    faTimes = faTimes;
    newPoll = { question: '', type: '', options: [] };
    screenWidth = window.innerWidth;
    modalWidth = this.screenWidth > 500 ? 350 : 0.7 * this.screenWidth;
    ngOnInit() {
        this.renderPolls();
    }
    ngOnChanges(changes) {
        if (changes['isPollModalVisible']) {
            this.renderPolls();
        }
    }
    renderPolls = () => {
        let activePollCount = 0;
        this.polls &&
            this.polls.forEach((polled) => {
                if (polled.status === 'active' && this.poll && polled.id === this.poll.id) {
                    activePollCount++;
                }
            });
        if (this.islevel == '2' && activePollCount === 0) {
            if (this.poll && this.poll.status === 'active') {
                this.poll.status = 'inactive';
            }
        }
    };
    calculatePercentage(votes, optionIndex) {
        const totalVotes = votes.reduce((a, b) => a + b, 0);
        return totalVotes > 0 ? parseFloat(((votes[optionIndex] / totalVotes) * 100).toFixed(2)) : 0;
    }
    handlePollTypeChange(event) {
        const type = event.target.value;
        let options = [];
        switch (type) {
            case 'trueFalse':
                options = ['True', 'False'];
                break;
            case 'yesNo':
                options = ['Yes', 'No'];
                break;
            case 'custom':
                options = ['', '', '', '', '']; // Preload 5 empty options
                break;
            default:
                options = [];
                break;
        }
        this.newPoll = { ...this.newPoll, type, options };
    }
    async validateAndCreatePoll() {
        // Remove empty options before creating the poll
        this.newPoll.options = this.newPoll.options.filter((option) => option.trim() !== '');
        // Ensure there's at least one valid option
        if (this.newPoll.options.length > 0) {
            await this.handleCreatePoll({
                poll: this.newPoll,
                socket: this.socket,
                roomName: this.roomName,
                showAlert: this.showAlert,
                updateIsPollModalVisible: this.updateIsPollModalVisible,
            });
        }
    }
    handledVotePoll(pollId, optionIndex) {
        this.handleVotePoll({
            pollId,
            optionIndex,
            socket: this.socket,
            member: this.member,
            roomName: this.roomName,
            showAlert: this.showAlert,
            updateIsPollModalVisible: this.updateIsPollModalVisible,
        });
    }
    handledEndPoll(pollId) {
        this.handleEndPoll({
            pollId,
            socket: this.socket,
            roomName: this.roomName,
            showAlert: this.showAlert,
            updateIsPollModalVisible: this.updateIsPollModalVisible,
        });
    }
    get modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isPollModalVisible ? 'block' : 'none',
            zIndex: 999,
        };
    }
    get modalContentStyle() {
        return {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${this.modalWidth}px`,
            maxHeight: '75%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PollModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: PollModal, isStandalone: true, selector: "app-poll-modal", inputs: { isPollModalVisible: "isPollModalVisible", onClose: "onClose", position: "position", backgroundColor: "backgroundColor", member: "member", islevel: "islevel", polls: "polls", poll: "poll", socket: "socket", roomName: "roomName", showAlert: "showAlert", updateIsPollModalVisible: "updateIsPollModalVisible", handleCreatePoll: "handleCreatePoll", handleEndPoll: "handleEndPoll", handleVotePoll: "handleVotePoll" }, usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\">\r\n      <h2>Polls</h2>\r\n      <button (click)=\"onClose()\" class=\"close-button\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <!-- Previous Polls Section -->\r\n      <div *ngIf=\"islevel === '2'\">\r\n        <div class=\"previous-polls\">\r\n          <h5>Previous Polls</h5>\r\n          <div *ngIf=\"polls.length === 0\">No polls available</div>\r\n\r\n          <!-- Using ng-container to avoid multiple structural directives on the same element -->\r\n          <ng-container *ngFor=\"let polled of polls\">\r\n            <div\r\n              *ngIf=\"!poll || polled.id !== poll.id || poll.status !== 'active'\"\r\n              class=\"poll\"\r\n            >\r\n              <h6>Question:</h6>\r\n              <textarea\r\n                class=\"form-control\"\r\n                rows=\"3\"\r\n                [disabled]=\"true\"\r\n                [value]=\"polled.question\"\r\n              ></textarea>\r\n              <br />\r\n              <h6>Options:</h6>\r\n              <div *ngFor=\"let option of polled.options; let i = index\">\r\n                {{ option }}: {{ polled.votes[i] }} votes ({{\r\n                  calculatePercentage(polled.votes, i)\r\n                }}%)\r\n              </div>\r\n              <!-- End Poll Button (if poll is active) -->\r\n              <button\r\n                *ngIf=\"polled.status === 'active'\"\r\n                class=\"btn btn-danger\"\r\n                (click)=\"handledEndPoll(polled.id)\"\r\n              >\r\n                End Poll\r\n              </button>\r\n            </div>\r\n          </ng-container>\r\n        </div>\r\n        <hr />\r\n\r\n        <!-- Create Poll Section -->\r\n        <div class=\"create-poll\">\r\n          <h5>Create a New Poll</h5>\r\n          <form (ngSubmit)=\"validateAndCreatePoll()\">\r\n            <div class=\"form-group\">\r\n              <label for=\"pollQuestion\">Poll Question</label>\r\n              <textarea\r\n                class=\"form-control\"\r\n                id=\"pollQuestion\"\r\n                rows=\"3\"\r\n                maxLength=\"300\"\r\n                required\r\n                [(ngModel)]=\"newPoll.question\"\r\n                name=\"question\"\r\n              ></textarea>\r\n            </div>\r\n            <div class=\"form-group\">\r\n              <label for=\"pollType\">Select Poll Answer Type</label>\r\n              <select\r\n                class=\"form-control\"\r\n                id=\"pollType\"\r\n                required\r\n                (change)=\"handlePollTypeChange($event)\"\r\n                [(ngModel)]=\"newPoll.type\"\r\n                name=\"type\"\r\n              >\r\n                <option value=\"\">Choose...</option>\r\n                <option value=\"trueFalse\">True/False</option>\r\n                <option value=\"yesNo\">Yes/No</option>\r\n                <option value=\"custom\">Custom</option>\r\n              </select>\r\n            </div>\r\n\r\n            <!-- Render Poll Options -->\r\n            <div\r\n              *ngIf=\"newPoll.type === 'trueFalse' || newPoll.type === 'yesNo'\"\r\n            >\r\n              <div\r\n                *ngFor=\"let option of newPoll.options; let i = index\"\r\n                class=\"form-check\"\r\n              >\r\n                <input\r\n                  class=\"form-check-input\"\r\n                  type=\"radio\"\r\n                  name=\"pollOption\"\r\n                  [value]=\"option.toLowerCase()\"\r\n                  [id]=\"'option' + option\"\r\n                />\r\n                <label class=\"form-check-label\" [for]=\"'option' + option\">{{\r\n                  option\r\n                }}</label>\r\n              </div>\r\n            </div>\r\n            <div *ngIf=\"newPoll.type === 'custom'\">\r\n              <div\r\n                *ngFor=\"let option of newPoll.options; let i = index\"\r\n                class=\"form-group\"\r\n              >\r\n                <input\r\n                  type=\"text\"\r\n                  class=\"form-control\"\r\n                  placeholder=\"Option {{ i + 1 }}\"\r\n                  maxLength=\"50\"\r\n                  [(ngModel)]=\"newPoll.options[i]\"\r\n                  name=\"option{{ i }}\"\r\n                />\r\n              </div>\r\n            </div>\r\n            <button type=\"submit\" class=\"btn btn-primary\">Create Poll</button>\r\n          </form>\r\n        </div>\r\n        <hr />\r\n      </div>\r\n\r\n      <!-- Current Poll Section -->\r\n      <div class=\"current-poll\">\r\n        <h5>Current Poll</h5>\r\n        <div *ngIf=\"poll && poll.status === 'active'\">\r\n          <h6>Question:</h6>\r\n          <textarea\r\n            class=\"form-control\"\r\n            rows=\"3\"\r\n            [disabled]=\"true\"\r\n            [value]=\"poll.question\"\r\n          ></textarea>\r\n          <h6>Options:</h6>\r\n          <div\r\n            *ngFor=\"let option of poll.options; let i = index\"\r\n            class=\"form-check\"\r\n          >\r\n            <input\r\n              class=\"form-check-input\"\r\n              type=\"radio\"\r\n              name=\"pollOption\"\r\n              [value]=\"i\"\r\n              id=\"pollOption{{ i }}\"\r\n              [checked]=\"poll.voters?.[member] === i\"\r\n              (change)=\"handledVotePoll(poll.id, i)\"\r\n            />\r\n            <label class=\"form-check-label\" [for]=\"'pollOption' + i\">{{\r\n              option\r\n            }}</label>\r\n          </div>\r\n          <button\r\n            *ngIf=\"poll.status === 'active' && islevel === '2'\"\r\n            class=\"btn btn-danger\"\r\n            (click)=\"handledEndPoll(poll.id)\"\r\n          >\r\n            End Poll\r\n          </button>\r\n        </div>\r\n        <div *ngIf=\"!poll || poll.status !== 'active'\">\r\n          <hr />\r\n          No active poll\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-body{display:flex;flex-direction:column;gap:10px}.previous-polls,.create-poll,.current-poll{overflow-y:auto;max-height:20%}.poll{margin-bottom:15px}.close-button{border:none;background:none;cursor:pointer}.form-group{max-width:80%;overflow-x:auto}textarea.form-control{resize:none}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$1.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$1.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: i2$1.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PollModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-poll-modal', standalone: true, imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\">\r\n      <h2>Polls</h2>\r\n      <button (click)=\"onClose()\" class=\"close-button\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <!-- Previous Polls Section -->\r\n      <div *ngIf=\"islevel === '2'\">\r\n        <div class=\"previous-polls\">\r\n          <h5>Previous Polls</h5>\r\n          <div *ngIf=\"polls.length === 0\">No polls available</div>\r\n\r\n          <!-- Using ng-container to avoid multiple structural directives on the same element -->\r\n          <ng-container *ngFor=\"let polled of polls\">\r\n            <div\r\n              *ngIf=\"!poll || polled.id !== poll.id || poll.status !== 'active'\"\r\n              class=\"poll\"\r\n            >\r\n              <h6>Question:</h6>\r\n              <textarea\r\n                class=\"form-control\"\r\n                rows=\"3\"\r\n                [disabled]=\"true\"\r\n                [value]=\"polled.question\"\r\n              ></textarea>\r\n              <br />\r\n              <h6>Options:</h6>\r\n              <div *ngFor=\"let option of polled.options; let i = index\">\r\n                {{ option }}: {{ polled.votes[i] }} votes ({{\r\n                  calculatePercentage(polled.votes, i)\r\n                }}%)\r\n              </div>\r\n              <!-- End Poll Button (if poll is active) -->\r\n              <button\r\n                *ngIf=\"polled.status === 'active'\"\r\n                class=\"btn btn-danger\"\r\n                (click)=\"handledEndPoll(polled.id)\"\r\n              >\r\n                End Poll\r\n              </button>\r\n            </div>\r\n          </ng-container>\r\n        </div>\r\n        <hr />\r\n\r\n        <!-- Create Poll Section -->\r\n        <div class=\"create-poll\">\r\n          <h5>Create a New Poll</h5>\r\n          <form (ngSubmit)=\"validateAndCreatePoll()\">\r\n            <div class=\"form-group\">\r\n              <label for=\"pollQuestion\">Poll Question</label>\r\n              <textarea\r\n                class=\"form-control\"\r\n                id=\"pollQuestion\"\r\n                rows=\"3\"\r\n                maxLength=\"300\"\r\n                required\r\n                [(ngModel)]=\"newPoll.question\"\r\n                name=\"question\"\r\n              ></textarea>\r\n            </div>\r\n            <div class=\"form-group\">\r\n              <label for=\"pollType\">Select Poll Answer Type</label>\r\n              <select\r\n                class=\"form-control\"\r\n                id=\"pollType\"\r\n                required\r\n                (change)=\"handlePollTypeChange($event)\"\r\n                [(ngModel)]=\"newPoll.type\"\r\n                name=\"type\"\r\n              >\r\n                <option value=\"\">Choose...</option>\r\n                <option value=\"trueFalse\">True/False</option>\r\n                <option value=\"yesNo\">Yes/No</option>\r\n                <option value=\"custom\">Custom</option>\r\n              </select>\r\n            </div>\r\n\r\n            <!-- Render Poll Options -->\r\n            <div\r\n              *ngIf=\"newPoll.type === 'trueFalse' || newPoll.type === 'yesNo'\"\r\n            >\r\n              <div\r\n                *ngFor=\"let option of newPoll.options; let i = index\"\r\n                class=\"form-check\"\r\n              >\r\n                <input\r\n                  class=\"form-check-input\"\r\n                  type=\"radio\"\r\n                  name=\"pollOption\"\r\n                  [value]=\"option.toLowerCase()\"\r\n                  [id]=\"'option' + option\"\r\n                />\r\n                <label class=\"form-check-label\" [for]=\"'option' + option\">{{\r\n                  option\r\n                }}</label>\r\n              </div>\r\n            </div>\r\n            <div *ngIf=\"newPoll.type === 'custom'\">\r\n              <div\r\n                *ngFor=\"let option of newPoll.options; let i = index\"\r\n                class=\"form-group\"\r\n              >\r\n                <input\r\n                  type=\"text\"\r\n                  class=\"form-control\"\r\n                  placeholder=\"Option {{ i + 1 }}\"\r\n                  maxLength=\"50\"\r\n                  [(ngModel)]=\"newPoll.options[i]\"\r\n                  name=\"option{{ i }}\"\r\n                />\r\n              </div>\r\n            </div>\r\n            <button type=\"submit\" class=\"btn btn-primary\">Create Poll</button>\r\n          </form>\r\n        </div>\r\n        <hr />\r\n      </div>\r\n\r\n      <!-- Current Poll Section -->\r\n      <div class=\"current-poll\">\r\n        <h5>Current Poll</h5>\r\n        <div *ngIf=\"poll && poll.status === 'active'\">\r\n          <h6>Question:</h6>\r\n          <textarea\r\n            class=\"form-control\"\r\n            rows=\"3\"\r\n            [disabled]=\"true\"\r\n            [value]=\"poll.question\"\r\n          ></textarea>\r\n          <h6>Options:</h6>\r\n          <div\r\n            *ngFor=\"let option of poll.options; let i = index\"\r\n            class=\"form-check\"\r\n          >\r\n            <input\r\n              class=\"form-check-input\"\r\n              type=\"radio\"\r\n              name=\"pollOption\"\r\n              [value]=\"i\"\r\n              id=\"pollOption{{ i }}\"\r\n              [checked]=\"poll.voters?.[member] === i\"\r\n              (change)=\"handledVotePoll(poll.id, i)\"\r\n            />\r\n            <label class=\"form-check-label\" [for]=\"'pollOption' + i\">{{\r\n              option\r\n            }}</label>\r\n          </div>\r\n          <button\r\n            *ngIf=\"poll.status === 'active' && islevel === '2'\"\r\n            class=\"btn btn-danger\"\r\n            (click)=\"handledEndPoll(poll.id)\"\r\n          >\r\n            End Poll\r\n          </button>\r\n        </div>\r\n        <div *ngIf=\"!poll || poll.status !== 'active'\">\r\n          <hr />\r\n          No active poll\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-body{display:flex;flex-direction:column;gap:10px}.previous-polls,.create-poll,.current-poll{overflow-y:auto;max-height:20%}.poll{margin-bottom:15px}.close-button{border:none;background:none;cursor:pointer}.form-group{max-width:80%;overflow-x:auto}textarea.form-control{resize:none}\n"] }]
        }], propDecorators: { isPollModalVisible: [{
                type: Input
            }], onClose: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], member: [{
                type: Input
            }], islevel: [{
                type: Input
            }], polls: [{
                type: Input
            }], poll: [{
                type: Input
            }], socket: [{
                type: Input
            }], roomName: [{
                type: Input
            }], showAlert: [{
                type: Input
            }], updateIsPollModalVisible: [{
                type: Input
            }], handleCreatePoll: [{
                type: Input
            }], handleEndPoll: [{
                type: Input
            }], handleVotePoll: [{
                type: Input
            }] } });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
class BackgroundModal {
    isVisible = false;
    parameters = {};
    position = 'topLeft';
    backgroundColor = '#f5f5f5';
    onClose = () => {
        console.log('onClose');
    };
    defaultImagesContainerRef;
    uploadImageInputRef;
    backgroundCanvasRef;
    videoPreviewRef;
    captureVideoRef;
    loadingOverlayRef;
    applyBackgroundButtonRef;
    saveBackgroundButtonRef;
    faTimes = faTimes;
    customImage = '';
    selectedImage = '';
    segmentVideo = null;
    selfieSegmentation = null;
    pauseSegmentation = false;
    processedStream = null;
    keepBackground = false;
    backgroundHasChanged = false;
    virtualStream = null;
    mainCanvas;
    prevKeepBackground = false;
    appliedBackground = false;
    videoAlreadyOn = false;
    audioOnlyRoom = false;
    islevel = '0';
    recordStarted = false;
    recordResumed = false;
    recordPaused = false;
    recordStopped = false;
    recordingMediaOptions = '';
    vidCons = {};
    frameRate = 5;
    targetResolution = '1280x720';
    videoParams = {};
    autoClickBackground = false;
    localStreamVideo = null;
    clonedStream = null;
    clonedTrack = null;
    updateCustomImage;
    updateSelectedImage;
    updateSegmentVideo;
    updateSelfieSegmentation;
    updatePauseSegmentation;
    updateProcessedStream;
    updateKeepBackground;
    updateBackgroundHasChanged;
    updateVirtualStream;
    updateMainCanvas;
    updatePrevKeepBackground;
    updateAppliedBackground;
    updateVideoParams;
    updateAutoClickBackground;
    // Media functions
    createSendTransport;
    connectSendTransportVideo;
    disconnectSendTransportVideo;
    onScreenChanges;
    sleep;
    ngOnInit() {
        // Initialize local properties from the parameters
        if (this.parameters) {
            try {
                this.updateVariables();
            }
            catch {
                /* handle error */
            }
        }
    }
    ngOnChanges(changes) {
        if (changes['isVisible']) {
            this.onVisibilityChange();
        }
        if (changes['autoClickBackground']) {
            console.log('Auto click background changed:', this.autoClickBackground, changes['autoClickBackground']);
        }
    }
    updateVariables() {
        this.customImage = this.parameters.customImage || '';
        this.selectedImage = this.parameters.selectedImage || '';
        this.segmentVideo = this.parameters.segmentVideo || null;
        this.selfieSegmentation = this.parameters.selfieSegmentation || null;
        this.pauseSegmentation = this.parameters.pauseSegmentation || false;
        this.processedStream = this.parameters.processedStream || null;
        this.keepBackground = this.parameters.keepBackground || false;
        this.backgroundHasChanged = this.parameters.backgroundHasChanged || false;
        this.virtualStream = this.parameters.virtualStream || null;
        this.mainCanvas = this.parameters.mainCanvas || this.backgroundCanvasRef?.nativeElement || null;
        this.prevKeepBackground = this.parameters.prevKeepBackground || false;
        this.appliedBackground = this.parameters.appliedBackground || false;
        this.videoAlreadyOn = this.parameters.videoAlreadyOn || false;
        this.audioOnlyRoom = this.parameters.audioOnlyRoom || false;
        this.islevel = this.parameters.islevel || '0';
        this.recordStarted = this.parameters.recordStarted || false;
        this.recordResumed = this.parameters.recordResumed || false;
        this.recordPaused = this.parameters.recordPaused || false;
        this.recordStopped = this.parameters.recordStopped || false;
        this.recordingMediaOptions = this.parameters.recordingMediaOptions || '';
        this.vidCons = this.parameters.vidCons || {};
        this.frameRate = this.parameters.frameRate || 5;
        this.videoParams = this.parameters.videoParams || null;
        this.autoClickBackground = this.parameters.autoClickBackground || false;
        this.localStreamVideo = this.parameters.localStreamVideo || null;
        // Assign method references
        this.updateCustomImage = this.parameters.updateCustomImage;
        this.updateSelectedImage = this.parameters.updateSelectedImage;
        this.updateSegmentVideo = this.parameters.updateSegmentVideo;
        this.updateSelfieSegmentation = this.parameters.updateSelfieSegmentation;
        this.updatePauseSegmentation = this.parameters.updatePauseSegmentation;
        this.updateProcessedStream = this.parameters.updateProcessedStream;
        this.updateKeepBackground = this.parameters.updateKeepBackground;
        this.updateBackgroundHasChanged = this.parameters.updateBackgroundHasChanged;
        this.updateVirtualStream = this.parameters.updateVirtualStream;
        this.updateMainCanvas = this.parameters.updateMainCanvas;
        this.updatePrevKeepBackground = this.parameters.updatePrevKeepBackground;
        this.updateAppliedBackground = this.parameters.updateAppliedBackground;
        this.updateVideoParams = this.parameters.updateVideoParams;
        this.updateAutoClickBackground = this.parameters.updateAutoClickBackground;
        this.createSendTransport = this.parameters.createSendTransport;
        this.connectSendTransportVideo = this.parameters.connectSendTransportVideo;
        this.disconnectSendTransportVideo = this.parameters.disconnectSendTransportVideo;
        this.onScreenChanges = this.parameters.onScreenChanges;
        this.sleep = this.parameters.sleep;
    }
    onVisibilityChange = async () => {
        if (this.parameters) {
            this.parameters = this.parameters.getUpdatedAllParams();
            this.updateVariables();
        }
        if (this.isVisible) {
            if (!this.selfieSegmentation) {
                await this.preloadModel().catch(() => console.log('Error preloading model:'));
            }
            this.renderDefaultImages();
            if (this.selectedImage) {
                await this.loadImageToCanvas(this.selectedImage, this.selectedImage);
            }
            else {
                this.clearCanvas();
                this.backgroundCanvasRef.nativeElement.classList.remove('d-none');
            }
            this.saveBackgroundButtonRef.nativeElement.classList.add('d-none');
            this.saveBackgroundButtonRef.nativeElement.disabled = true;
            this.applyBackgroundButtonRef.nativeElement.classList.remove('d-none');
            this.applyBackgroundButtonRef.nativeElement.disabled = false;
            if (this.processedStream &&
                this.prevKeepBackground == this.keepBackground &&
                this.keepBackground &&
                this.appliedBackground) {
                this.applyBackgroundButtonRef.nativeElement.innerText = 'Apply Background';
            }
            else {
                this.applyBackgroundButtonRef.nativeElement.innerText = 'Preview Background';
            }
            if (this.autoClickBackground) {
                await this.applyBackground();
                await this.saveBackground();
                this.autoClickBackground = false;
                this.updateAutoClickBackground(this.autoClickBackground);
            }
        }
        else {
            try {
                // If no background is applied or the applied background should not be kept
                if (!this.appliedBackground ||
                    (this.appliedBackground && !this.keepBackground) ||
                    (this.appliedBackground && !this.videoAlreadyOn)) {
                    const refVideo = this.captureVideoRef.nativeElement;
                    this.pauseSegmentation = true;
                    this.updatePauseSegmentation(this.pauseSegmentation);
                    if (!this.videoAlreadyOn) {
                        // Stop video tracks and clear the video element's srcObject
                        if (refVideo && refVideo.srcObject) {
                            refVideo.srcObject.getTracks().forEach((track) => track.stop());
                            refVideo.srcObject = null;
                        }
                        // Stop segmentVideo tracks
                        if (this.segmentVideo) {
                            this.segmentVideo.getTracks().forEach((track) => track.stop());
                            this.segmentVideo = null;
                            this.updateSegmentVideo(this.segmentVideo);
                        }
                        // Stop virtualStream tracks
                        if (this.virtualStream) {
                            this.virtualStream.getTracks().forEach((track) => track.stop());
                            this.virtualStream = null;
                            this.updateVirtualStream(this.virtualStream);
                        }
                    }
                }
                // Hide the video preview and show the canvas
                this.videoPreviewRef.nativeElement.classList.add('d-none');
                this.backgroundCanvasRef.nativeElement.classList.remove('d-none');
            }
            catch {
                /* handle error */
            }
        }
    };
    async preloadModel() {
        this.selfieSegmentation = new SelfieSegmentation({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`,
        });
        this.selfieSegmentation.setOptions({
            modelSelection: 1,
            selfieMode: false,
        });
        await this.selfieSegmentation.initialize();
        this.updateSelfieSegmentation(this.selfieSegmentation);
    }
    renderDefaultImages() {
        const defaultImages = ['wall', 'wall2', 'shelf', 'clock', 'desert', 'flower'];
        const defaultImagesContainer = this.defaultImagesContainerRef.nativeElement;
        defaultImagesContainer.innerHTML = '';
        defaultImages.forEach((baseName) => {
            const thumb = `https://mediasfu.com/images/backgrounds/${baseName}_thumbnail.jpg`;
            const small = `https://mediasfu.com/images/backgrounds/${baseName}_small.jpg`;
            const large = `https://mediasfu.com/images/backgrounds/${baseName}_large.jpg`;
            const full = `https://mediasfu.com/images/backgrounds/${baseName}.jpg`;
            const img = document.createElement('img');
            img.src = thumb;
            img.classList.add('img-thumbnail', 'm-1');
            img.style.width = '80px';
            img.style.cursor = 'pointer';
            img.addEventListener('click', async () => {
                if (this.targetResolution == 'fhd' || this.targetResolution == 'qhd') {
                    await this.loadImageToCanvas(small, large);
                }
                else {
                    await this.loadImageToCanvas(small, full);
                }
            });
            defaultImagesContainer.appendChild(img);
        });
        const noBackgroundImg = document.createElement('div');
        noBackgroundImg.classList.add('img-thumbnail', 'm-1', 'd-flex', 'align-items-center', 'justify-content-center');
        noBackgroundImg.style.width = '76px';
        noBackgroundImg.style.minHeight = '60px';
        noBackgroundImg.style.cursor = 'pointer';
        noBackgroundImg.style.backgroundColor = '#f8f9fa';
        noBackgroundImg.style.border = '1px solid #dee2e6';
        noBackgroundImg.style.position = 'relative';
        noBackgroundImg.innerHTML =
            '<span style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#000;">None</span>';
        noBackgroundImg.addEventListener('click', async () => {
            this.selectedImage = '';
            this.updateSelectedImage(this.selectedImage);
            this.updateCustomImage('');
            this.showLoading();
            this.videoPreviewRef.nativeElement.classList.add('d-none');
            this.backgroundCanvasRef.nativeElement.classList.remove('d-none');
            this.clearCanvas();
            this.hideLoading();
        });
        defaultImagesContainer.appendChild(noBackgroundImg);
        if (this.customImage) {
            const img = document.createElement('img');
            img.src = this.customImage;
            img.classList.add('img-thumbnail', 'm-1');
            img.style.width = '80px';
            img.style.cursor = 'pointer';
            img.addEventListener('click', async () => {
                await this.loadImageToCanvas(this.customImage, this.customImage);
            });
            defaultImagesContainer.appendChild(img);
        }
    }
    async handleImageUpload(event) {
        let minWidth = 1280;
        let minHeight = 1280;
        let maxWidth = 2560;
        let maxHeight = 2560;
        if (this.targetResolution == 'fhd') {
            minWidth = 1920;
            minHeight = 1920;
        }
        else if (this.targetResolution == 'qhd') {
            minWidth = 2560;
            minHeight = 2560;
        } // For other resolutions, stick to the default 1280x1280
        const input = event.target;
        if (input.files && input.files.length > 0) {
            const file = input.files[0];
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = async () => {
                if (img.width < minWidth ||
                    img.height < minHeight ||
                    img.width > maxWidth ||
                    img.height > maxHeight) {
                    this.customImage = img.src;
                    this.updateCustomImage(this.customImage);
                    await this.loadImageToCanvas(img.src, img.src);
                }
            };
            const reader = new FileReader();
            reader.onload = (e) => {
                if (e.target) {
                    img.src = e.target.result;
                }
            };
            reader.readAsDataURL(file);
        }
    }
    clearCanvas() {
        const ctx = this.backgroundCanvasRef.nativeElement.getContext('2d');
        ctx.clearRect(0, 0, this.backgroundCanvasRef.nativeElement.width, this.backgroundCanvasRef.nativeElement.height);
        ctx.font = '30px Arial';
        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('No Background', this.backgroundCanvasRef.nativeElement.width / 2, this.backgroundCanvasRef.nativeElement.height / 2);
        this.applyBackgroundButtonRef.nativeElement.classList.remove('d-none');
        this.applyBackgroundButtonRef.nativeElement.disabled = false;
        if (this.processedStream &&
            this.prevKeepBackground == this.keepBackground &&
            this.keepBackground &&
            this.appliedBackground) {
            this.applyBackgroundButtonRef.nativeElement.innerText = 'Apply Background';
        }
        else {
            this.applyBackgroundButtonRef.nativeElement.innerText = 'Preview Background';
        }
    }
    async loadImageToCanvas(src, fullSrc) {
        this.showLoading();
        await this.backgroundCanvasRef.nativeElement.classList.remove('d-none');
        await this.videoPreviewRef.nativeElement.classList.add('d-none');
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = async () => {
            const ctx = await this.backgroundCanvasRef.nativeElement.getContext('2d');
            this.backgroundCanvasRef.nativeElement.width = img.width;
            this.backgroundCanvasRef.nativeElement.height = img.height;
            await ctx.drawImage(img, 0, 0);
            this.removeBackground(img);
            this.hideLoading();
        };
        img.src = src;
        this.selectedImage = fullSrc;
        this.updateSelectedImage(this.selectedImage);
        this.saveBackgroundButtonRef.nativeElement.classList.add('d-none');
        this.saveBackgroundButtonRef.nativeElement.disabled = true;
        this.applyBackgroundButtonRef.nativeElement.classList.remove('d-none');
        this.applyBackgroundButtonRef.nativeElement.disabled = false;
        if (this.processedStream &&
            this.prevKeepBackground == this.keepBackground &&
            this.keepBackground &&
            this.appliedBackground) {
            this.applyBackgroundButtonRef.nativeElement.innerText = 'Apply Background';
        }
        else {
            this.applyBackgroundButtonRef.nativeElement.innerText = 'Preview Background';
        }
    }
    removeBackground(img) {
        const ctx = this.backgroundCanvasRef.nativeElement.getContext('2d');
        ctx.clearRect(0, 0, this.backgroundCanvasRef.nativeElement.width, this.backgroundCanvasRef.nativeElement.height);
        ctx.drawImage(img, 0, 0);
    }
    async applyBackground() {
        try {
            if (this.audioOnlyRoom) {
                this.parameters.showAlert?.({
                    message: 'You cannot use a background in an audio only event.',
                    type: 'danger',
                });
                return;
            }
            this.showLoading();
            this.videoPreviewRef.nativeElement.classList.remove('d-none');
            this.backgroundCanvasRef.nativeElement.classList.add('d-none');
            const doSegmentation = this.selectedImage ? true : false;
            this.pauseSegmentation = false;
            this.updatePauseSegmentation(this.pauseSegmentation);
            await this.selfieSegmentationPreview(doSegmentation);
            this.hideLoading();
            this.applyBackgroundButtonRef.nativeElement.classList.add('d-none');
            this.applyBackgroundButtonRef.nativeElement.disabled = true;
            if (this.processedStream &&
                this.prevKeepBackground == this.keepBackground &&
                this.keepBackground &&
                this.appliedBackground) {
                this.saveBackgroundButtonRef.nativeElement.classList.add('d-none');
                this.saveBackgroundButtonRef.nativeElement.disabled = true;
            }
            else {
                this.saveBackgroundButtonRef.nativeElement.classList.remove('d-none');
                this.saveBackgroundButtonRef.nativeElement.disabled = false;
            }
        }
        catch (error) {
            console.log(error);
        }
    }
    async selfieSegmentationPreview(doSegmentation) {
        const refVideo = this.captureVideoRef.nativeElement;
        const previewVideo = this.videoPreviewRef.nativeElement;
        const virtualImage = new Image();
        virtualImage.crossOrigin = 'anonymous';
        virtualImage.src = this.selectedImage;
        if (!this.mainCanvas) {
            this.mainCanvas = await this.backgroundCanvasRef.nativeElement;
        }
        let mediaCanvas = this.mainCanvas;
        mediaCanvas.width = refVideo.videoWidth;
        mediaCanvas.height = refVideo.videoHeight;
        let ctx = mediaCanvas.getContext('2d');
        this.backgroundHasChanged = true;
        this.updateBackgroundHasChanged(this.backgroundHasChanged);
        this.prevKeepBackground = this.keepBackground;
        this.updatePrevKeepBackground(this.keepBackground);
        if (!doSegmentation) {
            const tracks = this.processedStream?.getVideoTracks();
            if (tracks) {
                tracks.forEach((track) => track.stop());
            }
            this.processedStream = null;
            this.keepBackground = false;
            this.updateProcessedStream(null);
            this.updateKeepBackground(false);
            previewVideo.classList.remove('d-none');
        }
        const segmentImage = async (videoElement) => {
            const processFrame = () => {
                if (!this.selfieSegmentation ||
                    this.pauseSegmentation ||
                    !videoElement ||
                    videoElement.videoWidth == 0 ||
                    videoElement.videoHeight == 0) {
                    return;
                }
                this.selfieSegmentation.send({ image: videoElement });
                requestAnimationFrame(processFrame);
            };
            videoElement.onloadeddata = () => {
                processFrame();
            };
            setTimeout(async () => {
                console.log('Capturing stream:', this.frameRate || 5);
                this.processedStream = mediaCanvas.captureStream(this.frameRate || 5);
                this.updateProcessedStream(this.processedStream);
                previewVideo.srcObject = this.processedStream;
                previewVideo.classList.remove('d-none');
                this.keepBackground = true;
                this.updateKeepBackground(this.keepBackground);
                if (previewVideo.paused) {
                    try {
                        // play the video
                        previewVideo.play().then(() => {
                            /* handle success */
                        });
                    }
                    catch {
                        /* handle error */
                    }
                }
            }, 100);
        };
        if (this.videoAlreadyOn) {
            if (this.clonedTrack &&
                this.clonedTrack.readyState == 'live' &&
                this.localStreamVideo?.getVideoTracks()[0].label == this.clonedTrack.label) {
                // Use existing clonedTrack
            }
            else {
                const localTracks = this.localStreamVideo?.getVideoTracks()[0];
                this.clonedTrack = localTracks.clone();
                this.clonedStream = new MediaStream([this.clonedTrack]);
                this.segmentVideo = this.clonedStream;
            }
            this.updateSegmentVideo(this.segmentVideo);
            refVideo.srcObject = this.segmentVideo;
            if (refVideo.paused) {
                refVideo.play();
            }
            refVideo.width = this.segmentVideo.getVideoTracks()[0].getSettings().width;
            refVideo.height = this.segmentVideo.getVideoTracks()[0].getSettings().height;
            mediaCanvas.width = refVideo.width;
            mediaCanvas.height = refVideo.height;
            ctx = mediaCanvas.getContext('2d');
            try {
                doSegmentation
                    ? await segmentImage(refVideo)
                    : (previewVideo.srcObject = this.clonedStream
                        ? this.clonedStream
                        : this.localStreamVideo);
            }
            catch (error) {
                console.log('Error segmenting image:', error);
            }
        }
        else {
            if (this.segmentVideo && this.segmentVideo.getVideoTracks()[0].readyState == 'live') {
                // Use existing segmentVideo
            }
            else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { ...this.vidCons, frameRate: { ideal: this.frameRate || 5 } },
                        audio: false,
                    });
                    this.segmentVideo = stream;
                    this.updateSegmentVideo(this.segmentVideo);
                    refVideo.srcObject = this.segmentVideo;
                    if (refVideo.paused) {
                        refVideo.play();
                    }
                }
                catch (error) {
                    console.log('Error getting user media:', error);
                }
                refVideo.width = this.segmentVideo.getVideoTracks()[0].getSettings().width;
                refVideo.height = this.segmentVideo.getVideoTracks()[0].getSettings().height;
                mediaCanvas.width = refVideo.width;
                mediaCanvas.height = refVideo.height;
                ctx = mediaCanvas.getContext('2d');
            }
            try {
                doSegmentation
                    ? await segmentImage(refVideo)
                    : (previewVideo.srcObject = refVideo.srcObject);
            }
            catch (error) {
                console.log(error);
            }
        }
        let repeatPattern = 'no-repeat';
        try {
            if (virtualImage.width < mediaCanvas.width || virtualImage.height < mediaCanvas.height) {
                repeatPattern = 'repeat';
            }
        }
        catch {
            /* handle error */
        }
        const onResults = (results) => {
            try {
                if (!this.pauseSegmentation &&
                    mediaCanvas &&
                    mediaCanvas.width > 0 &&
                    mediaCanvas.height > 0 &&
                    virtualImage.width > 0 &&
                    virtualImage.height > 0) {
                    ctx.clearRect(0, 0, mediaCanvas.width, mediaCanvas.height);
                    ctx.drawImage(results.segmentationMask, 0, 0, mediaCanvas.width, mediaCanvas.height);
                    ctx.globalCompositeOperation = 'source-out';
                    const pat = ctx.createPattern(virtualImage, repeatPattern);
                    ctx.fillStyle = pat;
                    ctx.fillRect(0, 0, mediaCanvas.width, mediaCanvas.height);
                    ctx.globalCompositeOperation = 'destination-atop';
                    ctx.drawImage(results.image, 0, 0, mediaCanvas.width, mediaCanvas.height);
                }
            }
            catch (error) {
                console.log('Error processing results:', error);
            }
        };
        if (!this.selfieSegmentation) {
            await this.preloadModel().catch(() => console.log('Error preloading model:'));
        }
        try {
            this.selfieSegmentation.onResults(onResults);
        }
        catch (error) {
            console.log(error);
        }
    }
    saveBackground = async () => {
        if (this.audioOnlyRoom) {
            this.parameters.showAlert?.({
                message: 'You cannot use a background in an audio-only event.',
                type: 'danger',
            });
            return;
        }
        if (this.backgroundHasChanged) {
            if (this.videoAlreadyOn) {
                if (this.islevel == '2' && (this.recordStarted || this.recordResumed)) {
                    if (!(this.recordPaused || this.recordStopped)) {
                        if (this.recordingMediaOptions == 'video') {
                            this.parameters.showAlert?.({
                                message: 'Please pause the recording before changing the background.',
                                type: 'danger',
                            });
                            return;
                        }
                    }
                }
                if (this.keepBackground && this.selectedImage && this.processedStream) {
                    this.virtualStream = this.processedStream;
                    this.updateVirtualStream(this.virtualStream);
                    this.videoParams = { track: this.virtualStream.getVideoTracks()[0] };
                    this.updateVideoParams(this.videoParams);
                }
                else {
                    if (this.localStreamVideo?.getVideoTracks()[0].readyState == 'live') {
                        this.videoParams = { track: this.localStreamVideo.getVideoTracks()[0] };
                        this.updateVideoParams(this.videoParams);
                    }
                    else {
                        try {
                            if (this.localStreamVideo?.getVideoTracks()[0].readyState !== 'live') {
                                this.localStreamVideo?.removeTrack(this.localStreamVideo.getVideoTracks()[0]);
                                this.localStreamVideo?.addTrack(this.segmentVideo.getVideoTracks()[0].clone());
                            }
                        }
                        catch (error) {
                            console.log('Error handling local stream video:', error);
                        }
                        this.videoParams = { track: this.segmentVideo.getVideoTracks()[0] };
                        this.updateVideoParams(this.videoParams);
                    }
                }
                if (this.keepBackground) {
                    this.appliedBackground = true;
                    this.updateAppliedBackground(this.appliedBackground);
                }
                else {
                    this.appliedBackground = false;
                    this.updateAppliedBackground(this.appliedBackground);
                }
                if (!this.parameters.transportCreated) {
                    await this.createSendTransport({
                        option: 'video',
                        parameters: { ...this.parameters, videoParams: this.videoParams },
                    });
                }
                else {
                    try {
                        if (this.parameters.videoProducer?.id &&
                            this.parameters.videoProducer.track?.id !== this.videoParams?.track?.id) {
                            await this.disconnectSendTransportVideo({ parameters: this.parameters });
                            await this.sleep({ ms: 500 });
                        }
                        await this.connectSendTransportVideo({
                            videoParams: this.videoParams,
                            parameters: this.parameters,
                        });
                    }
                    catch (error) {
                        console.log(error);
                    }
                }
                await this.onScreenChanges({ changed: true, parameters: this.parameters });
            }
        }
        if (this.keepBackground) {
            this.appliedBackground = true;
            this.updateAppliedBackground(this.appliedBackground);
        }
        else {
            this.appliedBackground = false;
            this.updateAppliedBackground(this.appliedBackground);
        }
        this.saveBackgroundButtonRef.nativeElement.classList.add('d-none');
        this.saveBackgroundButtonRef.nativeElement.disabled = true;
    };
    handleModalClose = () => {
        try {
            // If no background is applied or the applied background should not be kept
            if (!this.appliedBackground ||
                (this.appliedBackground && !this.keepBackground) ||
                (this.appliedBackground && !this.videoAlreadyOn)) {
                console.log('No background applied or applied background should not be kept');
                const refVideo = this.captureVideoRef.nativeElement;
                this.pauseSegmentation = true;
                this.updatePauseSegmentation(this.pauseSegmentation);
                if (!this.videoAlreadyOn) {
                    // Stop video tracks and clear the video element's srcObject
                    if (refVideo && refVideo.srcObject) {
                        refVideo.srcObject.getTracks().forEach((track) => track.stop());
                        refVideo.srcObject = null;
                    }
                    // Stop segmentVideo tracks
                    if (this.segmentVideo) {
                        this.segmentVideo.getTracks().forEach((track) => track.stop());
                        this.segmentVideo = null;
                        this.updateSegmentVideo(this.segmentVideo);
                    }
                    // Stop virtualStream tracks
                    if (this.virtualStream) {
                        this.virtualStream.getTracks().forEach((track) => track.stop());
                        this.virtualStream = null;
                        this.updateVirtualStream(this.virtualStream);
                    }
                }
            }
            // Hide the video preview and show the canvas
            this.videoPreviewRef.nativeElement.classList.add('d-none');
            this.backgroundCanvasRef.nativeElement.classList.remove('d-none');
            // Hide the modal
            // this.isVisible = false;
            this.onClose();
        }
        catch (error) {
            console.log('Error during modal close:', error);
        }
    };
    showLoading() {
        this.loadingOverlayRef.nativeElement.classList.remove('d-none');
    }
    hideLoading() {
        this.loadingOverlayRef.nativeElement.classList.add('d-none');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: BackgroundModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: BackgroundModal, isStandalone: true, selector: "app-background-modal", inputs: { isVisible: "isVisible", parameters: "parameters", position: "position", backgroundColor: "backgroundColor", onClose: "onClose" }, viewQueries: [{ propertyName: "defaultImagesContainerRef", first: true, predicate: ["defaultImagesContainer"], descendants: true }, { propertyName: "uploadImageInputRef", first: true, predicate: ["uploadImageInput"], descendants: true }, { propertyName: "backgroundCanvasRef", first: true, predicate: ["backgroundCanvas"], descendants: true }, { propertyName: "videoPreviewRef", first: true, predicate: ["videoPreview"], descendants: true }, { propertyName: "captureVideoRef", first: true, predicate: ["captureVideo"], descendants: true }, { propertyName: "loadingOverlayRef", first: true, predicate: ["loadingOverlay"], descendants: true }, { propertyName: "applyBackgroundButtonRef", first: true, predicate: ["applyBackgroundButton"], descendants: true }, { propertyName: "saveBackgroundButtonRef", first: true, predicate: ["saveBackgroundButton"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, 0.5)', display: isVisible ? 'block' : 'none', zIndex: 999 }\">\r\n    <div [ngStyle]=\"{ position: 'fixed', backgroundColor: backgroundColor, borderRadius: '10px', padding: '10px', width: '80%', maxWidth: '500px', maxHeight: '75%', overflowY: 'auto', overflowX: 'hidden', top: position.includes('top') ? '10px' : 'auto', bottom: position.includes('bottom') ? '10px' : 'auto', left: position.includes('Left') ? '10px' : 'auto', right: position.includes('Right') ? '10px' : 'auto' }\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">Background Settings</h2>\r\n        <button (click)=\"onClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr style=\"height: 1px; background-color: black; margin-top: 5px; margin-bottom: 5px;\" />\r\n      <div style=\"max-width: 95%; overflow-x: auto;\">\r\n        <div id=\"defaultImages\" #defaultImagesContainer></div>\r\n        <div class=\"form-group\" style=\"max-width: 70%; overflow-x: auto;\">\r\n          <label for=\"uploadImage\">Upload Custom Image</label>\r\n          <input type=\"file\" class=\"form-control\" id=\"uploadImage\" #uploadImageInput (change)=\"handleImageUpload($event)\" />\r\n        </div>\r\n        <canvas id=\"mainCanvas\" #mainCanvas class=\"d-none\"></canvas>\r\n        <canvas id=\"backgroundCanvas\" #backgroundCanvas class=\"d-none\" style=\"width: 100%; max-width: 400px; height: auto; background-color: transparent; border: 1px solid black;\"></canvas>\r\n        <video id=\"captureVideo\" #captureVideo class=\"d-none\" muted autoplay playsinline></video>\r\n        <video id=\"previewVideo\" #videoPreview class=\"d-none\" muted autoplay playsinline style=\"width: 100%; max-width: 400px; height: auto; background-color: transparent; border: 1px solid black;\"></video>\r\n        <div id=\"loadingOverlay\" #loadingOverlay class=\"d-none\" [ngStyle]=\"{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, 0.5)', display: 'flex', 'justify-content': 'center', 'align-items': 'center', zIndex: 1000 }\">\r\n          <div [ngStyle]=\"{ width: '50px', height: '50px', border: '5px solid rgba(255, 255, 255, 0.3)', borderRadius: '50%', borderTop: '5px solid white', animation: 'spin 1s linear infinite' }\"></div>\r\n        </div>\r\n        <br />\r\n        <button id=\"applyBackgroundButton\" #applyBackgroundButton class=\"btn btn-primary\" (click)=\"applyBackground()\">Preview Background</button>\r\n        <button id=\"saveBackgroundButton\" #saveBackgroundButton class=\"btn btn-success d-none\" (click)=\"saveBackground()\">Save Background</button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n", styles: ["@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: BackgroundModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-background-modal', standalone: true, imports: [CommonModule, FontAwesomeModule], template: "<div [ngStyle]=\"{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, 0.5)', display: isVisible ? 'block' : 'none', zIndex: 999 }\">\r\n    <div [ngStyle]=\"{ position: 'fixed', backgroundColor: backgroundColor, borderRadius: '10px', padding: '10px', width: '80%', maxWidth: '500px', maxHeight: '75%', overflowY: 'auto', overflowX: 'hidden', top: position.includes('top') ? '10px' : 'auto', bottom: position.includes('bottom') ? '10px' : 'auto', left: position.includes('Left') ? '10px' : 'auto', right: position.includes('Right') ? '10px' : 'auto' }\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">Background Settings</h2>\r\n        <button (click)=\"onClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr style=\"height: 1px; background-color: black; margin-top: 5px; margin-bottom: 5px;\" />\r\n      <div style=\"max-width: 95%; overflow-x: auto;\">\r\n        <div id=\"defaultImages\" #defaultImagesContainer></div>\r\n        <div class=\"form-group\" style=\"max-width: 70%; overflow-x: auto;\">\r\n          <label for=\"uploadImage\">Upload Custom Image</label>\r\n          <input type=\"file\" class=\"form-control\" id=\"uploadImage\" #uploadImageInput (change)=\"handleImageUpload($event)\" />\r\n        </div>\r\n        <canvas id=\"mainCanvas\" #mainCanvas class=\"d-none\"></canvas>\r\n        <canvas id=\"backgroundCanvas\" #backgroundCanvas class=\"d-none\" style=\"width: 100%; max-width: 400px; height: auto; background-color: transparent; border: 1px solid black;\"></canvas>\r\n        <video id=\"captureVideo\" #captureVideo class=\"d-none\" muted autoplay playsinline></video>\r\n        <video id=\"previewVideo\" #videoPreview class=\"d-none\" muted autoplay playsinline style=\"width: 100%; max-width: 400px; height: auto; background-color: transparent; border: 1px solid black;\"></video>\r\n        <div id=\"loadingOverlay\" #loadingOverlay class=\"d-none\" [ngStyle]=\"{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, 0.5)', display: 'flex', 'justify-content': 'center', 'align-items': 'center', zIndex: 1000 }\">\r\n          <div [ngStyle]=\"{ width: '50px', height: '50px', border: '5px solid rgba(255, 255, 255, 0.3)', borderRadius: '50%', borderTop: '5px solid white', animation: 'spin 1s linear infinite' }\"></div>\r\n        </div>\r\n        <br />\r\n        <button id=\"applyBackgroundButton\" #applyBackgroundButton class=\"btn btn-primary\" (click)=\"applyBackground()\">Preview Background</button>\r\n        <button id=\"saveBackgroundButton\" #saveBackgroundButton class=\"btn btn-success d-none\" (click)=\"saveBackground()\">Save Background</button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n", styles: ["@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n"] }]
        }], propDecorators: { isVisible: [{
                type: Input
            }], parameters: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], onClose: [{
                type: Input
            }], defaultImagesContainerRef: [{
                type: ViewChild,
                args: ['defaultImagesContainer']
            }], uploadImageInputRef: [{
                type: ViewChild,
                args: ['uploadImageInput']
            }], backgroundCanvasRef: [{
                type: ViewChild,
                args: ['backgroundCanvas']
            }], videoPreviewRef: [{
                type: ViewChild,
                args: ['videoPreview']
            }], captureVideoRef: [{
                type: ViewChild,
                args: ['captureVideo']
            }], loadingOverlayRef: [{
                type: ViewChild,
                args: ['loadingOverlay']
            }], applyBackgroundButtonRef: [{
                type: ViewChild,
                args: ['applyBackgroundButton']
            }], saveBackgroundButtonRef: [{
                type: ViewChild,
                args: ['saveBackgroundButton']
            }] } });

class RoomListComponent {
    rooms = [];
    editRoom = new EventEmitter();
    deleteRoom = new EventEmitter();
    removeParticipant = new EventEmitter();
    faPen = faPen;
    faTimes = faTimes;
    faUsers = faUsers;
    handleEditRoom(roomIndex) {
        this.editRoom.emit(roomIndex);
    }
    handleDeleteRoom(roomIndex) {
        this.deleteRoom.emit(roomIndex);
    }
    handleRemoveParticipant(roomIndex, participant) {
        this.removeParticipant.emit({ roomIndex, participant });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RoomListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: RoomListComponent, isStandalone: true, selector: "app-room-list", inputs: { rooms: "rooms" }, outputs: { editRoom: "editRoom", deleteRoom: "deleteRoom", removeParticipant: "removeParticipant" }, ngImport: i0, template: "<div *ngFor=\"let room of rooms; let roomIndex = index\" class=\"card mb-3 text-dark\">\r\n    <div class=\"card-header d-flex justify-content-between align-items-center\">\r\n      <span>Room {{ roomIndex + 1 }} <fa-icon [icon]=\"faUsers\"></fa-icon></span>\r\n      <div>\r\n        <button class=\"btn btn-secondary btn-sm\" (click)=\"handleEditRoom(roomIndex)\">\r\n          <fa-icon [icon]=\"faPen\"></fa-icon>\r\n        </button>\r\n        <button class=\"btn btn-danger btn-sm\" (click)=\"handleDeleteRoom(roomIndex)\">\r\n          <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n        </button>\r\n      </div>\r\n    </div>\r\n    <div class=\"card-body\">\r\n      <ul class=\"list-group\">\r\n        <li *ngFor=\"let participant of room; let index = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n          {{ participant.name }}\r\n          <button class=\"btn btn-danger btn-sm\" (click)=\"handleRemoveParticipant(roomIndex, participant)\">\r\n            <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n          </button>\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RoomListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-room-list', standalone: true, imports: [CommonModule, FontAwesomeModule], template: "<div *ngFor=\"let room of rooms; let roomIndex = index\" class=\"card mb-3 text-dark\">\r\n    <div class=\"card-header d-flex justify-content-between align-items-center\">\r\n      <span>Room {{ roomIndex + 1 }} <fa-icon [icon]=\"faUsers\"></fa-icon></span>\r\n      <div>\r\n        <button class=\"btn btn-secondary btn-sm\" (click)=\"handleEditRoom(roomIndex)\">\r\n          <fa-icon [icon]=\"faPen\"></fa-icon>\r\n        </button>\r\n        <button class=\"btn btn-danger btn-sm\" (click)=\"handleDeleteRoom(roomIndex)\">\r\n          <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n        </button>\r\n      </div>\r\n    </div>\r\n    <div class=\"card-body\">\r\n      <ul class=\"list-group\">\r\n        <li *ngFor=\"let participant of room; let index = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n          {{ participant.name }}\r\n          <button class=\"btn btn-danger btn-sm\" (click)=\"handleRemoveParticipant(roomIndex, participant)\">\r\n            <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n          </button>\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n" }]
        }], propDecorators: { rooms: [{
                type: Input
            }], editRoom: [{
                type: Output
            }], deleteRoom: [{
                type: Output
            }], removeParticipant: [{
                type: Output
            }] } });

class EditRoomModalComponent {
    editRoomModalVisible = false;
    currentRoom = [];
    participantsRef = [];
    currentRoomIndex = -1;
    position = 'center';
    backgroundColor = '#fff';
    setEditRoomModalVisible = new EventEmitter();
    addParticipant = new EventEmitter();
    removeParticipant = new EventEmitter();
    faTimes = faTimes;
    faPlus = faPlus;
    faUsers = faUsers;
    faPen = faPen;
    modalWidth = 400;
    ngOnInit() {
        this.calculateModalWidth();
        window.addEventListener('resize', this.calculateModalWidth.bind(this));
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.calculateModalWidth.bind(this));
    }
    calculateModalWidth() {
        const screenWidth = window.innerWidth;
        this.modalWidth = screenWidth > 500 ? 400 : screenWidth * 0.8;
    }
    modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            zIndex: 1000,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
        };
    }
    modalContentStyle() {
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '20px',
            width: `${this.modalWidth}px`,
            maxHeight: '80%',
            overflowY: 'auto',
        };
    }
    handleAddParticipant(roomIndex, participant) {
        this.addParticipant.emit({ roomIndex, participant });
    }
    handleRemoveParticipant(roomIndex, participant) {
        this.removeParticipant.emit({ roomIndex, participant });
    }
    closeModal() {
        this.setEditRoomModalVisible.emit(false);
    }
    unassignedParticipants() {
        return this.participantsRef.filter((participant) => participant['breakRoom'] == null);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: EditRoomModalComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: EditRoomModalComponent, isStandalone: true, selector: "app-edit-room-modal", inputs: { editRoomModalVisible: "editRoomModalVisible", currentRoom: "currentRoom", participantsRef: "participantsRef", currentRoomIndex: "currentRoomIndex", position: "position", backgroundColor: "backgroundColor" }, outputs: { setEditRoomModalVisible: "setEditRoomModalVisible", addParticipant: "addParticipant", removeParticipant: "removeParticipant" }, ngImport: i0, template: "<div *ngIf=\"editRoomModalVisible\" class=\"modal-container\" [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content text-dark\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <h5 class=\"modal-title\">Edit Room {{ currentRoomIndex + 1 }} <fa-icon [icon]=\"faPen\"></fa-icon></h5>\r\n      <button type=\"button\" class=\"close\" (click)=\"closeModal()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <div class=\"modal-body\">\r\n      <div class=\"list-container\">\r\n        <h5>Assigned Participants <fa-icon [icon]=\"faUsers\"></fa-icon></h5>\r\n        <ul class=\"list-group\">\r\n          <li *ngFor=\"let participant of currentRoom; let i = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            {{ participant.name }}\r\n            <button class=\"btn btn-danger btn-sm\" (click)=\"handleRemoveParticipant(currentRoomIndex, participant)\">\r\n              <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n            </button>\r\n          </li>\r\n          <li *ngIf=\"currentRoom.length === 0\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            None assigned\r\n          </li>\r\n        </ul>\r\n      </div>\r\n      <div class=\"list-container\">\r\n        <h5>Unassigned Participants <fa-icon [icon]=\"faUsers\"></fa-icon></h5>\r\n        <ul class=\"list-group\">\r\n          <li *ngFor=\"let participant of unassignedParticipants(); let i = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            {{ participant.name }}\r\n            <button class=\"btn btn-primary btn-sm\" (click)=\"handleAddParticipant(currentRoomIndex, participant)\">\r\n              <fa-icon [icon]=\"faPlus\"></fa-icon>\r\n            </button>\r\n          </li>\r\n          <li *ngIf=\"unassignedParticipants().length === 0\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            None pending\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button type=\"button\" class=\"btn btn-secondary\" (click)=\"closeModal()\">Close</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-content{background-color:#fff;border-radius:10px;padding:20px;max-width:500px;max-height:80%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}.modal-title{font-size:1.25rem;font-weight:700}.list-container{border:1px solid #ccc;border-radius:5px;padding:10px;margin-bottom:20px}.list-group-item{display:flex;justify-content:space-between;align-items:center}.modal-footer{display:flex;justify-content:flex-end;margin-top:20px}.close-button{border:none;background:none;cursor:pointer}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: EditRoomModalComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-edit-room-modal', standalone: true, imports: [CommonModule, FontAwesomeModule], template: "<div *ngIf=\"editRoomModalVisible\" class=\"modal-container\" [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content text-dark\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <h5 class=\"modal-title\">Edit Room {{ currentRoomIndex + 1 }} <fa-icon [icon]=\"faPen\"></fa-icon></h5>\r\n      <button type=\"button\" class=\"close\" (click)=\"closeModal()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <div class=\"modal-body\">\r\n      <div class=\"list-container\">\r\n        <h5>Assigned Participants <fa-icon [icon]=\"faUsers\"></fa-icon></h5>\r\n        <ul class=\"list-group\">\r\n          <li *ngFor=\"let participant of currentRoom; let i = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            {{ participant.name }}\r\n            <button class=\"btn btn-danger btn-sm\" (click)=\"handleRemoveParticipant(currentRoomIndex, participant)\">\r\n              <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n            </button>\r\n          </li>\r\n          <li *ngIf=\"currentRoom.length === 0\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            None assigned\r\n          </li>\r\n        </ul>\r\n      </div>\r\n      <div class=\"list-container\">\r\n        <h5>Unassigned Participants <fa-icon [icon]=\"faUsers\"></fa-icon></h5>\r\n        <ul class=\"list-group\">\r\n          <li *ngFor=\"let participant of unassignedParticipants(); let i = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            {{ participant.name }}\r\n            <button class=\"btn btn-primary btn-sm\" (click)=\"handleAddParticipant(currentRoomIndex, participant)\">\r\n              <fa-icon [icon]=\"faPlus\"></fa-icon>\r\n            </button>\r\n          </li>\r\n          <li *ngIf=\"unassignedParticipants().length === 0\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            None pending\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button type=\"button\" class=\"btn btn-secondary\" (click)=\"closeModal()\">Close</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-content{background-color:#fff;border-radius:10px;padding:20px;max-width:500px;max-height:80%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}.modal-title{font-size:1.25rem;font-weight:700}.list-container{border:1px solid #ccc;border-radius:5px;padding:10px;margin-bottom:20px}.list-group-item{display:flex;justify-content:space-between;align-items:center}.modal-footer{display:flex;justify-content:flex-end;margin-top:20px}.close-button{border:none;background:none;cursor:pointer}\n"] }]
        }], propDecorators: { editRoomModalVisible: [{
                type: Input
            }], currentRoom: [{
                type: Input
            }], participantsRef: [{
                type: Input
            }], currentRoomIndex: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], setEditRoomModalVisible: [{
                type: Output
            }], addParticipant: [{
                type: Output
            }], removeParticipant: [{
                type: Output
            }] } });

class BreakoutRoomsModal {
    isVisible = false;
    parameters;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    onBreakoutRoomsClose = () => {
        console.log('Breakout rooms closed');
    };
    roomsContainerRef;
    faDoorOpen = faDoorOpen;
    faTimes = faTimes;
    faRandom = faRandom;
    faHandPointer = faHandPointer;
    faPlus = faPlus;
    faSave = faSave;
    faPlay = faPlay;
    faSyncAlt = faSyncAlt;
    faStop = faStop;
    faUsers = faUsers;
    participantsRef = [];
    breakoutRoomsRef = [];
    numRooms = '';
    newParticipantAction = 'autoAssignNewRoom';
    currentRoom = null;
    editRoomModalVisible = false;
    startBreakoutButtonVisible = false;
    stopBreakoutButtonVisible = false;
    modalWidth = 400;
    calculateModalWidth() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.85 * screenWidth;
        if (modalWidth > 700) {
            modalWidth = 700;
        }
        this.modalWidth = modalWidth;
    }
    modalContainerStyle() {
        return {
            display: this.isVisible ? 'block' : 'none',
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            zIndex: '999',
        };
    }
    modalContentStyle() {
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${this.modalWidth}px`,
            maxHeight: '75%',
            overflowX: 'hidden',
            overflowY: 'auto',
            position: 'fixed',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    ngOnChanges(changes) {
        if (changes['isVisible'] && this.isVisible) {
            this.initializeBreakoutRooms();
        }
    }
    ngOnInit() {
        this.calculateModalWidth();
    }
    initializeBreakoutRooms = () => {
        this.parameters = this.parameters.getUpdatedAllParams();
        const filteredParticipants = this.parameters.participants.filter((participant) => participant.islevel != '2');
        this.participantsRef = filteredParticipants;
        this.breakoutRoomsRef =
            this.parameters.breakoutRooms && this.parameters.breakoutRooms.length > 0
                ? [...this.parameters.breakoutRooms]
                : [];
        this.checkCanStartBreakout();
    };
    handleRandomAssign() {
        const numRoomsInt = parseInt(this.numRooms);
        if (!numRoomsInt || numRoomsInt <= 0) {
            this.parameters.showAlert?.({
                message: 'Please enter a valid number of rooms',
                type: 'danger',
            });
            return;
        }
        const newBreakoutRooms = Array.from({ length: numRoomsInt }, () => []);
        const shuffledParticipants = [...this.participantsRef].sort(() => 0.5 - Math.random());
        shuffledParticipants.forEach((participant, index) => {
            const roomIndex = index % numRoomsInt;
            if (newBreakoutRooms[roomIndex].length < this.parameters.itemPageLimit) {
                const participant_ = { name: participant.name, breakRoom: roomIndex };
                newBreakoutRooms[roomIndex].push(participant_);
                participant['breakRoom'] = roomIndex;
            }
            else {
                for (let i = 0; i < numRoomsInt; i++) {
                    if (newBreakoutRooms[i].length < this.parameters.itemPageLimit) {
                        newBreakoutRooms[i].push(participant);
                        participant['breakRoom'] = i;
                        break;
                    }
                }
            }
        });
        this.breakoutRoomsRef = newBreakoutRooms;
        this.checkCanStartBreakout();
    }
    handleManualAssign() {
        const numRoomsInt = parseInt(this.numRooms);
        if (!numRoomsInt || numRoomsInt <= 0) {
            this.parameters.showAlert?.({
                message: 'Please enter a valid number of rooms',
                type: 'danger',
            });
            return;
        }
        this.breakoutRoomsRef = Array.from({ length: numRoomsInt }, () => []);
        this.parameters.updateCanStartBreakout(false);
        this.checkCanStartBreakout();
    }
    handleAddRoom() {
        this.breakoutRoomsRef = [...this.breakoutRoomsRef, []];
        this.parameters.updateCanStartBreakout(false);
        this.checkCanStartBreakout();
    }
    handleSaveRooms() {
        if (this.validateRooms()) {
            this.parameters.updateBreakoutRooms(this.breakoutRoomsRef);
            this.parameters.updateCanStartBreakout(true);
            this.checkCanStartBreakout();
            this.parameters.showAlert?.({ message: 'Rooms saved successfully', type: 'success' });
        }
        else {
            this.parameters.showAlert?.({ message: 'Rooms validation failed', type: 'danger' });
        }
    }
    validateRooms() {
        if (this.breakoutRoomsRef.length == 0) {
            this.parameters.showAlert?.({ message: 'There must be at least one room', type: 'danger' });
            return false;
        }
        for (let room of this.breakoutRoomsRef) {
            if (room.length == 0) {
                this.parameters.showAlert?.({ message: 'Rooms must not be empty', type: 'danger' });
                return false;
            }
            const participantNames = room.map((p) => p.name);
            const uniqueNames = new Set(participantNames);
            if (participantNames.length != uniqueNames.size) {
                this.parameters.showAlert?.({
                    message: 'Duplicate participant names in a room',
                    type: 'danger',
                });
                return false;
            }
            if (room.length > this.parameters.itemPageLimit) {
                this.parameters.showAlert?.({
                    message: 'A room exceeds the participant limit',
                    type: 'danger',
                });
                return false;
            }
        }
        return true;
    }
    checkCanStartBreakout = () => {
        this.parameters = this.parameters.getUpdatedAllParams();
        if (this.parameters.canStartBreakout) {
            this.startBreakoutButtonVisible = true;
            this.stopBreakoutButtonVisible =
                this.parameters.breakOutRoomStarted && !this.parameters.breakOutRoomEnded;
        }
        else {
            this.startBreakoutButtonVisible = false;
            this.stopBreakoutButtonVisible = false;
        }
    };
    handleStartBreakout = () => {
        this.parameters = this.parameters.getUpdatedAllParams();
        if (this.parameters.shareScreenStarted || this.parameters.shared) {
            this.parameters.showAlert?.({
                message: 'You cannot start breakout rooms while screen sharing is active',
                type: 'danger',
            });
            return;
        }
        if (this.parameters.canStartBreakout) {
            const emitName = this.parameters.breakOutRoomStarted && !this.parameters.breakOutRoomEnded
                ? 'updateBreakout'
                : 'startBreakout';
            const filteredBreakoutRooms = this.breakoutRoomsRef.map((room) => room.map(({ name, breakRoom }) => ({ name, breakRoom })));
            this.parameters.socket.emit(emitName, {
                breakoutRooms: filteredBreakoutRooms,
                newParticipantAction: this.newParticipantAction,
                roomName: this.parameters.roomName,
            }, (response) => {
                if (response.success) {
                    this.parameters.showAlert?.({ message: 'Breakout rooms active', type: 'success' });
                    this.parameters.updateBreakOutRoomStarted(true);
                    this.parameters.updateBreakOutRoomEnded(false);
                    this.onBreakoutRoomsClose();
                    if (this.parameters.meetingDisplayType != 'all') {
                        this.parameters.updateMeetingDisplayType('all');
                    }
                }
                else {
                    this.parameters.showAlert?.({ message: response.reason, type: 'danger' });
                }
            });
        }
    };
    handleStopBreakout() {
        this.parameters.socket.emit('stopBreakout', { roomName: this.parameters.roomName }, (response) => {
            if (response.success) {
                this.parameters.showAlert?.({ message: 'Breakout rooms stopped', type: 'success' });
                this.parameters.updateBreakOutRoomStarted(false);
                this.parameters.updateBreakOutRoomEnded(true);
                this.onBreakoutRoomsClose();
                if (this.parameters.meetingDisplayType != this.parameters.prevMeetingDisplayType) {
                    this.parameters.updateMeetingDisplayType(this.parameters.prevMeetingDisplayType);
                }
            }
            else {
                this.parameters.showAlert?.({ message: response.reason, type: 'danger' });
            }
        });
    }
    handleEditRoom(roomIndex) {
        this.parameters.updateCurrentRoomIndex(roomIndex);
        this.currentRoom = this.breakoutRoomsRef[roomIndex];
        this.editRoomModalVisible = true;
        this.parameters.updateCanStartBreakout(false);
        this.checkCanStartBreakout();
    }
    handleDeleteRoom(roomIndex) {
        if (this.breakoutRoomsRef.length > 0) {
            const room = this.breakoutRoomsRef[roomIndex];
            room.forEach((participant) => (participant.breakRoom = null));
            const newBreakoutRooms = [...this.breakoutRoomsRef];
            newBreakoutRooms.splice(roomIndex, 1);
            newBreakoutRooms.forEach((room, index) => {
                room.forEach((participant) => (participant.breakRoom = index));
            });
            this.breakoutRoomsRef = newBreakoutRooms;
            this.checkCanStartBreakout();
        }
    }
    handleAddParticipant(event) {
        const { roomIndex, participant } = event;
        if (this.breakoutRoomsRef[roomIndex].length < this.parameters.itemPageLimit) {
            const newBreakoutRooms = [...this.breakoutRoomsRef];
            newBreakoutRooms[roomIndex].push(participant);
            this.breakoutRoomsRef = newBreakoutRooms;
            participant['breakRoom'] = roomIndex;
            if (this.parameters.currentRoomIndex != null) {
                this.handleEditRoom(this.parameters.currentRoomIndex);
            }
        }
        else {
            this.parameters.showAlert?.({ message: 'Room is full', type: 'danger' });
        }
    }
    handleRemoveParticipant(event) {
        const { roomIndex, participant } = event;
        const newBreakoutRooms = [...this.breakoutRoomsRef];
        newBreakoutRooms[roomIndex] = newBreakoutRooms[roomIndex].filter((p) => p != participant);
        this.breakoutRoomsRef = newBreakoutRooms;
        participant['breakRoom'] = null;
        if (this.parameters.currentRoomIndex != null) {
            this.handleEditRoom(this.parameters.currentRoomIndex);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: BreakoutRoomsModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: BreakoutRoomsModal, isStandalone: true, selector: "app-breakout-rooms-modal", inputs: { isVisible: "isVisible", parameters: "parameters", position: "position", backgroundColor: "backgroundColor", onBreakoutRoomsClose: "onBreakoutRoomsClose" }, viewQueries: [{ propertyName: "roomsContainerRef", first: true, predicate: ["roomsContainer"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isVisible\" class=\"modal-container\" [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <h2>Breakout Rooms <fa-icon [icon]=\"faDoorOpen\"></fa-icon></h2>\r\n      <button class=\"close-btn\" (click)=\"onBreakoutRoomsClose()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <hr>\r\n    <div class=\"form-group\">\r\n      <label for=\"numRooms\">Number of Rooms <fa-icon [icon]=\"faUsers\"></fa-icon></label>\r\n      <input type=\"number\" class=\"form-control\" id=\"numRooms\" [(ngModel)]=\"numRooms\">\r\n    </div>\r\n    <div class=\"form-group\">\r\n      <button class=\"btn btn-primary\" (click)=\"handleRandomAssign()\">Random Assign <fa-icon [icon]=\"faRandom\"></fa-icon></button>\r\n      <button class=\"btn btn-secondary\" (click)=\"handleManualAssign()\">Manual Assign <fa-icon [icon]=\"faHandPointer\"></fa-icon></button>\r\n      <button class=\"btn btn-success\" (click)=\"handleAddRoom()\">Add Room <fa-icon [icon]=\"faPlus\"></fa-icon></button>\r\n      <button class=\"btn btn-info\" (click)=\"handleSaveRooms()\">Save Rooms <fa-icon [icon]=\"faSave\"></fa-icon></button>\r\n    </div>\r\n    <div class=\"form-group\">\r\n      <label for=\"newParticipantAction\">New Participant Action <fa-icon [icon]=\"faUsers\"></fa-icon></label>\r\n      <select class=\"form-control\" id=\"newParticipantAction\" [(ngModel)]=\"newParticipantAction\">\r\n        <option value=\"autoAssignNewRoom\">Add to new room</option>\r\n        <option value=\"autoAssignAvailableRoom\">Add to open room</option>\r\n        <option value=\"manualAssign\">No action</option>\r\n      </select>\r\n    </div>\r\n    <div #roomsContainer>\r\n      <app-room-list [rooms]=\"breakoutRoomsRef\" (editRoom)=\"handleEditRoom($event)\" (deleteRoom)=\"handleDeleteRoom($event)\" (removeParticipant)=\"handleRemoveParticipant($event)\"></app-room-list>\r\n    </div>\r\n    <div *ngIf=\"startBreakoutButtonVisible\">\r\n      <button class=\"btn btn-primary mr-2 mb-2\" (click)=\"handleStartBreakout()\">\r\n        {{ parameters.breakOutRoomStarted && !parameters.breakOutRoomEnded ? 'Update Breakout' : 'Start Breakout' }} <fa-icon [icon]=\"parameters.breakOutRoomStarted && !parameters.breakOutRoomEnded ? faSyncAlt : faPlay\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <div *ngIf=\"stopBreakoutButtonVisible\">\r\n      <button class=\"btn btn-danger mr-2 mb-2\" (click)=\"handleStopBreakout()\">\r\n        Stop Breakout <fa-icon [icon]=\"faStop\"></fa-icon>\r\n      </button>\r\n    </div>\r\n  </div>\r\n  <app-edit-room-modal [editRoomModalVisible]=\"editRoomModalVisible\" [currentRoom]=\"currentRoom!\" [participantsRef]=\"participantsRef\" [currentRoomIndex]=\"parameters.currentRoomIndex!\" (setEditRoomModalVisible)=\"editRoomModalVisible = $event\" (addParticipant)=\"handleAddParticipant($event)\" (removeParticipant)=\"handleRemoveParticipant($event)\"></app-edit-room-modal>\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$1.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { kind: "directive", type: i2$1.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: RoomListComponent, selector: "app-room-list", inputs: ["rooms"], outputs: ["editRoom", "deleteRoom", "removeParticipant"] }, { kind: "component", type: EditRoomModalComponent, selector: "app-edit-room-modal", inputs: ["editRoomModalVisible", "currentRoom", "participantsRef", "currentRoomIndex", "position", "backgroundColor"], outputs: ["setEditRoomModalVisible", "addParticipant", "removeParticipant"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: BreakoutRoomsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-breakout-rooms-modal', standalone: true, imports: [
                        CommonModule,
                        FormsModule,
                        FontAwesomeModule,
                        RoomListComponent,
                        EditRoomModalComponent,
                    ], template: "<div *ngIf=\"isVisible\" class=\"modal-container\" [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <h2>Breakout Rooms <fa-icon [icon]=\"faDoorOpen\"></fa-icon></h2>\r\n      <button class=\"close-btn\" (click)=\"onBreakoutRoomsClose()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <hr>\r\n    <div class=\"form-group\">\r\n      <label for=\"numRooms\">Number of Rooms <fa-icon [icon]=\"faUsers\"></fa-icon></label>\r\n      <input type=\"number\" class=\"form-control\" id=\"numRooms\" [(ngModel)]=\"numRooms\">\r\n    </div>\r\n    <div class=\"form-group\">\r\n      <button class=\"btn btn-primary\" (click)=\"handleRandomAssign()\">Random Assign <fa-icon [icon]=\"faRandom\"></fa-icon></button>\r\n      <button class=\"btn btn-secondary\" (click)=\"handleManualAssign()\">Manual Assign <fa-icon [icon]=\"faHandPointer\"></fa-icon></button>\r\n      <button class=\"btn btn-success\" (click)=\"handleAddRoom()\">Add Room <fa-icon [icon]=\"faPlus\"></fa-icon></button>\r\n      <button class=\"btn btn-info\" (click)=\"handleSaveRooms()\">Save Rooms <fa-icon [icon]=\"faSave\"></fa-icon></button>\r\n    </div>\r\n    <div class=\"form-group\">\r\n      <label for=\"newParticipantAction\">New Participant Action <fa-icon [icon]=\"faUsers\"></fa-icon></label>\r\n      <select class=\"form-control\" id=\"newParticipantAction\" [(ngModel)]=\"newParticipantAction\">\r\n        <option value=\"autoAssignNewRoom\">Add to new room</option>\r\n        <option value=\"autoAssignAvailableRoom\">Add to open room</option>\r\n        <option value=\"manualAssign\">No action</option>\r\n      </select>\r\n    </div>\r\n    <div #roomsContainer>\r\n      <app-room-list [rooms]=\"breakoutRoomsRef\" (editRoom)=\"handleEditRoom($event)\" (deleteRoom)=\"handleDeleteRoom($event)\" (removeParticipant)=\"handleRemoveParticipant($event)\"></app-room-list>\r\n    </div>\r\n    <div *ngIf=\"startBreakoutButtonVisible\">\r\n      <button class=\"btn btn-primary mr-2 mb-2\" (click)=\"handleStartBreakout()\">\r\n        {{ parameters.breakOutRoomStarted && !parameters.breakOutRoomEnded ? 'Update Breakout' : 'Start Breakout' }} <fa-icon [icon]=\"parameters.breakOutRoomStarted && !parameters.breakOutRoomEnded ? faSyncAlt : faPlay\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <div *ngIf=\"stopBreakoutButtonVisible\">\r\n      <button class=\"btn btn-danger mr-2 mb-2\" (click)=\"handleStopBreakout()\">\r\n        Stop Breakout <fa-icon [icon]=\"faStop\"></fa-icon>\r\n      </button>\r\n    </div>\r\n  </div>\r\n  <app-edit-room-modal [editRoomModalVisible]=\"editRoomModalVisible\" [currentRoom]=\"currentRoom!\" [participantsRef]=\"participantsRef\" [currentRoomIndex]=\"parameters.currentRoomIndex!\" (setEditRoomModalVisible)=\"editRoomModalVisible = $event\" (addParticipant)=\"handleAddParticipant($event)\" (removeParticipant)=\"handleRemoveParticipant($event)\"></app-edit-room-modal>\r\n</div>\r\n" }]
        }], propDecorators: { isVisible: [{
                type: Input
            }], parameters: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], onBreakoutRoomsClose: [{
                type: Input
            }], roomsContainerRef: [{
                type: ViewChild,
                args: ['roomsContainer']
            }] } });

class ConfigureWhiteboardModal {
    isVisible = false;
    parameters = {};
    backgroundColor = '#83c0e9';
    position = 'topRight';
    onConfigureWhiteboardClose;
    faTimes = faTimes;
    faCheck = faCheck;
    faSyncAlt = faSyncAlt;
    faPlay = faPlay;
    faSave = faSave;
    participantsCopy = [];
    whiteboardLimit;
    isEditing = false;
    canStartWhiteboard = false;
    assignedParticipants = [];
    unassignedParticipants = [];
    whiteboardStarted = false;
    whiteboardEnded = false;
    socket = {};
    ngOnInit() {
        if (this.parameters && this.isVisible) {
            try {
                this.parameters = this.parameters.getUpdatedAllParams();
            }
            catch {
                /* handle error */
            }
            this.whiteboardLimit = this.parameters.itemPageLimit;
            this.whiteboardStarted = this.parameters.whiteboardStarted;
            this.whiteboardEnded = this.parameters.whiteboardEnded;
            this.checkCanStartWhiteboard();
        }
        if (this.parameters) {
            this.socket = this.parameters.socket;
            if (this.socket) {
                this.setupSocketListeners();
            }
        }
    }
    ngOnChanges(changes) {
        if (changes['parameters'] && this.parameters) {
            if (this.parameters && this.isVisible) {
                this.whiteboardLimit = this.parameters.itemPageLimit;
                this.whiteboardStarted = this.parameters.whiteboardStarted;
                this.whiteboardEnded = this.parameters.whiteboardEnded;
                this.checkCanStartWhiteboard();
            }
            this.socket = this.parameters.socket;
            if (this.socket) {
                this.setupSocketListeners();
            }
        }
        if (changes['isVisible'] && this.isVisible) {
            this.parameters = this.parameters.getUpdatedAllParams();
            if (!this.participantsCopy.length) {
                const filteredParticipants = this.parameters.participants.filter((participant) => participant.islevel != '2');
                this.participantsCopy = filteredParticipants;
                this.updateParticipantsLists();
            }
            this.checkCanStartWhiteboard();
        }
    }
    setupSocketListeners = () => {
        if (this.socket && this.socket instanceof Socket) {
            this.socket.on('whiteboardUpdated', async (data) => {
                if (this.parameters.islevel == '2' && data.members) {
                    const filteredParticipants = data.members.filter((participant) => !participant.isBanned);
                    this.participantsCopy = filteredParticipants;
                    this.updateParticipantsLists();
                }
                this.parameters.updateWhiteboardUsers(data.whiteboardUsers);
                if (data.status == 'started') {
                    this.whiteboardStarted = true;
                    this.whiteboardEnded = false;
                    this.parameters.updateWhiteboardStarted(true);
                    this.parameters.updateWhiteboardEnded(false);
                    if (this.parameters.islevel != '2') {
                        this.parameters.shareScreenStarted = true;
                        await this.parameters.onScreenChanges({ changed: true, parameters: this.parameters });
                    }
                }
                else if (data.status == 'ended') {
                    this.whiteboardEnded = true;
                    this.whiteboardStarted = false;
                    this.parameters.updateWhiteboardStarted(false);
                    this.parameters.updateWhiteboardEnded(true);
                    this.parameters.shareScreenStarted = false;
                    await this.parameters.onScreenChanges({ changed: true, parameters: this.parameters });
                    await this.parameters.prepopulateUserMedia({
                        name: this.parameters.hostLabel,
                        parameters: this.parameters,
                    });
                    await this.parameters.rePort({ restart: true, parameters: this.parameters });
                }
            });
        }
    };
    toggleParticipant = (participant, add) => {
        this.isEditing = true;
        const selectedParticipants = this.participantsCopy.filter((p) => p.useBoard);
        if (add && selectedParticipants.length >= this.whiteboardLimit - 1) {
            this.parameters.showAlert?.({
                message: `Participant limit exceeded - you can only add ${this.whiteboardLimit - 1} other participants`,
                type: 'danger',
            });
            return;
        }
        this.participantsCopy = this.participantsCopy.map((p) => p.name === participant.name ? { ...p, useBoard: add } : p);
        this.updateParticipantsLists();
    };
    validateWhiteboard() {
        const selectedParticipants = this.participantsCopy.filter((participant) => participant.useBoard);
        if (selectedParticipants.length > this.whiteboardLimit) {
            this.parameters.showAlert?.({ message: 'Participant limit exceeded', type: 'danger' });
            return false;
        }
        return true;
    }
    checkCanStartWhiteboard() {
        const isValid = this.validateWhiteboard();
        this.canStartWhiteboard = isValid;
        this.parameters.updateCanStartWhiteboard(isValid);
    }
    handleSaveWhiteboard() {
        if (this.validateWhiteboard()) {
            this.isEditing = false;
            this.canStartWhiteboard = true;
            this.parameters.updateCanStartWhiteboard(true);
            this.checkCanStartWhiteboard();
            this.parameters.showAlert?.({ message: 'Whiteboard saved successfully', type: 'success' });
        }
        else {
            this.parameters.showAlert?.({ message: 'Whiteboard validation failed', type: 'danger' });
        }
    }
    async handleStartWhiteboard() {
        const { shareScreenStarted, shared, breakOutRoomStarted, breakOutRoomEnded, roomName, socket, recordStarted, recordResumed, recordPaused, recordStopped, recordingMediaOptions, onScreenChanges, captureCanvasStream, showAlert, } = this.parameters;
        if ((shareScreenStarted || shared) && !this.whiteboardStarted) {
            showAlert?.({
                message: 'You cannot start whiteboard while screen sharing is active',
                type: 'danger',
            });
            return;
        }
        if (breakOutRoomStarted && !breakOutRoomEnded) {
            showAlert?.({
                message: 'You cannot start whiteboard while breakout rooms are active',
                type: 'danger',
            });
            return;
        }
        if (this.canStartWhiteboard) {
            const emitName = this.whiteboardStarted && !this.whiteboardEnded ? 'updateWhiteboard' : 'startWhiteboard';
            const filteredWhiteboardUsers = this.participantsCopy
                .filter((participant) => participant.useBoard)
                .map(({ name, useBoard }) => ({ name, useBoard }));
            socket.emit(emitName, { whiteboardUsers: filteredWhiteboardUsers, roomName }, async (response) => {
                if (response.success) {
                    showAlert?.({ message: 'Whiteboard active', type: 'success' });
                    this.parameters.whiteboardStarted = true;
                    this.parameters.whiteboardEnded = false;
                    this.parameters.updateWhiteboardStarted(true);
                    this.parameters.updateWhiteboardEnded(false);
                    this.parameters.updateIsConfigureWhiteboardModalVisible(false);
                    if (this.parameters.islevel != '2') {
                        this.parameters.shareScreenStarted = true;
                        await onScreenChanges({ changed: true, parameters: this.parameters });
                    }
                    if (this.parameters.islevel == '2' && (recordStarted || recordResumed)) {
                        if (!(recordPaused || recordStopped) && recordingMediaOptions == 'video') {
                            await captureCanvasStream({ parameters: this.parameters });
                        }
                    }
                }
                else {
                    showAlert?.({ message: response.reason, type: 'danger' });
                }
            });
        }
    }
    async handleStopWhiteboard() {
        const { roomName, socket, showAlert, updateWhiteboardStarted, updateWhiteboardEnded, updateIsConfigureWhiteboardModalVisible, onScreenChanges, prepopulateUserMedia, rePort, hostLabel, } = this.parameters;
        socket.emit('stopWhiteboard', { roomName }, async (response) => {
            if (response.success) {
                showAlert?.({ message: 'Whiteboard stopped', type: 'success' });
                this.parameters.whiteboardEnded = true;
                this.parameters.whiteboardStarted = false;
                updateWhiteboardStarted(false);
                updateWhiteboardEnded(true);
                updateIsConfigureWhiteboardModalVisible(false);
                this.parameters.shareScreenStarted = false;
                await onScreenChanges({ changed: true, parameters: this.parameters });
                await prepopulateUserMedia({ name: hostLabel, parameters: this.parameters });
                await rePort({ restart: true, parameters: this.parameters });
            }
            else {
                showAlert?.({ message: response.reason, type: 'danger' });
            }
        });
    }
    modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isVisible ? 'block' : 'none',
            zIndex: 999,
        };
    }
    modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.7 * screenWidth;
        if (modalWidth > 400) {
            modalWidth = 400;
        }
        return {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: modalWidth + 'px',
            maxWidth: modalWidth + 'px',
            maxHeight: '75%',
            overflowY: 'auto',
            overflowX: 'hidden',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    updateParticipantsLists = () => {
        this.assignedParticipants = this.participantsCopy.filter((p) => p.useBoard);
        this.unassignedParticipants = this.participantsCopy.filter((p) => !p.useBoard);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfigureWhiteboardModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ConfigureWhiteboardModal, isStandalone: true, selector: "app-configure-whiteboard-modal", inputs: { isVisible: "isVisible", parameters: "parameters", backgroundColor: "backgroundColor", position: "position", onConfigureWhiteboardClose: "onConfigureWhiteboardClose" }, usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div [ngStyle]=\"modalContentStyle()\">\r\n    <div style=\"display: flex; flex-direction: column;\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">\r\n          Configure Whiteboard\r\n        </h2>\r\n        <button (click)=\"onConfigureWhiteboardClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <div class=\"modal-body\">\r\n        <div class=\"row\">\r\n          <div class=\"col-md-6 mb-3\">\r\n            <h6>Assigned</h6>\r\n            <ul class=\"list-group\" style=\"max-height: 200px; overflow-y: auto; border: 1px solid #ccc;\">\r\n              <ng-container *ngIf=\"assignedParticipants.length > 0; else noAssignedParticipants\">\r\n                <li *ngFor=\"let participant of assignedParticipants\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark mb-2 mr-2\">\r\n                  {{ participant.name }}\r\n                  <button class=\"btn btn-danger btn-sm mr-2 ml-2\" (click)=\"toggleParticipant(participant, false)\">\r\n                    <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n                  </button>\r\n                </li>\r\n              </ng-container>\r\n              <ng-template #noAssignedParticipants>\r\n                <li class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n                  None\r\n                </li>\r\n              </ng-template>\r\n            </ul>\r\n          </div>\r\n          <div class=\"col-md-6 mt-xs-3 mb-3\">\r\n            <h6>Pending</h6>\r\n            <ul class=\"list-group\" style=\"max-height: 200px; overflow-y: auto; border: 1px solid #ccc;\">\r\n              <ng-container *ngIf=\"unassignedParticipants.length > 0; else noPendingParticipants\">\r\n                <li *ngFor=\"let participant of unassignedParticipants\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark mb-2 mr-2\">\r\n                  {{ participant.name }}\r\n                  <button class=\"btn btn-primary btn-sm mr-2 ml-2\" (click)=\"toggleParticipant(participant, true)\">\r\n                    <fa-icon [icon]=\"faCheck\"></fa-icon>\r\n                  </button>\r\n                </li>\r\n              </ng-container>\r\n              <ng-template #noPendingParticipants>\r\n                <li class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n                  None\r\n                </li>\r\n              </ng-template>\r\n            </ul>\r\n          </div>\r\n        </div>\r\n      </div>\r\n      <div class=\"modal-footer\">\r\n        <button type=\"button\" class=\"btn btn-info\" (click)=\"handleSaveWhiteboard()\">\r\n          Save <fa-icon [icon]=\"faSave\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr />\r\n      <div *ngIf=\"!isEditing\">\r\n        <button *ngIf=\"canStartWhiteboard && whiteboardStarted && !whiteboardEnded\" class=\"btn btn-warning mb-2 mr-2\" (click)=\"handleStartWhiteboard()\">\r\n          Update <fa-icon [icon]=\"faSyncAlt\"></fa-icon>\r\n        </button>\r\n        <button *ngIf=\"canStartWhiteboard && !whiteboardStarted\" class=\"btn btn-success mb-2 mr-2\" (click)=\"handleStartWhiteboard()\">\r\n          Start <fa-icon [icon]=\"faPlay\"></fa-icon>\r\n        </button>\r\n        <button *ngIf=\"whiteboardStarted && !whiteboardEnded\" class=\"btn btn-danger mb-2 ml-2\" (click)=\"handleStopWhiteboard()\">\r\n          Stop <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-body{max-height:400px;overflow-y:auto}.list-group-item{cursor:pointer}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfigureWhiteboardModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-configure-whiteboard-modal', standalone: true, imports: [CommonModule, FontAwesomeModule], template: "<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div [ngStyle]=\"modalContentStyle()\">\r\n    <div style=\"display: flex; flex-direction: column;\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">\r\n          Configure Whiteboard\r\n        </h2>\r\n        <button (click)=\"onConfigureWhiteboardClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <div class=\"modal-body\">\r\n        <div class=\"row\">\r\n          <div class=\"col-md-6 mb-3\">\r\n            <h6>Assigned</h6>\r\n            <ul class=\"list-group\" style=\"max-height: 200px; overflow-y: auto; border: 1px solid #ccc;\">\r\n              <ng-container *ngIf=\"assignedParticipants.length > 0; else noAssignedParticipants\">\r\n                <li *ngFor=\"let participant of assignedParticipants\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark mb-2 mr-2\">\r\n                  {{ participant.name }}\r\n                  <button class=\"btn btn-danger btn-sm mr-2 ml-2\" (click)=\"toggleParticipant(participant, false)\">\r\n                    <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n                  </button>\r\n                </li>\r\n              </ng-container>\r\n              <ng-template #noAssignedParticipants>\r\n                <li class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n                  None\r\n                </li>\r\n              </ng-template>\r\n            </ul>\r\n          </div>\r\n          <div class=\"col-md-6 mt-xs-3 mb-3\">\r\n            <h6>Pending</h6>\r\n            <ul class=\"list-group\" style=\"max-height: 200px; overflow-y: auto; border: 1px solid #ccc;\">\r\n              <ng-container *ngIf=\"unassignedParticipants.length > 0; else noPendingParticipants\">\r\n                <li *ngFor=\"let participant of unassignedParticipants\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark mb-2 mr-2\">\r\n                  {{ participant.name }}\r\n                  <button class=\"btn btn-primary btn-sm mr-2 ml-2\" (click)=\"toggleParticipant(participant, true)\">\r\n                    <fa-icon [icon]=\"faCheck\"></fa-icon>\r\n                  </button>\r\n                </li>\r\n              </ng-container>\r\n              <ng-template #noPendingParticipants>\r\n                <li class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n                  None\r\n                </li>\r\n              </ng-template>\r\n            </ul>\r\n          </div>\r\n        </div>\r\n      </div>\r\n      <div class=\"modal-footer\">\r\n        <button type=\"button\" class=\"btn btn-info\" (click)=\"handleSaveWhiteboard()\">\r\n          Save <fa-icon [icon]=\"faSave\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr />\r\n      <div *ngIf=\"!isEditing\">\r\n        <button *ngIf=\"canStartWhiteboard && whiteboardStarted && !whiteboardEnded\" class=\"btn btn-warning mb-2 mr-2\" (click)=\"handleStartWhiteboard()\">\r\n          Update <fa-icon [icon]=\"faSyncAlt\"></fa-icon>\r\n        </button>\r\n        <button *ngIf=\"canStartWhiteboard && !whiteboardStarted\" class=\"btn btn-success mb-2 mr-2\" (click)=\"handleStartWhiteboard()\">\r\n          Start <fa-icon [icon]=\"faPlay\"></fa-icon>\r\n        </button>\r\n        <button *ngIf=\"whiteboardStarted && !whiteboardEnded\" class=\"btn btn-danger mb-2 ml-2\" (click)=\"handleStopWhiteboard()\">\r\n          Stop <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-body{max-height:400px;overflow-y:auto}.list-group-item{cursor:pointer}\n"] }]
        }], propDecorators: { isVisible: [{
                type: Input
            }], parameters: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], position: [{
                type: Input
            }], onConfigureWhiteboardClose: [{
                type: Input
            }] } });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Whiteboard component for drawing and manipulating shapes, text, and images on a canvas.
 *
 * @component
 * @selector app-whiteboard
 * @templateUrl ./whiteboard.component.html
 * @styleUrls ./whiteboard.component.css
 * @encapsulation ViewEncapsulation.None
 * @imports [CommonModule, FormsModule, FontAwesomeModule]
 *
 * @class Whiteboard
 * @implements OnInit, OnDestroy, OnChanges
 *
 * @property {number} customWidth - Custom width for the whiteboard.
 * @property {number} customHeight - Custom height for the whiteboard.
 * @property {WhiteboardParameters} parameters - Parameters for the whiteboard.
 * @property {boolean} showAspect - Flag to show aspect ratio.
 *
 * @property {ElementRef<HTMLCanvasElement>} canvasRef - Reference to the canvas element.
 * @property {ElementRef<HTMLTextAreaElement>} textInputRef - Reference to the text input element.
 * @property {ElementRef<HTMLButtonElement>} toggleBackgroundRef - Reference to the toggle background button element.
 * @property {ElementRef<HTMLAnchorElement>} downloadLinkRef - Reference to the download link element.
 * @property {ElementRef<HTMLCanvasElement>} tempCanvasRef - Reference to the temporary canvas element.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for times.
 * @property {IconDefinition} faUndo - FontAwesome icon for undo.
 * @property {IconDefinition} faRedo - FontAwesome icon for redo.
 * @property {IconDefinition} faEraser - FontAwesome icon for eraser.
 * @property {IconDefinition} faShapes - FontAwesome icon for shapes.
 * @property {IconDefinition} faMousePointer - FontAwesome icon for mouse pointer.
 * @property {IconDefinition} faHandPaper - FontAwesome icon for hand paper.
 * @property {IconDefinition} faTextHeight - FontAwesome icon for text height.
 * @property {IconDefinition} faFont - FontAwesome icon for font.
 * @property {IconDefinition} faPencilAlt - FontAwesome icon for pencil alt.
 * @property {IconDefinition} faPaintBrush - FontAwesome icon for paint brush.
 * @property {IconDefinition} faTrash - FontAwesome icon for trash.
 * @property {IconDefinition} faSave - FontAwesome icon for save.
 * @property {IconDefinition} faSearch - FontAwesome icon for search.
 * @property {IconDefinition} faSearchMinus - FontAwesome icon for search minus.
 * @property {IconDefinition} faSearchPlus - FontAwesome icon for search plus.
 * @property {IconDefinition} faChevronLeft - FontAwesome icon for chevron left.
 * @property {IconDefinition} faUpload - FontAwesome icon for upload.
 * @property {IconDefinition} faChevronRight - FontAwesome icon for chevron right.
 *
 * @property {string} mode - Current mode of the whiteboard (e.g., 'pan', 'draw', 'erase').
 * @property {boolean} isDrawing - Flag indicating if drawing is in progress.
 * @property {boolean} isPanning - Flag indicating if panning is in progress.
 * @property {boolean} isDragging - Flag indicating if dragging is in progress.
 * @property {number} startX - Starting X coordinate for drawing.
 * @property {number} startY - Starting Y coordinate for drawing.
 * @property {number} currentX - Current X coordinate for drawing.
 * @property {number} currentY - Current Y coordinate for drawing.
 * @property {any[]} freehandDrawing - Array of points for freehand drawing.
 * @property {any} selectedShape - Currently selected shape.
 * @property {any} selectedHandle - Currently selected handle for resizing shapes.
 * @property {boolean} movingShape - Flag indicating if a shape is being moved.
 * @property {number} panX - X coordinate for panning.
 * @property {number} panY - Y coordinate for panning.
 * @property {number} scale - Current scale of the canvas.
 * @property {number} minScale - Minimum scale of the canvas.
 * @property {number} maxScale - Maximum scale of the canvas.
 * @property {number} eraserThickness - Thickness of the eraser.
 * @property {number} brushThickness - Thickness of the brush.
 * @property {number} lineThickness - Thickness of the line.
 * @property {string} lineType - Type of the line (e.g., 'solid', 'dashed').
 * @property {string} color - Current color for drawing.
 * @property {string} font - Current font for text.
 * @property {number} fontSize - Current font size for text.
 * @property {any} shape - Current shape being drawn.
 * @property {HTMLImageElement} backgroundImage - Background image for the canvas.
 * @property {boolean} toolbarVisible - Flag indicating if the toolbar is visible.
 * @property {string | null} dropdownOpen - Currently open dropdown menu.
 * @property {{ clientX: number, clientY: number, offsetX: number, offsetY: number } | null} currentClickPosition - Current click position on the canvas.
 * @property {number} maxWidth - Maximum width of the canvas.
 * @property {number} maxHeight - Maximum height of the canvas.
 * @property {boolean} dimensionsFixed - Flag indicating if the canvas dimensions are fixed.
 *
 * @method updateLineThickness - Updates the thickness of the line.
 * @param {number} thickness - New thickness for the line.
 *
 * @method updateBrushThickness - Updates the thickness of the brush.
 * @param {number} thickness - New thickness for the brush.
 *
 * @method updateEraserThickness - Updates the thickness of the eraser.
 * @param {number} thickness - New thickness for the eraser.
 *
 * @method updateColor - Updates the color for drawing.
 * @param {string} color - New color for drawing.
 *
 * @method updateFont - Updates the font for text.
 * @param {string} font - New font for text.
 *
 * @method updateFontSize - Updates the font size for text.
 * @param {number} fontSize - New font size for text.
 *
 * @method updateShape - Updates the shape being drawn.
 * @param {string} shape - New shape to be drawn.
 *
 * @constructor
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 *
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property of a directive changes.
 * @param {SimpleChanges} changes - Object of changes.
 *
 * @method ngOnDestroy - Lifecycle hook that is called when a directive, pipe, or service is destroyed.
 *
 * @method ngAfterViewInit - Lifecycle hook that is called after a component's view has been fully initialized.
 *
 * @method handleTextInput - Handles the text input event.
 * @param {KeyboardEvent} event - Keyboard event.
 *
 * @method addListeners - Adds event listeners to the canvas and document.
 *
 * @method handleTouchStart - Handles the touch start event.
 * @param {TouchEvent} e - Touch event.
 *
 * @method handleTouchMove - Handles the touch move event.
 * @param {TouchEvent} e - Touch event.
 *
 * @method handleTouchEnd - Handles the touch end event.
 * @param {TouchEvent} e - Touch event.
 *
 * @method handleClickOutside - Handles the click outside event.
 * @param {MouseEvent} event - Mouse event.
 *
 * @method handleCanvasClick - Handles the canvas click event.
 * @param {MouseEvent} e - Mouse event.
 *
 * @method startDrawing - Starts the drawing process.
 * @param {MouseEvent} e - Mouse event.
 *
 * @method draw - Draws on the canvas.
 * @param {MouseEvent} e - Mouse event.
 *
 * @method stopDrawing - Stops the drawing process.
 * @param {MouseEvent} e - Mouse event.
 *
 * @method erase - Erases a part of the canvas.
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 *
 * @method isPointNearLine - Checks if a point is near a line.
 * @param {number} px - X coordinate of the point.
 * @param {number} py - Y coordinate of the point.
 * @param {number} x1 - X coordinate of the line start.
 * @param {number} y1 - Y coordinate of the line start.
 * @param {number} x2 - X coordinate of the line end.
 * @param {number} y2 - Y coordinate of the line end.
 * @param {number} threshold - Distance threshold.
 * @returns {boolean} - True if the point is near the line, false otherwise.
 *
 * @method zoomCanvas - Zooms the canvas.
 * @param {number} scaleFactor - Scale factor for zooming.
 * @param {MouseEvent} [event] - Mouse event.
 *
 * @method handleZoom - Handles the zoom event.
 * @param {WheelEvent} e - Wheel event.
 *
 * @method drawEdgeMarkers - Draws edge markers on the canvas.
 *
 * @method drawShapes - Draws all shapes on the canvas.
 *
 * @method drawLine - Draws a line on the canvas.
 * @param {number} x1 - X coordinate of the line start.
 * @param {number} y1 - Y coordinate of the line start.
 * @param {number} x2 - X coordinate of the line end.
 * @param {number} y2 - Y coordinate of the line end.
 * @param {string} color - Color of the line.
 * @param {number} thickness - Thickness of the line.
 * @param {string} lineType - Type of the line (e.g., 'solid', 'dashed').
 *
 * @method drawText - Draws text on the canvas.
 * @param {string} text - Text to be drawn.
 * @param {number} x - X coordinate of the text.
 * @param {number} y - Y coordinate of the text.
 * @param {string} color - Color of the text.
 * @param {string} font - Font of the text.
 *
 * @method drawFreehand - Draws freehand lines on the canvas.
 * @param {{ x: number, y: number }[]} points - Array of points for freehand drawing.
 * @param {string} color - Color of the freehand drawing.
 * @param {number} thickness - Thickness of the freehand drawing.
 *
 * @method drawShape - Draws a shape on the canvas.
 * @param {string} type - Type of the shape.
 * @param {number} x1 - X coordinate of the shape start.
 * @param {number} y1 - Y coordinate of the shape start.
 * @param {number} x2 - X coordinate of the shape end.
 * @param {number} y2 - Y coordinate of the shape end.
 * @param {string} color - Color of the shape.
 * @param {number} thickness - Thickness of the shape.
 * @param {string} lineType - Type of the line (e.g., 'solid', 'dashed').
 * @param {CanvasRenderingContext2D} [ctx] - Canvas rendering context.
 *
 * @method drawPolygon - Draws a polygon on the canvas.
 * @param {CanvasRenderingContext2D} ctx - Canvas rendering context.
 * @param {number} sides - Number of sides of the polygon.
 * @param {number} x1 - X coordinate of the polygon start.
 * @param {number} y1 - Y coordinate of the polygon start.
 * @param {number} x2 - X coordinate of the polygon end.
 * @param {number} y2 - Y coordinate of the polygon end.
 */
class Whiteboard {
    customWidth;
    customHeight;
    parameters = {};
    showAspect;
    canvasRef;
    textInputRef;
    toggleBackgroundRef;
    downloadLinkRef;
    tempCanvasRef;
    faTimes = faTimes;
    faUndo = faUndo;
    faRedo = faRedo;
    faEraser = faEraser;
    faShapes = faShapes;
    faMousePointer = faMousePointer;
    faHandPaper = faHandPaper;
    faTextHeight = faTextHeight;
    faFont = faFont;
    faPencilAlt = faPencilAlt;
    faPaintBrush = faPaintBrush;
    faTrash = faTrash;
    faSave = faSave;
    faSearch = faSearch;
    faSearchMinus = faSearchMinus;
    faSearchPlus = faSearchPlus;
    faChevronLeft = faChevronLeft;
    faUpload = faUpload;
    faChevronRight = faChevronRight;
    mode = 'pan';
    isDrawing = false;
    isPanning = false;
    isDragging = false;
    startX = 0;
    startY = 0;
    currentX = 0;
    currentY = 0;
    freehandDrawing = [];
    selectedShape = null;
    selectedHandle = null;
    movingShape = false;
    panX = 0;
    panY = 0;
    scale = 1;
    minScale = 0.25;
    maxScale = 1.75;
    eraserThickness = 10;
    brushThickness = 6;
    lineThickness = 6;
    lineType = 'solid';
    color = '#000000';
    font = 'Arial';
    fontSize = 20;
    shape = null;
    backgroundImage = new Image();
    toolbarVisible = true;
    dropdownOpen = null;
    currentClickPosition = null;
    maxWidth = 1280;
    maxHeight = 720;
    dimensionsFixed = false;
    isValidShape = false;
    updateLineThickness = (thickness) => {
        this.lineThickness = thickness;
    };
    updateBrushThickness = (thickness) => {
        this.brushThickness = thickness;
    };
    updateEraserThickness = (thickness) => {
        this.eraserThickness = thickness;
    };
    updateColor = (color) => {
        this.color = color;
    };
    updateFont = (font) => {
        this.font = font;
    };
    updateFontSize = (fontSize) => {
        this.fontSize = fontSize;
    };
    updateShape = (shape) => {
        this.shape = shape;
    };
    ngOnInit() {
        if (this.showAspect) {
            this.addListeners();
        }
    }
    ngOnChanges(changes) {
        if (changes['parameters'] && changes['parameters'].currentValue) {
            this.parameters = changes['parameters'].currentValue;
            if (this.parameters.socket) {
                this.parameters.socket.on('whiteboardUpdated', async (data) => {
                    this.WhiteboardUpdated(data);
                });
                this.parameters.socket.on('whiteboardAction', (data) => {
                    this.WhiteboardAction(data);
                });
            }
        }
        if (changes['showAspect']) {
            if (changes['showAspect'].currentValue) {
                this.addListeners();
            }
        }
    }
    ngOnDestroy() {
        const canvas = this.canvasRef.nativeElement;
        canvas.removeEventListener('mousedown', this.startDrawing.bind(this));
        canvas.removeEventListener('mousemove', this.draw.bind(this));
        canvas.removeEventListener('mouseup', this.stopDrawing.bind(this));
        canvas.removeEventListener('wheel', this.handleZoom.bind(this));
        canvas.removeEventListener('click', this.handleCanvasClick.bind(this));
        // touch events
        canvas.removeEventListener('touchstart', this.handleTouchStart.bind(this));
        canvas.removeEventListener('touchmove', this.handleTouchMove.bind(this));
        canvas.removeEventListener('touchend', this.handleTouchEnd.bind(this));
        document.removeEventListener('mousedown', this.handleClickOutside.bind(this));
    }
    ngAfterViewInit() {
        // Attach the event listener once after the view has been initialized
        const textInput = this.textInputRef.nativeElement;
        textInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                this.handleTextInput(event);
            }
        });
    }
    handleTextInput(event) {
        const textInput = this.textInputRef.nativeElement;
        if (event.key === 'Enter' && this.currentClickPosition) {
            const { offsetX, offsetY } = this.currentClickPosition;
            const text = textInput.value;
            textInput.style.display = 'none';
            textInput.value = '';
            const x = (offsetX - this.panX) / this.scale;
            const y = (offsetY - this.panY) / this.scale;
            this.parameters.shapes.push({
                type: 'text',
                text,
                x,
                y,
                color: this.color,
                font: this.font,
                fontSize: this.fontSize,
            });
            this.drawShapes();
            this.parameters.updateShapes(this.parameters.shapes);
            this.parameters.socket.emit('updateBoardAction', {
                action: 'text',
                payload: {
                    type: 'text',
                    text,
                    x,
                    y,
                    color: this.color,
                    font: this.font,
                    fontSize: this.fontSize,
                },
            }, this.handleServerResponse);
        }
    }
    addListeners = () => {
        if (this.parameters) {
            this.parameters = this.parameters.getUpdatedAllParams();
        }
        this.backgroundImage.src = 'https://mediasfu.com/images/svg/graph_paper.jpg';
        this.backgroundImage.crossOrigin = 'anonymous';
        this.backgroundImage.onload = () => {
            this.drawShapes();
        };
        const canvas = this.canvasRef.nativeElement;
        if (this.canvasRef.nativeElement) {
            try {
                if (this.parameters.targetResolution == 'qhd' ||
                    this.parameters.targetResolutionHost == 'qhd') {
                    this.maxWidth = 1920;
                    this.maxHeight = 1080;
                }
                else if (this.parameters.targetResolution == 'fhd' ||
                    this.parameters.targetResolutionHost == 'fhd') {
                    this.maxWidth = 1920;
                    this.maxHeight = 1080;
                }
                canvas.width = this.maxWidth;
                canvas.height = this.maxHeight;
                this.dimensionsFixed = true;
            }
            catch {
                /* handle error */
            }
            this.parameters.updateCanvasWhiteboard(this.canvasRef.nativeElement);
        }
        canvas.addEventListener('mousedown', this.startDrawing.bind(this));
        canvas.addEventListener('mousemove', this.draw.bind(this));
        canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
        canvas.addEventListener('wheel', this.handleZoom.bind(this));
        canvas.addEventListener('click', this.handleCanvasClick.bind(this));
        // touch events
        canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
        canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
        canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
        document.addEventListener('mousedown', this.handleClickOutside.bind(this));
    };
    handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY,
        });
        this.canvasRef.nativeElement.dispatchEvent(mouseEvent);
    }
    handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY,
        });
        this.canvasRef.nativeElement.dispatchEvent(mouseEvent);
    }
    handleTouchEnd(e) {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        this.canvasRef.nativeElement.dispatchEvent(mouseEvent);
    }
    handleClickOutside(event) {
        const target = event.target;
        if (this.dropdownOpen && !target.closest('.btn-group')) {
            this.dropdownOpen = null;
        }
    }
    handleCanvasClick(e) {
        if (this.mode === 'text') {
            const textInput = this.textInputRef.nativeElement;
            textInput.style.left = e.clientX + 'px';
            textInput.style.top = e.clientY + 'px';
            textInput.style.display = 'block';
            textInput.focus();
            this.currentClickPosition = {
                clientX: e.clientX,
                clientY: e.clientY,
                offsetX: e.offsetX,
                offsetY: e.offsetY,
            };
        }
    }
    startDrawing(e) {
        this.isDrawing = true;
        this.startX = (e.offsetX - this.panX) / this.scale;
        this.startY = (e.offsetY - this.panY) / this.scale;
        if (this.mode === 'erase') {
            this.erase(this.startX, this.startY);
        }
        else if (this.mode === 'draw' || this.mode === 'freehand') {
            const ctx = this.canvasRef.nativeElement.getContext('2d');
            ctx.beginPath();
            ctx.moveTo(this.startX, this.startY);
            if (this.mode === 'freehand') {
                this.freehandDrawing = [{ x: this.startX, y: this.startY }];
            }
        }
        else if (this.mode === 'pan') {
            this.isPanning = true;
            this.isDragging = false;
        }
        else if (this.mode === 'select') {
            this.selectedHandle = this.getHandleAtPosition(this.startX, this.startY);
            if (this.selectedHandle) {
                this.isDragging = true;
                this.movingShape = this.selectedHandle.isCenter;
            }
            else {
                this.selectedShape = this.findShape(this.startX, this.startY);
                if (this.selectedShape) {
                    this.drawShapes();
                    this.drawSelection(this.selectedShape);
                }
            }
        }
    }
    draw = (e) => {
        if (!this.dimensionsFixed) {
            try {
                if (this.parameters.targetResolution == 'qhd' ||
                    this.parameters.targetResolutionHost == 'qhd') {
                    this.maxWidth = 1920;
                    this.maxHeight = 1080;
                }
                else if (this.parameters.targetResolution == 'fhd' ||
                    this.parameters.targetResolutionHost == 'fhd') {
                    this.maxWidth = 1920;
                    this.maxHeight = 1080;
                }
                this.canvasRef.nativeElement.width = this.maxWidth;
                this.canvasRef.nativeElement.height = this.maxHeight;
                this.dimensionsFixed = true;
                this.parameters.updateCanvasWhiteboard(this.canvasRef.nativeElement);
            }
            catch {
                /* handle error */
            }
        }
        if (!this.isDrawing)
            return;
        this.currentX = (e.offsetX - this.panX) / this.scale;
        this.currentY = (e.offsetY - this.panY) / this.scale;
        if (this.mode == 'draw' || this.mode == 'freehand' || this.mode == 'shape') {
            //if more than max width or height or less than 0, return
            if (this.currentX > this.maxWidth ||
                this.currentY > this.maxHeight ||
                this.currentX < 0 ||
                this.currentY < 0) {
                this.isValidShape = false;
                return;
            }
            else {
                this.isValidShape = true;
            }
        }
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        if (this.mode === 'erase') {
            this.erase(this.currentX, this.currentY);
        }
        else if (this.mode === 'draw') {
            ctx.clearRect(0, 0, this.canvasRef.nativeElement.width, this.canvasRef.nativeElement.height);
            this.drawShapes();
            this.drawLine(this.startX, this.startY, this.currentX, this.currentY, this.color, this.lineThickness, this.lineType);
        }
        else if (this.mode === 'freehand') {
            ctx.lineTo(this.currentX, this.currentY);
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.brushThickness;
            ctx.stroke();
            this.freehandDrawing.push({ x: this.currentX, y: this.currentY });
        }
        else if (this.mode === 'shape') {
            ctx.clearRect(0, 0, this.canvasRef.nativeElement.width, this.canvasRef.nativeElement.height);
            this.drawShapes();
            this.drawShape(this.shape, this.startX, this.startY, this.currentX, this.currentY, this.color, this.lineThickness, this.lineType);
        }
        else if (this.mode === 'pan' && this.isPanning) {
            this.isDragging = true;
            const dx = e.clientX - this.startX;
            const dy = e.clientY - this.startY;
            this.panX += dx;
            this.panY += dy;
            this.startX = e.clientX;
            this.startY = e.clientY;
            ctx.setTransform(this.scale, 0, 0, this.scale, this.panX, this.panY);
            this.drawShapes();
        }
        else if (this.mode === 'select' && this.selectedShape) {
            ctx.clearRect(0, 0, this.canvasRef.nativeElement.width, this.canvasRef.nativeElement.height);
            if (this.movingShape) {
                const dx = this.currentX - this.startX;
                const dy = this.currentY - this.startY;
                this.moveShape(this.selectedShape, dx, dy);
                this.startX = this.currentX;
                this.startY = this.currentY;
            }
            else if (this.isDragging) {
                this.resizeShape(this.selectedShape, this.selectedHandle, this.currentX, this.currentY);
            }
            this.drawShapes();
            this.drawSelection(this.selectedShape);
        }
    };
    stopDrawing() {
        this.isDrawing = false;
        this.isPanning = false;
        this.isDragging = false;
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        ctx.closePath();
        if (this.mode === 'draw' && this.isValidShape) {
            this.parameters.shapes.push({
                type: 'line',
                x1: this.startX,
                y1: this.startY,
                x2: this.currentX,
                y2: this.currentY,
                color: this.color,
                thickness: this.lineThickness,
                lineType: this.lineType,
            });
            this.parameters.updateShapes(this.parameters.shapes);
            this.saveState();
            this.parameters.socket.emit('updateBoardAction', {
                action: 'draw',
                payload: {
                    type: 'line',
                    x1: this.startX,
                    y1: this.startY,
                    x2: this.currentX,
                    y2: this.currentY,
                    color: this.color,
                    thickness: this.lineThickness,
                    lineType: this.lineType,
                },
            }, this.handleServerResponse);
        }
        else if (this.mode === 'freehand' && this.isValidShape) {
            this.parameters.shapes.push({
                type: 'freehand',
                points: this.freehandDrawing,
                color: this.color,
                thickness: this.brushThickness,
            });
            this.parameters.updateShapes(this.parameters.shapes);
            this.parameters.socket.emit('updateBoardAction', {
                action: 'draw',
                payload: {
                    type: 'freehand',
                    points: this.freehandDrawing,
                    color: this.color,
                    thickness: this.brushThickness,
                },
            }, this.handleServerResponse);
            this.freehandDrawing = [];
            this.saveState();
        }
        else if (this.mode === 'shape' && this.isValidShape) {
            this.parameters.shapes.push({
                type: this.shape,
                x1: this.startX,
                y1: this.startY,
                x2: this.currentX,
                y2: this.currentY,
                color: this.color,
                thickness: this.lineThickness,
                lineType: this.lineType,
            });
            this.parameters.updateShapes(this.parameters.shapes);
            this.saveState();
            this.parameters.socket.emit('updateBoardAction', {
                action: 'shape',
                payload: {
                    type: this.shape,
                    x1: this.startX,
                    y1: this.startY,
                    x2: this.currentX,
                    y2: this.currentY,
                    color: this.color,
                    thickness: this.lineThickness,
                    lineType: this.lineType,
                },
            }, this.handleServerResponse);
        }
        else if (this.mode === 'select') {
            if (this.selectedShape && !this.movingShape && !this.isDragging) {
                const shapeFound = this.findShape(this.currentX, this.currentY);
                if (shapeFound) {
                    this.selectedShape = shapeFound;
                    this.drawShapes();
                    this.drawSelection(shapeFound);
                }
            }
            if (this.selectedShape) {
                this.parameters.socket.emit('updateBoardAction', { action: 'shapes', payload: { shapes: this.parameters.shapes } }, this.handleServerResponse);
            }
            this.saveState();
        }
    }
    erase(x, y) {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(x, y, this.eraserThickness / 2, 0, Math.PI * 2, false);
        ctx.fill();
        ctx.restore();
        let changeOccurred = false;
        this.parameters.shapes = this.parameters.shapes
            .map((shape) => {
            if (shape.type === 'freehand') {
                return {
                    ...shape,
                    points: shape.points.filter((point) => {
                        const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                        if (distance <= this.eraserThickness / 2) {
                            changeOccurred = true;
                            return false;
                        }
                        return distance > this.eraserThickness / 2;
                    }),
                };
            }
            else if (shape.type === 'line') {
                if (this.isPointNearLine(x, y, shape.x1, shape.y1, shape.x2, shape.y2, this.eraserThickness / 2)) {
                    changeOccurred = true;
                    return null;
                }
            }
            else if (shape.type === 'text') {
                const textWidth = ctx.measureText(shape.text).width;
                if (x > shape.x &&
                    x < shape.x + textWidth &&
                    y > shape.y - shape.fontSize &&
                    y < shape.y) {
                    changeOccurred = true;
                    return null;
                }
            }
            else if (shape.type === 'image') {
                if (x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2) {
                    changeOccurred = true;
                    return null;
                }
            }
            else {
                if (x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2) {
                    changeOccurred = true;
                    return null;
                }
            }
            return shape;
        })
            .filter((shape) => shape && (shape.type !== 'freehand' || shape.points.length > 0));
        this.parameters.updateShapes(this.parameters.shapes);
        this.drawShapes();
        if (changeOccurred) {
            this.parameters.socket.emit('updateBoardAction', { action: 'shapes', payload: { shapes: this.parameters.shapes } }, this.handleServerResponse);
        }
    }
    isPointNearLine(px, py, x1, y1, x2, y2, threshold) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        const dot = ((px - x1) * dx + (py - y1) * dy) / (length * length);
        const closestX = x1 + dot * dx;
        const closestY = y1 + dot * dy;
        const distance = Math.sqrt(Math.pow(px - closestX, 2) + Math.pow(py - closestY, 2));
        return distance <= threshold;
    }
    zoomCanvas(scaleFactor, event = {
        clientX: this.canvasRef.nativeElement.width / 2,
        clientY: this.canvasRef.nativeElement.height / 2,
    }) {
        const canvas = this.canvasRef.nativeElement;
        const ctx = canvas.getContext('2d');
        if (scaleFactor === 10) {
            this.scale = 1;
            this.panX = 0;
            this.panY = 0;
        }
        else {
            let newScale = this.scale * scaleFactor;
            if (newScale < this.minScale) {
                newScale = this.minScale;
            }
            else if (newScale > this.maxScale) {
                newScale = this.maxScale;
            }
            const rect = canvas.getBoundingClientRect();
            const offsetX = (event.clientX - rect.left) / rect.width;
            const offsetY = (event.clientY - rect.top) / rect.height;
            const dx = offsetX * canvas.width * (1 - scaleFactor);
            const dy = offsetY * canvas.height * (1 - scaleFactor);
            this.scale = newScale;
            this.panX = this.panX * scaleFactor + dx;
            this.panY = this.panY * scaleFactor + dy;
            const maxPanX = (canvas.width * (this.scale - 1)) / this.scale;
            const maxPanY = (canvas.height * (this.scale - 1)) / this.scale;
            this.panX = Math.min(Math.max(this.panX, -maxPanX), 0);
            this.panY = Math.min(Math.max(this.panY, -maxPanY), 0);
        }
        ctx.setTransform(this.scale, 0, 0, this.scale, this.panX, this.panY);
        this.drawShapes();
    }
    handleZoom(e) {
        e.preventDefault();
        if (e.deltaY < 0) {
            this.zoomCanvas(1.2, e);
        }
        else {
            this.zoomCanvas(0.8, e);
        }
    }
    drawEdgeMarkers() {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 5;
        ctx.setLineDash([]); // reset line dash
        const markerLength = 20;
        const topLeftX = this.panX;
        const topLeftY = this.panY;
        const bottomRightX = this.panX + 1280 * this.scale;
        const bottomRightY = this.panY + 720 * this.scale;
        ctx.beginPath();
        ctx.moveTo(topLeftX, topLeftY + markerLength);
        ctx.lineTo(topLeftX, topLeftY);
        ctx.lineTo(topLeftX + markerLength, topLeftY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(bottomRightX - markerLength, topLeftY);
        ctx.lineTo(bottomRightX, topLeftY);
        ctx.lineTo(bottomRightX, topLeftY + markerLength);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(bottomRightX, bottomRightY - markerLength);
        ctx.lineTo(bottomRightX, bottomRightY);
        ctx.lineTo(bottomRightX - markerLength, bottomRightY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(topLeftX + markerLength, bottomRightY);
        ctx.lineTo(topLeftX, bottomRightY);
        ctx.lineTo(topLeftX, bottomRightY - markerLength);
        ctx.stroke();
        ctx.restore();
    }
    drawShapes() {
        const canvas = this.canvasRef.nativeElement;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.setTransform(this.scale, 0, 0, this.scale, this.panX, this.panY);
        if (this.parameters.useImageBackground) {
            ctx.drawImage(this.backgroundImage, -this.panX / this.scale, -this.panY / this.scale, canvas.width / this.scale, canvas.height / this.scale);
        }
        else {
            ctx.fillStyle = '#fff';
            ctx.fillRect(-this.panX / this.scale, -this.panY / this.scale, canvas.width / this.scale, canvas.height / this.scale);
        }
        this.parameters.shapes.forEach((shape) => {
            if (shape.type === 'line') {
                this.drawLine(shape.x1, shape.y1, shape.x2, shape.y2, shape.color, shape.thickness, shape.lineType);
            }
            else if (shape.type === 'freehand') {
                this.drawFreehand(shape.points, shape.color, shape.thickness);
            }
            else if (shape.type === 'text') {
                ctx.font = `${shape.fontSize}px ${shape.font}`;
                ctx.fillStyle = shape.color;
                ctx.fillText(shape.text, shape.x, shape.y);
            }
            else if (shape.type === 'image') {
                ctx.drawImage(shape.img, shape.x1, shape.y1, shape.x2 - shape.x1, shape.y2 - shape.y1);
            }
            else {
                this.drawShape(shape.type, shape.x1, shape.y1, shape.x2, shape.y2, shape.color, shape.thickness, shape.lineType);
            }
        });
        ctx.restore();
        this.drawEdgeMarkers();
    }
    drawLine(x1, y1, x2, y2, color, thickness, lineType) {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        if (lineType === 'dashed') {
            ctx.setLineDash([10, 10]);
        }
        else if (lineType === 'dotted') {
            ctx.setLineDash([2, 10]);
        }
        else if (lineType === 'dashDot') {
            ctx.setLineDash([10, 5, 2, 5]);
        }
        else {
            ctx.setLineDash([]);
        }
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    drawText(text, x, y, color, font) {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        ctx.font = `20px ${font}`;
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
    }
    drawFreehand(points, color, thickness) {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        if (points.length < 2)
            return;
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
    }
    drawShape(type, x1, y1, x2, y2, color, thickness, lineType, ctx = this.canvasRef.nativeElement.getContext('2d')) {
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        if (lineType === 'dashed') {
            ctx.setLineDash([10, 10]);
        }
        else if (lineType === 'dotted') {
            ctx.setLineDash([2, 10]);
        }
        else if (lineType === 'dashDot') {
            ctx.setLineDash([10, 5, 2, 5]);
        }
        else {
            ctx.setLineDash([]);
        }
        if (type === 'rectangle') {
            ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
        }
        else if (type === 'circle') {
            const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            ctx.arc(x1, y1, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }
        else if (type === 'rhombus') {
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            ctx.moveTo(centerX, y1);
            ctx.lineTo(x2, centerY);
            ctx.lineTo(centerX, y2);
            ctx.lineTo(x1, centerY);
            ctx.closePath();
            ctx.stroke();
        }
        else if (type === 'pentagon') {
            this.drawPolygon(ctx, 5, x1, y1, x2, y2);
        }
        else if (type === 'hexagon') {
            this.drawPolygon(ctx, 6, x1, y1, x2, y2);
        }
        else if (type === 'triangle') {
            const centerX = (x1 + x2) / 2;
            ctx.moveTo(centerX, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x1, y2);
            ctx.closePath();
            ctx.stroke();
        }
        else if (type === 'square') {
            ctx.strokeRect(x1, y1, x2 - x1, x2 - x1);
        }
        else if (type === 'octagon') {
            this.drawPolygon(ctx, 8, x1, y1, x2, y2);
        }
        else if (type === 'oval') {
            const radiusX = Math.abs(x2 - x1) / 2;
            const radiusY = Math.abs(y2 - y1) / 2;
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            ctx.stroke();
        }
        else if (type === 'parallelogram') {
            const centerX = (x1 + x2) / 2;
            ctx.moveTo(centerX, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(centerX, y2);
            ctx.lineTo(x1, y1);
            ctx.closePath();
            ctx.stroke();
        }
        else if (type === 'image') {
            ctx.drawImage(this.shape.img, x1, y1, x2 - x1, y2 - y1);
        }
    }
    drawPolygon(ctx, sides, x1, y1, x2, y2) {
        const centerX = (x1 + x2) / 2;
        const centerY = (y1 + y2) / 2;
        const radius = Math.min(Math.abs(x2 - x1), Math.abs(y2 - y1)) / 2;
        const angle = (2 * Math.PI) / sides;
        ctx.beginPath();
        for (let i = 0; i < sides; i++) {
            const x = centerX + radius * Math.cos(i * angle - Math.PI / 2);
            const y = centerY + radius * Math.sin(i * angle - Math.PI / 2);
            if (i === 0) {
                ctx.moveTo(x, y);
            }
            else {
                ctx.lineTo(x, y);
            }
        }
        ctx.closePath();
        ctx.stroke();
    }
    undo() {
        if (this.parameters.shapes.length > 0) {
            this.parameters.redoStack.push(this.parameters.shapes.pop());
            this.parameters.updateRedoStack(this.parameters.redoStack);
            this.drawShapes();
            this.parameters.socket.emit('updateBoardAction', { action: 'undo' }, this.handleServerResponse);
        }
    }
    redo() {
        if (this.parameters.redoStack.length > 0) {
            this.parameters.shapes.push(this.parameters.redoStack.pop());
            this.parameters.updateShapes(this.parameters.shapes);
            this.drawShapes();
            this.parameters.socket.emit('updateBoardAction', { action: 'redo' }, this.handleServerResponse);
        }
    }
    saveState() {
        this.parameters.undoStack.push(JSON.stringify(this.parameters.shapes));
        this.parameters.updateUndoStack(this.parameters.undoStack);
    }
    findShape(x, y) {
        return this.parameters.shapes.find((shape) => {
            if (shape.type === 'freehand') {
                return shape.points.some((point) => {
                    const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                    return distance < shape.thickness;
                });
            }
            else if (shape.type === 'text') {
                const ctx = this.canvasRef.nativeElement.getContext('2d');
                ctx.font = `${shape.fontSize}px ${shape.font}`;
                const textMetrics = ctx.measureText(shape.text);
                return (x > shape.x &&
                    x < shape.x + textMetrics.width &&
                    y > shape.y - shape.fontSize &&
                    y < shape.y);
            }
            else if (shape.type === 'image') {
                return x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2;
            }
            else {
                return x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2;
            }
        });
    }
    drawSelection(shape) {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        if (!shape)
            return;
        const handles = this.getResizeHandles(shape);
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 3]);
        if (shape.type === 'line') {
            ctx.beginPath();
            ctx.moveTo(shape.x1, shape.y1);
            ctx.lineTo(shape.x2, shape.y2);
            ctx.stroke();
        }
        else if (shape.type === 'circle') {
            const radius = Math.sqrt(Math.pow(shape.x2 - shape.x1, 2) + Math.pow(shape.y2 - shape.y1, 2));
            ctx.beginPath();
            ctx.arc(shape.x1, shape.y1, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }
        else {
            ctx.strokeRect(shape.x1, shape.y1, shape.x2 - shape.x1, shape.y2 - shape.y1);
        }
        ctx.setLineDash([]);
        handles.forEach((handle) => {
            ctx.fillStyle = handle.isCenter ? 'blue' : 'red';
            ctx.fillRect(handle.x - 6, handle.y - 6, 12, 12);
        });
    }
    getResizeHandles(shape) {
        const handles = [];
        if (shape.type === 'line') {
            handles.push({ x: shape.x1, y: shape.y1 });
            handles.push({ x: shape.x2, y: shape.y2 });
        }
        else if (shape.type === 'circle') {
            const radius = Math.sqrt(Math.pow(shape.x2 - shape.x1, 2) + Math.pow(shape.y2 - shape.y1, 2));
            handles.push({ x: shape.x1 + radius, y: shape.y1 });
            handles.push({ x: shape.x1 - radius, y: shape.y1 });
            handles.push({ x: shape.x1, y: shape.y1 + radius });
            handles.push({ x: shape.x1, y: shape.y1 - radius });
            handles.push({ x: shape.x1, y: shape.y1, isCenter: true });
        }
        else if (shape.type === 'text') {
            const ctx = this.canvasRef.nativeElement.getContext('2d');
            const textMetrics = ctx.measureText(shape.text);
            handles.push({ x: shape.x, y: shape.y - shape.fontSize, isCenter: true });
            handles.push({ x: shape.x + textMetrics.width, y: shape.y, isCenter: false });
        }
        else if (shape.type === 'image') {
            handles.push({ x: shape.x1, y: shape.y1 });
            handles.push({ x: shape.x2, y: shape.y1 });
            handles.push({ x: shape.x2, y: shape.y2 });
            handles.push({ x: shape.x1, y: shape.y2 });
            handles.push({ x: (shape.x1 + shape.x2) / 2, y: (shape.y1 + shape.y2) / 2, isCenter: true });
        }
        else {
            handles.push({ x: shape.x1, y: shape.y1 });
            handles.push({ x: shape.x2, y: shape.y1 });
            handles.push({ x: shape.x2, y: shape.y2 });
            handles.push({ x: shape.x1, y: shape.y2 });
            handles.push({ x: (shape.x1 + shape.x2) / 2, y: (shape.y1 + shape.y2) / 2, isCenter: true });
        }
        return handles.map((handle) => ({
            ...handle,
            isCenter: handle.isCenter || false,
        }));
    }
    getHandleAtPosition(x, y) {
        if (!this.selectedShape)
            return null;
        return this.getResizeHandles(this.selectedShape).find((handle) => {
            return Math.abs(handle.x - x) < 6 && Math.abs(handle.y - y) < 6;
        });
    }
    resizeShape(shape, handle, x, y) {
        if (shape.type === 'line') {
            if (handle.x === shape.x1 && handle.y === shape.y1) {
                shape.x1 = x;
                shape.y1 = y;
            }
            else {
                shape.x2 = x;
                shape.y2 = y;
            }
        }
        else if (shape.type === 'circle') {
            const dx = x - shape.x1;
            const dy = y - shape.y1;
            const radius = Math.sqrt(dx * dx + dy * dy);
            shape.x2 = shape.x1 + radius;
            shape.y2 = shape.y1;
        }
        else if (shape.type === 'text') {
            if (handle.isCenter) {
                shape.x = x;
                shape.y = y;
            }
            else {
                const textMetrics = this.canvasRef.nativeElement.getContext('2d').measureText(shape.text);
                shape.x = x - textMetrics.width;
                shape.y = y;
            }
        }
        else if (shape.type === 'image') {
            if (handle.isCenter) {
                const dx = x - (shape.x1 + shape.x2) / 2;
                const dy = y - (shape.y1 + shape.y2) / 2;
                this.moveShape(shape, dx, dy);
            }
            else {
                if (handle.x === shape.x1 && handle.y === shape.y1) {
                    shape.x1 = x;
                    shape.y1 = y;
                }
                else if (handle.x === shape.x2 && handle.y === shape.y1) {
                    shape.x2 = x;
                    shape.y1 = y;
                }
                else if (handle.x === shape.x2 && handle.y === shape.y2) {
                    shape.x2 = x;
                    shape.y2 = y;
                }
                else {
                    shape.x1 = x;
                    shape.y2 = y;
                }
            }
        }
        else {
            if (handle.isCenter) {
                const dx = x - (shape.x1 + shape.x2) / 2;
                const dy = y - (shape.y1 + shape.y2) / 2;
                this.moveShape(shape, dx, dy);
            }
            else {
                if (handle.x === shape.x1 && handle.y === shape.y1) {
                    shape.x1 = x;
                    shape.y1 = y;
                }
                else if (handle.x === shape.x2 && handle.y === shape.y1) {
                    shape.x2 = x;
                    shape.y1 = y;
                }
                else if (handle.x === shape.x2 && handle.y === shape.y2) {
                    shape.x2 = x;
                    shape.y2 = y;
                }
                else {
                    shape.x1 = x;
                    shape.y2 = y;
                }
            }
        }
        this.drawShapes();
    }
    moveShape(shape, dx, dy) {
        if (shape.type === 'line' || shape.type === 'circle') {
            shape.x1 += dx;
            shape.y1 += dy;
            shape.x2 += dx;
            shape.y2 += dy;
        }
        else if (shape.type === 'freehand') {
            shape.points.forEach((point) => {
                point.x += dx;
                point.y += dy;
            });
        }
        else if (shape.type === 'text') {
            shape.x += dx;
            shape.y += dy;
        }
        else if (shape.type === 'image') {
            shape.x1 += dx;
            shape.y1 += dy;
            shape.x2 += dx;
            shape.y2 += dy;
        }
        else {
            shape.x1 += dx;
            shape.y1 += dy;
            shape.x2 += dx;
            shape.y2 += dy;
        }
    }
    downloadCanvas(tempCanvas) {
        const link = this.downloadLinkRef.nativeElement;
        link.href = tempCanvas.toDataURL();
        link.download = 'whiteboard.png';
        link.click();
    }
    saveCanvas() {
        const tempCanvas = this.tempCanvasRef.nativeElement;
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = this.canvasRef.nativeElement.width;
        tempCanvas.height = this.canvasRef.nativeElement.height;
        const notShapes = ['freehand', 'text', 'image', 'line'];
        if (this.parameters.useImageBackground) {
            const backgroundImage = new Image();
            backgroundImage.crossOrigin = 'anonymous';
            backgroundImage.onload = () => {
                tempCtx.drawImage(backgroundImage, 0, 0, tempCanvas.width, tempCanvas.height);
                this.parameters.shapes.forEach((shape) => {
                    !notShapes.includes(shape.type)
                        ? this.drawShape(shape.type, shape.x1, shape.y1, shape.x2, shape.y2, shape.color, shape.thickness, shape.lineType, tempCtx)
                        : this.drawShapeOnCanvas(shape, tempCtx);
                });
                this.downloadCanvas(tempCanvas);
            };
            backgroundImage.src = 'https://mediasfu.com/images/svg/graph_paper.jpg';
        }
        else {
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            this.parameters.shapes.forEach((shape) => {
                !notShapes.includes(shape.type)
                    ? this.drawShape(shape.type, shape.x1, shape.y1, shape.x2, shape.y2, shape.color, shape.thickness, shape.lineType, tempCtx)
                    : this.drawShapeOnCanvas(shape, tempCtx);
            });
            this.downloadCanvas(tempCanvas);
        }
    }
    drawShapeOnCanvas(shape, ctx = this.canvasRef.nativeElement.getContext('2d')) {
        ctx.beginPath();
        ctx.strokeStyle = shape.color;
        ctx.lineWidth = shape.thickness || 2;
        ctx.fillStyle = shape.color;
        ctx.font = `${shape.fontSize}px ${shape.fontFamily}`;
        const lineType = shape.lineType ? shape.lineType : 'solid';
        if (lineType === 'dashed') {
            ctx.setLineDash([10, 10]);
        }
        else if (lineType === 'dotted') {
            ctx.setLineDash([2, 10]);
        }
        else if (lineType === 'dashDot') {
            ctx.setLineDash([10, 5, 2, 5]);
        }
        else {
            ctx.setLineDash([]);
        }
        switch (shape.type) {
            case 'line':
                ctx.moveTo(shape.x1, shape.y1);
                ctx.lineTo(shape.x2, shape.y2);
                break;
            case 'freehand':
                try {
                    ctx.moveTo(shape.points[0].x, shape.points[0].y);
                    shape.points.forEach((point) => ctx.lineTo(point.x, point.y));
                }
                catch {
                    //console.log('Error drawing freehand shape');
                }
                break;
            case 'text':
                ctx.fillText(shape.text, shape.x, shape.y);
                break;
            case 'image':
                ctx.drawImage(shape.img, shape.x1, shape.y1, shape.x2 - shape.x1, shape.y2 - shape.y1);
                break;
            default:
                break;
        }
        ctx.stroke();
    }
    deleteShape(doEmits = true) {
        if (!this.checkBoardAccess())
            return;
        if (!this.selectedShape)
            return;
        if (this.selectedShape) {
            this.parameters.shapes = this.parameters.shapes.filter((shape) => shape !== this.selectedShape);
            this.parameters.updateShapes(this.parameters.shapes);
            this.selectedShape = null;
            if (doEmits) {
                this.parameters.socket.emit('updateBoardAction', { action: 'shapes', payload: { shapes: this.parameters.shapes } }, this.handleServerResponse);
            }
            this.drawShapes();
        }
    }
    toggleBackground = (doEmits = true) => {
        if (doEmits && !this.checkBoardAccess())
            return;
        this.parameters.useImageBackground = !this.parameters.useImageBackground;
        this.parameters.updateUseImageBackground(this.parameters.useImageBackground);
        const toggleButton = this.toggleBackgroundRef.nativeElement;
        if (this.parameters.useImageBackground) {
            this.canvasRef.nativeElement.style.backgroundImage = `url('https://mediasfu.com/images/svg/graph_paper.jpg')`;
            toggleButton.classList.remove('active');
        }
        else {
            this.canvasRef.nativeElement.style.backgroundImage = 'none';
            this.canvasRef.nativeElement.style.backgroundColor = 'white';
            toggleButton.classList.add('active');
        }
        this.drawShapes();
        if (doEmits) {
            this.parameters.socket.emit('updateBoardAction', { action: 'toggleBackground', payload: this.parameters.useImageBackground }, this.handleServerResponse);
        }
    };
    clearCanvas = (doEmits = true) => {
        if (this.parameters.islevel != '2' && doEmits) {
            this.parameters.showAlert?.({
                message: 'You do not have permission to clear the board',
                type: 'danger',
            });
            return;
        }
        if (this.parameters.shapes.length === 0)
            return;
        this.parameters.shapes = [];
        this.parameters.updateShapes([]);
        this.drawShapes();
        if (doEmits) {
            this.parameters.socket.emit('updateBoardAction', { action: 'clear' }, this.handleServerResponse);
        }
    };
    uploadImage = (event, doEmits = true) => {
        try {
            if (!this.checkBoardAccess())
                return;
            const file = event.target.files[0];
            if (file.size > 1024 * 1024) {
                this.parameters.showAlert?.({ message: 'File size must be less than 1MB', type: 'danger' });
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    if (img.height > 600 && img.height > img.width && !file.type.includes('jpeg')) {
                        this.parameters.showAlert?.({
                            message: 'For better performance, please upload the image in JPG format.',
                            type: 'danger',
                        });
                        return;
                    }
                    let imageWidth = 350;
                    const aspectRatio = img.height / img.width;
                    let imageHeight = imageWidth * aspectRatio;
                    const maxHeight = 600;
                    if (imageHeight > maxHeight) {
                        imageHeight = maxHeight;
                        imageWidth = imageHeight / aspectRatio;
                        if (imageWidth > 600) {
                            imageWidth = 600;
                        }
                    }
                    const imageShape = {
                        type: 'image',
                        img: img,
                        src: event.target.result,
                        x1: 50,
                        y1: 50,
                        x2: 50 + imageWidth,
                        y2: 50 + imageHeight,
                    };
                    this.parameters.shapes.push(imageShape);
                    this.parameters.updateShapes(this.parameters.shapes);
                    this.drawShapes();
                    if (doEmits) {
                        this.parameters.socket.emit('updateBoardAction', { action: 'uploadImage', payload: imageShape }, this.handleServerResponse);
                    }
                };
                img.onerror = () => {
                    this.parameters.showAlert?.({ message: 'Error loading image', type: 'danger' });
                };
                img.src = event.target.result;
            };
            reader.onerror = () => {
                this.parameters.showAlert?.({ message: 'Error reading file', type: 'danger' });
            };
            reader.readAsDataURL(file);
        }
        catch (error) {
            //console.log(error);
        }
    };
    handleServerResponse = (response) => {
        if (!response.success) {
            this.parameters.showAlert?.({
                message: `Whiteboard action failed: ${response.reason}`,
                type: 'danger',
            });
        }
    };
    WhiteboardAction = (data) => {
        const { action, payload } = data;
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        if (!ctx)
            return;
        this.parameters.updateCanvasWhiteboard(this.canvasRef.nativeElement);
        switch (action) {
            case 'draw':
                if (payload.type === 'freehand') {
                    this.drawFreehand(payload.points, payload.color, payload.thickness);
                    this.parameters.shapes.push({
                        type: 'freehand',
                        points: payload.points,
                        color: payload.color,
                        thickness: payload.thickness,
                    });
                    this.parameters.updateShapes(this.parameters.shapes);
                }
                else {
                    this.drawLine(payload.x1, payload.y1, payload.x2, payload.y2, payload.color, payload.thickness, payload.lineType);
                    this.parameters.shapes.push({
                        type: 'line',
                        x1: payload.x1,
                        y1: payload.y1,
                        x2: payload.x2,
                        y2: payload.y2,
                        color: payload.color,
                        thickness: payload.thickness,
                        lineType: payload.lineType,
                    });
                    this.parameters.updateShapes(this.parameters.shapes);
                }
                break;
            case 'shape':
                this.drawShape(payload.type, payload.x1, payload.y1, payload.x2, payload.y2, payload.color, payload.thickness, payload.lineType);
                this.parameters.shapes.push({
                    type: payload.type,
                    x1: payload.x1,
                    y1: payload.y1,
                    x2: payload.x2,
                    y2: payload.y2,
                    color: payload.color,
                    thickness: payload.thickness,
                    lineType: payload.lineType,
                });
                this.parameters.updateShapes(this.parameters.shapes);
                break;
            case 'erase':
                this.erase(payload.x, payload.y);
                break;
            case 'clear':
                this.clearCanvas(false);
                break;
            case 'uploadImage': {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const imageShape = {
                        type: 'image',
                        img,
                        src: payload.src,
                        x1: payload.x1,
                        y1: payload.y1,
                        x2: payload.x2,
                        y2: payload.y2,
                    };
                    this.parameters.shapes.push(imageShape);
                    this.parameters.updateShapes(this.parameters.shapes);
                    this.drawShapes();
                };
                img.src = payload.src;
                break;
            }
            case 'toggleBackground':
                this.toggleBackground(false);
                this.drawShapes();
                break;
            case 'undo':
                if (this.parameters.shapes.length > 0) {
                    this.parameters.redoStack.push(this.parameters.shapes.pop());
                    this.parameters.updateRedoStack(this.parameters.redoStack);
                    this.drawShapes();
                }
                break;
            case 'redo':
                if (this.parameters.redoStack.length > 0) {
                    this.parameters.shapes.push(this.parameters.redoStack.pop());
                    this.parameters.updateShapes(this.parameters.shapes);
                    this.drawShapes();
                }
                break;
            case 'text':
                this.parameters.shapes.push({
                    type: 'text',
                    text: payload.text,
                    x: payload.x,
                    y: payload.y,
                    color: payload.color,
                    font: payload.font,
                    fontSize: payload.fontSize,
                });
                this.parameters.updateShapes(this.parameters.shapes);
                this.drawShapes();
                break;
            case 'deleteShape':
                this.parameters.shapes = this.parameters.shapes.filter((shape) => shape !== payload);
                this.parameters.updateShapes(this.parameters.shapes);
                this.drawShapes();
                break;
            case 'shapes': {
                const oldShapes = this.parameters.shapes.filter((shape) => shape.type === 'image');
                this.parameters.shapes = payload.shapes.map((shape) => {
                    if (shape.type === 'image') {
                        const oldShape = oldShapes.find((oldShape) => oldShape.src === shape.src);
                        if (oldShape) {
                            return { ...shape, img: oldShape.img };
                        }
                        else {
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.src = shape.src;
                            return { ...shape, img };
                        }
                    }
                    else {
                        return shape;
                    }
                });
                this.parameters.updateShapes(this.parameters.shapes);
                this.drawShapes();
                break;
            }
            default:
                break;
        }
    };
    WhiteboardUpdated = (data) => {
        // data = { whiteboardUsers, status}
        // status = 'started', 'ended', 'updated'
        // whiteboardUsers array
        // members (participants) array only sent to the host
        //whiteboardData = {shapes=[], useImageBackground=Boolean, redoStack=[], undoStack=[]} or {} or null
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        if (!ctx)
            return;
        if (this.parameters.islevel == '2' && data.members) {
            this.parameters.participantsAll = data.members.map((participant) => ({
                isBanned: participant.isBanned,
                name: participant.name,
            }));
            this.parameters.participants = data.members.filter((participant) => participant.isBanned == false);
            this.parameters.updateParticipants(this.parameters.participants);
        }
        this.parameters.whiteboardUsers = data.whiteboardUsers;
        this.parameters.updateWhiteboardUsers(this.parameters.whiteboardUsers);
        const useBoard = this.parameters.whiteboardUsers.find((user) => user.name == this.parameters.member && user.useBoard)
            ? true
            : false;
        if (this.parameters.islevel != '2' && !useBoard && !this.parameters.whiteboardEnded) {
            this.changeMode('pan');
        }
        if (data.whiteboardData && Object.keys(data.whiteboardData).length > 0) {
            if (data.whiteboardData.shapes) {
                const oldShapes = this.parameters.shapes.filter((shape) => shape.type === 'image');
                this.parameters.shapes = data.whiteboardData.shapes.map((shape) => {
                    if (shape.type === 'image') {
                        const oldShape = oldShapes.find((oldShape) => oldShape.src === shape.src);
                        if (oldShape) {
                            return { ...shape, img: oldShape.img };
                        }
                        else {
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.src = shape.src;
                            return { ...shape, img };
                        }
                    }
                    else {
                        return shape;
                    }
                });
                this.parameters.updateShapes(this.parameters.shapes);
            }
            if (data.whiteboardData.useImageBackground != null) {
                this.parameters.useImageBackground = data.whiteboardData.useImageBackground;
                this.parameters.updateUseImageBackground(this.parameters.useImageBackground);
            }
            else {
                this.parameters.useImageBackground = true;
                this.parameters.updateUseImageBackground(true);
            }
            if (data.whiteboardData.redoStack) {
                this.parameters.redoStack = data.whiteboardData.redoStack;
                this.parameters.updateRedoStack(this.parameters.redoStack);
            }
            if (data.whiteboardData.undoStack) {
                this.parameters.undoStack = data.whiteboardData.undoStack;
                this.parameters.updateUndoStack(this.parameters.undoStack);
            }
        }
        if (data.status == 'started' && !this.parameters.whiteboardStarted) {
            this.parameters.whiteboardStarted = true;
            this.parameters.whiteboardEnded = false;
            this.parameters.screenId = `whiteboard-${this.parameters.roomName}`;
            this.parameters.updateWhiteboardStarted(true);
            this.parameters.updateWhiteboardEnded(false);
            this.parameters.updateScreenId(this.parameters.screenId);
            if (this.parameters.islevel != '2') {
                this.parameters.shareScreenStarted = true;
                this.parameters.updateShareScreenStarted(true);
                this.parameters.onScreenChanges({ changed: true, parameters: this.parameters });
            }
        }
        else if (data.status == 'ended') {
            const prevWhiteboardEnded = this.parameters.whiteboardEnded;
            const prevWhiteboardStarted = this.parameters.whiteboardStarted;
            this.parameters.whiteboardEnded = true;
            this.parameters.whiteboardStarted = false;
            this.parameters.updateWhiteboardStarted(false);
            this.parameters.updateWhiteboardEnded(true);
            if (this.parameters.islevel == '2' && prevWhiteboardEnded) {
                // No operation needed
            }
            else {
                this.parameters.shareScreenStarted = false;
                this.parameters.screenId = '';
                this.parameters.updateShareScreenStarted(false);
                this.parameters.updateScreenId('');
                this.parameters.onScreenChanges({ changed: true, parameters: this.parameters });
            }
            try {
                if (prevWhiteboardStarted &&
                    this.parameters.islevel == '2' &&
                    (this.parameters.recordStarted || this.parameters.recordResumed)) {
                    if (!(this.parameters.recordPaused || this.parameters.recordStopped)) {
                        if (this.parameters.recordingMediaOptions == 'video') {
                            this.parameters.captureCanvasStream({ parameters: this.parameters, start: false });
                        }
                    }
                }
            }
            catch (error) {
                // Handle error
            }
        }
        else if (data.status == 'started' && this.parameters.whiteboardStarted) {
            this.parameters.whiteboardStarted = true;
            this.parameters.whiteboardEnded = false;
            this.parameters.updateWhiteboardStarted(true);
            this.parameters.updateWhiteboardEnded(false);
            this.parameters.shareScreenStarted = true;
            this.parameters.screenId = `whiteboard-${this.parameters.roomName}`;
            this.parameters.updateShareScreenStarted(true);
            this.parameters.updateScreenId(this.parameters.screenId);
            this.parameters.onScreenChanges({ changed: true, parameters: this.parameters });
        }
    };
    handleDropdownClick(id) {
        this.dropdownOpen = this.dropdownOpen === id ? null : id;
    }
    handleItemClick(callback, name, value) {
        callback(value);
        this.dropdownOpen = null;
        if (['draw', 'freehand', 'shape', 'text', 'erase'].includes(name)) {
            this.changeMode(name);
        }
    }
    dropdownItems(items, name, callback) {
        return items.map((item, index) => `<button key="${index}" class="dropdown-item" (click)="handleItemClick(${callback}, '${name}', ${item.value})" style="padding: 5px;">
        ${item.label}
      </button>`);
    }
    toggleToolbar() {
        this.toolbarVisible = !this.toolbarVisible;
    }
    checkBoardAccess() {
        this.parameters = this.parameters.getUpdatedAllParams();
        if (this.parameters.whiteboardStarted && !this.parameters.whiteboardEnded) {
            const user = this.parameters.whiteboardUsers.find((user) => user.name === this.parameters.member);
            if ((!user || !user.useBoard) && this.parameters.islevel != '2') {
                this.parameters.showAlert?.({
                    message: 'You are not allowed to use the whiteboard. Please ask the host to assign you.',
                    type: 'danger',
                });
                return false;
            }
            else {
                return true;
            }
        }
        else {
            return true;
        }
    }
    changeMode(newMode) {
        if (newMode !== 'pan' && !this.checkBoardAccess())
            return;
        this.mode = newMode;
        const canvas = this.canvasRef.nativeElement;
        if (newMode === 'pan') {
            canvas.style.cursor = 'grab';
        }
        else if (newMode === 'select') {
            canvas.style.cursor = 'pointer';
        }
        else if (newMode === 'erase') {
            canvas.style.cursor = 'crosshair';
        }
        else {
            canvas.style.cursor = 'crosshair';
        }
        if (newMode !== 'freehand' && this.freehandDrawing.length > 0) {
            this.parameters.shapes.push({
                type: 'freehand',
                points: this.freehandDrawing,
                color: this.color,
                thickness: this.brushThickness,
            });
            this.parameters.updateShapes(this.parameters.shapes);
            this.freehandDrawing = [];
            this.saveState();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Whiteboard, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: Whiteboard, isStandalone: true, selector: "app-whiteboard", inputs: { customWidth: "customWidth", customHeight: "customHeight", parameters: "parameters", showAspect: "showAspect" }, viewQueries: [{ propertyName: "canvasRef", first: true, predicate: ["canvasRef"], descendants: true }, { propertyName: "textInputRef", first: true, predicate: ["textInputRef"], descendants: true }, { propertyName: "toggleBackgroundRef", first: true, predicate: ["toggleBackgroundRef"], descendants: true }, { propertyName: "downloadLinkRef", first: true, predicate: ["downloadLinkRef"], descendants: true }, { propertyName: "tempCanvasRef", first: true, predicate: ["tempCanvasRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div id=\"whiteboard-interface\" [style.width.px]=\"customWidth\" [style.height.px]=\"customHeight\" [style.display]=\"showAspect ? 'block' : 'none'\" style=\"position: relative; display: flex; justify-content: center; align-items: center; border: 2px solid #000; background-color: #f0f0f0;\">\r\n  <div id=\"whiteboardContent\" style=\"position: relative; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: auto;\">\r\n    <button id=\"toolbarToggle\" class=\"btn btnBoard btn-primary\" style=\"position: absolute; top: 5px; left: 55px; z-index: 10;\" (click)=\"toggleToolbar()\">\r\n      <fa-icon [icon]=\"toolbarVisible ? faChevronLeft : faChevronRight\"></fa-icon>\r\n    </button>\r\n    <div *ngIf=\"toolbarVisible\" class=\"toolbar mb-3\" id=\"toolbar\" style=\"position: absolute; top: 5px; left: 100px; z-index: 10; background-color: transparent;\">\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"drawMode\" (click)=\"handleDropdownClick('drawMode')\">\r\n          <fa-icon [icon]=\"faPencilAlt\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'drawMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'XX-Small (3px)', value: 3 }, { label: 'X-Small (6px)', value: 6 }, { label: 'Small (12px)', value: 12 }, { label: 'Medium (18px)', value: 18 }, { label: 'Large (24px)', value: 24 }, { label: 'X-Large (36px)', value: 36 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateLineThickness, 'draw', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"freehandMode\" (click)=\"handleDropdownClick('freehandMode')\">\r\n          <fa-icon [icon]=\"faPaintBrush\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'freehandMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (40px)', value: 40 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateBrushThickness, 'freehand', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"shapeMode\" (click)=\"handleDropdownClick('shapeMode')\">\r\n          <fa-icon [icon]=\"faShapes\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'shapeMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/square.svg\\' alt=\\'Square\\' class=\\'shape-icon\\' />', value: 'square' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/rectangle.svg\\' alt=\\'Rectangle\\' class=\\'shape-icon\\' />', value: 'rectangle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/circle.svg\\' alt=\\'Circle\\' class=\\'shape-icon\\' />', value: 'circle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/triangle.svg\\' alt=\\'Triangle\\' class=\\'shape-icon\\' />', value: 'triangle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/hexagon.svg\\' alt=\\'Hexagon\\' class=\\'shape-icon\\' />', value: 'hexagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/pentagon.svg\\' alt=\\'Pentagon\\' class=\\'shape-icon\\' />', value: 'pentagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/rhombus.svg\\' alt=\\'Rhombus\\' class=\\'shape-icon\\' />', value: 'rhombus' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/octagon.svg\\' alt=\\'Octagon\\' class=\\'shape-icon\\' />', value: 'octagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/parallelogram.svg\\' alt=\\'Parallelogram\\' class=\\'shape-icon\\' />', value: 'parallelogram' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/oval.svg\\' alt=\\'Oval\\' class=\\'shape-icon\\' />', value: 'oval' }\r\n          ]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateShape, 'shape', item.value)\" style=\"padding: 5px;\" [innerHTML]=\"item.label\">\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"selectMode\" (click)=\"changeMode('select')\">\r\n        <fa-icon [icon]=\"faMousePointer\"></fa-icon>\r\n      </button>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-danger dropdown-toggle\" id=\"eraseMode\" (click)=\"handleDropdownClick('eraseMode')\">\r\n          <fa-icon [icon]=\"faEraser\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'eraseMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (30px)', value: 30 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateEraserThickness, 'erase', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-info\" id=\"panMode\" (click)=\"changeMode('pan')\">\r\n        <fa-icon [icon]=\"faHandPaper\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomIn\" (click)=\"zoomCanvas(1.2, $event)\">\r\n        <fa-icon [icon]=\"faSearchPlus\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomReset\" (click)=\"zoomCanvas(10, $event)\">\r\n        <fa-icon [icon]=\"faSearch\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomOut\" (click)=\"zoomCanvas(0.8, $event)\">\r\n        <fa-icon [icon]=\"faSearchMinus\"></fa-icon>\r\n      </button>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"addText\" (click)=\"handleDropdownClick('addText')\">\r\n          <fa-icon [icon]=\"faFont\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'addText'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'Arial', value: 'Arial' }, { label: 'Times New Roman', value: 'Times New Roman' }, { label: 'Courier New', value: 'Courier New' }, { label: 'Verdana', value: 'Verdana' }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateFont, 'text', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"fontSize\" (click)=\"handleDropdownClick('fontSize')\">\r\n          <fa-icon [icon]=\"faTextHeight\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'fontSize'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (40px)', value: 40 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateFontSize, '', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"undo\" (click)=\"undo()\">\r\n        <fa-icon [icon]=\"faUndo\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"redo\" (click)=\"redo()\">\r\n        <fa-icon [icon]=\"faRedo\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"save\" (click)=\"saveCanvas()\">\r\n        <fa-icon [icon]=\"faSave\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-danger\" id=\"delete\" (click)=\"deleteShape()\">\r\n        <fa-icon [icon]=\"faTrash\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"clearCanvas\" (click)=\"clearCanvas()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n      <button id=\"toggleBackgroundRef\" #toggleBackgroundRef class=\"btn btnBoard btn-secondary\" (click)=\"toggleBackground()\">\r\n        <img src=\"https://mediasfu.com/images/svg/graph.jpg\" alt=\"Background\" class=\"toggle-icon\" id=\"backgroundIcon\" />\r\n      </button>\r\n      <input type=\"file\" id=\"uploadBoardImage\" accept=\"image/*\" style=\"display: none;\" (change)=\"uploadImage($event)\" />\r\n      <label for=\"uploadBoardImage\" class=\"btn btnBoard btn-primary\">\r\n        <fa-icon [icon]=\"faUpload\"></fa-icon>\r\n      </label>\r\n      <input type=\"color\" id=\"colorPicker\" class=\"btn\" [(ngModel)]=\"color\" />\r\n      <select id=\"lineTypePicker\" class=\"custom-select\" style=\"width: auto;\" [(ngModel)]=\"lineType\">\r\n        <option value=\"solid\">Solid</option>\r\n        <option value=\"dashed\">Dashed</option>\r\n        <option value=\"dotted\">Dotted</option>\r\n        <option value=\"dashDot\">Dash-Dot</option>\r\n      </select>\r\n    </div>\r\n    <canvas id=\"canvasRef\" width=\"1280\" height=\"720\" style=\"border: 2px solid red;\" #canvasRef></canvas>\r\n    <textarea id=\"textInputRef\" class=\"form-control\" #textInputRef style=\"display: none; position: absolute;\"></textarea>\r\n    <a href=\"#\" id=\"downloadLinkRef\" #downloadLinkRef style=\"display: none;\">Download</a>\r\n    <canvas id=\"tempCanvasRef\" #tempCanvasRef style=\"display: none;\"></canvas>\r\n  </div>\r\n</div>\r\n", styles: ["#whiteboardCanvas,#canvsRef{border:1px solid #000;cursor:crosshair;background-color:#fff}.resize-handle,.move-handle{width:8px;height:8px;background:red;position:absolute}.move-handle{background:#00f}#textInput,#textInputRef{display:none;position:absolute;z-index:10;width:200px}.shape-icon{width:20px!important;height:20px!important;color:#fff}.toolbar .btn-group button,.toolbar .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s}.toolbar .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbar .btn-group button:hover,.toolbar .dropdown-menu a:hover{background-color:#e3e7eb}.toolbar .btn-group button.active{background-color:#454d55}.toolbarScreen .btn-group button,.toolbarScreen .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s;color:\"black\"}.toolbarScreen .btn-group button{background-color:#e3e7eb;border:none}.toolbarScreen .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbarScreen .btn-group button:hover,.toolbarScreen .dropdown-menu a:hover{background-color:#d6d1d166;color:#000}.toolbarScreen .btn-group button.active{background-color:#454d55}#toolbarToggleScreen{background-color:#d6d1d166;border:\"1px solid black\"}#toolbar,#toolbarScreen{transition:display .3s ease-in-out}#toolbarToggle,#toolbarToggleScreen{cursor:pointer}#colorPicker,#colorPickerScreen{font-size:.8rem;padding:2px;width:32px;height:32px}#lineTypePicker{font-size:.8rem;padding:2px auto;width:32px;height:32px}.btnBoard{font-size:1rem;padding:2px;width:40px;height:40px;margin:2px}#lineTypePickerScreen{font-size:.8rem;padding:2px auto;width:32px;height:32px;background-color:#d6d1d166;color:#000}.toggle-icon{width:34px;height:34px;padding:0;margin:0}#toggleBackground.active{background-color:#fdfeff}.annotateScreenBtn{background-color:#2d2e2f!important;border:2px solid #000!important;color:green!important}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$1.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }], encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Whiteboard, decorators: [{
            type: Component,
            args: [{ selector: 'app-whiteboard', standalone: true, encapsulation: ViewEncapsulation.None, imports: [CommonModule, FormsModule, FontAwesomeModule], template: "<div id=\"whiteboard-interface\" [style.width.px]=\"customWidth\" [style.height.px]=\"customHeight\" [style.display]=\"showAspect ? 'block' : 'none'\" style=\"position: relative; display: flex; justify-content: center; align-items: center; border: 2px solid #000; background-color: #f0f0f0;\">\r\n  <div id=\"whiteboardContent\" style=\"position: relative; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: auto;\">\r\n    <button id=\"toolbarToggle\" class=\"btn btnBoard btn-primary\" style=\"position: absolute; top: 5px; left: 55px; z-index: 10;\" (click)=\"toggleToolbar()\">\r\n      <fa-icon [icon]=\"toolbarVisible ? faChevronLeft : faChevronRight\"></fa-icon>\r\n    </button>\r\n    <div *ngIf=\"toolbarVisible\" class=\"toolbar mb-3\" id=\"toolbar\" style=\"position: absolute; top: 5px; left: 100px; z-index: 10; background-color: transparent;\">\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"drawMode\" (click)=\"handleDropdownClick('drawMode')\">\r\n          <fa-icon [icon]=\"faPencilAlt\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'drawMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'XX-Small (3px)', value: 3 }, { label: 'X-Small (6px)', value: 6 }, { label: 'Small (12px)', value: 12 }, { label: 'Medium (18px)', value: 18 }, { label: 'Large (24px)', value: 24 }, { label: 'X-Large (36px)', value: 36 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateLineThickness, 'draw', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"freehandMode\" (click)=\"handleDropdownClick('freehandMode')\">\r\n          <fa-icon [icon]=\"faPaintBrush\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'freehandMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (40px)', value: 40 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateBrushThickness, 'freehand', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"shapeMode\" (click)=\"handleDropdownClick('shapeMode')\">\r\n          <fa-icon [icon]=\"faShapes\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'shapeMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/square.svg\\' alt=\\'Square\\' class=\\'shape-icon\\' />', value: 'square' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/rectangle.svg\\' alt=\\'Rectangle\\' class=\\'shape-icon\\' />', value: 'rectangle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/circle.svg\\' alt=\\'Circle\\' class=\\'shape-icon\\' />', value: 'circle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/triangle.svg\\' alt=\\'Triangle\\' class=\\'shape-icon\\' />', value: 'triangle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/hexagon.svg\\' alt=\\'Hexagon\\' class=\\'shape-icon\\' />', value: 'hexagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/pentagon.svg\\' alt=\\'Pentagon\\' class=\\'shape-icon\\' />', value: 'pentagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/rhombus.svg\\' alt=\\'Rhombus\\' class=\\'shape-icon\\' />', value: 'rhombus' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/octagon.svg\\' alt=\\'Octagon\\' class=\\'shape-icon\\' />', value: 'octagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/parallelogram.svg\\' alt=\\'Parallelogram\\' class=\\'shape-icon\\' />', value: 'parallelogram' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/oval.svg\\' alt=\\'Oval\\' class=\\'shape-icon\\' />', value: 'oval' }\r\n          ]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateShape, 'shape', item.value)\" style=\"padding: 5px;\" [innerHTML]=\"item.label\">\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"selectMode\" (click)=\"changeMode('select')\">\r\n        <fa-icon [icon]=\"faMousePointer\"></fa-icon>\r\n      </button>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-danger dropdown-toggle\" id=\"eraseMode\" (click)=\"handleDropdownClick('eraseMode')\">\r\n          <fa-icon [icon]=\"faEraser\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'eraseMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (30px)', value: 30 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateEraserThickness, 'erase', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-info\" id=\"panMode\" (click)=\"changeMode('pan')\">\r\n        <fa-icon [icon]=\"faHandPaper\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomIn\" (click)=\"zoomCanvas(1.2, $event)\">\r\n        <fa-icon [icon]=\"faSearchPlus\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomReset\" (click)=\"zoomCanvas(10, $event)\">\r\n        <fa-icon [icon]=\"faSearch\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomOut\" (click)=\"zoomCanvas(0.8, $event)\">\r\n        <fa-icon [icon]=\"faSearchMinus\"></fa-icon>\r\n      </button>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"addText\" (click)=\"handleDropdownClick('addText')\">\r\n          <fa-icon [icon]=\"faFont\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'addText'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'Arial', value: 'Arial' }, { label: 'Times New Roman', value: 'Times New Roman' }, { label: 'Courier New', value: 'Courier New' }, { label: 'Verdana', value: 'Verdana' }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateFont, 'text', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"fontSize\" (click)=\"handleDropdownClick('fontSize')\">\r\n          <fa-icon [icon]=\"faTextHeight\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'fontSize'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (40px)', value: 40 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateFontSize, '', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"undo\" (click)=\"undo()\">\r\n        <fa-icon [icon]=\"faUndo\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"redo\" (click)=\"redo()\">\r\n        <fa-icon [icon]=\"faRedo\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"save\" (click)=\"saveCanvas()\">\r\n        <fa-icon [icon]=\"faSave\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-danger\" id=\"delete\" (click)=\"deleteShape()\">\r\n        <fa-icon [icon]=\"faTrash\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"clearCanvas\" (click)=\"clearCanvas()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n      <button id=\"toggleBackgroundRef\" #toggleBackgroundRef class=\"btn btnBoard btn-secondary\" (click)=\"toggleBackground()\">\r\n        <img src=\"https://mediasfu.com/images/svg/graph.jpg\" alt=\"Background\" class=\"toggle-icon\" id=\"backgroundIcon\" />\r\n      </button>\r\n      <input type=\"file\" id=\"uploadBoardImage\" accept=\"image/*\" style=\"display: none;\" (change)=\"uploadImage($event)\" />\r\n      <label for=\"uploadBoardImage\" class=\"btn btnBoard btn-primary\">\r\n        <fa-icon [icon]=\"faUpload\"></fa-icon>\r\n      </label>\r\n      <input type=\"color\" id=\"colorPicker\" class=\"btn\" [(ngModel)]=\"color\" />\r\n      <select id=\"lineTypePicker\" class=\"custom-select\" style=\"width: auto;\" [(ngModel)]=\"lineType\">\r\n        <option value=\"solid\">Solid</option>\r\n        <option value=\"dashed\">Dashed</option>\r\n        <option value=\"dotted\">Dotted</option>\r\n        <option value=\"dashDot\">Dash-Dot</option>\r\n      </select>\r\n    </div>\r\n    <canvas id=\"canvasRef\" width=\"1280\" height=\"720\" style=\"border: 2px solid red;\" #canvasRef></canvas>\r\n    <textarea id=\"textInputRef\" class=\"form-control\" #textInputRef style=\"display: none; position: absolute;\"></textarea>\r\n    <a href=\"#\" id=\"downloadLinkRef\" #downloadLinkRef style=\"display: none;\">Download</a>\r\n    <canvas id=\"tempCanvasRef\" #tempCanvasRef style=\"display: none;\"></canvas>\r\n  </div>\r\n</div>\r\n", styles: ["#whiteboardCanvas,#canvsRef{border:1px solid #000;cursor:crosshair;background-color:#fff}.resize-handle,.move-handle{width:8px;height:8px;background:red;position:absolute}.move-handle{background:#00f}#textInput,#textInputRef{display:none;position:absolute;z-index:10;width:200px}.shape-icon{width:20px!important;height:20px!important;color:#fff}.toolbar .btn-group button,.toolbar .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s}.toolbar .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbar .btn-group button:hover,.toolbar .dropdown-menu a:hover{background-color:#e3e7eb}.toolbar .btn-group button.active{background-color:#454d55}.toolbarScreen .btn-group button,.toolbarScreen .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s;color:\"black\"}.toolbarScreen .btn-group button{background-color:#e3e7eb;border:none}.toolbarScreen .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbarScreen .btn-group button:hover,.toolbarScreen .dropdown-menu a:hover{background-color:#d6d1d166;color:#000}.toolbarScreen .btn-group button.active{background-color:#454d55}#toolbarToggleScreen{background-color:#d6d1d166;border:\"1px solid black\"}#toolbar,#toolbarScreen{transition:display .3s ease-in-out}#toolbarToggle,#toolbarToggleScreen{cursor:pointer}#colorPicker,#colorPickerScreen{font-size:.8rem;padding:2px;width:32px;height:32px}#lineTypePicker{font-size:.8rem;padding:2px auto;width:32px;height:32px}.btnBoard{font-size:1rem;padding:2px;width:40px;height:40px;margin:2px}#lineTypePickerScreen{font-size:.8rem;padding:2px auto;width:32px;height:32px;background-color:#d6d1d166;color:#000}.toggle-icon{width:34px;height:34px;padding:0;margin:0}#toggleBackground.active{background-color:#fdfeff}.annotateScreenBtn{background-color:#2d2e2f!important;border:2px solid #000!important;color:green!important}\n"] }]
        }], propDecorators: { customWidth: [{
                type: Input
            }], customHeight: [{
                type: Input
            }], parameters: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], canvasRef: [{
                type: ViewChild,
                args: ['canvasRef', { static: false }]
            }], textInputRef: [{
                type: ViewChild,
                args: ['textInputRef', { static: false }]
            }], toggleBackgroundRef: [{
                type: ViewChild,
                args: ['toggleBackgroundRef', { static: false }]
            }], downloadLinkRef: [{
                type: ViewChild,
                args: ['downloadLinkRef', { static: false }]
            }], tempCanvasRef: [{
                type: ViewChild,
                args: ['tempCanvasRef', { static: false }]
            }] } });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * @fileoverview Screenboard component for MediaSFU-Angular application.
 *
 * This component provides a screenboard with drawing, freehand, shape, and erase modes.
 * It supports mouse and touch events for drawing on a canvas.
 *
 * @component
 * @selector app-screenboard
 * @templateUrl ./screenboard.component.html
 * @styleUrls ./screenboard.component.css
 * @imports CommonModule, FontAwesomeModule, FormsModule
 *
 * @class Screenboard
 * @implements OnInit, AfterViewInit, OnDestroy, OnChanges
 *
 * @property {number} customWidth - Custom width for the screenboard.
 * @property {number} customHeight - Custom height for the screenboard.
 * @property {any} parameters - Parameters for the screenboard.
 * @property {boolean} showAspect - Flag to show aspect ratio.
 *
 * @property {ElementRef<HTMLCanvasElement>} canvasRef - Reference to the canvas element.
 * @property {ElementRef<HTMLDivElement>} screenboardRef - Reference to the screenboard div element.
 * @property {ElementRef<HTMLDivElement>} screenboardContentRef - Reference to the screenboard content div element.
 *
 * @property {IconDefinition} faChevronRight - FontAwesome icon for chevron right.
 * @property {IconDefinition} faChevronLeft - FontAwesome icon for chevron left.
 * @property {IconDefinition} faPencilAlt - FontAwesome icon for pencil.
 * @property {IconDefinition} faPaintBrush - FontAwesome icon for paint brush.
 * @property {IconDefinition} faShapes - FontAwesome icon for shapes.
 * @property {IconDefinition} faEraser - FontAwesome icon for eraser.
 * @property {IconDefinition} faSearch - FontAwesome icon for search.
 * @property {IconDefinition} faSearchPlus - FontAwesome icon for search plus.
 * @property {IconDefinition} faSearchMinus - FontAwesome icon for search minus.
 * @property {IconDefinition} faFont - FontAwesome icon for font.
 * @property {IconDefinition} faTextHeight - FontAwesome icon for text height.
 * @property {IconDefinition} faUndo - FontAwesome icon for undo.
 * @property {IconDefinition} faRedo - FontAwesome icon for redo.
 * @property {IconDefinition} faSave - FontAwesome icon for save.
 * @property {IconDefinition} faTrash - FontAwesome icon for trash.
 * @property {IconDefinition} faTimes - FontAwesome icon for times.
 * @property {IconDefinition} faMousePointer - FontAwesome icon for mouse pointer.
 *
 * @property {'draw' | 'freehand' | 'shape' | 'erase'} mode - Current drawing mode.
 * @property {boolean} isDrawing - Flag to indicate if drawing is in progress.
 * @property {number} startX - Starting X coordinate for drawing.
 * @property {number} startY - Starting Y coordinate for drawing.
 * @property {number} currentX - Current X coordinate for drawing.
 * @property {number} currentY - Current Y coordinate for drawing.
 * @property {Array<{ x: number; y: number; color: string; thickness: number }>} freehandDrawing - Array of points for freehand drawing.
 * @property {any[]} shapes - Array of shapes drawn on the canvas.
 * @property {number} eraserThickness - Thickness of the eraser.
 * @property {number} brushThickness - Thickness of the brush.
 * @property {number} lineThickness - Thickness of the line.
 * @property {string} lineType - Type of the line (solid, dashed, dotted, dashDot).
 * @property {string} color - Color for drawing.
 * @property {string} font - Font for text.
 * @property {number} fontSize - Font size for text.
 * @property {string | null} shape - Current shape being drawn.
 * @property {boolean} toolbarVisible - Flag to indicate if the toolbar is visible.
 * @property {string | null} dropdownOpen - ID of the currently open dropdown.
 * @property {HTMLCanvasElement} canvas - Canvas element.
 * @property {CanvasRenderingContext2D} ctx - Canvas rendering context.
 *
 * @constructor
 * @param {number} [injectedCustomWidth] - Injected custom width.
 * @param {number} [injectedCustomHeight] - Injected custom height.
 * @param {any} [injectedParameters] - Injected parameters.
 * @param {boolean} [injectedShowAspect] - Injected show aspect flag.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes.
 * @method ngAfterViewInit - Lifecycle hook that is called after the component's view has been fully initialized.
 * @method ngOnDestroy - Lifecycle hook that is called just before the component is destroyed.
 *
 * @method addListeners - Adds event listeners to the canvas.
 * @method handleMouseDown - Handles mouse down events.
 * @method handleMouseMove - Handles mouse move events.
 * @method handleMouseUp - Handles mouse up events.
 * @method handleTouchStart - Handles touch start events.
 * @method handleTouchMove - Handles touch move events.
 * @method handleTouchEnd - Handles touch end events.
 * @method handleClickOutside - Handles click events outside the component.
 * @method handleDropdownClick - Handles dropdown click events.
 * @method setDrawMode - Sets the drawing mode.
 * @method setFreehandMode - Sets the freehand mode.
 * @method setShapeMode - Sets the shape mode.
 * @method setEraseMode - Sets the erase mode.
 * @method startDrawing - Starts the drawing process.
 * @method draw - Draws on the canvas.
 * @method stopDrawing - Stops the drawing process.
 * @method drawLine - Draws a line on the canvas.
 * @method drawShapes - Draws all shapes on the canvas.
 * @method drawFreehand - Draws freehand on the canvas.
 * @method drawShape - Draws a shape on the canvas.
 * @method drawPolygon - Draws a polygon on the canvas.
 * @method removeShape - Removes the first shape from the shapes array.
 * @method erase - Erases part of the drawing.
 * @method isPointNearLine - Checks if a point is near a line.
 * @method toggleToolbar - Toggles the visibility of the toolbar.
 * @method toggleAnnotate - Toggles the annotation mode.
 */
class Screenboard {
    customWidth;
    customHeight;
    parameters = {};
    showAspect;
    canvasRef;
    screenboardRef;
    screenboardContentRef;
    faChevronRight = faChevronRight;
    faChevronLeft = faChevronLeft;
    faPencilAlt = faPencilAlt;
    faPaintBrush = faPaintBrush;
    faShapes = faShapes;
    faEraser = faEraser;
    faSearch = faSearch;
    faSearchPlus = faSearchPlus;
    faSearchMinus = faSearchMinus;
    faFont = faFont;
    faTextHeight = faTextHeight;
    faUndo = faUndo;
    faRedo = faRedo;
    faSave = faSave;
    faTrash = faTrash;
    faTimes = faTimes;
    faMousePointer = faMousePointer;
    mode = 'draw';
    isDrawing = false;
    startX = 0;
    startY = 0;
    currentX = 0;
    currentY = 0;
    freehandDrawing = [];
    shapes = [];
    eraserThickness = 10;
    brushThickness = 6;
    lineThickness = 6;
    lineType = 'solid';
    color = '#000000';
    font = 'Arial';
    fontSize = 20;
    shape = null;
    toolbarVisible = false;
    dropdownOpen = null;
    canvas;
    ctx;
    constructor(injectedCustomWidth, injectedCustomHeight, injectedParameters, injectedShowAspect) {
        this.customWidth = injectedCustomWidth || this.customWidth || 0;
        this.customHeight = injectedCustomHeight || this.customHeight || 0;
        this.parameters = injectedParameters || this.parameters || {};
        this.showAspect = injectedShowAspect || this.showAspect || false;
    }
    ngOnInit() {
        setTimeout(() => {
            if (this.parameters) {
                this.parameters = this.parameters.getUpdatedAllParams();
            }
        }, 100);
    }
    ngOnChanges(changes) {
        if (changes['showAspect']) {
            if (!this.canvas && this.canvasRef) {
                this.canvas = this.canvasRef.nativeElement;
                this.addListeners();
            }
        }
    }
    ngAfterViewInit() {
        if (this.canvasRef && !this.canvas) {
            this.canvas = this.canvasRef.nativeElement;
            this.addListeners();
        }
    }
    ngOnDestroy() {
        if (this.canvas) {
            this.canvas.removeEventListener('mousedown', this.handleMouseDown.bind(this));
            this.canvas.removeEventListener('mousemove', this.handleMouseMove.bind(this));
            this.canvas.removeEventListener('mouseup', this.handleMouseUp.bind(this));
            this.canvas.removeEventListener('mouseout', this.handleMouseUp.bind(this));
            this.canvas.removeEventListener('touchstart', this.handleTouchStart.bind(this));
            this.canvas.removeEventListener('touchmove', this.handleTouchMove.bind(this));
            this.canvas.removeEventListener('touchend', this.handleTouchEnd.bind(this));
            document.removeEventListener('mousedown', this.handleClickOutside.bind(this));
        }
    }
    addListeners = () => {
        if (this.canvas) {
            this.ctx = this.canvas.getContext('2d');
            this.parameters.updateCanvasScreenboard(this.canvas);
            this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
            this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
            this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
            this.canvas.addEventListener('mouseout', this.handleMouseUp.bind(this));
            this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
            this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
            this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
            document.addEventListener('mousedown', this.handleClickOutside.bind(this));
        }
    };
    handleMouseDown(event) {
        this.startDrawing(event);
    }
    handleMouseMove(event) {
        this.draw(event);
    }
    handleMouseUp() {
        this.stopDrawing();
    }
    handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY,
        });
        this.canvas.dispatchEvent(mouseEvent);
    }
    handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY,
        });
        this.canvas.dispatchEvent(mouseEvent);
    }
    handleTouchEnd(e) {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        this.canvas.dispatchEvent(mouseEvent);
    }
    handleClickOutside(event) {
        if (this.dropdownOpen && !event.target.closest('.btn-group')) {
            this.dropdownOpen = null;
        }
    }
    handleDropdownClick(id) {
        this.dropdownOpen = this.dropdownOpen === id ? null : id;
    }
    setDrawMode(thickness) {
        this.lineThickness = thickness;
        this.mode = 'draw';
        this.dropdownOpen = null;
    }
    setFreehandMode(thickness) {
        this.brushThickness = thickness;
        this.mode = 'freehand';
        this.dropdownOpen = null;
    }
    setShapeMode(shape) {
        this.shape = shape;
        this.mode = 'shape';
        this.dropdownOpen = null;
    }
    setEraseMode(thickness) {
        this.eraserThickness = thickness;
        this.mode = 'erase';
        this.dropdownOpen = null;
    }
    startDrawing(event) {
        this.isDrawing = true;
        this.startX = event.offsetX;
        this.startY = event.offsetY;
        if (this.mode === 'erase') {
            this.erase(event.offsetX, event.offsetY);
        }
        else if (this.mode === 'draw' || this.mode === 'freehand') {
            this.ctx.beginPath();
            this.ctx.moveTo(event.offsetX, event.offsetY);
            if (this.mode === 'freehand') {
                this.freehandDrawing = [
                    { x: event.offsetX, y: event.offsetY, color: this.color, thickness: this.brushThickness },
                ];
            }
        }
    }
    draw(event) {
        if (!this.isDrawing)
            return;
        this.currentX = event.offsetX;
        this.currentY = event.offsetY;
        if (this.mode === 'erase') {
            this.erase(event.offsetX, event.offsetY);
        }
        else if (this.mode === 'draw') {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawShapes();
            this.drawLine(this.startX, this.startY, event.offsetX, event.offsetY);
        }
        else if (this.mode === 'freehand') {
            this.ctx.lineTo(event.offsetX, event.offsetY);
            this.ctx.strokeStyle = this.color;
            this.ctx.lineWidth = this.brushThickness;
            this.ctx.stroke();
            this.freehandDrawing.push({
                x: event.offsetX,
                y: event.offsetY,
                color: this.color,
                thickness: this.brushThickness,
            });
        }
        else if (this.mode === 'shape') {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawShapes();
            this.drawShape(this.shape, this.startX, this.startY, event.offsetX, event.offsetY);
        }
    }
    stopDrawing() {
        this.isDrawing = false;
        if (this.mode === 'draw') {
            this.shapes.push({
                type: 'line',
                x1: this.startX,
                y1: this.startY,
                x2: this.currentX,
                y2: this.currentY,
                color: this.color,
                thickness: this.lineThickness,
                lineType: this.lineType,
            });
        }
        else if (this.mode === 'freehand') {
            this.shapes.push({
                type: 'freehand',
                points: this.freehandDrawing,
                color: this.color,
                thickness: this.brushThickness,
            });
            this.freehandDrawing = [];
        }
        else if (this.mode === 'shape') {
            this.shapes.push({
                type: this.shape,
                x1: this.startX,
                y1: this.startY,
                x2: this.currentX,
                y2: this.currentY,
                color: this.color,
                thickness: this.lineThickness,
                lineType: this.lineType,
            });
        }
        setTimeout(() => this.removeShape(), 15000);
    }
    drawLine = (x1, y1, x2, y2) => {
        this.ctx.beginPath();
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.lineThickness;
        if (this.lineType === 'dashed') {
            this.ctx.setLineDash([10, 10]);
        }
        else if (this.lineType === 'dotted') {
            this.ctx.setLineDash([2, 10]);
        }
        else if (this.lineType === 'dashDot') {
            this.ctx.setLineDash([10, 5, 2, 5]);
        }
        else {
            this.ctx.setLineDash([]);
        }
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
    };
    drawShapes = () => {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.shapes.forEach((shape) => {
            if (shape.type === 'line') {
                this.drawLine(shape.x1, shape.y1, shape.x2, shape.y2);
            }
            else if (shape.type === 'freehand') {
                this.drawFreehand(shape.points);
            }
            else {
                this.drawShape(shape.type, shape.x1, shape.y1, shape.x2, shape.y2);
            }
        });
    };
    drawFreehand = (points) => {
        if (points.length < 2)
            return;
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.brushThickness;
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            this.ctx.lineTo(points[i].x, points[i].y);
        }
        this.ctx.stroke();
    };
    drawShape = (type, x1, y1, x2, y2) => {
        this.ctx.beginPath();
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.lineThickness;
        if (this.lineType === 'dashed') {
            this.ctx.setLineDash([10, 10]);
        }
        else if (this.lineType === 'dotted') {
            this.ctx.setLineDash([2, 10]);
        }
        else if (this.lineType === 'dashDot') {
            this.ctx.setLineDash([10, 5, 2, 5]);
        }
        else {
            this.ctx.setLineDash([]);
        }
        if (type === 'rectangle') {
            this.ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
        }
        else if (type === 'circle') {
            const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            this.ctx.arc(x1, y1, radius, 0, 2 * Math.PI);
            this.ctx.stroke();
        }
        else if (type === 'rhombus') {
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            this.ctx.moveTo(centerX, y1);
            this.ctx.lineTo(x2, centerY);
            this.ctx.lineTo(centerX, y2);
            this.ctx.lineTo(x1, centerY);
            this.ctx.closePath();
            this.ctx.stroke();
        }
        else if (type === 'pentagon') {
            this.drawPolygon(5, x1, y1, x2, y2);
        }
        else if (type === 'hexagon') {
            this.drawPolygon(6, x1, y1, x2, y2);
        }
        else if (type === 'triangle') {
            const centerXTriangle = (x1 + x2) / 2;
            this.ctx.moveTo(centerXTriangle, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.lineTo(x1, y2);
            this.ctx.closePath();
            this.ctx.stroke();
        }
        else if (type === 'square') {
            this.ctx.strokeRect(x1, y1, x2 - x1, x2 - x1);
        }
        else if (type === 'octagon') {
            this.drawPolygon(8, x1, y1, x2, y2);
        }
        else if (type === 'oval') {
            const radiusX = Math.abs(x2 - x1) / 2;
            const radiusY = Math.abs(y2 - y1) / 2;
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            this.ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            this.ctx.stroke();
        }
        else if (type === 'parallelogram') {
            const centerX = (x1 + x2) / 2;
            this.ctx.moveTo(centerX, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.lineTo(centerX, y2);
            this.ctx.lineTo(x1, y1);
            this.ctx.closePath();
            this.ctx.stroke();
        }
        this.ctx.setLineDash([]);
    };
    drawPolygon = (sides, x1, y1, x2, y2) => {
        const centerX = (x1 + x2) / 2;
        const centerY = (y1 + y2) / 2;
        const radius = Math.min(Math.abs(x2 - x1), Math.abs(y2 - y1)) / 2;
        const angle = (2 * Math.PI) / sides;
        this.ctx.beginPath();
        for (let i = 0; i < sides; i++) {
            const x = centerX + radius * Math.cos(i * angle - Math.PI / 2);
            const y = centerY + radius * Math.sin(i * angle - Math.PI / 2);
            if (i === 0) {
                this.ctx.moveTo(x, y);
            }
            else {
                this.ctx.lineTo(x, y);
            }
        }
        this.ctx.closePath();
        this.ctx.stroke();
    };
    removeShape = () => {
        this.shapes.shift();
        this.drawShapes();
    };
    erase = (x, y) => {
        this.ctx.save();
        this.ctx.globalCompositeOperation = 'destination-out';
        this.ctx.beginPath();
        this.ctx.arc(x, y, this.eraserThickness / 2, 0, Math.PI * 2, false);
        this.ctx.fill();
        this.ctx.restore();
        this.shapes = this.shapes
            .map((shape) => {
            if (shape.type === 'freehand') {
                return {
                    ...shape,
                    points: shape.points.filter((point) => {
                        const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                        return distance > this.eraserThickness / 2;
                    }),
                };
            }
            else if (shape.type === 'line') {
                if (this.isPointNearLine(x, y, shape.x1, shape.y1, shape.x2, shape.y2, this.eraserThickness / 2)) {
                    return null;
                }
            }
            else if (shape.type === 'text') {
                const textWidth = this.ctx.measureText(shape.text).width;
                if (x > shape.x &&
                    x < shape.x + textWidth &&
                    y > shape.y - shape.fontSize &&
                    y < shape.y) {
                    return null;
                }
            }
            else {
                if (x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2) {
                    return null;
                }
            }
            return shape;
        })
            .filter((shape) => shape && (shape.type !== 'freehand' || shape.points.length > 0));
    };
    isPointNearLine(px, py, x1, y1, x2, y2, threshold) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        const dot = ((px - x1) * dx + (py - y1) * dy) / (length * length);
        const closestX = x1 + dot * dx;
        const closestY = y1 + dot * dy;
        const distance = Math.sqrt(Math.pow(px - closestX, 2) + Math.pow(py - closestY, 2));
        return distance <= threshold;
    }
    toggleToolbar = () => {
        this.toolbarVisible = !this.toolbarVisible;
    };
    toggleAnnotate = async () => {
        const annotateScreenStream = this.parameters.annotateScreenStream;
        this.parameters.annotateScreenStream = !annotateScreenStream;
        setTimeout(() => {
            this.parameters.updateAnnotateScreenStream(!annotateScreenStream);
        });
        if (this.parameters.annotateScreenStream) {
            this.toolbarVisible = true;
            this.parameters.showAlert?.({
                message: `You can now annotate the screen. If you cannot see your annotation controls (on top), try minimizing your screen by using 'Cmd' + '-' (on Mac) or 'Ctrl' + '-' (on Windows).`,
                type: 'success',
                duration: 9000,
            });
        }
        else {
            this.toolbarVisible = false;
        }
        this.parameters.updateIsScreenboardModalVisible(true);
        await this.parameters.sleep({ ms: 500 });
        this.parameters.updateIsScreenboardModalVisible(false);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Screenboard, deps: [{ token: 'customWidth', optional: true }, { token: 'customHeight', optional: true }, { token: 'parameters', optional: true }, { token: 'showAspect', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: Screenboard, isStandalone: true, selector: "app-screenboard", inputs: { customWidth: "customWidth", customHeight: "customHeight", parameters: "parameters", showAspect: "showAspect" }, viewQueries: [{ propertyName: "canvasRef", first: true, predicate: ["canvasRef"], descendants: true }, { propertyName: "screenboardRef", first: true, predicate: ["screenboardRef"], descendants: true }, { propertyName: "screenboardContentRef", first: true, predicate: ["screenboardContentRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div id=\"screenboard-interface\" *ngIf=\"showAspect\" style=\"position: relative; display: block; justify-content: center; align-items: center; background-color: transparent; z-index: 1000; width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: auto;\" #screenboardRef>\r\n  <div id=\"screenboardContent\" style=\"position: relative; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; overflow: hidden; top: 0; left: 0;\" #screenboardContentRef>\r\n    <button id=\"annotateScreen\" class=\"btn btn-primary btnBoardScreen annotateScreenBtn\" style=\"position: absolute; top: 5px; right: 10px; z-index: 1000;\" (click)=\"toggleAnnotate()\">\r\n      <fa-icon [icon]=\"faPencilAlt\" [ngStyle]=\"{'color': parameters.annotateScreenStream ? 'red' : 'green'}\"></fa-icon>\r\n    </button>\r\n\r\n    <button id=\"toolbarToggleScreen\" *ngIf=\"parameters.annotateScreenStream\" class=\"btn btnBoardScreen btn-primary\" style=\"position: absolute; top: 5px; right: 55px; z-index: 1000;\" (click)=\"toggleToolbar()\">\r\n      <fa-icon [icon]=\"toolbarVisible ? faChevronRight : faChevronLeft\"></fa-icon>\r\n    </button>\r\n\r\n    <div class=\"toolbarScreen mb-3\" id=\"toolbarScreen\" style=\"position: absolute; top: 5px; right: 105px; z-index: 1000; background-color: transparent;\" [style.display]=\"toolbarVisible ? 'block' : 'none'\">\r\n      <!-- Draw Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-secondary dropdown-toggle\" id=\"drawModeScreen\" (click)=\"handleDropdownClick('drawModeScreen')\">\r\n          <fa-icon [icon]=\"faPencilAlt\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'drawModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(3)\">XX-Small (3px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(6)\">X-Small (6px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(12)\">Small (12px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(18)\">Medium (18px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(24)\">Large (24px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(36)\">X-Large (36px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Freehand Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-dark dropdown-toggle\" id=\"freehandModeScreen\" (click)=\"handleDropdownClick('freehandModeScreen')\">\r\n          <fa-icon [icon]=\"faPaintBrush\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'freehandModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(5)\">X-Small (5px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(10)\">Small (10px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(20)\">Medium (20px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(40)\">Large (40px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(60)\">X-Large (60px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Shape Mode Dropdown with Images -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-dark dropdown-toggle\" id=\"shapeModeScreen\" (click)=\"handleDropdownClick('shapeModeScreen')\">\r\n          <fa-icon [icon]=\"faShapes\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'shapeModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('square')\">\r\n            <img src=\"https://mediasfu.com/images/svg/square.svg\" alt=\"Square\" class=\"shape-icon\" /> Square\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('rectangle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/rectangle.svg\" alt=\"Rectangle\" class=\"shape-icon\" /> Rectangle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('circle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/circle.svg\" alt=\"Circle\" class=\"shape-icon\" /> Circle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('triangle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/triangle.svg\" alt=\"Triangle\" class=\"shape-icon\" /> Triangle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('hexagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/hexagon.svg\" alt=\"Hexagon\" class=\"shape-icon\" /> Hexagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('pentagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/pentagon.svg\" alt=\"Pentagon\" class=\"shape-icon\" /> Pentagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('rhombus')\">\r\n            <img src=\"https://mediasfu.com/images/svg/rhombus.svg\" alt=\"Rhombus\" class=\"shape-icon\" /> Rhombus\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('octagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/octagon.svg\" alt=\"Octagon\" class=\"shape-icon\" /> Octagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('oval')\">\r\n            <img src=\"https://mediasfu.com/images/svg/oval.svg\" alt=\"Oval\" class=\"shape-icon\" /> Oval\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('parallelogram')\">\r\n            <img src=\"https://mediasfu.com/images/svg/parallelogram.svg\" alt=\"Parallelogram\" class=\"shape-icon\" /> Parallelogram\r\n          </button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Erase Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-danger dropdown-toggle\" id=\"eraseModeScreen\" (click)=\"handleDropdownClick('eraseModeScreen')\">\r\n          <fa-icon [icon]=\"faEraser\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'eraseModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(5)\">X-Small (5px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(10)\">Small (10px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(20)\">Medium (20px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(30)\">Large (30px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(60)\">X-Large (60px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Additional Toolbar Controls -->\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomResetScreen\" style=\"display: none;\">\r\n        <fa-icon [icon]=\"faSearch\"></fa-icon>\r\n      </button>\r\n\r\n      <input type=\"color\" class=\"btn\" id=\"colorPickerScreen\" [(ngModel)]=\"color\">\r\n      <select id=\"lineTypePickerScreen\" class=\"custom-select\" style=\"width: auto;\" [(ngModel)]=\"lineType\">\r\n        <option value=\"solid\">Solid</option>\r\n        <option value=\"dashed\">Dashed</option>\r\n        <option value=\"dotted\">Dotted</option>\r\n        <option value=\"dashDot\">Dash-Dot</option>\r\n      </select>\r\n    </div>\r\n\r\n    <canvas id=\"canvasRef\" width=\"1280\" height=\"720\" [ngStyle]=\"{'display': parameters.annotateScreenStream ? 'block' : 'none'}\" style=\"padding: 0; margin: 0;\" #canvasRef></canvas>\r\n  </div>\r\n</div>\r\n", styles: ["#whiteboardCanvas{border:1px solid #000;cursor:crosshair;background-color:#fff}.resize-handle,.move-handle{width:8px;height:8px;background:red;position:absolute}.move-handle{background:#00f}#textInput{display:none;position:absolute;z-index:10;width:200px}.shape-icon{width:20px;height:20px;color:#fff}.toolbar .btn-group button,.toolbar .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s}.toolbar .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbar .btn-group button:hover,.toolbar .dropdown-menu a:hover{background-color:#e3e7eb}.toolbar .btn-group button.active{background-color:#454d55}.toolbarScreen .btn-group button,.toolbarScreen .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:1px 2px;border-radius:4px;transition:background-color .2s;background-color:transparent;color:\"black\"}.toolbarScreen .btn-group button{color:#060606;border:none}.toolbarScreen .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbarScreen .btn-group button.active{background-color:#454d55}#toolbar,#toolbarScreen{transition:display .3s ease-in-out}#toolbarToggle,#toolbarToggleScreen{cursor:pointer;border:\"2px solid black\"!important;font-size:.8rem}#colorPicker,#colorPickerScreen{font-size:.8rem;padding:2px;width:32px;height:32px}#lineTypePicker{font-size:.8rem;padding:2px auto;width:32px;height:32px}.btnBoard{font-size:1rem;padding:2px;width:40px;height:40px;margin:2px}#lineTypePickerScreen{font-size:.7rem;padding:2px auto;width:28px;height:28px;background-color:#d6d1d166;color:#000;border-radius:4px}.toggle-icon{width:30px;height:30px;padding:0;margin:0}#toggleBackground.active{background-color:#fdfeff}.annotateScreenBtn{background-color:#2d2e2f!important;border:2px solid #000!important;color:green!important;font-size:.75rem}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$1.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Screenboard, decorators: [{
            type: Component,
            args: [{ selector: 'app-screenboard', standalone: true, imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div id=\"screenboard-interface\" *ngIf=\"showAspect\" style=\"position: relative; display: block; justify-content: center; align-items: center; background-color: transparent; z-index: 1000; width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: auto;\" #screenboardRef>\r\n  <div id=\"screenboardContent\" style=\"position: relative; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; overflow: hidden; top: 0; left: 0;\" #screenboardContentRef>\r\n    <button id=\"annotateScreen\" class=\"btn btn-primary btnBoardScreen annotateScreenBtn\" style=\"position: absolute; top: 5px; right: 10px; z-index: 1000;\" (click)=\"toggleAnnotate()\">\r\n      <fa-icon [icon]=\"faPencilAlt\" [ngStyle]=\"{'color': parameters.annotateScreenStream ? 'red' : 'green'}\"></fa-icon>\r\n    </button>\r\n\r\n    <button id=\"toolbarToggleScreen\" *ngIf=\"parameters.annotateScreenStream\" class=\"btn btnBoardScreen btn-primary\" style=\"position: absolute; top: 5px; right: 55px; z-index: 1000;\" (click)=\"toggleToolbar()\">\r\n      <fa-icon [icon]=\"toolbarVisible ? faChevronRight : faChevronLeft\"></fa-icon>\r\n    </button>\r\n\r\n    <div class=\"toolbarScreen mb-3\" id=\"toolbarScreen\" style=\"position: absolute; top: 5px; right: 105px; z-index: 1000; background-color: transparent;\" [style.display]=\"toolbarVisible ? 'block' : 'none'\">\r\n      <!-- Draw Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-secondary dropdown-toggle\" id=\"drawModeScreen\" (click)=\"handleDropdownClick('drawModeScreen')\">\r\n          <fa-icon [icon]=\"faPencilAlt\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'drawModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(3)\">XX-Small (3px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(6)\">X-Small (6px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(12)\">Small (12px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(18)\">Medium (18px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(24)\">Large (24px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(36)\">X-Large (36px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Freehand Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-dark dropdown-toggle\" id=\"freehandModeScreen\" (click)=\"handleDropdownClick('freehandModeScreen')\">\r\n          <fa-icon [icon]=\"faPaintBrush\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'freehandModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(5)\">X-Small (5px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(10)\">Small (10px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(20)\">Medium (20px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(40)\">Large (40px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(60)\">X-Large (60px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Shape Mode Dropdown with Images -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-dark dropdown-toggle\" id=\"shapeModeScreen\" (click)=\"handleDropdownClick('shapeModeScreen')\">\r\n          <fa-icon [icon]=\"faShapes\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'shapeModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('square')\">\r\n            <img src=\"https://mediasfu.com/images/svg/square.svg\" alt=\"Square\" class=\"shape-icon\" /> Square\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('rectangle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/rectangle.svg\" alt=\"Rectangle\" class=\"shape-icon\" /> Rectangle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('circle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/circle.svg\" alt=\"Circle\" class=\"shape-icon\" /> Circle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('triangle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/triangle.svg\" alt=\"Triangle\" class=\"shape-icon\" /> Triangle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('hexagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/hexagon.svg\" alt=\"Hexagon\" class=\"shape-icon\" /> Hexagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('pentagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/pentagon.svg\" alt=\"Pentagon\" class=\"shape-icon\" /> Pentagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('rhombus')\">\r\n            <img src=\"https://mediasfu.com/images/svg/rhombus.svg\" alt=\"Rhombus\" class=\"shape-icon\" /> Rhombus\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('octagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/octagon.svg\" alt=\"Octagon\" class=\"shape-icon\" /> Octagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('oval')\">\r\n            <img src=\"https://mediasfu.com/images/svg/oval.svg\" alt=\"Oval\" class=\"shape-icon\" /> Oval\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('parallelogram')\">\r\n            <img src=\"https://mediasfu.com/images/svg/parallelogram.svg\" alt=\"Parallelogram\" class=\"shape-icon\" /> Parallelogram\r\n          </button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Erase Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-danger dropdown-toggle\" id=\"eraseModeScreen\" (click)=\"handleDropdownClick('eraseModeScreen')\">\r\n          <fa-icon [icon]=\"faEraser\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'eraseModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(5)\">X-Small (5px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(10)\">Small (10px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(20)\">Medium (20px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(30)\">Large (30px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(60)\">X-Large (60px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Additional Toolbar Controls -->\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomResetScreen\" style=\"display: none;\">\r\n        <fa-icon [icon]=\"faSearch\"></fa-icon>\r\n      </button>\r\n\r\n      <input type=\"color\" class=\"btn\" id=\"colorPickerScreen\" [(ngModel)]=\"color\">\r\n      <select id=\"lineTypePickerScreen\" class=\"custom-select\" style=\"width: auto;\" [(ngModel)]=\"lineType\">\r\n        <option value=\"solid\">Solid</option>\r\n        <option value=\"dashed\">Dashed</option>\r\n        <option value=\"dotted\">Dotted</option>\r\n        <option value=\"dashDot\">Dash-Dot</option>\r\n      </select>\r\n    </div>\r\n\r\n    <canvas id=\"canvasRef\" width=\"1280\" height=\"720\" [ngStyle]=\"{'display': parameters.annotateScreenStream ? 'block' : 'none'}\" style=\"padding: 0; margin: 0;\" #canvasRef></canvas>\r\n  </div>\r\n</div>\r\n", styles: ["#whiteboardCanvas{border:1px solid #000;cursor:crosshair;background-color:#fff}.resize-handle,.move-handle{width:8px;height:8px;background:red;position:absolute}.move-handle{background:#00f}#textInput{display:none;position:absolute;z-index:10;width:200px}.shape-icon{width:20px;height:20px;color:#fff}.toolbar .btn-group button,.toolbar .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s}.toolbar .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbar .btn-group button:hover,.toolbar .dropdown-menu a:hover{background-color:#e3e7eb}.toolbar .btn-group button.active{background-color:#454d55}.toolbarScreen .btn-group button,.toolbarScreen .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:1px 2px;border-radius:4px;transition:background-color .2s;background-color:transparent;color:\"black\"}.toolbarScreen .btn-group button{color:#060606;border:none}.toolbarScreen .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbarScreen .btn-group button.active{background-color:#454d55}#toolbar,#toolbarScreen{transition:display .3s ease-in-out}#toolbarToggle,#toolbarToggleScreen{cursor:pointer;border:\"2px solid black\"!important;font-size:.8rem}#colorPicker,#colorPickerScreen{font-size:.8rem;padding:2px;width:32px;height:32px}#lineTypePicker{font-size:.8rem;padding:2px auto;width:32px;height:32px}.btnBoard{font-size:1rem;padding:2px;width:40px;height:40px;margin:2px}#lineTypePickerScreen{font-size:.7rem;padding:2px auto;width:28px;height:28px;background-color:#d6d1d166;color:#000;border-radius:4px}.toggle-icon{width:30px;height:30px;padding:0;margin:0}#toggleBackground.active{background-color:#fdfeff}.annotateScreenBtn{background-color:#2d2e2f!important;border:2px solid #000!important;color:green!important;font-size:.75rem}\n"] }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customWidth']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customHeight']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showAspect']
                }] }], propDecorators: { customWidth: [{
                type: Input
            }], customHeight: [{
                type: Input
            }], parameters: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], canvasRef: [{
                type: ViewChild,
                args: ['canvasRef']
            }], screenboardRef: [{
                type: ViewChild,
                args: ['screenboardRef']
            }], screenboardContentRef: [{
                type: ViewChild,
                args: ['screenboardContentRef']
            }] } });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * @fileoverview ScreenboardModal component for handling screen annotation and modal visibility.
 *
 * @component
 * @selector app-screenboard-modal
 * @standalone true
 * @templateUrl ./screenboard-modal.component.html
 * @styleUrls ./screenboard-modal.component.css
 * @imports CommonModule, FormsModule, FontAwesomeModule
 *
 * @class ScreenboardModal
 * @implements OnInit, OnDestroy, OnChanges, AfterViewInit
 *
 * @description
 * This component is responsible for managing the screen annotation modal, including showing and hiding the modal,
 * handling screen annotations, and managing media streams.
 *
 * @property {ScreenboardModalParameters} parameters - Input parameter for screen annotation modal.
 * @property {boolean} isVisible - Input flag to control the visibility of the modal.
 * @property {() => void} onClose - Input callback function to be called when the modal is closed.
 * @property {string} position - Input string to set the position of the modal.
 * @property {string} backgroundColor - Input string to set the background color of the modal.
 *
 * @property {ElementRef<HTMLVideoElement>} screenVideoRef - ViewChild reference to the screen video element.
 * @property {ElementRef<HTMLCanvasElement>} screenCanvasRef - ViewChild reference to the screen canvas element.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for the close button.
 *
 * @property {any} annotationInterval - Interval for annotation updates.
 * @property {any} annotationCheckInterval - Interval for checking annotation updates.
 * @property {MediaStream | null} clonedStreamScreen - Cloned media stream for screen sharing.
 * @property {CanvasRenderingContext2D | null} ctx - Canvas rendering context.
 *
 * @method ngOnInit - Initialization logic that does not depend on the view.
 * @method ngOnDestroy - Cleanup logic when the component is destroyed.
 * @method ngOnChanges - Logic to handle changes in input properties.
 * @method ngAfterViewInit - Logic that requires view access.
 * @method showModal - Method to show the modal and handle screen annotation setup.
 * @method hideModal - Method to hide the modal and cleanup screen annotation.
 * @method annotatationPreview - Method to handle the preview of screen annotations.
 * @method handleScreenTransport - Method to handle screen transport logic.
 * @method stopAnnotation - Method to stop the screen annotation.
 * @method stopAllTracks - Method to stop all media tracks.
 */
class ScreenboardModal {
    parameters = {};
    isVisible = false;
    onClose;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    screenVideoRef;
    screenCanvasRef;
    faTimes = faTimes;
    annotationInterval;
    annotationCheckInterval;
    clonedStreamScreen = null;
    ctx = null;
    ngOnInit() {
        // Initialization logic that does not depend on the view
    }
    ngOnDestroy() {
        this.stopAnnotation();
    }
    ngOnChanges(changes) {
        if (changes['isVisible']) {
            this.isVisible = changes['isVisible'].currentValue;
            if (this.isVisible) {
                // In case isVisible changes after view init
                if (this.screenCanvasRef && this.screenVideoRef) {
                    this.showModal();
                }
                else {
                    setTimeout(() => {
                        if (this.screenCanvasRef && this.screenVideoRef) {
                            this.showModal();
                        }
                    }, 100);
                }
            }
            else {
                if (this.screenCanvasRef && this.screenVideoRef) {
                    this.hideModal();
                }
            }
        }
    }
    ngAfterViewInit() {
        // Move logic that requires view access here
    }
    showModal = async () => {
        try {
            this.parameters = this.parameters.getUpdatedAllParams();
            const { annotateScreenStream, shared, createSendTransport, prepopulateUserMedia, hostLabel } = this.parameters;
            const annotate = annotateScreenStream;
            const screenVideo = this.screenVideoRef.nativeElement;
            if (annotate && shared) {
                screenVideo.classList.remove('d-none');
                await this.annotatationPreview();
                setTimeout(async () => {
                    if (!this.parameters.transportCreated) {
                        await createSendTransport({ option: 'screen', parameters: this.parameters });
                    }
                    else {
                        try {
                            await this.handleScreenTransport();
                            await this.parameters.sleep({ ms: 250 });
                        }
                        catch {
                            /* handle error */
                        }
                    }
                    await this.parameters.connectSendTransportScreen({
                        stream: this.parameters.processedScreenStream,
                        parameters: this.parameters,
                    });
                    await prepopulateUserMedia({ name: hostLabel, parameters: this.parameters });
                }, 100);
            }
            else {
                screenVideo.classList.add('d-none');
            }
        }
        catch {
            /* handle error */
        }
    };
    hideModal = async () => {
        this.parameters = this.parameters.getUpdatedAllParams();
        const { annotateScreenStream, shared, createSendTransport, disconnectSendTransportScreen, stopShareScreen, prepopulateUserMedia, hostLabel, } = this.parameters;
        const annotate = annotateScreenStream;
        const screenVideo = this.screenVideoRef && this.screenVideoRef.nativeElement;
        try {
            if (!annotate) {
                try {
                    await this.stopAnnotation();
                }
                catch {
                    /* handle error */
                }
                if (shared) {
                    if (!this.parameters.transportCreated) {
                        await createSendTransport({ option: 'screen', parameters: this.parameters });
                    }
                    else {
                        try {
                            await disconnectSendTransportScreen({ parameters: this.parameters });
                            await this.parameters.sleep({ ms: 500 });
                        }
                        catch {
                            /* handle error */
                        }
                        if (this.parameters.localStreamScreen &&
                            this.parameters.localStreamScreen.getVideoTracks().length > 0 &&
                            this.parameters.localStreamScreen.getVideoTracks()[0].readyState === 'ended') {
                            this.parameters.localStreamScreen.removeTrack(this.parameters.localStreamScreen.getVideoTracks()[0]);
                            if (this.clonedStreamScreen) {
                                this.parameters.localStreamScreen.addTrack(this.clonedStreamScreen.getVideoTracks()[0].clone());
                            }
                            this.parameters.updateLocalStreamScreen(this.parameters.localStreamScreen);
                        }
                        if (this.clonedStreamScreen) {
                            this.clonedStreamScreen.getVideoTracks()[0].onended = async () => {
                                await disconnectSendTransportScreen({ parameters: this.parameters });
                                await stopShareScreen({ parameters: this.parameters });
                            };
                        }
                        await this.parameters.connectSendTransportScreen({
                            stream: this.parameters.localStreamScreen,
                            parameters: this.parameters,
                        });
                    }
                }
                else {
                    await this.stopAllTracks();
                }
                await prepopulateUserMedia({ name: hostLabel, parameters: this.parameters });
            }
            screenVideo && screenVideo.classList.add('d-none');
            if (this.parameters.mainScreenCanvas && this.screenCanvasRef) {
                this.screenCanvasRef.nativeElement.classList.add('d-none');
            }
            this.onClose();
        }
        catch {
            /* handle error */
        }
    };
    annotatationPreview = async () => {
        const screenVideo = this.screenVideoRef.nativeElement;
        if (!this.parameters.mainScreenCanvas) {
            this.parameters.mainScreenCanvas = this.screenCanvasRef.nativeElement;
            this.parameters.updateMainScreenCanvas(this.parameters.mainScreenCanvas);
        }
        const annotate = this.parameters.annotateScreenStream;
        if (annotate &&
            (!this.clonedStreamScreen ||
                (this.clonedStreamScreen &&
                    this.clonedStreamScreen.getVideoTracks().length > 0 &&
                    this.clonedStreamScreen.getVideoTracks()[0].readyState === 'ended'))) {
            const originalTrack = this.parameters.localStreamScreen.getVideoTracks()[0];
            const originalSettings = originalTrack.getSettings();
            const cloned = originalTrack.clone();
            await cloned.applyConstraints({
                width: originalSettings.width,
                height: originalSettings.height,
                frameRate: originalSettings.frameRate,
                aspectRatio: originalSettings.aspectRatio,
            });
            this.clonedStreamScreen = new MediaStream([cloned]);
        }
        if (this.clonedStreamScreen &&
            this.parameters.localStreamScreen &&
            this.parameters.localStreamScreen.getVideoTracks().length > 0 &&
            this.parameters.localStreamScreen.getVideoTracks()[0].readyState === 'ended') {
            this.parameters.localStreamScreen.removeTrack(this.parameters.localStreamScreen.getVideoTracks()[0]);
            this.parameters.localStreamScreen.addTrack(this.clonedStreamScreen.getVideoTracks()[0].clone());
        }
        if (this.clonedStreamScreen) {
            this.clonedStreamScreen.getVideoTracks()[0].onended = async () => {
                await this.parameters.disconnectSendTransportScreen({ parameters: this.parameters });
                await this.parameters.stopShareScreen({ parameters: this.parameters });
            };
        }
        const mediaCanvas = this.parameters.mainScreenCanvas;
        const ctx = mediaCanvas.getContext('2d');
        mediaCanvas.width = this.parameters.localStreamScreen.getVideoTracks()[0].getSettings().width;
        mediaCanvas.height = this.parameters
            .localStreamScreen.getVideoTracks()[0]
            .getSettings().height;
        if (!annotate) {
            this.parameters.processedScreenStream = null;
            this.parameters.updateProcessedScreenStream(null);
        }
        const captureStream = () => {
            const stream = mediaCanvas.captureStream(30);
            this.annotationCheckInterval = setInterval(() => {
                const params = this.parameters.getUpdatedAllParams();
                canvasElement = params.canvasScreenboard;
                const height = canvasElement.height;
                const width = canvasElement.width;
                const refHeight = params.localStreamScreen.getVideoTracks()[0].getSettings().height;
                const refWidth = params.localStreamScreen.getVideoTracks()[0].getSettings().width;
                if (height !== refHeight || width !== refWidth) {
                    canvasElement.width = refWidth;
                    canvasElement.height = refHeight;
                    mediaCanvas.width = refWidth;
                    mediaCanvas.height = refHeight;
                }
            }, 1000);
            this.annotationInterval = setInterval(() => {
                drawCombined();
            }, 30);
            return stream;
        };
        const annotateImage = async () => {
            this.parameters.processedScreenStream = await captureStream();
            this.parameters.updateProcessedScreenStream(this.parameters.processedScreenStream);
        };
        const annotateVideo = this.clonedStreamScreen;
        if (annotateVideo && annotate) {
            screenVideo.style.width = `${annotateVideo.getVideoTracks()[0].getSettings().width}px`;
            screenVideo.style.height = `${annotateVideo.getVideoTracks()[0].getSettings().height}px`;
            screenVideo.srcObject = annotateVideo;
            await annotateImage();
        }
        let canvasElement = this.parameters.getUpdatedAllParams().canvasScreenboard;
        canvasElement.width = mediaCanvas.width;
        canvasElement.height = mediaCanvas.height;
        const drawCombined = () => {
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            ctx.drawImage(screenVideo, 0, 0, canvasElement.width, canvasElement.height);
            ctx.drawImage(canvasElement, 0, 0, canvasElement.width, canvasElement.height);
            ctx.restore();
        };
    };
    handleScreenTransport = async () => {
        if (this.parameters.localStreamScreen.getVideoTracks().length > 0 &&
            this.parameters.localStreamScreen.getVideoTracks()[0].id ===
                this.parameters.screenProducer?.track.id) {
            if (this.clonedStreamScreen &&
                this.clonedStreamScreen.getVideoTracks().length > 0 &&
                this.clonedStreamScreen.getVideoTracks()[0].readyState === 'ended') {
                this.clonedStreamScreen.removeTrack(this.clonedStreamScreen.getVideoTracks()[0]);
                this.clonedStreamScreen.addTrack(this.parameters.localStreamScreen.getVideoTracks()[0].clone());
            }
            this.parameters.localStreamScreen.removeTrack(this.parameters.localStreamScreen.getVideoTracks()[0]);
            this.parameters.localStreamScreen.addTrack(this.clonedStreamScreen.getVideoTracks()[0].clone());
        }
        await this.parameters.disconnectSendTransportScreen({ parameters: this.parameters });
    };
    stopAnnotation = async () => {
        if (this.annotationInterval) {
            clearInterval(this.annotationInterval);
            clearInterval(this.annotationCheckInterval);
            this.annotationInterval = null;
            this.annotationCheckInterval = null;
        }
        if (this.parameters.processedScreenStream) {
            this.parameters.processedScreenStream
                .getTracks()
                .forEach((track) => track.stop());
            this.parameters.processedScreenStream = null;
            this.parameters.updateProcessedScreenStream(null);
        }
        if (this.parameters.mainScreenCanvas) {
            this.parameters.mainScreenCanvas
                ?.getContext('2d')
                .clearRect(0, 0, this.parameters.mainScreenCanvas.width, this.parameters.mainScreenCanvas.height);
        }
    };
    stopAllTracks = async () => {
        try {
            if (this.parameters.localStreamScreen &&
                this.parameters.localStreamScreen.getVideoTracks().length > 0) {
                this.parameters.localStreamScreen
                    .getVideoTracks()
                    .forEach((track) => track.stop());
                this.parameters.updateLocalStreamScreen(null);
            }
            else {
                this.parameters.updateLocalStreamScreen(null);
            }
        }
        catch {
            /* handle error */
        }
        try {
            if (this.clonedStreamScreen && this.clonedStreamScreen.getVideoTracks().length > 0) {
                this.clonedStreamScreen.getVideoTracks().forEach((track) => track.stop());
            }
        }
        catch {
            /* handle error */
        }
        try {
            if (this.parameters.processedScreenStream) {
                this.parameters.processedScreenStream
                    .getTracks()
                    .forEach((track) => track.stop());
                this.parameters.updateProcessedScreenStream(null);
            }
        }
        catch {
            /* handle error */
        }
        this.clonedStreamScreen = null;
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ScreenboardModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ScreenboardModal, isStandalone: true, selector: "app-screenboard-modal", inputs: { parameters: "parameters", isVisible: "isVisible", onClose: "onClose", position: "position", backgroundColor: "backgroundColor" }, viewQueries: [{ propertyName: "screenVideoRef", first: true, predicate: ["screenVideo"], descendants: true }, { propertyName: "screenCanvasRef", first: true, predicate: ["screenCanvas"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Screen Annotation</div>\r\n      <div class=\"modal-close\" (click)=\"hideModal()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <video #screenVideo id=\"screenVideo\" class=\"d-none\" autoplay></video>\r\n      <canvas #screenCanvas id=\"screenCanvas\"></canvas>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:500px;max-height:75%;overflow-y:auto;overflow-x:hidden;top:10px;right:10px}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.modal-close{padding:5px}.modal-body{flex:1}#screenCanvas{width:100%;height:auto}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FormsModule }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ScreenboardModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-screenboard-modal', standalone: true, imports: [CommonModule, FormsModule, FontAwesomeModule], template: "<div *ngIf=\"isVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Screen Annotation</div>\r\n      <div class=\"modal-close\" (click)=\"hideModal()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <video #screenVideo id=\"screenVideo\" class=\"d-none\" autoplay></video>\r\n      <canvas #screenCanvas id=\"screenCanvas\"></canvas>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:500px;max-height:75%;overflow-y:auto;overflow-x:hidden;top:10px;right:10px}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.modal-close{padding:5px}.modal-body{flex:1}#screenCanvas{width:100%;height:auto}\n"] }]
        }], propDecorators: { parameters: [{
                type: Input
            }], isVisible: [{
                type: Input
            }], onClose: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], screenVideoRef: [{
                type: ViewChild,
                args: ['screenVideo']
            }], screenCanvasRef: [{
                type: ViewChild,
                args: ['screenCanvas']
            }] } });

class GeneratePageContent {
    /**
     * Generates the content for a specific page.
     *
     * @param {Object} options - The options for generating page content.
     * @param {number | string} options.page - The page number to generate content for.
     * @param {Object} options.parameters - The parameters required for generating content.
     * @param {Array} options.parameters.paginatedStreams - The streams to be paginated.
     * @param {number} options.parameters.currentUserPage - The current page of the user.
     * @param {Function} options.parameters.updateMainWindow - Function to update the main window flag.
     * @param {Function} options.parameters.updateCurrentUserPage - Function to update the current user page.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window update flag.
     * @param {Function} options.parameters.dispStreams - Function to display streams for the specified page.
     * @param {number} [options.breakRoom=-1] - The break room identifier.
     * @param {boolean} [options.inBreakRoom=false] - Flag indicating if the user is in a break room.
     * @returns {Promise<void>} A promise that resolves when the content generation is complete.
     * @throws {Error} Throws an error if content generation fails.
     */
    async generatePageContent({ page, parameters, breakRoom = -1, inBreakRoom = false, }) {
        try {
            // Destructure parameters
            parameters = parameters.getUpdatedAllParams();
            let { paginatedStreams, currentUserPage, updateMainWindow, updateCurrentUserPage, updateUpdateMainWindow, 
            // mediasfu functions
            dispStreams, } = parameters;
            // Convert page to an integer
            page = parseInt(page.toString(), 10);
            // Update current user page
            currentUserPage = page;
            updateCurrentUserPage(currentUserPage);
            // Update main window flag
            updateMainWindow = true;
            updateUpdateMainWindow(updateMainWindow);
            // Display streams for the specified page
            await dispStreams({
                lStreams: paginatedStreams[page],
                ind: page,
                parameters,
                breakRoom,
                inBreakRoom,
            });
        }
        catch (error) {
            // Handle errors during content generation
            console.log('Error generating page content:', error.message);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GeneratePageContent, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GeneratePageContent, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GeneratePageContent, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Pagination component for displaying and handling pagination controls.
 *
 * @component
 * @selector app-pagination
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule]
 *
 * @description
 * This component renders pagination controls with customizable styles and behavior.
 * It supports horizontal and vertical layouts, different positions, and dynamic data.
 *
 * @example
 * <app-pagination
 *   [totalPages]="10"
 *   [currentUserPage]="1"
 *   [handlePageChange]="handlePageChange"
 *   [position]="'middle'"
 *   [location]="'bottom'"
 *   [direction]="'horizontal'"
 *   [backgroundColor]="'#ffffff'"
 *   [paginationHeight]="40"
 *   [showAspect]="true"
 *   [parameters]="paginationParameters">
 * </app-pagination>
 *
 * @input {number} totalPages - Total number of pages.
 * @input {number} currentUserPage - Current active page.
 * @input {Function} handlePageChange - Function to handle page change.
 * @input {'left' | 'middle' | 'right' | string} position - Position of the pagination controls.
 * @input {'top' | 'middle' | 'bottom' | string} location - Location of the pagination controls.
 * @input {'horizontal' | 'vertical' | string} direction - Direction of the pagination controls.
 * @input {any} buttonsContainerStyle - Custom styles for the buttons container.
 * @input {any} activePageStyle - Custom styles for the active page button.
 * @input {any} inactivePageStyle - Custom styles for the inactive page buttons.
 * @input {string} backgroundColor - Background color of the pagination controls.
 * @input {number} paginationHeight - Height of the pagination controls.
 * @input {boolean} showAspect - Flag to show or hide the pagination controls.
 * @input {PaginationParameters} parameters - Additional parameters for pagination.
 *
 * @method ngOnInit - Initializes the component and sets up initial data.
 * @method ngOnChanges - Handles changes to input properties and updates data accordingly.
 * @method handleClick - Handles click events on pagination buttons and performs necessary actions.
 * @method getPageStyle - Returns the style for a given page button based on its state.
 * @method isBreakoutRoom - Determines if a given item represents a breakout room.
 * @method getDisplayItem - Returns the display text for a given item.
 */
class Pagination {
    generatePageContentService;
    totalPages = 0;
    currentUserPage = 0;
    handlePageChange;
    position = 'middle';
    location = 'middle';
    direction = 'horizontal';
    buttonsContainerStyle = {};
    activePageStyle = { backgroundColor: '#2c678f' };
    inactivePageStyle = {};
    backgroundColor = '#ffffff';
    paginationHeight = 40;
    showAspect = true;
    parameters = {};
    constructor(generatePageContentService) {
        this.generatePageContentService = generatePageContentService;
    }
    faStar = faStar;
    faLock = faLock;
    data = [];
    ngOnInit() {
        this.data = Array.from({ length: this.totalPages + 1 }, (_, index) => index);
        this.componentSizes = this.parameters.componentSizes;
        if (!this.handlePageChange) {
            this.handlePageChange = this.generatePageContentService.generatePageContent.bind(this.generatePageContentService);
        }
    }
    ngOnChanges(changes) {
        if (changes['totalPages'] || changes['currentUserPage']) {
            this.data = Array.from({ length: this.totalPages + 1 }, (_, index) => index);
        }
    }
    handleClick = async (page) => {
        if (page == this.currentUserPage) {
            return;
        }
        this.parameters = this.parameters.getUpdatedAllParams();
        const params = { ...this.parameters };
        this.componentSizes = params.componentSizes;
        if (this.parameters.breakOutRoomStarted && !this.parameters.breakOutRoomEnded && page !== 0) {
            const roomMember = this.parameters.breakoutRooms.find((r) => r.find((p) => p.name == this.parameters.member));
            const pageInt = page - this.parameters.mainRoomsLength;
            let memberBreakRoom = -1;
            if (roomMember) {
                memberBreakRoom = this.parameters.breakoutRooms.indexOf(roomMember);
            }
            if ((memberBreakRoom == -1 || memberBreakRoom !== pageInt) && pageInt >= 0) {
                if (this.parameters.islevel !== '2') {
                    if (this.parameters.showAlert) {
                        this.parameters.showAlert({
                            message: `You are not part of the breakout room ${pageInt + 1}.`,
                            type: 'danger',
                        });
                    }
                    return;
                }
                await this.handlePageChange({
                    page,
                    parameters: params,
                    breakRoom: pageInt,
                    inBreakRoom: true,
                });
                if (this.parameters.hostNewRoom !== pageInt) {
                    this.parameters.socket.emit('updateHostBreakout', {
                        newRoom: pageInt,
                        roomName: this.parameters.roomName,
                    });
                }
            }
            else {
                await this.handlePageChange({
                    page,
                    parameters: params,
                    breakRoom: pageInt,
                    inBreakRoom: pageInt >= 0,
                });
                if (this.parameters.islevel == '2' && this.parameters.hostNewRoom !== -1) {
                    this.parameters.socket.emit('updateHostBreakout', {
                        prevRoom: this.parameters.hostNewRoom,
                        newRoom: -1,
                        roomName: this.parameters.roomName,
                    });
                }
            }
        }
        else {
            await this.handlePageChange({ page, parameters: params, breakRoom: 0, inBreakRoom: false });
            if (this.parameters.islevel == '2' && this.parameters.hostNewRoom !== -1) {
                this.parameters.socket.emit('updateHostBreakout', {
                    prevRoom: this.parameters.hostNewRoom,
                    newRoom: -1,
                    roomName: this.parameters.roomName,
                });
            }
        }
    };
    componentSizes = {};
    getPageStyle(item) {
        return item == this.currentUserPage ? this.activePageStyle : this.inactivePageStyle;
    }
    isBreakoutRoom = (item) => {
        this.parameters = this.parameters.getUpdatedAllParams();
        return (this.parameters.breakOutRoomStarted &&
            !this.parameters.breakOutRoomEnded &&
            item >= this.parameters.mainRoomsLength);
    };
    getDisplayItem(item) {
        const roomNumber = item - (this.parameters.mainRoomsLength - 1);
        if (this.isBreakoutRoom(item)) {
            if (this.parameters.memberRoom + 1 !== roomNumber) {
                return `Room ${roomNumber}`;
            }
            else {
                return `Room ${roomNumber}`;
            }
        }
        return item.toString();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Pagination, deps: [{ token: GeneratePageContent }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: Pagination, isStandalone: true, selector: "app-pagination", inputs: { totalPages: "totalPages", currentUserPage: "currentUserPage", handlePageChange: "handlePageChange", position: "position", location: "location", direction: "direction", buttonsContainerStyle: "buttonsContainerStyle", activePageStyle: "activePageStyle", inactivePageStyle: "inactivePageStyle", backgroundColor: "backgroundColor", paginationHeight: "paginationHeight", showAspect: "showAspect", parameters: "parameters" }, usesOnChanges: true, ngImport: i0, template: `
    <div
      [ngStyle]="{
        'background-color': backgroundColor,
        'justify-content': position == 'middle' ? 'space-evenly' : position == 'left' ? 'flex-start' : 'flex-end',
        'align-items': location == 'middle' ? 'center' : location == 'top' ? 'flex-start' : 'flex-end',
        'padding': '0',
        'margin': '0',
        'min-height': direction == 'horizontal' ? paginationHeight + 'px' : componentSizes.otherHeight + 'px',
        'min-width': direction == 'horizontal' ? componentSizes.otherWidth + 'px' : paginationHeight + 'px',
        'width': direction == 'horizontal' ? '100%' : paginationHeight + 'px',
        'height': direction == 'horizontal' ? paginationHeight + 'px' : '100%',
        'display': showAspect ? 'flex' : 'none',
        'max-height': direction == 'horizontal' ? paginationHeight + 'px' : '100%',
        'max-width': direction == 'horizontal' ? '100%' : paginationHeight + 'px',
        'flex-direction': direction == 'vertical' ? 'column' : 'row',
        'overflow-x': 'auto',
      }"
    >
      <ng-container *ngFor="let item of data; let index = index">
        <button
          *ngIf="item == 0"
          [ngClass]="{ active: item == currentUserPage }"
          [ngStyle]="getPageStyle(item)"
          (click)="handleClick(item)"
        >
          <fa-icon
            [icon]="faStar"
            size="lg"
            [style.color]="item == currentUserPage ? 'yellow' : 'gray'"
          ></fa-icon>
        </button>
        <button
          *ngIf="item !== 0"
          [ngClass]="{ active: item == currentUserPage }"
          [ngStyle]="getPageStyle(item)"
          (click)="handleClick(item)"
        >
          <span
            *ngIf="!isBreakoutRoom(item)"
            class="pageText"
            [ngStyle]="{ color: item == currentUserPage ? '#ffffff' : '#000000' }"
            >{{ item }}</span
          >
          <span
            *ngIf="isBreakoutRoom(item)"
            class="pageText"
            [ngStyle]="{ color: item == currentUserPage ? '#ffffff' : '#000000' }"
            >{{ getDisplayItem(item) }}
            <fa-icon
              *ngIf="
                parameters.memberRoom + 1 !== item - (parameters.mainRoomsLength - 1) &&
                parameters.islevel !== '2'
              "
              [icon]="faLock"
            ></fa-icon
          ></span>
        </button>
      </ng-container>
    </div>
  `, isInline: true, styles: [".pageButton.active{background-color:#2c678f}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Pagination, decorators: [{
            type: Component,
            args: [{ selector: 'app-pagination', standalone: true, imports: [CommonModule, FontAwesomeModule], template: `
    <div
      [ngStyle]="{
        'background-color': backgroundColor,
        'justify-content': position == 'middle' ? 'space-evenly' : position == 'left' ? 'flex-start' : 'flex-end',
        'align-items': location == 'middle' ? 'center' : location == 'top' ? 'flex-start' : 'flex-end',
        'padding': '0',
        'margin': '0',
        'min-height': direction == 'horizontal' ? paginationHeight + 'px' : componentSizes.otherHeight + 'px',
        'min-width': direction == 'horizontal' ? componentSizes.otherWidth + 'px' : paginationHeight + 'px',
        'width': direction == 'horizontal' ? '100%' : paginationHeight + 'px',
        'height': direction == 'horizontal' ? paginationHeight + 'px' : '100%',
        'display': showAspect ? 'flex' : 'none',
        'max-height': direction == 'horizontal' ? paginationHeight + 'px' : '100%',
        'max-width': direction == 'horizontal' ? '100%' : paginationHeight + 'px',
        'flex-direction': direction == 'vertical' ? 'column' : 'row',
        'overflow-x': 'auto',
      }"
    >
      <ng-container *ngFor="let item of data; let index = index">
        <button
          *ngIf="item == 0"
          [ngClass]="{ active: item == currentUserPage }"
          [ngStyle]="getPageStyle(item)"
          (click)="handleClick(item)"
        >
          <fa-icon
            [icon]="faStar"
            size="lg"
            [style.color]="item == currentUserPage ? 'yellow' : 'gray'"
          ></fa-icon>
        </button>
        <button
          *ngIf="item !== 0"
          [ngClass]="{ active: item == currentUserPage }"
          [ngStyle]="getPageStyle(item)"
          (click)="handleClick(item)"
        >
          <span
            *ngIf="!isBreakoutRoom(item)"
            class="pageText"
            [ngStyle]="{ color: item == currentUserPage ? '#ffffff' : '#000000' }"
            >{{ item }}</span
          >
          <span
            *ngIf="isBreakoutRoom(item)"
            class="pageText"
            [ngStyle]="{ color: item == currentUserPage ? '#ffffff' : '#000000' }"
            >{{ getDisplayItem(item) }}
            <fa-icon
              *ngIf="
                parameters.memberRoom + 1 !== item - (parameters.mainRoomsLength - 1) &&
                parameters.islevel !== '2'
              "
              [icon]="faLock"
            ></fa-icon
          ></span>
        </button>
      </ng-container>
    </div>
  `, styles: [".pageButton.active{background-color:#2c678f}\n"] }]
        }], ctorParameters: () => [{ type: GeneratePageContent }], propDecorators: { totalPages: [{
                type: Input
            }], currentUserPage: [{
                type: Input
            }], handlePageChange: [{
                type: Input
            }], position: [{
                type: Input
            }], location: [{
                type: Input
            }], direction: [{
                type: Input
            }], buttonsContainerStyle: [{
                type: Input
            }], activePageStyle: [{
                type: Input
            }], inactivePageStyle: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], paginationHeight: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], parameters: [{
                type: Input
            }] } });

/**
 * @component FlexibleGrid
 *
 * A flexible grid component that dynamically renders a grid of components based on the provided inputs.
 *
 * @selector app-flexible-grid
 *
 * @inputs
 * - `customWidth` (number): The custom width for each grid item in pixels. Default is 0.
 * - `customHeight` (number): The custom height for each grid item in pixels. Default is 0.
 * - `rows` (number): The number of rows in the grid. Default is 0.
 * - `columns` (number): The number of columns in the grid. Default is 0.
 * - `componentsToRender` ({ component: any, inputs?: any }[]): An array of components to render in the grid, each with optional inputs.
 * - `backgroundColor` (string): The background color for each grid item. Default is 'transparent'.
 *
 * @methods
 * - `ngOnInit()`: Lifecycle hook that is called after the component is initialized. It generates the grid.
 * - `ngOnChanges(changes: SimpleChanges)`: Lifecycle hook that is called when any data-bound property of the component changes. It regenerates the grid if `columns`, `componentsToRender`, or `rows` change.
 * - `generateGrid()`: Generates the grid based on the number of rows and columns, and the components to render.
 * - `getGridItemStyle()`: Returns the style object for each grid item, including custom width, height, background color, margin, padding, and border radius.
 * - `createInjector(inputs: any)`: Creates and caches an injector for the given inputs to be used with `ngComponentOutlet`.
 *
 * @dependencies
 * - `CommonModule`: Angular's common module is imported for common directives.
 * - `Injector`: Angular's dependency injection system is used to create injectors for dynamic components.
 */
class FlexibleGrid {
    injector;
    customWidth = 0;
    customHeight = 0;
    rows = 0;
    columns = 0;
    componentsToRender = [];
    backgroundColor = 'transparent';
    grid = [];
    injectorCache = new WeakMap();
    constructor(injector) {
        this.injector = injector;
    }
    ngOnInit() {
        this.generateGrid();
    }
    ngOnChanges(changes) {
        if (changes['columns'] || changes['componentsToRender'] || changes['rows']) {
            this.generateGrid();
        }
    }
    generateGrid() {
        this.grid = [];
        for (let row = 0; row < this.rows; row++) {
            const rowComponents = [];
            for (let col = 0; col < this.columns; col++) {
                const index = row * this.columns + col;
                const component = this.componentsToRender[index];
                rowComponents.push(component);
            }
            this.grid.push(rowComponents);
        }
    }
    getGridItemStyle() {
        return {
            flex: 1,
            width: this.customWidth + 'px',
            height: this.customHeight + 'px',
            backgroundColor: this.backgroundColor,
            margin: '1px',
            padding: 0,
            borderRadius: '8px',
        };
    }
    createInjector(inputs) {
        if (!this.injectorCache.has(inputs)) {
            const injector = Injector.create({
                providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
                parent: this.injector,
            });
            this.injectorCache.set(inputs, injector);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.injectorCache.get(inputs);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: FlexibleGrid, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: FlexibleGrid, isStandalone: true, selector: "app-flexible-grid", inputs: { customWidth: "customWidth", customHeight: "customHeight", rows: "rows", columns: "columns", componentsToRender: "componentsToRender", backgroundColor: "backgroundColor" }, usesOnChanges: true, ngImport: i0, template: `
    <div style="padding: 0;">
      <div
        *ngFor="let rowComponents of grid; let rowIndex = index"
        style="display: flex; flex-direction: row;"
      >
        <div
          *ngFor="let component of rowComponents; let colIndex = index"
          [ngStyle]="getGridItemStyle()"
        >
          <ng-container
            *ngComponentOutlet="component.component; injector: createInjector(component.inputs)"
          ></ng-container>
        </div>
      </div>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: FlexibleGrid, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-flexible-grid',
                    standalone: true,
                    imports: [CommonModule],
                    template: `
    <div style="padding: 0;">
      <div
        *ngFor="let rowComponents of grid; let rowIndex = index"
        style="display: flex; flex-direction: row;"
      >
        <div
          *ngFor="let component of rowComponents; let colIndex = index"
          [ngStyle]="getGridItemStyle()"
        >
          <ng-container
            *ngComponentOutlet="component.component; injector: createInjector(component.inputs)"
          ></ng-container>
        </div>
      </div>
    </div>
  `,
                }]
        }], ctorParameters: () => [{ type: i0.Injector }], propDecorators: { customWidth: [{
                type: Input
            }], customHeight: [{
                type: Input
            }], rows: [{
                type: Input
            }], columns: [{
                type: Input
            }], componentsToRender: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }] } });

/**
 * Component for displaying a flexible video grid.
 *
 * @component
 * @selector app-flexible-video
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * <div>
 *   <!-- Dynamic styles and layout for video grid -->
 *   <div *ngFor="let rowComponents of grid; let rowIndex = index">
 *     <div *ngFor="let component of rowComponents; let colIndex = index">
 *       <ng-container *ngComponentOutlet="component.component; injector: createInjector(component.inputs)"></ng-container>
 *     </div>
 *   </div>
 *   <div *ngIf="Screenboard && Screenboard.component">
 *     <ng-container *ngComponentOutlet="Screenboard.component; injector: createInjector(Screenboard.inputs)"></ng-container>
 *   </div>
 * </div>
 *
 * @class FlexibleVideo
 * @implements OnInit, OnChanges
 *
 * @property {number} customWidth - Custom width for the video grid.
 * @property {number} customHeight - Custom height for the video grid.
 * @property {number} rows - Number of rows in the video grid.
 * @property {number} columns - Number of columns in the video grid.
 * @property {Array<{ component: ComponentType<any>, inputs: any }>} componentsToRender - Components to render in the grid.
 * @property {boolean} showAspect - Flag to show or hide the aspect ratio.
 * @property {string} [backgroundColor='transparent'] - Background color for the video grid.
 * @property {{ component: ComponentType<any>, inputs: any }} [Screenboard] - Screenboard component to overlay on the grid.
 * @property {boolean} [annotateScreenStream=false] - Flag to annotate the screen stream.
 * @property {MediaStream} [localStreamScreen] - Local media stream for the screen.
 *
 * @property {number} key - Key for tracking changes.
 * @property {number} cardWidth - Width of each card in the grid.
 * @property {number} cardHeight - Height of each card in the grid.
 * @property {number} cardTop - Top position of each card in the grid.
 * @property {number} cardLeft - Left position of each card in the grid.
 * @property {number} canvasLeft - Left position of the canvas.
 * @property {any[][]} grid - Grid structure for the components.
 *
 * @constructor
 * @param {Injector} injector - Angular injector for dependency injection.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes.
 * @method generateGrid - Generates the grid structure based on rows and columns.
 * @method createInjector - Creates an injector for the given inputs.
 * @param {any} inputs - Inputs for the component.
 * @returns {Injector} - The created injector.
 */
class FlexibleVideo {
    injector;
    customWidth = 0;
    customHeight = 0;
    rows = 0;
    columns = 0;
    componentsToRender = [];
    showAspect = false;
    backgroundColor = 'transparent';
    Screenboard;
    annotateScreenStream = false;
    localStreamScreen;
    key = 0;
    cardWidth = 0;
    cardHeight = 0;
    cardTop = 0;
    cardLeft = 0;
    canvasLeft = 0;
    grid = [];
    injectorCache = new WeakMap();
    constructor(injector) {
        this.injector = injector;
    }
    ngOnInit() {
        if (this.showAspect) {
            this.generateGrid();
        }
    }
    ngOnChanges(changes) {
        if (changes['columns'] ||
            changes['rows'] ||
            changes['componentsToRender'] ||
            changes['customWidth'] ||
            changes['customHeight']) {
            if (this.showAspect) {
                this.key++;
                this.generateGrid();
            }
        }
        if (this.annotateScreenStream && this.localStreamScreen) {
            const videoHeight = this.localStreamScreen.getVideoTracks()[0].getSettings().height || 0;
            const videoWidth = this.localStreamScreen.getVideoTracks()[0].getSettings().width || 0;
            this.cardWidth = videoWidth;
            this.cardHeight = videoHeight;
            this.cardTop = Math.floor((this.customHeight - videoHeight) / 2);
            this.cardLeft = Math.floor((this.customWidth - videoWidth) / 2);
            this.canvasLeft = this.cardLeft < 0 ? this.cardLeft : 0;
        }
        else {
            this.cardWidth = this.customWidth;
            this.cardHeight = this.customHeight;
            this.cardTop = 0;
            this.cardLeft = 0;
            this.canvasLeft = 0;
        }
    }
    generateGrid() {
        this.grid = [];
        for (let row = 0; row < this.rows; row++) {
            const rowComponents = [];
            for (let col = 0; col < this.columns; col++) {
                const index = row * this.columns + col;
                const component = this.componentsToRender[index];
                rowComponents.push(component);
            }
            this.grid.push(rowComponents);
        }
    }
    createInjector(inputs) {
        if (!this.injectorCache.has(inputs)) {
            const injector = Injector.create({
                providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
                parent: this.injector,
            });
            this.injectorCache.set(inputs, injector);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.injectorCache.get(inputs);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: FlexibleVideo, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: FlexibleVideo, isStandalone: true, selector: "app-flexible-video", inputs: { customWidth: "customWidth", customHeight: "customHeight", rows: "rows", columns: "columns", componentsToRender: "componentsToRender", showAspect: "showAspect", backgroundColor: "backgroundColor", Screenboard: "Screenboard", annotateScreenStream: "annotateScreenStream", localStreamScreen: "localStreamScreen" }, usesOnChanges: true, ngImport: i0, template: `
    <div
      style="padding: 0; flex: 1; margin: 0; position: relative; display: {{
        showAspect ? 'flex' : 'none'
      }};
             max-width: {{ customWidth }}px; overflow-x: hidden; overflow-y: auto; left: {{
        cardLeft > 0 ? cardLeft : 0
      }}px;"
    >
      <div
        *ngFor="let rowComponents of grid; let rowIndex = index"
        style="display: flex; flex-direction: row;"
      >
        <div
          *ngFor="let component of rowComponents; let colIndex = index"
          [ngStyle]="{
            flex: 1,
            width: cardWidth + 'px',
            height: cardHeight + 'px',
            backgroundColor: backgroundColor,
            margin: '1px',
            padding: 0,
            borderRadius: '0px',
            left: cardLeft + 'px'
          }"
        >
          <ng-container
            *ngComponentOutlet="component.component; injector: createInjector(component.inputs)"
          ></ng-container>
        </div>
      </div>
      <div
        *ngIf="Screenboard && Screenboard.component"
        [ngStyle]="{
          position: 'absolute',
          top: '0',
          left: canvasLeft + 'px',
          width: cardWidth + 'px',
          height: cardHeight + 'px',
          backgroundColor: 'rgba(0, 0, 0, 0.005)',
          zIndex: '2'
        }"
      >
        <ng-container
          *ngComponentOutlet="Screenboard.component; injector: createInjector(Screenboard.inputs)"
        ></ng-container>
      </div>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: FlexibleVideo, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-flexible-video',
                    standalone: true,
                    imports: [CommonModule],
                    template: `
    <div
      style="padding: 0; flex: 1; margin: 0; position: relative; display: {{
        showAspect ? 'flex' : 'none'
      }};
             max-width: {{ customWidth }}px; overflow-x: hidden; overflow-y: auto; left: {{
        cardLeft > 0 ? cardLeft : 0
      }}px;"
    >
      <div
        *ngFor="let rowComponents of grid; let rowIndex = index"
        style="display: flex; flex-direction: row;"
      >
        <div
          *ngFor="let component of rowComponents; let colIndex = index"
          [ngStyle]="{
            flex: 1,
            width: cardWidth + 'px',
            height: cardHeight + 'px',
            backgroundColor: backgroundColor,
            margin: '1px',
            padding: 0,
            borderRadius: '0px',
            left: cardLeft + 'px'
          }"
        >
          <ng-container
            *ngComponentOutlet="component.component; injector: createInjector(component.inputs)"
          ></ng-container>
        </div>
      </div>
      <div
        *ngIf="Screenboard && Screenboard.component"
        [ngStyle]="{
          position: 'absolute',
          top: '0',
          left: canvasLeft + 'px',
          width: cardWidth + 'px',
          height: cardHeight + 'px',
          backgroundColor: 'rgba(0, 0, 0, 0.005)',
          zIndex: '2'
        }"
      >
        <ng-container
          *ngComponentOutlet="Screenboard.component; injector: createInjector(Screenboard.inputs)"
        ></ng-container>
      </div>
    </div>
  `,
                }]
        }], ctorParameters: () => [{ type: i0.Injector }], propDecorators: { customWidth: [{
                type: Input
            }], customHeight: [{
                type: Input
            }], rows: [{
                type: Input
            }], columns: [{
                type: Input
            }], componentsToRender: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], Screenboard: [{
                type: Input
            }], annotateScreenStream: [{
                type: Input
            }], localStreamScreen: [{
                type: Input
            }] } });

class AudioGrid {
    injector;
    componentsToRender = [];
    injectorCache = new WeakMap();
    constructor(injector) {
        this.injector = injector;
    }
    ngOnChanges(changes) {
        if (changes['componentsToRender']) {
            this.clearInjectorCache();
        }
    }
    createInjector(inputs) {
        if (!this.injectorCache.has(inputs)) {
            const injector = Injector.create({
                providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
                parent: this.injector,
            });
            this.injectorCache.set(inputs, injector);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.injectorCache.get(inputs);
    }
    clearInjectorCache() {
        this.injectorCache = new WeakMap();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AudioGrid, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: AudioGrid, isStandalone: true, selector: "app-audio-grid", inputs: { componentsToRender: "componentsToRender" }, usesOnChanges: true, ngImport: i0, template: `
    <div style="z-index: 9">
      <ng-container *ngFor="let item of componentsToRender; let i = index">
        <div style="z-index: 9" [attr.key]="i">
          <ng-container
            *ngComponentOutlet="item.component; injector: createInjector(item.inputs)"
          ></ng-container>
        </div>
      </ng-container>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AudioGrid, decorators: [{
            type: Component,
            args: [{ selector: 'app-audio-grid', standalone: true, imports: [CommonModule], template: `
    <div style="z-index: 9">
      <ng-container *ngFor="let item of componentsToRender; let i = index">
        <div style="z-index: 9" [attr.key]="i">
          <ng-container
            *ngComponentOutlet="item.component; injector: createInjector(item.inputs)"
          ></ng-container>
        </div>
      </ng-container>
    </div>
  ` }]
        }], ctorParameters: () => [{ type: i0.Injector }], propDecorators: { componentsToRender: [{
                type: Input
            }] } });

class LaunchMenuModal {
    /**
     * Toggles the visibility of the menu modal.
     *
     * @param updateIsMenuModalVisible - Function to update the visibility state of the menu modal.
     * @param isMenuModalVisible - Current visibility state of the menu modal.
     */
    launchMenuModal({ updateIsMenuModalVisible, isMenuModalVisible }) {
        updateIsMenuModalVisible(!isMenuModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchMenuModal, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchMenuModal, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchMenuModal, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class LaunchRecording {
    /**
     * Launches the recording process based on various conditions and updates the UI accordingly.
     *
     * @param {Object} options - The options for launching the recording.
     * @param {Function} options.updateIsRecordingModalVisible - Function to update the visibility of the recording modal.
     * @param {boolean} options.isRecordingModalVisible - Indicates if the recording modal is currently visible.
     * @param {Function} options.showAlert - Function to show an alert message.
     * @param {boolean} options.stopLaunchRecord - Indicates if the recording launch should be stopped.
     * @param {boolean} options.canLaunchRecord - Indicates if the recording can be launched.
     * @param {boolean} options.recordingAudioSupport - Indicates if audio recording is supported.
     * @param {boolean} options.recordingVideoSupport - Indicates if video recording is supported.
     * @param {Function} options.updateCanRecord - Function to update the recording capability.
     * @param {Function} options.updateClearedToRecord - Function to update the cleared-to-record status.
     * @param {boolean} options.recordStarted - Indicates if the recording has started.
     * @param {boolean} options.recordPaused - Indicates if the recording is paused.
     * @param {boolean} options.localUIMode - Indicates if the local UI mode is active.
     *
     * @returns {void}
     */
    launchRecording({ updateIsRecordingModalVisible, isRecordingModalVisible, showAlert, stopLaunchRecord, canLaunchRecord, recordingAudioSupport, recordingVideoSupport, updateCanRecord, updateClearedToRecord, recordStarted, recordPaused, localUIMode, }) {
        // Check if recording is already launched
        if (!isRecordingModalVisible && stopLaunchRecord && !localUIMode) {
            showAlert?.({
                message: 'Recording has already ended or you are not allowed to record',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Check if recording initiation is allowed
        if (!isRecordingModalVisible && canLaunchRecord && !localUIMode) {
            // Check if both audio and video recording are not allowed
            if (!recordingAudioSupport && !recordingVideoSupport) {
                showAlert?.({
                    message: 'You are not allowed to record',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            // update clearedToRecord to false
            updateClearedToRecord(false);
            // update canRecord to false
            updateCanRecord(false);
        }
        if (!isRecordingModalVisible && recordStarted) {
            if (!recordPaused) {
                showAlert?.({
                    message: 'You can only re-configure recording after pausing it',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        if (!isRecordingModalVisible &&
            !recordingAudioSupport &&
            !recordingVideoSupport &&
            !localUIMode) {
            showAlert?.({
                message: 'You are not allowed to record',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Update the visibility of the recording modal
        updateIsRecordingModalVisible(!isRecordingModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchRecording, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class RecordUpdateTimer {
    /**
     * Updates the recording timer and progress time.
     * @function
     * @param {RecordUpdateTimerOptions} options - The options object containing necessary variables and functions.
     */
    /**
     * Updates the recording timer by calculating the elapsed time since the recording started
     * and formatting it in HH:MM:SS format.
     *
     * @param {Object} options - The options object.
     * @param {number} options.recordElapsedTime - The elapsed recording time in seconds.
     * @param {number} options.recordStartTime - The timestamp when the recording started.
     * @param {Function} options.updateRecordElapsedTime - Callback to update the elapsed recording time.
     * @param {Function} options.updateRecordingProgressTime - Callback to update the formatted recording time.
     * @returns {void}
     */
    recordUpdateTimer({ recordElapsedTime, recordStartTime, updateRecordElapsedTime, updateRecordingProgressTime, }) {
        /**
         * Utility function to pad single-digit numbers with leading zeros.
         * @param {number} number - The number to pad.
         * @returns {string} The padded number as a string.
         */
        function padNumber(number) {
            return number.toString().padStart(2, '0');
        }
        const currentTime = new Date().getTime(); // Get the current timestamp
        recordElapsedTime = Math.floor((currentTime - recordStartTime) / 1000); // Calculate the elapsed time in seconds
        updateRecordElapsedTime(recordElapsedTime);
        // Format the time in HH:MM:SS format
        const hours = Math.floor(recordElapsedTime / 3600);
        const minutes = Math.floor((recordElapsedTime % 3600) / 60);
        const seconds = recordElapsedTime % 60;
        const formattedTime = padNumber(hours) + ':' + padNumber(minutes) + ':' + padNumber(seconds);
        updateRecordingProgressTime(formattedTime);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordUpdateTimer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordUpdateTimer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordUpdateTimer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class RecordStartTimer {
    RecordUpdateTimerService;
    constructor(RecordUpdateTimerService) {
        this.RecordUpdateTimerService = RecordUpdateTimerService;
    }
    /**
     * Starts the recording timer.
     * @function
     * @param {RecordStartTimerOptions} options - The options object containing necessary variables and functions.
     */
    /**
     * Starts a recording timer and manages its state.
     *
     * @param {RecordStartTimerOptions} options - The options for starting the recording timer.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {number} options.parameters.recordStartTime - The start time of the recording.
     * @param {number | null} options.parameters.recordTimerInterval - The interval ID for the recording timer.
     * @param {boolean} options.parameters.isTimerRunning - Flag indicating if the timer is running.
     * @param {boolean} options.parameters.canPauseResume - Flag indicating if pause/resume actions are enabled.
     * @param {number} options.parameters.recordChangeSeconds - The time after which pause/resume actions are enabled.
     * @param {Function} options.parameters.updateRecordStartTime - Function to update the recording start time.
     * @param {Function} options.parameters.updateRecordTimerInterval - Function to update the recording timer interval.
     * @param {Function} options.parameters.updateIsTimerRunning - Function to update the timer running state.
     * @param {Function} options.parameters.updateCanPauseResume - Function to update the pause/resume state.
     *
     * @returns {Promise<void>} A promise that resolves when the timer is started.
     *
     * @remarks
     * This function initializes the recording start time and sets up an interval to update the timer every second.
     * It also manages the state of the timer, including enabling and disabling pause/resume actions.
     * The timer is stopped if the recording is paused, stopped, or if the room name is invalid.
     */
    recordStartTimer = async ({ parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { recordStartTime, recordTimerInterval, isTimerRunning, canPauseResume, recordChangeSeconds, updateRecordStartTime, updateRecordTimerInterval, updateIsTimerRunning, updateCanPauseResume, } = parameters;
        /**
         * Utility function to enable pause/resume actions after a specified time.
         */
        function enablePauseResume() {
            canPauseResume = true;
            updateCanPauseResume(canPauseResume);
        }
        if (!isTimerRunning) {
            recordStartTime = new Date().getTime(); // Get the current timestamp
            updateRecordStartTime(recordStartTime);
            recordTimerInterval = setInterval(() => {
                // Update the timer every second (1000 milliseconds)
                this.RecordUpdateTimerService.recordUpdateTimer({
                    recordElapsedTime: parameters.recordElapsedTime,
                    recordStartTime: recordStartTime,
                    updateRecordElapsedTime: parameters.updateRecordElapsedTime,
                    updateRecordingProgressTime: parameters.updateRecordingProgressTime,
                });
                parameters = getUpdatedAllParams();
                // Check if recording is paused or stopped, and close the interval if needed
                if (parameters.recordPaused ||
                    parameters.recordStopped ||
                    parameters.roomName == '' ||
                    parameters.roomName == null) {
                    clearInterval(recordTimerInterval);
                    updateRecordTimerInterval(null);
                    isTimerRunning = false;
                    updateIsTimerRunning(isTimerRunning);
                    canPauseResume = false;
                    updateCanPauseResume(canPauseResume);
                }
            }, 1000);
            updateRecordTimerInterval(recordTimerInterval);
            isTimerRunning = true;
            updateIsTimerRunning(isTimerRunning);
            canPauseResume = false; // Disable pause/resume actions initially
            updateCanPauseResume(canPauseResume);
            setTimeout(enablePauseResume, recordChangeSeconds); // Enable pause/resume actions after specified time
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordStartTimer, deps: [{ token: RecordUpdateTimer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordStartTimer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordStartTimer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: RecordUpdateTimer }] });

class RecordResumeTimer {
    RecordUpdateTimerService;
    constructor(RecordUpdateTimerService) {
        this.RecordUpdateTimerService = RecordUpdateTimerService;
    }
    /**
     * Resumes the recording timer if it is not already running and can be paused/resumed.
     *
     * @param {RecordResumeTimerOptions} options - The options for resuming the recording timer.
     * @param {Object} options.parameters - The parameters for the recording timer.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {boolean} options.parameters.isTimerRunning - Indicates if the timer is currently running.
     * @param {boolean} options.parameters.canPauseResume - Indicates if the timer can be paused/resumed.
     * @param {number} options.parameters.recordElapsedTime - The elapsed recording time in seconds.
     * @param {number} options.parameters.recordStartTime - The start time of the recording.
     * @param {number | null} options.parameters.recordTimerInterval - The interval ID for the recording timer.
     * @param {Function} options.parameters.showAlert - Function to show an alert message.
     * @param {Function} options.parameters.updateRecordStartTime - Function to update the recording start time.
     * @param {Function} options.parameters.updateRecordTimerInterval - Function to update the recording timer interval.
     * @param {Function} options.parameters.updateIsTimerRunning - Function to update the timer running status.
     * @param {Function} options.parameters.updateCanPauseResume - Function to update the pause/resume status.
     *
     * @returns {Promise<boolean>} - Returns a promise that resolves to true if the timer was successfully resumed, otherwise false.
     */
    recordResumeTimer = async ({ parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { isTimerRunning, canPauseResume, recordElapsedTime, recordStartTime, recordTimerInterval, showAlert, updateRecordStartTime, updateRecordTimerInterval, updateIsTimerRunning, updateCanPauseResume,
        //mediasfu Functions
        // recordUpdateTimer,
         } = parameters;
        if (!isTimerRunning && canPauseResume) {
            recordStartTime = new Date().getTime() - recordElapsedTime * 1000; // Calculate the starting time based on elapsed time
            updateRecordStartTime(recordStartTime);
            recordTimerInterval = setInterval(() => {
                // Update the timer every second (1000 milliseconds)
                this.RecordUpdateTimerService.recordUpdateTimer({
                    recordElapsedTime: recordElapsedTime,
                    recordStartTime: recordStartTime,
                    updateRecordElapsedTime: parameters['updateRecordElapsedTime'],
                    updateRecordingProgressTime: parameters['updateRecordingProgressTime'],
                });
                parameters = getUpdatedAllParams();
                // Check if recording is paused or stopped, and close the interval if needed
                if (parameters['recordPaused'] ||
                    parameters['recordStopped'] ||
                    parameters['roomName'] == '' ||
                    parameters['roomName'] == null) {
                    if (recordTimerInterval != null) {
                        clearInterval(recordTimerInterval);
                    }
                    updateRecordTimerInterval(null);
                    isTimerRunning = false;
                    updateIsTimerRunning(isTimerRunning);
                    canPauseResume = false;
                    updateCanPauseResume(canPauseResume);
                }
            }, 1000);
            updateRecordTimerInterval(recordTimerInterval);
            isTimerRunning = true;
            updateIsTimerRunning(isTimerRunning);
            canPauseResume = false; // Disable pause/resume actions until paused again
            updateCanPauseResume(canPauseResume);
            return true;
        }
        else {
            showAlert?.({
                type: 'danger',
                message: 'Can only pause or resume after 15 seconds of starting or pausing or resuming recording',
            });
            return false;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordResumeTimer, deps: [{ token: RecordUpdateTimer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordResumeTimer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordResumeTimer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: RecordUpdateTimer }] });

class StartRecording {
    RecordStartTimerService;
    RecordResumeTimerService;
    constructor(RecordStartTimerService, RecordResumeTimerService) {
        this.RecordStartTimerService = RecordStartTimerService;
        this.RecordResumeTimerService = RecordResumeTimerService;
    }
    /**
     * Starts the recording process based on the provided parameters.
     *
     * @param {StartRecordingOptions} options - The options for starting the recording.
     * @param {object} options.parameters - The parameters required for starting the recording.
     * @param {string} options.parameters.roomName - The name of the room where recording is to be started.
     * @param {object} options.parameters.userRecordingParams - User-specific recording parameters.
     * @param {object} options.parameters.socket - The socket instance for communication.
     * @param {function} options.parameters.updateIsRecordingModalVisible - Function to update the visibility of the recording modal.
     * @param {boolean} options.parameters.confirmedToRecord - Flag indicating if the user has confirmed to record.
     * @param {function} options.parameters.showAlert - Function to show alerts.
     * @param {string} options.parameters.recordingMediaOptions - The media options for recording (e.g., "video", "audio").
     * @param {boolean} options.parameters.videoAlreadyOn - Flag indicating if the video is already on.
     * @param {boolean} options.parameters.audioAlreadyOn - Flag indicating if the audio is already on.
     * @param {boolean} options.parameters.recordStarted - Flag indicating if the recording has started.
     * @param {boolean} options.parameters.recordPaused - Flag indicating if the recording is paused.
     * @param {boolean} options.parameters.recordResumed - Flag indicating if the recording is resumed.
     * @param {boolean} options.parameters.recordStopped - Flag indicating if the recording is stopped.
     * @param {boolean} options.parameters.startReport - Flag indicating if the start report is active.
     * @param {boolean} options.parameters.endReport - Flag indicating if the end report is active.
     * @param {boolean} options.parameters.canRecord - Flag indicating if recording is allowed.
     * @param {function} options.parameters.updateClearedToRecord - Function to update the cleared to record status.
     * @param {function} options.parameters.updateRecordStarted - Function to update the record started status.
     * @param {function} options.parameters.updateRecordPaused - Function to update the record paused status.
     * @param {function} options.parameters.updateRecordResumed - Function to update the record resumed status.
     * @param {function} options.parameters.updateStartReport - Function to update the start report status.
     * @param {function} options.parameters.updateEndReport - Function to update the end report status.
     * @param {function} options.parameters.updateCanRecord - Function to update the can record status.
     * @param {boolean} options.parameters.whiteboardStarted - Flag indicating if the whiteboard has started.
     * @param {boolean} options.parameters.whiteboardEnded - Flag indicating if the whiteboard has ended.
     * @param {function} options.parameters.rePort - Function to report the recording status.
     * @param {function} options.parameters.captureCanvasStream - Function to capture the canvas stream.
     *
     * @returns {Promise<boolean | undefined>} - A promise that resolves to a boolean indicating if the recording attempt was successful, or undefined if not applicable.
     */
    startRecording = async ({ parameters }) => {
        parameters = parameters.getUpdatedAllParams();
        let { roomName, userRecordingParams, socket, updateIsRecordingModalVisible, confirmedToRecord, showAlert, recordingMediaOptions, videoAlreadyOn, audioAlreadyOn, recordStarted, recordPaused, recordResumed, recordStopped, startReport, endReport, canRecord, updateClearedToRecord, updateRecordStarted, updateRecordPaused, updateRecordResumed, updateStartReport, updateEndReport, updateCanRecord, whiteboardStarted, whiteboardEnded, 
        //mediasfu functions
        rePort, captureCanvasStream, } = parameters;
        // Check if recording is confirmed before starting
        if (!confirmedToRecord) {
            showAlert?.({
                message: 'You must click confirm before you can start recording',
                type: 'danger',
            });
            return false;
        }
        // Check for recordingMediaOptions for video
        if (recordingMediaOptions === 'video' && !videoAlreadyOn) {
            showAlert?.({
                message: 'You must turn on your video before you can start recording',
                type: 'danger',
            });
            return false;
        }
        // Check for recordingMediaOptions for audio
        if (recordingMediaOptions === 'audio' && !audioAlreadyOn) {
            showAlert?.({
                message: 'You must turn on your audio before you can start recording',
                type: 'danger',
            });
            return false;
        }
        // Set clearedToRecord to true
        updateClearedToRecord(true);
        let action = 'startRecord';
        if (recordStarted && recordPaused && !recordResumed && !recordStopped) {
            action = 'resumeRecord';
        }
        else {
            action = 'startRecord';
        }
        let recAttempt = false;
        await new Promise((resolve) => {
            socket.emit(action, { roomName, userRecordingParams }, async ({ success, reason }) => {
                if (success) {
                    recordStarted = true;
                    startReport = true;
                    endReport = false;
                    recordPaused = false;
                    recAttempt = true;
                    updateRecordStarted(recordStarted);
                    updateStartReport(startReport);
                    updateEndReport(endReport);
                    updateRecordPaused(recordPaused);
                    if (action === 'startRecord') {
                        await rePort({ parameters });
                        await this.RecordStartTimerService.recordStartTimer({ parameters });
                    }
                    else {
                        recordResumed = true;
                        updateRecordResumed(recordResumed);
                        await rePort({ restart: true, parameters });
                        await this.RecordResumeTimerService.recordResumeTimer({ parameters });
                    }
                }
                else {
                    showAlert?.({ message: `Recording could not start - ${reason}`, type: 'danger' });
                    canRecord = true;
                    startReport = false;
                    endReport = true;
                    recAttempt = false;
                    updateCanRecord(canRecord);
                    updateStartReport(startReport);
                    updateEndReport(endReport);
                }
                resolve();
            });
        });
        // Capture canvas stream if recording is successful and whiteboard is active
        try {
            if (recAttempt &&
                whiteboardStarted &&
                !whiteboardEnded &&
                recordingMediaOptions === 'video') {
                captureCanvasStream({ parameters });
            }
        }
        catch (error) {
            console.log('Error capturing canvas stream:', error);
        }
        // Set isRecordingModalVisible to false
        updateIsRecordingModalVisible(false);
        return recAttempt;
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartRecording, deps: [{ token: RecordStartTimer }, { token: RecordResumeTimer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: RecordStartTimer }, { type: RecordResumeTimer }] });

class ConfirmRecording {
    /**
     * Confirms the recording settings based on the provided parameters and updates the recording state.
     *
     * @param {ConfirmRecordingOptions} options - The options for confirming the recording.
     * @param {Parameters} options.parameters - The parameters for the recording.
     *
     * @returns {Promise<void>} A promise that resolves when the recording settings have been confirmed.
     *
     * @remarks
     * This function performs several checks to ensure that the recording settings are valid based on the provided parameters.
     * If any of the checks fail, an alert is shown and the function returns early without updating the recording state.
     *
     * The function checks for the following conditions:
     * - Whether recording videos of all participants is allowed.
     * - Whether recording all participants is allowed.
     * - Whether recording other video participants is allowed.
     * - Whether recording all orientations is allowed.
     * - Whether recording the preferred orientation is allowed.
     * - Whether recording all formats is allowed.
     * - Whether the recording display type is valid based on the meeting display type.
     * - Whether recording all participants with media is allowed.
     *
     * If all checks pass, the function constructs the `mainSpecs`, `dispSpecs`, and `textSpecs` objects based on the state variables,
     * updates the user recording parameters, and confirms the recording.
     *
     * @example
     * ```typescript
     * const options: ConfirmRecordingOptions = { parameters: someParameters };
     * await confirmRecording(options);
     * ```
     */
    confirmRecording = async ({ parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { showAlert, recordingMediaOptions, recordingAudioOptions, recordingVideoOptions, recordingVideoType, recordingDisplayType, recordingNameTags, recordingBackgroundColor, recordingNameTagsColor, recordingOrientationVideo, recordingAddHLS, recordingAddText, recordingCustomText, recordingCustomTextPosition, recordingCustomTextColor, meetingDisplayType, recordingVideoParticipantsFullRoomSupport, recordingAllParticipantsSupport, recordingVideoParticipantsSupport, recordingSupportForOtherOrientation, recordingPreferredOrientation, recordingMultiFormatsSupport, recordingVideoOptimized, recordingAllParticipantsFullRoomSupport, meetingVideoOptimized, eventType, breakOutRoomStarted, breakOutRoomEnded, updateRecordingDisplayType, updateRecordingVideoOptimized, updateRecordingVideoParticipantsFullRoomSupport, updateRecordingAllParticipantsSupport, updateRecordingVideoParticipantsSupport, updateRecordingSupportForOtherOrientation, updateRecordingPreferredOrientation, updateRecordingMultiFormatsSupport, updateUserRecordingParams, updateConfirmedToRecord, } = parameters;
        // Retrieve the values from the state
        const mediaOptions = recordingMediaOptions;
        // Other variables not provided in the guide
        const selectedRecordOption = recordingDisplayType;
        // Additional logic similar to the provided guide
        // recordingVideoParticipantsFullRoomSupport = minigrid and main video
        if (eventType !== 'broadcast') {
            if (!recordingVideoParticipantsFullRoomSupport &&
                recordingVideoOptions === 'all' &&
                mediaOptions === 'video') {
                if (meetingDisplayType == 'all') {
                    if (breakOutRoomStarted && !breakOutRoomEnded) {
                        // breakout rooms are started
                    }
                    else {
                        showAlert?.({
                            message: 'You are not allowed to record videos of all participants; change the meeting display type to video or video optimized.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                }
            }
            // recordingAllParticipantsSupport  = others other than host screen (video + audio)
            if (!recordingAllParticipantsSupport && recordingVideoOptions === 'all') {
                showAlert?.({
                    message: 'You are only allowed to record yourself.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            // recordingVideoParticipantsSupport (maingrid + non-host screenshare person)
            if (!recordingVideoParticipantsSupport && recordingDisplayType === 'video') {
                showAlert?.({
                    message: 'You are not allowed to record other video participants.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        if (!recordingSupportForOtherOrientation && recordingOrientationVideo === 'all') {
            showAlert?.({
                message: 'You are not allowed to record all orientations.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (recordingPreferredOrientation === 'landscape' &&
            recordingOrientationVideo === 'portrait' &&
            !recordingSupportForOtherOrientation) {
            showAlert?.({
                message: 'You are not allowed to record portrait orientation.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        else if (recordingPreferredOrientation === 'portrait' &&
            recordingOrientationVideo === 'landscape' &&
            !recordingSupportForOtherOrientation) {
            showAlert?.({
                message: 'You are not allowed to record landscape orientation.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (!recordingMultiFormatsSupport && recordingVideoType === 'all') {
            showAlert?.({
                message: 'You are not allowed to record all formats.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (eventType !== 'broadcast') {
            if (recordingMediaOptions === 'video') {
                if (meetingDisplayType === 'media') {
                    if (recordingDisplayType === 'all') {
                        showAlert?.({
                            message: 'Recording display type can be either video, video optimized, or media when meeting display type is media.',
                            type: 'danger',
                            duration: 3000,
                        });
                        recordingDisplayType = meetingDisplayType;
                        return;
                    }
                }
                else if (meetingDisplayType === 'video') {
                    if (recordingDisplayType === 'all' || recordingDisplayType === 'media') {
                        showAlert?.({
                            message: 'Recording display type can be either video or video optimized when meeting display type is video.',
                            type: 'danger',
                            duration: 3000,
                        });
                        recordingDisplayType = meetingDisplayType;
                        return;
                    }
                    if (meetingVideoOptimized && !recordingVideoOptimized) {
                        showAlert?.({
                            message: 'Recording display type can be only video optimized when meeting display type is video optimized.',
                            type: 'danger',
                            duration: 3000,
                        });
                        recordingVideoOptimized = meetingVideoOptimized;
                        return;
                    }
                }
            }
            else {
                if (recordingDisplayType === 'all' || recordingDisplayType === 'media') {
                    // do nothing
                }
                else {
                    recordingDisplayType = 'media';
                }
                recordingVideoOptimized = false;
            }
        }
        if (recordingDisplayType === 'all' && !recordingAllParticipantsFullRoomSupport) {
            showAlert?.({
                message: 'You can only record all participants with media.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Construct mainSpecs and dispSpecs objects based on the state variables
        const mainSpecs = {
            mediaOptions: recordingMediaOptions,
            audioOptions: recordingAudioOptions,
            videoOptions: recordingVideoOptions,
            videoType: recordingVideoType,
            videoOptimized: recordingVideoOptimized,
            recordingDisplayType: recordingDisplayType,
            addHLS: recordingAddHLS,
        };
        const dispSpecs = {
            nameTags: recordingNameTags,
            backgroundColor: recordingBackgroundColor,
            nameTagsColor: recordingNameTagsColor,
            orientationVideo: recordingOrientationVideo,
        };
        const textSpecs = {
            addText: recordingAddText,
            customText: recordingCustomText,
            customTextPosition: recordingCustomTextPosition,
            customTextColor: recordingCustomTextColor,
        };
        // Construct userRecordingParams object
        const userRecordingParams = { mainSpecs, dispSpecs, textSpecs };
        // Update state variables based on the logic
        updateUserRecordingParams(userRecordingParams);
        updateConfirmedToRecord(true);
        updateRecordingDisplayType(selectedRecordOption);
        updateRecordingVideoOptimized(recordingVideoOptimized);
        updateRecordingVideoParticipantsFullRoomSupport(recordingVideoParticipantsFullRoomSupport);
        updateRecordingAllParticipantsSupport(recordingAllParticipantsSupport);
        updateRecordingVideoParticipantsSupport(recordingVideoParticipantsSupport);
        updateRecordingSupportForOtherOrientation(recordingSupportForOtherOrientation);
        updateRecordingPreferredOrientation(recordingPreferredOrientation);
        updateRecordingMultiFormatsSupport(recordingMultiFormatsSupport);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfirmRecording, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfirmRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConfirmRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class LaunchWaiting {
    /**
     * Toggles the visibility of the waiting modal.
     *
     * @param updateIsWaitingModalVisible - Function to update the visibility state of the waiting modal.
     * @param isWaitingModalVisible - Current visibility state of the waiting modal.
     */
    launchWaiting({ updateIsWaitingModalVisible, isWaitingModalVisible, }) {
        // Open or close the menu modal
        updateIsWaitingModalVisible(!isWaitingModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchWaiting, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchWaiting, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchWaiting, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class launchCoHost {
    /**
     * Toggles the visibility of the co-host modal.
     *
     * @param updateIsCoHostModalVisible - Function to update the visibility state of the co-host modal.
     * @param isCoHostModalVisible - Current visibility state of the co-host modal.
     */
    launchCoHost({ updateIsCoHostModalVisible, isCoHostModalVisible }) {
        updateIsCoHostModalVisible(!isCoHostModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: launchCoHost, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: launchCoHost, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: launchCoHost, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class LaunchMediaSettings {
    /**
     * Launches the media settings modal and updates the available audio and video input devices.
     *
     * @param {Object} options - The options for launching media settings.
     * @param {Function} options.updateIsMediaSettingsModalVisible - Function to update the visibility state of the media settings modal.
     * @param {boolean} options.isMediaSettingsModalVisible - Current visibility state of the media settings modal.
     * @param {MediaDeviceInfo[]} options.audioInputs - Array to store available audio input devices.
     * @param {MediaDeviceInfo[]} options.videoInputs - Array to store available video input devices.
     * @param {Function} options.updateAudioInputs - Function to update the available audio input devices.
     * @param {Function} options.updateVideoInputs - Function to update the available video input devices.
     * @returns {Promise<void>} A promise that resolves when the media settings have been updated.
     */
    async launchMediaSettings({ updateIsMediaSettingsModalVisible, isMediaSettingsModalVisible, audioInputs, videoInputs, updateAudioInputs, updateVideoInputs, }) {
        // Check if media settings modal is not visible and update available audio and video input devices
        if (!isMediaSettingsModalVisible) {
            try {
                // Get the list of all available media devices
                const devices = await navigator.mediaDevices.enumerateDevices();
                // Filter the devices to get only audio and video input devices
                videoInputs = devices.filter((device) => device.kind === 'videoinput');
                audioInputs = devices.filter((device) => device.kind === 'audioinput');
                // Update the available audio and video input devices
                updateVideoInputs(videoInputs);
                updateAudioInputs(audioInputs);
                // Open the media settings modal
                updateIsMediaSettingsModalVisible(true);
            }
            catch (error) {
                // Open the media settings modal
                updateIsMediaSettingsModalVisible(true);
            }
        }
        else {
            // Close the media settings modal
            updateIsMediaSettingsModalVisible(false);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchMediaSettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchMediaSettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchMediaSettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// display-settings.service.ts
class LaunchDisplaySettings {
    /**
     * Toggles the visibility of the display settings modal.
     *
     * @param updateIsDisplaySettingsModalVisible - Function to update the visibility state of the display settings modal.
     * @param isDisplaySettingsModalVisible - Current visibility state of the display settings modal.
     */
    launchDisplaySettings({ updateIsDisplaySettingsModalVisible, isDisplaySettingsModalVisible, }) {
        // Toggle the visibility of the display settings modal.
        updateIsDisplaySettingsModalVisible(!isDisplaySettingsModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchDisplaySettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchDisplaySettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchDisplaySettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// settings.service.ts
class LaunchSettings {
    /**
     * Toggles the visibility state of the settings modal.
     *
     * @param {LaunchSettingsOptions} options - The options for launching settings.
     * @param {Function} options.updateIsSettingsModalVisible - Function to update the visibility state of the settings modal.
     * @param {boolean} options.isSettingsModalVisible - Current visibility state of the settings modal.
     * @returns {void}
     */
    launchSettings({ updateIsSettingsModalVisible, isSettingsModalVisible, }) {
        // Toggle the visibility of the display settings modal.
        updateIsSettingsModalVisible(!isSettingsModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchSettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchSettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchSettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// requests.service.ts
class LaunchRequests {
    /**
     * Toggles the visibility state of the requests modal.
     *
     * @param {LaunchRequestsOptions} options - The options for launching requests.
     * @param {Function} options.updateIsRequestsModalVisible - Function to update the visibility state of the requests modal.
     * @param {boolean} options.isRequestsModalVisible - Current visibility state of the requests modal.
     * @returns {void}
     */
    launchRequests({ updateIsRequestsModalVisible, isRequestsModalVisible, }) {
        // Toggle the visibility of the display settings modal.
        updateIsRequestsModalVisible(!isRequestsModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchRequests, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchRequests, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchRequests, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class LaunchParticipants {
    /**
     * Toggles the visibility of the participants modal.
     * @function
     * @param {Object} options - The options object containing necessary variables and functions.
     * @param {Function} options.updateIsParticipantsModalVisible - Function to update the visibility state of the participants modal.
     * @param {boolean} options.isParticipantsModalVisible - Current visibility state of the participants modal.
     */
    launchParticipants({ updateIsParticipantsModalVisible, isParticipantsModalVisible, }) {
        updateIsParticipantsModalVisible(!isParticipantsModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchParticipants, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchParticipants, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchParticipants, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class LaunchMessages {
    /**
     * Toggles the visibility state of the messages modal.
     * If the modal is currently visible, it will be closed. If it's hidden, it will be opened.
     *
     * @param updateIsMessagesModalVisible - Function to update the visibility state of the messages modal.
     * @param isMessagesModalVisible - Current visibility state of the messages modal.
     */
    launchMessages({ updateIsMessagesModalVisible, isMessagesModalVisible, }) {
        updateIsMessagesModalVisible(!isMessagesModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchMessages, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchMessages, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchMessages, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class LaunchConfirmExit {
    /**
     * Toggles the visibility of the confirmation exit modal.
     *
     * @param updateIsConfirmExitModalVisible - Function to update the visibility state of the confirmation exit modal.
     * @param isConfirmExitModalVisible - Current visibility state of the confirmation exit modal.
     */
    launchConfirmExit({ updateIsConfirmExitModalVisible, isConfirmExitModalVisible, }) {
        updateIsConfirmExitModalVisible(!isConfirmExitModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchConfirmExit, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchConfirmExit, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchConfirmExit, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class LaunchPoll {
    /**
     * Toggles the visibility of the poll modal.
     * @function
     * @param {Object} options - The options object containing necessary variables and functions.
     * @param {Function} options.updateIsPollModalVisible - Function to update the visibility state of the poll modal.
     * @param {boolean} options.isPollModalVisible - Current visibility state of the poll modal.
     */
    launchPoll({ updateIsPollModalVisible, isPollModalVisible }) {
        updateIsPollModalVisible(!isPollModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchPoll, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchPoll, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchPoll, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class LaunchBackground {
    /**
     * Toggles the visibility of the background modal.
     * @function
     * @param {Object} options - The options object containing necessary variables and functions.
     * @param {Function} options.updateIsBackgroundModalVisible - Function to update the visibility state of the background modal.
     * @param {boolean} options.isBackgroundModalVisible - Current visibility state of the background modal.
     */
    launchBackground({ updateIsBackgroundModalVisible, isBackgroundModalVisible, }) {
        updateIsBackgroundModalVisible(!isBackgroundModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchBackground, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchBackground, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchBackground, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class LaunchBreakoutRooms {
    /**
     * Launches the breakout rooms by toggling the visibility of the breakout rooms modal.
     *
     * @param updateIsBreakoutRoomsModalVisible - Function to update the visibility state of the breakout rooms modal.
     * @param isBreakoutRoomsModalVisible - Current visibility state of the breakout rooms modal.
     */
    launchBreakoutRooms({ updateIsBreakoutRoomsModalVisible, isBreakoutRoomsModalVisible, }) {
        updateIsBreakoutRoomsModalVisible(!isBreakoutRoomsModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchBreakoutRooms, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchBreakoutRooms, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchBreakoutRooms, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// whiteboard.service.ts
class LaunchConfigureWhiteboard {
    /**
     * Toggles the visibility of the configure whiteboard modal.
     *
     * @param updateIsConfigureWhiteboardModalVisible - Function to update the visibility state of the configure whiteboard modal.
     * @param isConfigureWhiteboardModalVisible - Current visibility state of the configure whiteboard modal.
     */
    launchConfigureWhiteboard({ updateIsConfigureWhiteboardModalVisible, isConfigureWhiteboardModalVisible, }) {
        // Open or close the menu modal
        updateIsConfigureWhiteboardModalVisible(!isConfigureWhiteboardModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchConfigureWhiteboard, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchConfigureWhiteboard, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: LaunchConfigureWhiteboard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class SocketManager {
    socket;
    async validateApiKeyToken(value) {
        if (!/^[a-z0-9]{64}$/i.test(value)) {
            throw new Error('Invalid API key or token.');
        }
        return true;
    }
    connectSocket = async ({ apiUserName, apiKey, apiToken, link, }) => {
        if (!apiUserName) {
            throw new Error('API username required.');
        }
        if (!(apiKey || apiToken)) {
            throw new Error('API key or token required.');
        }
        if (!link) {
            throw new Error('Socket link required.');
        }
        let useKey = false;
        try {
            if (apiKey && apiKey.length === 64) {
                await this.validateApiKeyToken(apiKey);
                useKey = true;
            }
            else {
                if (apiToken) {
                    await this.validateApiKeyToken(apiToken);
                }
                else {
                    throw new Error('API token is required.');
                }
                useKey = false;
            }
        }
        catch (error) {
            throw new Error('Invalid API key or token.');
        }
        return new Promise((resolve, reject) => {
            const query = useKey ? { apiUserName, apiKey } : { apiUserName, apiToken };
            this.socket = io(`${link}/media`, {
                transports: ['websocket'],
                query,
            });
            this.socket.on('connect', () => {
                console.log('Connected to media socket.', this.socket.id);
                resolve(this.socket);
            });
            this.socket.on('connect_error', () => {
                reject(new Error('Error connecting to media socket.'));
            });
        });
    };
    disconnectSocket = async ({ socket }) => {
        if (socket) {
            socket.disconnect();
            return true;
        }
        return false;
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SocketManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SocketManager, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SocketManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ValidateAlphanumeric {
    /**
     * Validates if the given string contains only alphanumeric characters.
     *
     * @param {ValidateAlphanumericOptions} options - The options containing the string to validate.
     * @param {string} options.str - The string to be validated.
     * @returns {Promise<boolean>} - A promise that resolves to `true` if the string is alphanumeric, otherwise `false`.
     */
    async validateAlphanumeric({ str }) {
        let code, i, len;
        for (i = 0, len = str.length; i < len; i++) {
            code = str.charCodeAt(i);
            if (!(code > 47 && code < 58) && // numeric (0-9)
                !(code > 64 && code < 91) && // upper alpha (A-Z)
                !(code > 96 && code < 123)) {
                // lower alpha (a-z)
                return false;
            }
        }
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ValidateAlphanumeric, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ValidateAlphanumeric, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ValidateAlphanumeric, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class JoinRoom {
    validateAlphanumeric;
    constructor(validateAlphanumeric) {
        this.validateAlphanumeric = validateAlphanumeric;
    }
    /**
     * Joins a user to a specified room via a socket connection.
     *
     * @param {Object} options - The options for joining the room.
     * @param {Socket} options.socket - The socket instance to use for communication.
     * @param {string} options.roomName - The name of the room to join.
     * @param {string} options.islevel - The level of the user.
     * @param {string} options.member - The member identifier.
     * @param {string} options.sec - The security token.
     * @param {string} options.apiUserName - The API username of the user.
     *
     * @returns {Promise<object>} A promise that resolves with the data received from the 'joinRoom' event or rejects with a validation error.
     *
     * @throws {Error} Throws an error if the user is banned, suspended, or if the host has not joined the room yet.
     */
    async joinRoom({ socket, roomName, islevel, member, sec, apiUserName, }) {
        return new Promise((resolve, reject) => {
            // Validate inputs
            if (!(sec && roomName && islevel && apiUserName && member)) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Missing required parameters',
                };
                reject(validationError);
                return;
            }
            // Validate alphanumeric for roomName, apiUserName, and member
            try {
                this.validateAlphanumeric.validateAlphanumeric({ str: roomName });
                this.validateAlphanumeric.validateAlphanumeric({ str: apiUserName });
                this.validateAlphanumeric.validateAlphanumeric({ str: member });
            }
            catch (error) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName or apiUserName or member',
                };
                reject(validationError);
                return;
            }
            // Validate roomName starts with 's' or 'p'
            if (!(roomName.startsWith('s') || roomName.startsWith('p'))) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName, must start with s or p',
                };
                reject(validationError);
                return;
            }
            // Validate other conditions for sec, roomName, islevel, apiUserName
            if (!(sec.length === 64 &&
                roomName.length >= 8 &&
                islevel.length === 1 &&
                apiUserName.length >= 6 &&
                (islevel === '0' || islevel === '1' || islevel === '2'))) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName or islevel or apiUserName or secret',
                };
                reject(validationError);
                return;
            }
            socket.emit('joinRoom', { roomName, islevel, member, sec, apiUserName }, async (data) => {
                try {
                    // Check if rtpCapabilities is null
                    if (data.rtpCapabilities === null) {
                        // Check if banned, suspended, or noAdmin
                        if (data.banned) {
                            throw new Error('User is banned.');
                        }
                        if (data.suspended) {
                            throw new Error('User is suspended.');
                        }
                        if (data.noAdmin) {
                            throw new Error('Host has not joined the room yet.');
                        }
                        // Resolve with the data received from the 'joinRoom' event
                        resolve(data);
                    }
                    else {
                        // Resolve with the data received from the 'joinRoom' event
                        resolve(data);
                    }
                }
                catch (error) {
                    // Handle errors during the joinRoom process
                    console.log('Error joining room:', error);
                    reject(error);
                }
            });
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinRoom, deps: [{ token: ValidateAlphanumeric }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinRoom, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinRoom, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: ValidateAlphanumeric }] });

class JoinConRoom {
    validateAlphanumeric;
    constructor(validateAlphanumeric) {
        this.validateAlphanumeric = validateAlphanumeric;
    }
    /**
     * Joins a conference room using the provided options.
     *
     * @param {JoinConRoomOptions} options - The options for joining the conference room.
     * @param {Socket} options.socket - The socket instance to use for communication.
     * @param {string} options.roomName - The name of the room to join.
     * @param {string} options.islevel - The level of the user.
     * @param {string} options.member - The member identifier.
     * @param {string} options.sec - The security token.
     * @param {string} options.apiUserName - The API username.
     * @returns {Promise<JoinConRoomResponse>} A promise that resolves with the response of the join operation.
     *
     * @throws {Error} If any of the required parameters are missing or invalid.
     * @throws {Error} If the user is banned, suspended, or if the host has not joined the room yet.
     */
    async joinConRoom({ socket, roomName, islevel, member, sec, apiUserName, }) {
        return new Promise((resolve, reject) => {
            // Validate inputs
            if (!(sec && roomName && islevel && apiUserName && member)) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Missing required parameters',
                };
                reject(validationError);
                return;
            }
            // Validate alphanumeric for roomName, apiUserName, and member
            try {
                this.validateAlphanumeric.validateAlphanumeric({ str: roomName });
                this.validateAlphanumeric.validateAlphanumeric({ str: apiUserName });
                this.validateAlphanumeric.validateAlphanumeric({ str: member });
            }
            catch (error) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName or apiUserName or member',
                };
                reject(validationError);
                return;
            }
            // Validate roomName starts with 's' or 'p'
            if (!(roomName.startsWith('s') || roomName.startsWith('p'))) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName, must start with s or p',
                };
                reject(validationError);
                return;
            }
            // Validate other conditions for sec, roomName, islevel, apiUserName
            if (!(sec.length === 64 &&
                roomName.length >= 8 &&
                islevel.length === 1 &&
                apiUserName.length >= 6 &&
                (islevel === '0' || islevel === '1' || islevel === '2'))) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName or islevel or apiUserName or secret',
                };
                reject(validationError);
                return;
            }
            socket.emit('joinConRoom', { roomName, islevel, member, sec, apiUserName }, async (data) => {
                try {
                    // Check if rtpCapabilities is null
                    if (data.rtpCapabilities === null) {
                        // Check if banned, suspended, or noAdmin
                        if (data.banned) {
                            throw new Error('User is banned.');
                        }
                        if (data.suspended) {
                            throw new Error('User is suspended.');
                        }
                        if (data.noAdmin) {
                            throw new Error('Host has not joined the room yet.');
                        }
                        // Resolve with the data received from the 'joinConRoom' event
                        resolve(data);
                    }
                    else {
                        // Resolve with the data received from the 'joinConRoom' event
                        resolve(data);
                    }
                }
                catch (error) {
                    // Handle errors during the joinConRoom process
                    console.log('Error joining room:', error);
                    reject(error);
                }
            });
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinConRoom, deps: [{ token: ValidateAlphanumeric }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinConRoom, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinConRoom, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: ValidateAlphanumeric }] });

class JoinRoomClient {
    JoinRoomService;
    JoinConRoomService;
    constructor(JoinRoomService, JoinConRoomService) {
        this.JoinRoomService = JoinRoomService;
        this.JoinConRoomService = JoinConRoomService;
    }
    /**
     * Joins a room by emitting the `joinRoom` event to the server using the provided socket.
     *
     * @param {Object} options - The options for joining the room.
     * @param {Socket} options.socket - The socket instance to use for communication.
     * @param {string} options.roomName - The name of the room to join.
     * @param {boolean} options.islevel - The level indicator for the room.
     * @param {string} options.member - The member identifier.
     * @param {string} options.sec - The security token or identifier.
     * @param {string} options.apiUserName - The API username for authentication.
     * @param {boolean} [options.consume=false] - Flag to determine which join function to use.
     * @returns {Promise<any>} A promise that resolves with the data returned from the server.
     * @throws {Error} Throws an error if the room joining process fails.
     */
    async joinRoomClient({ socket, roomName, islevel, member, sec, apiUserName, consume = false, }) {
        try {
            let data;
            if (consume) {
                data = await this.JoinConRoomService.joinConRoom({
                    socket,
                    roomName,
                    islevel,
                    member,
                    sec,
                    apiUserName,
                });
            }
            else {
                data = await this.JoinRoomService.joinRoom({
                    socket,
                    roomName,
                    islevel,
                    member,
                    sec,
                    apiUserName,
                });
            }
            return data;
        }
        catch (error) {
            console.error(error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinRoomClient, deps: [{ token: JoinRoom }, { token: JoinConRoom }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinRoomClient, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinRoomClient, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: JoinRoom }, { type: JoinConRoom }] });

class VideoCaptureConstraints {
    // Landscape display sizes
    QnHDCons = { width: { ideal: 320 }, height: { ideal: 180 } };
    sdCons = { width: { ideal: 640 }, height: { ideal: 360 } };
    hdCons = { width: { ideal: 1280 }, height: { ideal: 720 } };
    fhdCons = { width: { ideal: 1920 }, height: { ideal: 1080 } };
    qhdCons = { width: { ideal: 2560 }, height: { ideal: 1440 } };
    // Portrait display sizes
    QnHDConsPort = { width: { ideal: 180 }, height: { ideal: 320 } };
    sdConsPort = { width: { ideal: 360 }, height: { ideal: 640 } };
    hdConsPort = { width: { ideal: 720 }, height: { ideal: 1280 } };
    fhdConsPort = { width: { ideal: 1080 }, height: { ideal: 1920 } };
    qhdConsPort = { width: { ideal: 1440 }, height: { ideal: 2560 } };
    // Neutral (Square) display sizes
    QnHDConsNeu = { width: { ideal: 240 }, height: { ideal: 240 } };
    sdConsNeu = { width: { ideal: 480 }, height: { ideal: 480 } };
    hdConsNeu = { width: { ideal: 960 }, height: { ideal: 960 } };
    fhdConsNeu = { width: { ideal: 1440 }, height: { ideal: 1440 } };
    qhdConsNeu = { width: { ideal: 1920 }, height: { ideal: 1920 } };
    // Frame rates for video capture
    QnHDFrameRate = 5;
    sdFrameRate = 10;
    hdFrameRate = 15;
    fhdFrameRate = 20;
    qhdFrameRate = 30;
    screenFrameRate = 30;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: VideoCaptureConstraints, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: VideoCaptureConstraints, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: VideoCaptureConstraints, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class HParams {
    hParams = {
        encodings: [
            {
                rid: 'r8',
                maxBitrate: 240000,
                scalabilityMode: 'L1T3',
                scaleResolutionDownBy: 4.0,
            },
            {
                rid: 'r9',
                maxBitrate: 480000,
                scalabilityMode: 'L1T3',
                scaleResolutionDownBy: 2.0,
            },
            {
                rid: 'r10',
                maxBitrate: 960000,
                scalabilityMode: 'L1T3',
            },
        ],
        codecOptions: {
            videoGoogleStartBitrate: 320,
        },
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HParams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HParams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HParams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class VParams {
    vParams = {
        encodings: [
            {
                rid: 'r3',
                maxBitrate: 200000,
                scalabilityMode: 'L1T3',
                scaleResolutionDownBy: 4.0,
            },
            {
                rid: 'r4',
                maxBitrate: 400000,
                scalabilityMode: 'L1T3',
                scaleResolutionDownBy: 2.0,
            },
            {
                rid: 'r5',
                maxBitrate: 800000,
                scalabilityMode: 'L1T3',
            },
        ],
        codecOptions: {
            videoGoogleStartBitrate: 320,
        },
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: VParams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: VParams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: VParams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ScreenParams {
    screenParams = {
        encodings: [
            {
                rid: 'r7',
                maxBitrate: 3000000,
            },
        ],
        codecOptions: {
            videoGoogleStartBitrate: 1000,
        },
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ScreenParams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ScreenParams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ScreenParams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class AParams {
    aParams = {
        encodings: [
            {
                rid: 'r0',
                maxBitrate: 64000,
            },
        ],
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AParams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AParams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AParams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
// room.service.ts
class UpdateRoomParametersClient {
    videoCaptureConstraints;
    hParams;
    vParams;
    screenParams;
    aParams;
    constructor(videoCaptureConstraints, hParams, vParams, screenParams, aParams) {
        this.videoCaptureConstraints = videoCaptureConstraints;
        this.hParams = hParams;
        this.vParams = vParams;
        this.screenParams = screenParams;
        this.aParams = aParams;
    }
    /**
     * Update Room Parameters Client after the user has joined the room and the room parameters have been received from the server.
     * @param {Object} parameters - An object containing various parameters and update functions.
     */
    updateRoomParametersClient = ({ parameters }) => {
        try {
            const { screenPageLimit, shareScreenStarted, shared, hParams, vParams, frameRate, islevel, showAlert, data, 
            //updates
            updateRtpCapabilities, updateRoomRecvIPs, updateMeetingRoomParams, updateItemPageLimit, updateAudioOnlyRoom, updateScreenPageLimit, updateVidCons, updateFrameRate, updateAdminPasscode, updateEventType, updateYouAreCoHost, updateAutoWave, updateForceFullDisplay, updateChatSetting, updateMeetingDisplayType, updateAudioSetting, updateVideoSetting, updateScreenshareSetting, updateHParams, updateVParams, updateScreenParams, updateAParams, updateTargetResolution, updateTargetResolutionHost, 
            // Recording updates
            updateRecordingAudioPausesLimit, updateRecordingAudioPausesCount, updateRecordingAudioSupport, updateRecordingAudioPeopleLimit, updateRecordingAudioParticipantsTimeLimit, updateRecordingVideoPausesCount, updateRecordingVideoPausesLimit, updateRecordingVideoSupport, updateRecordingVideoPeopleLimit, updateRecordingVideoParticipantsTimeLimit, updateRecordingAllParticipantsSupport, updateRecordingVideoParticipantsSupport, updateRecordingAllParticipantsFullRoomSupport, updateRecordingVideoParticipantsFullRoomSupport, updateRecordingPreferredOrientation, updateRecordingSupportForOtherOrientation, updateRecordingMultiFormatsSupport, updateRecordingVideoOptions, updateRecordingAudioOptions, updateMainHeightWidth, } = parameters;
            if (data.rtpCapabilities == null) {
                let reason = data.reason || '';
                showAlert?.({
                    message: 'Sorry, you are not allowed to join this room. ' + reason,
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            // Update all values
            updateRtpCapabilities(data.rtpCapabilities);
            updateAdminPasscode(data.secureCode);
            updateRoomRecvIPs(data.roomRecvIPs);
            updateMeetingRoomParams(data.meetingRoomParams);
            // Update recording values
            updateRecordingAudioPausesLimit(data.recordingParams.recordingAudioPausesLimit);
            updateRecordingAudioPausesCount(data.recordingParams.recordingAudioPausesCount);
            updateRecordingAudioSupport(data.recordingParams.recordingAudioSupport);
            updateRecordingAudioPeopleLimit(data.recordingParams.recordingAudioPeopleLimit);
            updateRecordingAudioParticipantsTimeLimit(data.recordingParams.recordingAudioParticipantsTimeLimit);
            updateRecordingVideoPausesCount(data.recordingParams.recordingVideoPausesCount);
            updateRecordingVideoPausesLimit(data.recordingParams.recordingVideoPausesLimit);
            updateRecordingVideoSupport(data.recordingParams.recordingVideoSupport);
            updateRecordingVideoPeopleLimit(data.recordingParams.recordingVideoPeopleLimit);
            updateRecordingVideoParticipantsTimeLimit(data.recordingParams.recordingVideoParticipantsTimeLimit);
            updateRecordingAllParticipantsSupport(data.recordingParams.recordingAllParticipantsSupport);
            updateRecordingVideoParticipantsSupport(data.recordingParams.recordingVideoParticipantsSupport);
            updateRecordingAllParticipantsFullRoomSupport(data.recordingParams.recordingAllParticipantsFullRoomSupport);
            updateRecordingVideoParticipantsFullRoomSupport(data.recordingParams.recordingVideoParticipantsFullRoomSupport);
            updateRecordingPreferredOrientation(data.recordingParams.recordingPreferredOrientation);
            updateRecordingSupportForOtherOrientation(data.recordingParams.recordingSupportForOtherOrientation);
            updateRecordingMultiFormatsSupport(data.recordingParams.recordingMultiFormatsSupport);
            // Update other meeting room settings
            updateItemPageLimit(data.meetingRoomParams.itemPageLimit);
            updateEventType(data.meetingRoomParams.type);
            if (data.meetingRoomParams.type == 'chat' && islevel != '2') {
                updateYouAreCoHost(true);
            }
            if (['chat', 'broadcast'].includes(data.meetingRoomParams.type)) {
                updateAutoWave(false);
                updateMeetingDisplayType('all');
                updateForceFullDisplay(true);
                updateChatSetting('allow');
            }
            updateAudioSetting(data.meetingRoomParams.audioSetting);
            updateVideoSetting(data.meetingRoomParams.videoSetting);
            updateScreenshareSetting(data.meetingRoomParams.screenshareSetting);
            updateChatSetting(data.meetingRoomParams.chatSetting);
            updateAudioOnlyRoom(data.meetingRoomParams.mediaType != 'video');
            if (data.meetingRoomParams.type == 'chat' || data.meetingRoomParams.type == 'broadcast') {
                if (data.meetingRoomParams.type == 'broadcast') {
                    updateItemPageLimit(1);
                    updateRecordingVideoOptions('mainScreen');
                    updateRecordingAudioOptions('host');
                }
                else {
                    updateItemPageLimit(2);
                }
            }
            if (data.meetingRoomParams.type == 'conference' && (shared || shareScreenStarted)) {
                updateMainHeightWidth(100);
            }
            else {
                updateMainHeightWidth(0);
            }
            updateScreenPageLimit(Math.min(data.meetingRoomParams.itemPageLimit, screenPageLimit));
            // Assign media capture constraints based on the user's role and room settings
            let targetOrientation = islevel == '2'
                ? data.meetingRoomParams.targetOrientationHost
                : data.meetingRoomParams.targetOrientation;
            let targetResolution = islevel == '2'
                ? data.meetingRoomParams.targetResolutionHost
                : data.meetingRoomParams.targetResolution;
            let vidCons;
            if (targetOrientation == 'landscape') {
                vidCons =
                    targetResolution == 'hd'
                        ? this.videoCaptureConstraints.hdCons
                        : targetResolution == 'QnHD'
                            ? this.videoCaptureConstraints.QnHDCons
                            : targetResolution == 'fhd'
                                ? this.videoCaptureConstraints.fhdCons
                                : targetResolution == 'qhd'
                                    ? this.videoCaptureConstraints.qhdCons
                                    : this.videoCaptureConstraints.sdCons;
            }
            else if (targetOrientation == 'neutral') {
                vidCons =
                    targetResolution == 'hd'
                        ? this.videoCaptureConstraints.hdConsNeu
                        : targetResolution == 'QnHD'
                            ? this.videoCaptureConstraints.QnHDConsNeu
                            : targetResolution == 'fhd'
                                ? this.videoCaptureConstraints.fhdConsNeu
                                : targetResolution == 'qhd'
                                    ? this.videoCaptureConstraints.qhdConsNeu
                                    : this.videoCaptureConstraints.sdConsNeu;
            }
            else {
                vidCons =
                    targetResolution == 'hd'
                        ? this.videoCaptureConstraints.hdConsPort
                        : targetResolution == 'QnHD'
                            ? this.videoCaptureConstraints.QnHDConsPort
                            : targetResolution == 'fhd'
                                ? this.videoCaptureConstraints.fhdConsPort
                                : targetResolution == 'qhd'
                                    ? this.videoCaptureConstraints.qhdConsPort
                                    : this.videoCaptureConstraints.sdConsPort;
            }
            let frameRateValue = frameRate ? frameRate : 10;
            let vParamsValue = { ...vParams };
            let hParamsValue = { ...hParams };
            if (Object.keys(vParamsValue).length === 0) {
                vParamsValue = this.vParams.vParams;
            }
            if (Object.keys(hParamsValue).length === 0) {
                hParamsValue = this.hParams.hParams;
            }
            if (targetResolution == 'hd') {
                frameRateValue = this.videoCaptureConstraints.hdFrameRate;
                vParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 4);
                });
                hParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 4);
                });
            }
            else if (targetResolution == 'QnHD') {
                frameRateValue = this.videoCaptureConstraints.QnHDFrameRate;
                vParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 0.25);
                });
                hParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 0.25);
                });
                hParamsValue.codecOptions.videoGoogleStartBitrate *= 0.25;
                vParamsValue.codecOptions.videoGoogleStartBitrate *= 0.25;
            }
            else if (targetResolution == 'fhd') {
                frameRateValue = this.videoCaptureConstraints.fhdFrameRate;
                vParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 8);
                });
                hParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 8);
                });
                hParamsValue.codecOptions.videoGoogleStartBitrate *= 8;
                vParamsValue.codecOptions.videoGoogleStartBitrate *= 8;
            }
            else if (targetResolution == 'qhd') {
                frameRateValue = this.videoCaptureConstraints.qhdFrameRate;
                vParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 16);
                });
                hParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 16);
                });
                hParamsValue.codecOptions.videoGoogleStartBitrate *= 16;
                vParamsValue.codecOptions.videoGoogleStartBitrate *= 16;
            }
            if (data.recordingParams.recordingVideoSupport) {
                vParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 1.2);
                });
                hParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 1.2);
                });
                hParamsValue.codecOptions.videoGoogleStartBitrate *= 1.2;
                vParamsValue.codecOptions.videoGoogleStartBitrate *= 1.2;
            }
            updateVidCons(vidCons);
            updateFrameRate(frameRateValue);
            updateHParams(hParamsValue);
            updateVParams(vParamsValue);
            updateScreenParams(this.screenParams.screenParams);
            updateAParams(this.aParams.aParams);
            updateTargetResolution(data.meetingRoomParams.targetResolution);
            updateTargetResolutionHost(data.meetingRoomParams.targetResolutionHost);
        }
        catch (error) {
            console.log('updateRoomParametersClient error', error);
            parameters.showAlert?.({
                message: error.message,
                type: 'danger',
                duration: 3000,
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateRoomParametersClient, deps: [{ token: VideoCaptureConstraints }, { token: HParams }, { token: VParams }, { token: ScreenParams }, { token: AParams }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateRoomParametersClient, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateRoomParametersClient, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: VideoCaptureConstraints }, { type: HParams }, { type: VParams }, { type: ScreenParams }, { type: AParams }] });

class CreateDeviceClient {
    /**
     * Creates a mediasoup client device with the provided RTP capabilities.
     *
     * @param {CreateDeviceClientOptions} options - The options for creating the device client.
     * @param {RTPCapabilities} options.rtpCapabilities - The RTP capabilities required for the device.
     * @returns {Promise<Device | null>} A promise that resolves to the created Device or null if creation fails.
     * @throws {Error} Throws an error if the required parameters are not provided or if device creation is not supported.
     *
     */
    async createDeviceClient({ rtpCapabilities }) {
        try {
            // Validate input parameters
            if (!rtpCapabilities || !mediasoupClient) {
                throw new Error('Both rtpCapabilities and mediasoupClient must be provided.');
            }
            // Create a mediasoup client device
            const device = new mediasoupClient.Device();
            // Remove orientation capabilities
            if (rtpCapabilities.headerExtensions) {
                rtpCapabilities.headerExtensions = rtpCapabilities.headerExtensions.filter((ext) => ext.uri !== 'urn:3gpp:video-orientation');
            }
            // Load the provided RTP capabilities into the device
            await device.load({
                routerRtpCapabilities: rtpCapabilities,
            });
            // Perform additional initialization, e.g., loading spinner and retrieving messages
            return device;
        }
        catch (error) {
            // Handle specific errors, e.g., UnsupportedError
            if (error.name === 'UnsupportedError') {
                // Handle unsupported device creation
                console.error('UnsupportedError: Device creation is not supported by the browser.');
            }
            throw error; // Propagate other errors
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CreateDeviceClient, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CreateDeviceClient, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CreateDeviceClient, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// click-video.service.ts
class ClickVideo {
    /**
     * Handles the click event to toggle the participant's video on/off and manages video permission requests.
     *
     * @param {ClickVideoParams} options - The function parameters.
     * @returns {Promise<void>}
     */
    clickVideo = async ({ parameters }) => {
        let { checkMediaPermission, hasCameraPermission, videoAlreadyOn, audioOnlyRoom, recordStarted, recordResumed, recordPaused, recordStopped, recordingMediaOptions, islevel, youAreCoHost, adminRestrictSetting, videoRequestState, videoRequestTime, member, socket, roomName, userDefaultVideoInputDevice, currentFacingMode, vidCons, frameRate, videoAction, localStream, audioSetting, videoSetting, screenshareSetting, chatSetting, updateRequestIntervalSeconds, streamSuccessVideo, showAlert, updateVideoAlreadyOn, updateVideoRequestState, updateLocalStream, disconnectSendTransportVideo, requestPermissionCamera, checkPermission, } = parameters;
        if (audioOnlyRoom) {
            showAlert?.({
                message: 'You cannot turn on your camera in an audio only event.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (videoAlreadyOn) {
            if (islevel === '2' && (recordStarted || recordResumed)) {
                if (!(recordPaused || recordStopped) && recordingMediaOptions === 'video') {
                    showAlert?.({
                        message: 'You cannot turn off your camera while recording video, please pause or stop recording first.',
                        type: 'danger',
                        duration: 3000,
                    });
                    return;
                }
            }
            videoAlreadyOn = false;
            updateVideoAlreadyOn(videoAlreadyOn);
            if (localStream) {
                localStream.getVideoTracks()[0].enabled = false;
            }
            updateLocalStream(localStream);
            await disconnectSendTransportVideo({ parameters });
        }
        else {
            if (adminRestrictSetting) {
                showAlert?.({
                    message: 'You cannot turn on your camera. Access denied by host.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            let response = 2;
            if (!videoAction && islevel !== '2' && !youAreCoHost) {
                response = await checkPermission({
                    permissionType: 'videoSetting',
                    audioSetting,
                    videoSetting,
                    screenshareSetting,
                    chatSetting,
                });
            }
            else {
                response = 0;
            }
            if (response === 1) {
                if (videoRequestState === 'pending') {
                    showAlert?.({
                        message: 'A request is pending. Please wait for the host to respond.',
                        type: 'danger',
                        duration: 3000,
                    });
                    return;
                }
                if (videoRequestState === 'rejected' &&
                    Date.now() - videoRequestTime < updateRequestIntervalSeconds) {
                    showAlert?.({
                        message: `A request was rejected. Please wait for ${updateRequestIntervalSeconds} seconds before sending another request.`,
                        type: 'danger',
                        duration: 3000,
                    });
                    return;
                }
                showAlert?.({
                    message: 'Request sent to host.',
                    type: 'success',
                    duration: 3000,
                });
                videoRequestState = 'pending';
                updateVideoRequestState(videoRequestState);
                let userRequest = { id: socket.id, name: member, icon: 'fa-video' };
                socket.emit('participantRequest', { userRequest, roomName });
            }
            else if (response === 2) {
                showAlert?.({
                    message: 'You cannot turn on your camera. Access denied by host.',
                    type: 'danger',
                    duration: 3000,
                });
            }
            else {
                if (!hasCameraPermission) {
                    if (checkMediaPermission) {
                        let statusCamera = await requestPermissionCamera();
                        if (statusCamera !== 'granted') {
                            showAlert?.({
                                message: 'Allow access to your camera or check if your camera is not being used by another application.',
                                type: 'danger',
                                duration: 3000,
                            });
                            return;
                        }
                    }
                }
                let mediaConstraints = {};
                let altMediaConstraints = {};
                if (userDefaultVideoInputDevice) {
                    if (vidCons && vidCons.width && vidCons.height) {
                        mediaConstraints = {
                            video: {
                                deviceId: userDefaultVideoInputDevice,
                                facingMode: currentFacingMode,
                                ...vidCons,
                                frameRate: { ideal: frameRate },
                            },
                            audio: false,
                        };
                        altMediaConstraints = {
                            video: { ...vidCons, frameRate: { ideal: frameRate } },
                            audio: false,
                        };
                    }
                    else {
                        mediaConstraints = {
                            video: { ...vidCons, frameRate: { ideal: frameRate } },
                            audio: false,
                        };
                        altMediaConstraints = { video: { frameRate: { ideal: frameRate } }, audio: false };
                    }
                }
                else {
                    if (vidCons && vidCons.width && vidCons.height) {
                        mediaConstraints = {
                            video: { ...vidCons, frameRate: { ideal: frameRate } },
                            audio: false,
                        };
                        altMediaConstraints = {
                            video: { ...vidCons, frameRate: { ideal: frameRate } },
                            audio: false,
                        };
                    }
                    else {
                        mediaConstraints = { video: { frameRate: { ideal: frameRate } }, audio: false };
                    }
                }
                await navigator.mediaDevices
                    .getUserMedia(mediaConstraints)
                    .then(async (stream) => {
                    await streamSuccessVideo({ stream, parameters });
                })
                    .catch(async () => {
                    await navigator.mediaDevices
                        .getUserMedia(altMediaConstraints)
                        .then(async (stream) => {
                        await streamSuccessVideo({ stream, parameters });
                    })
                        .catch(() => {
                        showAlert?.({
                            message: 'Allow access to your camera or check if your camera is not being used by another application.',
                            type: 'danger',
                            duration: 3000,
                        });
                    });
                });
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ClickVideo, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ClickVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ClickVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ClickAudio {
    /**
     * Handles the click event for toggling audio in a media session.
     *
     * @param {ClickAudioOptions} parameters - The parameters required for handling the audio click event.
     * @returns {Promise<void>} A promise that resolves when the audio click event has been handled.
     *
     * The function performs the following actions:
     * - If the event is audio-only, it shows an alert and exits.
     * - If the audio is already on, it handles the logic for turning it off, including checking recording states and permissions.
     * - If the audio is off, it checks for admin restrictions, user permissions, and handles the logic for turning the audio on.
     * - It updates various states and emits socket events as necessary.
     *
     * The function makes use of several helper functions and state update functions passed in through the parameters.
     */
    async clickAudio({ parameters }) {
        let { checkMediaPermission, hasAudioPermission, audioPaused, audioAlreadyOn, audioOnlyRoom, recordStarted, recordResumed, recordPaused, recordStopped, recordingMediaOptions, islevel, youAreCoHost, adminRestrictSetting, audioRequestState, audioRequestTime, member, socket, roomName, userDefaultAudioInputDevice, micAction, localStream, audioSetting, videoSetting, screenshareSetting, chatSetting, updateRequestIntervalSeconds, participants, showAlert, transportCreated, transportCreatedAudio, updateAudioAlreadyOn, updateAudioRequestState, updateAudioPaused, updateLocalStream, updateParticipants, updateTransportCreated, updateTransportCreatedAudio, updateMicAction, checkPermission, streamSuccessAudio, requestPermissionAudio, resumeSendTransportAudio, disconnectSendTransportAudio, } = parameters;
        if (audioOnlyRoom) {
            showAlert?.({
                message: 'You cannot turn on your camera in an audio-only event.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (audioAlreadyOn) {
            if (islevel === '2' && (recordStarted || recordResumed)) {
                if (!(recordPaused || recordStopped)) {
                    if (recordingMediaOptions === 'audio') {
                        showAlert?.({
                            message: 'You cannot turn off your audio while recording, please pause or stop recording first.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                }
            }
            audioAlreadyOn = false;
            updateAudioAlreadyOn(audioAlreadyOn);
            if (localStream) {
                localStream.getAudioTracks()[0].enabled = false;
            }
            updateLocalStream(localStream);
            await disconnectSendTransportAudio({ parameters }); //disconnect function here actuall calls audioProducer.pause() instead of close() as in mediasfu
            audioPaused = true;
            updateAudioPaused(audioPaused);
        }
        else {
            if (adminRestrictSetting) {
                showAlert?.({
                    message: 'You cannot turn on your microphone. Access denied by host.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            let response = 2;
            if (!micAction && islevel !== '2' && !youAreCoHost) {
                response = await checkPermission({
                    permissionType: 'audioSetting',
                    audioSetting,
                    videoSetting,
                    screenshareSetting,
                    chatSetting,
                });
            }
            else {
                response = 0;
            }
            switch (response) {
                case 1: {
                    if (audioRequestState === 'pending') {
                        showAlert?.({
                            message: 'A request is pending. Please wait for the host to respond.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                    showAlert?.({
                        message: 'Request sent to host.',
                        type: 'success',
                        duration: 3000,
                    });
                    audioRequestState = 'pending';
                    updateAudioRequestState(audioRequestState);
                    //create a request and add to the request list and send to host
                    const userRequest = {
                        id: socket.id,
                        name: member,
                        icon: 'fa-microphone',
                    };
                    socket.emit('participantRequest', { userRequest, roomName });
                    break;
                }
                case 2:
                    if (audioRequestState === 'rejected' &&
                        Date.now() - audioRequestTime < updateRequestIntervalSeconds * 1000) {
                        showAlert?.({
                            message: `A request was rejected. Please wait for ${updateRequestIntervalSeconds} seconds before sending another request.`,
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                    break;
                case 0:
                    //allow
                    if (audioPaused) {
                        if (localStream) {
                            localStream.getAudioTracks()[0].enabled = true;
                        }
                        updateAudioAlreadyOn(true);
                        await resumeSendTransportAudio({ parameters });
                        socket.emit('resumeProducerAudio', { mediaTag: 'audio', roomName });
                        updateLocalStream(localStream);
                        updateAudioAlreadyOn(audioAlreadyOn);
                        if (micAction == true) {
                            micAction = false;
                            updateMicAction(micAction);
                        }
                        participants.forEach((participant) => {
                            if (participant['socketId'] === socket.id && participant.name === member) {
                                participant.muted = false;
                            }
                        });
                        updateParticipants(participants);
                        transportCreated = true;
                        updateTransportCreated(transportCreated);
                        transportCreatedAudio = true;
                        updateTransportCreatedAudio(transportCreatedAudio);
                    }
                    else {
                        if (!hasAudioPermission && checkMediaPermission) {
                            const statusMic = await requestPermissionAudio();
                            if (statusMic !== 'granted') {
                                showAlert?.({
                                    message: 'Allow access to your microphone or check if your microphone is not being used by another application.',
                                    type: 'danger',
                                    duration: 3000,
                                });
                                return;
                            }
                        }
                        const mediaConstraints = userDefaultAudioInputDevice
                            ? { audio: { deviceId: userDefaultAudioInputDevice }, video: false }
                            : { audio: true, video: false };
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
                            await streamSuccessAudio({ stream, parameters });
                        }
                        catch (error) {
                            console.error(error);
                            showAlert?.({
                                message: 'Allow access to your microphone or check if your microphone is not being used by another application.',
                                type: 'danger',
                                duration: 3000,
                            });
                        }
                    }
                    break;
                default:
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ClickAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ClickAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ClickAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// screen-share.service.ts
class ClickScreenShare {
    /**
     * Handles the action for the screen button, including starting and stopping screen sharing.
     *
     * @param {ClickScreenShareParams} options - Options for handling the screen button action.
     * @returns {Promise<void>}
     */
    clickScreenShare = async ({ parameters }) => {
        parameters = { ...parameters, ...parameters.getUpdatedAllParams() };
        let { showAlert, roomName, member, socket, islevel, youAreCoHost, adminRestrictSetting, audioSetting, videoSetting, screenshareSetting, chatSetting, screenAction, screenAlreadyOn, screenRequestState, screenRequestTime, audioOnlyRoom, updateRequestIntervalSeconds, updateScreenRequestState, updateScreenAlreadyOn, checkPermission, checkScreenShare, stopShareScreen, } = parameters;
        if (audioOnlyRoom) {
            showAlert?.({
                message: 'You cannot turn on your camera in an audio-only event.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (roomName.startsWith('d')) {
            showAlert?.({
                message: 'You cannot start screen share in a demo room.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (screenAlreadyOn) {
            screenAlreadyOn = false;
            updateScreenAlreadyOn(screenAlreadyOn);
            await stopShareScreen({ parameters });
        }
        else {
            if (adminRestrictSetting) {
                showAlert?.({
                    message: 'You cannot start screen share. Access denied by host.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            let response = 2;
            if (!screenAction && islevel != '2' && !youAreCoHost) {
                response = await checkPermission({
                    permissionType: 'screenshareSetting',
                    audioSetting,
                    videoSetting,
                    screenshareSetting,
                    chatSetting,
                });
            }
            else {
                response = 0;
            }
            switch (response) {
                case 0:
                    checkScreenShare({ parameters });
                    break;
                case 1: {
                    if (screenRequestState === 'pending') {
                        showAlert?.({
                            message: 'A request is already pending. Please wait for the host to respond.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                    if (screenRequestState === 'rejected' &&
                        Date.now() - screenRequestTime < updateRequestIntervalSeconds) {
                        showAlert?.({
                            message: 'You cannot send another request at this time.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                    showAlert?.({
                        message: 'Your request has been sent to the host.',
                        type: 'success',
                        duration: 3000,
                    });
                    screenRequestState = 'pending';
                    updateScreenRequestState(screenRequestState);
                    let userRequest = { id: socket.id, name: member, icon: 'fa-desktop' };
                    socket.emit('participantRequest', { userRequest, roomName });
                    break;
                }
                case 2:
                    showAlert?.({
                        message: 'You are not allowed to start screen share.',
                        type: 'danger',
                        duration: 3000,
                    });
                    break;
                default:
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ClickScreenShare, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ClickScreenShare, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ClickScreenShare, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class StreamSuccessVideo {
    /**
     * Streams a video successfully by managing the local stream, updating parameters, and handling video transport.
     *
     * @param {StreamSuccessVideoOptions} options - The options for streaming the video.
     * @param {MediaStream} options.stream - The media stream to be used for the video.
     * @param {Object} options.parameters - The parameters required for streaming.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     *
     * @returns {Promise<void>} A promise that resolves when the video has been successfully streamed.
     *
     * @throws Will throw an error if there is an issue with streaming the video.
     */
    streamSuccessVideo = async ({ stream, parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        try {
            let { socket, participants, localStream, transportCreated, transportCreatedVideo, videoAlreadyOn, videoAction, videoParams, localStreamVideo, defVideoID, userDefaultVideoInputDevice, params, videoParamse, islevel, member, updateMainWindow, lock_screen, shared, shareScreenStarted, vParams, hParams, allowed, currentFacingMode, device, keepBackground, appliedBackground, videoProducer, 
            // update functions
            updateTransportCreatedVideo, updateVideoAlreadyOn, updateVideoAction, updateLocalStream, updateLocalStreamVideo, updateUserDefaultVideoInputDevice, updateCurrentFacingMode, updateDefVideoID, updateAllowed, updateUpdateMainWindow, updateParticipants, updateVideoParams, updateIsBackgroundModalVisible, updateAutoClickBackground, 
            // mediasfu functions
            createSendTransport, connectSendTransportVideo, showAlert, reorderStreams, sleep, } = parameters;
            localStreamVideo = stream;
            updateLocalStreamVideo(localStreamVideo);
            // Add the video stream track to localStream
            if (localStream == null) {
                localStream = new MediaStream([localStreamVideo.getVideoTracks()[0]]);
                updateLocalStream(localStream);
            }
            else {
                // Remove all video tracks that are currently in the localStream
                localStream.getVideoTracks().forEach((track) => {
                    localStream?.removeTrack(track);
                });
                // Add the new video track to the localStream
                localStream.addTrack(localStreamVideo.getVideoTracks()[0]);
                updateLocalStream(localStream);
            }
            // Get the video track settings
            const videoTracked = localStream.getVideoTracks()[0];
            defVideoID = videoTracked.getSettings().deviceId ?? '';
            userDefaultVideoInputDevice = defVideoID;
            currentFacingMode = videoTracked.getSettings().facingMode ?? 'user';
            // Update the state variables
            if (defVideoID) {
                updateDefVideoID(defVideoID);
            }
            if (userDefaultVideoInputDevice) {
                updateUserDefaultVideoInputDevice(userDefaultVideoInputDevice);
            }
            if (currentFacingMode) {
                updateCurrentFacingMode(currentFacingMode);
            }
            allowed = true;
            updateAllowed(allowed);
            try {
                // Apply the video constraints
                if (islevel == '2') {
                    if (!shared || !shareScreenStarted) {
                        params = hParams;
                        videoParamse = { ...params };
                    }
                    else {
                        params = vParams;
                        videoParamse = { ...params };
                    }
                }
                else {
                    params = vParams;
                    videoParamse = { ...params };
                }
                // Remove VP9 codec from the video codecs; support only VP8 and H264
                let codec = device?.rtpCapabilities?.codecs?.filter((codec) => codec.mimeType.toLowerCase() !== 'video/vp9' && codec.kind === 'video');
                // Create transport if not created else connect transport
                if (codec && codec.length > 0) {
                    videoParams = {
                        track: localStream.getVideoTracks()[0],
                        ...videoParamse,
                        codec: codec[0],
                    };
                }
                else {
                    throw new Error('No suitable video codec found');
                }
                updateVideoParams(videoParams);
                if (keepBackground && appliedBackground) {
                    videoAlreadyOn = true;
                    updateVideoAlreadyOn(videoAlreadyOn);
                    updateAutoClickBackground(true);
                    updateIsBackgroundModalVisible(true);
                    await sleep({ ms: 500 });
                    updateIsBackgroundModalVisible(false);
                    updateAutoClickBackground(false);
                }
                else {
                    if (!transportCreated) {
                        try {
                            await createSendTransport({
                                parameters: {
                                    ...parameters,
                                    videoParams: videoParams,
                                },
                                option: 'video',
                            });
                        }
                        catch (error) {
                            console.log('Error creating send transport:', error);
                        }
                    }
                    else {
                        try {
                            videoProducer?.close();
                            await sleep({ ms: 500 });
                        }
                        catch {
                            /* handle error */
                        }
                        await connectSendTransportVideo({
                            parameters: parameters,
                            videoParams: videoParams,
                        });
                    }
                }
            }
            catch (error) {
                showAlert?.({
                    message: error.message,
                    type: 'danger',
                    duration: 3000,
                });
            }
            // Update the videoAlreadyOn state
            videoAlreadyOn = true;
            updateVideoAlreadyOn(videoAlreadyOn);
            // If user requested to share video, update the videoAction state
            if (videoAction) {
                videoAction = false;
                updateVideoAction(videoAction);
            }
            // Update the display screen if host
            if (islevel == '2') {
                updateMainWindow = true;
                updateUpdateMainWindow(updateMainWindow);
            }
            // Update the participants array to reflect the change
            participants.forEach((participant) => {
                if (participant.socketId == socket.id && participant.name == member) {
                    participant.videoOn = true;
                }
            });
            updateParticipants(participants);
            // Update the transport created state
            transportCreatedVideo = true;
            updateTransportCreatedVideo(transportCreatedVideo);
            // Reupdate the screen display
            if (lock_screen) {
                try {
                    await reorderStreams({
                        add: true,
                        screenChanged: true,
                        parameters: { ...parameters, videoAlreadyOn },
                    });
                }
                catch (error) {
                    console.log('Error reordering streams with lock screen:', error);
                }
            }
            else {
                try {
                    await reorderStreams({
                        add: false,
                        screenChanged: true,
                        parameters: { ...parameters, videoAlreadyOn },
                    });
                }
                catch (error) {
                    console.log('Error reordering streams without lock screen:', error);
                }
            }
        }
        catch (error) {
            const { showAlert } = parameters;
            console.log('Error in streamSuccessVideo:', error);
            showAlert?.({
                message: error.message,
                type: 'danger',
                duration: 3000,
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessVideo, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class StreamSuccessAudio {
    /**
     * Handles the successful streaming of audio by setting up the necessary transports and updating the relevant states.
     *
     * @param {Object} options - The options for streaming success audio.
     * @param {MediaStream} options.stream - The media stream containing the audio track.
     * @param {Object} options.parameters - The parameters required for setting up the audio stream.
     * @param {Object} options.parameters.socket - The socket connection.
     * @param {Array} options.parameters.participants - The list of participants.
     * @param {MediaStream} options.parameters.localStream - The local media stream.
     * @param {boolean} options.parameters.transportCreated - Flag indicating if the transport is created.
     * @param {boolean} options.parameters.transportCreatedAudio - Flag indicating if the audio transport is created.
     * @param {boolean} options.parameters.audioAlreadyOn - Flag indicating if the audio is already on.
     * @param {boolean} options.parameters.micAction - Flag indicating the microphone action.
     * @param {Object} options.parameters.audioParams - The audio parameters.
     * @param {MediaStream} options.parameters.localStreamAudio - The local audio stream.
     * @param {string} options.parameters.defAudioID - The default audio device ID.
     * @param {string} options.parameters.userDefaultAudioInputDevice - The user default audio input device.
     * @param {Object} options.parameters.params - Additional parameters.
     * @param {Object} options.parameters.audioParamse - Additional audio parameters.
     * @param {Object} options.parameters.aParams - Additional parameters for audio.
     * @param {string} options.parameters.hostLabel - The label of the host.
     * @param {string} options.parameters.islevel - The level of the user.
     * @param {string} options.parameters.member - The member name.
     * @param {boolean} options.parameters.updateMainWindow - Flag indicating if the main window should be updated.
     * @param {boolean} options.parameters.lock_screen - Flag indicating if the screen is locked.
     * @param {boolean} options.parameters.shared - Flag indicating if the screen is shared.
     * @param {boolean} options.parameters.videoAlreadyOn - Flag indicating if the video is already on.
     * @param {Function} options.parameters.showAlert - Function to show alert messages.
     * @param {Function} options.parameters.updateParticipants - Function to update participants.
     * @param {Function} options.parameters.updateTransportCreated - Function to update transport created flag.
     * @param {Function} options.parameters.updateTransportCreatedAudio - Function to update audio transport created flag.
     * @param {Function} options.parameters.updateAudioAlreadyOn - Function to update audio already on flag.
     * @param {Function} options.parameters.updateMicAction - Function to update microphone action flag.
     * @param {Function} options.parameters.updateAudioParams - Function to update audio parameters.
     * @param {Function} options.parameters.updateLocalStream - Function to update local stream.
     * @param {Function} options.parameters.updateLocalStreamAudio - Function to update local audio stream.
     * @param {Function} options.parameters.updateDefAudioID - Function to update default audio device ID.
     * @param {Function} options.parameters.updateUserDefaultAudioInputDevice - Function to update user default audio input device.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update main window flag.
     * @param {Function} options.parameters.createSendTransport - Function to create send transport.
     * @param {Function} options.parameters.connectSendTransportAudio - Function to connect send transport audio.
     * @param {Function} options.parameters.resumeSendTransportAudio - Function to resume send transport audio.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @returns {Promise<void>} A promise that resolves when the audio streaming setup is complete.
     */
    async streamSuccessAudio({ stream, parameters }) {
        let { socket, participants, localStream, transportCreated, transportCreatedAudio, audioAlreadyOn, micAction, audioParams, localStreamAudio, defAudioID, userDefaultAudioInputDevice, params, audioParamse, aParams, hostLabel, islevel, member, updateMainWindow, lock_screen, shared, videoAlreadyOn, showAlert, 
        // update functions
        updateParticipants, updateTransportCreated, updateTransportCreatedAudio, updateAudioAlreadyOn, updateMicAction, updateAudioParams, updateLocalStream, updateLocalStreamAudio, updateDefAudioID, updateUserDefaultAudioInputDevice, updateUpdateMainWindow, 
        // mediasfu functions
        createSendTransport, connectSendTransportAudio, resumeSendTransportAudio, prepopulateUserMedia, } = parameters;
        localStreamAudio = stream;
        updateLocalStreamAudio(localStreamAudio);
        // Add the audio stream track to the localStream
        if (localStream == null) {
            localStream = new MediaStream([localStreamAudio.getAudioTracks()[0]]);
            updateLocalStream(localStream);
        }
        else {
            localStream.addTrack(localStreamAudio.getAudioTracks()[0]);
            updateLocalStream(localStream);
        }
        const audioTracked = localStream.getAudioTracks()[0];
        defAudioID = audioTracked.getSettings().deviceId || '';
        userDefaultAudioInputDevice = defAudioID;
        // Update the state variables
        updateDefAudioID(defAudioID);
        updateUserDefaultAudioInputDevice(userDefaultAudioInputDevice);
        try {
            params = aParams;
            audioParamse = { ...params };
            audioParams = { track: localStream.getAudioTracks()[0], ...audioParamse };
            updateAudioParams(audioParams);
            // Create transport if not created else connect transport
            if (!transportCreated) {
                try {
                    await createSendTransport({
                        parameters: {
                            ...parameters,
                            audioParams: audioParams,
                        },
                        option: 'audio',
                    });
                }
                catch (error) {
                    console.error('Error creating send transport:', error);
                }
            }
            else {
                if (!transportCreatedAudio) {
                    await connectSendTransportAudio({
                        audioParams,
                        parameters,
                    });
                }
                else {
                    await resumeSendTransportAudio({ parameters });
                }
            }
        }
        catch (error) {
            showAlert?.({
                message: error.message,
                type: 'danger',
                duration: 3000,
            });
        }
        // Update the participants array to reflect the change
        audioAlreadyOn = true;
        updateAudioAlreadyOn(audioAlreadyOn);
        if (micAction) {
            micAction = false;
            updateMicAction(micAction);
        }
        participants.forEach((participant) => {
            if (participant.socketId == socket.id && participant.name == member) {
                participant.muted = false;
            }
        });
        updateParticipants(participants);
        // Update the transport created state
        transportCreated = true;
        transportCreatedAudio = true;
        updateTransportCreated(transportCreated);
        updateTransportCreatedAudio(transportCreatedAudio);
        // Reupdate screen display if host
        if (videoAlreadyOn == false && islevel == '2') {
            if (!lock_screen && !shared) {
                updateMainWindow = true;
                updateUpdateMainWindow(updateMainWindow);
                await prepopulateUserMedia({ name: hostLabel, parameters });
                updateMainWindow = false;
                updateUpdateMainWindow(updateMainWindow);
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class StreamSuccessScreen {
    /**
     * Handles the successful initiation of screen sharing.
     *
     * @param {StreamSuccessScreenOptions} options - The options for the screen sharing success handler.
     * @param {MediaStream} options.stream - The media stream to be shared.
     * @param {Object} options.parameters - The parameters required for screen sharing.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {Socket} options.parameters.socket - The socket instance for communication.
     * @param {boolean} options.parameters.transportCreated - Flag indicating if the transport is already created.
     * @param {MediaStream} options.parameters.localStreamScreen - The local screen media stream.
     * @param {boolean} options.parameters.screenAlreadyOn - Flag indicating if the screen is already being shared.
     * @param {boolean} options.parameters.screenAction - Flag indicating if the screen share action is requested.
     * @param {boolean} options.parameters.transportCreatedScreen - Flag indicating if the screen transport is created.
     * @param {string} options.parameters.hostLabel - The label of the host.
     * @param {string} options.parameters.eventType - The type of the event (e.g., conference).
     * @param {Function} options.parameters.showAlert - Function to show alerts.
     * @param {boolean} options.parameters.annotateScreenStream - Flag indicating if screen annotation is enabled.
     * @param {Function} options.parameters.updateTransportCreatedScreen - Function to update the screen transport creation state.
     * @param {Function} options.parameters.updateScreenAlreadyOn - Function to update the screen sharing state.
     * @param {Function} options.parameters.updateScreenAction - Function to update the screen action state.
     * @param {Function} options.parameters.updateTransportCreated - Function to update the transport creation state.
     * @param {Function} options.parameters.updateLocalStreamScreen - Function to update the local screen stream.
     * @param {Function} options.parameters.updateShared - Function to update the shared state.
     * @param {Function} options.parameters.updateIsScreenboardModalVisible - Function to update the screenboard modal visibility.
     * @param {Function} options.parameters.sleep - Function to pause execution for a specified duration.
     * @param {Function} options.parameters.createSendTransport - Function to create a send transport.
     * @param {Function} options.parameters.connectSendTransportScreen - Function to connect the send transport for screen sharing.
     * @param {Function} options.parameters.disconnectSendTransportScreen - Function to disconnect the send transport for screen sharing.
     * @param {Function} options.parameters.stopShareScreen - Function to stop screen sharing.
     * @param {Function} options.parameters.reorderStreams - Function to reorder streams.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @param {Function} options.parameters.rePort - Function to reinitialize ports.
     *
     * @returns {Promise<void>} A promise that resolves when the screen sharing setup is complete.
     */
    async streamSuccessScreen({ stream, parameters }) {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { socket, transportCreated, localStreamScreen, screenAlreadyOn, screenAction, transportCreatedScreen, hostLabel, eventType, showAlert, annotateScreenStream, 
        // updates for the above
        updateTransportCreatedScreen, updateScreenAlreadyOn, updateScreenAction, updateTransportCreated, updateLocalStreamScreen, updateShared, updateIsScreenboardModalVisible, sleep, 
        // mediasfu functions
        createSendTransport, connectSendTransportScreen, disconnectSendTransportScreen, stopShareScreen, reorderStreams, prepopulateUserMedia, rePort, } = parameters;
        // Share screen on success
        localStreamScreen = stream;
        updateLocalStreamScreen(localStreamScreen);
        try {
            // Create transport if not created else connect transport
            if (!transportCreated) {
                await createSendTransport({
                    option: 'screen',
                    parameters: { ...parameters, localStreamScreen },
                });
            }
            else {
                await connectSendTransportScreen({
                    stream: localStreamScreen,
                    parameters: { ...parameters, localStreamScreen },
                });
            }
            // Alert the socket that you are sharing screen
            socket.emit('startScreenShare');
        }
        catch (error) {
            showAlert?.({
                message: error.message,
                type: 'danger',
                duration: 3000,
            });
        }
        // Reupdate the screen display
        try {
            updateShared(true);
            await prepopulateUserMedia({
                name: hostLabel,
                parameters: { ...parameters, localStreamScreen, shared: true },
            });
        }
        catch {
            /* handle error */
        }
        // Update the participants array to reflect the change
        screenAlreadyOn = true;
        updateScreenAlreadyOn(screenAlreadyOn);
        // Reorder streams if required
        try {
            if (eventType == 'conference') {
                await reorderStreams({ add: false, screenChanged: true, parameters });
                await prepopulateUserMedia({ name: hostLabel, parameters });
            }
            else {
                await reorderStreams({ parameters });
            }
        }
        catch (error) {
            try {
                await rePort({ parameters });
            }
            catch {
                /* handle error */
            }
        }
        // Handle screen share end
        localStreamScreen.getVideoTracks()[0].onended = async function () {
            // Supports both manual and automatic screen share end
            await disconnectSendTransportScreen({ parameters });
            await stopShareScreen({ parameters });
        };
        // If user requested to share screen, update the screenAction state
        if (screenAction == true) {
            screenAction = false;
        }
        updateScreenAction(screenAction);
        // Update the transport created state
        transportCreatedScreen = true;
        updateTransportCreatedScreen(transportCreatedScreen);
        updateTransportCreated(transportCreated);
        // Handle screen annotation modal
        try {
            if (annotateScreenStream) {
                annotateScreenStream = false;
                updateIsScreenboardModalVisible(true);
                await sleep({ ms: 500 });
                updateIsScreenboardModalVisible(false);
            }
        }
        catch (error) {
            //console.log('Error handling screen annotation:', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessScreen, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessScreen, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessScreen, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class StreamSuccessAudioSwitch {
    /**
     * Handles the switching of the audio stream upon successful stream connection.
     *
     * @param {Object} options - The options for the stream success audio switch.
     * @param {MediaStream} options.stream - The new media stream.
     * @param {Object} options.parameters - The parameters required for the audio switch.
     * @param {Producer} options.parameters.audioProducer - The current audio producer.
     * @param {Socket} options.parameters.socket - The socket connection.
     * @param {string} options.parameters.roomName - The name of the room.
     * @param {MediaStream} options.parameters.localStream - The local media stream.
     * @param {MediaStream} options.parameters.localStreamAudio - The local audio stream.
     * @param {Object} options.parameters.audioParams - The audio parameters.
     * @param {boolean} options.parameters.audioPaused - Indicates if the audio is paused.
     * @param {boolean} options.parameters.audioAlreadyOn - Indicates if the audio is already on.
     * @param {boolean} options.parameters.transportCreated - Indicates if the transport is created.
     * @param {Object} options.parameters.audioParamse - Additional audio parameters.
     * @param {string} options.parameters.defAudioID - The default audio device ID.
     * @param {string} options.parameters.userDefaultAudioInputDevice - The user default audio input device.
     * @param {string} options.parameters.hostLabel - The host label.
     * @param {boolean} options.parameters.updateMainWindow - Indicates if the main window should be updated.
     * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already on.
     * @param {string} options.parameters.islevel - The participant's level.
     * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
     * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
     * @param {Function} options.parameters.updateAudioProducer - Function to update the audio producer.
     * @param {Function} options.parameters.updateLocalStream - Function to update the local stream.
     * @param {Function} options.parameters.updateAudioParams - Function to update the audio parameters.
     * @param {Function} options.parameters.updateDefAudioID - Function to update the default audio device ID.
     * @param {Function} options.parameters.updateUserDefaultAudioInputDevice - Function to update the user default audio input device.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
     * @param {Function} options.parameters.sleep - Function to pause execution for a specified time.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @param {Function} options.parameters.createSendTransport - Function to create a send transport.
     * @param {Function} options.parameters.connectSendTransportAudio - Function to connect the send transport for audio.
     *
     * @returns {Promise<void>} A promise that resolves when the audio switch is complete.
     */
    async streamSuccessAudioSwitch({ stream, parameters, }) {
        let { audioProducer, socket, roomName, localStream, localStreamAudio, audioParams, audioPaused, audioAlreadyOn, transportCreated, audioParamse, defAudioID, userDefaultAudioInputDevice, hostLabel, updateMainWindow, videoAlreadyOn, islevel, lock_screen, shared, updateAudioProducer, updateLocalStream, updateAudioParams, updateDefAudioID, updateUserDefaultAudioInputDevice, updateUpdateMainWindow, 
        // mediasfu functions
        sleep, prepopulateUserMedia, createSendTransport, connectSendTransportAudio, } = parameters;
        // Get the new default audio device ID
        let newDefAudioID = stream.getAudioTracks()[0].getSettings().deviceId;
        // Check if the audio device has changed
        if (newDefAudioID != defAudioID) {
            // Close the current audioProducer
            if (audioProducer) {
                audioProducer.close();
                updateAudioProducer(audioProducer);
            }
            // Emit a pauseProducerMedia event to pause the audio media
            socket.emit('pauseProducerMedia', { mediaTag: 'audio', roomName: roomName, force: true });
            // Update the localStreamAudio with the new audio tracks
            localStreamAudio = stream;
            // If localStream is null, create a new MediaStream with the new audio track
            if (localStream == null) {
                localStream = new MediaStream([localStreamAudio.getAudioTracks()[0]]);
            }
            else {
                // Remove all existing audio tracks from localStream and add the new audio track
                localStream.getAudioTracks().forEach((track) => {
                    localStream?.removeTrack(track);
                });
                localStream.addTrack(localStreamAudio.getAudioTracks()[0]);
            }
            // Update localStream
            updateLocalStream(localStream);
            // Get the new default audio device ID from the new audio track
            const audioTracked = localStream.getAudioTracks()[0];
            defAudioID = audioTracked.getSettings().deviceId ?? '';
            updateDefAudioID(defAudioID);
            // Update userDefaultAudioInputDevice
            userDefaultAudioInputDevice = defAudioID;
            updateUserDefaultAudioInputDevice(userDefaultAudioInputDevice);
            // Update audioParams with the new audio track
            audioParams = { track: localStream.getAudioTracks()[0], ...audioParamse };
            updateAudioParams(audioParams);
            // Sleep for 500 milliseconds
            await sleep({ ms: 500 });
            // Create a new send transport if not created, otherwise, connect the existing transport
            if (!transportCreated) {
                try {
                    await createSendTransport({
                        parameters: {
                            ...parameters,
                            audioParams: audioParams,
                        },
                        option: 'audio',
                    });
                }
                catch (error) {
                    console.error('Error creating send transport:', error);
                }
            }
            else {
                await connectSendTransportAudio({
                    audioParams,
                    parameters,
                });
            }
            // If audio is paused and not already on, pause the audioProducer and emit a pauseProducerMedia event
            if (audioPaused && !audioAlreadyOn) {
                audioProducer?.pause();
                updateAudioProducer(audioProducer);
                socket.emit('pauseProducerMedia', { mediaTag: 'audio', roomName: roomName });
            }
        }
        // Update the UI based on the participant's level and screen lock status
        if (!videoAlreadyOn && islevel === '2') {
            if (!lock_screen && !shared) {
                // Set updateMainWindow to true, prepopulate user media, and set updateMainWindow back to false
                updateMainWindow = true;
                updateUpdateMainWindow(updateMainWindow);
                await prepopulateUserMedia({ name: hostLabel, parameters });
                updateMainWindow = false;
                updateUpdateMainWindow(updateMainWindow);
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessAudioSwitch, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessAudioSwitch, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StreamSuccessAudioSwitch, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CheckPermission {
    /**
     * Checks the permission based on the provided settings.
     *
     * @param {CheckPermissionOptions} options - The options for checking permissions.
     * @param {string} options.permissionType - The type of permission to check. Can be "audioSetting", "videoSetting", "screenshareSetting", or "chatSetting".
     * @param {string} options.audioSetting - The setting for audio permission. Can be "allow", "approval", or other.
     * @param {string} options.videoSetting - The setting for video permission. Can be "allow", "approval", or other.
     * @param {string} options.screenshareSetting - The setting for screenshare permission. Can be "allow", "approval", or other.
     * @param {string} options.chatSetting - The setting for chat permission. Can be "allow", "approval", or other.
     * @returns {Promise<number>} - Returns 0 if the setting is "allow", 1 if the setting is "approval", and 2 for other settings or invalid permission types.
     * @throws Will throw an error if an unexpected error occurs during the permission check.
     */
    async checkPermission({ permissionType, audioSetting, videoSetting, screenshareSetting, chatSetting, }) {
        try {
            // Perform a switch case to check for the permissionType and return the response
            switch (permissionType) {
                case 'audioSetting':
                    if (audioSetting === 'allow') {
                        return 0;
                    }
                    else if (audioSetting === 'approval') {
                        return 1;
                    }
                    else {
                        return 2;
                    }
                case 'videoSetting':
                    if (videoSetting === 'allow') {
                        return 0;
                    }
                    else if (videoSetting === 'approval') {
                        return 1;
                    }
                    else {
                        return 2;
                    }
                case 'screenshareSetting':
                    if (screenshareSetting === 'allow') {
                        return 0;
                    }
                    else if (screenshareSetting === 'approval') {
                        return 1;
                    }
                    else {
                        return 2;
                    }
                case 'chatSetting':
                    if (chatSetting === 'allow') {
                        return 0;
                    }
                    else if (chatSetting === 'approval') {
                        return 1;
                    }
                    else {
                        return 2;
                    }
                default:
                    // throw new Error(`Invalid permissionType: ${permissionType}`);
                    return 2;
            }
        }
        catch (error) {
            // console.log('checkPermission error', error);
            // throw error;
            return 2;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckPermission, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckPermission, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckPermission, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ProducerClosed {
    /**
     * Handles the closing of a producer and resizes video elements.
     * @param {Object} options - The options object containing necessary variables.
     * @param {string} options.remoteProducerId - The ID of the remote producer.
     * @param {any} options.parameters - Additional parameters required for the function.
     * @returns {Promise<void>}
     */
    producerClosed = async ({ remoteProducerId, parameters, }) => {
        let { consumerTransports, screenId, updateConsumerTransports, 
        // mediasfu functions
        closeAndResize, } = parameters;
        // Handle producer closed
        const producerToClose = consumerTransports.find((transportData) => transportData.producerId === remoteProducerId);
        if (!producerToClose) {
            return;
        }
        // Check if the ID of the producer to close is == screenId
        let kind = producerToClose.consumer.kind;
        if (producerToClose.producerId == screenId) {
            kind = 'screenshare';
        }
        try {
            await producerToClose['consumerTransport'].close();
        }
        catch (error) {
            console.error('Error closing consumerTransport:', error);
        }
        try {
            producerToClose.consumer.close();
        }
        catch (error) {
            console.error('Error closing consumer:', error);
        }
        consumerTransports = consumerTransports.filter((transportData) => transportData.producerId !== remoteProducerId);
        updateConsumerTransports(consumerTransports);
        // Close and resize the videos
        await closeAndResize({ producerId: remoteProducerId, kind: kind, parameters: parameters });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerClosed, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerClosed, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerClosed, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class SignalNewConsumerTransport {
    /**
     * Signals the creation of a new consumer transport.
     *
     * @param {Object} options - The options for signaling a new consumer transport.
     * @param {string} options.remoteProducerId - The ID of the remote producer.
     * @param {boolean} options.islevel - Indicates the level of the consumer.
     * @param {any} options.nsock - The socket instance for communication.
     * @param {SignalNewConsumerTransportOptions} options.parameters - The parameters for the transport.
     *
     * @returns {Promise<string[] | void>} A promise that resolves to an array of consuming transports or void.
     *
     * @throws Will throw an error if the signaling process fails.
     *
     * @example
     * const options = {
     *   remoteProducerId: 'producer-id',
     *   islevel: true,
     *   nsock: socketInstance,
     *   parameters: {
     *     device: mediaDevice,
     *     consumingTransports: [],
     *     lock_screen: false,
     *     updateConsumingTransports: updateFunction,
     *     connectRecvTransport: connectFunction,
     *     reorderStreams: reorderFunction,
     *     getUpdatedAllParams: getUpdatedParamsFunction,
     *   },
     * };
     *
     * signalNewConsumerTransport(options)
     *   .then(consumingTransports => {
     *     console.log('Consuming Transports:', consumingTransports);
     *   })
     *   .catch(error => {
     *     console.error('Error signaling new consumer transport:', error);
     *   });
     */
    signalNewConsumerTransport = async ({ remoteProducerId, islevel, nsock, parameters, }) => {
        try {
            let { device, consumingTransports, lock_screen, updateConsumingTransports, connectRecvTransport, reorderStreams, } = parameters;
            // Get updated parameters
            const updatedParams = parameters.getUpdatedAllParams();
            device = updatedParams.device;
            consumingTransports = updatedParams.consumingTransports;
            // Check if already consuming
            if (consumingTransports.includes(remoteProducerId)) {
                return consumingTransports;
            }
            // Add remote producer ID to consumingTransports array
            consumingTransports.push(remoteProducerId);
            updateConsumingTransports(consumingTransports);
            // Emit createWebRtcTransport event to signal a new consumer
            nsock.emit('createWebRtcTransport', { consumer: true, islevel }, async ({ params }) => {
                if (params.error) {
                    // Handle error
                    return;
                }
                try {
                    // Create a new receiving transport using the received parameters
                    if (!device) {
                        throw new Error('Device is not initialized');
                    }
                    const consumerTransport = device.createRecvTransport({ ...params });
                    // Handle 'connect' event for the consumer transport
                    consumerTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
                        try {
                            // Emit transport-recv-connect event to signal connection
                            nsock.emit('transport-recv-connect', {
                                dtlsParameters,
                                serverConsumerTransportId: params.id,
                            });
                            callback();
                        }
                        catch (error) {
                            errback(error);
                        }
                    });
                    // Listen for connection state change
                    consumerTransport.on('connectionstatechange', async (state) => {
                        switch (state) {
                            case 'connecting':
                                // Handle connecting state
                                break;
                            case 'connected':
                                // Handle connected state
                                break;
                            case 'failed':
                                // Handle failed state
                                consumerTransport.close();
                                // Reorder streams based on conditions
                                if (lock_screen) {
                                    await reorderStreams({ add: true, parameters });
                                }
                                else {
                                    await reorderStreams({ add: false, parameters });
                                }
                                break;
                            default:
                                break;
                        }
                    });
                    // Connect the receiving transport
                    await connectRecvTransport({
                        consumerTransport,
                        remoteProducerId,
                        serverConsumerTransportId: params.id,
                        nsock,
                        parameters,
                    });
                }
                catch (error) {
                    console.log(error, 'createRecvTransport error');
                    // Handle error
                    return;
                }
            });
        }
        catch (error) {
            console.log(error, 'signalNewConsumerTransport error');
            // Handle error
            return;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SignalNewConsumerTransport, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SignalNewConsumerTransport, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SignalNewConsumerTransport, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class NewPipeProducer {
    signalNewConsumerTransportService;
    constructor(signalNewConsumerTransportService) {
        this.signalNewConsumerTransportService = signalNewConsumerTransportService;
    }
    /**
     * Handles new pipe producer events and updates relevant states.
     * @param {Object} options - The options object containing necessary variables.
     * @param {string} options.producerId - The ID of the producer.
     * @param {string} options.islevel - The level of the producer.
     * @param {any} options.nsock - The socket object.
     * @param {any} options.parameters - Additional parameters required for the function.
     * @returns {Promise<void>}
     */
    newPipeProducer = async ({ producerId, islevel, nsock, parameters, }) => {
        let { first_round, shareScreenStarted, shared, landScaped, showAlert, isWideScreen, updateFirst_round, updateLandScaped, } = parameters;
        try {
            // Perform signaling for new consumer transport
            await this.signalNewConsumerTransportService.signalNewConsumerTransport({
                remoteProducerId: producerId,
                islevel: islevel,
                nsock: nsock,
                parameters: parameters,
            });
            first_round = false;
            if (shareScreenStarted || shared) {
                if (!isWideScreen) {
                    if (!landScaped) {
                        if (showAlert) {
                            showAlert({
                                message: 'Please rotate your device to landscape mode for better experience',
                                type: 'success',
                                duration: 3000,
                            });
                        }
                        landScaped = true;
                        updateLandScaped(landScaped);
                    }
                }
                first_round = true;
                updateFirst_round(first_round);
            }
        }
        catch (error) {
            console.error('Error in newPipeProducer:', error);
            throw new Error('Failed to handle new pipe producer event.');
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: NewPipeProducer, deps: [{ token: SignalNewConsumerTransport }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: NewPipeProducer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: NewPipeProducer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: SignalNewConsumerTransport }] });

class UpdateMiniCardsGrid {
    /**
     * Updates the mini cards grid based on the specified rows and columns.
     *
     * @param {object} options - The function parameters.
     * @param {number} options.rows - The number of rows in the grid.
     * @param {number} options.cols - The number of columns in the grid.
     * @param {boolean} options.defal - Flag indicating whether to update the default grid or an alternative grid.
     * @param {number} options.actualRows - The actual number of rows in the grid.
     * @param {number} options.ind - The index parameter.
     * @param {object} options.parameters - Additional parameters needed for the function.
     * @param {function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {function} options.parameters.updateGridRows - Function to update the grid rows.
     * @param {function} options.parameters.updateGridCols - Function to update the grid columns.
     * @param {function} options.parameters.updateAltGridRows - Function to update the alternative grid rows.
     * @param {function} options.parameters.updateAltGridCols - Function to update the alternative grid columns.
     * @param {function} options.parameters.updateGridSizes - Function to update the grid sizes.
     * @param {object} options.parameters.gridSizes - Object containing grid width and height.
     * @param {string} options.parameters.paginationDirection - The direction of pagination ('horizontal' or 'vertical').
     * @param {number} options.parameters.paginationHeightWidth - The height or width of pagination.
     * @param {boolean} options.parameters.doPaginate - Flag indicating whether pagination is enabled.
     * @param {object} options.parameters.componentSizes - Object containing container width and height.
     * @param {string} options.parameters.eventType - The type of event ('chat', etc.).
     * @returns {Promise<void>} - A Promise that resolves after updating the mini cards grid.
     */
    async updateMiniCardsGrid({ rows, cols, defal = true, actualRows = 2, parameters, }) {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { updateGridRows, updateGridCols, updateAltGridRows, updateAltGridCols, updateGridSizes, gridSizes, paginationDirection, paginationHeightWidth, doPaginate, componentSizes, eventType, } = parameters;
        let containerWidth = componentSizes.otherWidth;
        let containerHeight = componentSizes.otherHeight;
        if (doPaginate) {
            // if pagination is enabled and direction is horizontal
            if (paginationDirection == 'horizontal') {
                containerHeight = containerHeight - paginationHeightWidth;
            }
            else {
                containerWidth = containerWidth - paginationHeightWidth;
            }
        }
        let cardSpacing = 3; // 3px margin between cards
        if (eventType == 'chat') {
            cardSpacing = 0;
        }
        let totalSpacingHorizontal = (cols - 1) * cardSpacing;
        let totalSpacingVertical = (actualRows - 1) * cardSpacing;
        let cardWidth;
        let cardHeight;
        if (cols == 0 || actualRows == 0) {
            cardWidth = 0;
            cardHeight = 0;
        }
        else {
            cardWidth = Math.floor((containerWidth - totalSpacingHorizontal) / cols);
            cardHeight = Math.floor((containerHeight - totalSpacingVertical) / actualRows);
        }
        if (defal) {
            updateGridRows(rows);
            updateGridCols(cols);
            gridSizes = { ...gridSizes, gridWidth: cardWidth, gridHeight: cardHeight };
            updateGridSizes(gridSizes);
        }
        else {
            updateAltGridRows(rows);
            updateAltGridCols(cols);
            gridSizes = { ...gridSizes, altGridWidth: cardWidth, altGridHeight: cardHeight };
            updateGridSizes(gridSizes);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateMiniCardsGrid, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateMiniCardsGrid, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateMiniCardsGrid, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class MixStreams {
    /**
     * Mixes video and audio streams and participants based on specified parameters.
     *
     * @param {Object} options - The options for mixing streams.
     * @param {Array} options.alVideoStreams - The list of audio and video streams to mix.
     * @param {Array} options.non_alVideoStreams - The list of non-audio and video streams to mix.
     * @param {Array} options.ref_participants - The list of reference participants to mix.
     * @returns {Promise<Array>} A promise that resolves with the mixed streams.
     * @throws Will throw an error if there is an issue mixing the streams.
     * @example
     * ```typescript
     * mixStreams({
     *   alVideoStreams: [stream1, stream2],
     *  non_alVideoStreams: [participant1, participant2],
     * ref_participants: [participant1, participant2]
     * });
     *
     * ```
     */
    async mixStreams({ alVideoStreams, non_alVideoStreams, ref_participants, }) {
        try {
            const mixedStreams = [];
            const youyouStream = alVideoStreams.find((obj) => obj.producerId === 'youyou' || obj.producerId === 'youyouyou');
            alVideoStreams = alVideoStreams.filter((obj) => obj.producerId !== 'youyou' && obj.producerId !== 'youyouyou');
            const unmutedAlVideoStreams = alVideoStreams.filter((obj) => {
                const participant = ref_participants.find((p) => p.videoID === obj.producerId);
                return !obj.muted && participant && participant.muted === false;
            });
            const mutedAlVideoStreams = alVideoStreams.filter((obj) => {
                const participant = ref_participants.find((p) => p.videoID === obj.producerId);
                return obj.muted || (participant && participant.muted === true);
            });
            const nonAlVideoStreams = non_alVideoStreams.slice(); // Create a copy of non_alVideoStreams
            // Add unmutedAlVideoStreams to mixedStreams
            mixedStreams.push(...unmutedAlVideoStreams);
            // Interleave the mutedAlVideoStreams and nonAlVideoStreams
            let nonAlIndex = 0;
            for (let i = 0; i < mutedAlVideoStreams.length; i++) {
                if (nonAlIndex < nonAlVideoStreams.length) {
                    mixedStreams.push(nonAlVideoStreams[nonAlIndex]);
                    nonAlIndex++;
                }
                mixedStreams.push(mutedAlVideoStreams[i]);
            }
            // Handle remaining nonAlVideoStreams (if any)
            for (let i = nonAlIndex; i < nonAlVideoStreams.length; i++) {
                mixedStreams.push(nonAlVideoStreams[i]);
            }
            // Unshift 'youyou' or 'youyouyou' stream to mixedStreams
            if (youyouStream) {
                mixedStreams.unshift(youyouStream);
            }
            return mixedStreams;
        }
        catch (error) {
            // Handle errors during the process of mixing streams
            console.log('Error mixing streams:', error.message);
            throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MixStreams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MixStreams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MixStreams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class DispStreams {
    /**
     * Function to display streams based on various parameters and conditions.
     *
     * @param {Object} options - The options object.
     * @param {Array} options.lStreams - List of streams.
     * @param {number} options.ind - Index of the current stream.
     * @param {boolean} [options.auto=false] - Flag to indicate if the function should run automatically.
     * @param {boolean} [options.ChatSkip=false] - Flag to indicate if chat should be skipped.
     * @param {string|null} [options.forChatID=null] - ID for chat reference.
     * @param {Object} options.parameters - Parameters object containing various settings and functions.
     * @param {number} [options.breakRoom=-1] - Break room number.
     * @param {boolean} [options.inBreakRoom=false] - Flag to indicate if in break room.
     *
     * @returns {Promise<void>} - A promise that resolves when the function completes.
     *
     * @async
     */
    dispStreams = async ({ lStreams, ind, auto = false, ChatSkip = false, forChatID = null, parameters, breakRoom = -1, inBreakRoom = false, }) => {
        // function to display streams
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { consumerTransports, streamNames, audStreamNames, participants, ref_participants, recordingDisplayType, recordingVideoOptimized, meetingDisplayType, meetingVideoOptimized, currentUserPage, hostLabel, mainHeightWidth, prevMainHeightWidth, prevDoPaginate, doPaginate, firstAll, shared, shareScreenStarted, shareEnded, oldAllStreams, updateMainWindow, remoteProducerId, activeNames, dispActiveNames, p_dispActiveNames, nForReadjustRecord, first_round, lock_screen, chatRefStreams, eventType, islevel, localStreamVideo, breakOutRoomStarted, breakOutRoomEnded, keepBackground, virtualStream, updateActiveNames, updateDispActiveNames, updateLStreams, updateChatRefStreams, updateNForReadjustRecord, updateUpdateMainWindow, updateShowMiniView, prepopulateUserMedia, rePort, processConsumerTransports, resumePauseStreams, readjust, addVideosGrid, checkGrid, getEstimate, resumePauseAudioStreams, } = parameters;
        let proceed = true;
        let lStreams_ = lStreams.filter((stream) => stream.producerId !== 'youyou' && stream.producerId !== 'youyouyou');
        lStreams_ = lStreams_.filter((stream) => stream.id !== 'youyou' &&
            stream.id !== 'youyouyou' &&
            stream.name !== 'youyou' &&
            stream.name !== 'youyouyou');
        if (eventType === 'chat') {
            proceed = true;
        }
        else if (ind === 0 || (islevel !== '2' && currentUserPage === ind)) {
            proceed = false;
            lStreams_.forEach((stream) => {
                let checker = false;
                let check_level = 0;
                if (recordingDisplayType === 'video') {
                    if (recordingVideoOptimized) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            checker = true;
                            check_level = 0;
                        }
                    }
                    else {
                        if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') ||
                            (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '')) {
                            checker = true;
                            check_level = 1;
                        }
                    }
                }
                else if (recordingDisplayType === 'media') {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                        stream.producerId != null &&
                        stream.producerId !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                            stream.audioID != null &&
                            stream.audioID !== '')) {
                        checker = true;
                        check_level = 1;
                    }
                }
                else {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                        stream.producerId != null &&
                        stream.producerId !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                            stream.audioID != null &&
                            stream.audioID !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'name') &&
                            stream.name !== null &&
                            stream.name != '')) {
                        checker = true;
                        check_level = 2;
                    }
                }
                let participant;
                if (checker) {
                    if (check_level === 0) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                    }
                    else if (check_level === 1) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                        if (!participant) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '') {
                                participant = audStreamNames.find((obj) => obj.producerId === stream.audioID);
                                if (!participant) {
                                    participant = ref_participants.find((obj) => obj.audioID === stream.audioID);
                                }
                            }
                        }
                    }
                    else if (check_level === 2) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                        if (!participant) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '') {
                                participant = audStreamNames.find((obj) => obj.producerId === stream.audioID);
                                if (!participant) {
                                    participant = ref_participants.find((obj) => obj.audioID === stream.audioID);
                                }
                            }
                        }
                        if (!participant) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'name') &&
                                stream.name !== null &&
                                stream.name != '') {
                                participant = ref_participants.find((obj) => obj.name === stream.name);
                            }
                        }
                    }
                    if (participant) {
                        if (participant.name && !activeNames.includes(participant.name)) {
                            activeNames.push(participant.name);
                        }
                    }
                }
            });
            updateActiveNames(activeNames);
            lStreams_.forEach((stream) => {
                let disp_checker = false;
                let disp_check_level = 0;
                if (meetingDisplayType === 'video') {
                    if (meetingVideoOptimized) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            disp_checker = true;
                            disp_check_level = 0;
                        }
                    }
                    else {
                        if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') ||
                            (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '')) {
                            disp_checker = true;
                            disp_check_level = 1;
                        }
                    }
                }
                else if (meetingDisplayType === 'media') {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                        stream.producerId != null &&
                        stream.producerId !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                            stream.audioID != null &&
                            stream.audioID !== '')) {
                        disp_checker = true;
                        disp_check_level = 1;
                    }
                }
                else {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                        stream.producerId != null &&
                        stream.producerId !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                            stream.audioID != null &&
                            stream.audioID !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'name') &&
                            stream.name !== null &&
                            stream.name != '')) {
                        disp_checker = true;
                        disp_check_level = 2;
                    }
                }
                let participant_;
                if (disp_checker) {
                    if (disp_check_level === 0) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant_ = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                    }
                    else if (disp_check_level === 1) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant_ = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                        if (!participant_) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '') {
                                participant_ = audStreamNames.find((obj) => obj.producerId === stream.audioID);
                                if (!participant_) {
                                    participant_ = ref_participants.find((obj) => obj.audioID === stream.audioID);
                                }
                            }
                        }
                    }
                    else if (disp_check_level === 2) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant_ = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                        if (!participant_) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '') {
                                participant_ = audStreamNames.find((obj) => obj.producerId === stream.audioID);
                                if (!participant_) {
                                    participant_ = ref_participants.find((obj) => obj.audioID === stream.audioID);
                                }
                            }
                        }
                        if (!participant_) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'name') &&
                                stream.name !== null &&
                                stream.name != '') {
                                participant_ = ref_participants.find((obj) => obj.name === stream.name);
                            }
                        }
                    }
                    if (participant_) {
                        if (participant_.name && !dispActiveNames.includes(participant_.name)) {
                            dispActiveNames.push(participant_.name);
                            if (!p_dispActiveNames.includes(participant_.name)) {
                                proceed = true;
                            }
                        }
                    }
                }
            });
            updateDispActiveNames(dispActiveNames);
            if (lStreams_.length < 1) {
                if (shareScreenStarted || shared) {
                    proceed = true;
                }
                else if (!firstAll) {
                    proceed = true;
                }
            }
            if (shareScreenStarted || shared) {
                // screen share started
            }
            else {
                if (prevMainHeightWidth !== mainHeightWidth) {
                    updateMainWindow = true;
                    updateUpdateMainWindow(updateMainWindow);
                }
            }
            nForReadjustRecord = activeNames.length;
            updateNForReadjustRecord(nForReadjustRecord);
        }
        if (!proceed && auto) {
            if (updateMainWindow) {
                if (!lock_screen && !shared) {
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                }
                else {
                    if (!first_round) {
                        await prepopulateUserMedia({ name: hostLabel, parameters });
                    }
                }
            }
            if (ind === 0 && eventType !== 'chat') {
                await rePort({ parameters });
            }
            return;
        }
        if (eventType === 'broadcast') {
            lStreams = lStreams_;
            updateLStreams(lStreams);
        }
        else if (eventType === 'chat') {
            if (forChatID != null) {
                lStreams = chatRefStreams;
                updateLStreams(lStreams);
            }
            else {
                updateShowMiniView(false);
                if (islevel !== '2') {
                    let host = participants.find((obj) => obj.islevel === '2');
                    if (host) {
                        let streame;
                        remoteProducerId = host.videoID;
                        if (islevel === '2') {
                            host['stream'] = keepBackground && virtualStream ? virtualStream : localStreamVideo;
                        }
                        else {
                            streame = oldAllStreams.find((streame) => streame.producerId === remoteProducerId);
                            if (streame) {
                                lStreams = lStreams.filter((stream) => stream.name !== host.name);
                                lStreams.push(streame);
                            }
                        }
                    }
                }
                let youyou = lStreams.find((obj) => obj.producerId === 'youyou' || obj.producerId === 'youyouyou');
                lStreams = lStreams.filter((stream) => stream.producerId !== 'youyou' && stream.producerId !== 'youyouyou');
                if (youyou) {
                    lStreams.push(youyou);
                }
                chatRefStreams = lStreams;
                updateLStreams(lStreams);
                updateChatRefStreams(chatRefStreams);
            }
        }
        let refLength = lStreams.length;
        const [, rows, cols] = getEstimate({ n: refLength, parameters });
        let result = (await checkGrid({ rows, cols, actives: refLength })) || [false, 0, 0, 0, 0, 0, 0];
        let [removeAltGrid, numtoaddd, numRows, numCols, , actualRows, lastrowcols] = result;
        if (ChatSkip && eventType == 'chat') {
            numRows = 1;
            numCols = 1;
            actualRows = 1;
        }
        //if removeAltGrid is true then remove everyting from altGrid and add to mainGrid,check for streams on alvideoStreams and add to mainGrid that are not on mainGrid and add switching to true
        await readjust({ n: lStreams.length, state: ind, parameters });
        // split the streams into two arrays, one for mainGrid and one for altGrid
        // take up to numtoadd from the lStreams and add to mainGridStreams
        let mainGridStreams = lStreams.slice(0, numtoaddd);
        // take the rest of the streams and add to altGridStreams
        let altGridStreams = lStreams.slice(numtoaddd, lStreams.length);
        //add to grids
        if (doPaginate == true ||
            prevDoPaginate != doPaginate ||
            shared ||
            shareScreenStarted ||
            shareEnded) {
            let lStreams_alt = lStreams_;
            await processConsumerTransports({ consumerTransports, lStreams_: lStreams_alt, parameters });
            try {
                if (breakOutRoomStarted && !breakOutRoomEnded) {
                    await resumePauseAudioStreams({ inBreakRoom, breakRoom, parameters });
                }
            }
            catch (error) {
                // console.log('Error in resumePauseAudioStreams:', error);
            }
            try {
                if (!breakOutRoomStarted || (breakOutRoomStarted && breakOutRoomEnded)) {
                    await resumePauseStreams({ parameters });
                }
            }
            catch {
                /* handle error */
            }
            if (shareEnded) {
                shareEnded = false;
            }
        }
        if (ChatSkip && eventType == 'chat') {
            await addVideosGrid({
                mainGridStreams,
                altGridStreams,
                numtoadd: numtoaddd - 1,
                numRows,
                numCols,
                actualRows,
                lastrowcols,
                removeAltGrid,
                parameters,
            });
        }
        else {
            await addVideosGrid({
                mainGridStreams,
                altGridStreams,
                numtoadd: numtoaddd,
                numRows,
                numCols,
                actualRows,
                lastrowcols,
                removeAltGrid,
                parameters,
            });
        }
        if (updateMainWindow) {
            if (!lock_screen && !shared) {
                await prepopulateUserMedia({ name: hostLabel, parameters });
            }
            else {
                if (!first_round) {
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                }
            }
        }
        if (ind == 0 && eventType !== 'chat') {
            await rePort({ parameters });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DispStreams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DispStreams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DispStreams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class StopShareScreen {
    /**
     * Stops the screen sharing process and updates the relevant parameters and states.
     *
     * @param {StopShareScreenOptions} options - The options for stopping the screen share.
     * @param {Object} options.parameters - The parameters required for stopping the screen share.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {boolean} options.parameters.shared - Indicates if the screen is currently shared.
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if the screen sharing has started.
     * @param {boolean} options.parameters.shareEnded - Indicates if the screen sharing has ended.
     * @param {boolean} options.parameters.updateMainWindow - Indicates if the main window needs to be updated.
     * @param {boolean} options.parameters.defer_receive - Indicates if receiving is deferred.
     * @param {string} options.parameters.hostLabel - The label of the host.
     * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
     * @param {boolean} options.parameters.forceFullDisplay - Indicates if full display is forced.
     * @param {boolean} options.parameters.firstAll - Indicates if it is the first all.
     * @param {boolean} options.parameters.first_round - Indicates if it is the first round.
     * @param {MediaStream} options.parameters.localStreamScreen - The local screen stream.
     * @param {string} options.parameters.eventType - The type of event.
     * @param {boolean} options.parameters.prevForceFullDisplay - Indicates if full display was previously forced.
     * @param {boolean} options.parameters.annotateScreenStream - Indicates if the screen stream is annotated.
     * @param {Function} options.parameters.updateShared - Function to update the shared state.
     * @param {Function} options.parameters.updateShareScreenStarted - Function to update the share screen started state.
     * @param {Function} options.parameters.updateShareEnded - Function to update the share ended state.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window state.
     * @param {Function} options.parameters.updateDefer_receive - Function to update the defer receive state.
     * @param {Function} options.parameters.updateLock_screen - Function to update the lock screen state.
     * @param {Function} options.parameters.updateForceFullDisplay - Function to update the force full display state.
     * @param {Function} options.parameters.updateFirstAll - Function to update the first all state.
     * @param {Function} options.parameters.updateFirst_round - Function to update the first round state.
     * @param {Function} options.parameters.updateLocalStreamScreen - Function to update the local screen stream.
     * @param {Function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
     * @param {Function} options.parameters.updateAnnotateScreenStream - Function to update the annotate screen stream state.
     * @param {Function} options.parameters.updateIsScreenboardModalVisible - Function to update the screenboard modal visibility.
     * @param {Function} options.parameters.disconnectSendTransportScreen - Function to disconnect the send transport screen.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @param {Function} options.parameters.reorderStreams - Function to reorder streams.
     * @param {Function} options.parameters.getVideos - Function to get videos.
     *
     * @returns {Promise<void>} A promise that resolves when the screen sharing process is stopped.
     */
    stopShareScreen = async ({ parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { shared, shareScreenStarted, shareEnded, updateMainWindow, defer_receive, hostLabel, lock_screen, forceFullDisplay, firstAll, first_round, localStreamScreen, eventType, prevForceFullDisplay, annotateScreenStream, 
        // updates for the above
        updateShared, updateShareScreenStarted, updateShareEnded, updateUpdateMainWindow, updateDefer_receive, updateLock_screen, updateForceFullDisplay, updateFirstAll, updateFirst_round, updateLocalStreamScreen, updateMainHeightWidth, updateAnnotateScreenStream, updateIsScreenboardModalVisible, 
        // mediasfu functions
        disconnectSendTransportScreen, prepopulateUserMedia, reorderStreams, getVideos, } = parameters;
        shared = false;
        updateShared(shared);
        shareScreenStarted = false;
        updateShareScreenStarted(shareScreenStarted);
        shareEnded = true;
        updateShareEnded(shareEnded);
        updateMainWindow = true;
        updateUpdateMainWindow(updateMainWindow);
        if (defer_receive) {
            defer_receive = false;
            updateDefer_receive(defer_receive);
            await getVideos({
                participants: parameters.participants,
                allVideoStreams: parameters.allVideoStreams,
                oldAllStreams: parameters.oldAllStreams,
                adminVidID: parameters.adminVidID,
                updateAllVideoStreams: parameters['updateAllVideoStreams'],
                updateOldAllStreams: parameters['updateOldAllStreams'],
            });
        }
        localStreamScreen?.getTracks().forEach((track) => track.stop());
        updateLocalStreamScreen(localStreamScreen);
        await disconnectSendTransportScreen({ parameters });
        try {
            if (annotateScreenStream) {
                annotateScreenStream = false;
                updateAnnotateScreenStream(annotateScreenStream);
                updateIsScreenboardModalVisible(true);
                await new Promise((resolve) => setTimeout(resolve, 500));
                updateIsScreenboardModalVisible(false);
            }
        }
        catch (error) {
            console.log('Error handling screen annotation:', error);
        }
        if (eventType == 'conference') {
            updateMainHeightWidth(0);
        }
        try {
            await prepopulateUserMedia({ name: hostLabel, parameters });
        }
        catch (error) {
            console.log('Error in prepopulateUserMedia:', error);
        }
        try {
            await reorderStreams({ add: false, screenChanged: true, parameters });
        }
        catch (error) {
            console.log('Error in reorderStreams:', error);
        }
        lock_screen = false;
        updateLock_screen(lock_screen);
        forceFullDisplay = prevForceFullDisplay;
        updateForceFullDisplay(forceFullDisplay);
        firstAll = false;
        updateFirstAll(firstAll);
        first_round = false;
        updateFirst_round(first_round);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StopShareScreen, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StopShareScreen, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StopShareScreen, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CheckScreenShare {
    /**
     * Checks the current screen sharing status and either stops or requests screen sharing based on the provided parameters.
     *
     * @param {CheckScreenShareOptions} options - The options for checking screen share.
     * @param {Object} options.parameters - The parameters for screen sharing.
     * @param {boolean} options.parameters.shared - Indicates if the screen is currently being shared.
     * @param {Function} [options.parameters.showAlert] - Function to show alerts.
     * @param {boolean} options.parameters.whiteboardStarted - Indicates if the whiteboard session has started.
     * @param {boolean} options.parameters.whiteboardEnded - Indicates if the whiteboard session has ended.
     * @param {boolean} options.parameters.breakOutRoomStarted - Indicates if the breakout room session has started.
     * @param {boolean} options.parameters.breakOutRoomEnded - Indicates if the breakout room session has ended.
     * @param {Function} options.parameters.stopShareScreen - Function to stop screen sharing.
     * @param {Function} options.parameters.requestScreenShare - Function to request screen sharing.
     *
     * @returns {Promise<void>} A promise that resolves when the screen sharing status has been checked and the appropriate action has been taken.
     *
     * @throws Will log an error message if an error occurs during the process.
     */
    checkScreenShare = async ({ parameters }) => {
        try {
            const { shared, showAlert, whiteboardStarted, whiteboardEnded, breakOutRoomStarted, breakOutRoomEnded, 
            // mediasfu functions
            stopShareScreen, requestScreenShare, } = parameters;
            // Stop screen share if already shared or request screen share if not shared
            if (shared) {
                if (whiteboardStarted && !whiteboardEnded) {
                    showAlert?.({
                        message: 'Screen share is not allowed when whiteboard is active',
                        type: 'danger',
                    });
                    return;
                }
                await stopShareScreen({ parameters });
            }
            else {
                // Can't share if breakout room is active
                if (breakOutRoomStarted && !breakOutRoomEnded) {
                    showAlert?.({
                        message: 'Screen share is not allowed when breakout room is active',
                        type: 'danger',
                    });
                    return;
                }
                if (whiteboardStarted && !whiteboardEnded) {
                    showAlert?.({
                        message: 'Screen share is not allowed when whiteboard is active',
                        type: 'danger',
                    });
                    return;
                }
                await requestScreenShare({ parameters });
            }
        }
        catch (error) {
            console.log('checkScreenShare error', error);
            // throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckScreenShare, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckScreenShare, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckScreenShare, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class StartShareScreen {
    /**
     * Starts the screen sharing process.
     *
     * @param {StartShareScreenOptions} options - The options for starting screen sharing.
     * @param {Object} options.parameters - The parameters for screen sharing.
     * @param {boolean} options.parameters.shared - Indicates if the screen is currently being shared.
     * @param {Function} options.parameters.showAlert - Function to show alert messages.
     * @param {Function} options.parameters.updateShared - Function to update the shared state.
     * @param {boolean} options.parameters.onWeb - Indicates if the application is running on a web platform.
     * @param {number} [options.parameters.targetWidth] - The target width for screen sharing.
     * @param {number} [options.parameters.targetHeight] - The target height for screen sharing.
     * @param {Function} options.parameters.streamSuccessScreen - Function to handle successful screen sharing.
     *
     * @returns {Promise<void>} A promise that resolves when the screen sharing process is complete.
     *
     * @throws Will log an error message if there is an issue starting the screen share.
     */
    startShareScreen = async ({ parameters }) => {
        // start screen share function
        // attempt to start screen share and return true if successful
        let { shared, showAlert, updateShared, onWeb, targetWidth = 1280, targetHeight = 720, streamSuccessScreen, } = parameters;
        try {
            if (!onWeb) {
                showAlert?.({
                    message: 'You cannot share screen while on mobile',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                shared = true;
                await navigator.mediaDevices
                    .getDisplayMedia({
                    video: {
                        width: targetWidth,
                        height: targetHeight,
                        frameRate: 30,
                    },
                    audio: false,
                })
                    .then(async (stream) => {
                    await streamSuccessScreen({ stream, parameters });
                })
                    .catch(async () => {
                    shared = false;
                    showAlert?.({
                        message: 'Could not share screen, check and retry',
                        type: 'danger',
                        duration: 3000,
                    });
                });
            }
            else {
                showAlert?.({
                    message: 'Could not share screen, check and retry',
                    type: 'danger',
                    duration: 3000,
                });
            }
            // update the shared variable
            updateShared(shared);
        }
        catch (error) {
            console.log('Error starting screen share', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartShareScreen, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartShareScreen, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartShareScreen, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class RequestScreenShare {
    /**
     * Requests to start screen sharing.
     *
     * @param {RequestScreenShareOptions} options - The options for requesting screen share.
     * @param {Object} options.parameters - The parameters for the screen share request.
     * @param {Socket} options.parameters.socket - The socket instance to communicate with the server.
     * @param {Function} [options.parameters.showAlert] - Optional function to show alerts to the user.
     * @param {boolean} options.parameters.localUIMode - Indicates if the user is in local UI mode.
     * @param {string} [options.parameters.targetResolution] - The target resolution for screen sharing.
     * @param {string} [options.parameters.targetResolutionHost] - The target resolution for the host screen.
     * @param {Function} options.parameters.startShareScreen - Function to start screen sharing.
     *
     * @returns {Promise<void>} A promise that resolves when the screen share request is processed.
     *
     * @throws {Error} Throws an error if there is an issue during the screen share request process.
     */
    requestScreenShare = async ({ parameters }) => {
        try {
            // Destructure parameters
            const { showAlert, localUIMode, startShareScreen, socket, targetResolution = 'hd', targetResolutionHost = 'hd', } = parameters;
            // Check if the user is in local UI mode
            if (localUIMode === true) {
                await startShareScreen({ parameters });
                return;
            }
            let targetWidth = 1280;
            let targetHeight = 720;
            if (targetResolution == 'qhd' || targetResolutionHost == 'qhd') {
                targetWidth = 2560;
                targetHeight = 1440;
            }
            else if (targetResolution == 'fhd' || targetResolutionHost == 'fhd') {
                targetWidth = 1920;
                targetHeight = 1080;
            }
            socket.emit('requestScreenShare', async ({ allowScreenShare }) => {
                if (!allowScreenShare) {
                    // Send an alert to the user
                    showAlert?.({
                        message: 'You are not allowed to share screen',
                        type: 'danger',
                        duration: 3000,
                    });
                }
                else {
                    await startShareScreen({ parameters: { ...parameters, targetWidth, targetHeight } });
                }
            });
        }
        catch (error) {
            // Handle errors during the process of requesting screen share
            console.error('Error during requesting screen share: ', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RequestScreenShare, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RequestScreenShare, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RequestScreenShare, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
class ReorderStreams {
    /**
     * Reorders the video streams based on the provided options and updates the UI accordingly.
     *
     * @param {Object} options - The options for reordering streams.
     * @param {boolean} [options.add=false] - Whether to add new streams or not.
     * @param {boolean} [options.screenChanged=false] - Whether the screen has changed or not.
     * @param {ReorderStreamsOptions} options.parameters - The parameters required for reordering streams.
     *
     * @returns {Promise<void>} A promise that resolves when the reordering is complete.
     *
     * @typedef {Object} ReorderStreamsOptions
     * @property {Function} getUpdatedAllParams - Function to get updated parameters.
     * @property {Array} allVideoStreams - Array of all video streams.
     * @property {Array} participants - Array of participants.
     * @property {Array} oldAllStreams - Array of old streams.
     * @property {string} screenId - ID of the screen.
     * @property {string} adminVidID - ID of the admin video.
     * @property {Array} newLimitedStreams - Array of new limited streams.
     * @property {Array} newLimitedStreamsIDs - Array of new limited stream IDs.
     * @property {Array} activeSounds - Array of active sounds.
     * @property {string} screenShareIDStream - ID of the screen share stream.
     * @property {string} screenShareNameStream - Name of the screen share stream.
     * @property {string} adminIDStream - ID of the admin stream.
     * @property {string} adminNameStream - Name of the admin stream.
     * @property {Function} updateNewLimitedStreams - Function to update new limited streams.
     * @property {Function} updateNewLimitedStreamsIDs - Function to update new limited stream IDs.
     * @property {Function} updateActiveSounds - Function to update active sounds.
     * @property {Function} updateScreenShareIDStream - Function to update screen share ID stream.
     * @property {Function} updateScreenShareNameStream - Function to update screen share name stream.
     * @property {Function} updateAdminIDStream - Function to update admin ID stream.
     * @property {Function} updateAdminNameStream - Function to update admin name stream.
     * @property {Function} updateYouYouStream - Function to update YouYou stream.
     * @property {Function} changeVids - Function to reflect changes on the UI.
     */
    reorderStreams = async ({ add = false, screenChanged = false, parameters, }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { allVideoStreams, participants, oldAllStreams, screenId, adminVidID, newLimitedStreams, newLimitedStreamsIDs, activeSounds, screenShareIDStream, screenShareNameStream, adminIDStream, adminNameStream, updateNewLimitedStreams, updateNewLimitedStreamsIDs, updateActiveSounds, updateScreenShareIDStream, updateScreenShareNameStream, updateAdminIDStream, updateAdminNameStream, updateYouYouStream, 
        //mediasfu functions
        changeVids, } = parameters;
        // function to reorder streams on the ui
        if (!add) {
            newLimitedStreams = [];
            newLimitedStreamsIDs = [];
            activeSounds = [];
        }
        const youyou = allVideoStreams.filter((stream) => stream.producerId === 'youyou');
        const admin = participants.filter((participant) => participant.islevel === '2');
        if (admin.length > 0) {
            adminVidID = admin[0].videoID;
        }
        else {
            adminVidID = '';
        }
        if (adminVidID) {
            const adminStream = allVideoStreams.find((stream) => stream.producerId === adminVidID);
            if (!add) {
                newLimitedStreams = [...newLimitedStreams, ...youyou];
                newLimitedStreamsIDs = [
                    ...newLimitedStreamsIDs,
                    ...youyou.map((stream) => stream.producerId),
                ];
            }
            else {
                const youyouStream = newLimitedStreams.find((stream) => stream.producerId === 'youyou');
                if (!youyouStream) {
                    newLimitedStreams = [...newLimitedStreams, ...youyou];
                    newLimitedStreamsIDs = [
                        ...newLimitedStreamsIDs,
                        ...youyou.map((stream) => stream.producerId),
                    ];
                }
            }
            if (adminStream) {
                adminIDStream = adminVidID;
                if (!add) {
                    newLimitedStreams = [...newLimitedStreams, adminStream];
                    newLimitedStreamsIDs = [...newLimitedStreamsIDs, adminStream.producerId];
                }
                else {
                    const adminStreamer = newLimitedStreams.find((stream) => stream.producerId === adminVidID);
                    if (!adminStreamer) {
                        newLimitedStreams = [...newLimitedStreams, adminStream];
                        newLimitedStreamsIDs = [...newLimitedStreamsIDs, adminStream.producerId];
                    }
                }
            }
            else {
                const oldAdminStream = oldAllStreams.find((stream) => stream.producerId === adminVidID);
                if (oldAdminStream) {
                    //add it to the allVideoStream
                    adminIDStream = adminVidID;
                    adminNameStream = admin[0].name;
                    if (!add) {
                        newLimitedStreams = [...newLimitedStreams, oldAdminStream];
                        newLimitedStreamsIDs = [...newLimitedStreamsIDs, oldAdminStream.producerId];
                    }
                    else {
                        const adminStreamer = newLimitedStreams.find((stream) => stream.producerId === adminVidID);
                        if (!adminStreamer) {
                            newLimitedStreams = [...newLimitedStreams, oldAdminStream];
                            newLimitedStreamsIDs = [...newLimitedStreamsIDs, oldAdminStream.producerId];
                        }
                    }
                }
            }
            const screenParticipant = participants.filter((participant) => participant.ScreenID === screenId);
            if (screenParticipant.length > 0) {
                const screenParticipantVidID = screenParticipant[0].videoID;
                const screenParticipantVidID_ = newLimitedStreams.filter((stream) => stream.producerId === screenParticipantVidID);
                if (screenParticipantVidID_?.length < 1 && screenParticipantVidID) {
                    screenShareIDStream = screenParticipantVidID;
                    screenShareNameStream = screenParticipant[0].name;
                    const screenParticipantVidID__ = allVideoStreams.filter((stream) => stream.producerId === screenParticipantVidID);
                    newLimitedStreams = [...newLimitedStreams, ...screenParticipantVidID__];
                    newLimitedStreamsIDs = [
                        ...newLimitedStreamsIDs,
                        ...screenParticipantVidID__.map((stream) => stream.producerId),
                    ];
                }
            }
        }
        else {
            if (!add) {
                newLimitedStreams = [...newLimitedStreams, ...youyou];
                newLimitedStreamsIDs = [
                    ...newLimitedStreamsIDs,
                    ...youyou.map((stream) => stream.producerId),
                ];
            }
            else {
                const youyouStream = newLimitedStreams.find((stream) => stream.producerId === 'youyou');
                if (!youyouStream) {
                    newLimitedStreams = [...newLimitedStreams, ...youyou];
                    newLimitedStreamsIDs = [
                        ...newLimitedStreamsIDs,
                        ...youyou.map((stream) => stream.producerId),
                    ];
                }
            }
            const screenParticipant = participants.filter((participant) => participant.ScreenID === screenId);
            if (screenParticipant.length > 0) {
                const screenParticipantVidID = screenParticipant[0].videoID;
                const screenParticipantVidID_ = newLimitedStreams.filter((stream) => stream.producerId === screenParticipantVidID);
                if (screenParticipantVidID_?.length < 1 && screenParticipantVidID) {
                    screenShareIDStream = screenParticipantVidID;
                    screenShareNameStream = screenParticipant[0].name;
                    const screenParticipantVidID__ = allVideoStreams.filter((stream) => stream.producerId === screenParticipantVidID);
                    newLimitedStreams = [...newLimitedStreams, ...screenParticipantVidID__];
                    newLimitedStreamsIDs = [
                        ...newLimitedStreamsIDs,
                        ...screenParticipantVidID__.map((stream) => stream.producerId),
                    ];
                }
            }
        }
        updateNewLimitedStreams(newLimitedStreams);
        updateNewLimitedStreamsIDs(newLimitedStreamsIDs);
        updateActiveSounds(activeSounds);
        updateScreenShareIDStream(screenShareIDStream);
        updateScreenShareNameStream(screenShareNameStream);
        updateAdminIDStream(adminIDStream);
        updateAdminNameStream(adminNameStream);
        updateYouYouStream(youyou);
        //reflect the changes on the ui
        await changeVids({ screenChanged, parameters });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReorderStreams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReorderStreams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReorderStreams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * MiniCard component displays a card with either an image or initials.
 *
 * @component
 * @selector app-mini-card
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * <div class="mini-card" [ngStyle]="getMergedCardStyles()">
 *   <div *ngIf="imageSource; else noImage" class="image-container">
 *     <img [src]="imageSource" alt="Profile" [ngStyle]="getMergedImageStyles()" />
 *   </div>
 *   <ng-template #noImage>
 *     <div class="initials" [ngStyle]="getInitialsStyle()">{{ initials }}</div>
 *   </ng-template>
 * </div>
 *
 * @styleUrls ['./mini-card.component.css']
 *
 * @property {string} initials - The initials to display if no image is provided.
 * @property {number} fontSize - The font size for the initials text. Default is 14.
 * @property {Partial<CSSStyleDeclaration>} customStyle - Custom styles for the card.
 * @property {string} imageSource - The source URL for the image.
 * @property {boolean} roundedImage - Whether the image should be rounded. Default is false.
 * @property {Partial<CSSStyleDeclaration>} imageStyle - Custom styles for the image.
 *
 * @constructor
 * @param {string} [injectedInitials] - Injected initials.
 * @param {number} [injectedFontSize] - Injected font size.
 * @param {Partial<CSSStyleDeclaration>} [injectedCustomStyle] - Injected custom styles.
 * @param {string} [injectedImageSource] - Injected image source.
 * @param {boolean} [injectedRoundedImage] - Injected rounded image flag.
 * @param {Partial<CSSStyleDeclaration>} [injectedImageStyle] - Injected image styles.
 *
 * @method getMergedCardStyles
 * @description Merges the default card styles with custom styles.
 * @returns {CSSStyleDeclaration} The merged card styles.
 *
 * @method getMergedImageStyles
 * @description Merges the default image styles with custom styles.
 * @returns {CSSStyleDeclaration} The merged image styles.
 *
 * @method getInitialsStyle
 * @description Returns the styles for the initials text.
 * @returns {CSSStyleDeclaration} The initials text styles.
 */
class MiniCard {
    initials;
    fontSize = 14;
    customStyle = {};
    imageSource;
    roundedImage = false;
    imageStyle = {};
    constructor(injectedInitials, injectedFontSize, injectedCustomStyle, injectedImageSource, injectedRoundedImage, injectedImageStyle) {
        this.initials = injectedInitials || this.initials || '';
        this.fontSize = injectedFontSize || this.fontSize || 14;
        this.customStyle = injectedCustomStyle || this.customStyle || {};
        this.imageSource = injectedImageSource || this.imageSource || '';
        this.roundedImage = injectedRoundedImage || this.roundedImage || true;
        this.imageStyle = injectedImageStyle || this.imageStyle || {};
    }
    getMergedCardStyles() {
        return {
            'font-size': this.fontSize + 'px',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            borderRadius: '0',
            width: '100%',
            height: '100%',
            color: 'black',
            fontFamily: "'Nunito', sans-serif",
            overflow: 'hidden',
            border: '2px solid black',
            ...this.customStyle,
        };
    }
    getMergedImageStyles() {
        return {
            width: '60%',
            height: '60%',
            objectFit: 'cover',
            ...(this.roundedImage ? { borderRadius: '50%' } : {}),
            ...this.imageStyle,
        };
    }
    getInitialsStyle() {
        return {
            textAlign: 'center',
            'font-size': this.fontSize + 'px',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MiniCard, deps: [{ token: 'initials', optional: true }, { token: 'fontSize', optional: true }, { token: 'customStyle', optional: true }, { token: 'imageSource', optional: true }, { token: 'roundedImage', optional: true }, { token: 'imageStyle', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MiniCard, isStandalone: true, selector: "app-mini-card", inputs: { initials: "initials", fontSize: "fontSize", customStyle: "customStyle", imageSource: "imageSource", roundedImage: "roundedImage", imageStyle: "imageStyle" }, ngImport: i0, template: `
    <div class="mini-card" [ngStyle]="getMergedCardStyles()">
      <div *ngIf="imageSource; else noImage" class="image-container">
        <img [src]="imageSource" alt="Profile" [ngStyle]="getMergedImageStyles()" />
      </div>
      <ng-template #noImage>
        <div class="initials" [ngStyle]="getInitialsStyle()">{{ initials }}</div>
      </ng-template>
    </div>
  `, isInline: true, styles: [".mini-card{display:flex;justify-content:center;align-items:center;border-radius:0;width:100%;height:100%;color:#000;font-family:Nunito,sans-serif;overflow:hidden;border:2px solid black}.image-container{display:flex;justify-content:center;align-items:center;width:100%;height:100%}.backgroundImage{width:60%;height:60%;object-fit:cover}.roundedImage{border-radius:50%}.initials{text-align:center;font-size:14px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MiniCard, decorators: [{
            type: Component,
            args: [{ selector: 'app-mini-card', standalone: true, imports: [CommonModule], template: `
    <div class="mini-card" [ngStyle]="getMergedCardStyles()">
      <div *ngIf="imageSource; else noImage" class="image-container">
        <img [src]="imageSource" alt="Profile" [ngStyle]="getMergedImageStyles()" />
      </div>
      <ng-template #noImage>
        <div class="initials" [ngStyle]="getInitialsStyle()">{{ initials }}</div>
      </ng-template>
    </div>
  `, styles: [".mini-card{display:flex;justify-content:center;align-items:center;border-radius:0;width:100%;height:100%;color:#000;font-family:Nunito,sans-serif;overflow:hidden;border:2px solid black}.image-container{display:flex;justify-content:center;align-items:center;width:100%;height:100%}.backgroundImage{width:60%;height:60%;object-fit:cover}.roundedImage{border-radius:50%}.initials{text-align:center;font-size:14px}\n"] }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['initials']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['fontSize']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageSource']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['roundedImage']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageStyle']
                }] }], propDecorators: { initials: [{
                type: Input
            }], fontSize: [{
                type: Input
            }], customStyle: [{
                type: Input
            }], imageSource: [{
                type: Input
            }], roundedImage: [{
                type: Input
            }], imageStyle: [{
                type: Input
            }] } });

class CardVideoDisplay {
    remoteProducerId = '';
    eventType = 'webinar';
    forceFullDisplay = false;
    videoStream = null;
    backgroundColor = 'transparent';
    doMirror = false;
    videoElement;
    videoContainerStyle;
    ngOnInit() {
        this.updateVideoStream();
        this.setVideoContainerStyle();
    }
    ngOnChanges(changes) {
        if (changes['videoStream'] && this.videoStream) {
            const currentStream = changes['videoStream'].currentValue;
            const previousStream = changes['videoStream'].previousValue;
            if (!previousStream ||
                currentStream.id !== previousStream.id ||
                currentStream.active !== previousStream.active) {
                this.updateVideoStream();
            }
        }
        if (changes['backgroundColor'] &&
            changes['backgroundColor'].currentValue !== changes['backgroundColor'].previousValue) {
            this.setVideoContainerStyle();
        }
    }
    updateVideoStream() {
        if (this.videoElement && this.videoStream) {
            const videoElement = this.videoElement.nativeElement;
            // Update the video element's srcObject only if it has changed
            if (videoElement.srcObject !== this.videoStream) {
                videoElement.srcObject = this.videoStream;
            }
        }
    }
    setVideoContainerStyle() {
        this.videoContainerStyle = {
            ...this.getBaseVideoContainerStyle(),
            backgroundColor: this.backgroundColor,
        };
    }
    getBaseVideoContainerStyle() {
        return {
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            width: '100%',
            height: '100%',
            backgroundColor: 'black',
        };
    }
    getVideoStyle() {
        const baseStyles = {
            width: this.forceFullDisplay ? '100%' : 'auto',
            height: '100%',
            maxWidth: '100%',
            maxHeight: '100%',
            objectFit: this.forceFullDisplay ? 'cover' : 'contain',
            backgroundColor: this.backgroundColor,
        };
        if (this.doMirror) {
            baseStyles.transform = 'rotateY(180deg)';
        }
        return baseStyles;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CardVideoDisplay, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: CardVideoDisplay, isStandalone: true, selector: "app-card-video-display", inputs: { remoteProducerId: "remoteProducerId", eventType: "eventType", forceFullDisplay: "forceFullDisplay", videoStream: "videoStream", backgroundColor: "backgroundColor", doMirror: "doMirror" }, viewQueries: [{ propertyName: "videoElement", first: true, predicate: ["videoElement"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"videoContainerStyle\">\r\n  <video #videoElement autoplay muted playsinline [ngStyle]=\"getVideoStyle()\"></video>\r\n</div>\r\n", styles: [".videoContainer{display:flex;justify-content:center;align-items:center;width:100%;height:100%;background-color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CardVideoDisplay, decorators: [{
            type: Component,
            args: [{ selector: 'app-card-video-display', standalone: true, imports: [CommonModule], template: "<div [ngStyle]=\"videoContainerStyle\">\r\n  <video #videoElement autoplay muted playsinline [ngStyle]=\"getVideoStyle()\"></video>\r\n</div>\r\n", styles: [".videoContainer{display:flex;justify-content:center;align-items:center;width:100%;height:100%;background-color:#000}\n"] }]
        }], propDecorators: { remoteProducerId: [{
                type: Input
            }], eventType: [{
                type: Input
            }], forceFullDisplay: [{
                type: Input
            }], videoStream: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], doMirror: [{
                type: Input
            }], videoElement: [{
                type: ViewChild,
                args: ['videoElement', { static: true }]
            }] } });

/**
 * Gets the style for positioning an overlay based on the specified position.
 * @function
 * @param {string} position - The desired position for the overlay ('topLeft', 'topRight', 'bottomLeft', 'bottomRight').
 * @returns {OverlayPositionStyle} - The style object for positioning the overlay.
 */
function getOverlayPosition({ position }) {
    switch (position) {
        case 'topLeft':
            return { top: 0, left: 0 };
        case 'topRight':
            return { top: 0, right: 0 };
        case 'bottomLeft':
            return { bottom: 0, left: 0 };
        case 'bottomRight':
            return { bottom: 0, right: 0 };
        default:
            return {};
    }
}

class ControlMedia {
    /**
     * Controls the media of a participant in a media session if certain conditions are met.
     *
     * @param {Object} options - The options for controlling media.
     * @param {string} options.participantId - The ID of the participant to control.
     * @param {string} options.participantName - The name of the participant to control.
     * @param {string} options.type - The type of media to control.
     * @param {Socket} options.socket - The socket instance for communication.
     * @param {Array} options.coHostResponsibility - List of co-host responsibilities.
     * @param {Array} options.participants - List of participants in the session.
     * @param {string} options.member - The current member attempting to control media.
     * @param {string} options.islevel - The level of the current member.
     * @param {Function} [options.showAlert] - Optional function to show alerts.
     * @param {string} options.coHost - The co-host information.
     * @param {string} options.roomName - The name of the room.
     *
     * @returns {Promise<void>} A promise that resolves when the media control operation is complete.
     */
    async controlMedia({ participantId, participantName, type, socket, coHostResponsibility, participants, member, islevel, showAlert, coHost, roomName, }) {
        try {
            // Destructure parameters
            let mediaValue = false;
            try {
                mediaValue =
                    coHostResponsibility.find((item) => item.name === 'media')?.value ?? false;
            }
            catch {
                /* handle error */
            }
            let participant = participants.find((obj) => obj.name === participantName);
            if (islevel === '2' || (coHost === member && mediaValue === true)) {
                // Check if the participant is not muted and is not a host
                if (participant &&
                    ((!participant.muted && participant.islevel !== '2' && type == 'audio') ||
                        (participant.islevel !== '2' && type == 'video' && participant['videoOn']))) {
                    // Emit controlMedia event to the server
                    socket.emit('controlMedia', { participantId, participantName, type, roomName });
                }
            }
            else {
                // Display an alert if the participant is not allowed to mute other participants
                if (showAlert) {
                    showAlert({
                        message: 'You are not allowed to control media for other participants.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
        }
        catch (error) {
            console.log('controlMedia error', error);
            // throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlMedia, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlMedia, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlMedia, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class VideoCard {
    controlMediaService;
    customStyle = {};
    name;
    barColor = 'red';
    textColor = 'white';
    imageSource;
    roundedImage = false;
    imageStyle = {};
    remoteProducerId;
    eventType;
    forceFullDisplay;
    videoStream = null;
    showControls = true;
    showInfo = true;
    videoInfoComponent;
    videoControlsComponent;
    controlsPosition = 'topLeft';
    infoPosition = 'topRight';
    participant;
    backgroundColor;
    audioDecibels = [];
    doMirror;
    parameters;
    waveformAnimations = Array.from({ length: 9 }, () => 0);
    showWaveform = true;
    interval;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    constructor(controlMediaService, injectedCustomStyle, injectedName, injectedBarColor, injectedTextColor, injectedImageSource, injectedRoundedImage, injectedImageStyle, injectedRemoteProducerId, injectedEventType, injectedForceFullDisplay, injectedVideoStream, injectedShowControls, injectedShowInfo, injectedVideoInfoComponent, injectedVideoControlsComponent, injectedControlsPosition, injectedInfoPosition, injectedParticipant, injectedBackgroundColor, injectedAudioDecibels, injectedDoMirror, injectedParameters) {
        this.controlMediaService = controlMediaService;
        this.customStyle = injectedCustomStyle || this.customStyle;
        this.name = injectedName || this.name;
        this.barColor = injectedBarColor || this.barColor;
        this.textColor = injectedTextColor || this.textColor;
        this.imageSource = injectedImageSource || this.imageSource;
        this.roundedImage = injectedRoundedImage || this.roundedImage;
        this.imageStyle = injectedImageStyle || this.imageStyle;
        this.remoteProducerId = injectedRemoteProducerId || this.remoteProducerId;
        this.eventType = injectedEventType || this.eventType;
        this.forceFullDisplay = injectedForceFullDisplay || this.forceFullDisplay;
        this.videoStream = injectedVideoStream || this.videoStream;
        this.showControls = injectedShowControls != null ? injectedShowControls : this.showControls;
        this.showInfo = injectedShowInfo != null ? injectedShowInfo : this.showInfo;
        this.videoInfoComponent = injectedVideoInfoComponent || this.videoInfoComponent;
        this.videoControlsComponent = injectedVideoControlsComponent || this.videoControlsComponent;
        this.controlsPosition = injectedControlsPosition || this.controlsPosition;
        this.infoPosition = injectedInfoPosition || this.infoPosition;
        this.participant = injectedParticipant || this.participant;
        this.backgroundColor = injectedBackgroundColor || this.backgroundColor;
        this.audioDecibels = injectedAudioDecibels || this.audioDecibels;
        this.doMirror = injectedDoMirror || this.doMirror;
        this.parameters = injectedParameters || this.parameters;
    }
    ngOnInit() {
        this.interval = setInterval(() => {
            const params = this.parameters.getUpdatedAllParams();
            const { audioDecibels, participants } = params;
            const existingEntry = audioDecibels && audioDecibels.find((entry) => entry.name === this.name);
            const participantEntry = participants && participants.find((p) => p.name === this.name);
            if (existingEntry &&
                existingEntry.averageLoudness > 127.5 &&
                participantEntry &&
                !participantEntry.muted) {
                this.animateWaveform();
            }
            else {
                this.resetWaveform();
            }
        }, 1000);
    }
    ngOnDestroy() {
        clearInterval(this.interval);
    }
    animateWaveform() {
        this.waveformAnimations.forEach((_, index) => {
            setInterval(() => this.animateBar(index), this.getAnimationDuration(index) * 2);
        });
    }
    animateBar(index) {
        this.waveformAnimations[index] = 1;
        setTimeout(() => {
            this.waveformAnimations[index] = 0;
        }, this.getAnimationDuration(index));
    }
    resetWaveform() {
        this.waveformAnimations.fill(0);
    }
    getAnimationDuration(index) {
        const durations = [474, 433, 407, 458, 400, 427, 441, 419, 487];
        return durations[index] || 0;
    }
    async toggleAudio() {
        if (this.participant && !this.participant.muted) {
            const params = this.parameters;
            await this.controlMediaService.controlMedia({
                participantId: this.participant.id || '',
                participantName: this.participant.name,
                type: 'audio',
                socket: params.socket,
                roomName: params.roomName,
                coHostResponsibility: params.coHostResponsibility,
                showAlert: params.showAlert,
                coHost: params.coHost,
                participants: params.participants,
                member: params.member,
                islevel: params.islevel,
            });
        }
    }
    async toggleVideo() {
        if (this.participant) {
            const params = this.parameters.getUpdatedAllParams();
            await this.controlMediaService.controlMedia({
                participantId: this.participant.id || '',
                participantName: this.participant.name,
                type: 'video',
                socket: params.socket,
                roomName: params.roomName,
                coHostResponsibility: params.coHostResponsibility,
                showAlert: params.showAlert,
                coHost: params.coHost,
                participants: params.participants,
                member: params.member,
                islevel: params.islevel,
            });
        }
    }
    renderControls() {
        if (!this.showControls) {
            return null;
        }
        if (this.videoControlsComponent) {
            return this.videoControlsComponent;
        }
        return `
      <div class="overlayControls">
        <button class="controlButton" (click)="toggleAudio()">
          <fa-icon [icon]="participant?.muted ? faMicrophoneSlash : faMicrophone" [style.color]="participant?.muted ? 'red' : 'green'"></fa-icon>
        </button>
        <button class="controlButton" (click)="toggleVideo()">
          <fa-icon [icon]="participant?.videoOn ? faVideo : faVideoSlash" [style.color]="participant?.videoOn ? 'green' : 'red'"></fa-icon>
        </button>
      </div>
    `;
    }
    getOverlayPosition(position) {
        return getOverlayPosition({ position });
    }
    isCustomComponent(comp) {
        return (typeof comp.component !== 'function' &&
            comp.component !== undefined);
    }
    isFunctionComponent(comp) {
        return typeof comp === 'function';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: VideoCard, deps: [{ token: ControlMedia }, { token: 'customStyle', optional: true }, { token: 'name', optional: true }, { token: 'barColor', optional: true }, { token: 'textColor', optional: true }, { token: 'imageSource', optional: true }, { token: 'roundedImage', optional: true }, { token: 'imageStyle', optional: true }, { token: 'remoteProducerId', optional: true }, { token: 'eventType', optional: true }, { token: 'forceFullDisplay', optional: true }, { token: 'videoStream', optional: true }, { token: 'showControls', optional: true }, { token: 'showInfo', optional: true }, { token: 'videoInfoComponent', optional: true }, { token: 'videoControlsComponent', optional: true }, { token: 'controlsPosition', optional: true }, { token: 'infoPosition', optional: true }, { token: 'participant', optional: true }, { token: 'backgroundColor', optional: true }, { token: 'audioDecibels', optional: true }, { token: 'doMirror', optional: true }, { token: 'parameters', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: VideoCard, isStandalone: true, selector: "app-video-card", inputs: { customStyle: "customStyle", name: "name", barColor: "barColor", textColor: "textColor", imageSource: "imageSource", roundedImage: "roundedImage", imageStyle: "imageStyle", remoteProducerId: "remoteProducerId", eventType: "eventType", forceFullDisplay: "forceFullDisplay", videoStream: "videoStream", showControls: "showControls", showInfo: "showInfo", videoInfoComponent: "videoInfoComponent", videoControlsComponent: "videoControlsComponent", controlsPosition: "controlsPosition", infoPosition: "infoPosition", participant: "participant", backgroundColor: "backgroundColor", audioDecibels: "audioDecibels", doMirror: "doMirror", parameters: "parameters" }, ngImport: i0, template: "<div\r\n  [ngStyle]=\"customStyle\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n  class=\"video-card\"\r\n>\r\n  <app-card-video-display\r\n    [remoteProducerId]=\"remoteProducerId\"\r\n    [eventType]=\"eventType\"\r\n    [forceFullDisplay]=\"forceFullDisplay\"\r\n    [videoStream]=\"videoStream\"\r\n    [backgroundColor]=\"backgroundColor\"\r\n    [doMirror]=\"doMirror\"\r\n  ></app-card-video-display>\r\n\r\n  <div\r\n    *ngIf=\"showInfo\"\r\n    [ngClass]=\"showControls ? 'overlayWeb' : 'overlayWebAlt'\"\r\n    [ngStyle]=\"getOverlayPosition(infoPosition)\"\r\n  >\r\n    <div class=\"nameColumn\">\r\n      <span class=\"nameText\" [style.color]=\"textColor\">{{\r\n        participant.name\r\n      }}</span>\r\n    </div>\r\n    <div *ngIf=\"showWaveform\" class=\"waveformWeb\">\r\n      <div\r\n        *ngFor=\"let animation of waveformAnimations; let i = index\"\r\n        class=\"bar\"\r\n        [ngStyle]=\"{\r\n          height: animation === 0 ? '1px' : '16px',\r\n          backgroundColor: barColor\r\n        }\"\r\n      ></div>\r\n    </div>\r\n  </div>\r\n\r\n  <div\r\n    *ngIf=\"showControls\"\r\n    class=\"overlayControls\"\r\n    [ngStyle]=\"getOverlayPosition(controlsPosition)\"\r\n  >\r\n    <ng-container *ngIf=\"!videoControlsComponent\">\r\n      <div class=\"overlayControls\">\r\n        <button class=\"controlButton\" (click)=\"toggleAudio()\">\r\n          <fa-icon\r\n            [icon]=\"participant.muted ? faMicrophoneSlash : faMicrophone\"\r\n            [style.color]=\"participant.muted ? 'red' : 'green'\"\r\n          ></fa-icon>\r\n        </button>\r\n        <button class=\"controlButton\" (click)=\"toggleVideo()\">\r\n          <fa-icon\r\n            [icon]=\"participant['videoOn'] ? faVideo : faVideoSlash\"\r\n            [style.color]=\"participant['videoOn'] ? 'green' : 'red'\"\r\n          ></fa-icon>\r\n        </button>\r\n      </div>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"videoControlsComponent\">\r\n      <ng-container *ngIf=\"isCustomComponent(videoControlsComponent)\">\r\n        <ng-container\r\n          *ngComponentOutlet=\"\r\n            videoControlsComponent.component;\r\n            injector: videoControlsComponent.injector\r\n          \"\r\n        ></ng-container>\r\n      </ng-container>\r\n      <ng-container *ngIf=\"!isCustomComponent(videoControlsComponent)\">\r\n        <div [innerHTML]=\"videoControlsComponent.outerHTML\"></div>\r\n      </ng-container>\r\n    </ng-container>\r\n  </div>\r\n</div>\r\n", styles: [".video-card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f;border:2px solid black;position:relative}.overlayWeb{position:absolute;min-width:40%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.overlayWebAlt{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr;grid-gap:0px;top:0;right:0}.overlayControls{display:flex;flex-direction:row;padding:0;position:absolute;top:0;left:0}.controlButton{justify-content:center;align-items:center;background-color:#0003;padding:2px 4px;margin-right:2px;font-size:medium;border:none;cursor:pointer}.nameColumn{justify-content:center;align-items:center;background-color:#00000080;padding:5px;margin-right:2px;font-size:small;text-align:center}.nameText{font-size:small;font-weight:bolder}.waveformWeb{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin:0 1px;transition:height .5s ease}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: CardVideoDisplay, selector: "app-card-video-display", inputs: ["remoteProducerId", "eventType", "forceFullDisplay", "videoStream", "backgroundColor", "doMirror"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: VideoCard, decorators: [{
            type: Component,
            args: [{ selector: 'app-video-card', standalone: true, imports: [CommonModule, FontAwesomeModule, CardVideoDisplay], template: "<div\r\n  [ngStyle]=\"customStyle\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n  class=\"video-card\"\r\n>\r\n  <app-card-video-display\r\n    [remoteProducerId]=\"remoteProducerId\"\r\n    [eventType]=\"eventType\"\r\n    [forceFullDisplay]=\"forceFullDisplay\"\r\n    [videoStream]=\"videoStream\"\r\n    [backgroundColor]=\"backgroundColor\"\r\n    [doMirror]=\"doMirror\"\r\n  ></app-card-video-display>\r\n\r\n  <div\r\n    *ngIf=\"showInfo\"\r\n    [ngClass]=\"showControls ? 'overlayWeb' : 'overlayWebAlt'\"\r\n    [ngStyle]=\"getOverlayPosition(infoPosition)\"\r\n  >\r\n    <div class=\"nameColumn\">\r\n      <span class=\"nameText\" [style.color]=\"textColor\">{{\r\n        participant.name\r\n      }}</span>\r\n    </div>\r\n    <div *ngIf=\"showWaveform\" class=\"waveformWeb\">\r\n      <div\r\n        *ngFor=\"let animation of waveformAnimations; let i = index\"\r\n        class=\"bar\"\r\n        [ngStyle]=\"{\r\n          height: animation === 0 ? '1px' : '16px',\r\n          backgroundColor: barColor\r\n        }\"\r\n      ></div>\r\n    </div>\r\n  </div>\r\n\r\n  <div\r\n    *ngIf=\"showControls\"\r\n    class=\"overlayControls\"\r\n    [ngStyle]=\"getOverlayPosition(controlsPosition)\"\r\n  >\r\n    <ng-container *ngIf=\"!videoControlsComponent\">\r\n      <div class=\"overlayControls\">\r\n        <button class=\"controlButton\" (click)=\"toggleAudio()\">\r\n          <fa-icon\r\n            [icon]=\"participant.muted ? faMicrophoneSlash : faMicrophone\"\r\n            [style.color]=\"participant.muted ? 'red' : 'green'\"\r\n          ></fa-icon>\r\n        </button>\r\n        <button class=\"controlButton\" (click)=\"toggleVideo()\">\r\n          <fa-icon\r\n            [icon]=\"participant['videoOn'] ? faVideo : faVideoSlash\"\r\n            [style.color]=\"participant['videoOn'] ? 'green' : 'red'\"\r\n          ></fa-icon>\r\n        </button>\r\n      </div>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"videoControlsComponent\">\r\n      <ng-container *ngIf=\"isCustomComponent(videoControlsComponent)\">\r\n        <ng-container\r\n          *ngComponentOutlet=\"\r\n            videoControlsComponent.component;\r\n            injector: videoControlsComponent.injector\r\n          \"\r\n        ></ng-container>\r\n      </ng-container>\r\n      <ng-container *ngIf=\"!isCustomComponent(videoControlsComponent)\">\r\n        <div [innerHTML]=\"videoControlsComponent.outerHTML\"></div>\r\n      </ng-container>\r\n    </ng-container>\r\n  </div>\r\n</div>\r\n", styles: [".video-card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f;border:2px solid black;position:relative}.overlayWeb{position:absolute;min-width:40%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.overlayWebAlt{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr;grid-gap:0px;top:0;right:0}.overlayControls{display:flex;flex-direction:row;padding:0;position:absolute;top:0;left:0}.controlButton{justify-content:center;align-items:center;background-color:#0003;padding:2px 4px;margin-right:2px;font-size:medium;border:none;cursor:pointer}.nameColumn{justify-content:center;align-items:center;background-color:#00000080;padding:5px;margin-right:2px;font-size:small;text-align:center}.nameText{font-size:small;font-weight:bolder}.waveformWeb{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin:0 1px;transition:height .5s ease}\n"] }]
        }], ctorParameters: () => [{ type: ControlMedia }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['name']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['barColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['textColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageSource']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['roundedImage']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['remoteProducerId']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['eventType']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['forceFullDisplay']
                }] }, { type: MediaStream, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['videoStream']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showControls']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showInfo']
                }] }, { type: HTMLElement, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['videoInfoComponent']
                }] }, { type: HTMLElement, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['videoControlsComponent']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['controlsPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['infoPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['participant']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['backgroundColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['audioDecibels']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['doMirror']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }], propDecorators: { customStyle: [{
                type: Input
            }], name: [{
                type: Input
            }], barColor: [{
                type: Input
            }], textColor: [{
                type: Input
            }], imageSource: [{
                type: Input
            }], roundedImage: [{
                type: Input
            }], imageStyle: [{
                type: Input
            }], remoteProducerId: [{
                type: Input
            }], eventType: [{
                type: Input
            }], forceFullDisplay: [{
                type: Input
            }], videoStream: [{
                type: Input
            }], showControls: [{
                type: Input
            }], showInfo: [{
                type: Input
            }], videoInfoComponent: [{
                type: Input
            }], videoControlsComponent: [{
                type: Input
            }], controlsPosition: [{
                type: Input
            }], infoPosition: [{
                type: Input
            }], participant: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], audioDecibels: [{
                type: Input
            }], doMirror: [{
                type: Input
            }], parameters: [{
                type: Input
            }] } });

class AudioCard {
    ngZone;
    controlMediaService;
    controlUserMedia;
    customStyle = {};
    name = '';
    barColor = 'red';
    textColor = 'white';
    imageSource = '';
    roundedImage = false;
    imageStyle = {};
    showControls = true;
    showInfo = true;
    videoInfoComponent; // Custom component for participant information
    videoControlsComponent; // Custom component for video controls
    controlsPosition = 'topLeft';
    infoPosition = 'topRight';
    participant = null;
    backgroundColor = '';
    audioDecibels;
    parameters;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    waveformAnimations = Array.from({ length: 9 }, () => 0);
    showWaveform = true;
    interval;
    constructor(ngZone, controlMediaService, injectedControlUserMedia, injectedCustomStyle, injectedName, injectedBarColor, injectedTextColor, injectedImageSource, injectedRoundedImage, injectedImageStyle, injectedShowControls, injectedShowInfo, injectedVideoInfoComponent, injectedVideoControlsComponent, injectedControlsPosition, injectedInfoPosition, injectedParticipant, injectedBackgroundColor, injectedAudioDecibels, injectedParameters) {
        this.ngZone = ngZone;
        this.controlMediaService = controlMediaService;
        this.controlUserMedia = injectedControlUserMedia || this.controlUserMedia;
        this.customStyle = injectedCustomStyle || this.customStyle;
        this.name = injectedName || this.name;
        this.barColor = injectedBarColor || this.barColor;
        this.textColor = injectedTextColor || this.textColor;
        this.imageSource = injectedImageSource || this.imageSource;
        this.roundedImage = injectedRoundedImage || this.roundedImage;
        this.imageStyle = injectedImageStyle || this.imageStyle;
        this.showControls = injectedShowControls != null ? injectedShowControls : this.showControls;
        this.showInfo = injectedShowInfo != null ? injectedShowInfo : this.showInfo;
        this.videoInfoComponent = injectedVideoInfoComponent || this.videoInfoComponent;
        this.videoControlsComponent = injectedVideoControlsComponent || this.videoControlsComponent;
        this.controlsPosition = injectedControlsPosition || this.controlsPosition;
        this.infoPosition = injectedInfoPosition || this.infoPosition;
        this.participant = injectedParticipant || this.participant;
        this.backgroundColor = injectedBackgroundColor || this.backgroundColor;
        this.audioDecibels = injectedAudioDecibels || this.audioDecibels;
        this.parameters = injectedParameters || this.parameters;
    }
    ngOnInit() {
        if (!this.controlUserMedia) {
            this.controlUserMedia = async (options) => {
                await this.controlMediaService.controlMedia(options);
            };
        }
        if (this.parameters) {
            this.ngZone.runOutsideAngular(() => {
                this.interval = setInterval(() => {
                    const { audioDecibels, participants } = this.parameters.getUpdatedAllParams();
                    const existingEntry = audioDecibels.find((entry) => entry.name == this.name);
                    this.participant = participants.find((p) => p.name == this.name) || null;
                    if (existingEntry &&
                        existingEntry.averageLoudness > 127.5 &&
                        this.participant &&
                        !this.participant.muted) {
                        this.animateWaveform();
                    }
                    else {
                        this.resetWaveform();
                    }
                }, 1000);
            });
        }
        if (this.participant?.muted) {
            this.showWaveform = false;
        }
        else {
            this.showWaveform = true;
        }
    }
    ngOnDestroy() {
        clearInterval(this.interval);
    }
    animateBar(index) {
        this.waveformAnimations[index] = 1;
        setTimeout(() => {
            this.waveformAnimations[index] = 0;
        }, this.getAnimationDuration(index));
    }
    animateWaveform() {
        this.waveformAnimations.forEach((_, index) => {
            setInterval(() => this.animateBar(index), this.getAnimationDuration(index) * 2);
        });
    }
    resetWaveform() {
        this.waveformAnimations.fill(0);
    }
    getAnimationDuration(index) {
        const durations = [474, 433, 407, 458, 400, 427, 441, 419, 487];
        return durations[index] || 0;
    }
    async toggleAudio() {
        if (this.participant && !this.participant.muted) {
            await this.controlUserMedia?.({
                participantId: this.participant.id || '',
                participantName: this.participant.name,
                type: 'audio',
                socket: this.parameters.socket,
                coHostResponsibility: this.parameters.coHostResponsibility,
                roomName: this.parameters.roomName,
                showAlert: this.parameters.showAlert,
                coHost: this.parameters.coHost,
                islevel: this.parameters.islevel,
                member: this.parameters.member,
                participants: this.parameters.participants,
            });
        }
    }
    async toggleVideo() {
        if (this.participant) {
            await this.controlUserMedia?.({
                participantId: this.participant.id || '',
                participantName: this.participant.name,
                type: 'video',
                socket: this.parameters.socket,
                coHostResponsibility: this.parameters.coHostResponsibility,
                roomName: this.parameters.roomName,
                showAlert: this.parameters.showAlert,
                coHost: this.parameters.coHost,
                islevel: this.parameters.islevel,
                member: this.parameters.member,
                participants: this.parameters.participants,
            });
        }
    }
    renderControls() {
        return this.showControls;
    }
    // Helper method to combine styles
    combineStyles(baseStyle, additionalStyles) {
        return { ...baseStyle, ...additionalStyles };
    }
    getOverlayPosition(position) {
        return getOverlayPosition({ position });
    }
    isCustomComponent(comp) {
        return (typeof comp.component !== 'function' &&
            comp.component !== undefined);
    }
    isFunctionComponent(comp) {
        return typeof comp === 'function';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AudioCard, deps: [{ token: i0.NgZone }, { token: ControlMedia }, { token: 'controlUserMedia', optional: true }, { token: 'customStyle', optional: true }, { token: 'name', optional: true }, { token: 'barColor', optional: true }, { token: 'textColor', optional: true }, { token: 'imageSource', optional: true }, { token: 'roundedImage', optional: true }, { token: 'imageStyle', optional: true }, { token: 'showControls', optional: true }, { token: 'showInfo', optional: true }, { token: 'videoInfoComponent', optional: true }, { token: 'videoControlsComponent', optional: true }, { token: 'controlsPosition', optional: true }, { token: 'infoPosition', optional: true }, { token: 'participant', optional: true }, { token: 'backgroundColor', optional: true }, { token: 'audioDecibels', optional: true }, { token: 'parameters', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: AudioCard, isStandalone: true, selector: "app-audio-card", inputs: { controlUserMedia: "controlUserMedia", customStyle: "customStyle", name: "name", barColor: "barColor", textColor: "textColor", imageSource: "imageSource", roundedImage: "roundedImage", imageStyle: "imageStyle", showControls: "showControls", showInfo: "showInfo", videoInfoComponent: "videoInfoComponent", videoControlsComponent: "videoControlsComponent", controlsPosition: "controlsPosition", infoPosition: "infoPosition", participant: "participant", backgroundColor: "backgroundColor", audioDecibels: "audioDecibels", parameters: "parameters" }, ngImport: i0, template: "<div\r\n  class=\"card\"\r\n  [ngStyle]=\"customStyle\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n>\r\n  <ng-container *ngIf=\"imageSource; else noImage\">\r\n    <div class=\"imageContainer\">\r\n      <img\r\n        [src]=\"imageSource\"\r\n        [ngStyle]=\"\r\n          combineStyles(imageStyle, {\r\n            'border-radius': roundedImage ? '20%' : '0'\r\n          })\r\n        \"\r\n        class=\"backgroundImage\"\r\n      />\r\n    </div>\r\n  </ng-container>\r\n  <ng-template #noImage>\r\n    <div style=\"width: 100%; height: 100%\">\r\n      <app-mini-card [initials]=\"name\" [fontSize]=\"20\" [ngStyle]=\"{ 'border': parameters.eventType === 'broadcast' ? '2px solid black' : '0px solid black' }\"></app-mini-card>\r\n    </div>\r\n  </ng-template>\r\n\r\n  <ng-container *ngIf=\"showInfo\">\r\n    <div\r\n      class=\"overlay\"\r\n      [ngStyle]=\"getOverlayPosition(infoPosition)\"\r\n      [ngClass]=\"showControls ? 'overlayWeb' : 'overlayWebAlt'\"\r\n    >\r\n      <div class=\"nameColumn\">\r\n        <p [ngStyle]=\"{ color: textColor }\" class=\"nameText\">{{ name }}</p>\r\n      </div>\r\n      <div *ngIf=\"showWaveform\" class=\"waveformWeb\">\r\n        <div\r\n          *ngFor=\"let animation of waveformAnimations\"\r\n          [ngStyle]=\"{\r\n            height: animation === 0 ? '1px' : '12px',\r\n            backgroundColor: barColor\r\n          }\"\r\n          class=\"bar\"\r\n        ></div>\r\n      </div>\r\n    </div>\r\n  </ng-container>\r\n\r\n  <ng-container *ngIf=\"renderControls()\">\r\n    <div\r\n      class=\"overlayControls\"\r\n      [ngStyle]=\"getOverlayPosition(controlsPosition)\"\r\n    >\r\n      <ng-container *ngIf=\"!videoControlsComponent\">\r\n        <button class=\"controlButton\" (click)=\"toggleAudio()\">\r\n          <fa-icon\r\n            [icon]=\"participant?.muted ? faMicrophoneSlash : faMicrophone\"\r\n            [style.color]=\"participant?.muted ? 'red' : 'green'\"\r\n          ></fa-icon>\r\n        </button>\r\n        <button class=\"controlButton\" (click)=\"toggleVideo()\">\r\n          <fa-icon\r\n            [icon]=\"participant?.['videoOn'] ? faVideo : faVideoSlash\"\r\n            [style.color]=\"participant?.['videoOn'] ? 'green' : 'red'\"\r\n          ></fa-icon>\r\n        </button>\r\n      </ng-container>\r\n      <ng-container *ngIf=\"videoControlsComponent\">\r\n        <ng-container *ngIf=\"isCustomComponent(videoControlsComponent)\">\r\n          <ng-container\r\n            *ngComponentOutlet=\"\r\n              videoControlsComponent.component;\r\n              injector: videoControlsComponent.injector\r\n            \"\r\n          ></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!isCustomComponent(videoControlsComponent)\">\r\n          <div [innerHTML]=\"videoControlsComponent.outerHTML\"></div>\r\n        </ng-container>\r\n      </ng-container>\r\n    </div>\r\n  </ng-container>\r\n</div>\r\n", styles: [".card{width:100%;height:100%;margin:0;padding:0;background-color:transparent;position:relative}.imageContainer{display:flex;justify-content:center;align-items:center;width:100%;height:100%}.backgroundImage{width:80px;height:80px;border-radius:50%}.overlayWeb{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.overlayWebAlt{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr;grid-gap:0px;top:0;right:0}.overlayControls{display:flex;flex-direction:row;padding:0;position:absolute;top:0;left:0}.controlButton{justify-content:center;align-items:center;background-color:#0003;padding:0 5px;margin-right:2px;font-size:medium;border:none;cursor:pointer}.nameColumn{justify-content:center;align-items:center;background-color:#00000080;padding:5px 0 0;margin-right:2px;font-size:small;text-align:center;min-height:4%;max-height:70%}.nameText{font-size:small;font-weight:bolder}.waveformWeb{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row;min-height:4%;max-height:70%}.waveformMobile{flex-direction:row;align-items:center;background-color:#0000000d;padding:0;max-width:25%;margin:0}.bar{flex:1;opacity:.75;margin:0 1px;transition:height .5s ease}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: MiniCard, selector: "app-mini-card", inputs: ["initials", "fontSize", "customStyle", "imageSource", "roundedImage", "imageStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AudioCard, decorators: [{
            type: Component,
            args: [{ selector: 'app-audio-card', standalone: true, imports: [CommonModule, FontAwesomeModule, MiniCard], template: "<div\r\n  class=\"card\"\r\n  [ngStyle]=\"customStyle\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n>\r\n  <ng-container *ngIf=\"imageSource; else noImage\">\r\n    <div class=\"imageContainer\">\r\n      <img\r\n        [src]=\"imageSource\"\r\n        [ngStyle]=\"\r\n          combineStyles(imageStyle, {\r\n            'border-radius': roundedImage ? '20%' : '0'\r\n          })\r\n        \"\r\n        class=\"backgroundImage\"\r\n      />\r\n    </div>\r\n  </ng-container>\r\n  <ng-template #noImage>\r\n    <div style=\"width: 100%; height: 100%\">\r\n      <app-mini-card [initials]=\"name\" [fontSize]=\"20\" [ngStyle]=\"{ 'border': parameters.eventType === 'broadcast' ? '2px solid black' : '0px solid black' }\"></app-mini-card>\r\n    </div>\r\n  </ng-template>\r\n\r\n  <ng-container *ngIf=\"showInfo\">\r\n    <div\r\n      class=\"overlay\"\r\n      [ngStyle]=\"getOverlayPosition(infoPosition)\"\r\n      [ngClass]=\"showControls ? 'overlayWeb' : 'overlayWebAlt'\"\r\n    >\r\n      <div class=\"nameColumn\">\r\n        <p [ngStyle]=\"{ color: textColor }\" class=\"nameText\">{{ name }}</p>\r\n      </div>\r\n      <div *ngIf=\"showWaveform\" class=\"waveformWeb\">\r\n        <div\r\n          *ngFor=\"let animation of waveformAnimations\"\r\n          [ngStyle]=\"{\r\n            height: animation === 0 ? '1px' : '12px',\r\n            backgroundColor: barColor\r\n          }\"\r\n          class=\"bar\"\r\n        ></div>\r\n      </div>\r\n    </div>\r\n  </ng-container>\r\n\r\n  <ng-container *ngIf=\"renderControls()\">\r\n    <div\r\n      class=\"overlayControls\"\r\n      [ngStyle]=\"getOverlayPosition(controlsPosition)\"\r\n    >\r\n      <ng-container *ngIf=\"!videoControlsComponent\">\r\n        <button class=\"controlButton\" (click)=\"toggleAudio()\">\r\n          <fa-icon\r\n            [icon]=\"participant?.muted ? faMicrophoneSlash : faMicrophone\"\r\n            [style.color]=\"participant?.muted ? 'red' : 'green'\"\r\n          ></fa-icon>\r\n        </button>\r\n        <button class=\"controlButton\" (click)=\"toggleVideo()\">\r\n          <fa-icon\r\n            [icon]=\"participant?.['videoOn'] ? faVideo : faVideoSlash\"\r\n            [style.color]=\"participant?.['videoOn'] ? 'green' : 'red'\"\r\n          ></fa-icon>\r\n        </button>\r\n      </ng-container>\r\n      <ng-container *ngIf=\"videoControlsComponent\">\r\n        <ng-container *ngIf=\"isCustomComponent(videoControlsComponent)\">\r\n          <ng-container\r\n            *ngComponentOutlet=\"\r\n              videoControlsComponent.component;\r\n              injector: videoControlsComponent.injector\r\n            \"\r\n          ></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!isCustomComponent(videoControlsComponent)\">\r\n          <div [innerHTML]=\"videoControlsComponent.outerHTML\"></div>\r\n        </ng-container>\r\n      </ng-container>\r\n    </div>\r\n  </ng-container>\r\n</div>\r\n", styles: [".card{width:100%;height:100%;margin:0;padding:0;background-color:transparent;position:relative}.imageContainer{display:flex;justify-content:center;align-items:center;width:100%;height:100%}.backgroundImage{width:80px;height:80px;border-radius:50%}.overlayWeb{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.overlayWebAlt{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr;grid-gap:0px;top:0;right:0}.overlayControls{display:flex;flex-direction:row;padding:0;position:absolute;top:0;left:0}.controlButton{justify-content:center;align-items:center;background-color:#0003;padding:0 5px;margin-right:2px;font-size:medium;border:none;cursor:pointer}.nameColumn{justify-content:center;align-items:center;background-color:#00000080;padding:5px 0 0;margin-right:2px;font-size:small;text-align:center;min-height:4%;max-height:70%}.nameText{font-size:small;font-weight:bolder}.waveformWeb{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row;min-height:4%;max-height:70%}.waveformMobile{flex-direction:row;align-items:center;background-color:#0000000d;padding:0;max-width:25%;margin:0}.bar{flex:1;opacity:.75;margin:0 1px;transition:height .5s ease}\n"] }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: ControlMedia }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['controlUserMedia']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['name']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['barColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['textColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageSource']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['roundedImage']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showControls']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showInfo']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['videoInfoComponent']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['videoControlsComponent']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['controlsPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['infoPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['participant']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['backgroundColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['audioDecibels']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }], propDecorators: { controlUserMedia: [{
                type: Input
            }], customStyle: [{
                type: Input
            }], name: [{
                type: Input
            }], barColor: [{
                type: Input
            }], textColor: [{
                type: Input
            }], imageSource: [{
                type: Input
            }], roundedImage: [{
                type: Input
            }], imageStyle: [{
                type: Input
            }], showControls: [{
                type: Input
            }], showInfo: [{
                type: Input
            }], videoInfoComponent: [{
                type: Input
            }], videoControlsComponent: [{
                type: Input
            }], controlsPosition: [{
                type: Input
            }], infoPosition: [{
                type: Input
            }], participant: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], audioDecibels: [{
                type: Input
            }], parameters: [{
                type: Input
            }] } });

class PrepopulateUserMedia {
    /**
     * Prepopulates the user media based on the provided options.
     *
     * @param {PrepopulateUserMediaOptions} options - The options for prepopulating user media.
     * @param {string} options.name - The name of the user.
     * @param {Parameters} options.parameters - The parameters for prepopulating user media.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {Array<Participant>} options.parameters.participants - List of participants.
     * @param {Array<Stream>} options.parameters.allVideoStreams - List of all video streams.
     * @param {string} options.parameters.islevel - The level of the user.
     * @param {string} options.parameters.member - The member name.
     * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
     * @param {string} options.parameters.eventType - The type of event.
     * @param {string} options.parameters.screenId - The screen ID.
     * @param {boolean} options.parameters.forceFullDisplay - Indicates if full display is forced.
     * @param {Function} options.parameters.updateMainWindow - Function to update the main window.
     * @param {boolean} options.parameters.mainScreenFilled - Indicates if the main screen is filled.
     * @param {boolean} options.parameters.adminOnMainScreen - Indicates if admin is on the main screen.
     * @param {string} options.parameters.mainScreenPerson - The person on the main screen.
     * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already on.
     * @param {boolean} options.parameters.audioAlreadyOn - Indicates if the audio is already on.
     * @param {Array<Stream>} options.parameters.oldAllStreams - List of old all streams.
     * @param {Function} options.parameters.checkOrientation - Function to check orientation.
     * @param {boolean} options.parameters.screenForceFullDisplay - Indicates if screen force full display is enabled.
     * @param {Stream} options.parameters.localStreamScreen - The local screen stream.
     * @param {Array<Stream>} options.parameters.remoteScreenStream - List of remote screen streams.
     * @param {Stream} options.parameters.localStreamVideo - The local video stream.
     * @param {number} options.parameters.mainHeightWidth - The main height and width.
     * @param {boolean} options.parameters.isWideScreen - Indicates if the screen is wide.
     * @param {boolean} options.parameters.localUIMode - Indicates if local UI mode is enabled.
     * @param {boolean} options.parameters.whiteboardStarted - Indicates if whiteboard has started.
     * @param {boolean} options.parameters.whiteboardEnded - Indicates if whiteboard has ended.
     * @param {Stream} options.parameters.virtualStream - The virtual stream.
     * @param {boolean} options.parameters.keepBackground - Indicates if background should be kept.
     * @param {Stream} options.parameters.annotateScreenStream - The annotate screen stream.
     * @param {Function} options.parameters.updateMainScreenPerson - Function to update the main screen person.
     * @param {Function} options.parameters.updateMainScreenFilled - Function to update if the main screen is filled.
     * @param {Function} options.parameters.updateAdminOnMainScreen - Function to update if admin is on the main screen.
     * @param {Function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
     * @param {Function} options.parameters.updateScreenForceFullDisplay - Function to update screen force full display.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window update status.
     * @param {Function} options.parameters.updateMainGridStream - Function to update the main grid stream.
     *
     * @returns {Promise<{ component: any, inputs: any }[] | void>} A promise that resolves with the components and inputs or void.
     */
    prepopulateUserMedia = async ({ name, parameters, }) => {
        try {
            // Destructure parameters
            let { getUpdatedAllParams } = parameters;
            parameters = getUpdatedAllParams();
            let { participants, allVideoStreams, islevel, member, shared, shareScreenStarted, eventType, screenId, forceFullDisplay, updateMainWindow, mainScreenFilled, adminOnMainScreen, mainScreenPerson, videoAlreadyOn, audioAlreadyOn, oldAllStreams, checkOrientation, screenForceFullDisplay, localStreamScreen, remoteScreenStream, localStreamVideo, mainHeightWidth, isWideScreen, localUIMode, whiteboardStarted, whiteboardEnded, virtualStream, keepBackground, annotateScreenStream, updateMainScreenPerson, updateMainScreenFilled, updateAdminOnMainScreen, updateMainHeightWidth, updateScreenForceFullDisplay, updateUpdateMainWindow, updateMainGridStream, } = parameters;
            // If the event type is 'chat', return early
            if (eventType == 'chat') {
                return;
            }
            // Initialize variables
            let host;
            let hostStream;
            let newComponents = [];
            // Check if screen sharing is started or shared
            if (shareScreenStarted || shared) {
                // Handle main grid visibility based on the event type
                if (eventType == 'conference') {
                    if (shared || shareScreenStarted) {
                        if (mainHeightWidth == 0) {
                            // Add the main grid if not present
                            updateMainHeightWidth(84);
                        }
                    }
                    else {
                        // Remove the main grid if not shared or started
                        updateMainHeightWidth(0);
                    }
                }
                // Switch display to optimize for screen share
                screenForceFullDisplay = forceFullDisplay;
                updateScreenForceFullDisplay(screenForceFullDisplay);
                // Get the orientation and adjust forceFullDisplay
                let orientation = checkOrientation();
                if (orientation == 'portrait' || !isWideScreen) {
                    if (shareScreenStarted || shared) {
                        screenForceFullDisplay = false;
                        updateScreenForceFullDisplay(screenForceFullDisplay);
                    }
                }
                // Check if the user is sharing the screen
                if (shared) {
                    // User is sharing
                    host = { name: member, audioID: '', videoID: '' };
                    hostStream = localStreamScreen;
                    // Update admin on the main screen
                    adminOnMainScreen = islevel == '2';
                    updateAdminOnMainScreen(adminOnMainScreen);
                    // Update main screen person
                    mainScreenPerson = host.name || '';
                    updateMainScreenPerson(mainScreenPerson);
                }
                else {
                    //someone else is sharing
                    host =
                        participants.find((participant) => participant.ScreenID == screenId && participant.ScreenOn == true) ?? null;
                    if (whiteboardStarted && !whiteboardEnded) {
                        host = { name: 'WhiteboardActive', islevel: '2', audioID: '', videoID: '' };
                        hostStream = { producerId: 'WhiteboardActive' };
                    }
                    if (host == null) {
                        // remoteScreenStream
                        host =
                            participants.find((participant) => participant.ScreenOn == true) ?? null;
                    }
                    // check remoteScreenStream
                    if (host != null && !host?.name?.includes('WhiteboardActive')) {
                        if (remoteScreenStream.length == 0) {
                            hostStream =
                                allVideoStreams.find((stream) => stream.producerId == host?.ScreenID) ?? null;
                        }
                        else {
                            hostStream = remoteScreenStream[0];
                        }
                    }
                    // Update admin on the main screen
                    adminOnMainScreen = (host && host.islevel == '2') ?? false;
                    updateAdminOnMainScreen(adminOnMainScreen);
                    // Update main screen person
                    mainScreenPerson = host?.name ?? '';
                    updateMainScreenPerson(mainScreenPerson);
                }
            }
            else {
                // Screen share not started
                if (eventType == 'conference') {
                    // No main grid for conferences
                    return;
                }
                // Find the host with level '2'
                host = participants.find((participant) => participant.islevel == '2') ?? null;
                // Update main screen person
                mainScreenPerson = host?.name ?? '';
                updateMainScreenPerson(mainScreenPerson);
            }
            // If host is not null, check if host videoIsOn
            if (host) {
                // Populate the main screen with the host video
                if (shareScreenStarted || shared) {
                    forceFullDisplay = screenForceFullDisplay;
                    if (whiteboardStarted && !whiteboardEnded) {
                        // Whiteboard is active
                    }
                    else {
                        newComponents.push({
                            component: VideoCard,
                            inputs: {
                                videoStream: shared ? hostStream : hostStream.stream,
                                remoteProducerId: host.ScreenID,
                                eventType,
                                forceFullDisplay: annotateScreenStream && shared ? false : forceFullDisplay,
                                customStyle: {
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                                participant: host,
                                backgroundColor: 'rgba(217, 227, 234, 0.99)',
                                showControls: false,
                                showInfo: true,
                                name: host.name,
                                doMirror: false,
                                parameters,
                            },
                        });
                    }
                    updateMainGridStream(newComponents);
                    mainScreenFilled = true;
                    updateMainScreenFilled(mainScreenFilled);
                    adminOnMainScreen = host.islevel == '2';
                    updateAdminOnMainScreen(adminOnMainScreen);
                    mainScreenPerson = host.name ?? '';
                    updateMainScreenPerson(mainScreenPerson);
                    return newComponents;
                }
                // Check if video is already on or not
                if ((islevel != '2' && !host['videoOn']) ||
                    (islevel == '2' && (!host['videoOn'] || !videoAlreadyOn)) ||
                    localUIMode == true) {
                    // Video is off
                    if (islevel == '2' && videoAlreadyOn) {
                        // Admin's video is on
                        newComponents.push({
                            component: VideoCard,
                            inputs: {
                                videoStream: keepBackground && virtualStream ? virtualStream : localStreamVideo,
                                remoteProducerId: host.videoID,
                                eventType,
                                forceFullDisplay,
                                customStyle: {
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                                participant: host,
                                backgroundColor: 'rgba(217, 227, 234, 0.99)',
                                showControls: false,
                                showInfo: true,
                                name: host.name,
                                doMirror: true,
                                parameters,
                            },
                        });
                        updateMainGridStream(newComponents);
                        mainScreenFilled = true;
                        updateMainScreenFilled(mainScreenFilled);
                        adminOnMainScreen = true;
                        updateAdminOnMainScreen(adminOnMainScreen);
                        mainScreenPerson = host.name ?? '';
                        updateMainScreenPerson(mainScreenPerson);
                    }
                    else {
                        // Video is off and not admin
                        let audOn;
                        if (islevel == '2' && audioAlreadyOn) {
                            audOn = true;
                        }
                        else {
                            if (host != null && islevel != '2') {
                                audOn = host['muted'] == false;
                            }
                        }
                        if (audOn) {
                            // Audio is on
                            try {
                                newComponents.push({
                                    component: AudioCard,
                                    inputs: {
                                        name: host.name,
                                        barColor: 'red',
                                        textColor: 'white',
                                        customStyle: {
                                            backgroundColor: 'transparent',
                                            border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                        },
                                        controlsPosition: 'topLeft',
                                        infoPosition: 'topRight',
                                        showWaveform: true,
                                        roundedImage: true,
                                        parameters: parameters,
                                        showControls: false,
                                        backgroundColor: 'transparent',
                                    },
                                });
                                updateMainGridStream(newComponents);
                            }
                            catch (error) {
                                // Handle audio card creation error
                            }
                            mainScreenFilled = true;
                            updateMainScreenFilled(mainScreenFilled);
                            adminOnMainScreen = islevel == '2';
                            updateAdminOnMainScreen(adminOnMainScreen);
                            mainScreenPerson = host.name ?? '';
                            updateMainScreenPerson(mainScreenPerson);
                        }
                        else {
                            // Audio is off
                            try {
                                newComponents.push({
                                    component: MiniCard,
                                    inputs: {
                                        initials: name,
                                        fontSize: 20,
                                        customStyle: {
                                            backgroundColor: 'transparent',
                                            border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                        },
                                    },
                                });
                                updateMainGridStream(newComponents);
                            }
                            catch (error) {
                                // Handle mini card creation error
                            }
                            mainScreenFilled = false;
                            updateMainScreenFilled(mainScreenFilled);
                            adminOnMainScreen = islevel == '2';
                            updateAdminOnMainScreen(adminOnMainScreen);
                            mainScreenPerson = host.name ?? '';
                            updateMainScreenPerson(mainScreenPerson);
                        }
                    }
                }
                else {
                    // Video is on
                    if (shareScreenStarted || shared) {
                        // Screen share is on
                        if (whiteboardStarted && !whiteboardEnded) {
                            // Whiteboard is active
                        }
                        else {
                            try {
                                newComponents.push({
                                    component: VideoCard,
                                    inputs: {
                                        videoStream: shared ? hostStream : hostStream.stream,
                                        remoteProducerId: host.ScreenID,
                                        eventType,
                                        forceFullDisplay,
                                        customStyle: {
                                            border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                        },
                                        participant: host,
                                        backgroundColor: 'rgba(217, 227, 234, 0.99)',
                                        showControls: false,
                                        showInfo: true,
                                        name: host.name,
                                        doMirror: false,
                                        parameters,
                                    },
                                });
                                updateMainGridStream(newComponents);
                                mainScreenFilled = true;
                                updateMainScreenFilled(mainScreenFilled);
                                adminOnMainScreen = host.islevel == '2';
                                updateAdminOnMainScreen(adminOnMainScreen);
                                mainScreenPerson = host.name ?? '';
                                updateMainScreenPerson(mainScreenPerson);
                            }
                            catch (error) {
                                // Handle video card creation error
                            }
                        }
                    }
                    else {
                        // Screen share is off
                        let streame;
                        if (islevel == '2') {
                            host['stream'] = keepBackground && virtualStream ? virtualStream : localStreamVideo;
                        }
                        else {
                            streame = oldAllStreams.find((streame) => streame.producerId == host.videoID);
                            host['stream'] = streame && streame.stream;
                        }
                        try {
                            if (host['stream']) {
                                newComponents.push({
                                    component: VideoCard,
                                    inputs: {
                                        videoStream: host['stream'],
                                        remoteProducerId: host.videoID,
                                        eventType,
                                        forceFullDisplay,
                                        customStyle: {
                                            border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                        },
                                        participant: host,
                                        backgroundColor: 'rgba(217, 227, 234, 0.99)',
                                        showControls: false,
                                        showInfo: true,
                                        name: host.name,
                                        doMirror: member == host.name,
                                        parameters,
                                    },
                                });
                                updateMainGridStream(newComponents);
                                mainScreenFilled = true;
                                adminOnMainScreen = host.islevel == '2';
                                mainScreenPerson = host.name ?? '';
                            }
                            else {
                                newComponents.push({
                                    component: MiniCard,
                                    inputs: {
                                        initials: name,
                                        fontSize: 20,
                                        customStyle: {
                                            backgroundColor: 'transparent',
                                            border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                        },
                                    },
                                });
                                updateMainGridStream(newComponents);
                                mainScreenFilled = false;
                                adminOnMainScreen = islevel == '2';
                                mainScreenPerson = host.name ?? '';
                            }
                            updateMainScreenFilled(mainScreenFilled);
                            updateAdminOnMainScreen(adminOnMainScreen);
                            updateMainScreenPerson(mainScreenPerson);
                        }
                        catch (error) {
                            // Handle video card creation error
                        }
                    }
                }
            }
            else {
                // Host is null, add a mini card
                try {
                    newComponents.push({
                        component: MiniCard,
                        inputs: {
                            initials: name,
                            fontSize: 20,
                            customStyle: {
                                backgroundColor: 'transparent',
                                border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                            },
                        },
                    });
                    updateMainGridStream(newComponents);
                    mainScreenFilled = false;
                    adminOnMainScreen = false;
                    mainScreenPerson = '';
                    updateMainScreenFilled(mainScreenFilled);
                    updateAdminOnMainScreen(adminOnMainScreen);
                    updateMainScreenPerson(mainScreenPerson);
                }
                catch (error) {
                    // Handle mini card creation error
                }
            }
            updateMainWindow = false;
            updateUpdateMainWindow(updateMainWindow);
            return newComponents;
        }
        catch (error) {
            // Handle errors during the process of preparing and populating the main screen
            console.log('Error preparing and populating the main screen:', error.message);
            return [];
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PrepopulateUserMedia, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PrepopulateUserMedia, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PrepopulateUserMedia, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class GetVideos {
    /**
     * Asynchronously processes and updates video streams by filtering out the admin's video stream.
     *
     * @param {GetVideosOptions} options - The options for getting videos.
     * @param {Participant[]} options.participants - The list of participants.
     * @param {Stream[]} options.allVideoStreams - The list of all video streams.
     * @param {(Stream | Participant)[]} options.oldAllStreams - The list of old video streams.
     * @param {string} options.adminVidID - The ID of the admin's video stream.
     * @param {Function} options.updateAllVideoStreams - Function to update the state variable for all video streams.
     * @param {Function} options.updateOldAllStreams - Function to update the state variable for old video streams.
     * @returns {Promise<void>} A promise that resolves when the video streams have been processed and updated.
     */
    async getVideos({ participants, allVideoStreams, oldAllStreams, adminVidID, updateAllVideoStreams, updateOldAllStreams, }) {
        try {
            // Filter out the admin's video stream and update state variables
            let admin = participants.filter((participant) => participant.islevel === '2');
            if (admin.length > 0) {
                adminVidID = admin[0].videoID;
                if (adminVidID != null && adminVidID !== '') {
                    let oldAllStreams_ = [];
                    // Check if the length of oldAllStreams is greater than 0
                    if (oldAllStreams.length > 0) {
                        oldAllStreams_ = oldAllStreams;
                    }
                    // Filter out admin's video stream from oldAllStreams
                    oldAllStreams = allVideoStreams.filter((streame) => streame.producerId === adminVidID);
                    // If no admin's video stream found, revert to the previous state
                    if (oldAllStreams.length < 1) {
                        oldAllStreams = oldAllStreams_;
                    }
                    // Update the state variable for old video streams
                    updateOldAllStreams(oldAllStreams);
                    // Filter out admin's video stream from allVideoStreams
                    allVideoStreams = allVideoStreams.filter((streame) => streame.producerId !== adminVidID);
                    // Update the state variable for all video streams
                    updateAllVideoStreams(allVideoStreams);
                }
            }
        }
        catch (error) {
            // Handle errors during the process of updating video streams
            console.log('Error updating video streams:', error.message);
            // throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetVideos, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetVideos, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetVideos, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class RePort {
    /**
     * RePort function that handles the reporting logic based on the provided parameters.
     *
     * @param {RePortOptions} options - The options for the rePort function.
     * @param {boolean} [options.restart=false] - Flag indicating whether to restart the process.
     * @param {Object} options.parameters - The parameters object containing various states and functions.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {string} options.parameters.islevel - The current level of the process.
     * @param {string} options.parameters.mainScreenPerson - The person on the main screen.
     * @param {boolean} options.parameters.adminOnMainScreen - Flag indicating if admin is on the main screen.
     * @param {boolean} options.parameters.mainScreenFilled - Flag indicating if the main screen is filled.
     * @param {boolean} options.parameters.recordStarted - Flag indicating if recording has started.
     * @param {boolean} options.parameters.recordStopped - Flag indicating if recording has stopped.
     * @param {boolean} options.parameters.recordPaused - Flag indicating if recording is paused.
     * @param {boolean} options.parameters.recordResumed - Flag indicating if recording has resumed.
     * @param {Array} options.parameters.screenStates - Array of current screen states.
     * @param {Function} options.parameters.updateScreenStates - Function to update the current screen states.
     * @param {Function} options.parameters.updatePrevScreenStates - Function to update the previous screen states.
     * @param {Function} options.parameters.compareActiveNames - Function to compare active names.
     * @param {Function} options.parameters.compareScreenStates - Function to compare screen states.
     *
     * @returns {Promise<void>} A promise that resolves when the reporting process is complete.
     *
     * @throws {Error} Throws an error if there is an issue during the reporting process.
     */
    async rePort({ restart = false, parameters }) {
        const { getUpdatedAllParams } = parameters;
        const updatedParams = getUpdatedAllParams();
        const { islevel, mainScreenPerson, adminOnMainScreen, mainScreenFilled, recordStarted, recordStopped, recordPaused, recordResumed, screenStates, updateScreenStates, updatePrevScreenStates, compareActiveNames, compareScreenStates, } = updatedParams;
        try {
            if (recordStarted || recordResumed) {
                if (recordStopped || recordPaused) {
                    // Recording stopped or paused, do nothing
                }
                else {
                    if (islevel === '2') {
                        const prevScreenStatesCopy = [...screenStates];
                        updatePrevScreenStates(prevScreenStatesCopy);
                        const newScreenStates = [{ mainScreenPerson, adminOnMainScreen, mainScreenFilled }];
                        updateScreenStates(newScreenStates);
                        await compareActiveNames({ restart, parameters: updatedParams });
                        if (!restart) {
                            await compareScreenStates({ restart, parameters: updatedParams });
                        }
                    }
                }
            }
        }
        catch (error) {
            // Handle errors during the process of rePorting
            console.error('Error during rePorting: ', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RePort, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RePort, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RePort, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class Trigger {
    /**
     * Triggers an update to the screen client based on the provided parameters.
     *
     * @param {TriggerOptions} options - The options for triggering the update.
     * @param {string[]} options.ref_ActiveNames - Reference to the active names.
     * @param {Parameters} options.parameters - The parameters for the trigger.
     * @returns {Promise<void>} A promise that resolves when the trigger is complete.
     *
     * @throws Will throw an error if the updateScreenClient operation fails.
     *
     * @remarks
     * This function handles various conditions to determine the main screen person,
     * adjusts the screen states, and emits an update to the screen client via socket.
     *
     * @example
     * ```typescript
     * await trigger({
     *   ref_ActiveNames: ["user1", "user2"],
     *   parameters: {
     *     socket: socketInstance,
     *     roomName: "room1",
     *     screenStates: [{ mainScreenPerson: "user1", mainScreenFilled: true, adminOnMainScreen: false }],
     *     participants: [{ name: "admin", islevel: "2" }],
     *     updateDateState: 0,
     *     lastUpdate: null,
     *     nForReadjust: 0,
     *     eventType: "conference",
     *     shared: false,
     *     shareScreenStarted: false,
     *     whiteboardStarted: false,
     *     whiteboardEnded: false,
     *     updateUpdateDateState: (date) => {},
     *     updateLastUpdate: (date) => {},
     *     updateNForReadjust: (n) => {},
     *     autoAdjust: async ({ n, parameters }) => [n, 0],
     *   },
     * });
     * ```
     */
    async trigger({ ref_ActiveNames, parameters }) {
        // Function to trigger the updateScreen event
        try {
            let { socket, roomName, screenStates, participants, updateDateState, lastUpdate, nForReadjust, eventType, shared, shareScreenStarted, whiteboardStarted, whiteboardEnded, updateUpdateDateState, updateLastUpdate, updateNForReadjust, autoAdjust, } = parameters;
            let personOnMainScreen = screenStates[0].mainScreenPerson;
            let adminName = '';
            const admin = participants.filter((participant) => participant.islevel == '2');
            if (admin.length > 0) {
                adminName = admin[0].name || '';
            }
            if (personOnMainScreen === 'WhiteboardActive') {
                personOnMainScreen = adminName;
            }
            let mainfilled = screenStates[0].mainScreenFilled;
            let adminOnMain = screenStates[0].adminOnMainScreen;
            let nForReadjust_;
            let val1;
            let noww = new Date().getTime();
            // get now in seconds
            let timestamp = Math.floor(noww / 1000);
            let eventPass = false;
            if (eventType === 'conference' && !(shared || shareScreenStarted)) {
                eventPass = true;
                personOnMainScreen = adminName;
                if (!ref_ActiveNames.includes(adminName)) {
                    ref_ActiveNames.unshift(adminName);
                }
            }
            if ((mainfilled && personOnMainScreen != null && adminOnMain) || eventPass) {
                if (eventType === 'conference') {
                    nForReadjust = nForReadjust + 1;
                    updateNForReadjust(nForReadjust);
                }
                if (!ref_ActiveNames.includes(adminName) && whiteboardStarted && !whiteboardEnded) {
                    ref_ActiveNames.unshift(adminName);
                }
                nForReadjust_ = ref_ActiveNames.length;
                if (nForReadjust_ === 0 && eventType === 'webinar') {
                    val1 = 0;
                }
                else {
                    const [val11] = await autoAdjust({
                        n: nForReadjust_,
                        eventType,
                        shared,
                        shareScreenStarted,
                    });
                    val1 = val11;
                }
                let calc1 = Math.floor((val1 / 12) * 100);
                let calc2 = 100 - calc1;
                // check if lastUpdate is not null and at least same seconds
                if (lastUpdate == null || updateDateState != timestamp) {
                    let now = new Date();
                    socket.emit('updateScreenClient', {
                        roomName,
                        names: ref_ActiveNames,
                        mainPercent: calc2,
                        mainScreenPerson: personOnMainScreen,
                        viewType: eventType,
                    }, ({ success, reason }) => {
                        updateDateState = timestamp;
                        updateUpdateDateState(updateDateState);
                        lastUpdate = Math.floor(now.getTime() / 1000);
                        updateLastUpdate(lastUpdate);
                        if (success) {
                            // handle success
                        }
                        else {
                            console.log(reason, 'updateScreenClient failed');
                        }
                    });
                }
            }
            else if (mainfilled && personOnMainScreen != null && !adminOnMain) {
                nForReadjust_ = ref_ActiveNames.length;
                if (!ref_ActiveNames.includes(adminName)) {
                    ref_ActiveNames.unshift(adminName);
                    nForReadjust_ = ref_ActiveNames.length;
                }
                const [val11] = await autoAdjust({
                    n: nForReadjust_,
                    eventType,
                    shared,
                    shareScreenStarted,
                });
                val1 = val11;
                const calc1 = Math.floor((val1 / 12) * 100);
                const calc2 = 100 - calc1;
                if (lastUpdate == null || updateDateState != timestamp) {
                    let now = new Date();
                    socket.emit('updateScreenClient', {
                        roomName,
                        names: ref_ActiveNames,
                        mainPercent: calc2,
                        mainScreenPerson: personOnMainScreen,
                        viewType: eventType,
                    }, ({ success, reason }) => {
                        updateDateState = timestamp;
                        updateUpdateDateState(updateDateState);
                        lastUpdate = Math.floor(now.getTime() / 1000);
                        updateLastUpdate(lastUpdate);
                        if (success) {
                            // handle success
                        }
                        else {
                            console.log(reason, 'updateScreenClient failed');
                        }
                    });
                }
            }
            else {
                // stop recording
                console.log('trigger stopRecording');
            }
        }
        catch (error) {
            console.log('Error triggering updateScreen:', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Trigger, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Trigger, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Trigger, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * MiniAudio component is a standalone Angular component that displays a mini audio player with waveform animations.
 * It supports various customizations including visibility, styles, text, and image properties.
 * The component can be dragged around the screen.
 *
 * @selector app-mini-audio
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * The template includes a modal container with a card that displays an optional background image, name text, and waveform animations.
 *
 * @styles
 * The styles define the appearance of the modal container, card, background image, name text, overlay, waveform, and bars.
 *
 * @class MiniAudio
 * @implements OnInit, OnDestroy
 *
 * @property {boolean} visible - Determines if the component is visible.
 * @property {any} customStyle - Custom styles for the component.
 * @property {string} name - The name text displayed in the component.
 * @property {boolean} showWaveform - Flag to show or hide the waveform animations.
 * @property {string} overlayPosition - Position of the overlay.
 * @property {string} barColor - Color of the waveform bars.
 * @property {string} textColor - Color of the name text.
 * @property {any} nameTextStyling - Additional styles for the name text.
 * @property {string} imageSource - Source URL for the background image.
 * @property {boolean} roundedImage - Flag to apply rounded corners to the background image.
 * @property {any} imageStyle - Custom styles for the background image.
 *
 * @constructor
 * The constructor allows optional dependency injection for all input properties.
 *
 * @method ngOnInit
 * Initializes the component and starts waveform animations if enabled.
 *
 * @method ngOnDestroy
 * Cleans up intervals to prevent memory leaks.
 *
 * @method animateWaveform
 * Starts the waveform animations by setting intervals for each bar.
 *
 * @method animateBar
 * Animates a single bar in the waveform.
 *
 * @method resetWaveform
 * Resets the waveform animations to their initial state.
 *
 * @method clearIntervals
 * Clears all animation intervals.
 *
 * @method getAnimationDuration
 * Returns the animation duration for a given bar index.
 *
 * @method getImageStyle
 * Returns the combined styles for the background image, including optional rounded corners.
 *
 * @method combineStyles
 * Combines base styles with additional styles.
 *
 * @method handleMouseDown
 * Handles the mousedown event to start dragging the component.
 *
 * @method handleMouseMove
 * Handles the mousemove event to update the component's position while dragging.
 *
 * @method handleMouseUp
 * Handles the mouseup event to stop dragging the component.
 *
 * @method getOverlayPosition
 * Returns the position styles for the overlay.
 */
class MiniAudio {
    visible = true;
    customStyle;
    name = '';
    showWaveform = false;
    overlayPosition = '';
    barColor = 'red';
    textColor = 'white';
    nameTextStyling = {};
    imageSource = '';
    roundedImage = false;
    imageStyle = {};
    waveformAnimations = Array.from({ length: 9 }, () => 0);
    intervals = [];
    position = { x: 0, y: 0 };
    isDragging = false;
    dragOffset = { x: 0, y: 0 };
    constructor(injectedVisible, injectedCustomStyle, injectedName, injectedShowWaveform, injectedOverlayPosition, injectedBarColor, injectedTextColor, injectedNameTextStyling, injectedImageSource, injectedRoundedImage, injectedImageStyle) {
        this.visible = injectedVisible != null ? injectedVisible : this.visible;
        this.customStyle = injectedCustomStyle || this.customStyle;
        this.name = injectedName || this.name;
        this.showWaveform = injectedShowWaveform != null ? injectedShowWaveform : this.showWaveform;
        this.overlayPosition = injectedOverlayPosition || this.overlayPosition;
        this.barColor = injectedBarColor || this.barColor;
        this.textColor = injectedTextColor || this.textColor;
        this.nameTextStyling = injectedNameTextStyling || this.nameTextStyling;
        this.imageSource = injectedImageSource || this.imageSource;
        this.roundedImage = injectedRoundedImage != null ? injectedRoundedImage : this.roundedImage;
        this.imageStyle = injectedImageStyle || this.imageStyle;
    }
    ngOnInit() {
        if (this.showWaveform) {
            this.animateWaveform();
        }
        else {
            this.resetWaveform();
        }
    }
    ngOnDestroy() {
        this.clearIntervals();
    }
    animateWaveform() {
        this.intervals = this.waveformAnimations.map((_, index) => setInterval(() => this.animateBar(index), this.getAnimationDuration(index) * 2));
    }
    animateBar(index) {
        this.waveformAnimations[index] = 1;
        setTimeout(() => {
            this.waveformAnimations[index] = 0;
        }, this.getAnimationDuration(index));
    }
    resetWaveform() {
        this.waveformAnimations.fill(0);
    }
    clearIntervals() {
        this.intervals.forEach((interval) => clearInterval(interval));
    }
    getAnimationDuration(index) {
        const durations = [474, 433, 407, 458, 400, 427, 441, 419, 487];
        return durations[index] || 0;
    }
    getImageStyle() {
        return {
            ...this.imageStyle,
            ...(this.roundedImage ? { borderRadius: '20%' } : {}),
        };
    }
    combineStyles(baseStyle, additionalStyles) {
        return { ...baseStyle, ...additionalStyles };
    }
    handleMouseDown(event) {
        this.isDragging = true;
        this.dragOffset = {
            x: event.clientX - this.position.x,
            y: event.clientY - this.position.y,
        };
    }
    handleMouseMove(event) {
        if (this.isDragging) {
            this.position = {
                x: event.clientX - this.dragOffset.x,
                y: event.clientY - this.dragOffset.y,
            };
        }
    }
    handleMouseUp() {
        this.isDragging = false;
    }
    getOverlayPosition(position) {
        return getOverlayPosition({ position });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MiniAudio, deps: [{ token: 'visible', optional: true }, { token: 'customStyle', optional: true }, { token: 'name', optional: true }, { token: 'showWaveform', optional: true }, { token: 'overlayPosition', optional: true }, { token: 'barColor', optional: true }, { token: 'textColor', optional: true }, { token: 'nameTextStyling', optional: true }, { token: 'imageSource', optional: true }, { token: 'roundedImage', optional: true }, { token: 'imageStyle', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MiniAudio, isStandalone: true, selector: "app-mini-audio", inputs: { visible: "visible", customStyle: "customStyle", name: "name", showWaveform: "showWaveform", overlayPosition: "overlayPosition", barColor: "barColor", textColor: "textColor", nameTextStyling: "nameTextStyling", imageSource: "imageSource", roundedImage: "roundedImage", imageStyle: "imageStyle" }, host: { listeners: { "document:mousemove": "handleMouseMove($event)", "document:mouseup": "handleMouseUp()" } }, ngImport: i0, template: `
    <div
      *ngIf="visible"
      class="modal-container"
      [ngStyle]="{ transform: 'translate(' + position.x + 'px, ' + position.y + 'px)' }"
      (mousedown)="handleMouseDown($event)"
    >
      <div class="card" [ngStyle]="customStyle">
        <ng-container *ngIf="imageSource">
          <img
            [src]="imageSource"
            [ngStyle]="getImageStyle()"
            alt="Background"
            class="background-image"
          />
        </ng-container>
        <div class="name-text" [ngStyle]="combineStyles({ color: textColor }, nameTextStyling)">
          {{ name }}
        </div>
        <div [ngStyle]="getOverlayPosition(overlayPosition)" class="overlay-web">
          <div class="waveform-web">
            <div
              *ngFor="let animation of waveformAnimations; let i = index"
              [ngStyle]="{
                height: animation == 0 ? '1px' : '30px',
                width: '10px',
                backgroundColor: barColor
              }"
              class="bar"
            ></div>
          </div>
        </div>
      </div>
    </div>
  `, isInline: true, styles: [".modal-container{position:absolute;top:0;right:0;padding:0;margin:0;width:100px;height:100px;display:flex;justify-content:center;align-items:center;background-color:#002d2180;z-index:8;elevation:8}.card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f}.background-image{position:absolute;width:70px;height:70px;justify-content:center;align-items:center;align-self:center;top:40%;left:50%;transform:translate(-35px,-10px)}.name-text{font-size:20px;font-weight:700;display:flex;justify-content:center;align-items:center;background-color:#00000080;width:100%;padding-top:5px;padding-bottom:5px;text-align:center;z-index:2}.overlay-web{position:absolute;width:100%;height:100%;display:grid;grid-template-columns:1fr 12fr 1fr;grid-gap:3px;z-index:3}.waveform-web{display:flex;justify-content:center;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin-right:.5px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MiniAudio, decorators: [{
            type: Component,
            args: [{ selector: 'app-mini-audio', standalone: true, imports: [CommonModule], template: `
    <div
      *ngIf="visible"
      class="modal-container"
      [ngStyle]="{ transform: 'translate(' + position.x + 'px, ' + position.y + 'px)' }"
      (mousedown)="handleMouseDown($event)"
    >
      <div class="card" [ngStyle]="customStyle">
        <ng-container *ngIf="imageSource">
          <img
            [src]="imageSource"
            [ngStyle]="getImageStyle()"
            alt="Background"
            class="background-image"
          />
        </ng-container>
        <div class="name-text" [ngStyle]="combineStyles({ color: textColor }, nameTextStyling)">
          {{ name }}
        </div>
        <div [ngStyle]="getOverlayPosition(overlayPosition)" class="overlay-web">
          <div class="waveform-web">
            <div
              *ngFor="let animation of waveformAnimations; let i = index"
              [ngStyle]="{
                height: animation == 0 ? '1px' : '30px',
                width: '10px',
                backgroundColor: barColor
              }"
              class="bar"
            ></div>
          </div>
        </div>
      </div>
    </div>
  `, styles: [".modal-container{position:absolute;top:0;right:0;padding:0;margin:0;width:100px;height:100px;display:flex;justify-content:center;align-items:center;background-color:#002d2180;z-index:8;elevation:8}.card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f}.background-image{position:absolute;width:70px;height:70px;justify-content:center;align-items:center;align-self:center;top:40%;left:50%;transform:translate(-35px,-10px)}.name-text{font-size:20px;font-weight:700;display:flex;justify-content:center;align-items:center;background-color:#00000080;width:100%;padding-top:5px;padding-bottom:5px;text-align:center;z-index:2}.overlay-web{position:absolute;width:100%;height:100%;display:grid;grid-template-columns:1fr 12fr 1fr;grid-gap:3px;z-index:3}.waveform-web{display:flex;justify-content:center;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin-right:.5px}\n"] }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['visible']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['name']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showWaveform']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['overlayPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['barColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['textColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['nameTextStyling']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageSource']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['roundedImage']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageStyle']
                }] }], propDecorators: { visible: [{
                type: Input
            }], customStyle: [{
                type: Input
            }], name: [{
                type: Input
            }], showWaveform: [{
                type: Input
            }], overlayPosition: [{
                type: Input
            }], barColor: [{
                type: Input
            }], textColor: [{
                type: Input
            }], nameTextStyling: [{
                type: Input
            }], imageSource: [{
                type: Input
            }], roundedImage: [{
                type: Input
            }], imageStyle: [{
                type: Input
            }], handleMouseMove: [{
                type: HostListener,
                args: ['document:mousemove', ['$event']]
            }], handleMouseUp: [{
                type: HostListener,
                args: ['document:mouseup']
            }] } });

class MiniAudioPlayer {
    injector;
    stream = null;
    remoteProducerId = '';
    parameters = {};
    MiniAudioComponent;
    miniAudioProps = {};
    audioElement;
    showWaveModal = false;
    isMuted = false;
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    intervalId;
    autoWaveCheck = false;
    previousShowWaveModal = null;
    previousIsMuted = null;
    injectorCache = new WeakMap();
    cachedMiniAudioProps;
    constructor(injector, injectedStream, injectedRemoteProducerId, injectedParameters, injectedMiniAudioComponent, injectedMiniAudioProps) {
        this.injector = injector;
        this.stream = injectedStream || this.stream;
        this.remoteProducerId = injectedRemoteProducerId || this.remoteProducerId;
        this.parameters = injectedParameters || this.parameters;
        this.MiniAudioComponent = injectedMiniAudioComponent || this.MiniAudioComponent;
        this.miniAudioProps = injectedMiniAudioProps || this.miniAudioProps;
    }
    ngOnInit() {
        if (this.stream) {
            this.setupAudioProcessing();
        }
    }
    ngOnDestroy() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    setupAudioProcessing() {
        const analyser = this.audioContext.createAnalyser();
        analyser.fftSize = 32;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const source = this.audioContext.createMediaStreamSource(this.stream);
        source.connect(analyser);
        let consLow = false;
        this.intervalId = setInterval(() => {
            analyser.getByteTimeDomainData(dataArray);
            let averageLoudness = Array.from(dataArray).reduce((sum, value) => sum + value, 0) / bufferLength;
            const updatedParams = this.parameters.getUpdatedAllParams();
            let { eventType, participants, paginatedStreams, currentUserPage, adminNameStream, dispActiveNames, activeSounds, reUpdateInter, updateParticipantAudioDecibels, updateActiveSounds, shared, shareScreenStarted, breakOutRoomStarted, breakOutRoomEnded, limitedBreakRoom, } = updatedParams;
            const participant = participants.find((obj) => obj.audioID == this.remoteProducerId);
            let audioActiveInRoom = true;
            if (participant) {
                if (breakOutRoomStarted && !breakOutRoomEnded) {
                    if (!limitedBreakRoom.map((obj) => obj.name).includes(participant.name)) {
                        audioActiveInRoom = false;
                        averageLoudness = 127;
                    }
                }
            }
            if (this.parameters.meetingDisplayType != 'video') {
                this.autoWaveCheck = true;
            }
            if (shared || shareScreenStarted) {
                this.autoWaveCheck = false;
            }
            if (participant) {
                this.isMuted = participant.muted || false;
                if (eventType != 'chat' && eventType != 'broadcast') {
                    updateParticipantAudioDecibels({
                        name: participant.name ?? '',
                        averageLoudness: averageLoudness,
                        audioDecibels: updatedParams.audioDecibels,
                        updateAudioDecibels: updatedParams['updateAudioDecibels'],
                    });
                }
                const inPage = paginatedStreams[currentUserPage].findIndex((obj) => obj.name == participant.name);
                if (participant.name && !dispActiveNames.includes(participant.name) && inPage == -1) {
                    this.autoWaveCheck = false;
                    if (!adminNameStream) {
                        const adminParticipant = participants.find((obj) => obj.islevel == '2');
                        adminNameStream = adminParticipant ? adminParticipant.name : '';
                    }
                    if (participant.name == adminNameStream) {
                        this.autoWaveCheck = true;
                    }
                }
                else {
                    this.autoWaveCheck = true;
                }
                if (participant.videoID ||
                    this.autoWaveCheck ||
                    (breakOutRoomStarted && !breakOutRoomEnded && audioActiveInRoom)) {
                    this.showWaveModal = false;
                    if (averageLoudness > 127.5) {
                        if (!activeSounds.includes(participant.name)) {
                            activeSounds.push(participant.name);
                            consLow = false;
                            if ((shareScreenStarted || shared) && !participant.videoID) {
                                // do nothing
                            }
                            else {
                                if (eventType != 'chat' && eventType != 'broadcast' && participant.name) {
                                    reUpdateInter({
                                        name: participant.name,
                                        add: true,
                                        average: averageLoudness,
                                        parameters: updatedParams,
                                    });
                                }
                            }
                        }
                    }
                    else {
                        if (activeSounds.includes(participant.name) && consLow) {
                            activeSounds.splice(activeSounds.indexOf(participant.name), 1);
                            if ((shareScreenStarted || shared) && !participant.videoID) {
                                // do nothing
                            }
                            else {
                                if (eventType != 'chat' && eventType != 'broadcast' && participant.name) {
                                    reUpdateInter({
                                        name: participant.name,
                                        average: averageLoudness,
                                        parameters: updatedParams,
                                    });
                                }
                            }
                        }
                        else {
                            consLow = true;
                        }
                    }
                }
                else {
                    if (averageLoudness > 127.5) {
                        if (!this.parameters['autoWave']) {
                            this.showWaveModal = false;
                        }
                        else {
                            this.showWaveModal = true;
                        }
                        if (!activeSounds.includes(participant.name)) {
                            activeSounds.push(participant.name);
                        }
                        if ((shareScreenStarted || shared) && !participant.videoID) {
                            // do nothing
                        }
                        else {
                            if (eventType != 'chat' && eventType != 'broadcast' && participant.name) {
                                reUpdateInter({
                                    name: participant.name,
                                    add: true,
                                    average: averageLoudness,
                                    parameters: updatedParams,
                                });
                            }
                        }
                    }
                    else {
                        this.showWaveModal = false;
                        if (activeSounds.includes(participant.name)) {
                            activeSounds.splice(activeSounds.indexOf(participant.name), 1);
                        }
                        if ((shareScreenStarted || shared) && !participant.videoID) {
                            // do nothing
                        }
                        else {
                            if (eventType != 'chat' && eventType != 'broadcast' && participant.name) {
                                reUpdateInter({
                                    name: participant.name,
                                    average: averageLoudness,
                                    parameters: updatedParams,
                                });
                            }
                        }
                    }
                }
                updateActiveSounds(activeSounds);
            }
            else {
                this.showWaveModal = false;
                this.isMuted = true;
            }
        }, 2000);
    }
    createInjector(inputs) {
        if (!this.injectorCache.has(inputs)) {
            const injector = Injector.create({
                providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
                parent: this.injector,
            });
            this.injectorCache.set(inputs, injector);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.injectorCache.get(inputs);
    }
    getMiniAudioProps() {
        if (!this.cachedMiniAudioProps ||
            this.showWaveModal !== this.previousShowWaveModal ||
            this.isMuted !== this.previousIsMuted) {
            this.cachedMiniAudioProps = {
                ...this.miniAudioProps,
                visible: this.showWaveModal && !this.isMuted,
                showWaveform: this.showWaveModal,
            };
            this.previousShowWaveModal = this.showWaveModal;
            this.previousIsMuted = this.isMuted;
        }
        return this.cachedMiniAudioProps;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MiniAudioPlayer, deps: [{ token: i0.Injector }, { token: 'stream', optional: true }, { token: 'remoteProducerId', optional: true }, { token: 'parameters', optional: true }, { token: 'MiniAudioComponent', optional: true }, { token: 'miniAudioProps', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MiniAudioPlayer, isStandalone: true, selector: "app-mini-audio-player", inputs: { stream: "stream", remoteProducerId: "remoteProducerId", parameters: "parameters", MiniAudioComponent: "MiniAudioComponent", miniAudioProps: "miniAudioProps" }, viewQueries: [{ propertyName: "audioElement", first: true, predicate: ["audioElement"], descendants: true, static: true }], ngImport: i0, template: "<div class=\"container\">\r\n  <audio *ngIf=\"stream\" autoplay playsinline #audioElement [srcObject]=\"stream\"></audio>\r\n\r\n  <ng-container *ngIf=\"MiniAudioComponent\">\r\n    <ng-container *ngComponentOutlet=\"MiniAudioComponent; injector: createInjector(getMiniAudioProps())\"></ng-container>\r\n  </ng-container>\r\n</div>\r\n", styles: [".container{display:flex;justify-content:center;align-items:center;z-index:9}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MiniAudioPlayer, decorators: [{
            type: Component,
            args: [{ selector: 'app-mini-audio-player', standalone: true, imports: [CommonModule], template: "<div class=\"container\">\r\n  <audio *ngIf=\"stream\" autoplay playsinline #audioElement [srcObject]=\"stream\"></audio>\r\n\r\n  <ng-container *ngIf=\"MiniAudioComponent\">\r\n    <ng-container *ngComponentOutlet=\"MiniAudioComponent; injector: createInjector(getMiniAudioProps())\"></ng-container>\r\n  </ng-container>\r\n</div>\r\n", styles: [".container{display:flex;justify-content:center;align-items:center;z-index:9}\n"] }]
        }], ctorParameters: () => [{ type: i0.Injector }, { type: MediaStream, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['stream']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['remoteProducerId']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['MiniAudioComponent']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['miniAudioProps']
                }] }], propDecorators: { stream: [{
                type: Input
            }], remoteProducerId: [{
                type: Input
            }], parameters: [{
                type: Input
            }], MiniAudioComponent: [{
                type: Input
            }], miniAudioProps: [{
                type: Input
            }], audioElement: [{
                type: ViewChild,
                args: ['audioElement', { static: true }]
            }] } });

class ConsumerResume {
    /**
     * Resumes a consumer, making it ready for use.
     *
     * @param {Object} options - The options object.
     * @param {MediaStreamTrack} options.track - The media stream track associated with the resumed consumer.
     * @param {string} options.kind - The type of media ('audio' or 'video') being resumed.
     * @param {string} options.remoteProducerId - The ID of the remote producer associated with the resumed consumer.
     * @param {Object} options.params - Additional parameters related to the resumed consumer.
     * @param {Object} options.parameters - The parameters object containing various utility functions and state.
     * @param {Object} options.nsock - The socket associated with the consumer.
     * @throws Throws an error if an issue occurs during the consumer resumption.
     */
    consumerResume = async ({ track, remoteProducerId, params, parameters, nsock, }) => {
        try {
            // Get updated parameters
            parameters = parameters.getUpdatedAllParams();
            // Destructure parameters
            let { nStream, allAudioStreams, allVideoStreams, streamNames, audStreamNames, updateMainWindow, shared, shareScreenStarted, screenId, participants, eventType, meetingDisplayType, mainScreenFilled, first_round, lock_screen, oldAllStreams, adminVidID, mainHeightWidth, member, audioOnlyStreams, gotAllVids, defer_receive, firstAll, remoteScreenStream, hostLabel, whiteboardStarted, whiteboardEnded, updateUpdateMainWindow, updateAllAudioStreams, updateAllVideoStreams, updateStreamNames, updateAudStreamNames, updateNStream, updateMainHeightWidth, updateLock_screen, updateFirstAll, updateRemoteScreenStream, updateOldAllStreams, updateAudioOnlyStreams, updateShareScreenStarted, updateGotAllVids, updateScreenId, updateDefer_receive, 
            //mediasfu functions
            reorderStreams, prepopulateUserMedia, } = parameters;
            if (params.kind === 'audio') {
                // Audio resumed
                // Check if the participant with audioID == remoteProducerId has a valid videoID
                let participant = participants.filter((p) => p.audioID === remoteProducerId);
                let name__ = participant.length > 0 ? participant[0].name || '' : '';
                if (name__ === member)
                    return;
                //find any participants with ScreenID not null and ScreenOn == true
                let screenParticipant_alt = participants.filter((participant) => participant.ScreenID != null &&
                    participant.ScreenOn == true &&
                    participant.ScreenID != '');
                if (screenParticipant_alt.length > 0) {
                    screenId = screenParticipant_alt[0].ScreenID;
                    if (screenId) {
                        updateScreenId(screenId);
                    }
                    if (!shared) {
                        shareScreenStarted = true;
                        updateShareScreenStarted(shareScreenStarted);
                    }
                }
                else {
                    if (whiteboardStarted && !whiteboardEnded) {
                        // whiteboard is active
                    }
                    else {
                        screenId = '';
                        updateScreenId(screenId);
                        updateShareScreenStarted(false);
                    }
                }
                // Media display and UI update to prioritize audio/video
                nStream = new MediaStream([track]);
                updateNStream(nStream);
                // Create MiniAudioPlayer track
                let nTrack = {
                    component: MiniAudioPlayer,
                    inputs: {
                        stream: nStream ? nStream : null,
                        remoteProducerId: remoteProducerId,
                        parameters: parameters,
                        MiniAudioComponent: MiniAudio,
                        miniAudioProps: {
                            customStyle: { backgroundColor: 'gray' },
                            name: name__,
                            showWaveform: true,
                            overlayPosition: 'topRight',
                            barColor: 'white',
                            textColor: 'white',
                            imageSource: 'https://mediasfu.com/images/logo192.png',
                            roundedImage: true,
                            imageStyle: {},
                        },
                    },
                };
                // Add to audioOnlyStreams array
                audioOnlyStreams.push(nTrack);
                updateAudioOnlyStreams(audioOnlyStreams);
                // Add to allAudioStreams array; add producerId, stream
                allAudioStreams = [...allAudioStreams, { producerId: remoteProducerId, stream: nStream }];
                updateAllAudioStreams(allAudioStreams);
                let name;
                try {
                    name = participant[0].name;
                }
                catch {
                    /* handle error */
                }
                if (name) {
                    // Add to audStreamNames array; add producerId, name
                    audStreamNames = [...audStreamNames, { producerId: remoteProducerId, name: name__ }];
                    updateAudStreamNames(audStreamNames);
                    if (!mainScreenFilled && participant[0].islevel === '2') {
                        updateMainWindow = true;
                        updateUpdateMainWindow(updateMainWindow);
                        await prepopulateUserMedia({
                            name: hostLabel,
                            parameters: { ...parameters, audStreamNames, allAudioStreams },
                        });
                        updateMainWindow = false;
                        updateUpdateMainWindow(updateMainWindow);
                    }
                }
                else {
                    return;
                }
                // Checks for display type and updates the UI
                let checker;
                let alt_checker = false;
                if (meetingDisplayType == 'video') {
                    checker =
                        participant[0].videoID != null &&
                            participant[0].videoID != '' &&
                            participant[0].videoID != undefined;
                }
                else {
                    checker = true;
                    alt_checker = true;
                }
                if (checker) {
                    if (shareScreenStarted || shared) {
                        if (!alt_checker) {
                            await reorderStreams({
                                parameters: { ...parameters, audStreamNames, allAudioStreams },
                            });
                        }
                    }
                    else {
                        if (alt_checker && meetingDisplayType != 'video') {
                            await reorderStreams({
                                add: false,
                                screenChanged: true,
                                parameters: { ...parameters, audStreamNames, allAudioStreams },
                            });
                        }
                    }
                }
            }
            else {
                // Video resumed
                nStream = new MediaStream([track]);
                updateNStream(nStream);
                //find any participants with ScreenID not null and ScreenOn == true
                let screenParticipant_alt = participants.filter((participant) => participant.ScreenID != null &&
                    participant.ScreenOn == true &&
                    participant.ScreenID != '');
                if (screenParticipant_alt.length > 0) {
                    screenId = screenParticipant_alt[0].ScreenID;
                    if (screenId) {
                        updateScreenId(screenId);
                    }
                    if (!shared) {
                        shareScreenStarted = true;
                        updateShareScreenStarted(shareScreenStarted);
                    }
                }
                else {
                    if (whiteboardStarted && !whiteboardEnded) {
                        // whiteboard is active
                    }
                    else {
                        screenId = '';
                        updateScreenId(screenId);
                        updateShareScreenStarted(false);
                    }
                }
                // Check for display type and update the UI
                if (remoteProducerId == screenId) {
                    // Put on main screen for screen share
                    updateMainWindow = true;
                    updateUpdateMainWindow(updateMainWindow);
                    remoteScreenStream = [{ producerId: remoteProducerId, stream: nStream }];
                    updateRemoteScreenStream(remoteScreenStream);
                    if (eventType == 'conference') {
                        if (shared || shareScreenStarted) {
                            if (mainHeightWidth == 0) {
                                updateMainHeightWidth(84);
                            }
                        }
                        else {
                            if (mainHeightWidth > 0) {
                                updateMainHeightWidth(0);
                            }
                        }
                    }
                    if (!lock_screen) {
                        await prepopulateUserMedia({ name: hostLabel, parameters });
                        await reorderStreams({
                            add: false,
                            screenChanged: true,
                            parameters: { ...parameters, remoteScreenStream, allVideoStreams },
                        });
                    }
                    else {
                        if (!first_round) {
                            await prepopulateUserMedia({
                                name: hostLabel,
                                parameters: {
                                    ...parameters,
                                    remoteScreenStream,
                                    allVideoStreams,
                                },
                            });
                            await reorderStreams({
                                add: false,
                                screenChanged: true,
                                parameters: {
                                    ...parameters,
                                    remoteScreenStream,
                                    allVideoStreams,
                                },
                            });
                        }
                    }
                    lock_screen = true;
                    updateLock_screen(lock_screen);
                    firstAll = true;
                    updateFirstAll(firstAll);
                }
                else {
                    // Non-screen share video resumed
                    // Operations to add video to the UI (either main screen or mini screen)
                    parameters = parameters.getUpdatedAllParams();
                    // Get the name of the participant with videoID == remoteProducerId
                    let participant = participants.filter((participant) => participant.videoID == remoteProducerId);
                    if (participant.length > 0 &&
                        participant[0].name != null &&
                        participant[0].name != '' &&
                        participant[0].name != undefined &&
                        participant[0].name !== member) {
                        allVideoStreams = [
                            ...allVideoStreams,
                            { producerId: remoteProducerId, stream: nStream, socket_: nsock },
                        ];
                        updateAllVideoStreams(allVideoStreams);
                    }
                    if (participant.length > 0) {
                        let name = participant[0].name;
                        streamNames = [...streamNames, { producerId: remoteProducerId, name: name || '' }];
                        updateStreamNames(streamNames);
                    }
                    // If not screenshare, filter out the stream that belongs to the participant with isAdmin = true and islevel == '2' (host)
                    // Find the ID of the participant with isAdmin = true and islevel == '2'
                    if (!shareScreenStarted) {
                        let admin = participants.filter((participant) => participant.isAdmin == true && participant.islevel == '2');
                        // Remove video stream with producerId == admin.id
                        // Get the videoID of the admin
                        if (admin.length > 0) {
                            adminVidID = admin[0].videoID;
                            if (adminVidID != null && adminVidID != '') {
                                let oldAllStreams_ = [];
                                // Check if the length of allVideoStreams is > 0
                                if (oldAllStreams.length > 0) {
                                    oldAllStreams_ = oldAllStreams;
                                }
                                oldAllStreams = allVideoStreams.filter((streame) => streame.producerId == adminVidID);
                                updateOldAllStreams(oldAllStreams);
                                if (oldAllStreams.length < 1) {
                                    oldAllStreams = oldAllStreams_;
                                    updateOldAllStreams(oldAllStreams);
                                }
                                allVideoStreams = allVideoStreams.filter((streame) => streame.producerId != adminVidID);
                                updateAllVideoStreams(allVideoStreams);
                                if (remoteProducerId == adminVidID) {
                                    updateMainWindow = true;
                                }
                            }
                            gotAllVids = true;
                            updateGotAllVids(gotAllVids);
                        }
                    }
                    else {
                        // Check if the videoID is either that of the admin or that of the screen participant
                        let screenParticipant = participants.filter((participant) => participant.ScreenID == screenId);
                        // See if producerId is that of admin videoID or screenParticipant videoID
                        let adminVidID;
                        let screenParticipantVidID;
                        if (screenParticipant.length > 0) {
                            screenParticipantVidID = screenParticipant[0].videoID;
                        }
                        if ((adminVidID != null && adminVidID != '') ||
                            (screenParticipantVidID != null && screenParticipantVidID != '')) {
                            if (adminVidID == remoteProducerId || screenParticipantVidID == remoteProducerId) {
                                await reorderStreams({
                                    parameters: { ...parameters, allVideoStreams },
                                });
                                return;
                            }
                        }
                    }
                    // Update the UI
                    if (lock_screen || shared) {
                        defer_receive = true;
                        updateDefer_receive(defer_receive);
                        if (!first_round) {
                            await reorderStreams({
                                add: false,
                                screenChanged: true,
                                parameters: { ...parameters, allVideoStreams },
                            });
                        }
                    }
                    else {
                        await reorderStreams({
                            add: false,
                            screenChanged: true,
                            parameters: { ...parameters, allVideoStreams },
                        });
                    }
                }
            }
        }
        catch (error) {
            console.log('consumerResume error', error);
            // throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConsumerResume, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConsumerResume, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConsumerResume, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ConnectSendTransportAudio {
    /**
     * Connects the send transport for audio by producing audio data and updating the audio producer and producer transport objects.
     *
     * @param {Object} params - The parameters for connecting the send transport.
     * @param {ProducerOptions} params.audioParams - The options for the audio producer.
     * @param {ConnectSendTransportAudioParameters} params.parameters - The parameters containing the audio producer, producer transport, and update functions.
     * @param {Producer} params.parameters.audioProducer - The current audio producer.
     * @param {Transport} params.parameters.producerTransport - The transport used to produce audio data.
     * @param {Function} params.parameters.updateAudioProducer - Function to update the audio producer.
     * @param {Function} params.parameters.updateProducerTransport - Function to update the producer transport.
     *
     * @returns {Promise<void>} A promise that resolves when the audio transport is successfully connected.
     *
     * @throws Will throw an error if the connection fails.
     */
    async connectSendTransportAudio({ audioParams, parameters, }) {
        try {
            let { audioProducer, producerTransport, updateAudioProducer, updateProducerTransport } = parameters;
            // Connect the send transport for audio by producing audio data
            if (producerTransport) {
                audioProducer = await producerTransport.produce(audioParams);
            }
            else {
                throw new Error('Producer transport is null');
            }
            // Update the audio producer and producer transport objects
            updateAudioProducer(audioProducer);
            updateProducerTransport(producerTransport);
        }
        catch (error) {
            console.log('connectSendTransportAudio error', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransportAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransportAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransportAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ConnectSendTransportVideo {
    /**
     * Connects the send transport for video by producing video data and updates the relevant states.
     *
     * @param {ConnectSendTransportVideoOptions} options - The options for connecting the send transport for video.
     * @param {Object} options.videoParams - The parameters for producing video data.
     * @param {Object} options.parameters - The parameters for updating the state.
     * @param {Producer} options.parameters.videoProducer - The video producer instance.
     * @param {Transport} options.parameters.producerTransport - The transport instance used for producing video.
     * @param {string} options.parameters.islevel - The connection level.
     * @param {boolean} options.parameters.updateMainWindow - The state of the main window update.
     * @param {Function} options.parameters.updateVideoProducer - Function to update the video producer.
     * @param {Function} options.parameters.updateProducerTransport - Function to update the producer transport.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window state.
     *
     * @returns {Promise<void>} A promise that resolves when the send transport for video is connected.
     *
     * @throws Will throw an error if the connection fails.
     */
    connectSendTransportVideo = async ({ videoParams, parameters, }) => {
        try {
            let { videoProducer, producerTransport, islevel, updateMainWindow, updateVideoProducer, updateProducerTransport, updateUpdateMainWindow, } = parameters;
            // Connect the send transport for video by producing video data
            if (producerTransport) {
                videoProducer = await producerTransport.produce(videoParams);
            }
            else {
                throw new Error('Producer transport is null');
            }
            // Update main window state based on the video connection level
            if (islevel === '2') {
                updateMainWindow = true;
            }
            // Update the video producer and producer transport objects
            updateVideoProducer(videoProducer);
            updateProducerTransport(producerTransport);
            updateUpdateMainWindow(updateMainWindow);
        }
        catch (error) {
            console.log('connectSendTransportVideo error', error);
            throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransportVideo, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransportVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransportVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ConnectSendTransportScreen {
    /**
     * Connects and sets up the screen sharing transport for sending video streams.
     *
     * @param {Object} options - The options for connecting the screen transport.
     * @param {MediaStream} options.stream - The media stream containing the screen video track.
     * @param {ConnectSendTransportScreenOptions} options.parameters - The parameters required for setting up the transport.
     * @param {Producer} options.parameters.screenProducer - The screen producer object.
     * @param {Device} options.parameters.device - The device object containing RTP capabilities.
     * @param {Promise<ScreenParams>} options.parameters.screenParams - A promise resolving to screen share parameters.
     * @param {Transport} options.parameters.producerTransport - The transport object used for producing the screen share.
     * @param {Params} options.parameters.params - The parameters for producing the screen share.
     * @param {Function} options.parameters.updateScreenProducer - Function to update the screen producer object.
     * @param {Function} options.parameters.updateProducerTransport - Function to update the producer transport object.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to fetch updated device information.
     *
     * @returns {Promise<void>} A promise that resolves when the screen transport is successfully connected and set up.
     *
     * @throws Will throw an error if the connection or setup process fails.
     */
    async connectSendTransportScreen({ stream, parameters, }) {
        try {
            let { screenProducer, device, screenParams, producerTransport, params, updateScreenProducer, updateProducerTransport, } = parameters;
            device = parameters.getUpdatedAllParams().device;
            // Connect the send transport for screen share by producing screen video data
            params = screenParams;
            // Find VP9 codec for screen share
            if (!device || !device.rtpCapabilities || !device.rtpCapabilities.codecs) {
                throw new Error('Device or its RTP capabilities are not available.');
            }
            let codec = device.rtpCapabilities.codecs.find((codec) => codec.mimeType.toLowerCase() === 'video/vp9' && codec.kind === 'video');
            // Produce screen share data using the producer transport
            if (!producerTransport) {
                throw new Error('Producer transport is not available.');
            }
            screenProducer = await producerTransport.produce({
                track: stream?.getVideoTracks()[0],
                ...params,
                codec: codec,
                appData: { mediaTag: 'screen-video' },
            });
            // Update the screen producer and producer transport objects
            updateScreenProducer(screenProducer);
            updateProducerTransport(producerTransport);
        }
        catch (error) {
            console.log('connectSendTransportScreen error', error);
            throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransportScreen, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransportScreen, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransportScreen, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ProcessConsumerTransports {
    /**
     * Processes consumer transports by pausing and resuming them based on certain conditions.
     *
     * @param {Object} options - The options for processing consumer transports.
     * @param {Array} options.consumerTransports - The list of consumer transports to process.
     * @param {Array} options.lStreams_ - The list of local streams.
     * @param {Object} options.parameters - The parameters object containing various stream arrays and utility functions.
     *
     * @returns {Promise<void>} - A promise that resolves when the processing is complete.
     *
     * @throws {Error} - Throws an error if there is an issue processing consumer transports.
     *
     * The function performs the following steps:
     * 1. Destructures and updates the parameters.
     * 2. Defines a helper function to check if a producerId is valid in given stream arrays.
     * 3. Filters consumer transports to resume based on certain conditions.
     * 4. Filters consumer transports to pause based on certain conditions.
     * 5. Pauses consumer transports after a short delay.
     * 6. Emits `consumer-pause` event for each filtered transport (not audio).
     * 7. Emits `consumer-resume` event for each filtered transport (not audio).
     */
    processConsumerTransports = async ({ consumerTransports, lStreams_, parameters, }) => {
        try {
            // Destructure parameters
            let { getUpdatedAllParams } = parameters;
            parameters = getUpdatedAllParams();
            const { remoteScreenStream, oldAllStreams, newLimitedStreams, 
            // mediasfu functions
            sleep, } = parameters;
            // Function to check if the producerId is valid in the given stream arrays
            const isValidProducerId = (producerId, ...streamArrays) => {
                return (producerId !== null &&
                    producerId !== '' &&
                    streamArrays.some((streamArray) => {
                        return (streamArray.length > 0 &&
                            streamArray.some((stream) => stream?.producerId === producerId));
                    }));
            };
            // Get paused consumer transports that are not audio
            const consumerTransportsToResume = consumerTransports.filter((transport) => isValidProducerId(transport.producerId, lStreams_, remoteScreenStream, oldAllStreams, newLimitedStreams) &&
                transport.consumer?.paused === true &&
                transport.consumer.kind !== 'audio');
            // Get unpaused consumer transports that are not audio
            const consumerTransportsToPause = consumerTransports.filter((transport) => transport.producerId &&
                transport.producerId !== null &&
                transport.producerId !== '' &&
                !lStreams_.some((stream) => stream.producerId === transport.producerId) &&
                transport.consumer &&
                transport.consumer.kind &&
                transport.consumer.paused !== true &&
                transport.consumer.kind !== 'audio' &&
                !remoteScreenStream.some((stream) => stream.producerId === transport.producerId) &&
                !oldAllStreams.some((stream) => stream.producerId === transport.producerId) &&
                !newLimitedStreams.some((stream) => stream.producerId === transport.producerId));
            // Pause consumer transports after a short delay
            await sleep({ ms: 100 });
            // Emit consumer.pause() for each filtered transport (not audio)
            for (const transport of consumerTransportsToPause) {
                transport.consumer.pause();
                transport.socket_.emit('consumer-pause', { serverConsumerId: transport.serverConsumerTransportId }, async () => {
                    // Handle the response if needed
                });
            }
            // Emit consumer.resume() for each filtered transport (not audio)
            for (const transport of consumerTransportsToResume) {
                transport.socket_.emit('consumer-resume', { serverConsumerId: transport.serverConsumerTransportId }, async ({ resumed }) => {
                    if (resumed) {
                        transport.consumer.resume();
                    }
                });
            }
        }
        catch (error) {
            // Handle errors during the process of pausing or resuming consumer transports
            console.log(`Error processing consumer transports: ${error.message}`);
            // throw new Error(`Error processing consumer transports: ${error.message}`);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProcessConsumerTransports, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProcessConsumerTransports, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProcessConsumerTransports, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ResumePauseStreams {
    /**
     * Resumes or pauses streams based on the provided parameters.
     *
     * @param {ResumePauseStreamsOptions} options - The options for resuming or pausing streams.
     * @param {Object} options.parameters - The parameters for the function.
     * @param {Array} options.parameters.participants - The list of participants.
     * @param {Array} options.parameters.dispActiveNames - The list of active display names.
     * @param {Array} options.parameters.consumerTransports - The list of consumer transports.
     * @param {string} options.parameters.screenId - The screen producer ID.
     * @param {string} options.parameters.islevel - The level of the user.
     *
     * @returns {Promise<void>} A promise that resolves when the streams have been resumed or paused.
     *
     * @throws Will throw an error if there is an issue during the process of resuming or pausing streams.
     */
    resumePauseStreams = async ({ parameters }) => {
        try {
            // Destructure parameters
            parameters = parameters.getUpdatedAllParams();
            let { participants, dispActiveNames, consumerTransports, screenId, islevel } = parameters;
            // Get the videoID of the host (islevel=2)
            let host = participants.find((obj) => obj.islevel === '2');
            let hostVideoID = host ? host.videoID : null;
            // Get videoIDs of participants in dispActiveNames and screenproducerId
            let videosIDs = dispActiveNames.map((name) => {
                let participant = participants.find((obj) => obj.name === name);
                return participant ? participant.videoID : null;
            });
            // Add screenproducerId to allVideoIDs if it's not null or empty
            if (screenId) {
                videosIDs.push(screenId);
            }
            // Add hostVideoID to allVideoIDs if it's not null or empty (only if the user is not the host)
            if (islevel !== '2' && hostVideoID) {
                videosIDs.push(hostVideoID);
            }
            // Remove null or empty videoIDs
            let allVideoIDs = videosIDs.filter((videoID) => videoID !== null && videoID !== '');
            if (allVideoIDs.length > 0) {
                // Get consumer transports with producerId in allVideoIDs
                const consumerTransportsToResume = consumerTransports.filter((transport) => allVideoIDs.includes(transport.producerId) && transport.consumer.kind !== 'audio');
                // Resume all consumerTransportsToResume
                for (const transport of consumerTransportsToResume) {
                    transport.socket_.emit('consumer-resume', { serverConsumerId: transport.serverConsumerTransportId }, async ({ resumed }) => {
                        if (resumed) {
                            transport.consumer.resume();
                        }
                    });
                }
            }
        }
        catch (error) {
            console.log('Error during resuming or pausing streams: ', error);
            // Handle errors during the process of resuming or pausing streams
            // throw new Error(`Error during resuming or pausing streams: ${error.message}`);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ResumePauseStreams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ResumePauseStreams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ResumePauseStreams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class Readjust {
    /**
     * Adjusts the layout parameters based on the provided options.
     *
     * @param {ReadjustOptions} options - The options for readjusting the layout.
     * @param {number} options.n - The number of participants or elements.
     * @param {number} options.state - The current state of the layout.
     * @param {object} options.parameters - The parameters for the layout adjustment.
     * @param {function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {string} options.parameters.eventType - The type of event (e.g., "broadcast", "chat", "conference").
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
     * @param {boolean} options.parameters.shared - Indicates if content is being shared.
     * @param {number} options.parameters.mainHeightWidth - The main height and width value.
     * @param {number} options.parameters.prevMainHeightWidth - The previous main height and width value.
     * @param {string} options.parameters.hostLabel - The label for the host.
     * @param {boolean} options.parameters.first_round - Indicates if it is the first round.
     * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
     * @param {function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
     * @param {function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @returns {Promise<void>} A promise that resolves when the layout adjustment is complete.
     * @throws {Error} Throws an error if there is an issue updating the grid sizes.
     */
    readjust = async ({ n, state, parameters }) => {
        let { getUpdatedAllParams, prepopulateUserMedia } = parameters;
        parameters = getUpdatedAllParams();
        try {
            // Destructure parameters
            let { eventType, shareScreenStarted, shared, mainHeightWidth, prevMainHeightWidth, hostLabel, first_round, lock_screen, updateMainHeightWidth, } = parameters;
            if (state == 0) {
                prevMainHeightWidth = mainHeightWidth;
            }
            let val1 = 6;
            let val2 = 12 - val1;
            let cal1 = Math.floor((val1 / 12) * 100);
            let cal2 = 100 - cal1;
            if (eventType == 'broadcast') {
                val1 = 0;
                val2 = 12 - val1;
                if (n == 0) {
                    val1 = 0;
                    val2 = 12 - val1;
                }
            }
            else if (eventType == 'chat' ||
                (eventType == 'conference' && !(shareScreenStarted || shared))) {
                val1 = 12;
                val2 = 12 - val1;
            }
            else {
                if (shareScreenStarted || shared) {
                    val2 = 10;
                    val1 = 12 - val2;
                }
                else {
                    if (n == 0) {
                        val1 = 1;
                        val2 = 12 - val1;
                    }
                    else if (n >= 1 && n < 4) {
                        val1 = 4;
                        val2 = 12 - val1;
                    }
                    else if (n >= 4 && n < 6) {
                        val1 = 6;
                        val2 = 12 - val1;
                    }
                    else if (n >= 6 && n < 9) {
                        val1 = 6;
                        val2 = 12 - val1;
                    }
                    else if (n >= 9 && n < 12) {
                        val1 = 6;
                        val2 = 12 - val1;
                    }
                    else if (n >= 12 && n < 20) {
                        val1 = 8;
                        val2 = 12 - val1;
                    }
                    else if (n >= 20 && n < 50) {
                        val1 = 8;
                        val2 = 12 - val1;
                    }
                    else {
                        val1 = 10;
                        val2 = 12 - val1;
                    }
                }
            }
            if (state == 0) {
                mainHeightWidth = val2;
            }
            cal1 = Math.floor((val1 / 12) * 100);
            cal2 = 100 - cal1;
            updateMainHeightWidth(cal2);
            if (prevMainHeightWidth != mainHeightWidth) {
                if (!lock_screen && !shared) {
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                }
                else {
                    if (!first_round) {
                        await prepopulateUserMedia({ name: hostLabel, parameters });
                    }
                }
            }
        }
        catch (error) {
            // Handle errors during the process of updating grid sizes
            console.log('Error updating grid sizes:', error.message);
            // throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Readjust, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Readjust, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Readjust, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CheckGrid {
    /**
     * Checks the grid configuration and calculates various parameters based on the number of rows, columns, and active elements.
     *
     * @param {CheckGridOptions} options - The options for checking the grid.
     * @param {number} options.rows - The number of rows in the grid.
     * @param {number} options.cols - The number of columns in the grid.
     * @param {number} options.actives - The number of active elements in the grid.
     * @returns {Promise<[boolean, number, number, number, number, number, number] | void>} A promise that resolves to a tuple containing:
     * - `removeAltGrid` (boolean): Indicates whether to remove the alternate grid.
     * - `numtoadd` (number): The number of elements to add.
     * - `numRows` (number): The number of rows.
     * - `numCols` (number): The number of columns.
     * - `remainingVideos` (number): The number of remaining videos.
     * - `actualRows` (number): The actual number of rows.
     * - `lastrowcols` (number): The number of columns in the last row.
     *
     * If an error occurs, it logs the error to the console.
     */
    async checkGrid({ rows, cols, actives, }) {
        try {
            let numRows = 0;
            let numCols = 0;
            let lastrow = 0;
            let lastrowcols = 0;
            let remainingVideos = 0;
            let numtoadd = 0;
            let actualRows = 0;
            let removeAltGrid = false;
            if (rows * cols !== actives) {
                if (rows * cols > actives) {
                    const res = actives - (rows - 1) * cols;
                    if (cols * 0.5 < res) {
                        lastrow = rows;
                        lastrowcols = res;
                        remainingVideos = lastrowcols;
                    }
                    else {
                        lastrowcols = res + cols;
                        lastrow = rows - 1;
                        remainingVideos = lastrowcols;
                    }
                    numRows = lastrow - 1;
                    numCols = cols;
                    numtoadd = (lastrow - 1) * numCols;
                    actualRows = lastrow;
                    removeAltGrid = false;
                }
            }
            else {
                // Perfect fit
                numCols = cols;
                numRows = rows;
                lastrow = rows;
                lastrowcols = cols;
                remainingVideos = 0;
                numtoadd = lastrow * numCols;
                actualRows = lastrow;
                removeAltGrid = true;
            }
            return [removeAltGrid, numtoadd, numRows, numCols, remainingVideos, actualRows, lastrowcols];
        }
        catch (error) {
            console.log('checkGrid error', error);
            throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckGrid, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckGrid, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckGrid, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// estimate.service.ts
class GetEstimate {
    /**
     * Estimates the number of rows and columns for a given set of parameters.
     *
     * @param {GetEstimateOptions} options - The options for the estimation.
     * @param {number} options.n - The number of items to estimate for.
     * @param {Object} options.parameters - The parameters for the estimation.
     * @param {number} options.parameters.fixedPageLimit - The fixed page limit.
     * @param {number} options.parameters.screenPageLimit - The screen page limit.
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
     * @param {boolean} options.parameters.shared - Indicates if sharing is active.
     * @param {string} options.parameters.eventType - The type of event (e.g., "chat", "conference").
     * @param {boolean} options.parameters.removeAltGrid - Indicates if the alternate grid should be removed.
     * @param {boolean} options.parameters.isWideScreen - Indicates if the screen is wide.
     * @param {boolean} options.parameters.isMediumScreen - Indicates if the screen is medium-sized.
     * @param {Function} options.parameters.updateRemoveAltGrid - Function to update the removeAltGrid parameter.
     * @param {Function} options.parameters.calculateRowsAndColumns - Function to calculate rows and columns.
     *
     * @returns {number[]} An array containing the estimated number of items, rows, and columns.
     *
     * @throws Will log an error message if an error occurs during estimation.
     */
    getEstimate({ n, parameters }) {
        try {
            // Destructure parameters
            let { fixedPageLimit, screenPageLimit, shareScreenStarted, shared, eventType, removeAltGrid, isWideScreen, isMediumScreen, updateRemoveAltGrid, 
            // mediaSfu functions
            calculateRowsAndColumns, } = parameters;
            // Calculate rows and columns
            const [rows, cols] = calculateRowsAndColumns({ n });
            // Check conditions for removing alt grid
            if (n < fixedPageLimit || ((shareScreenStarted || shared) && n < screenPageLimit + 1)) {
                removeAltGrid = true;
                updateRemoveAltGrid(removeAltGrid);
                // Return estimated values based on screen width
                if (!(isMediumScreen || isWideScreen)) {
                    return eventType === 'chat' ||
                        (eventType === 'conference' && !(shareScreenStarted || shared))
                        ? [n, n, 1]
                        : [n, 1, n];
                }
                else {
                    return eventType === 'chat' ||
                        (eventType === 'conference' && !(shareScreenStarted || shared))
                        ? [n, 1, n]
                        : [n, n, 1];
                }
            }
            return [rows * cols, rows, cols];
        }
        catch (error) {
            // Handle errors during estimation
            console.log('Error estimating rows and columns:', error.message);
            // throw error;
            return [0, 0, 0];
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetEstimate, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetEstimate, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetEstimate, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CalculateRowsAndColumns {
    /**
     * Calculates the number of rows and columns needed to display a given number of items in a grid.
     *
     * @param {CalculateRowsAndColumnsOptions} options - The options for calculating rows and columns.
     * @param {number} options.n - The number of items to display.
     * @returns {[number, number]} A tuple containing the number of rows and columns.
     */
    calculateRowsAndColumns({ n }) {
        // Calculate the square root of n
        const sqrt = Math.sqrt(n);
        // Initialize columns based on the floor of the square root
        let cols = Math.floor(sqrt);
        // Calculate the number of rows needed to display n videos
        let rows = Math.ceil(n / cols);
        // Calculate the product of rows and columns
        let prod = rows * cols;
        // Adjust rows and columns until the product is greater than or equal to n
        while (prod < n) {
            if (cols < rows) {
                cols++;
            }
            else {
                rows++;
            }
            prod = rows * cols;
        }
        // Return an array with the calculated number of rows and columns
        return [rows, cols];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CalculateRowsAndColumns, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CalculateRowsAndColumns, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CalculateRowsAndColumns, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class AddVideosGrid {
    addVideosGrid = async ({ mainGridStreams, altGridStreams, numtoadd, numRows, numCols, actualRows, lastrowcols, removeAltGrid, parameters, }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = { ...parameters, ...getUpdatedAllParams() };
        let { eventType, updateAddAltGrid, ref_participants, islevel, videoAlreadyOn, localStreamVideo, keepBackground, virtualStream, forceFullDisplay, otherGridStreams, updateOtherGridStreams, updateMiniCardsGrid, } = parameters;
        let newComponents = [[], []];
        let participant;
        let remoteProducerId = '';
        let participant_ = null;
        numtoadd = mainGridStreams.length;
        if (removeAltGrid) {
            updateAddAltGrid(false);
        }
        // Add participants to the main grid
        for (let i = 0; i < numtoadd; i++) {
            participant = mainGridStreams[i];
            remoteProducerId = participant.producerId;
            let pseudoName = !remoteProducerId || remoteProducerId === '';
            if (pseudoName) {
                participant_ = participant;
                remoteProducerId = await participant.name;
                if (Object.prototype.hasOwnProperty.call(participant, 'audioID') &&
                    participant.audioID != null &&
                    participant.audioID !== '') {
                    newComponents[0].push({
                        component: AudioCard,
                        inputs: {
                            name: participant.name,
                            barColor: 'red',
                            textColor: 'white',
                            customStyle: {
                                backgroundColor: 'transparent',
                                border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                            },
                            controlsPosition: 'topLeft',
                            infoPosition: 'topRight',
                            showWaveform: true,
                            roundedImage: true,
                            parameters,
                            backgroundColor: 'transparent',
                            showControls: eventType !== 'chat',
                            participant,
                        },
                    });
                }
                else {
                    newComponents[0].push({
                        component: MiniCard,
                        inputs: {
                            initials: participant.name,
                            fontSize: 20,
                            customStyle: {
                                backgroundColor: 'transparent',
                                border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                            },
                        },
                    });
                }
            }
            else {
                if (remoteProducerId === 'youyou' || remoteProducerId === 'youyouyou') {
                    let name = 'You';
                    if (islevel === '2' && eventType !== 'chat') {
                        name = 'You (Host)';
                    }
                    if (!videoAlreadyOn) {
                        name = 'You';
                        if (islevel == '2' && eventType != 'chat') {
                            name = 'You (Host)';
                        }
                        newComponents[0].push({
                            component: MiniCard,
                            inputs: {
                                initials: name,
                                fontSize: 20,
                                customStyle: {
                                    backgroundColor: 'transparent',
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                            },
                        });
                    }
                    else {
                        participant = {
                            id: 'youyouyou',
                            stream: keepBackground && virtualStream ? virtualStream : localStreamVideo,
                            name: 'youyouyou',
                            muted: true,
                        };
                        participant_ = {
                            id: 'youyou',
                            videoID: 'youyou',
                            name: 'youyouyou',
                            stream: keepBackground && virtualStream ? virtualStream : localStreamVideo,
                        };
                        remoteProducerId = 'youyouyou';
                        newComponents[0].push({
                            component: VideoCard,
                            inputs: {
                                videoStream: participant.stream ? participant.stream : null,
                                remoteProducerId: participant.stream ? participant.stream.id : null,
                                eventType,
                                forceFullDisplay: eventType == 'webinar' ? false : forceFullDisplay,
                                customStyle: {
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                                participant: participant,
                                backgroundColor: 'transparent',
                                showControls: false,
                                showInfo: false,
                                name: participant.name,
                                doMirror: true,
                                parameters,
                            },
                        });
                    }
                }
                else {
                    participant_ = ref_participants.find((obj) => obj.videoID === remoteProducerId);
                    if (participant_) {
                        newComponents[0].push({
                            component: VideoCard,
                            inputs: {
                                videoStream: participant.stream ? participant.stream : null,
                                remoteProducerId,
                                eventType,
                                forceFullDisplay,
                                customStyle: {
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                                participant: participant_,
                                backgroundColor: 'transparent',
                                showControls: eventType !== 'chat',
                                showInfo: true,
                                name: participant_.name,
                                doMirror: false,
                                parameters,
                            },
                        });
                    }
                }
            }
            if (i === numtoadd - 1) {
                otherGridStreams[0] = newComponents[0];
                await updateMiniCardsGrid({
                    rows: numRows,
                    cols: numCols,
                    defal: true,
                    actualRows: actualRows,
                    parameters,
                });
                updateOtherGridStreams(otherGridStreams);
                await updateMiniCardsGrid({
                    rows: numRows,
                    cols: numCols,
                    defal: true,
                    actualRows,
                    parameters,
                });
            }
        }
        // Handle the alternate grid streams
        if (!removeAltGrid) {
            for (let i = 0; i < altGridStreams.length; i++) {
                participant = altGridStreams[i];
                remoteProducerId = participant.producerId;
                let participant_;
                let pseudoName = false;
                //check if there is .name in the participant object and if it is null
                if (Object.prototype.hasOwnProperty.call(participant, 'producerId') &&
                    participant.producerId != null &&
                    participant.producerId !== '') {
                    //actual video
                    pseudoName = false;
                }
                else {
                    pseudoName = true;
                }
                if (pseudoName) {
                    participant_ = participant;
                    remoteProducerId = await participant.name;
                    if (Object.prototype.hasOwnProperty.call(participant, 'audioID') &&
                        participant.audioID != null &&
                        participant.audioID !== '') {
                        newComponents[1].push({
                            component: AudioCard,
                            inputs: {
                                name: participant.name,
                                barColor: 'red',
                                textColor: 'white',
                                customStyle: {
                                    backgroundColor: 'transparent',
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                                controlsPosition: 'topLeft',
                                infoPosition: 'topRight',
                                showWaveform: true,
                                roundedImage: true,
                                parameters,
                                backgroundColor: 'transparent',
                                showControls: eventType !== 'chat',
                                participant,
                            },
                        });
                    }
                    else {
                        newComponents[1].push({
                            component: MiniCard,
                            inputs: {
                                initials: participant.name,
                                fontSize: 20,
                                customStyle: {
                                    backgroundColor: 'transparent',
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                            },
                        });
                    }
                }
                else {
                    participant_ = ref_participants.find((obj) => obj.videoID === remoteProducerId);
                    newComponents[1].push({
                        component: VideoCard,
                        inputs: {
                            videoStream: participant_ && participant_['stream'] ? participant_['stream'] : null,
                            remoteProducerId,
                            eventType,
                            forceFullDisplay,
                            customStyle: {
                                border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                            },
                            participant: participant_,
                            backgroundColor: 'transparent',
                            showControls: eventType !== 'chat',
                            showInfo: true,
                            name: participant.name,
                            doMirror: false,
                            parameters,
                        },
                    });
                }
                if (i === numtoadd - 1) {
                    otherGridStreams[1] = newComponents[1];
                    await updateMiniCardsGrid({
                        rows: 1,
                        cols: lastrowcols,
                        defal: false,
                        actualRows,
                        parameters,
                    });
                    updateOtherGridStreams(otherGridStreams);
                    await updateMiniCardsGrid({
                        rows: 1,
                        cols: lastrowcols,
                        defal: false,
                        actualRows,
                        parameters,
                    });
                }
            }
        }
        else {
            updateAddAltGrid(false);
            otherGridStreams[1] = [];
            await updateMiniCardsGrid({
                rows: 0,
                cols: 0,
                defal: false,
                actualRows: actualRows,
                parameters,
            });
            updateOtherGridStreams(otherGridStreams);
            await updateMiniCardsGrid({
                rows: 0,
                cols: 0,
                defal: false,
                actualRows,
                parameters,
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AddVideosGrid, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AddVideosGrid, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AddVideosGrid, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class OnScreenChanges {
    /**
     * Handles changes in screen events such as broadcast, chat, and conference.
     *
     * @param {OnScreenChangesOptions} options - The options for handling screen changes.
     * @param {boolean} options.changed - Indicates if the screen has changed.
     * @param {object} options.parameters - The parameters for handling screen changes.
     * @param {string} options.parameters.eventType - The type of event (e.g., "broadcast", "chat", "conference").
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
     * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
     * @param {boolean} options.parameters.addForBasic - Flag to add basic controls.
     * @param {function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
     * @param {function} options.parameters.updateAddForBasic - Function to update the addForBasic flag.
     * @param {number} options.parameters.itemPageLimit - The limit for item pages.
     * @param {function} options.parameters.updateItemPageLimit - Function to update the item page limit.
     * @param {function} options.parameters.reorderStreams - Function to reorder streams.
     *
     * @returns {Promise<void>} A promise that resolves when the screen changes have been handled.
     *
     * @throws {Error} Throws an error if there is an issue handling screen changes.
     */
    onScreenChanges = async ({ changed = false, parameters, }) => {
        try {
            // Destructure parameters
            let { eventType, shareScreenStarted, shared, addForBasic, updateMainHeightWidth, updateAddForBasic, itemPageLimit, updateItemPageLimit, 
            // mediasfu functions
            reorderStreams, } = parameters;
            // Remove element with id 'controlButtons'
            addForBasic = false;
            updateAddForBasic(addForBasic);
            if (eventType == 'broadcast' || eventType == 'chat') {
                addForBasic = true;
                updateAddForBasic(addForBasic);
                itemPageLimit = eventType == 'broadcast' ? 1 : 2;
                updateItemPageLimit(itemPageLimit);
                updateMainHeightWidth(eventType == 'broadcast' ? 100 : 0);
            }
            else {
                if (eventType == 'conference' && !(shareScreenStarted || shared)) {
                    updateMainHeightWidth(0);
                }
            }
            // Update the mini cards grid
            await reorderStreams({ add: false, screenChanged: changed, parameters });
        }
        catch (error) {
            // Handle errors during the process of handling screen changes
            console.log('Error handling screen changes:', error.message);
            // throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: OnScreenChanges, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: OnScreenChanges, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: OnScreenChanges, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Pauses the execution for a specified number of milliseconds.
 *
 * @param {SleepOptions} options - An object containing the sleep duration.
 * @param {number} options.ms - The number of milliseconds to sleep.
 * @returns {Promise<void>} A promise that resolves after the specified duration.
 */
function sleep({ ms }) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

class ChangeVids {
    /**
     * Asynchronously changes the video streams based on the provided options.
     *
     * @param {Object} options - The options for changing video streams.
     * @param {boolean} [options.screenChanged=false] - Indicates if the screen has changed.
     * @param {ChangeVidsOptions} options.parameters - The parameters for changing video streams.
     * @returns {Promise<void>} A promise that resolves when the video streams have been changed.
     *
     * @typedef {Object} ChangeVidsOptions
     * @property {Function} getUpdatedAllParams - Function to get updated parameters.
     * @property {Array} allVideoStreams - Array of all video streams.
     * @property {Array} p_activeNames - Array of active participant names.
     * @property {Array} activeNames - Array of active names.
     * @property {Array} dispActiveNames - Array of displayed active names.
     * @property {boolean} shareScreenStarted - Indicates if screen sharing has started.
     * @property {boolean} shared - Indicates if the screen is shared.
     * @property {Array} newLimitedStreams - Array of new limited streams.
     * @property {Array} non_alVideoStreams - Array of non-al video streams.
     * @property {Array} ref_participants - Array of reference participants.
     * @property {Array} participants - Array of participants.
     * @property {string} eventType - Type of the event.
     * @property {string} islevel - Level of the participant.
     * @property {string} member - Name of the member.
     * @property {boolean} sortAudioLoudness - Indicates if audio loudness should be sorted.
     * @property {Array} audioDecibels - Array of audio decibels.
     * @property {Array} mixed_alVideoStreams - Array of mixed al video streams.
     * @property {Array} non_alVideoStreams_muted - Array of muted non-al video streams.
     * @property {string} remoteProducerId - ID of the remote producer.
     * @property {Object} localStreamVideo - Local stream video object.
     * @property {Array} oldAllStreams - Array of old all streams.
     * @property {number} screenPageLimit - Limit of streams per screen page.
     * @property {string} meetingDisplayType - Type of meeting display.
     * @property {boolean} meetingVideoOptimized - Indicates if meeting video is optimized.
     * @property {boolean} recordingVideoOptimized - Indicates if recording video is optimized.
     * @property {string} recordingDisplayType - Type of recording display.
     * @property {Array} paginatedStreams - Array of paginated streams.
     * @property {number} itemPageLimit - Limit of items per page.
     * @property {boolean} doPaginate - Indicates if pagination should be done.
     * @property {boolean} prevDoPaginate - Indicates if pagination was previously done.
     * @property {number} currentUserPage - Current user page number.
     * @property {Array} breakoutRooms - Array of breakout rooms.
     * @property {number} hostNewRoom - Index of the new room for the host.
     * @property {boolean} breakOutRoomStarted - Indicates if breakout room has started.
     * @property {boolean} breakOutRoomEnded - Indicates if breakout room has ended.
     * @property {Object} virtualStream - Virtual stream object.
     * @property {number} mainRoomsLength - Length of main rooms.
     * @property {string} memberRoom - Room of the member.
     * @property {Function} updateP_activeNames - Function to update active participant names.
     * @property {Function} updateActiveNames - Function to update active names.
     * @property {Function} updateDispActiveNames - Function to update displayed active names.
     * @property {Function} updateNewLimitedStreams - Function to update new limited streams.
     * @property {Function} updateNon_alVideoStreams - Function to update non-al video streams.
     * @property {Function} updateRef_participants - Function to update reference participants.
     * @property {Function} updateSortAudioLoudness - Function to update audio loudness sorting.
     * @property {Function} updateMixed_alVideoStreams - Function to update mixed al video streams.
     * @property {Function} updateNon_alVideoStreams_muted - Function to update muted non-al video streams.
     * @property {Function} updatePaginatedStreams - Function to update paginated streams.
     * @property {Function} updateDoPaginate - Function to update pagination status.
     * @property {Function} updatePrevDoPaginate - Function to update previous pagination status.
     * @property {Function} updateCurrentUserPage - Function to update current user page.
     * @property {Function} updateNumberPages - Function to update number of pages.
     * @property {Function} updateMainRoomsLength - Function to update main rooms length.
     * @property {Function} updateMemberRoom - Function to update member room.
     * @property {Function} mixStreams - Function to mix streams.
     * @property {Function} dispStreams - Function to display streams.
     */
    changeVids = async ({ screenChanged = false, parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { allVideoStreams, p_activeNames, activeNames, dispActiveNames, shareScreenStarted, shared, newLimitedStreams, non_alVideoStreams, ref_participants, participants, eventType, islevel, member, sortAudioLoudness, audioDecibels, mixed_alVideoStreams, non_alVideoStreams_muted, remoteProducerId, localStreamVideo, oldAllStreams, screenPageLimit, meetingDisplayType, meetingVideoOptimized, recordingVideoOptimized, recordingDisplayType, paginatedStreams, itemPageLimit, doPaginate, prevDoPaginate, currentUserPage, breakoutRooms, hostNewRoom, breakOutRoomStarted, breakOutRoomEnded, virtualStream, mainRoomsLength, memberRoom, updateP_activeNames, updateActiveNames, updateDispActiveNames, updateNewLimitedStreams, updateNon_alVideoStreams, updateRef_participants, updateSortAudioLoudness, updateMixed_alVideoStreams, updateNon_alVideoStreams_muted, updatePaginatedStreams, updateDoPaginate, updatePrevDoPaginate, updateCurrentUserPage, updateNumberPages, updateMainRoomsLength, updateMemberRoom, 
        // mediasfu functions
        mixStreams, dispStreams, } = parameters;
        try {
            let alVideoStreams = [...allVideoStreams];
            p_activeNames = [...activeNames];
            let streame;
            if (shareScreenStarted || shared) {
                alVideoStreams = [...newLimitedStreams];
                activeNames = [];
            }
            activeNames = [];
            dispActiveNames = [];
            ref_participants = participants;
            let temp = alVideoStreams;
            await Promise.all(temp.map(async (stream) => {
                let participant = ref_participants.find((obj) => obj.videoID === stream.producerId);
                if (!participant && stream.producerId !== 'youyou' && stream.producerId !== 'youyouyou') {
                    alVideoStreams = alVideoStreams.filter((obj) => obj.producerId !== stream.producerId);
                }
            }));
            if (eventType === 'broadcast' || eventType === 'chat') {
                sortAudioLoudness = false;
            }
            if (shareScreenStarted || shared) {
                non_alVideoStreams = [];
                non_alVideoStreams_muted = [];
                mixed_alVideoStreams = [];
            }
            else {
                if (alVideoStreams.length > screenPageLimit) {
                    alVideoStreams = alVideoStreams.filter((obj) => obj.producerId !== 'youyou' && obj.producerId !== 'youyouyou');
                    ref_participants = ref_participants.sort((a, b) => (a.muted ?? false) > (b.muted ?? false) ? 1 : -1);
                    let temp = [];
                    await Promise.all(ref_participants.map((participant) => {
                        let stream = alVideoStreams.find((obj) => obj.producerId === participant.videoID);
                        if (stream) {
                            temp.push(stream);
                        }
                    }));
                    alVideoStreams = temp;
                    let youyou = allVideoStreams.find((obj) => obj.producerId === 'youyou');
                    if (!youyou) {
                        let youyouyou = allVideoStreams.find((obj) => obj.producerId === 'youyouyou');
                        if (youyouyou) {
                            alVideoStreams.unshift(youyouyou);
                        }
                    }
                    else {
                        if (youyou) {
                            alVideoStreams.unshift(youyou);
                        }
                    }
                }
                const admin = participants.filter((participant) => participant.islevel === '2');
                let adminName = '';
                if (admin.length > 0) {
                    adminName = admin[0].name || '';
                }
                non_alVideoStreams = [];
                await Promise.all(ref_participants.map(async (participant) => {
                    let stream = alVideoStreams.find((obj) => obj.producerId === participant.videoID);
                    if (eventType !== 'chat' && eventType !== 'conference') {
                        if (!stream &&
                            participant.name !== member &&
                            !participant['muted'] &&
                            participant.name !== adminName) {
                            non_alVideoStreams.push(participant);
                        }
                    }
                    else {
                        if (!stream && participant.name !== member && !participant['muted']) {
                            non_alVideoStreams.push(participant);
                        }
                    }
                }));
                if (sortAudioLoudness) {
                    non_alVideoStreams.sort((a, b) => {
                        const avgLoudnessA = audioDecibels.find((obj) => obj.name === a.name)?.averageLoudness || 127;
                        const avgLoudnessB = audioDecibels.find((obj) => obj.name === b.name)?.averageLoudness || 127;
                        return avgLoudnessB - avgLoudnessA;
                    });
                    if (!(meetingDisplayType === 'video' && meetingVideoOptimized) ||
                        !(recordingVideoOptimized && recordingDisplayType === 'video')) {
                        mixed_alVideoStreams = await mixStreams({
                            alVideoStreams,
                            non_alVideoStreams,
                            ref_participants,
                        });
                    }
                }
                non_alVideoStreams_muted = [];
                await Promise.all(ref_participants.map(async (participant) => {
                    let stream = alVideoStreams.find((obj) => obj.producerId === participant.videoID);
                    if (eventType !== 'chat' && eventType !== 'conference') {
                        if (!stream &&
                            participant.name !== member &&
                            participant['muted'] &&
                            participant.name !== adminName) {
                            non_alVideoStreams_muted.push(participant);
                        }
                    }
                    else {
                        if (!stream && participant.name !== member && participant['muted']) {
                            non_alVideoStreams_muted.push(participant);
                        }
                    }
                }));
            }
            if (eventType === 'conference' && islevel !== '2') {
                let host = participants.find((obj) => obj.islevel === '2');
                if (host) {
                    if (host.videoID) {
                        remoteProducerId = host.videoID;
                    }
                    if (islevel === '2') {
                        host['stream'] = virtualStream || localStreamVideo;
                    }
                    else {
                        let hostVideo = alVideoStreams.find((obj) => obj.producerId === remoteProducerId);
                        if (!hostVideo) {
                            streame = oldAllStreams.find((streame) => streame.producerId === remoteProducerId);
                            if (streame) {
                                alVideoStreams = alVideoStreams.filter((obj) => obj.producerId !== host.videoID);
                                non_alVideoStreams = non_alVideoStreams.filter((obj) => obj.name !== host.name);
                                non_alVideoStreams_muted = non_alVideoStreams_muted.filter((obj) => obj.name !== host.name);
                                if (sortAudioLoudness) {
                                    mixed_alVideoStreams = mixed_alVideoStreams.filter((obj) => obj.name !== host.name);
                                    non_alVideoStreams_muted = non_alVideoStreams_muted.filter((obj) => obj.name !== host.name);
                                    if (meetingDisplayType == 'video' && meetingVideoOptimized) {
                                        alVideoStreams.unshift(streame);
                                    }
                                    else {
                                        mixed_alVideoStreams.unshift(streame);
                                    }
                                }
                                else {
                                    alVideoStreams.unshift(streame);
                                }
                            }
                            else {
                                await Promise.all(ref_participants.map(async (participant) => {
                                    let stream = alVideoStreams.find((obj) => obj.producerId == participant.videoID && participant.name == host.name);
                                    if (stream) {
                                        if (sortAudioLoudness) {
                                            mixed_alVideoStreams = mixed_alVideoStreams.filter((obj) => obj.name !== host.name);
                                            non_alVideoStreams_muted = non_alVideoStreams_muted.filter((obj) => obj.name !== host.name);
                                            mixed_alVideoStreams.unshift(participant);
                                        }
                                        else {
                                            non_alVideoStreams = non_alVideoStreams.filter((obj) => obj.name !== host.name);
                                            non_alVideoStreams.unshift(participant);
                                            return;
                                        }
                                    }
                                }));
                            }
                        }
                    }
                }
            }
            let allStreamsPaged = [];
            if (sortAudioLoudness) {
                if (meetingDisplayType === 'video') {
                    if (meetingVideoOptimized) {
                        allStreamsPaged = [...alVideoStreams];
                    }
                    else {
                        allStreamsPaged = [...mixed_alVideoStreams];
                    }
                }
                else if (meetingDisplayType === 'media') {
                    allStreamsPaged = [...mixed_alVideoStreams];
                }
                else if (meetingDisplayType === 'all') {
                    allStreamsPaged = [...mixed_alVideoStreams, ...non_alVideoStreams_muted];
                }
            }
            else {
                if (meetingDisplayType === 'video') {
                    allStreamsPaged = [...alVideoStreams];
                }
                else if (meetingDisplayType === 'media') {
                    allStreamsPaged = [...alVideoStreams, ...non_alVideoStreams];
                }
                else if (meetingDisplayType === 'all') {
                    allStreamsPaged = [...alVideoStreams, ...non_alVideoStreams, ...non_alVideoStreams_muted];
                }
            }
            paginatedStreams = [];
            let limit = itemPageLimit;
            if (shareScreenStarted || shared) {
                limit = screenPageLimit;
            }
            let firstPage = [];
            let page = [];
            let limit_ = limit + 1;
            if (eventType === 'conference' && !shared && !shareScreenStarted) {
                limit_ = limit_ - 1;
            }
            // Create pagination
            let memberInRoom = false;
            let filterHost = false;
            if (breakOutRoomStarted && !breakOutRoomEnded) {
                let tempBreakoutRooms = JSON.parse(JSON.stringify(breakoutRooms));
                let host = participants.find((obj) => obj.islevel == '2');
                for (let room of tempBreakoutRooms) {
                    try {
                        let currentStreams = [];
                        const roomIndex = tempBreakoutRooms.indexOf(room);
                        if (hostNewRoom != -1 && roomIndex == hostNewRoom) {
                            if (host) {
                                if (!room.map((obj) => obj.name).includes(host.name)) {
                                    room = [...room, { name: host.name, breakRoom: roomIndex }];
                                    filterHost = true;
                                }
                            }
                        }
                        for (let participant of room) {
                            if (participant.name == member && !memberInRoom) {
                                memberInRoom = true;
                                memberRoom = participant.breakRoom;
                                updateMemberRoom(memberRoom);
                            }
                            let streams = allStreamsPaged.filter((stream) => {
                                if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                                    stream.producerId != null &&
                                    stream.producerId !== '') ||
                                    (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                        stream['audioID'] != null &&
                                        stream['audioID'] !== '')) {
                                    let producerId = stream.producerId || stream['audioID'];
                                    let matchingParticipant = ref_participants.find((obj) => obj['audioID'] === producerId ||
                                        obj.videoID === producerId ||
                                        ((producerId == 'youyou' || producerId == 'youyouyou') &&
                                            member == participant.name));
                                    return ((matchingParticipant && matchingParticipant.name === participant.name) ||
                                        (participant.name == member &&
                                            (producerId == 'youyou' || producerId == 'youyouyou')));
                                }
                                else {
                                    return (Object.prototype.hasOwnProperty.call(stream, 'name') &&
                                        stream.name == participant.name);
                                }
                            });
                            for (let stream of streams) {
                                if (currentStreams.length < limit_) {
                                    currentStreams.push(stream);
                                }
                            }
                        }
                        paginatedStreams.push(currentStreams);
                    }
                    catch {
                        /* handle error */
                    }
                }
                let remainingStreams = allStreamsPaged.filter((stream) => {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                        stream.producerId != null &&
                        stream.producerId !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                            stream['audioID'] != null &&
                            stream['audioID'] !== '')) {
                        let producerId = stream.producerId || stream['audioID'];
                        let matchingParticipant = ref_participants.find((obj) => obj['audioID'] === producerId ||
                            obj.videoID === producerId ||
                            ((producerId == 'youyou' || producerId == 'youyouyou') && member == obj.name));
                        return (matchingParticipant &&
                            !breakoutRooms
                                .flat()
                                .map((obj) => obj.name)
                                .includes(matchingParticipant.name) &&
                            (!filterHost || matchingParticipant.name != host?.name));
                    }
                    else {
                        return (!breakoutRooms
                            .flat()
                            .map((obj) => obj.name)
                            .includes(stream.name ?? '') &&
                            (!filterHost || stream.name != host?.name));
                    }
                });
                if (memberInRoom) {
                    let memberStream = allStreamsPaged.find((stream) => {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            return stream.producerId == 'youyou' || stream.producerId == 'youyouyou';
                        }
                        return false; // Add a return statement here
                    });
                    if (memberStream && !remainingStreams.includes(memberStream)) {
                        remainingStreams.unshift(memberStream);
                    }
                }
                let remainingPaginatedStreams = [];
                if (remainingStreams.length > 0) {
                    firstPage = remainingStreams.slice(0, limit_);
                    remainingPaginatedStreams.push(firstPage);
                    for (let i = limit_; i < remainingStreams.length; i += limit) {
                        page = remainingStreams.slice(i, i + limit);
                        remainingPaginatedStreams.push(page);
                    }
                }
                mainRoomsLength = remainingPaginatedStreams.length;
                updateMainRoomsLength(mainRoomsLength);
                // Add the remaining streams to the beginning of the paginatedStreams
                for (let i = remainingPaginatedStreams.length - 1; i >= 0; i--) {
                    paginatedStreams.unshift(remainingPaginatedStreams[i]);
                }
            }
            else {
                firstPage = allStreamsPaged.slice(0, limit_);
                paginatedStreams.push(firstPage);
                for (let i = limit_; i < allStreamsPaged.length; i += limit) {
                    page = allStreamsPaged.slice(i, i + limit);
                    paginatedStreams.push(page);
                }
            }
            // State updates
            updateP_activeNames(p_activeNames);
            updateActiveNames(activeNames);
            updateDispActiveNames(dispActiveNames);
            updateNewLimitedStreams(newLimitedStreams);
            updateNon_alVideoStreams(non_alVideoStreams);
            updateRef_participants(ref_participants);
            updateSortAudioLoudness(sortAudioLoudness);
            updateMixed_alVideoStreams(mixed_alVideoStreams);
            updateNon_alVideoStreams_muted(non_alVideoStreams_muted);
            updatePaginatedStreams(paginatedStreams);
            prevDoPaginate = doPaginate;
            doPaginate = false;
            updatePrevDoPaginate(prevDoPaginate);
            updateDoPaginate(doPaginate);
            let isActive = false;
            if (paginatedStreams.length > 1) {
                if (!shareScreenStarted && !shared) {
                    doPaginate = true;
                }
                updateDoPaginate(doPaginate);
                if (currentUserPage > paginatedStreams.length - 1) {
                    if (breakOutRoomStarted && !breakOutRoomEnded) {
                        currentUserPage = 0;
                    }
                    else {
                        currentUserPage = paginatedStreams.length - 1;
                    }
                }
                else if (currentUserPage == 0) {
                    isActive = true;
                }
                updateCurrentUserPage(currentUserPage);
                updateNumberPages(paginatedStreams.length - 1);
                if (screenChanged) {
                    await dispStreams({
                        lStreams: paginatedStreams[0],
                        ind: 0,
                        parameters,
                    });
                }
                else {
                    await dispStreams({
                        lStreams: paginatedStreams[0],
                        ind: 0,
                        auto: true,
                        parameters,
                    });
                }
                if (!isActive) {
                    const currentPageBreak = currentUserPage - mainRoomsLength;
                    await dispStreams({
                        lStreams: paginatedStreams[currentUserPage],
                        ind: currentUserPage,
                        parameters,
                        breakRoom: currentPageBreak,
                        inBreakRoom: currentPageBreak >= 0,
                    });
                }
            }
            else {
                currentUserPage = 0;
                updateCurrentUserPage(currentUserPage);
                if (screenChanged) {
                    await dispStreams({
                        lStreams: paginatedStreams[0],
                        ind: 0,
                        parameters,
                    });
                }
                else {
                    await dispStreams({
                        lStreams: paginatedStreams[0],
                        ind: 0,
                        auto: true,
                        parameters,
                    });
                }
            }
        }
        catch (error) {
            console.log('changeVids error', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ChangeVids, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ChangeVids, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ChangeVids, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CompareActiveNames {
    /**
     * Compares the current active names with the previous active names and triggers an action if there are changes.
     *
     * @param {Object} options - The options for comparing active names.
     * @param {boolean} [options.restart=false] - Whether to restart the comparison.
     * @param {CompareActiveNamesOptions} options.parameters - The parameters for the comparison.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {string[]} options.parameters.activeNames - The current active names.
     * @param {string[]} options.parameters.prevActiveNames - The previous active names.
     * @param {Function} options.parameters.updatePrevActiveNames - Function to update the previous active names.
     * @param {Function} options.parameters.trigger - Function to trigger an action when names change.
     *
     * @returns {Promise<void>} A promise that resolves when the comparison is complete.
     *
     * @throws Will log an error message if an error occurs during the comparison.
     */
    async compareActiveNames({ restart = false, parameters, }) {
        try {
            let { getUpdatedAllParams } = parameters;
            parameters = getUpdatedAllParams();
            let { activeNames, prevActiveNames, updatePrevActiveNames, trigger } = parameters;
            // Restart the comparison if needed
            if (restart) {
                await trigger({ ref_ActiveNames: activeNames, parameters });
                return;
            }
            // Array to track changes in activeNames
            let nameChanged = [];
            // Compare each name in activeNames
            for (let i = 0; i < activeNames.length; i++) {
                const currentName = activeNames[i];
                // Check if the name is present in prevActiveNames
                const hasNameChanged = !prevActiveNames.includes(currentName);
                if (hasNameChanged) {
                    nameChanged.push(true);
                    trigger({ ref_ActiveNames: activeNames, parameters });
                    break;
                }
            }
            // Count the number of true in nameChanged
            let count = nameChanged.filter((value) => value === true).length;
            if (count < 1) {
                // Check for new names in prevActiveNames
                for (let i = 0; i < prevActiveNames.length; i++) {
                    const currentName = prevActiveNames[i];
                    // Check if the name is present in activeNames
                    const hasNameChanged = !activeNames.includes(currentName);
                    // Signal change if the name is new
                    if (hasNameChanged) {
                        trigger({ ref_ActiveNames: activeNames, parameters });
                        break;
                    }
                }
            }
            // Update prevActiveNames with current activeNames
            prevActiveNames = [...activeNames];
            updatePrevActiveNames(prevActiveNames);
        }
        catch (error) {
            console.log('compareActiveNames error', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CompareActiveNames, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CompareActiveNames, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CompareActiveNames, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CompareScreenStates {
    /**
     * Compares the current screen states with the previous screen states and triggers actions based on changes.
     *
     * @param {Object} options - The options for comparing screen states.
     * @param {boolean} [options.restart=false] - Whether to restart the comparison process.
     * @param {CompareScreenStatesOptions} options.parameters - The parameters for the comparison.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {string} options.parameters.recordingDisplayType - The type of display being recorded.
     * @param {boolean} options.parameters.recordingVideoOptimized - Whether the recording is optimized for video.
     * @param {Array<ScreenState>} options.parameters.screenStates - The current screen states.
     * @param {Array<ScreenState>} options.parameters.prevScreenStates - The previous screen states.
     * @param {Array<string>} options.parameters.activeNames - The active names in the current context.
     * @param {Function} options.parameters.trigger - Function to trigger actions based on changes.
     *
     * @returns {Promise<void>} A promise that resolves when the comparison and any triggered actions are complete.
     *
     * @throws Will log an error message if an error occurs during the comparison process.
     */
    async compareScreenStates({ restart = false, parameters, }) {
        try {
            let { getUpdatedAllParams } = parameters;
            parameters = getUpdatedAllParams();
            let { recordingDisplayType, recordingVideoOptimized, screenStates, prevScreenStates, activeNames, trigger, } = parameters;
            // Restart the comparison if needed
            if (restart) {
                // Perform necessary actions on restart
                return;
            }
            // Compare each key-value pair in the screenStates objects
            for (let i = 0; i < screenStates.length; i++) {
                const currentScreenState = screenStates[i];
                const prevScreenState = prevScreenStates[i];
                // Check if any value has changed
                const hasChanged = Object.keys(currentScreenState).some((key) => currentScreenState[key] !== prevScreenState[key]);
                // Signal change if any value has changed
                if (hasChanged) {
                    // Perform actions or trigger events based on the change
                    if (recordingDisplayType === 'video' && recordingVideoOptimized) {
                        await trigger({ ref_ActiveNames: activeNames, parameters });
                        break;
                    }
                    await trigger({ ref_ActiveNames: activeNames, parameters });
                    break;
                }
            }
        }
        catch (error) {
            console.log('compareScreenStates error', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CompareScreenStates, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CompareScreenStates, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CompareScreenStates, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CreateSendTransport {
    /**
     * Creates a WebRTC send transport and sets up event handlers for the transport.
     *
     * @param {CreateSendTransportOptions} options - The options for creating the send transport.
     * @param {Object} options.option - Additional options for the transport creation.
     * @param {Object} options.parameters - The parameters required for creating the transport.
     * @param {boolean} options.parameters.islevel - Indicates the level of the transport.
     * @param {string} options.parameters.member - The member name associated with the transport.
     * @param {Socket} options.parameters.socket - The socket instance for communication.
     * @param {Device} options.parameters.device - The WebRTC device instance.
     * @param {boolean} options.parameters.transportCreated - Flag indicating if the transport is created.
     * @param {Transport} options.parameters.producerTransport - The producer transport instance.
     * @param {Function} options.parameters.updateProducerTransport - Function to update the producer transport.
     * @param {Function} options.parameters.updateTransportCreated - Function to update the transport creation state.
     * @param {Function} options.parameters.connectSendTransport - Function to connect the send transport.
     * @returns {Promise<void>} A promise that resolves when the send transport is created and configured.
     *
     * @throws Will throw an error if there is an issue creating the send transport.
     */
    async createSendTransport({ option, parameters }) {
        try {
            // Destructure parameters
            let { islevel, member, device, socket, transportCreated, producerTransport, updateProducerTransport, updateTransportCreated, connectSendTransport, getUpdatedAllParams, } = parameters;
            const updatedParams = getUpdatedAllParams();
            device = updatedParams.device;
            socket = updatedParams.socket;
            // Emit createWebRtcTransport event to the server
            socket.emit('createWebRtcTransport', { consumer: false, islevel: islevel }, async ({ params }) => {
                // Check if there is an error in the response
                if (params && params.error) {
                    return;
                }
                // Create a WebRTC send transport
                if (device) {
                    producerTransport = device.createSendTransport(params);
                }
                else {
                    throw new Error('Device is null');
                }
                updateProducerTransport(producerTransport);
                // Handle 'connect' event
                producerTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
                    try {
                        socket.emit('transport-connect', {
                            dtlsParameters,
                        });
                        callback();
                    }
                    catch (error) {
                        errback(error);
                    }
                });
                // Handle 'produce' event
                producerTransport.on('produce', async (parameters, callback, errback) => {
                    try {
                        socket.emit('transport-produce', {
                            kind: parameters.kind,
                            rtpParameters: parameters.rtpParameters,
                            appData: parameters.appData,
                            islevel: islevel,
                            name: member,
                        }, ({ id }) => {
                            callback({ id });
                        });
                    }
                    catch (error) {
                        errback(error);
                    }
                });
                // Handle 'connectionstatechange' event
                producerTransport.on('connectionstatechange', (state) => {
                    switch (state) {
                        case 'connecting':
                            break;
                        case 'connected':
                            break;
                        case 'failed':
                            producerTransport?.close();
                            break;
                        default:
                            break;
                    }
                });
                // Update transport creation state
                transportCreated = true;
                await connectSendTransport({
                    option: option,
                    parameters: {
                        ...parameters,
                        producerTransport: producerTransport,
                    },
                });
                updateTransportCreated(transportCreated);
            });
        }
        catch (error) {
            // Handle errors during transport creation
            try {
                const { showAlert } = parameters;
                if (showAlert) {
                    showAlert({
                        message: 'Error creating send transport.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
            catch (innerError) {
                console.log('Error creating send transport:', innerError);
            }
            console.log('Error creating send transport:', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CreateSendTransport, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CreateSendTransport, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CreateSendTransport, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ResumeSendTransportAudio {
    /**
     * Resumes the send transport for audio and updates the UI and audio producer state accordingly.
     *
     * @param {ResumeSendTransportAudioOptions} options - The options for resuming the send transport.
     * @param {Object} options.parameters - The parameters required for resuming the send transport.
     * @param {Producer} options.parameters.audioProducer - The audio producer to be resumed.
     * @param {string} options.parameters.islevel - The level of the user.
     * @param {string} options.parameters.hostLabel - The label of the host.
     * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
     * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
     * @param {Function} options.parameters.updateAudioProducer - Function to update the audio producer state.
     * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already on.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window state.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     *
     * @returns {Promise<void>} A promise that resolves when the send transport is resumed and the UI is updated.
     *
     * @throws {Error} Throws an error if there is an issue during the process of resuming the audio send transport.
     */
    async resumeSendTransportAudio({ parameters }) {
        try {
            let { audioProducer, islevel, updateMainWindow, hostLabel, lock_screen, shared, updateAudioProducer, videoAlreadyOn, updateUpdateMainWindow, prepopulateUserMedia, } = parameters;
            // Resume send transport for audio
            audioProducer?.resume();
            // Update the UI
            if (!videoAlreadyOn && islevel === '2') {
                if (!lock_screen && !shared) {
                    updateMainWindow = true;
                    updateUpdateMainWindow(updateMainWindow);
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                    updateMainWindow = false;
                    updateUpdateMainWindow(updateMainWindow);
                }
            }
            // Update audio producer state
            updateAudioProducer(audioProducer);
        }
        catch (error) {
            // Handle errors during the process of resuming the audio send transport
            throw new Error(`Error during resuming audio send transport: ${error.message}`);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ResumeSendTransportAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ResumeSendTransportAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ResumeSendTransportAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ReceiveAllPipedTransports {
    /**
     * Receives all piped transports by emitting an event to the server and processing the response.
     *
     * @param {ReceiveAllPipedTransportsOptions} options - The options for receiving all piped transports.
     * @param {any} options.nsock - The socket instance used for communication.
     * @param {Object} options.parameters - The parameters for the operation.
     * @param {string} options.parameters.roomName - The name of the room.
     * @param {string} options.parameters.member - The member identifier.
     * @param {Function} options.parameters.getPipedProducersAlt - The function to get piped producers for a given level.
     *
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     *
     * @throws Will log an error message if the operation fails.
     */
    receiveAllPipedTransports = async ({ nsock, parameters, }) => {
        try {
            // Destructure parameters
            const { roomName, member, getPipedProducersAlt } = parameters;
            // Emit createReceiveAllTransportsPiped event to the server
            await new Promise((resolve, reject) => {
                nsock.emit('createReceiveAllTransportsPiped', { roomName, member }, async ({ producersExist }) => {
                    try {
                        // Array of options representing different levels
                        const options = ['0', '1', '2'];
                        // If producers exist, loop through each level and get producers
                        if (producersExist) {
                            for (const islevel of options) {
                                await getPipedProducersAlt({ nsock, islevel, parameters });
                            }
                        }
                        resolve();
                    }
                    catch (err) {
                        reject(err);
                    }
                });
            });
        }
        catch (error) {
            console.log('receiveAllPipedTransports error', error);
            // throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReceiveAllPipedTransports, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReceiveAllPipedTransports, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReceiveAllPipedTransports, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class DisconnectSendTransportVideo {
    /**
     * Disconnects the send transport for video, closes the video producer, and updates the state.
     *
     * @param {DisconnectSendTransportVideoOptions} parameters - The parameters required for disconnecting the send transport.
     * @param {Producer} parameters.videoProducer - The video producer to be closed.
     * @param {Socket} parameters.socket - The socket instance for communication.
     * @param {string} parameters.islevel - The participant's level.
     * @param {string} parameters.roomName - The name of the room.
     * @param {boolean} parameters.updateMainWindow - Flag to update the main window.
     * @param {boolean} parameters.lock_screen - Flag indicating if the screen is locked.
     * @param {Function} parameters.updateUpdateMainWindow - Function to update the main window state.
     * @param {Function} parameters.updateVideoProducer - Function to update the video producer state.
     * @param {Function} parameters.reorderStreams - Function to reorder streams.
     *
     * @returns {Promise<void>} - A promise that resolves when the disconnection process is complete.
     *
     * @throws {Error} - Throws an error if the disconnection process fails.
     */
    async disconnectSendTransportVideo({ parameters, }) {
        try {
            let { videoProducer, socket, islevel, roomName, lock_screen, updateMainWindow, updateUpdateMainWindow, updateVideoProducer, reorderStreams, } = parameters.getUpdatedAllParams();
            // Close the video producer and update the state
            await videoProducer.close();
            updateVideoProducer(null);
            // Notify the server about pausing video sharing
            socket.emit('pauseProducerMedia', { mediaTag: 'video', roomName });
            // Update the UI based on the participant's level and screen lock status
            if (islevel === '2') {
                updateMainWindow = true;
                updateUpdateMainWindow(updateMainWindow);
            }
            if (lock_screen) {
                await reorderStreams({ add: true, screenChanged: true, parameters });
            }
            else {
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
        catch (error) {
            // Handle errors during the disconnection process
            console.log('Error disconnecting send transport for video:', error.message);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectSendTransportVideo, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectSendTransportVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectSendTransportVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class DisconnectSendTransportAudio {
    /**
     * Disconnects the send transport for audio by pausing the audio producer and updating the UI accordingly.
     *
     * @param {DisconnectSendTransportAudioOptions} parameters - The parameters required to disconnect the send transport for audio.
     * @param {Object} parameters.audioProducer - The audio producer to be paused.
     * @param {Object} parameters.socket - The socket connection to notify the server.
     * @param {boolean} parameters.videoAlreadyOn - Flag indicating if the video is already on.
     * @param {string} parameters.islevel - The level of the user.
     * @param {boolean} parameters.lock_screen - Flag indicating if the screen is locked.
     * @param {boolean} parameters.shared - Flag indicating if the screen is shared.
     * @param {Function} parameters.updateMainWindow - Function to update the main window state.
     * @param {string} parameters.hostLabel - The label of the host.
     * @param {string} parameters.roomName - The name of the room.
     * @param {Function} parameters.updateAudioProducer - Function to update the audio producer state.
     * @param {Function} parameters.updateUpdateMainWindow - Function to update the main window update state.
     * @param {Function} parameters.prepopulateUserMedia - Function to prepopulate user media.
     *
     * @returns {Promise<void>} A promise that resolves when the send transport for audio is disconnected.
     *
     * @throws Will throw an error if the operation fails.
     */
    async disconnectSendTransportAudio({ parameters, }) {
        try {
            // Destructure parameters
            let { audioProducer, socket, videoAlreadyOn, islevel, lock_screen, shared, updateMainWindow, hostLabel, roomName, updateAudioProducer, updateUpdateMainWindow, prepopulateUserMedia, } = parameters;
            // Pause the audio producer
            audioProducer?.pause(); // actual logic is to close (await audioProducer.close()) but mediaSFU prefers pause if recording
            updateAudioProducer(audioProducer);
            // Update the UI
            if (!videoAlreadyOn && islevel === '2') {
                if (!lock_screen && !shared) {
                    updateMainWindow = true;
                    updateUpdateMainWindow(updateMainWindow);
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                    updateMainWindow = false;
                    updateUpdateMainWindow(updateMainWindow);
                }
            }
            // Notify the server about pausing audio producer
            socket.emit('pauseProducerMedia', { mediaTag: 'audio', roomName: roomName });
        }
        catch (error) {
            console.error('disconnectSendTransportAudio error', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectSendTransportAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectSendTransportAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectSendTransportAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class DisconnectSendTransportScreen {
    /**
     * Disconnects the send transport for screen sharing.
     *
     * This function closes the screen producer, updates the state, and notifies the server
     * about the closure and pausing of screen sharing.
     *
     * @param {DisconnectSendTransportScreenOptions} options - The options for disconnecting the send transport.
     * @param {Object} options.parameters - The parameters required for disconnection.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {Object} options.parameters.screenProducer - The screen producer to be closed.
     * @param {Object} options.parameters.socket - The socket connection to notify the server.
     * @param {string} options.parameters.roomName - The name of the room.
     * @param {Function} options.parameters.updateScreenProducer - Function to update the screen producer state.
     * @returns {Promise<void>} A promise that resolves when the disconnection process is complete.
     * @throws {Error} If an error occurs during the disconnection process.
     */
    async disconnectSendTransportScreen({ parameters, }) {
        try {
            // Destructure parameters
            let { screenProducer, socket, roomName, updateScreenProducer } = parameters.getUpdatedAllParams();
            // Close the screen producer and update the state
            screenProducer?.close();
            updateScreenProducer(screenProducer);
            // Notify the server about closing the screen producer and pausing screen sharing
            socket.emit('closeScreenProducer');
            socket.emit('pauseProducerMedia', { mediaTag: 'screen', roomName });
        }
        catch (error) {
            // Handle errors during the disconnection process
            console.log('Error disconnecting send transport for screen:', error.message);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectSendTransportScreen, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectSendTransportScreen, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectSendTransportScreen, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ConnectSendTransport {
    /**
     * Connects the send transport based on the specified option.
     *
     * @param {ConnectSendTransportOptions} options - The options for connecting the send transport.
     * @param {string} options.option - The type of transport to connect ("audio", "video", "screen", or both).
     * @param {Object} options.parameters - The parameters required for connecting the transport.
     * @param {Object} options.parameters.audioParams - The audio parameters.
     * @param {Object} options.parameters.videoParams - The video parameters.
     * @param {MediaStream} options.parameters.localStreamScreen - The local screen stream.
     * @param {MediaStream} options.parameters.canvasStream - The canvas stream.
     * @param {boolean} options.parameters.whiteboardStarted - Indicates if the whiteboard has started.
     * @param {boolean} options.parameters.whiteboardEnded - Indicates if the whiteboard has ended.
     * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
     * @param {string} options.parameters.islevel - The level of the screen sharing.
     * @param {Function} options.parameters.connectSendTransportAudio - Function to connect the audio send transport.
     * @param {Function} options.parameters.connectSendTransportVideo - Function to connect the video send transport.
     * @param {Function} options.parameters.connectSendTransportScreen - Function to connect the screen send transport.
     *
     * @returns {Promise<void>} A promise that resolves when the transport is connected.
     *
     * @throws Will throw an error if the connection fails.
     */
    async connectSendTransport({ option, parameters }) {
        try {
            const { audioParams, videoParams, localStreamScreen, canvasStream, whiteboardStarted, whiteboardEnded, shared, islevel, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, } = parameters;
            // Connect send transport based on the specified option
            if (option === 'audio') {
                await connectSendTransportAudio({
                    audioParams,
                    parameters,
                });
            }
            else if (option === 'video') {
                await connectSendTransportVideo({
                    videoParams,
                    parameters,
                });
            }
            else if (option === 'screen') {
                if (whiteboardStarted && !whiteboardEnded && canvasStream && islevel === '2' && !shared) {
                    await connectSendTransportScreen({
                        stream: canvasStream,
                        parameters,
                    });
                }
                else {
                    if (localStreamScreen) {
                        await connectSendTransportScreen({
                            stream: localStreamScreen,
                            parameters,
                        });
                    }
                    else {
                        throw new Error('localStreamScreen is null or undefined');
                    }
                }
            }
            else {
                // Connect both audio and video send transports
                await connectSendTransportAudio({
                    audioParams,
                    parameters,
                });
                await connectSendTransportVideo({
                    videoParams,
                    parameters,
                });
            }
        }
        catch (error) {
            console.log('connectSendTransport error', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransport, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransport, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectSendTransport, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// piped-producers.service.ts
class GetPipedProducersAlt {
    /**
     * Retrieves piped producers and signals new consumer transport for each retrieved producer.
     *
     * @param {Object} options - The options for retrieving piped producers.
     * @param {WebSocket} options.nsock - The WebSocket instance used for communication.
     * @param {boolean} options.islevel - A flag indicating the level of the request.
     * @param {Object} options.parameters - Additional parameters for the request.
     * @param {string} options.parameters.member - The member identifier.
     * @param {Function} options.parameters.signalNewConsumerTransport - A function to signal new consumer transport.
     *
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     *
     * @throws {Error} If an error occurs during the process of retrieving producers.
     */
    async getPipedProducersAlt({ nsock, islevel, parameters, }) {
        try {
            // Destructure parameters
            const { member, signalNewConsumerTransport } = parameters;
            // Emit request to get piped producers using WebSocket
            nsock.emit('getProducersPipedAlt', { islevel, member }, async (producerIds) => {
                // Check if producers are retrieved
                if (producerIds.length > 0) {
                    // Signal new consumer transport for each retrieved producer
                    for (const id of producerIds) {
                        await signalNewConsumerTransport({ nsock, remoteProducerId: id, islevel, parameters });
                    }
                }
            });
        }
        catch (error) {
            // Handle errors during the process of retrieving producers
            console.log('Error getting piped producers:', error.message);
            // throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetPipedProducersAlt, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetPipedProducersAlt, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetPipedProducersAlt, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ConnectRecvTransport {
    /**
     * Connects the receiving transport to consume media from a remote producer.
     *
     * @param {Object} options - The options for connecting the receiving transport.
     * @param {Transport} options.consumerTransport - The transport used for consuming media.
     * @param {string} options.remoteProducerId - The ID of the remote producer.
     * @param {string} options.serverConsumerTransportId - The ID of the server consumer transport.
     * @param {Socket} options.nsock - The socket used for communication.
     * @param {ConnectRecvTransportOptions} options.parameters - The parameters for the connection.
     *
     * @returns {Promise<void>} A promise that resolves when the connection is established.
     *
     * @throws Will throw an error if the connection or consumption fails.
     *
     * @example
     * ```typescript
     * const options = {
     *   consumerTransport,
     *   remoteProducerId: 'producer-id',
     *   serverConsumerTransportId: 'transport-id',
     *   nsock: socket,
     *   parameters: connectRecvTransportOptions,
     * };
     *
     * connectRecvTransport(options)
     *   .then(() => {
     *     console.log('Transport connected and consuming media');
     *   })
     *   .catch((error) => {
     *     console.error('Error connecting transport:', error);
     *   });
     * ```
     */
    connectRecvTransport = async ({ consumerTransport, remoteProducerId, serverConsumerTransportId, nsock, parameters, }) => {
        try {
            parameters = parameters.getUpdatedAllParams();
            const { device, consumerTransports, updateConsumerTransports, consumerResume } = parameters;
            // Emit 'consume' event to signal consumption initiation
            nsock.emit('consume', {
                rtpCapabilities: device ? device.rtpCapabilities : null,
                remoteProducerId,
                serverConsumerTransportId,
            }, async ({ params }) => {
                if (params.error) {
                    // Handle error
                    console.log('consume error', params.error);
                    return;
                }
                try {
                    // Consume media using received parameters
                    const consumer = await consumerTransport.consume({
                        id: params.id,
                        producerId: params.producerId,
                        kind: params.kind,
                        rtpParameters: params.rtpParameters,
                    });
                    // Update consumerTransports array with the new consumer
                    consumerTransports.push({
                        consumerTransport,
                        serverConsumerTransportId: params.id,
                        producerId: remoteProducerId,
                        consumer,
                        socket_: nsock,
                    });
                    updateConsumerTransports(consumerTransports);
                    // Extract track from the consumer
                    const { track } = consumer;
                    // Emit 'consumer-resume' event to signal consumer resumption
                    nsock.emit('consumer-resume', { serverConsumerId: params.serverConsumerId }, async ({ resumed }) => {
                        if (resumed) {
                            // Consumer resumed and ready to be used
                            try {
                                await consumerResume({
                                    track,
                                    kind: params.kind,
                                    remoteProducerId,
                                    params,
                                    parameters,
                                    nsock,
                                });
                            }
                            catch (error) {
                                // Handle error
                                console.log('consumerResume error', error);
                            }
                        }
                    });
                }
                catch (error) {
                    // Handle error
                    console.log('consume error', error);
                    return;
                }
            });
        }
        catch (error) {
            // Handle error
            console.log('connectRecvTransport error', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectRecvTransport, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectRecvTransport, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectRecvTransport, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ReUpdateInter {
    /**
     * Updates the interaction state based on the provided options and parameters.
     *
     * @param {ReUpdateInterOptions} options - The options for updating the interaction.
     * @param {string} options.name - The name of the participant.
     * @param {boolean} [options.add=false] - Whether to add the participant to the interaction.
     * @param {boolean} [options.force=false] - Whether to force the update.
     * @param {number} [options.average=127] - The average value used for determining reorder intervals.
     * @param {Object} options.parameters - The parameters for updating the interaction.
     * @param {number} options.parameters.screenPageLimit - The screen page limit.
     * @param {number} options.parameters.itemPageLimit - The item page limit.
     * @param {number} options.parameters.reorderInterval - The reorder interval.
     * @param {number} options.parameters.fastReorderInterval - The fast reorder interval.
     * @param {string} options.parameters.eventType - The type of event.
     * @param {Array} options.parameters.participants - The list of participants.
     * @param {Array} options.parameters.allVideoStreams - The list of all video streams.
     * @param {boolean} options.parameters.shared - Whether the screen is shared.
     * @param {boolean} options.parameters.shareScreenStarted - Whether screen sharing has started.
     * @param {string} options.parameters.adminNameStream - The admin name stream.
     * @param {string} options.parameters.screenShareNameStream - The screen share name stream.
     * @param {boolean} options.parameters.updateMainWindow - Whether to update the main window.
     * @param {boolean} options.parameters.sortAudioLoudness - Whether to sort audio by loudness.
     * @param {number} options.parameters.lastReorderTime - The last reorder time.
     * @param {Array} options.parameters.newLimitedStreams - The list of new limited streams.
     * @param {Array} options.parameters.newLimitedStreamsIDs - The list of new limited stream IDs.
     * @param {Array} options.parameters.oldSoundIds - The list of old sound IDs.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
     * @param {Function} options.parameters.updateSortAudioLoudness - Function to update the audio loudness sorting.
     * @param {Function} options.parameters.updateLastReorderTime - Function to update the last reorder time.
     * @param {Function} options.parameters.updateNewLimitedStreams - Function to update the new limited streams.
     * @param {Function} options.parameters.updateNewLimitedStreamsIDs - Function to update the new limited stream IDs.
     * @param {Function} options.parameters.updateOldSoundIds - Function to update the old sound IDs.
     * @param {Function} options.parameters.onScreenChanges - Function to handle screen changes.
     * @param {Function} options.parameters.reorderStreams - Function to reorder streams.
     * @param {Function} options.parameters.changeVids - Function to change videos.
     *
     * @returns {Promise<void>} A promise that resolves when the interaction update is complete.
     */
    reUpdateInter = async ({ name, add = false, force = false, average = 127, parameters, }) => {
        let { screenPageLimit, itemPageLimit, reorderInterval, fastReorderInterval, eventType, participants, allVideoStreams, shared, shareScreenStarted, adminNameStream, screenShareNameStream, updateMainWindow, sortAudioLoudness, lastReorderTime, newLimitedStreams, newLimitedStreamsIDs, oldSoundIds, updateUpdateMainWindow, updateSortAudioLoudness, updateLastReorderTime, updateNewLimitedStreams, updateNewLimitedStreamsIDs, updateOldSoundIds, onScreenChanges, reorderStreams, changeVids, } = parameters;
        if (eventType == 'broadcast' || eventType == 'chat') {
            return;
        }
        let refLimit = screenPageLimit - 1;
        if (shareScreenStarted || shared) {
            // Do something when screen is shared or screen share is started
        }
        else {
            refLimit = itemPageLimit - 1;
            if (add) {
                const currentTime = Date.now();
                if ((currentTime - lastReorderTime >= reorderInterval && average > 128.5) ||
                    (average > 130 && currentTime - lastReorderTime >= fastReorderInterval)) {
                    lastReorderTime = currentTime;
                    sortAudioLoudness = true;
                    if (eventType == 'conference') {
                        await onScreenChanges({ changed: true, parameters });
                    }
                    else {
                        await reorderStreams({ add: false, screenChanged: true, parameters });
                    }
                    sortAudioLoudness = false;
                    updateSortAudioLoudness(sortAudioLoudness);
                    updateUpdateMainWindow(updateMainWindow);
                    updateLastReorderTime(lastReorderTime);
                    return;
                }
            }
        }
        let videoID = null;
        if (shareScreenStarted || shared) {
            if (add) {
                const participant = participants.find((p) => p.name === name);
                videoID = participant?.videoID ?? null;
                if (!videoID) {
                    return;
                }
                if (!newLimitedStreamsIDs.includes(videoID)) {
                    //first check length of newLimitedStreams to not exceed refLimit, if so remove oldSoundID from newLimitedStreams
                    if (newLimitedStreams.length > refLimit) {
                        let oldoldSounds = [...oldSoundIds];
                        for (let i = 0; i < oldSoundIds.length; i++) {
                            if (newLimitedStreams.length > refLimit) {
                                // remove stream from newLimitedStreams
                                if (newLimitedStreams.length < screenPageLimit) {
                                    return;
                                }
                                const currentId = oldSoundIds[i];
                                if (currentId !== screenShareNameStream && currentId !== adminNameStream) {
                                    newLimitedStreams = newLimitedStreams.filter((stream) => stream.producerId !== currentId);
                                    newLimitedStreamsIDs = newLimitedStreamsIDs.filter((id) => id !== currentId);
                                    oldoldSounds = oldoldSounds.filter((id) => id !== currentId);
                                }
                            }
                        }
                        oldSoundIds = [...oldoldSounds];
                    }
                    const stream = allVideoStreams.find((s) => s.producerId === videoID);
                    if (stream && newLimitedStreams.length < screenPageLimit) {
                        newLimitedStreams.push(stream);
                        newLimitedStreamsIDs.push(videoID);
                        if (!oldSoundIds.includes(name)) {
                            oldSoundIds.push(name);
                        }
                        await changeVids({ screenChanged: true, parameters });
                    }
                }
            }
            else {
                if (!force) {
                    try {
                        // remove stream from newLimitedStreams
                        if (newLimitedStreams.length < screenPageLimit) {
                            return;
                        }
                        newLimitedStreams = newLimitedStreams.filter((stream) => stream.producerId != videoID);
                        newLimitedStreamsIDs = newLimitedStreamsIDs.filter((id) => id !== videoID);
                        oldSoundIds = oldSoundIds.filter((id) => id !== name);
                        await changeVids({ parameters });
                    }
                    catch {
                        /* handle error */
                    }
                }
                else {
                    const participant = participants.find((p) => p.name === name);
                    if (participant?.muted) {
                        try {
                            newLimitedStreams = newLimitedStreams.filter((stream) => stream.producerId !== videoID);
                            newLimitedStreamsIDs = newLimitedStreamsIDs.filter((id) => id !== videoID);
                            oldSoundIds = oldSoundIds.filter((id) => id !== name);
                            await changeVids({ parameters });
                        }
                        catch {
                            /* handle error */
                        }
                    }
                }
            }
            updateNewLimitedStreams(newLimitedStreams);
            updateNewLimitedStreamsIDs(newLimitedStreamsIDs);
            updateOldSoundIds(oldSoundIds);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReUpdateInter, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReUpdateInter, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReUpdateInter, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class UpdateParticipantAudioDecibels {
    /**
     * Updates the audio decibels for a participant.
     *
     * @param {Object} options - The options for updating participant audio decibels.
     * @param {string} options.name - The name of the participant.
     * @param {number} options.averageLoudness - The average loudness of the participant.
     * @param {Array<{ name: string, averageLoudness: number }>} options.audioDecibels - The array of audio decibels entries.
     * @param {Function} options.updateAudioDecibels - The function to update the audio decibels array.
     *
     * @returns {void}
     */
    updateParticipantAudioDecibels({ name, averageLoudness, audioDecibels, updateAudioDecibels, }) {
        // Function to update the audioDecibels array
        // Check if the entry already exists in audioDecibels
        const existingEntry = audioDecibels.find((entry) => entry.name === name);
        if (existingEntry) {
            // Entry exists, update the averageLoudness
            existingEntry.averageLoudness = averageLoudness;
        }
        else {
            // Entry doesn't exist, add a new entry to audioDecibels
            audioDecibels.push({ name, averageLoudness });
        }
        // Update the audioDecibels array
        updateAudioDecibels(audioDecibels);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateParticipantAudioDecibels, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateParticipantAudioDecibels, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateParticipantAudioDecibels, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CloseAndResize {
    /**
     * Closes and resizes the video and audio elements based on the provided options.
     *
     * @param {CloseAndResizeOptions} options - The options for closing and resizing.
     * @param {string} options.producerId - The ID of the producer.
     * @param {string} options.kind - The kind of media (audio, video, screenshare, or screen).
     * @param {object} options.parameters - The parameters for the operation.
     * @param {function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {Array} options.parameters.allAudioStreams - Array of all audio streams.
     * @param {Array} options.parameters.allVideoStreams - Array of all video streams.
     * @param {Array} options.parameters.activeNames - Array of active participant names.
     * @param {Array} options.parameters.participants - Array of participants.
     * @param {Array} options.parameters.streamNames - Array of stream names.
     * @param {string} options.parameters.recordingDisplayType - Type of recording display.
     * @param {boolean} options.parameters.recordingVideoOptimized - Whether recording is video optimized.
     * @param {string} options.parameters.adminIDStream - ID of the admin stream.
     * @param {Array} options.parameters.newLimitedStreams - Array of new limited streams.
     * @param {Array} options.parameters.newLimitedStreamsIDs - Array of new limited stream IDs.
     * @param {Array} options.parameters.oldAllStreams - Array of old all streams.
     * @param {boolean} options.parameters.shareScreenStarted - Whether screen sharing has started.
     * @param {boolean} options.parameters.shared - Whether sharing is active.
     * @param {string} options.parameters.meetingDisplayType - Type of meeting display.
     * @param {boolean} options.parameters.defer_receive - Whether to defer receiving.
     * @param {boolean} options.parameters.lock_screen - Whether the screen is locked.
     * @param {boolean} options.parameters.firstAll - Whether it is the first all.
     * @param {boolean} options.parameters.first_round - Whether it is the first round.
     * @param {boolean} options.parameters.gotAllVids - Whether all videos are received.
     * @param {string} options.parameters.eventType - Type of event.
     * @param {string} options.parameters.hostLabel - Label of the host.
     * @param {boolean} options.parameters.shareEnded - Whether sharing has ended.
     * @param {boolean} options.parameters.updateMainWindow - Whether to update the main window.
     * @param {function} options.parameters.updateActiveNames - Function to update active names.
     * @param {function} options.parameters.updateAllAudioStreams - Function to update all audio streams.
     * @param {function} options.parameters.updateAllVideoStreams - Function to update all video streams.
     * @param {function} options.parameters.updateShareScreenStarted - Function to update share screen started status.
     * @param {function} options.parameters.updateUpdateMainWindow - Function to update main window status.
     * @param {function} options.parameters.updateNewLimitedStreams - Function to update new limited streams.
     * @param {function} options.parameters.updateOldAllStreams - Function to update old all streams.
     * @param {function} options.parameters.updateDefer_receive - Function to update defer receive status.
     * @param {function} options.parameters.updateMainHeightWidth - Function to update main height and width.
     * @param {function} options.parameters.updateShareEnded - Function to update share ended status.
     * @param {function} options.parameters.updateLock_screen - Function to update lock screen status.
     * @param {function} options.parameters.updateFirstAll - Function to update first all status.
     * @param {function} options.parameters.updateFirst_round - Function to update first round status.
     * @param {function} options.parameters.reorderStreams - Function to reorder streams.
     * @param {function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @param {function} options.parameters.getVideos - Function to get videos.
     * @param {function} options.parameters.rePort - Function to report.
     *
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     */
    closeAndResize = async ({ producerId, kind, parameters, }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { allAudioStreams, allVideoStreams, activeNames, participants, streamNames, recordingDisplayType, recordingVideoOptimized, adminIDStream, newLimitedStreams, newLimitedStreamsIDs, oldAllStreams, shareScreenStarted, shared, meetingDisplayType, defer_receive, lock_screen, firstAll, first_round, gotAllVids, eventType, hostLabel, shareEnded, updateMainWindow, updateActiveNames, updateAllAudioStreams, updateAllVideoStreams, updateShareScreenStarted, updateUpdateMainWindow, updateNewLimitedStreams, updateOldAllStreams, updateDefer_receive, updateMainHeightWidth, updateShareEnded, updateLock_screen, updateFirstAll, updateFirst_round, 
        //mediasfu functions
        reorderStreams, prepopulateUserMedia, getVideos, rePort, } = parameters;
        //function to close and resize the video and audio elements
        let participant;
        if (kind === 'audio') {
            //stop the audio by removing the miniAudio with id = producerId
            //remove the audio from the allAudioStreams array
            allAudioStreams = allAudioStreams.filter(function (audioStream) {
                return audioStream.producerId !== producerId;
            });
            updateAllAudioStreams(allAudioStreams);
            if (recordingDisplayType == 'video' && recordingVideoOptimized == true) {
                // do nothing
            }
            else {
                //get the name of the participant with the producerId
                participant = participants.find((obj) => obj.audioID === producerId);
                if (participant) {
                    //check if the participants videoID is not null or ""
                    if (participant.videoID !== null && participant.videoID !== '') {
                        // do nothing
                    }
                    else {
                        //remove the participant from the activeNames array
                        activeNames = activeNames.filter(function (name) {
                            return name !== participant?.name;
                        });
                        updateActiveNames(activeNames);
                    }
                }
            }
            let checker = false;
            let alt_checker = false;
            if (meetingDisplayType == 'video' && participant) {
                checker =
                    participant[0].videoID != null &&
                        participant[0].videoID != '' &&
                        participant[0].videoID != undefined;
            }
            else {
                checker = true;
                alt_checker = true;
            }
            if (checker) {
                if (shareScreenStarted || shared) {
                    if (!alt_checker) {
                        await reorderStreams({ parameters });
                    }
                }
                else {
                    if (alt_checker && meetingDisplayType != 'video') {
                        await reorderStreams({ add: false, screenChanged: true, parameters });
                    }
                }
            }
        }
        else if (kind === 'video') {
            //update the video elements by removing the miniVideo with id = producerId
            //remove the video from the allVideoStreams array
            //check if producerId == adminidstream
            if (producerId == adminIDStream) {
                updateMainWindow = true;
                updateUpdateMainWindow(updateMainWindow);
            }
            try {
                allVideoStreams = allVideoStreams.filter(function (videoStream) {
                    return videoStream.producerId !== producerId;
                });
                updateAllVideoStreams(allVideoStreams);
                try {
                    //try remove it from oldVideoStreams
                    oldAllStreams = oldAllStreams.filter(function (videoStream) {
                        return videoStream.producerId !== producerId;
                    });
                    updateOldAllStreams(oldAllStreams);
                }
                catch {
                    /* handle error */
                }
                try {
                    //try remove it from newLimitedStreams
                    newLimitedStreams = newLimitedStreams.filter(function (videoStream) {
                        return videoStream.producerId !== producerId;
                    });
                    updateNewLimitedStreams(newLimitedStreams);
                }
                catch {
                    /* handle error */
                }
            }
            catch (error) {
                try {
                    //try remove it from oldVideoStreams
                    oldAllStreams = oldAllStreams.filter(function (videoStream) {
                        return videoStream.producerId !== producerId;
                    });
                    updateOldAllStreams(oldAllStreams);
                }
                catch {
                    /* handle error */
                }
            }
            try {
                //remove the participant from activeNames
                activeNames = activeNames.filter(function (name) {
                    //get the participant with the producerId
                    let participant = streamNames.find((obj) => obj.producerId === producerId);
                    return name !== (participant?.name ?? '');
                });
                updateActiveNames(activeNames);
            }
            catch {
                /* handle error */
            }
            if (lock_screen) {
                defer_receive = true;
                // check if the video is the one being displayed (i.e. (newLimitedStreamsIDs))
                if (newLimitedStreamsIDs.includes(producerId)) {
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                    await reorderStreams({ add: false, screenChanged: true, parameters });
                }
            }
            else {
                await prepopulateUserMedia({ name: hostLabel, parameters });
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
        else if (kind === 'screenshare' || kind === 'screen') {
            //update the video elements by removing the mainVideo with id = producerId
            updateMainWindow = true;
            //screenshare stuff
            shareScreenStarted = false;
            shareEnded = true;
            lock_screen = false;
            firstAll = false;
            first_round = false;
            updateUpdateMainWindow(updateMainWindow);
            updateShareScreenStarted(shareScreenStarted);
            updateShareEnded(shareEnded);
            updateLock_screen(lock_screen);
            updateFirstAll(firstAll);
            updateFirst_round(first_round);
            if (!gotAllVids || defer_receive) {
                defer_receive = false;
                updateDefer_receive(defer_receive);
                await getVideos({
                    participants,
                    allVideoStreams,
                    oldAllStreams,
                    updateAllVideoStreams,
                    updateOldAllStreams,
                });
                await rePort({ parameters });
            }
            if (eventType == 'conference') {
                updateMainHeightWidth(0);
            }
            await prepopulateUserMedia({ name: hostLabel, parameters });
            await reorderStreams({ add: false, screenChanged: true, parameters });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CloseAndResize, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CloseAndResize, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CloseAndResize, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class AutoAdjust {
    /**
     * Adjusts values based on the provided options.
     *
     * @param {AutoAdjustOptions} options - The options for auto adjustment.
     * @param {number} options.n - The number of participants.
     * @param {string} options.eventType - The type of event (e.g., 'broadcast', 'chat', 'conference').
     * @param {boolean} options.shareScreenStarted - Indicates if screen sharing has started.
     * @param {boolean} options.shared - Indicates if something is shared.
     *
     * @returns {Promise<number[]>} A promise that resolves to an array containing the adjusted values.
     */
    async autoAdjust({ n, eventType, shareScreenStarted, shared, }) {
        // Default values
        let val1 = 6;
        let val2 = 12 - val1;
        // Calculate percentage values
        // Adjust values based on eventType and other conditions
        if (eventType === 'broadcast') {
            val1 = 0;
            val2 = 12 - val1;
        }
        else if (eventType === 'chat' ||
            (eventType === 'conference' && !(shareScreenStarted || shared))) {
            val1 = 12;
            val2 = 12 - val1;
        }
        else {
            if (shareScreenStarted || shared) {
                val2 = 10;
                val1 = 12 - val2;
            }
            else {
                // Adjust values based on the number of participants (n)
                if (n === 0) {
                    val1 = 1;
                    val2 = 12 - val1;
                }
                else if (n >= 1 && n < 4) {
                    val1 = 4;
                    val2 = 12 - val1;
                }
                else if (n >= 4 && n < 6) {
                    val1 = 6;
                    val2 = 12 - val1;
                }
                else if (n >= 6 && n < 9) {
                    val1 = 6;
                    val2 = 12 - val1;
                }
                else if (n >= 9 && n < 12) {
                    val1 = 6;
                    val2 = 12 - val1;
                }
                else if (n >= 12 && n < 20) {
                    val1 = 8;
                    val2 = 12 - val1;
                }
                else if (n >= 20 && n < 50) {
                    val1 = 8;
                    val2 = 12 - val1;
                }
                else {
                    val1 = 10;
                    val2 = 12 - val1;
                }
            }
        }
        // Return an array with adjusted values
        return [val1, val2];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AutoAdjust, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AutoAdjust, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AutoAdjust, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class SwitchUserVideoAlt {
    ClickVideoService;
    constructor(ClickVideoService) {
        this.ClickVideoService = ClickVideoService;
    }
    /**
     * Switches the user's video stream based on the provided video preference and other parameters.
     *
     * @param {Object} options - The options for switching the user's video.
     * @param {string} options.videoPreference - The preferred video facing mode (e.g., "user" or "environment").
     * @param {boolean} options.checkoff - A flag indicating whether to turn off the video before switching.
     * @param {SwitchUserVideoAltOptions} options.parameters - The parameters required for switching the video.
     *
     * @returns {Promise<void>} A promise that resolves when the video switching is complete.
     *
     * @throws Will throw an error if there is an issue with switching the video.
     */
    async switchUserVideoAlt({ videoPreference, checkoff, parameters, }) {
        let { getUpdatedAllParams } = parameters;
        let parameters_ = getUpdatedAllParams();
        let { audioOnlyRoom, frameRate, vidCons, showAlert, hasCameraPermission, updateVideoSwitching, updateCurrentFacingMode, 
        // mediasfu functions
        requestPermissionCamera, streamSuccessVideo, sleep, checkMediaPermission, } = parameters;
        let { currentFacingMode, prevFacingMode } = parameters_;
        try {
            // Check if it's an audio-only room
            if (audioOnlyRoom) {
                showAlert?.({
                    message: 'You cannot turn on your camera in an audio-only event.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            // If checkoff is not true, trigger a click on the video button to turn off the video
            if (!checkoff) {
                await this.ClickVideoService.clickVideo({ parameters });
                updateVideoSwitching(true);
                await sleep({ ms: 500 });
                updateVideoSwitching(false);
            }
            // Check camera permission
            if (!hasCameraPermission) {
                if (checkMediaPermission) {
                    let statusCamera = await requestPermissionCamera();
                    if (statusCamera !== 'granted') {
                        showAlert?.({
                            message: 'Allow access to your camera or check if your camera is not being used by another application.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                }
            }
            // Enumerate video devices
            const videoDevices = await navigator.mediaDevices.enumerateDevices();
            // Define media constraints based on preferences and options
            let mediaConstraints = {};
            if (vidCons && vidCons.width && vidCons.height) {
                mediaConstraints = {
                    video: {
                        facingMode: { exact: videoPreference },
                        ...vidCons,
                        frameRate: { ideal: frameRate },
                    },
                    audio: false,
                };
            }
            else {
                mediaConstraints = {
                    video: {
                        facingMode: { exact: videoPreference },
                        frameRate: { ideal: frameRate },
                    },
                    audio: false,
                };
            }
            // Get user media with the defined constraints
            await navigator.mediaDevices
                .getUserMedia(mediaConstraints)
                .then(async (stream) => {
                await streamSuccessVideo({ stream, parameters });
            })
                .catch(async () => {
                let videoDevicesFront = [];
                // Filter video devices based on the preferred facing mode
                if (videoPreference === 'user') {
                    videoDevicesFront = videoDevices.filter((device) => device.label.includes('front') && device.kind === 'videoinput');
                }
                else {
                    videoDevicesFront = videoDevices.filter((device) => device.label.includes('back') && device.kind === 'videoinput');
                }
                if (videoDevicesFront.length > 0) {
                    videoDevicesFront.forEach((device) => {
                        if (device.kind === 'videoinput') {
                            let videoDeviceId = device.deviceId;
                            // Update media constraints with the specific video device
                            if (vidCons && vidCons.width && vidCons.height) {
                                mediaConstraints = {
                                    video: {
                                        deviceId: { exact: videoDeviceId },
                                        ...vidCons,
                                        frameRate: { ideal: frameRate },
                                    },
                                    audio: false,
                                };
                            }
                            else {
                                mediaConstraints = {
                                    video: {
                                        deviceId: { exact: videoDeviceId },
                                        frameRate: { ideal: frameRate },
                                    },
                                    audio: false,
                                };
                            }
                            // Try to get user media with the new constraints
                            navigator.mediaDevices
                                .getUserMedia(mediaConstraints)
                                .then(async (stream) => {
                                await streamSuccessVideo({ stream, parameters });
                            })
                                .catch(() => {
                                // If the current video device is the last one in the list, show the error; otherwise, try the next device
                                if (videoDeviceId === videoDevicesFront[videoDevicesFront.length - 1].deviceId) {
                                    currentFacingMode = prevFacingMode;
                                    updateCurrentFacingMode(currentFacingMode);
                                    showAlert?.({
                                        message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                                        type: 'danger',
                                        duration: 3000,
                                    });
                                }
                            });
                        }
                    });
                }
                else {
                    // Show error if no compatible video devices are found
                    currentFacingMode = prevFacingMode;
                    updateCurrentFacingMode(currentFacingMode);
                    showAlert?.({
                        message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
            });
        }
        catch (error) {
            // Handle any unexpected errors
            const videoDevices = await navigator.mediaDevices.enumerateDevices();
            let videoDevicesFront = [];
            if (videoPreference === 'user') {
                videoDevicesFront = videoDevices.filter((device) => device.label.includes('front') && device.kind === 'videoinput');
            }
            else {
                videoDevicesFront = videoDevices.filter((device) => device.label.includes('back') && device.kind === 'videoinput');
            }
            let mediaConstraints = {};
            if (videoDevicesFront.length > 0) {
                videoDevicesFront.forEach((device) => {
                    if (device.kind === 'videoinput') {
                        let videoDeviceId = device.deviceId;
                        if (vidCons && vidCons.width && vidCons.height) {
                            mediaConstraints = {
                                video: {
                                    deviceId: { exact: videoDeviceId },
                                    ...vidCons,
                                    frameRate: { ideal: frameRate },
                                },
                                audio: false,
                            };
                        }
                        else {
                            mediaConstraints = {
                                video: {
                                    deviceId: { exact: videoDeviceId },
                                    frameRate: { ideal: frameRate },
                                },
                                audio: false,
                            };
                        }
                        navigator.mediaDevices
                            .getUserMedia(mediaConstraints)
                            .then(async (stream) => {
                            await streamSuccessVideo({ stream, parameters });
                        })
                            .catch(() => {
                            // If current video device is the last one in the list, show the error; otherwise, try next device
                            if (videoDeviceId === videoDevicesFront[videoDevicesFront.length - 1].deviceId) {
                                currentFacingMode = prevFacingMode;
                                updateCurrentFacingMode(currentFacingMode);
                                showAlert?.({
                                    message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                                    type: 'danger',
                                    duration: 3000,
                                });
                            }
                        });
                    }
                });
            }
            else {
                currentFacingMode = prevFacingMode;
                updateCurrentFacingMode(currentFacingMode);
                showAlert?.({
                    message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                    type: 'danger',
                    duration: 3000,
                });
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchUserVideoAlt, deps: [{ token: ClickVideo }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchUserVideoAlt, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchUserVideoAlt, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: ClickVideo }] });

class SwitchUserVideo {
    ClickVideoService;
    constructor(ClickVideoService) {
        this.ClickVideoService = ClickVideoService;
    }
    /**
     * Switches the user's video input device based on the provided options.
     *
     * @param {SwitchUserVideoOptions} options - The options for switching the user's video.
     * @param {string} options.videoPreference - The preferred video input device ID.
     * @param {boolean} options.checkoff - Flag indicating whether to turn off the video.
     * @param {Object} options.parameters - Additional parameters required for switching the video.
     * @param {boolean} options.parameters.audioOnlyRoom - Indicates if the room is audio-only.
     * @param {number} options.parameters.frameRate - The desired frame rate for the video.
     * @param {Object} options.parameters.vidCons - Video constraints such as width and height.
     * @param {string} options.parameters.prevVideoInputDevice - The previous video input device ID.
     * @param {Function} options.parameters.showAlert - Function to show alerts to the user.
     * @param {boolean} options.parameters.hasCameraPermission - Indicates if the user has camera permission.
     * @param {Function} options.parameters.updateVideoSwitching - Function to update video switching state.
     * @param {Function} options.parameters.updateUserDefaultVideoInputDevice - Function to update the default video input device.
     * @param {Function} options.parameters.requestPermissionCamera - Function to request camera permission.
     * @param {Function} options.parameters.streamSuccessVideo - Function to handle successful video stream.
     * @param {Function} options.parameters.sleep - Function to pause execution for a specified duration.
     * @param {Function} options.parameters.checkMediaPermission - Function to check media permissions.
     *
     * @returns {Promise<void>} A promise that resolves when the video input device has been switched.
     *
     * @throws Will throw an error if switching the video input device fails.
     */
    switchUserVideo = async ({ videoPreference, checkoff, parameters, }) => {
        let { audioOnlyRoom, frameRate, vidCons, prevVideoInputDevice, userDefaultVideoInputDevice, showAlert, hasCameraPermission, updateVideoSwitching, updateUserDefaultVideoInputDevice, 
        // mediasfu functions
        requestPermissionCamera, streamSuccessVideo, sleep, checkMediaPermission, } = parameters;
        try {
            // Check if it's an audio-only room
            if (audioOnlyRoom) {
                showAlert?.({
                    message: 'You cannot turn on your camera in an audio-only event.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            // If checkoff is not true, trigger a click on the video button to turn off the video
            if (!checkoff) {
                await this.ClickVideoService.clickVideo({ parameters });
                await updateVideoSwitching(true);
                await sleep(500);
                await updateVideoSwitching(false);
            }
            // Check camera permission
            if (!hasCameraPermission) {
                if (checkMediaPermission) {
                    let statusCamera = await requestPermissionCamera();
                    if (statusCamera !== 'granted') {
                        showAlert?.({
                            message: 'Allow access to your camera or check if your camera is not being used by another application.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                }
            }
            let mediaConstraints = {};
            if (vidCons && vidCons.width && vidCons.height) {
                mediaConstraints = {
                    video: {
                        deviceId: { exact: videoPreference },
                        ...vidCons,
                        frameRate: { ideal: frameRate },
                    },
                    audio: false,
                };
            }
            else {
                mediaConstraints = {
                    video: {
                        deviceId: { exact: videoPreference },
                        frameRate: { ideal: frameRate },
                    },
                    audio: false,
                };
            }
            // Get user media with the defined constraints
            await navigator.mediaDevices
                .getUserMedia(mediaConstraints)
                .then(async (stream) => {
                await streamSuccessVideo({ stream, parameters });
            })
                .catch(async () => {
                // Handle errors and revert to the previous video input device
                userDefaultVideoInputDevice = prevVideoInputDevice;
                updateUserDefaultVideoInputDevice(userDefaultVideoInputDevice);
                showAlert?.({
                    message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                    type: 'danger',
                    duration: 3000,
                });
            });
        }
        catch (error) {
            // Handle unexpected errors and revert to the previous video input device
            userDefaultVideoInputDevice = prevVideoInputDevice;
            updateUserDefaultVideoInputDevice(userDefaultVideoInputDevice);
            showAlert?.({
                message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                type: 'danger',
                duration: 3000,
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchUserVideo, deps: [{ token: ClickVideo }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchUserVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchUserVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: ClickVideo }] });

class SwitchUserAudio {
    /**
     * Switches the user's audio input device based on the provided audio preference.
     *
     * @param {SwitchUserAudioOptions} options - The options for switching the user's audio input device.
     * @param {string} options.audioPreference - The preferred audio input device ID.
     * @param {Object} options.parameters - Additional parameters required for switching the audio input device.
     * @param {string} options.parameters.prevAudioInputDevice - The previous audio input device ID.
     * @param {Function} options.parameters.showAlert - Function to show alert messages.
     * @param {boolean} options.parameters.hasAudioPermission - Flag indicating if the user has granted audio permission.
     * @param {Function} options.parameters.updateUserDefaultAudioInputDevice - Function to update the user's default audio input device.
     * @param {Function} options.parameters.streamSuccessAudioSwitch - Function to handle successful audio stream switch.
     * @param {Function} options.parameters.requestPermissionAudio - Function to request audio permission from the user.
     * @param {Function} options.parameters.checkMediaPermission - Function to check if media permission is granted.
     *
     * @returns {Promise<void>} A promise that resolves when the audio input device has been successfully switched.
     *
     * @throws Will throw an error if the audio input device cannot be accessed or if there is an unexpected error.
     */
    async switchUserAudio({ audioPreference, parameters }) {
        let { userDefaultAudioInputDevice, prevAudioInputDevice, showAlert, hasAudioPermission, updateUserDefaultAudioInputDevice, 
        // media functions
        streamSuccessAudioSwitch, requestPermissionAudio, checkMediaPermission, } = parameters;
        try {
            // Check if audio permission is granted
            if (!hasAudioPermission) {
                if (checkMediaPermission) {
                    let statusMic = await requestPermissionAudio();
                    if (statusMic !== 'granted') {
                        showAlert?.({
                            message: 'Allow access to your microphone or check if your microphone is not being used by another application.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                }
            }
            let mediaConstraints = {
                audio: {
                    deviceId: { exact: audioPreference },
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false,
                },
                video: false,
            };
            // Get user media with the defined audio constraints
            await navigator.mediaDevices
                .getUserMedia(mediaConstraints)
                .then(async (stream) => {
                await streamSuccessAudioSwitch({ stream, parameters });
            })
                .catch(() => {
                // Handle errors and revert to the previous audio input device
                userDefaultAudioInputDevice = prevAudioInputDevice;
                updateUserDefaultAudioInputDevice(userDefaultAudioInputDevice);
                showAlert?.({
                    message: 'Error switching; the specified microphone could not be accessed.',
                    type: 'danger',
                    duration: 3000,
                });
            });
        }
        catch (error) {
            // Handle unexpected errors and revert to the previous audio input device
            userDefaultAudioInputDevice = prevAudioInputDevice;
            updateUserDefaultAudioInputDevice(userDefaultAudioInputDevice);
            showAlert?.({
                message: 'Error switching; the specified microphone could not be accessed.',
                type: 'danger',
                duration: 3000,
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchUserAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchUserAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SwitchUserAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ReceiveRoomMessages {
    /**
     * Asynchronously retrieves and updates messages for a specified room from the server.
     *
     * @param {object} options - The function parameters.
     * @param {object} options.parameters - Additional parameters needed for the function.
     * @param {string} options.parameters.roomName - The name of the room to retrieve messages for.
     * @param {function} options.parameters.updateMessages - Function to update the messages array.
     */
    async receiveRoomMessages({ socket, roomName, updateMessages, }) {
        try {
            // Retrieve messages from the server
            await new Promise((resolve, reject) => {
                socket.emit('getMessage', { roomName }, async ({ messages_ }) => {
                    try {
                        const updatedMessages = messages_;
                        updateMessages(updatedMessages);
                        resolve();
                    }
                    catch (err) {
                        reject(err);
                    }
                });
            });
        }
        catch (error) {
            // Handle errors if any
            console.log('Error tuning messages:', error.message);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReceiveRoomMessages, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReceiveRoomMessages, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReceiveRoomMessages, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class FormatNumber {
    /**
     * Formats a number into a string representation with appropriate suffixes (K, M, B).
     *
     * @param number - The number to format.
     * @returns A promise that resolves to a formatted string or undefined if the input is falsy.
     *
     * @example
     * ```typescript
     * formatNumber(500); // "500"
     * formatNumber(1500); // "1.5K"
     * formatNumber(1500000); // "1.5M"
     * formatNumber(1500000000); // "1.5B"
     * ```
     */
    async formatNumber({ number }) {
        if (number) {
            if (number < 1e3) {
                return number.toString();
            }
            else if (number < 1e6) {
                return (number / 1e3).toFixed(1) + 'K';
            }
            else if (number < 1e9) {
                return (number / 1e6).toFixed(1) + 'M';
            }
            else if (number < 1e12) {
                return (number / 1e9).toFixed(1) + 'B';
            }
        }
        // Return undefined for falsy input values
        return undefined;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: FormatNumber, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: FormatNumber, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: FormatNumber, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class JoinConsumeRoom {
    JoinConRoomService;
    constructor(JoinConRoomService) {
        this.JoinConRoomService = JoinConRoomService;
    }
    /**
     * Joins a consumption room by sending a request to the server and handles the necessary setup.
     * @param {Object} options - The options object containing necessary variables.
     * @param {any} options.remote_sock - The remote socket information.
     * @param {string} options.apiToken - The API token for authentication.
     * @param {string} options.apiUserName - The API username for authentication.
     * @param {any} options.parameters - Additional parameters required for the function.
     * @returns {Promise<any>} - A promise that resolves with data related to the success of joining the room.
     */
    joinConsumeRoom = async ({ remote_sock, apiToken, apiUserName, parameters, }) => {
        let { roomName, islevel, member, device, updateDevice, 
        //Mediasfu functions
        receiveAllPipedTransports, createDeviceClient, } = parameters;
        try {
            // Join the consumption room
            const data = await this.JoinConRoomService.joinConRoom({
                socket: remote_sock,
                roomName,
                islevel,
                member,
                sec: apiToken,
                apiUserName,
            });
            if (data && data.success) {
                // Setup media device if not already set
                if (!device) {
                    if (data.rtpCapabilities) {
                        const device_ = await createDeviceClient({
                            rtpCapabilities: data.rtpCapabilities,
                        });
                        if (device_) {
                            updateDevice(device_);
                        }
                    }
                }
                // Receive all piped transports
                await receiveAllPipedTransports({ nsock: remote_sock, parameters });
            }
            return data;
        }
        catch (error) {
            console.log('Error in joinConsumeRoom:', error);
            throw new Error('Failed to join the consumption room or set up necessary components.');
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinConsumeRoom, deps: [{ token: JoinConRoom }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinConsumeRoom, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: JoinConsumeRoom, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: JoinConRoom }] });

class ConnectIps {
    socketManagerService;
    newPipeProducerService;
    producerClosedService;
    joinConsumeRoomService;
    constructor(socketManagerService, newPipeProducerService, producerClosedService, joinConsumeRoomService) {
        this.socketManagerService = socketManagerService;
        this.newPipeProducerService = newPipeProducerService;
        this.producerClosedService = producerClosedService;
        this.joinConsumeRoomService = joinConsumeRoomService;
    }
    /**
     * Connects to remote IPs and manages socket connections.
     *
     * @param {Object} options - The options for connecting IPs.
     * @param {Record<string, any>[]} options.consume_sockets - The array of current socket connections.
     * @param {string[]} options.remIP - The list of remote IPs to connect to.
     * @param {string} options.apiUserName - The API username for authentication.
     * @param {string} [options.apiKey] - The API key for authentication.
     * @param {string} [options.apiToken] - The API token for authentication.
     * @param {Function} [options.newProducerMethod=newPipeProducer] - The method to handle new pipe producer events.
     * @param {Function} [options.closedProducerMethod=producerClosed] - The method to handle producer closed events.
     * @param {Function} [options.joinConsumeRoomMethod=joinConsumeRoom] - The method to handle joining a consuming room.
     * @param {Object} options.parameters - Additional parameters.
     * @param {string[]} options.parameters.roomRecvIPs - The list of IPs that have been received in the room.
     * @param {Function} options.parameters.updateRoomRecvIPs - The function to update the room received IPs.
     * @param {Function} options.parameters.updateConsume_sockets - The function to update the consume sockets.
     *
     * @returns {Promise<[Record<string, any>[], string[]]>} A promise that resolves to an array containing the updated consume sockets and room received IPs.
     *
     * @throws Will throw an error if required parameters are missing or if there is an issue connecting to a remote IP.
     */
    connectIps = async ({ consume_sockets, remIP, apiUserName, apiKey = '', apiToken = '', newProducerMethod = this.newPipeProducerService.newPipeProducer, closedProducerMethod = this.producerClosedService.producerClosed, joinConsumeRoomMethod = this.joinConsumeRoomService.joinConsumeRoom, parameters, }) => {
        try {
            const { roomRecvIPs, updateRoomRecvIPs, updateConsume_sockets } = parameters;
            if (!consume_sockets || !remIP || !apiUserName || (!apiKey && !apiToken)) {
                console.log('Missing required parameters - consume_sockets, remIP, apiUserName, apiKey, apiToken');
                return [consume_sockets, roomRecvIPs];
            }
            await Promise.all(remIP.map(async (ip) => {
                try {
                    // Check if the IP is already connected
                    const matching = consume_sockets.find((socketObj) => Object.keys(socketObj)[0] == ip);
                    if (matching || !ip || ip === '' || ip === null || ip === undefined) {
                        // Skip if the IP is already connected
                        return;
                    }
                    // Connect to the remote socket using socket.io-client
                    const remote_sock = await this.socketManagerService.connectSocket({
                        apiUserName,
                        apiKey,
                        apiToken,
                        link: `https://${ip}.mediasfu.com`,
                    });
                    // Handle successful connection to the remote socket
                    if (remote_sock.id) {
                        // Check if the IP is in the roomRecvIPs, if not, add it
                        if (!roomRecvIPs.includes(ip)) {
                            roomRecvIPs.push(ip);
                            updateRoomRecvIPs(roomRecvIPs);
                        }
                        // Handle new pipe producer event
                        remote_sock.on('new-pipe-producer', async ({ producerId, islevel }) => {
                            await newProducerMethod({ producerId, islevel, nsock: remote_sock, parameters });
                        });
                        // Handle producer closed event
                        remote_sock.on('producer-closed', async ({ remoteProducerId }) => {
                            await closedProducerMethod({ remoteProducerId, parameters });
                        });
                        // Handle new consuming room by joining the room
                        const data = await joinConsumeRoomMethod({
                            remote_sock,
                            apiToken,
                            apiUserName,
                            parameters,
                        });
                        if (!data.rtpCapabilities) {
                            return;
                        }
                        // Add the remote socket to the consume_sockets array
                        consume_sockets.push({ [ip]: remote_sock });
                        updateConsume_sockets(consume_sockets);
                    }
                }
                catch (error) {
                    // Handle the error
                    console.log('connectIps error', error);
                }
            }));
            return [consume_sockets, roomRecvIPs];
        }
        catch (error) {
            // Handle the error
            console.log('connectIps error', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectIps, deps: [{ token: SocketManager }, { token: NewPipeProducer }, { token: ProducerClosed }, { token: JoinConsumeRoom }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectIps, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ConnectIps, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: SocketManager }, { type: NewPipeProducer }, { type: ProducerClosed }, { type: JoinConsumeRoom }] });

class PollUpdated {
    /**
     * Updates the poll state based on the provided data.
     *
     * @param {Object} options - The options for updating the poll.
     * @param {any} options.data - The data containing poll information.
     * @param {any[]} options.polls - The current list of polls.
     * @param {any} options.poll - The current poll.
     * @param {string} options.member - The member identifier.
     * @param {string} options.islevel - The level of the member.
     * @param {Function} options.showAlert - Function to show alerts.
     * @param {Function} options.updatePolls - Function to update the list of polls.
     * @param {Function} options.updatePoll - Function to update the current poll.
     * @param {Function} options.updateIsPollModalVisible - Function to update the visibility of the poll modal.
     * @returns {Promise<void>} A promise that resolves when the poll update is complete.
     */
    async pollUpdated({ data, polls, poll, member, islevel, showAlert, updatePolls, updatePoll, updateIsPollModalVisible, }) {
        try {
            if (data.polls) {
                polls = data.polls;
                updatePolls(data.polls);
            }
            else {
                polls = [data.poll];
                updatePolls(polls);
            }
            let temp_poll = { id: '' };
            if (poll) {
                temp_poll = { ...poll };
            }
            if (data.status != 'ended') {
                poll = data.poll;
                updatePoll(data.poll);
            }
            if (data.status === 'started' && islevel !== '2') {
                if (!poll.voters || (poll.voters && !poll.voters[member])) {
                    showAlert?.({ message: 'New poll started', type: 'success', duration: 3000 });
                    updateIsPollModalVisible(true);
                }
            }
            else if (data.status === 'ended') {
                if (temp_poll.id === data.poll.id) {
                    showAlert?.({ message: 'Poll ended', type: 'danger', duration: 3000 });
                    // update the poll
                    updatePoll(data.poll);
                }
            }
        }
        catch (error) {
            // console.log(error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PollUpdated, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PollUpdated, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PollUpdated, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class HandleCreatePoll {
    /**
     * Handles the creation of a poll.
     *
     * @param {Object} options - The options for creating the poll.
     * @param {Poll} options.poll - The poll object containing the poll details.
     * @param {Object} options.parameters - Additional parameters for creating the poll.
     * @returns {Promise<void>} - A promise that resolves when the poll is created successfully.
     */
    async handleCreatePoll({ poll, socket, roomName, showAlert, updateIsPollModalVisible, }) {
        try {
            socket.emit('createPoll', { roomName, poll }, (response) => {
                if (response.success) {
                    showAlert?.({ message: 'Poll created successfully', type: 'success' });
                    updateIsPollModalVisible(false);
                }
                else {
                    showAlert?.({ message: response.reason || 'Failed to create poll', type: 'danger' });
                }
            });
        }
        catch {
            /* handle error */
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HandleCreatePoll, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HandleCreatePoll, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HandleCreatePoll, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class HandleVotePoll {
    /**
     * Handles the voting process for a poll.
     *
     * @param {Object} options - The options for handling the vote.
     * @param {string} options.pollId - The ID of the poll.
     * @param {number} options.optionIndex - The index of the selected option.
     * @param {Socket} options.socket - The socket instance for communication.
     * @param {Function} [options.showAlert] - Optional function to show alerts.
     * @param {Object} options.member - The member who is voting.
     * @param {string} options.roomName - The name of the room where the poll is conducted.
     * @param {Function} options.updateIsPollModalVisible - Function to update the visibility of the poll modal.
     * @returns {Promise<void>} A promise that resolves when the vote is handled.
     *
     * @throws Will log an error message if there is an issue submitting the vote.
     */
    async handleVotePoll({ pollId, optionIndex, socket, showAlert, member, roomName, updateIsPollModalVisible, }) {
        try {
            socket.emit('votePoll', {
                roomName,
                poll_id: pollId,
                member,
                choice: optionIndex,
            }, (response) => {
                if (response.success) {
                    showAlert?.({ message: 'Vote submitted successfully', type: 'success' });
                    updateIsPollModalVisible(false);
                }
                else {
                    showAlert?.({ message: response.reason, type: 'danger' });
                }
            });
        }
        catch (error) {
            // console.log(error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HandleVotePoll, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HandleVotePoll, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HandleVotePoll, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class HandleEndPoll {
    /**
     * Handles the end of a poll by emitting an "endPoll" event through the provided socket.
     * Displays an alert based on the success or failure of the operation.
     *
     * @param {Object} options - The options for ending the poll.
     * @param {string} options.pollId - The ID of the poll to end.
     * @param {Socket} options.socket - The socket instance to emit the event.
     * @param {Function} [options.showAlert] - Optional function to display alerts.
     * @param {string} options.roomName - The name of the room where the poll is being conducted.
     * @returns {Promise<void>} A promise that resolves when the poll end operation is complete.
     */
    async handleEndPoll({ pollId, socket, showAlert, roomName, updateIsPollModalVisible, }) {
        try {
            socket.emit('endPoll', { roomName, poll_id: pollId }, (response) => {
                if (response.success) {
                    showAlert?.({ message: 'Poll ended successfully', type: 'success' });
                    updateIsPollModalVisible(false);
                }
                else {
                    showAlert?.({ message: response.reason || 'Failed to end poll', type: 'danger' });
                }
            });
        }
        catch (error) {
            console.log(error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HandleEndPoll, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HandleEndPoll, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HandleEndPoll, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class BreakoutRoomUpdated {
    /**
     * Updates the state of breakout rooms based on the provided data and parameters.
     *
     * @param {Object} options - The options object.
     * @param {Object} options.data - The data object containing information about the breakout rooms.
     * @param {Object} options.parameters - The parameters object containing various state update functions and other parameters.
     * @param {boolean} options.parameters.breakOutRoomStarted - Indicates if the breakout room has started.
     * @param {boolean} options.parameters.breakOutRoomEnded - Indicates if the breakout room has ended.
     * @param {Array} options.parameters.breakoutRooms - The list of current breakout rooms.
     * @param {number} options.parameters.hostNewRoom - The ID of the new room for the host.
     * @param {string} options.parameters.islevel - The level of the breakout room.
     * @param {Array} options.parameters.participantsAll - The list of all participants.
     * @param {Array} options.parameters.participants - The list of participants who are not banned.
     * @param {string} options.parameters.meetingDisplayType - The current display type of the meeting.
     * @param {string} options.parameters.prevMeetingDisplayType - The previous display type of the meeting.
     * @param {Function} options.parameters.updateBreakoutRooms - Function to update the breakout rooms.
     * @param {Function} options.parameters.updateBreakOutRoomStarted - Function to update the breakout room started state.
     * @param {Function} options.parameters.updateBreakOutRoomEnded - Function to update the breakout room ended state.
     * @param {Function} options.parameters.updateHostNewRoom - Function to update the host's new room.
     * @param {Function} options.parameters.updateMeetingDisplayType - Function to update the meeting display type.
     * @param {Function} options.parameters.updateParticipantsAll - Function to update the list of all participants.
     * @param {Function} options.parameters.updateParticipants - Function to update the list of participants who are not banned.
     * @param {Function} options.parameters.onScreenChanges - Function to handle screen changes.
     * @param {Function} options.parameters.rePort - Function to handle reporting.
     *
     * @returns {Promise<void>} A promise that resolves when the breakout room state has been updated.
     *
     * @throws Will throw an error if the update process fails.
     */
    breakoutRoomUpdated = async ({ data, parameters }) => {
        try {
            parameters = parameters.getUpdatedAllParams();
            let { breakOutRoomStarted, breakOutRoomEnded, breakoutRooms, islevel, participantsAll, participants, updateBreakoutRooms, updateBreakOutRoomStarted, updateBreakOutRoomEnded, updateHostNewRoom, updateMeetingDisplayType, meetingDisplayType, prevMeetingDisplayType, updateParticipantsAll, updateParticipants, 
            //mediaSfu functions
            onScreenChanges, rePort, } = parameters;
            if (data.forHost) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                updateHostNewRoom(data.newRoom);
                await onScreenChanges({ changed: true, parameters });
                return;
            }
            if (islevel == '2' && data.members) {
                //filter out the participant that isBanned == true
                participantsAll = data.members;
                //remove every field other than isBanned and name from participantsAll
                participantsAll = data.members.map((participant) => ({
                    isBanned: participant.isBanned,
                    name: participant.name,
                    audioID: participant.audioID,
                    videoID: participant.videoID,
                }));
                updateParticipantsAll(participantsAll);
                participants = data.members.filter((participant) => participant.isBanned == false);
                updateParticipants(participants);
            }
            breakoutRooms = data.breakoutRooms || [];
            updateBreakoutRooms(breakoutRooms);
            if (data.status == 'started' && (breakOutRoomStarted || !breakOutRoomEnded)) {
                breakOutRoomStarted = true;
                breakOutRoomEnded = false;
                updateBreakOutRoomStarted(true);
                updateBreakOutRoomEnded(false);
                prevMeetingDisplayType = meetingDisplayType;
                if (meetingDisplayType != 'all') {
                    meetingDisplayType = 'all';
                    updateMeetingDisplayType('all');
                }
                await onScreenChanges({ changed: true, parameters });
                if (islevel == '2') {
                    await rePort({ restart: true, parameters });
                }
            }
            else if (data.status == 'ended') {
                breakOutRoomEnded = true;
                updateBreakOutRoomEnded(true);
                if (meetingDisplayType != prevMeetingDisplayType) {
                    meetingDisplayType = prevMeetingDisplayType;
                    updateMeetingDisplayType(prevMeetingDisplayType);
                }
                await onScreenChanges({ changed: true, parameters });
                if (islevel == '2') {
                    await rePort({ restart: true, parameters });
                }
            }
            else if (data.status == 'started' && breakOutRoomStarted) {
                breakOutRoomStarted = true;
                breakOutRoomEnded = false;
                updateBreakOutRoomStarted(true);
                updateBreakOutRoomEnded(false);
                await onScreenChanges({ changed: true, parameters });
                if (islevel == '2') {
                    await rePort({ restart: true, parameters });
                }
            }
        }
        catch (error) {
            // console.log('Error updating breakout room:', error.message);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: BreakoutRoomUpdated, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: BreakoutRoomUpdated, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: BreakoutRoomUpdated, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// start-meeting-progress-timer.service.ts
class StartMeetingProgressTimer {
    timeProgress;
    /**
     * Starts a timer to track the progress of a meeting.
     *
     * @param {Object} options - The options for starting the meeting progress timer.
     * @param {number} options.startTime - The custom start time for the meeting progress timer.
     * @param {Object} options.parameters - The parameters required for updating the meeting progress.
     * @param {Function} options.parameters.updateMeetingProgressTime - Function to update the meeting progress time.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     *
     * @returns {void}
     */
    startMeetingProgressTimer = ({ startTime, parameters, }) => {
        let { updateMeetingProgressTime, getUpdatedAllParams } = parameters;
        const calculateElapsedTime = (startTime) => {
            const currentTime = Math.floor(new Date().getTime() / 1000);
            return currentTime - startTime;
        };
        const padNumber = (number) => {
            return number.toString().padStart(2, '0');
        };
        const formatTime = (time) => {
            const hours = Math.floor(time / 3600);
            const minutes = Math.floor((time % 3600) / 60);
            const seconds = (time % 60).toFixed(0).padStart(2, '0');
            return `${padNumber(hours)}:${padNumber(minutes)}:${padNumber(Number(seconds))}`;
        };
        let elapsedTime = calculateElapsedTime(startTime);
        this.timeProgress = setInterval(async () => {
            elapsedTime++;
            const formattedTime = formatTime(elapsedTime);
            updateMeetingProgressTime(formattedTime);
            parameters = getUpdatedAllParams();
            if (!parameters.validated || !parameters.roomName) {
                clearInterval(this.timeProgress);
                this.timeProgress = null;
            }
        }, 1000);
    };
    stopMeetingProgressTimer = () => {
        if (this.timeProgress) {
            clearInterval(this.timeProgress);
            this.timeProgress = null;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartMeetingProgressTimer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartMeetingProgressTimer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartMeetingProgressTimer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CheckPauseState {
    /**
     * Checks if the recording can be paused based on the current pause count and the allowed pause limits.
     *
     * @param {Object} options - The options for checking the pause state.
     * @param {string} options.recordingMediaOptions - The type of media being recorded ("video" or "audio").
     * @param {number} options.recordingVideoPausesLimit - The maximum number of pauses allowed for video recordings.
     * @param {number} options.recordingAudioPausesLimit - The maximum number of pauses allowed for audio recordings.
     * @param {number} options.pauseRecordCount - The current count of pauses that have been made.
     * @param {Function} options.showAlert - A function to show an alert message if the pause limit is reached.
     * @returns {Promise<boolean>} - A promise that resolves to `true` if the recording can be paused, otherwise `false`.
     */
    checkPauseState = async ({ recordingMediaOptions, recordingVideoPausesLimit, recordingAudioPausesLimit, pauseRecordCount, showAlert, }) => {
        // function to check if the user can pause recording
        let ref_limit = 0;
        if (recordingMediaOptions == 'video') {
            ref_limit = recordingVideoPausesLimit;
        }
        else {
            ref_limit = recordingAudioPausesLimit;
        }
        if (pauseRecordCount < ref_limit) {
            return true;
        }
        else {
            showAlert?.({
                message: 'You have reached the limit of pauses - you can choose to stop recording.',
                type: 'danger',
                duration: 3000,
            });
            return false;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckPauseState, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckPauseState, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckPauseState, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CheckResumeState {
    /**
     * Checks if the recording can be resumed based on the media type and pause limits.
     *
     * @param {Object} options - The options for checking resume state.
     * @param {string} options.recordingMediaOptions - The type of media being recorded ("video" or "audio").
     * @param {number} options.recordingVideoPausesLimit - The maximum number of pauses allowed for video recording.
     * @param {number} options.recordingAudioPausesLimit - The maximum number of pauses allowed for audio recording.
     * @param {number} options.pauseRecordCount - The current number of pauses that have occurred.
     * @returns {Promise<boolean>} - A promise that resolves to a boolean indicating whether the recording can be resumed.
     */
    checkResumeState = async ({ recordingMediaOptions, recordingVideoPausesLimit, recordingAudioPausesLimit, pauseRecordCount, }) => {
        // function to check if the user can resume recording
        let ref_limit = 0;
        if (recordingMediaOptions == 'video') {
            ref_limit = recordingVideoPausesLimit;
        }
        else {
            ref_limit = recordingAudioPausesLimit;
        }
        return pauseRecordCount <= ref_limit;
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckResumeState, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckResumeState, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CheckResumeState, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class RecordPauseTimer {
    /**
     * Controls the pause and resume functionality of a recording timer.
     *
     * @param {Object} options - The options for controlling the timer.
     * @param {boolean} [options.stop=false] - Indicates whether to stop the timer.
     * @param {Object} options.parameters - The parameters for the timer control.
     * @param {boolean} options.parameters.isTimerRunning - Indicates if the timer is currently running.
     * @param {boolean} options.parameters.canPauseResume - Indicates if the timer can be paused or resumed.
     * @param {Function} [options.parameters.showAlert] - Optional function to show an alert message.
     * @returns {boolean} - Returns true if the timer can be paused or resumed, otherwise false.
     */
    recordPauseTimer = ({ stop = false, isTimerRunning, canPauseResume, showAlert, }) => {
        // Ensure the timer is running and pause/resume actions are allowed
        if (isTimerRunning && canPauseResume) {
            return true;
        }
        else {
            const message = stop
                ? 'Can only stop after 15 seconds of starting or pausing or resuming recording'
                : 'Can only pause or resume after 15 seconds of starting or pausing or resuming recording';
            showAlert?.({
                message,
                type: 'danger',
            });
            return false;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordPauseTimer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordPauseTimer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordPauseTimer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class UpdateRecording {
    CheckPauseStateService;
    CheckResumeStateService;
    RecordPauseTimerService;
    RecordResumeTimerService;
    constructor(CheckPauseStateService, CheckResumeStateService, RecordPauseTimerService, RecordResumeTimerService) {
        this.CheckPauseStateService = CheckPauseStateService;
        this.CheckResumeStateService = CheckResumeStateService;
        this.RecordPauseTimerService = RecordPauseTimerService;
        this.RecordResumeTimerService = RecordResumeTimerService;
    }
    /**
     * Updates the recording state based on the provided parameters.
     *
     * @param {UpdateRecordingOptions} parameters - The parameters for updating the recording state.
     * @returns {Promise<void>} A promise that resolves when the recording state has been updated.
     *
     * @property {string} roomName - The name of the room where the recording is taking place.
     * @property {any} userRecordingParams - Parameters related to the user's recording settings.
     * @property {any} socket - The socket connection used for communication.
     * @property {Function} updateIsRecordingModalVisible - Function to update the visibility of the recording modal.
     * @property {boolean} confirmedToRecord - Indicates if the user has confirmed to start recording.
     * @property {Function} showAlert - Function to show alert messages.
     * @property {string} recordingMediaOptions - The media options for recording (e.g., "video", "audio").
     * @property {boolean} videoAlreadyOn - Indicates if the video is already turned on.
     * @property {boolean} audioAlreadyOn - Indicates if the audio is already turned on.
     * @property {boolean} recordStarted - Indicates if the recording has started.
     * @property {boolean} recordPaused - Indicates if the recording is paused.
     * @property {boolean} recordResumed - Indicates if the recording has resumed.
     * @property {boolean} recordStopped - Indicates if the recording has stopped.
     * @property {number} recordChangeSeconds - The interval in seconds for changing the recording state.
     * @property {number} pauseRecordCount - The count of pauses during the recording.
     * @property {boolean} startReport - Indicates if the start report is active.
     * @property {boolean} endReport - Indicates if the end report is active.
     * @property {boolean} canRecord - Indicates if recording is allowed.
     * @property {boolean} canPauseResume - Indicates if pausing and resuming the recording is allowed.
     * @property {Function} updateCanPauseResume - Function to update the pause/resume state.
     * @property {Function} updatePauseRecordCount - Function to update the pause record count.
     * @property {Function} updateClearedToRecord - Function to update the cleared-to-record state.
     * @property {Function} updateRecordPaused - Function to update the record paused state.
     * @property {Function} updateRecordResumed - Function to update the record resumed state.
     * @property {Function} updateStartReport - Function to update the start report state.
     * @property {Function} updateEndReport - Function to update the end report state.
     * @property {Function} updateCanRecord - Function to update the can record state.
     * @property {Function} rePort - Function to handle reporting.
     */
    updateRecording = async ({ parameters }) => {
        parameters = parameters.getUpdatedAllParams();
        let { roomName, userRecordingParams, socket, updateIsRecordingModalVisible, confirmedToRecord, showAlert, recordingMediaOptions, videoAlreadyOn, audioAlreadyOn, recordStarted, recordPaused, recordResumed, recordStopped, recordChangeSeconds, pauseRecordCount, startReport, endReport, canRecord, updateCanPauseResume, updatePauseRecordCount, updateClearedToRecord, updateRecordPaused, updateRecordResumed, updateStartReport, updateEndReport, updateCanRecord, 
        //mediasfu functions
        // checkPauseState,
        // checkResumeState,
        rePort,
        // recordPauseTimer,
        // recordResumeTimer,
         } = parameters;
        // Check if recording is confirmed before starting
        if (recordStopped) {
            showAlert?.({
                message: 'Recording has already stopped',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Check for recordingMediaOptions for video
        if (recordingMediaOptions === 'video' && !videoAlreadyOn) {
            showAlert?.({
                message: 'You must turn on your video before you can start recording',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Check for recordingMediaOptions for audio
        if (recordingMediaOptions === 'audio' && !audioAlreadyOn) {
            showAlert?.({
                message: 'You must turn on your audio before you can start recording',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (recordStarted && !recordPaused && !recordStopped) {
            let proceed = false;
            proceed = await this.CheckPauseStateService.checkPauseState({
                recordingMediaOptions,
                recordingVideoPausesLimit: parameters['recordingVideoPausesLimit'],
                recordingAudioPausesLimit: parameters['recordingAudioPausesLimit'],
                pauseRecordCount,
                showAlert,
            });
            if (!proceed) {
                return;
            }
            let record = this.RecordPauseTimerService.recordPauseTimer({
                stop: false,
                isTimerRunning: parameters.isTimerRunning,
                canPauseResume: parameters.canPauseResume,
                showAlert,
            });
            if (record) {
                let action = 'pauseRecord';
                await new Promise((resolve) => {
                    socket.emit(action, { roomName }, async ({ success, reason, recordState, pauseCount, }) => {
                        pauseRecordCount = pauseCount;
                        updatePauseRecordCount(pauseRecordCount);
                        if (success) {
                            startReport = false;
                            endReport = true;
                            recordPaused = true;
                            updateStartReport(startReport);
                            updateEndReport(endReport);
                            updateRecordPaused(recordPaused);
                            showAlert?.({
                                message: 'Recording paused',
                                type: 'success',
                                duration: 3000,
                            });
                            // Set isRecordingModalVisible to false
                            updateIsRecordingModalVisible(false);
                            setTimeout(() => {
                                updateCanPauseResume(true);
                            }, recordChangeSeconds);
                        }
                        else {
                            let reasonMessage = `Recording Pause Failed: ${reason}; the current state is: ${recordState}`;
                            showAlert?.({
                                message: reasonMessage,
                                type: 'danger',
                                duration: 3000,
                            });
                        }
                        resolve();
                    });
                });
            }
        }
        else if (recordStarted && recordPaused && !recordStopped) {
            if (!confirmedToRecord) {
                showAlert?.({
                    message: 'You must click confirm before you can start recording',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            let proceed = false;
            proceed = await this.CheckResumeStateService.checkResumeState({
                recordingMediaOptions,
                recordingVideoPausesLimit: parameters['recordingVideoPausesLimit'],
                recordingAudioPausesLimit: parameters['recordingAudioPausesLimit'],
                pauseRecordCount,
            });
            if (!proceed) {
                return;
            }
            let resume = await this.RecordResumeTimerService.recordResumeTimer({ parameters });
            if (resume) {
                // Set clearedToRecord to true
                updateClearedToRecord(true);
                let action = 'startRecord';
                if (recordStarted && recordPaused && !recordResumed && !recordStopped) {
                    action = 'resumeRecord';
                }
                else {
                    action = 'startRecord';
                }
                action = 'resumeRecord';
                await new Promise((resolve) => {
                    socket.emit(action, { roomName, userRecordingParams }, async ({ success, reason, }) => {
                        if (success) {
                            recordPaused = false;
                            recordResumed = true;
                            updateRecordPaused(recordPaused);
                            updateRecordResumed(recordResumed);
                            if (action === 'startRecord') {
                                await rePort({ parameters });
                            }
                            else {
                                recordResumed = true;
                                await rePort({ restart: true, parameters });
                            }
                        }
                        else {
                            showAlert?.({
                                message: `Recording could not start - ${reason}`,
                                type: 'danger',
                                duration: 3000,
                            });
                            canRecord = true;
                            startReport = false;
                            endReport = true;
                            updateCanRecord(canRecord);
                            updateStartReport(startReport);
                            updateEndReport(endReport);
                        }
                        resolve();
                    });
                });
                // Set isRecordingModalVisible to false
                updateIsRecordingModalVisible(false);
                setTimeout(() => {
                    updateCanPauseResume(true);
                }, recordChangeSeconds);
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateRecording, deps: [{ token: CheckPauseState }, { token: CheckResumeState }, { token: RecordPauseTimer }, { token: RecordResumeTimer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: CheckPauseState }, { type: CheckResumeState }, { type: RecordPauseTimer }, { type: RecordResumeTimer }] });

class StopRecording {
    RecordPauseTimerService;
    constructor(RecordPauseTimerService) {
        this.RecordPauseTimerService = RecordPauseTimerService;
    }
    async stopRecording({ parameters }) {
        let { roomName, socket, showAlert, startReport, endReport, recordStarted, recordPaused, recordStopped, updateRecordPaused, updateRecordStopped, updateStartReport, updateEndReport, updateShowRecordButtons, whiteboardStarted, whiteboardEnded, recordingMediaOptions, 
        //mediasfu functions
        captureCanvasStream, } = parameters;
        let recAttempt;
        if (recordStarted && !recordStopped) {
            let stop = await this.RecordPauseTimerService.recordPauseTimer({
                stop: true,
                isTimerRunning: parameters['isTimerRunning'],
                canPauseResume: parameters['canPauseResume'],
                showAlert: parameters.showAlert,
            });
            if (stop) {
                let action = 'stopRecord';
                await new Promise((resolve) => {
                    socket.emit(action, { roomName }, ({ success, reason, recordState, }) => {
                        if (success) {
                            startReport = false;
                            endReport = true;
                            recordPaused = false;
                            recordStopped = true;
                            recAttempt = true;
                            updateStartReport(startReport);
                            updateEndReport(endReport);
                            updateRecordPaused(recordPaused);
                            updateRecordStopped(recordStopped);
                            showAlert?.({ message: 'Recording Stopped', type: 'success' });
                            updateShowRecordButtons(false);
                        }
                        else {
                            let reasonMessage = `Recording Stop Failed: ${reason}; the recording is currently ${recordState}`;
                            showAlert?.({ message: reasonMessage, type: 'danger' });
                            recAttempt = false;
                        }
                        resolve();
                    });
                });
                try {
                    if (recAttempt && whiteboardStarted && !whiteboardEnded) {
                        if (recordingMediaOptions === 'video') {
                            captureCanvasStream({ parameters, start: false });
                        }
                    }
                }
                catch (error) {
                    console.log('Error capturing canvas stream:', error);
                }
            }
            else {
                return;
            }
        }
        else {
            showAlert?.({ message: 'Recording is not started yet or already stopped', type: 'danger' });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StopRecording, deps: [{ token: RecordPauseTimer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StopRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StopRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: RecordPauseTimer }] });

/**
 * @fileoverview Service to handle user waiting functionality.
 *
 * @description
 * This service provides methods to handle the logic when a user joins the waiting room.
 * It displays an alert/notification and updates the total number of requests waiting.
 */
/**
 * Options for the userWaiting method.
 *
 * @interface UserWaitingOptions
 * @property {string} name - The name of the user joining the waiting room.
 * @property {(options: { message: string; type: string; duration: number }) => void} [showAlert] - Optional function to display an alert/notification.
 * @property {number} totalReqWait - The current total number of requests waiting.
 * @property {(total: number) => void} updateTotalReqWait - Function to update the total number of requests waiting.
 */
/**
 * Service to handle user waiting functionality.
 *
 * @class
 * @name UserWaiting
 * @description
 * This service provides methods to handle the logic when a user joins the waiting room.
 * It displays an alert/notification and updates the total number of requests waiting.
 *
 * @example
 * const userWaitingService = new UserWaiting();
 * userWaitingService.userWaiting({
 *   name: 'John Doe',
 *   showAlert: (options) => console.log(options.message),
 *   totalReqWait: 5,
 *   updateTotalReqWait: (total) => console.log(`Total requests: ${total}`),
 * });
 */
/**
 * Handles the logic when a user joins the waiting room.
 *
 * @method
 * @name userWaiting
 * @memberof UserWaiting
 * @async
 *
 * @param {UserWaitingOptions} options - The options for the user waiting method.
 * @returns {Promise<void>} A promise that resolves when the operation is complete.
 *
 * @example
 * const options = {
 *   name: 'John Doe',
 *   showAlert: (options) => console.log(options.message),
 *   totalReqWait: 5,
 *   updateTotalReqWait: (total) => console.log(`Total requests: ${total}`),
 * };
 * await userWaitingService.userWaiting(options);
 */
class UserWaiting {
    userWaiting = async ({ name, showAlert, totalReqWait, updateTotalReqWait, }) => {
        // Display an alert/notification about the user joining the waiting room
        showAlert?.({
            message: `${name} joined the waiting room.`,
            type: 'success',
            duration: 3000,
        });
        // Update the total number of requests waiting in the waiting room
        const totalReqs = totalReqWait + 1;
        updateTotalReqWait(totalReqs);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UserWaiting, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UserWaiting, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UserWaiting, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class PersonJoined {
    /**
     * Handles the event when a person joins.
     *
     * @param {PersonJoinedOptions} options - The options for the person joined event.
     * @param {string} options.name - The name of the person who joined.
     * @param {Function} options.showAlert - A function to display an alert/notification.
     * @returns {Promise<void>} A promise that resolves when the alert has been shown.
     */
    personJoined = ({ name, showAlert }) => {
        // Display an alert/notification about the person joining the event
        showAlert?.({
            message: `${name} joined the event.`,
            type: 'success',
            duration: 3000,
        });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PersonJoined, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PersonJoined, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: PersonJoined, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class AllWaitingRoomMembers {
    /**
     * Updates the waiting room participants list and the total count of waiting room participants.
     *
     * @param {Object} options - The options object.
     * @param {Array} options.waitingParticipants - An array of participants currently in the waiting room.
     * @param {Function} options.updateWaitingRoomList - A function to update the waiting room participants list.
     * @param {Function} options.updateTotalReqWait - A function to update the total count of waiting room participants.
     * @returns {Promise<void>} A promise that resolves when the updates are complete.
     */
    allWaitingRoomMembers = async ({ waitingParticipants, updateWaitingRoomList, updateTotalReqWait, }) => {
        // Calculate the total number of waiting room participants
        const totalReqs = waitingParticipants.length;
        // Update the waiting room participants list
        updateWaitingRoomList(waitingParticipants);
        // Update the total count of waiting room participants
        updateTotalReqWait(totalReqs);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AllWaitingRoomMembers, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AllWaitingRoomMembers, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AllWaitingRoomMembers, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class RoomRecordParams {
    /**
     * Updates various recording parameters based on the provided `recordParams`.
     *
     * @param {Object} params - The parameters object.
     * @param {RecordParams} params.recordParams - The recording parameters to update.
     * @param {Parameters} params.parameters - The functions to update each recording parameter.
     * @param {Function} params.parameters.updateRecordingAudioPausesLimit - Function to update the audio pauses limit.
     * @param {Function} params.parameters.updateRecordingAudioPausesCount - Function to update the audio pauses count.
     * @param {Function} params.parameters.updateRecordingAudioSupport - Function to update the audio support.
     * @param {Function} params.parameters.updateRecordingAudioPeopleLimit - Function to update the audio people limit.
     * @param {Function} params.parameters.updateRecordingAudioParticipantsTimeLimit - Function to update the audio participants time limit.
     * @param {Function} params.parameters.updateRecordingVideoPausesCount - Function to update the video pauses count.
     * @param {Function} params.parameters.updateRecordingVideoPausesLimit - Function to update the video pauses limit.
     * @param {Function} params.parameters.updateRecordingVideoSupport - Function to update the video support.
     * @param {Function} params.parameters.updateRecordingVideoPeopleLimit - Function to update the video people limit.
     * @param {Function} params.parameters.updateRecordingVideoParticipantsTimeLimit - Function to update the video participants time limit.
     * @param {Function} params.parameters.updateRecordingAllParticipantsSupport - Function to update the all participants support.
     * @param {Function} params.parameters.updateRecordingVideoParticipantsSupport - Function to update the video participants support.
     * @param {Function} params.parameters.updateRecordingAllParticipantsFullRoomSupport - Function to update the all participants full room support.
     * @param {Function} params.parameters.updateRecordingVideoParticipantsFullRoomSupport - Function to update the video participants full room support.
     * @param {Function} params.parameters.updateRecordingPreferredOrientation - Function to update the preferred orientation.
     * @param {Function} params.parameters.updateRecordingSupportForOtherOrientation - Function to update the support for other orientation.
     * @param {Function} params.parameters.updateRecordingMultiFormatsSupport - Function to update the multi-formats support.
     * @returns {Promise<void>} A promise that resolves when all parameters have been updated.
     */
    roomRecordParams = ({ recordParams, parameters }) => {
        let { updateRecordingAudioPausesLimit, updateRecordingAudioPausesCount, updateRecordingAudioSupport, updateRecordingAudioPeopleLimit, updateRecordingAudioParticipantsTimeLimit, updateRecordingVideoPausesCount, updateRecordingVideoPausesLimit, updateRecordingVideoSupport, updateRecordingVideoPeopleLimit, updateRecordingVideoParticipantsTimeLimit, updateRecordingAllParticipantsSupport, updateRecordingVideoParticipantsSupport, updateRecordingAllParticipantsFullRoomSupport, updateRecordingVideoParticipantsFullRoomSupport, updateRecordingPreferredOrientation, updateRecordingSupportForOtherOrientation, updateRecordingMultiFormatsSupport, } = parameters;
        // Update each recording parameter based on the provided recordParams
        updateRecordingAudioPausesLimit(recordParams.recordingAudioPausesLimit);
        updateRecordingAudioPausesCount(recordParams.recordingAudioPausesCount);
        updateRecordingAudioSupport(recordParams.recordingAudioSupport);
        updateRecordingAudioPeopleLimit(recordParams.recordingAudioPeopleLimit);
        updateRecordingAudioParticipantsTimeLimit(recordParams.recordingAudioParticipantsTimeLimit);
        updateRecordingVideoPausesCount(recordParams.recordingVideoPausesCount);
        updateRecordingVideoPausesLimit(recordParams.recordingVideoPausesLimit);
        updateRecordingVideoSupport(recordParams.recordingVideoSupport);
        updateRecordingVideoPeopleLimit(recordParams.recordingVideoPeopleLimit);
        updateRecordingVideoParticipantsTimeLimit(recordParams.recordingVideoParticipantsTimeLimit);
        updateRecordingAllParticipantsSupport(recordParams.recordingAllParticipantsSupport);
        updateRecordingVideoParticipantsSupport(recordParams.recordingVideoParticipantsSupport);
        updateRecordingAllParticipantsFullRoomSupport(recordParams.recordingAllParticipantsFullRoomSupport);
        updateRecordingVideoParticipantsFullRoomSupport(recordParams.recordingVideoParticipantsFullRoomSupport);
        updateRecordingPreferredOrientation(recordParams.recordingPreferredOrientation);
        updateRecordingSupportForOtherOrientation(recordParams.recordingSupportForOtherOrientation);
        updateRecordingMultiFormatsSupport(recordParams.recordingMultiFormatsSupport);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RoomRecordParams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RoomRecordParams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RoomRecordParams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class BanParticipant {
    /**
     * Bans a participant from the session by removing them from the active and display names arrays,
     * updating the participants list, and reordering the streams.
     *
     * @param {BanParticipantOptions} options - The options for banning a participant.
     * @param {string} options.name - The name of the participant to be banned.
     * @param {Object} options.parameters - The parameters required for banning the participant.
     * @param {string[]} options.parameters.activeNames - The array of active participant names.
     * @param {string[]} options.parameters.dispActiveNames - The array of display participant names.
     * @param {Object[]} options.parameters.participants - The array of participant objects.
     * @param {Function} options.parameters.updateParticipants - The function to update the participants array.
     * @param {Function} options.parameters.reorderStreams - The function to reorder the streams.
     *
     * @returns {Promise<void>} A promise that resolves when the participant has been banned and streams reordered.
     */
    banParticipant = async ({ name, parameters }) => {
        const { activeNames, dispActiveNames, participants, updateParticipants, reorderStreams } = parameters;
        // Check if the participant is in the active or display names array
        if (activeNames.includes(name) || dispActiveNames.includes(name)) {
            // Filter out the banned participant from the participants array
            const updatedParticipants = participants.filter((participant) => participant.name !== name);
            // Update the participants array
            updateParticipants(updatedParticipants);
            // Reorder streams after participant removal
            await reorderStreams({ add: false, screenChanged: true, parameters });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: BanParticipant, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: BanParticipant, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: BanParticipant, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class UpdatedCoHost {
    /**
     * Updates the co-host information, responsibility, and user's co-host status based on the provided options.
     *
     * @param options - The options for updating the co-host.
     * @param options.coHost - The co-host to be updated.
     * @param options.coHostResponsibility - The responsibility of the co-host.
     * @param options.showAlert - A function to show alerts.
     * @param options.eventType - The type of event triggering the update.
     * @param options.islevel - The level of the event.
     * @param options.member - The member to be checked against the co-host.
     * @param options.youAreCoHost - The current co-host status of the user.
     * @param options.updateCoHost - A function to update the co-host.
     * @param options.updateCoHostResponsibility - A function to update the co-host's responsibility.
     * @param options.updateYouAreCoHost - A function to update the user's co-host status.
     *
     * @returns A promise that resolves when the co-host information has been updated.
     */
    updatedCoHost = async ({ coHost, coHostResponsibility, showAlert, eventType, islevel, member, youAreCoHost, updateCoHost, updateCoHostResponsibility, updateYouAreCoHost, }) => {
        // Update co-host information, responsibility, and user's co-host status
        if (eventType !== 'broadcast' && eventType !== 'chat') {
            // Only update the co-host if the event type is not broadcast or chat
            updateCoHost(coHost);
            updateCoHostResponsibility(coHostResponsibility);
            if (member === coHost) {
                if (!youAreCoHost) {
                    updateYouAreCoHost(true);
                    showAlert?.({
                        message: 'You are now a co-host.',
                        type: 'success',
                        duration: 3000,
                    });
                }
            }
            else {
                updateYouAreCoHost(false);
            }
        }
        else {
            if (islevel !== '2') {
                updateYouAreCoHost(true);
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdatedCoHost, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdatedCoHost, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdatedCoHost, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ParticipantRequested {
    /**
     * Handles a participant's request by adding it to the request list and updating the total count of requests and waiting room participants.
     *
     * @param {ParticipantRequestedOptions} options - The options for handling the participant's request.
     * @param {UserRequest} options.userRequest - The user request to be added to the request list.
     * @param {UserRequest[]} options.requestList - The current list of user requests.
     * @param {UserRequest[]} options.waitingRoomList - The current list of participants in the waiting room.
     * @param {Function} options.updateTotalReqWait - Function to update the total count of requests and waiting room participants.
     * @param {Function} options.updateRequestList - Function to update the request list.
     * @returns {Promise<void>} A promise that resolves when the participant's request has been handled.
     */
    participantRequested = async ({ userRequest, requestList, waitingRoomList, updateTotalReqWait, updateRequestList, }) => {
        // Add the user request to the request list
        const updatedRequestList = [...requestList, userRequest];
        updateRequestList(updatedRequestList);
        // Update the total count of requests and waiting room participants
        const reqCount = updatedRequestList.length + waitingRoomList.length;
        updateTotalReqWait(reqCount);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantRequested, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantRequested, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ParticipantRequested, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ScreenProducerId {
    /**
     * Handles the screen producer id.
     *
     * @param producerId - The id of the producer.
     * @param screenId - The id of the screen.
     * @param membersReceived - Whether the members data has been received.
     * @param shareScreenStarted - Whether the screen sharing has started.
     * @param deferScreenReceived - Whether the screen sharing has been deferred.
     * @param participants - The list of participants.
     * @param updateScreenId - Function to update the screen id.
     * @param updateShareScreenStarted - Function to update the screen sharing status.
     * @param updateDeferScreenReceived - Function to update the screen sharing defer status.
     */
    screenProducerId = ({ producerId, screenId, membersReceived, shareScreenStarted, deferScreenReceived, participants, updateScreenId, updateShareScreenStarted, updateDeferScreenReceived, }) => {
        // Check if members data has been received with the screenId participant in it
        let host = participants.find((participant) => participant.ScreenID === screenId && participant.ScreenOn === true);
        // Operations to update the UI
        if (host && membersReceived) {
            screenId = producerId;
            shareScreenStarted = true;
            deferScreenReceived = false;
            updateScreenId(screenId);
            updateShareScreenStarted(shareScreenStarted);
            updateDeferScreenReceived(deferScreenReceived);
        }
        else {
            deferScreenReceived = true;
            screenId = producerId;
            updateScreenId(screenId);
            updateDeferScreenReceived(deferScreenReceived);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ScreenProducerId, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ScreenProducerId, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ScreenProducerId, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class UpdateMediaSettings {
    /**
     * Updates the media settings by invoking the provided update functions for each setting.
     *
     * @param {Object} options - The options for updating the media settings.
     * @param {Settings} options.settings - The media settings to update.
     * @param {Function} options.updateAudioSetting - Function to update the audio setting.
     * @param {Function} options.updateVideoSetting - Function to update the video setting.
     * @param {Function} options.updateScreenshareSetting - Function to update the screenshare setting.
     * @param {Function} options.updateChatSetting - Function to update the chat setting.
     * @returns {void} A promise that resolves when the media settings have been updated.
     * @memberof UpdateMediaSettings
     */
    updateMediaSettings = ({ settings, updateAudioSetting, updateVideoSetting, updateScreenshareSetting, updateChatSetting, }) => {
        const [audioSetting, videoSetting, screenshareSetting, chatSetting] = settings;
        // Update audio setting
        updateAudioSetting(audioSetting);
        // Update video setting
        updateVideoSetting(videoSetting);
        // Update screenshare setting
        updateScreenshareSetting(screenshareSetting);
        // Update chat setting
        updateChatSetting(chatSetting);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateMediaSettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateMediaSettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateMediaSettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ProducerMediaPaused {
    /**
     * Handles the event when media is paused for a producer.
     *
     * @param {ProducerMediaPausedOptions} options - The options for the producer media paused event.
     * @param {string} options.producerId - The ID of the producer.
     * @param {string} options.kind - The kind of media (e.g., "audio", "video").
     * @param {string} options.name - The name of the producer.
     * @param {Parameters} options.parameters - The parameters for the event.
     *
     * @returns {Promise<void>} A promise that resolves when the media paused handling is complete.
     *
     * @description
     * This function handles the event when media is paused for a producer. It performs the following tasks:
     * - Updates the parameters.
     * - Iterates through participants and updates the UI based on their muted status and other conditions.
     * - Handles meeting display type and optimizes the UI accordingly.
     * - Manages audio media by updating the relevant participant's state.
     */
    producerMediaPaused = async ({ producerId, kind, name, parameters, }) => {
        parameters = parameters.getUpdatedAllParams();
        let { activeSounds, meetingDisplayType, meetingVideoOptimized, participants, oldSoundIds, shared, shareScreenStarted, updateMainWindow, hostLabel, islevel, updateActiveSounds, updateUpdateMainWindow, reorderStreams, prepopulateUserMedia, reUpdateInter, } = parameters;
        await Promise.all(participants.map(async (participant) => {
            if (participant.muted) {
                try {
                    if (participant.islevel == '2' &&
                        !participant.videoID &&
                        !shared &&
                        !shareScreenStarted &&
                        islevel != '2') {
                        updateMainWindow = true;
                        updateUpdateMainWindow(updateMainWindow);
                        await prepopulateUserMedia({ name: hostLabel, parameters });
                        updateMainWindow = false;
                        updateUpdateMainWindow(updateMainWindow);
                    }
                }
                catch {
                    /* handle error */
                }
                if (shareScreenStarted || shared) {
                    if (activeSounds.includes(participant.name)) {
                        activeSounds = activeSounds.filter((audioStream) => audioStream != participant.name);
                        updateActiveSounds(activeSounds);
                    }
                    await reUpdateInter({ name: participant.name, add: false, force: true, parameters });
                }
            }
        }));
        let checker = false;
        if (meetingDisplayType == 'media' ||
            (meetingDisplayType == 'video' && !meetingVideoOptimized)) {
            const participant = participants.find((obj) => obj.name == name);
            checker = !!participant?.videoID;
            if (!checker && !shareScreenStarted && !shared) {
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
        if (kind == 'audio') {
            try {
                const participant = participants.find((obj) => obj.audioID == producerId) ||
                    participants.find((obj) => obj.name == name);
                if (participant &&
                    ((participant.name && oldSoundIds.includes(participant.name)) ||
                        (name && oldSoundIds.includes(name)))) {
                    reUpdateInter({
                        name: participant.name ?? '',
                        add: false,
                        force: true,
                        parameters,
                    });
                }
            }
            catch {
                /* handle error */
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerMediaPaused, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerMediaPaused, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerMediaPaused, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ProducerMediaResumed {
    /**
     * Resumes media for a specific participant in a meeting.
     *
     * @param {ProducerMediaResumedOptions} options - The options for resuming media.
     * @param {string} options.name - The name of the participant whose media is to be resumed.
     * @param {Object} options.parameters - The parameters related to the meeting and participants.
     * @param {string} options.parameters.meetingDisplayType - The type of meeting display.
     * @param {Array} options.parameters.participants - The list of participants in the meeting.
     * @param {boolean} options.parameters.shared - Indicates if the screen is being shared.
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
     * @param {boolean} options.parameters.mainScreenFilled - Indicates if the main screen is filled.
     * @param {string} options.parameters.hostLabel - The label of the host.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
     * @param {Function} options.parameters.reorderStreams - Function to reorder the streams.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     *
     * @returns {Promise<void>} A promise that resolves when the media has been resumed.
     */
    producerMediaResumed = async ({ name, parameters, }) => {
        parameters = parameters.getUpdatedAllParams();
        let { meetingDisplayType, participants, shared, shareScreenStarted, updateMainWindow, mainScreenFilled, hostLabel, updateUpdateMainWindow, reorderStreams, prepopulateUserMedia, } = parameters;
        // Update to resume the audio only of a participant
        // name is the name of the participant
        // kind is the kind of media (always audio)
        // Operations to update UI to optimize interest levels
        const participant = participants.find((obj) => obj.name == name);
        if (!mainScreenFilled && participant?.islevel == '2') {
            updateMainWindow = true;
            updateUpdateMainWindow(updateMainWindow);
            await prepopulateUserMedia({ name: hostLabel, parameters });
            updateMainWindow = false;
            updateUpdateMainWindow(updateMainWindow);
        }
        let checker;
        if (meetingDisplayType == 'media') {
            checker = participant?.videoID != null && participant.videoID !== '';
            if (!checker && !(shareScreenStarted || shared)) {
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerMediaResumed, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerMediaResumed, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerMediaResumed, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ProducerMediaClosed {
    /**
     * Handles the closure of a media producer.
     *
     * @param {ProducerMediaClosedOptions} options - The options for closing the media producer.
     * @param {string} options.producerId - The ID of the producer to close.
     * @param {string} options.kind - The kind of media (e.g., "screenshare" or "screen").
     * @param {Parameters} options.parameters - The parameters object containing various methods and properties.
     *
     * @returns {Promise<void>} - A promise that resolves when the producer has been closed and necessary updates are made.
     *
     * @remarks
     * This function performs the following steps:
     * 1. Retrieves updated parameters.
     * 2. Finds the transport associated with the producer to close.
     * 3. Closes the consumer transport and consumer if found.
     * 4. Updates the consumer transports list.
     * 5. Calls `closeAndResize` with the necessary parameters.
     * 6. If the producer kind is "screenshare" or "screen", updates shared state and calls various update methods.
     */
    producerMediaClosed = async ({ producerId, kind, parameters, }) => {
        parameters = parameters.getUpdatedAllParams();
        const { consumerTransports, updateConsumerTransports, hostLabel, shared, updateShared, updateShareScreenStarted, updateScreenId, updateShareEnded, closeAndResize, prepopulateUserMedia, reorderStreams, } = parameters;
        const producerToClose = consumerTransports.find((transportData) => transportData.producerId === producerId);
        if (producerToClose) {
            try {
                await producerToClose['consumerTransport'].close();
            }
            catch (error) {
                console.error('Error closing consumer transport:', error);
            }
            try {
                producerToClose.consumer.close();
            }
            catch (error) {
                console.error('Error closing consumer:', error);
            }
            const updatedConsumerTransports = consumerTransports.filter((transportData) => transportData.producerId !== producerId);
            updateConsumerTransports(updatedConsumerTransports);
            await closeAndResize({ producerId, kind, parameters });
        }
        else {
            if (kind === 'screenshare' || kind === 'screen') {
                if (shared) {
                    updateShared(false);
                }
                else {
                    updateShareScreenStarted(false);
                    updateScreenId('');
                }
                updateShareEnded(true);
                await prepopulateUserMedia({ name: hostLabel, parameters });
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerMediaClosed, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerMediaClosed, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProducerMediaClosed, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ControlMediaHost {
    /**
     * Controls the media (audio, video, screenshare, chat) of a participant as a host.
     *
     * @param {object} options - The function parameters.
     * @param {string} options.type - The type of media to control ('audio', 'video', 'screenshare', 'chat', 'all').
     * @param {object} options.parameters - Additional parameters needed for the function.
     * @param {boolean} options.parameters.adminRestrictSetting - The setting to restrict host control.
     * @param {function} options.parameters.updateAdminRestrictSetting - Function to update the adminRestrictSetting.
     * @param {MediaStream} options.parameters.localStream - The local audio and video stream.
     * @param {function} options.parameters.updateLocalStream - Function to update the local audio and video stream.
     * @param {boolean} options.parameters.audioAlreadyOn - Indicates whether audio is currently on.
     * @param {function} options.parameters.updateAudioAlreadyOn - Function to update the audioAlreadyOn status.
     * @param {MediaStream} options.parameters.localStreamScreen - The local screenshare stream.
     * @param {function} options.parameters.updateLocalStreamScreen - Function to update the local screenshare stream.
     * @param {MediaStream} options.parameters.localStreamVideo - The local video stream.
     * @param {function} options.parameters.updateLocalStreamVideo - Function to update the local video stream.
     * @param {boolean} options.parameters.screenAlreadyOn - Indicates whether screenshare is currently on.
     * @param {function} options.parameters.updateScreenAlreadyOn - Function to update the screenAlreadyOn status.
     * @param {boolean} options.parameters.videoAlreadyOn - Indicates whether video is currently on.
     * @param {function} options.parameters.updateVideoAlreadyOn - Function to update the videoAlreadyOn status.
     * @param {boolean} options.parameters.chatAlreadyOn - Indicates whether chat is currently on.
     * @param {function} options.parameters.updateChatAlreadyOn - Function to update the chatAlreadyOn status.
     * @param {function} options.parameters.onScreenChanges - Function to handle changes in screen status.
     * @param {function} options.parameters.stopShareScreen - Function to stop sharing the screen.
     * @param {function} options.parameters.disconnectSendTransportVideo - Function to disconnect video send transport.
     * @param {function} options.parameters.disconnectSendTransportAudio - Function to disconnect audio send transport.
     * @param {function} options.parameters.disconnectSendTransportScreen - Function to disconnect screenshare send transport.
     */
    controlMediaHost = async ({ type, parameters }) => {
        let { updateAdminRestrictSetting, updateLocalStream, updateAudioAlreadyOn, updateLocalStreamScreen, updateLocalStreamVideo, updateScreenAlreadyOn, updateVideoAlreadyOn, updateChatAlreadyOn, onScreenChanges, stopShareScreen, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, } = parameters;
        let { localStream, localStreamScreen, localStreamVideo } = parameters.getUpdatedAllParams();
        try {
            updateAdminRestrictSetting(true);
            if (type === 'audio') {
                if (localStream) {
                    localStream.getAudioTracks()[0].enabled = false;
                }
                updateLocalStream(localStream);
                await disconnectSendTransportAudio({ parameters });
                updateAudioAlreadyOn(false);
            }
            else if (type === 'video') {
                try {
                    if (localStream) {
                        localStream.getVideoTracks()[0].enabled = false;
                    }
                    updateLocalStream(localStream);
                    await disconnectSendTransportVideo({ parameters });
                    await onScreenChanges({ changed: true, parameters });
                    updateVideoAlreadyOn(false);
                }
                catch {
                    /* handle error */
                }
                try {
                    if (localStreamVideo) {
                        localStreamVideo.getVideoTracks()[0].enabled = false;
                        updateLocalStreamVideo(localStreamVideo);
                        await disconnectSendTransportVideo({ parameters });
                        await onScreenChanges({ changed: true, parameters });
                        updateVideoAlreadyOn(false);
                    }
                }
                catch (error) {
                    onScreenChanges({ changed: true, parameters });
                }
            }
            else if (type === 'screenshare') {
                if (localStreamScreen) {
                    localStreamScreen.getVideoTracks()[0].enabled = false;
                }
                updateLocalStreamScreen(localStreamScreen);
                await disconnectSendTransportScreen({ parameters });
                await stopShareScreen({ parameters });
                updateScreenAlreadyOn(false);
            }
            else if (type === 'chat') {
                updateChatAlreadyOn(false);
            }
            else if (type === 'all') {
                try {
                    if (localStream) {
                        localStream.getAudioTracks()[0].enabled = false;
                    }
                    updateLocalStream(localStream);
                    await disconnectSendTransportAudio({ parameters });
                    updateAudioAlreadyOn(false);
                }
                catch {
                    /* handle error */
                }
                try {
                    if (localStreamScreen) {
                        localStreamScreen.getVideoTracks()[0].enabled = false;
                    }
                    updateLocalStreamScreen(localStreamScreen);
                    await disconnectSendTransportScreen({ parameters });
                    await stopShareScreen({ parameters });
                    updateScreenAlreadyOn(false);
                }
                catch {
                    /* handle error */
                }
                try {
                    if (localStream) {
                        localStream.getVideoTracks()[0].enabled = false;
                    }
                    updateLocalStream(localStream);
                    await disconnectSendTransportVideo({ parameters });
                    await onScreenChanges({ changed: true, parameters });
                    updateVideoAlreadyOn(false);
                }
                catch {
                    /* handle error */
                }
                try {
                    if (localStreamVideo) {
                        localStreamVideo.getVideoTracks()[0].enabled = false;
                    }
                    updateLocalStreamVideo(localStreamVideo);
                    await disconnectSendTransportVideo({ parameters });
                    await onScreenChanges({ changed: true, parameters });
                    updateVideoAlreadyOn(false);
                }
                catch (error) {
                    onScreenChanges({ changed: true, parameters });
                }
            }
        }
        catch (error) {
            console.error('Error in controlMediaHost:', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlMediaHost, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlMediaHost, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ControlMediaHost, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class MeetingEnded {
    /**
     * Handles the end of a meeting by showing an alert and redirecting the user.
     *
     * @param {MeetingEndedOptions} options - The options for handling the meeting end.
     * @param {Function} options.showAlert - Function to show an alert message.
     * @param {string} options.redirectURL - URL to redirect to after the meeting ends.
     * @param {boolean} options.onWeb - Flag indicating if the application is running on the web.
     * @param {string} options.eventType - Type of the event that triggered the meeting end.
     *
     * @returns {Promise<void>} A promise that resolves when the meeting end handling is complete.
     */
    meetingEnded = async ({ showAlert, redirectURL, onWeb, eventType, }) => {
        // Show an alert that the meeting has ended and wait for 2 seconds before redirecting to the home page
        if (eventType !== 'chat') {
            showAlert?.({
                message: 'The event has ended. You will be redirected to the home page in 2 seconds.',
                type: 'danger',
                duration: 2000,
            });
        }
        if (onWeb && redirectURL) {
            setTimeout(() => {
                window.location.href = redirectURL;
            }, 2000);
        }
        else {
            // setTimeout(() => {
            //   updateValidated(false);
            // }, 2000);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingEnded, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingEnded, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingEnded, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class DisconnectUserSelf {
    /**
     * Disconnects the user from the specified room and bans them.
     *
     * @param {DisconnectUserSelfOptions} options - The options for disconnecting the user.
     * @param {Object} options.member - The member object representing the user to disconnect.
     * @param {string} options.roomName - The name of the room from which the user will be disconnected.
     * @param {Socket} options.socket - The socket instance used to emit the disconnection request.
     * @returns {Promise<void>} A promise that resolves when the disconnection request has been emitted.
     */
    disconnectUserSelf = async ({ member, roomName, socket, }) => {
        // Update that the user needs to be disconnected; this is initiated by the host when banning a user
        socket.emit('disconnectUser', { member, roomName, ban: true });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectUserSelf, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectUserSelf, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: DisconnectUserSelf, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ReceiveMessage {
    /**
     * Receives and processes a message, updating the messages array and handling
     * various message types and events.
     *
     * @param {ReceiveMessageOptions} options - The options for receiving the message.
     * @param {Object} options.message - The message object containing sender, receivers, content, timestamp, and group.
     * @param {Function} options.getUpdatedAllParams - Function to get updated parameters.
     * @param {Array} options.messages - Array of current messages.
     * @param {Array} options.participantsAll - Array of all participants.
     * @param {string} options.member - The current member.
     * @param {string} options.eventType - The type of event (e.g., "broadcast", "chat").
     * @param {string} options.islevel - The level of the current member.
     * @param {string} options.coHost - The co-host of the event.
     * @param {Function} options.updateMessages - Function to update the messages array.
     * @param {Function} options.updateShowMessagesBadge - Function to update the visibility of the messages badge.
     *
     * @returns {Promise<void>} A promise that resolves when the message has been processed.
     */
    receiveMessage = async ({ message, messages, participantsAll, member, eventType, islevel, coHost, updateMessages, updateShowMessagesBadge, }) => {
        // Add the received message to the messages array
        const { sender, receivers, message: content, timestamp, group } = message;
        let oldMessages = messages;
        messages = [...messages, { sender, receivers, message: content, timestamp, group }];
        // Filter out messages with banned senders in the participants array
        if (eventType !== 'broadcast' && eventType !== 'chat') {
            messages = messages.filter((message) => participantsAll.some((participant) => participant.name === message.sender && !participant.isBanned));
        }
        else {
            messages = messages.filter((message) => {
                const participant = participantsAll.find((participant) => participant.name === message.sender);
                return !participant || !participant.isBanned;
            });
        }
        updateMessages(messages);
        // Separate group and direct messages
        const oldGroupMessages = oldMessages.filter((message) => message.group);
        const oldDirectMessages = oldMessages.filter((message) => !message.group);
        // Render and update counts for group messages
        const groupMessages = messages.filter((message) => message.group);
        if (eventType !== 'broadcast' && eventType !== 'chat') {
            // Check if oldGroupMessages length is different from groupMessages length
            if (oldGroupMessages.length !== groupMessages.length) {
                // Identify new messages
                const newGroupMessages = groupMessages.filter((message) => !oldGroupMessages.some((oldMessage) => oldMessage.timestamp === message.timestamp));
                // Check if newGroupMessages sender is the member or receivers include the member
                const newGroupMessages2 = newGroupMessages.filter((message) => message.sender === member || message.receivers.includes(member));
                // Check if member is the sender of any newGroupMessages
                const newGroupMessages3 = newGroupMessages2.filter((message) => message.sender === member);
                // Check if member is the receiver of any newGroupMessages
                if (newGroupMessages.length > 0 && newGroupMessages.length !== newGroupMessages3.length) {
                    updateShowMessagesBadge(true);
                }
            }
        }
        // Render and update counts for direct messages
        const directMessages = messages.filter((message) => !message.group);
        if (eventType !== 'broadcast' && eventType !== 'chat') {
            // Check if oldDirectMessages length is different from directMessages length
            if (oldDirectMessages.length !== directMessages.length) {
                // Identify new direct messages
                const newDirectMessages = directMessages.filter((message) => !oldDirectMessages.some((oldMessage) => oldMessage.timestamp === message.timestamp));
                // Check if newDirectMessages sender is the member or receivers include the member
                const newDirectMessages2 = newDirectMessages.filter((message) => message.sender === member || message.receivers.includes(member));
                // Check if member is the sender of any newDirectMessages
                const newDirectMessages3 = newDirectMessages2.filter((message) => message.sender === member);
                if ((newDirectMessages.length > 0 && newDirectMessages2.length > 0) ||
                    (newDirectMessages.length > 0 && islevel === '2') ||
                    coHost === member) {
                    if (islevel === '2' || coHost === member) {
                        if (newDirectMessages.length !== newDirectMessages3.length) {
                            updateShowMessagesBadge(true);
                        }
                    }
                    else {
                        if (newDirectMessages2.length > 0 &&
                            newDirectMessages.length !== newDirectMessages3.length) {
                            updateShowMessagesBadge(true);
                        }
                    }
                }
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReceiveMessage, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReceiveMessage, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReceiveMessage, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class MeetingTimeRemaining {
    /**
     * Handles the remaining time for a meeting and shows an alert if the event type is not 'chat'.
     *
     * @param {Object} options - The options for the meeting time remaining.
     * @param {number} options.timeRemaining - The remaining time in milliseconds.
     * @param {Function} options.showAlert - The function to show an alert message.
     * @param {string} options.eventType - The type of the event.
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     */
    meetingTimeRemaining = async ({ timeRemaining, showAlert, eventType, }) => {
        // Convert time from milliseconds to readable format of minutes and seconds
        const minutes = Math.floor(timeRemaining / 60000);
        const seconds = Math.floor((timeRemaining % 60000) / 1000);
        const timeRemainingString = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        // Show alert with time remaining if eventType is not 'chat'
        if (eventType !== 'chat') {
            showAlert?.({
                message: `The event will end in ${timeRemainingString} minutes.`,
                type: 'success',
                duration: 3000,
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingTimeRemaining, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingTimeRemaining, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingTimeRemaining, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class MeetingStillThere {
    /**
     * Handles the "still there?" meeting check by updating the visibility of the confirmation modal.
     *
     * @param {Object} options - The options for the meeting still there check.
     * @param {Function} options.updateIsConfirmHereModalVisible - Function to update the visibility of the "still there?" modal.
     * @returns {Promise<void>} A promise that resolves when the modal visibility is updated.
     */
    meetingStillThere = ({ updateIsConfirmHereModalVisible }) => {
        // Update the visibility of the "still there?" modal
        updateIsConfirmHereModalVisible(true);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingStillThere, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingStillThere, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MeetingStillThere, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class StartRecords {
    /**
     * Starts recording the room.
     *
     * @param {Object} options - The options for starting the recording.
     * @param {string} options.roomName - The name of the room to start recording.
     * @param {string} options.member - The member starting the recording.
     * @param {Socket} options.socket - The socket instance for communication.
     *
     * @returns {Promise<void>} A promise that resolves when the recording is started.
     */
    startRecords = async ({ roomName, member, socket }) => {
        // Send the 'startRecording' event to the server with roomName and member information
        socket.emit('startRecordIng', { roomName, member }, ({ success }) => {
            // Handle the success or failure of starting recording (if needed)
            if (success) {
                console.log('Recording started successfully');
            }
            else {
                console.log('Recording failed to start');
            }
        });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartRecords, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartRecords, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StartRecords, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ReInitiateRecording {
    /**
     * Re-initiates recording based on specific conditions.
     * @async
     * @function
     * @param {ReInitiateRecordingOptions} options - The options for re-initiating recording.
     * @param {string} options.roomName - The name of the room to re-initiate recording.
     * @param {string} options.member - The member re-initiating the recording.
     * @param {Socket} options.socket - The socket instance for communication.
     * @param {boolean} options.adminRestrictSetting - Indicates whether the admin restrict setting is enabled.
     * @returns {Promise<void>} A promise that resolves when the recording is re-initiated.
     */
    reInitiateRecording = async ({ roomName, member, socket, adminRestrictSetting, }) => {
        if (!adminRestrictSetting) {
            await new Promise((resolve, reject) => {
                socket.emit('startRecordIng', { roomName, member }, ({ success }) => {
                    if (success) {
                        resolve();
                    }
                    else {
                        reject(new Error('Failed to re-initiate recording.'));
                    }
                });
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReInitiateRecording, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReInitiateRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ReInitiateRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle domain-related operations.
 *
 * @class
 * @name GetDomains
 * @description This service provides a method to retrieve and process domains.
 *
 * @method
 * @name getDomains
 * @async
 * @param {Object} options - The options for retrieving domains.
 * @param {string[]} options.domains - The list of domains to process.
 * @param {Object} options.alt_domains - An object mapping domains to alternative domains.
 * @param {string} options.apiUserName - The API username for authentication.
 * @param {string} options.apiKey - The API key for authentication.
 * @param {string} options.apiToken - The API token for authentication.
 * @param {Object} options.parameters - Additional parameters for the operation.
 * @param {string[]} options.parameters.roomRecvIPs - The list of IPs currently in the room.
 * @param {Function} options.parameters.getUpdatedAllParams - A function to get updated parameters.
 * @param {Function} options.parameters.connectIps - A function to connect IPs.
 * @returns {Promise<void>} A promise that resolves when the operation is complete.
 * @throws {Error} Throws an error if the domain retrieval fails.
 */
class GetDomains {
    getDomains = async ({ domains, alt_domains, apiUserName, apiKey, apiToken, parameters, }) => {
        const { roomRecvIPs, connectIps } = parameters;
        const ipsToConnect = [];
        let updatedConsumeSockets = parameters.getUpdatedAllParams().consume_sockets;
        try {
            for (const domain of domains) {
                const ipToCheck = alt_domains[domain] || domain;
                // Check if the IP is already in roomRecvIPs
                if (!roomRecvIPs.includes(ipToCheck)) {
                    ipsToConnect.push(ipToCheck);
                }
            }
            const [,] = await connectIps({
                consume_sockets: updatedConsumeSockets,
                remIP: ipsToConnect,
                parameters,
                apiUserName,
                apiKey,
                apiToken,
            });
            // Handle sockets_ and ips_ if needed
        }
        catch (error) {
            console.error('Error in getDomains: ', error);
            throw new Error('Failed to retrieve domains.');
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetDomains, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetDomains, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GetDomains, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class UpdateConsumingDomains {
    /**
     * Updates the consuming domains based on the provided options.
     *
     * @param {Object} options - The options for updating the consuming domains.
     * @param {Array<string>} options.domains - The consuming domains to update.
     * @param {Object} options.alt_domains - The alternative consuming domains to update.
     * @param {string} options.apiUserName - The API username for the consuming domains.
     * @param {string} options.apiKey - The API key for the consuming domains.
     * @param {string} options.apiToken - The API token for the consuming domains.
     * @param {Object} options.parameters - The parameters for updating the consuming domains.
     * @param {Array<Participant>} options.parameters.participants - The participants to update consuming domains for.
     * @param {Array<ConsumeSocket>} options.parameters.consume_sockets - The consume sockets to update consuming domains for.
     * @param {Function} options.parameters.getDomains - Function to get the consuming domains.
     * @param {Function} options.parameters.connectIps - Function to connect IPs.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     *
     * @returns {Promise<void>} A promise that resolves when the consuming domains have been updated.
     *
     * @throws Will log an error message if an error occurs during the update process.
     */
    updateConsumingDomains = async ({ domains, alt_domains, parameters, apiUserName, apiKey, apiToken, }) => {
        let { participants, getDomains, consume_sockets, connectIps } = parameters;
        parameters = parameters.getUpdatedAllParams();
        consume_sockets = parameters.consume_sockets;
        console.log('Updating consuming domains...');
        try {
            // Check if participants array is not empty
            if (participants.length > 0) {
                // Check if alt_domains has keys and remove duplicates
                if (Object.keys(alt_domains).length > 0) {
                    console.log('Getting domains...');
                    await getDomains({ domains, alt_domains, apiUserName, apiKey, apiToken, parameters });
                }
                else {
                    await connectIps({
                        consume_sockets,
                        remIP: domains,
                        parameters,
                        apiUserName,
                        apiKey,
                        apiToken,
                    });
                }
            }
        }
        catch (error) {
            console.log('Error in updateConsumingDomains: ', error);
            // throw new Error('Failed to update consuming domains.');
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateConsumingDomains, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateConsumingDomains, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: UpdateConsumingDomains, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Plays a sound from a given URL.
 * @class
 * @implements {OnInit}
 * @param {string} soundUrl - The URL of the sound to play.
 * @returns {void}
 * @example
 * const soundUrl = 'https://example.com/sound.mp3';
 * const soundPlayer = new SoundPlayer();
 * soundPlayer.playSound({ soundUrl });
 */
class SoundPlayer {
    soundUrl;
    ngOnInit() {
        const shouldPlaySound = true;
        if (shouldPlaySound) {
            if (this.soundUrl) {
                this.playSound({ soundUrl: this.soundUrl });
            }
            else {
                console.log('Sound URL is not defined');
            }
        }
    }
    playSound({ soundUrl }) {
        const audio = new Audio(soundUrl);
        audio.play().catch((error) => console.error('Error playing sound:', error));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SoundPlayer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SoundPlayer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: SoundPlayer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], propDecorators: { soundUrl: [{
                type: Input
            }] } });

class RecordingNotice {
    SoundPlayerService;
    constructor(SoundPlayerService) {
        this.SoundPlayerService = SoundPlayerService;
    }
    /**
     * Handles the recording notice state and updates various recording parameters accordingly.
     *
     * @param {Object} options - The options object.
     * @param {string} options.state - The current state of the recording (e.g., "pause", "stop").
     * @param {Object} options.userRecordingParam - The user recording parameters.
     * @param {number} options.pauseCount - The count of pauses during the recording.
     * @param {number} options.timeDone - The elapsed time of the recording.
     * @param {Object} options.parameters - The parameters object containing various update functions and state variables.
     * @param {string} options.parameters.islevel - The level of the recording.
     * @param {Object} options.parameters.userRecordingParams - The user recording parameters.
     * @param {number} options.parameters.pauseRecordCount - The count of pauses during the recording.
     * @param {number} options.parameters.recordElapsedTime - The elapsed time of the recording.
     * @param {number} options.parameters.recordStartTime - The start time of the recording.
     * @param {boolean} options.parameters.recordStarted - Indicates if the recording has started.
     * @param {boolean} options.parameters.recordPaused - Indicates if the recording is paused.
     * @param {boolean} options.parameters.canLaunchRecord - Indicates if the recording can be launched.
     * @param {boolean} options.parameters.stopLaunchRecord - Indicates if the recording launch should be stopped.
     * @param {boolean} options.parameters.recordStopped - Indicates if the recording is stopped.
     * @param {boolean} options.parameters.isTimerRunning - Indicates if the timer is running.
     * @param {boolean} options.parameters.canPauseResume - Indicates if the recording can be paused or resumed.
     * @param {string} options.parameters.eventType - The type of event triggering the recording notice.
     * @param {Function} options.parameters.updateRecordingProgressTime - Function to update the recording progress time.
     * @param {Function} options.parameters.updateShowRecordButtons - Function to update the visibility of record buttons.
     * @param {Function} options.parameters.updateUserRecordingParams - Function to update user recording parameters.
     * @param {Function} options.parameters.updateRecordingMediaOptions - Function to update recording media options.
     * @param {Function} options.parameters.updateRecordingAudioOptions - Function to update recording audio options.
     * @param {Function} options.parameters.updateRecordingVideoOptions - Function to update recording video options.
     * @param {Function} options.parameters.updateRecordingVideoType - Function to update recording video type.
     * @param {Function} options.parameters.updateRecordingVideoOptimized - Function to update recording video optimization.
     * @param {Function} options.parameters.updateRecordingDisplayType - Function to update recording display type.
     * @param {Function} options.parameters.updateRecordingAddHLS - Function to update HLS addition in recording.
     * @param {Function} options.parameters.updateRecordingNameTags - Function to update recording name tags.
     * @param {Function} options.parameters.updateRecordingBackgroundColor - Function to update recording background color.
     * @param {Function} options.parameters.updateRecordingNameTagsColor - Function to update recording name tags color.
     * @param {Function} options.parameters.updateRecordingOrientationVideo - Function to update recording orientation video.
     * @param {Function} options.parameters.updateRecordingAddText - Function to update recording text addition.
     * @param {Function} options.parameters.updateRecordingCustomText - Function to update custom text in recording.
     * @param {Function} options.parameters.updateRecordingCustomTextPosition - Function to update custom text position.
     * @param {Function} options.parameters.updateRecordingCustomTextColor - Function to update custom text color.
     * @param {Function} options.parameters.updatePauseRecordCount - Function to update pause record count.
     * @param {Function} options.parameters.updateRecordElapsedTime - Function to update record elapsed time.
     * @param {Function} options.parameters.updateRecordStartTime - Function to update record start time.
     * @param {Function} options.parameters.updateRecordStarted - Function to update record started status.
     * @param {Function} options.parameters.updateRecordPaused - Function to update record paused status.
     * @param {Function} options.parameters.updateCanLaunchRecord - Function to update can launch record status.
     * @param {Function} options.parameters.updateStopLaunchRecord - Function to update stop launch record status.
     * @param {Function} options.parameters.updateRecordStopped - Function to update record stopped status.
     * @param {Function} options.parameters.updateIsTimerRunning - Function to update timer running status.
     * @param {Function} options.parameters.updateCanPauseResume - Function to update can pause/resume status.
     * @param {Function} options.parameters.updateRecordState - Function to update the record state.
     *
     * @returns {Promise<void>} A promise that resolves when the recording notice handling is complete.
     *
     * @throws {Error} Throws an error if handling the recording state and status fails.
     */
    RecordingNotice = async ({ state, userRecordingParam, pauseCount, timeDone, parameters, }) => {
        let { islevel, userRecordingParams, pauseRecordCount, recordElapsedTime, recordStartTime, recordStarted, recordPaused, canLaunchRecord, stopLaunchRecord, recordStopped, isTimerRunning, canPauseResume, eventType, updateRecordingProgressTime, updateShowRecordButtons, updateUserRecordingParams, updateRecordingMediaOptions, updateRecordingAudioOptions, updateRecordingVideoOptions, updateRecordingVideoType, updateRecordingVideoOptimized, updateRecordingDisplayType, updateRecordingAddHLS, updateRecordingNameTags, updateRecordingBackgroundColor, updateRecordingNameTagsColor, updateRecordingOrientationVideo, updateRecordingAddText, updateRecordingCustomText, updateRecordingCustomTextPosition, updateRecordingCustomTextColor, updatePauseRecordCount, updateRecordElapsedTime, updateRecordStartTime, updateRecordStarted, updateRecordPaused, updateCanLaunchRecord, updateStopLaunchRecord, updateRecordStopped, updateIsTimerRunning, updateCanPauseResume, updateRecordState, } = parameters;
        try {
            if (islevel !== '2') {
                if (state === 'pause') {
                    updateRecordStarted(true);
                    updateRecordPaused(true);
                    updateRecordState('yellow');
                    eventType !== 'broadcast' &&
                        this.SoundPlayerService.playSound({
                            soundUrl: 'https://www.mediasfu.com/sounds/record-paused.mp3',
                        });
                }
                else if (state === 'stop') {
                    updateRecordStarted(true);
                    updateRecordStopped(true);
                    updateRecordState('green');
                    eventType !== 'broadcast' &&
                        this.SoundPlayerService.playSound({
                            soundUrl: 'https://www.mediasfu.com/sounds/record-stopped.mp3',
                        });
                }
                else {
                    updateRecordState('red');
                    updateRecordStarted(true);
                    updateRecordPaused(false);
                    eventType !== 'broadcast' &&
                        this.SoundPlayerService.playSound({
                            soundUrl: 'https://www.mediasfu.com/sounds/record-progress.mp3',
                        });
                }
            }
            else {
                if (state === 'pause') {
                    updateRecordState('yellow');
                    if (userRecordingParam) {
                        userRecordingParams.mainSpecs = userRecordingParam.mainSpecs;
                        userRecordingParams.dispSpecs = userRecordingParam.dispSpecs;
                        userRecordingParams.textSpecs = userRecordingParam.textSpecs;
                        updateUserRecordingParams(userRecordingParams);
                        updateRecordingMediaOptions(userRecordingParams.mainSpecs.mediaOptions);
                        updateRecordingAudioOptions(userRecordingParams.mainSpecs.audioOptions);
                        updateRecordingVideoOptions(userRecordingParams.mainSpecs.videoOptions);
                        updateRecordingVideoType(userRecordingParams.mainSpecs.videoType);
                        updateRecordingVideoOptimized(userRecordingParams.mainSpecs.videoOptimized);
                        updateRecordingDisplayType(userRecordingParams.mainSpecs.recordingDisplayType);
                        updateRecordingAddHLS(userRecordingParams.mainSpecs.addHLS);
                        updateRecordingNameTags(userRecordingParams.dispSpecs.nameTags);
                        updateRecordingBackgroundColor(userRecordingParams.dispSpecs.backgroundColor);
                        updateRecordingNameTagsColor(userRecordingParams.dispSpecs.nameTagsColor);
                        updateRecordingOrientationVideo(userRecordingParams.dispSpecs.orientationVideo);
                        updateRecordingAddText(userRecordingParams.textSpecs?.addText ?? false);
                        updateRecordingCustomText(userRecordingParams.textSpecs?.customText ?? '');
                        updateRecordingCustomTextPosition(userRecordingParams.textSpecs?.customTextPosition ?? '');
                        updateRecordingCustomTextColor(userRecordingParams.textSpecs?.customTextColor ?? '');
                        pauseRecordCount = pauseCount;
                        updatePauseRecordCount(pauseRecordCount);
                        recordElapsedTime = timeDone;
                        recordElapsedTime = Math.floor(recordElapsedTime / 1000);
                        recordStartTime = Math.floor(Date.now() / 1000) - recordElapsedTime;
                        updateRecordStartTime(recordStartTime);
                        updateRecordElapsedTime(recordElapsedTime);
                        recordStarted = true;
                        recordPaused = true;
                        canLaunchRecord = false;
                        recordStopped = false;
                        updateRecordStarted(recordStarted);
                        updateRecordPaused(recordPaused);
                        updateCanLaunchRecord(canLaunchRecord);
                        updateRecordStopped(recordStopped);
                        updateShowRecordButtons(true);
                        isTimerRunning = false;
                        canPauseResume = true;
                        updateIsTimerRunning(isTimerRunning);
                        updateCanPauseResume(canPauseResume);
                        const formattedTime = this.formatElapsedTime(recordElapsedTime);
                        updateRecordingProgressTime(formattedTime);
                    }
                    this.SoundPlayerService.playSound({
                        soundUrl: 'https://www.mediasfu.com/sounds/record-paused.mp3',
                    });
                }
                else if (state === 'stop') {
                    updateRecordStarted(true);
                    updateRecordStopped(true);
                    canLaunchRecord = false;
                    stopLaunchRecord = true;
                    updateRecordStarted(recordStarted);
                    updateRecordStopped(recordStopped);
                    updateCanLaunchRecord(canLaunchRecord);
                    updateStopLaunchRecord(stopLaunchRecord);
                    updateShowRecordButtons(false);
                    updateRecordState('green');
                    this.SoundPlayerService.playSound({
                        soundUrl: 'https://www.mediasfu.com/sounds/record-stopped.mp3',
                    });
                }
                else {
                    updateRecordState('red');
                    updateRecordStarted(true);
                    updateRecordPaused(false);
                    this.SoundPlayerService.playSound({
                        soundUrl: 'https://www.mediasfu.com/sounds/record-progress.mp3',
                    });
                }
            }
        }
        catch (error) {
            console.log('Error in RecordingNotice: ', error);
            // throw new Error("Failed to handle recording state and status.");
        }
    };
    formatElapsedTime = (recordElapsedTime) => {
        const hours = Math.floor(recordElapsedTime / 3600);
        const minutes = Math.floor((recordElapsedTime % 3600) / 60);
        const seconds = recordElapsedTime % 60;
        return `${this.padNumber(hours)}:${this.padNumber(minutes)}:${this.padNumber(seconds)}`;
    };
    padNumber = (number) => {
        return number.toString().padStart(2, '0');
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordingNotice, deps: [{ token: SoundPlayer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordingNotice, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordingNotice, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: SoundPlayer }] });

class TimeLeftRecording {
    /**
     * Displays an alert message indicating the remaining time left for recording.
     *
     * @param {TimeLeftRecordingOptions} options - The options for the time left recording.
     * @param {number} options.timeLeft - The amount of time left in seconds.
     * @param {Function} options.showAlert - The function to display the alert message.
     *
     * @throws {Error} If there is an issue displaying the alert message.
     */
    timeLeftRecording = ({ timeLeft, showAlert }) => {
        try {
            // Display alert message
            showAlert?.({
                message: `The recording will stop in less than ${timeLeft} seconds.`,
                duration: 3000,
                type: 'danger',
            });
        }
        catch (error) {
            console.log('Error in timeLeftRecording: ', error);
            // throw new Error("Failed to display the time left alert message.");
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: TimeLeftRecording, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: TimeLeftRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: TimeLeftRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class StoppedRecording {
    /**
     * Displays an alert message when the recording has stopped.
     *
     * @param {Object} options - The options for displaying the alert message.
     * @param {string} options.state - The state of the recording.
     * @param {string} options.reason - The reason for stopping the recording.
     * @param {Function} options.showAlert - Function to show alerts.
     * @returns {Promise<void>} A promise that resolves when the alert message is displayed.
     */
    stoppedRecording = async ({ state, reason, showAlert, }) => {
        try {
            if (state === 'stop') {
                showAlert?.({
                    message: `The recording has stopped - ${reason}.`,
                    duration: 3000,
                    type: 'danger',
                });
            }
        }
        catch (error) {
            console.error('Error in stoppedRecording: ', error);
            // throw new Error("Failed to display the recording stopped alert message.");
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StoppedRecording, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StoppedRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: StoppedRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle host request responses.
 *
 * @example
 * ```typescript
 * const hostRequestResponseService = new HostRequestResponse();
 * await hostRequestResponseService.hostRequestResponse({
 *   requestResponse: { id: '1', type: 'fa-microphone', name: 'John Doe', username: 'johndoe', action: 'accepted' },
 *   showAlert: (alert) => console.log(alert),
 *   requestList: [],
 *   updateRequestList: (list) => console.log(list),
 *   updateMicAction: (state) => console.log(state),
 *   updateVideoAction: (state) => console.log(state),
 *   updateScreenAction: (state) => console.log(state),
 *   updateChatAction: (state) => console.log(state),
 *   updateAudioRequestState: (state) => console.log(state),
 *   updateVideoRequestState: (state) => console.log(state),
 *   updateScreenRequestState: (state) => console.log(state),
 *   updateChatRequestState: (state) => console.log(state),
 *   updateAudioRequestTime: (time) => console.log(time),
 *   updateVideoRequestTime: (time) => console.log(time),
 *   updateScreenRequestTime: (time) => console.log(time),
 *   updateChatRequestTime: (time) => console.log(time),
 *   updateRequestIntervalSeconds: 30,
 * });
 * ```
 *
 * @typedef {Object} HostRequestResponseOptions
 * @property {Object} requestResponse - The request response object.
 * @property {Function} showAlert - Function to show alert messages.
 * @property {Array} requestList - List of current requests.
 * @property {Function} updateRequestList - Function to update the request list.
 * @property {Function} updateMicAction - Function to update microphone action state.
 * @property {Function} updateVideoAction - Function to update video action state.
 * @property {Function} updateScreenAction - Function to update screen action state.
 * @property {Function} updateChatAction - Function to update chat action state.
 * @property {Function} updateAudioRequestState - Function to update audio request state.
 * @property {Function} updateVideoRequestState - Function to update video request state.
 * @property {Function} updateScreenRequestState - Function to update screen request state.
 * @property {Function} updateChatRequestState - Function to update chat request state.
 * @property {Function} updateAudioRequestTime - Function to update audio request time.
 * @property {Function} updateVideoRequestTime - Function to update video request time.
 * @property {Function} updateScreenRequestTime - Function to update screen request time.
 * @property {Function} updateChatRequestTime - Function to update chat request time.
 * @property {number} updateRequestIntervalSeconds - Interval in seconds to update request time.
 *
 * @class
 * @classdesc This service handles the responses to host requests, updating the state and showing alerts based on the response.
 *
 * @method hostRequestResponse
 * @async
 * @param {HostRequestResponseOptions} options - The options for handling the host request response.
 * @returns {Promise<void>} A promise that resolves when the request response has been handled.
 */
class HostRequestResponse {
    hostRequestResponse = async ({ requestResponse, showAlert, requestList, updateRequestList, updateMicAction, updateVideoAction, updateScreenAction, updateChatAction, updateAudioRequestState, updateVideoRequestState, updateScreenRequestState, updateChatRequestState, updateAudioRequestTime, updateVideoRequestTime, updateScreenRequestTime, updateChatRequestTime, updateRequestIntervalSeconds, }) => {
        // Filter out the request from the list
        const filteredRequests = requestList.filter((request) => request.id !== requestResponse.id &&
            request.icon !== requestResponse.type &&
            request.name !== requestResponse.name &&
            request.username !== requestResponse.username);
        updateRequestList(filteredRequests);
        const requestType = requestResponse.type;
        // Handle accepted actions
        if (requestResponse.action === 'accepted') {
            switch (requestType) {
                case 'fa-microphone':
                    showAlert?.({
                        message: 'Unmute request was accepted; click the mic button again to begin.',
                        type: 'success',
                        duration: 10000,
                    });
                    updateMicAction(true);
                    updateAudioRequestState('accepted');
                    break;
                case 'fa-video':
                    showAlert?.({
                        message: 'Video request was accepted; click the video button again to begin.',
                        type: 'success',
                        duration: 10000,
                    });
                    updateVideoAction(true);
                    updateVideoRequestState('accepted');
                    break;
                case 'fa-desktop':
                    showAlert?.({
                        message: 'Screenshare request was accepted; click the screen button again to begin.',
                        type: 'success',
                        duration: 10000,
                    });
                    updateScreenAction(true);
                    updateScreenRequestState('accepted');
                    break;
                case 'fa-comments':
                    showAlert?.({
                        message: 'Chat request was accepted; click the chat button again to begin.',
                        type: 'success',
                        duration: 10000,
                    });
                    updateChatAction(true);
                    updateChatRequestState('accepted');
                    break;
            }
        }
        else {
            // Handle rejected actions
            let timerDate;
            switch (requestType) {
                case 'fa-microphone':
                    showAlert?.({
                        message: 'Unmute request was not accepted',
                        type: 'danger',
                        duration: 10000,
                    });
                    updateAudioRequestState('rejected');
                    timerDate = new Date();
                    timerDate.setSeconds(timerDate.getSeconds() + updateRequestIntervalSeconds);
                    updateAudioRequestTime(timerDate.getTime());
                    break;
                case 'fa-video':
                    showAlert?.({
                        message: 'Video request was not accepted',
                        type: 'danger',
                        duration: 10000,
                    });
                    updateVideoRequestState('rejected');
                    timerDate = new Date();
                    timerDate.setSeconds(timerDate.getSeconds() + updateRequestIntervalSeconds);
                    updateVideoRequestTime(timerDate.getTime());
                    break;
                case 'fa-desktop':
                    showAlert?.({
                        message: 'Screenshare request was not accepted',
                        type: 'danger',
                        duration: 10000,
                    });
                    updateScreenRequestState('rejected');
                    timerDate = new Date();
                    timerDate.setSeconds(timerDate.getSeconds() + updateRequestIntervalSeconds);
                    updateScreenRequestTime(timerDate.getTime());
                    break;
                case 'fa-comments':
                    showAlert?.({
                        message: 'Chat request was not accepted',
                        type: 'danger',
                        duration: 10000,
                    });
                    updateChatRequestState('rejected');
                    timerDate = new Date();
                    timerDate.setSeconds(timerDate.getSeconds() + updateRequestIntervalSeconds);
                    updateChatRequestTime(timerDate.getTime());
                    break;
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HostRequestResponse, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HostRequestResponse, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: HostRequestResponse, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class AllMembers {
    /**
     * allMembers - A method for handling various tasks related to participant management and UI updates.
     * @param {Object} params - The parameters passed to the allMembers method.
     * @param {Array} params.members - The array of participant members.
     * @param {Array} params.requestss - The array of requests.
     * @param {boolean} params.coHoste - The co-host state.
     * @param {boolean} params.coHostRes - The co-host responsibility state.
     * @param {Object} params.parameters - The object containing parameters for the allMembers method.
     * @param {Array} params.consume_sockets - The array of consume sockets.
     * @param {string} params.apiUserName - The API username.
     * @param {string} params.apiKey - The API key.
     * @param {string} params.apiToken - The API token.
     * @returns {void} - No return value.
     */
    allMembers = async ({ members, requestss, coHoste, coHostRes, parameters, consume_sockets, apiUserName, apiKey, apiToken, }) => {
        let { participantsAll, participants, dispActiveNames, requestList, coHost, coHostResponsibility, lock_screen, firstAll, membersReceived, roomRecvIPs, deferScreenReceived, screenId, shareScreenStarted, meetingDisplayType, hostFirstSwitch, waitingRoomList, islevel, updateParticipantsAll, updateParticipants, updateRequestList, updateCoHost, updateCoHostResponsibility, updateFirstAll, updateMembersReceived, updateDeferScreenReceived, updateShareScreenStarted, updateHostFirstSwitch, updateConsume_sockets, updateRoomRecvIPs, updateIsLoadingModalVisible, updateTotalReqWait, onScreenChanges, connectIps, reorderStreams, sleep, } = parameters;
        // Filter out the participant that isBanned == true or isSuspended == true
        participantsAll = members.map((participant) => ({
            isBanned: participant.isBanned,
            isSuspended: participant.isSuspended,
            name: participant.name,
            audioID: participant.audioID,
            videoID: participant.videoID,
        }));
        updateParticipantsAll(participantsAll);
        participants = members.filter((participant) => !participant.isBanned && !participant.isSuspended);
        updateParticipants(participants);
        // Check if dispActiveNames is not empty and contains the name of the participant that is not in the participants array
        if (dispActiveNames.length > 0) {
            let dispActiveNames_ = dispActiveNames.filter((name) => !participants.map((participant) => participant.name).includes(name));
            if (dispActiveNames_.length > 0) {
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
        // Operations to update the UI; make sure we are connected to the server before updating the UI
        if (!membersReceived) {
            if (roomRecvIPs.length < 1) {
                // Keep checking every 0.01s
                let checkIPs = setInterval(async () => {
                    if (roomRecvIPs.length > 0) {
                        clearInterval(checkIPs);
                        if (deferScreenReceived && screenId != null) {
                            shareScreenStarted = true;
                            updateShareScreenStarted(shareScreenStarted);
                        }
                        const [sockets_, ips_] = await connectIps({
                            consume_sockets,
                            remIP: roomRecvIPs,
                            parameters,
                            apiUserName,
                            apiKey,
                            apiToken,
                        });
                        if (sockets_ && ips_) {
                            updateConsume_sockets(sockets_);
                            updateRoomRecvIPs(ips_);
                        }
                        membersReceived = true;
                        updateMembersReceived(membersReceived);
                        await sleep({ ms: 250 });
                        updateIsLoadingModalVisible(false);
                        deferScreenReceived = false;
                        updateDeferScreenReceived(deferScreenReceived);
                    }
                }, 10);
            }
            else {
                const [sockets_, ips_] = await connectIps({
                    consume_sockets,
                    remIP: roomRecvIPs,
                    parameters,
                    apiUserName,
                    apiKey,
                    apiToken,
                });
                if (sockets_ && ips_) {
                    updateConsume_sockets(sockets_);
                    updateRoomRecvIPs(ips_);
                }
                membersReceived = true;
                updateMembersReceived(membersReceived);
                if (deferScreenReceived && screenId != null) {
                    shareScreenStarted = true;
                    updateShareScreenStarted(shareScreenStarted);
                }
                await sleep({ ms: 250 });
                updateIsLoadingModalVisible(false);
                deferScreenReceived = false;
                updateDeferScreenReceived(deferScreenReceived);
            }
        }
        else {
            if (screenId != null) {
                let host = participants.find((participant) => participant.ScreenID == screenId && participant.ScreenOn == true);
                if (deferScreenReceived && screenId != null && host) {
                    shareScreenStarted = true;
                    updateShareScreenStarted(shareScreenStarted);
                }
            }
        }
        // Return requests for only ids that are in the participants array and update the count badge
        requestList = requestss.filter((request) => participants.some((participant) => participant.id == request.id));
        updateRequestList(requestList);
        updateTotalReqWait(requestList.length + waitingRoomList.length);
        if (coHoste !== undefined && coHoste !== null) {
            coHost = coHoste;
        }
        updateCoHost(coHost);
        if (coHostRes) {
            coHostResponsibility = coHostRes;
        }
        updateCoHostResponsibility(coHostResponsibility);
        try {
            if (!lock_screen && !firstAll) {
                await onScreenChanges({ parameters });
                if (meetingDisplayType != 'all') {
                    firstAll = true;
                    updateFirstAll(firstAll);
                }
            }
            else {
                if (islevel == '2') {
                    if (!hostFirstSwitch) {
                        await onScreenChanges({ parameters });
                        hostFirstSwitch = true; // Get self display
                        updateHostFirstSwitch(hostFirstSwitch);
                    }
                }
            }
        }
        catch (error) {
            console.log('allMembers OnScreen', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AllMembers, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AllMembers, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AllMembers, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class AllMembersRest {
    /**
     * Handles various tasks related to participant management and UI updates.
     * @param {Object} params - The parameters passed to the allMembersRest method.
     * @param {Array} params.members - The array of participant members.
     * @param {Array} params.settings - The array of settings.
     * @param {boolean} params.coHoste - The co-host state.
     * @param {boolean} params.coHostRes - The co-host responsibility state.
     * @param {Object} params.parameters - The object containing parameters for the allMembersRest method.
     * @param {Array} params.consume_sockets - The array of consume sockets.
     * @param {string} params.apiUserName - The API username.
     * @param {string} params.apiKey - The API key.
     * @param {string} params.apiToken - The API token.
     * @returns {void} - No return value.
     */
    async allMembersRest({ members, settings, coHoste, coHostRes, parameters, consume_sockets, apiUserName, apiKey, apiToken, }) {
        let { participantsAll, participants, dispActiveNames, requestList, coHost, coHostResponsibility, lock_screen, firstAll, membersReceived, roomRecvIPs, deferScreenReceived, screenId, shareScreenStarted, meetingDisplayType, audioSetting, videoSetting, screenshareSetting, chatSetting, updateParticipantsAll, updateParticipants, updateRequestList, updateCoHost, updateCoHostResponsibility, updateFirstAll, updateMembersReceived, updateDeferScreenReceived, updateShareScreenStarted, updateAudioSetting, updateVideoSetting, updateScreenshareSetting, updateChatSetting, updateConsume_sockets, updateRoomRecvIPs, updateIsLoadingModalVisible, onScreenChanges, connectIps, reorderStreams, sleep, } = parameters;
        // Filter out the participant that isBanned == true or isSuspended == true
        participantsAll = members.map((participant) => ({
            isBanned: participant.isBanned,
            isSuspended: participant.isSuspended,
            name: participant.name,
            audioID: participant.audioID,
            videoID: participant.videoID,
        }));
        updateParticipantsAll(participantsAll);
        participants = members.filter((participant) => !participant.isBanned && !participant.isSuspended);
        updateParticipants(participants);
        // Check if dispActiveNames is not empty and contains the name of the participant that is not in the participants array
        if (dispActiveNames.length > 0) {
            let dispActiveNames_ = dispActiveNames.filter((name) => !participants.map((participant) => participant.name).includes(name));
            if (dispActiveNames_.length > 0 && membersReceived) {
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
        // Operations to update the UI; make sure we are connected to the server before updating the UI
        if (!membersReceived) {
            if (roomRecvIPs.length < 1) {
                // Keep checking every 0.01s
                let checkIPs = setInterval(async () => {
                    if (roomRecvIPs.length > 0) {
                        clearInterval(checkIPs);
                        if (deferScreenReceived && screenId != null) {
                            shareScreenStarted = true;
                            updateShareScreenStarted(shareScreenStarted);
                        }
                        const [sockets_, ips_] = await connectIps({
                            consume_sockets,
                            remIP: roomRecvIPs,
                            parameters,
                            apiUserName,
                            apiKey,
                            apiToken,
                        });
                        if (sockets_ && ips_) {
                            updateConsume_sockets(sockets_);
                            updateRoomRecvIPs(ips_);
                        }
                        membersReceived = true;
                        updateMembersReceived(membersReceived);
                        await sleep({ ms: 250 });
                        updateIsLoadingModalVisible(false);
                        deferScreenReceived = false;
                        updateDeferScreenReceived(deferScreenReceived);
                    }
                }, 10);
            }
            else {
                const [sockets_, ips_] = await connectIps({
                    consume_sockets,
                    remIP: roomRecvIPs,
                    parameters,
                    apiUserName,
                    apiKey,
                    apiToken,
                });
                if (sockets_ && ips_) {
                    updateConsume_sockets(sockets_);
                    updateRoomRecvIPs(ips_);
                }
                membersReceived = true;
                updateMembersReceived(membersReceived);
                if (deferScreenReceived && screenId != null) {
                    shareScreenStarted = true;
                    updateShareScreenStarted(shareScreenStarted);
                }
                await sleep({ ms: 250 });
                updateIsLoadingModalVisible(false);
                deferScreenReceived = false;
                updateDeferScreenReceived(deferScreenReceived);
            }
        }
        else {
            if (screenId != null) {
                let host = participants.find((participant) => participant.ScreenID == screenId && participant.ScreenOn == true);
                if (deferScreenReceived && screenId != null && host) {
                    shareScreenStarted = true;
                    updateShareScreenStarted(shareScreenStarted);
                }
            }
        }
        // Return requests for only ids that are in the participants array and update the count badge
        let requests = requestList;
        requestList = requests.filter((request) => participants.some((participant) => participant.id == request.id));
        updateRequestList(requestList);
        if (coHoste !== undefined && coHoste !== null) {
            coHost = coHoste;
        }
        if (coHost !== undefined && coHost !== null) {
            updateCoHost(coHost);
        }
        if (coHostRes !== undefined && coHostRes !== null) {
            coHostResponsibility = coHostRes;
        }
        updateCoHostResponsibility(coHostResponsibility);
        try {
            if (!lock_screen && !firstAll) {
                await onScreenChanges({ parameters });
                if (meetingDisplayType != 'all') {
                    firstAll = true;
                    updateFirstAll(firstAll);
                }
            }
        }
        catch (error) {
            console.log('allMembersRest OnScreen', error);
        }
        try {
            if (membersReceived) {
                audioSetting = settings[0];
                videoSetting = settings[1];
                screenshareSetting = settings[2];
                chatSetting = settings[3];
                updateAudioSetting(audioSetting);
                updateVideoSetting(videoSetting);
                updateScreenshareSetting(screenshareSetting);
                updateChatSetting(chatSetting);
            }
        }
        catch (error) {
            console.log('allMembersRest Settings', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AllMembersRest, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AllMembersRest, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: AllMembersRest, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class Disconnect {
    /**
     * Handles the disconnection logic by either redirecting to a specified URL or showing an alert.
     *
     * @param {DisconnectOptions} options - The options for handling disconnection.
     * @param {Function} options.showAlert - Function to display an alert message.
     * @param {string} options.redirectURL - URL to redirect to if on the web.
     * @param {boolean} options.onWeb - Flag indicating if the operation is on the web.
     * @returns {Promise<void>} A promise that resolves when the disconnection handling is complete.
     */
    disconnect = async ({ showAlert, redirectURL, onWeb }) => {
        // Redirect to the specified URL on the web
        if (onWeb && redirectURL) {
            window.location.href = redirectURL;
        }
        else {
            // Display an alert and update the validated state
            if (showAlert) {
                showAlert({
                    message: 'You have been disconnected from the session.',
                    type: 'danger',
                    duration: 2000,
                });
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Disconnect, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Disconnect, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: Disconnect, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
// canvas.service.ts
class CaptureCanvasStream {
    /**
     * Capture the canvas stream.
     * @param {Object} parameters - The parameters object.
     * @param {boolean} [start=true] - Indicates whether to start capturing the stream.
     * @returns {Promise<void>} - A promise that resolves when the canvas stream is captured.
     */
    captureCanvasStream = async ({ parameters, start = true, }) => {
        try {
            parameters = parameters.getUpdatedAllParams();
            let { canvasWhiteboard, canvasStream, updateCanvasStream, screenProducer, transportCreated, updateScreenProducer, sleep, createSendTransport, connectSendTransportScreen, disconnectSendTransportScreen, } = parameters;
            if (start && !canvasStream) {
                // Wait for canvasWhiteboard to be available
                let attempts = 0;
                const maxAttempts = 20; // 2 seconds / 100ms intervals
                while (!canvasWhiteboard && attempts < maxAttempts) {
                    await new Promise((resolve) => setTimeout(resolve, 100));
                    parameters = parameters.getUpdatedAllParams();
                    canvasWhiteboard = parameters.canvasWhiteboard;
                    attempts++;
                }
                if (!canvasWhiteboard) {
                    throw new Error('Canvas whiteboard not available.');
                }
                const stream = canvasWhiteboard.captureStream(30);
                canvasStream = stream;
                updateCanvasStream(stream);
                if (!transportCreated) {
                    await createSendTransport({ option: 'screen', parameters });
                }
                else {
                    try {
                        screenProducer.close();
                        updateScreenProducer(null);
                        await sleep({ ms: 500 });
                    }
                    catch {
                        /* handle error */
                    }
                    await connectSendTransportScreen({ stream, parameters });
                }
            }
            else {
                if (!start && canvasStream) {
                    canvasStream.getTracks().forEach((track) => track.stop());
                    canvasStream = null;
                    updateCanvasStream(null);
                    disconnectSendTransportScreen({ parameters });
                }
            }
        }
        catch (error) {
            console.log('Error in captureCanvasStream:', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CaptureCanvasStream, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CaptureCanvasStream, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: CaptureCanvasStream, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ResumePauseAudioStreams {
    /**
     * Resumes or pauses audio streams based on the provided options.
     *
     * @param {ResumePauseAudioStreamsOptions} options - The options for resuming or pausing audio streams.
     * @param {number} [options.breakRoom=-1] - The ID of the break room.
     * @param {boolean} [options.inBreakRoom=false] - Indicates if the participant is in a break room.
     * @param {Parameters} options.parameters - The parameters required for processing audio streams.
     *
     * @returns {Promise<void>} A promise that resolves when the audio streams have been processed.
     *
     * @throws Will log an error message if there is an issue processing the audio streams.
     */
    resumePauseAudioStreams = async ({ breakRoom = -1, inBreakRoom = false, parameters, }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { breakoutRooms, ref_participants, allAudioStreams, participants, islevel, eventType, consumerTransports, hostNewRoom, member, updateLimitedBreakRoom, processConsumerTransportsAudio, } = parameters;
        let room = [];
        let currentStreams = [];
        // Determine the room based on breakout status
        if (inBreakRoom && breakRoom !== -1) {
            room = breakoutRooms[breakRoom];
        }
        else {
            room = ref_participants.filter((participant) => !breakoutRooms
                .flat()
                .map((obj) => obj.name)
                .includes(participant.name));
        }
        updateLimitedBreakRoom(room);
        try {
            let addHostAudio = false;
            if (islevel !== '2' && eventType === 'conference') {
                const roomMember = breakoutRooms.find((r) => r.find((p) => p.name === member));
                let memberBreakRoom = -1;
                if (roomMember) {
                    memberBreakRoom = breakoutRooms.indexOf(roomMember);
                }
                if ((inBreakRoom && breakRoom !== hostNewRoom) ||
                    (!inBreakRoom && hostNewRoom !== -1 && hostNewRoom !== memberBreakRoom)) {
                    const host = participants.find((obj) => obj.islevel === '2');
                    // Remove the host from the room
                    room = room.filter((participant) => participant.name !== host?.name);
                }
                else {
                    if ((inBreakRoom && breakRoom === hostNewRoom) ||
                        (!inBreakRoom && hostNewRoom === -1) ||
                        (!inBreakRoom && hostNewRoom === memberBreakRoom && memberBreakRoom !== -1)) {
                        addHostAudio = true;
                    }
                }
            }
            for (let participant of room) {
                let streams = allAudioStreams.filter((stream) => {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') && stream.producerId) ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') && stream.audioID)) {
                        let producerId = stream.producerId || stream.audioID;
                        let matchingParticipant = ref_participants.find((obj) => obj.audioID == producerId);
                        return matchingParticipant && matchingParticipant.name == participant.name;
                    }
                    // Return false if the stream doesn't meet the criteria
                    return false;
                });
                currentStreams.push(...streams);
            }
            // If webinar, add the host audio stream if it is not in the currentStreams
            if (islevel !== '2' && (eventType === 'webinar' || addHostAudio)) {
                const host = participants.find((obj) => obj.islevel === '2');
                const hostStream = allAudioStreams.find((obj) => obj.producerId === host?.audioID);
                if (hostStream && !currentStreams.includes(hostStream)) {
                    currentStreams.push(hostStream);
                    if (host?.name && !room.map((obj) => obj.name).includes(host.name)) {
                        room.push({ name: host?.name || '', breakRoom: -1 });
                    }
                    updateLimitedBreakRoom(room);
                }
            }
            await processConsumerTransportsAudio({
                consumerTransports,
                lStreams: currentStreams,
                parameters,
            });
        }
        catch (error) {
            console.log('Error in resumePauseAudioStreams:', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ResumePauseAudioStreams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ResumePauseAudioStreams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ResumePauseAudioStreams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ProcessConsumerTransportsAudio {
    /**
     * Processes consumer transports for audio streams by pausing and resuming them based on their current state and the provided streams.
     *
     * @param {Object} options - The options for processing consumer transports.
     * @param {Array} options.consumerTransports - The list of consumer transports to process.
     * @param {Array} options.lStreams - The list of local streams to check against.
     * @param {Object} options.parameters - Additional parameters for processing.
     * @param {Function} options.parameters.sleep - A function to pause execution for a specified duration.
     *
     * @returns {Promise<void>} A promise that resolves when the processing is complete.
     *
     * @throws Will throw an error if there is an issue processing the consumer transports.
     */
    processConsumerTransportsAudio = async ({ consumerTransports, lStreams, parameters, }) => {
        try {
            const { sleep } = parameters;
            // Function to check if the producerId is valid
            const isValidProducerId = (producerId, ...streamArrays) => {
                return (producerId !== null &&
                    producerId !== '' &&
                    streamArrays.some((streamArray) => {
                        return (streamArray.length > 0 &&
                            streamArray.some((stream) => stream?.producerId === producerId));
                    }));
            };
            // Get paused consumer transports that are audio
            const consumerTransportsToResume = consumerTransports.filter((transport) => isValidProducerId(transport.producerId, lStreams) &&
                transport.consumer?.paused === true &&
                transport.consumer.kind === 'audio');
            // Get unpaused consumer transports that are audio
            const consumerTransportsToPause = consumerTransports.filter((transport) => transport.producerId &&
                transport.producerId !== null &&
                transport.producerId !== '' &&
                !lStreams.some((stream) => stream.producerId === transport.producerId) &&
                transport.consumer &&
                transport.consumer.kind &&
                transport.consumer.paused !== true &&
                transport.consumer.kind === 'audio');
            await sleep({ ms: 100 });
            // Emit consumer.pause() for each transport to pause
            for (const transport of consumerTransportsToPause) {
                transport.consumer.pause();
                transport.socket_.emit('consumer-pause', { serverConsumerId: transport.serverConsumerTransportId }, async () => {
                    // Do something after the consumer is paused
                });
            }
            // Emit consumer.resume() for each transport to resume
            for (const transport of consumerTransportsToResume) {
                transport.socket_.emit('consumer-resume', { serverConsumerId: transport.serverConsumerTransportId }, async ({ resumed }) => {
                    if (resumed) {
                        transport.consumer.resume();
                    }
                });
            }
        }
        catch (error) {
            console.log(`Error in processConsumerTransportsAudio: ${error.message}`);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProcessConsumerTransportsAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProcessConsumerTransportsAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ProcessConsumerTransportsAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class MenuWidget {
    icon;
    iconColor = 'black';
    badgeValue;
    showBadge = false;
    constructor(icon, iconColor, badgeValue, showBadge) {
        this.icon = icon;
        this.iconColor = iconColor;
        this.badgeValue = badgeValue;
        this.showBadge = showBadge;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MenuWidget, deps: [{ token: 'icon' }, { token: 'iconColor' }, { token: 'badgeValue' }, { token: 'showBadge' }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MenuWidget, isStandalone: true, selector: "app-menu-widget", inputs: { icon: "icon", iconColor: "iconColor", badgeValue: "badgeValue", showBadge: "showBadge" }, ngImport: i0, template: `
    <div style="position: relative; display: inline-block;">
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <div
        style="
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      align-items: center;
      justify-content: center;
    "
      >
        <div
          style="
        background-color: red;
        border-radius: 8px;
        padding: 4px 8px;
        min-width: 16px; /* Ensure a minimum width for consistent circular shape */
        min-height: 16px; /* Ensure a minimum height for consistent circular shape */
        display: flex;
        align-items: center;
        justify-content: center;
      "
          *ngIf="showBadge"
        >
          <span style="color: white; font-size: 8px; font-weight: bold;">
            {{ badgeValue }}
          </span>
        </div>
      </div>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MenuWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-menu-widget',
                    standalone: true,
                    template: `
    <div style="position: relative; display: inline-block;">
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <div
        style="
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      align-items: center;
      justify-content: center;
    "
      >
        <div
          style="
        background-color: red;
        border-radius: 8px;
        padding: 4px 8px;
        min-width: 16px; /* Ensure a minimum width for consistent circular shape */
        min-height: 16px; /* Ensure a minimum height for consistent circular shape */
        display: flex;
        align-items: center;
        justify-content: center;
      "
          *ngIf="showBadge"
        >
          <span style="color: white; font-size: 8px; font-weight: bold;">
            {{ badgeValue }}
          </span>
        </div>
      </div>
    </div>
  `,
                    imports: [CommonModule, FontAwesomeModule],
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['icon']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['iconColor']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['badgeValue']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['showBadge']
                }] }], propDecorators: { icon: [{
                type: Input
            }], iconColor: [{
                type: Input
            }], badgeValue: [{
                type: Input
            }], showBadge: [{
                type: Input
            }] } });

class MessageWidget {
    icon;
    iconColor = 'black';
    badgeValue;
    showBadge = false;
    constructor(icon, iconColor, badgeValue, showBadge) {
        this.icon = icon;
        this.iconColor = iconColor;
        this.badgeValue = badgeValue;
        this.showBadge = showBadge;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MessageWidget, deps: [{ token: 'icon' }, { token: 'iconColor' }, { token: 'badgeValue' }, { token: 'showBadge' }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MessageWidget, isStandalone: true, selector: "app-message-widget", inputs: { icon: "icon", iconColor: "iconColor", badgeValue: "badgeValue", showBadge: "showBadge" }, ngImport: i0, template: `
    <div style="position: relative; display: inline-block;">
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <div
        style="
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      align-items: center;
      justify-content: center;
    "
      >
        <div
          style="
        background-color: red;
        border-radius: 8px;
        padding: 4px 8px;
        min-width: 16px; /* Ensure a minimum width for consistent circular shape */
        min-height: 16px; /* Ensure a minimum height for consistent circular shape */
        display: flex;
        align-items: center;
        justify-content: center;
      "
          *ngIf="showBadge"
        >
          <span style="color: white; font-size: 8px; font-weight: bold;">
            {{ badgeValue }}
          </span>
        </div>
      </div>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MessageWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-message-widget',
                    standalone: true,
                    template: `
    <div style="position: relative; display: inline-block;">
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <div
        style="
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      align-items: center;
      justify-content: center;
    "
      >
        <div
          style="
        background-color: red;
        border-radius: 8px;
        padding: 4px 8px;
        min-width: 16px; /* Ensure a minimum width for consistent circular shape */
        min-height: 16px; /* Ensure a minimum height for consistent circular shape */
        display: flex;
        align-items: center;
        justify-content: center;
      "
          *ngIf="showBadge"
        >
          <span style="color: white; font-size: 8px; font-weight: bold;">
            {{ badgeValue }}
          </span>
        </div>
      </div>
    </div>
  `,
                    imports: [CommonModule, FontAwesomeModule],
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['icon']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['iconColor']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['badgeValue']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['showBadge']
                }] }], propDecorators: { icon: [{
                type: Input
            }], iconColor: [{
                type: Input
            }], badgeValue: [{
                type: Input
            }], showBadge: [{
                type: Input
            }] } });

class MenuRecordWidget {
    buttons = [];
    direction = 'horizontal';
    constructor(buttons, direction) {
        this.buttons = buttons;
        this.direction = direction;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MenuRecordWidget, deps: [{ token: 'buttons' }, { token: 'direction' }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MenuRecordWidget, isStandalone: true, selector: "app-menu-record-widget", ngImport: i0, template: `
    <app-control-buttons-alt-component
      [buttons]="buttons"
      [direction]="direction"
      [showAspect]="true"
    ></app-control-buttons-alt-component>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: ControlButtonsAltComponent, selector: "app-control-buttons-alt-component", inputs: ["buttons", "position", "location", "direction", "buttonsContainerStyle", "showAspect"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MenuRecordWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-menu-record-widget',
                    standalone: true,
                    template: `
    <app-control-buttons-alt-component
      [buttons]="buttons"
      [direction]="direction"
      [showAspect]="true"
    ></app-control-buttons-alt-component>
  `,
                    imports: [CommonModule, FontAwesomeModule, ControlButtonsAltComponent],
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['buttons']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['direction']
                }] }] });

class RecordTimerWidget {
    recordingProgressTime = '';
    constructor(recordingProgressTime) {
        this.recordingProgressTime = recordingProgressTime;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordTimerWidget, deps: [{ token: 'recordingProgressTime' }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: RecordTimerWidget, isStandalone: true, selector: "app-record-timer-widget", ngImport: i0, template: `
    <div style="background-color: transparent; border-width: 0; padding: 0; margin: 2;">
      <span style="background-color: transparent; border-width: 0; padding: 0; margin: 0;">
        {{ recordingProgressTime }}
      </span>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: RecordTimerWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-record-timer-widget',
                    standalone: true,
                    template: `
    <div style="background-color: transparent; border-width: 0; padding: 0; margin: 2;">
      <span style="background-color: transparent; border-width: 0; padding: 0; margin: 0;">
        {{ recordingProgressTime }}
      </span>
    </div>
  `,
                    imports: [CommonModule],
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['recordingProgressTime']
                }] }] });

class MenuParticipantsWidget {
    icon;
    iconColor = 'black';
    participantsCounter;
    constructor(icon, iconColor, participantsCounter) {
        this.icon = icon;
        this.iconColor = iconColor;
        this.participantsCounter = participantsCounter;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MenuParticipantsWidget, deps: [{ token: 'icon' }, { token: 'iconColor' }, { token: 'participantsCounter' }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MenuParticipantsWidget, isStandalone: true, selector: "app-menu-participants-widget", inputs: { icon: "icon", iconColor: "iconColor", participantsCounter: "participantsCounter" }, ngImport: i0, template: `
    <div
      style="background-color: transparent; border-width: 0; padding: 0; margin: 5px; display: flex; flex-direction: row; align-items: center; justify-content: center;"
    >
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <span style="background-color: transparent; border-width: 0; padding: 0; margin: 0;">
        {{ participantsCounter }}
      </span>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MenuParticipantsWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-menu-participants-widget',
                    standalone: true,
                    template: `
    <div
      style="background-color: transparent; border-width: 0; padding: 0; margin: 5px; display: flex; flex-direction: row; align-items: center; justify-content: center;"
    >
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <span style="background-color: transparent; border-width: 0; padding: 0; margin: 0;">
        {{ participantsCounter }}
      </span>
    </div>
  `,
                    imports: [CommonModule, FontAwesomeModule],
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['icon']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['iconColor']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['participantsCounter']
                }] }], propDecorators: { icon: [{
                type: Input
            }], iconColor: [{
                type: Input
            }], participantsCounter: [{
                type: Input
            }] } });

class ScreenShareWidget {
    injectedDisabled;
    disabled = false; // Input to toggle disabled state
    faDesktop = faDesktop;
    faBan = faBan;
    computedDisabled;
    constructor(injectedDisabled) {
        this.injectedDisabled = injectedDisabled;
        // Use the injected value if provided, otherwise fall back to the @Input value
        this.computedDisabled = this.injectedDisabled != null ? this.injectedDisabled : this.disabled;
    }
    ngOnChanges() {
        // Update computedDisabled whenever the Input changes
        if (this.injectedDisabled == null) {
            this.computedDisabled = this.disabled;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ScreenShareWidget, deps: [{ token: 'disabled', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: ScreenShareWidget, isStandalone: true, selector: "app-screen-share-button", inputs: { disabled: "disabled" }, usesOnChanges: true, ngImport: i0, template: `
    <div style="position: relative; display: inline-block;">
      <!-- Desktop icon, change color based on disabled state -->
      <fa-icon [icon]="faDesktop" size="lg" [style.color]="computedDisabled ? 'black' : 'green'">
      </fa-icon>

      <!-- Red Ban icon on top if disabled -->
      <fa-icon
        *ngIf="computedDisabled"
        [icon]="faBan"
        size="lg"
        style="color: red; position: absolute; top: 0; right: 0;"
      >
      </fa-icon>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: ScreenShareWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-screen-share-button',
                    standalone: true,
                    imports: [CommonModule, FontAwesomeModule],
                    template: `
    <div style="position: relative; display: inline-block;">
      <!-- Desktop icon, change color based on disabled state -->
      <fa-icon [icon]="faDesktop" size="lg" [style.color]="computedDisabled ? 'black' : 'green'">
      </fa-icon>

      <!-- Red Ban icon on top if disabled -->
      <fa-icon
        *ngIf="computedDisabled"
        [icon]="faBan"
        size="lg"
        style="color: red; position: absolute; top: 0; right: 0;"
      >
      </fa-icon>
    </div>
  `,
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['disabled']
                }] }], propDecorators: { disabled: [{
                type: Input
            }] } });

class MediasfuGeneric {
    cdr;
    injector;
    updateMiniCardsGrid;
    mixStreams;
    dispStreams;
    stopShareScreen;
    checkScreenShare;
    startShareScreen;
    requestScreenShare;
    reorderStreams;
    prepopulateUserMedia;
    getVideos;
    rePort;
    trigger;
    consumerResume;
    connectSendTransport;
    connectSendTransportAudio;
    connectSendTransportVideo;
    connectSendTransportScreen;
    processConsumerTransports;
    resumePauseStreams;
    readjust;
    checkGrid;
    getEstimate;
    calculateRowsAndColumns;
    addVideosGrid;
    onScreenChanges;
    changeVids;
    compareActiveNames;
    compareScreenStates;
    createSendTransport;
    resumeSendTransportAudio;
    receiveAllPipedTransports;
    disconnectSendTransportVideo;
    disconnectSendTransportAudio;
    disconnectSendTransportScreen;
    getPipedProducersAlt;
    signalNewConsumerTransport;
    connectRecvTransport;
    reUpdateInter;
    updateParticipantAudioDecibels;
    closeAndResize;
    autoAdjust;
    switchUserVideoAlt;
    switchUserVideo;
    switchUserAudio;
    getDomains;
    formatNumber;
    connectIps;
    createDeviceClient;
    handleCreatePoll;
    handleEndPoll;
    handleVotePoll;
    captureCanvasStream;
    resumePauseAudioStreams;
    processConsumerTransportsAudio;
    launchMenuModal;
    launchRecording;
    startRecording;
    confirmRecording;
    launchWaiting;
    launchCoHost;
    launchMediaSettings;
    launchDisplaySettings;
    launchSettings;
    launchRequests;
    launchParticipants;
    launchMessages;
    launchConfirmExit;
    launchPoll;
    launchBreakoutRooms;
    launchConfigureWhiteboard;
    startMeetingProgressTimer;
    updateRecording;
    stopRecording;
    userWaiting;
    personJoined;
    allWaitingRoomMembers;
    roomRecordParams;
    banParticipant;
    updatedCoHost;
    participantRequested;
    screenProducerId;
    updateMediaSettings;
    producerMediaPaused;
    producerMediaResumed;
    producerMediaClosed;
    controlMediaHost;
    meetingEnded;
    disconnectUserSelf;
    receiveMessage;
    meetingTimeRemaining;
    meetingStillThere;
    startRecords;
    reInitiateRecording;
    recordingNotice;
    timeLeftRecording;
    stoppedRecording;
    hostRequestResponse;
    allMembers;
    allMembersRest;
    disconnect;
    pollUpdated;
    breakoutRoomUpdated;
    socketManager;
    joinRoomClient;
    updateRoomParametersClient;
    clickVideo;
    clickAudio;
    clickScreenShare;
    switchVideoAlt;
    streamSuccessVideo;
    streamSuccessAudio;
    streamSuccessScreen;
    streamSuccessAudioSwitch;
    checkPermission;
    updateConsumingDomains;
    receiveRoomMessages;
    PrejoinPage = WelcomePage;
    credentials = { apiUserName: '', apiKey: '' };
    useLocalUIMode = false;
    seedData;
    useSeed = false;
    imgSrc = 'https://mediasfu.com/images/logo192.png';
    title = 'MediaSFU-Generic';
    mainHeightWidthSubscription;
    validatedSubscription;
    islevelSubscription;
    coHostSubscription;
    buttonSubscriptions = [];
    ScreenboardSubscription;
    recordingSubscription;
    constructor(cdr, injector, updateMiniCardsGrid, mixStreams, dispStreams, stopShareScreen, checkScreenShare, startShareScreen, requestScreenShare, reorderStreams, prepopulateUserMedia, getVideos, rePort, trigger, consumerResume, connectSendTransport, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, processConsumerTransports, resumePauseStreams, readjust, checkGrid, getEstimate, calculateRowsAndColumns, addVideosGrid, onScreenChanges, changeVids, compareActiveNames, compareScreenStates, createSendTransport, resumeSendTransportAudio, receiveAllPipedTransports, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, getPipedProducersAlt, signalNewConsumerTransport, connectRecvTransport, reUpdateInter, updateParticipantAudioDecibels, closeAndResize, autoAdjust, switchUserVideoAlt, switchUserVideo, switchUserAudio, getDomains, formatNumber, connectIps, createDeviceClient, handleCreatePoll, handleEndPoll, handleVotePoll, captureCanvasStream, resumePauseAudioStreams, processConsumerTransportsAudio, launchMenuModal, launchRecording, startRecording, confirmRecording, launchWaiting, launchCoHost, launchMediaSettings, launchDisplaySettings, launchSettings, launchRequests, launchParticipants, launchMessages, launchConfirmExit, launchPoll, launchBreakoutRooms, launchConfigureWhiteboard, startMeetingProgressTimer, updateRecording, stopRecording, userWaiting, personJoined, allWaitingRoomMembers, roomRecordParams, banParticipant, updatedCoHost, participantRequested, screenProducerId, updateMediaSettings, producerMediaPaused, producerMediaResumed, producerMediaClosed, controlMediaHost, meetingEnded, disconnectUserSelf, receiveMessage, meetingTimeRemaining, meetingStillThere, startRecords, reInitiateRecording, recordingNotice, timeLeftRecording, stoppedRecording, hostRequestResponse, allMembers, allMembersRest, disconnect, pollUpdated, breakoutRoomUpdated, socketManager, joinRoomClient, updateRoomParametersClient, clickVideo, clickAudio, clickScreenShare, switchVideoAlt, streamSuccessVideo, streamSuccessAudio, streamSuccessScreen, streamSuccessAudioSwitch, checkPermission, updateConsumingDomains, receiveRoomMessages) {
        this.cdr = cdr;
        this.injector = injector;
        this.updateMiniCardsGrid = updateMiniCardsGrid;
        this.mixStreams = mixStreams;
        this.dispStreams = dispStreams;
        this.stopShareScreen = stopShareScreen;
        this.checkScreenShare = checkScreenShare;
        this.startShareScreen = startShareScreen;
        this.requestScreenShare = requestScreenShare;
        this.reorderStreams = reorderStreams;
        this.prepopulateUserMedia = prepopulateUserMedia;
        this.getVideos = getVideos;
        this.rePort = rePort;
        this.trigger = trigger;
        this.consumerResume = consumerResume;
        this.connectSendTransport = connectSendTransport;
        this.connectSendTransportAudio = connectSendTransportAudio;
        this.connectSendTransportVideo = connectSendTransportVideo;
        this.connectSendTransportScreen = connectSendTransportScreen;
        this.processConsumerTransports = processConsumerTransports;
        this.resumePauseStreams = resumePauseStreams;
        this.readjust = readjust;
        this.checkGrid = checkGrid;
        this.getEstimate = getEstimate;
        this.calculateRowsAndColumns = calculateRowsAndColumns;
        this.addVideosGrid = addVideosGrid;
        this.onScreenChanges = onScreenChanges;
        this.changeVids = changeVids;
        this.compareActiveNames = compareActiveNames;
        this.compareScreenStates = compareScreenStates;
        this.createSendTransport = createSendTransport;
        this.resumeSendTransportAudio = resumeSendTransportAudio;
        this.receiveAllPipedTransports = receiveAllPipedTransports;
        this.disconnectSendTransportVideo = disconnectSendTransportVideo;
        this.disconnectSendTransportAudio = disconnectSendTransportAudio;
        this.disconnectSendTransportScreen = disconnectSendTransportScreen;
        this.getPipedProducersAlt = getPipedProducersAlt;
        this.signalNewConsumerTransport = signalNewConsumerTransport;
        this.connectRecvTransport = connectRecvTransport;
        this.reUpdateInter = reUpdateInter;
        this.updateParticipantAudioDecibels = updateParticipantAudioDecibels;
        this.closeAndResize = closeAndResize;
        this.autoAdjust = autoAdjust;
        this.switchUserVideoAlt = switchUserVideoAlt;
        this.switchUserVideo = switchUserVideo;
        this.switchUserAudio = switchUserAudio;
        this.getDomains = getDomains;
        this.formatNumber = formatNumber;
        this.connectIps = connectIps;
        this.createDeviceClient = createDeviceClient;
        this.handleCreatePoll = handleCreatePoll;
        this.handleEndPoll = handleEndPoll;
        this.handleVotePoll = handleVotePoll;
        this.captureCanvasStream = captureCanvasStream;
        this.resumePauseAudioStreams = resumePauseAudioStreams;
        this.processConsumerTransportsAudio = processConsumerTransportsAudio;
        this.launchMenuModal = launchMenuModal;
        this.launchRecording = launchRecording;
        this.startRecording = startRecording;
        this.confirmRecording = confirmRecording;
        this.launchWaiting = launchWaiting;
        this.launchCoHost = launchCoHost;
        this.launchMediaSettings = launchMediaSettings;
        this.launchDisplaySettings = launchDisplaySettings;
        this.launchSettings = launchSettings;
        this.launchRequests = launchRequests;
        this.launchParticipants = launchParticipants;
        this.launchMessages = launchMessages;
        this.launchConfirmExit = launchConfirmExit;
        this.launchPoll = launchPoll;
        this.launchBreakoutRooms = launchBreakoutRooms;
        this.launchConfigureWhiteboard = launchConfigureWhiteboard;
        this.startMeetingProgressTimer = startMeetingProgressTimer;
        this.updateRecording = updateRecording;
        this.stopRecording = stopRecording;
        this.userWaiting = userWaiting;
        this.personJoined = personJoined;
        this.allWaitingRoomMembers = allWaitingRoomMembers;
        this.roomRecordParams = roomRecordParams;
        this.banParticipant = banParticipant;
        this.updatedCoHost = updatedCoHost;
        this.participantRequested = participantRequested;
        this.screenProducerId = screenProducerId;
        this.updateMediaSettings = updateMediaSettings;
        this.producerMediaPaused = producerMediaPaused;
        this.producerMediaResumed = producerMediaResumed;
        this.producerMediaClosed = producerMediaClosed;
        this.controlMediaHost = controlMediaHost;
        this.meetingEnded = meetingEnded;
        this.disconnectUserSelf = disconnectUserSelf;
        this.receiveMessage = receiveMessage;
        this.meetingTimeRemaining = meetingTimeRemaining;
        this.meetingStillThere = meetingStillThere;
        this.startRecords = startRecords;
        this.reInitiateRecording = reInitiateRecording;
        this.recordingNotice = recordingNotice;
        this.timeLeftRecording = timeLeftRecording;
        this.stoppedRecording = stoppedRecording;
        this.hostRequestResponse = hostRequestResponse;
        this.allMembers = allMembers;
        this.allMembersRest = allMembersRest;
        this.disconnect = disconnect;
        this.pollUpdated = pollUpdated;
        this.breakoutRoomUpdated = breakoutRoomUpdated;
        this.socketManager = socketManager;
        this.joinRoomClient = joinRoomClient;
        this.updateRoomParametersClient = updateRoomParametersClient;
        this.clickVideo = clickVideo;
        this.clickAudio = clickAudio;
        this.clickScreenShare = clickScreenShare;
        this.switchVideoAlt = switchVideoAlt;
        this.streamSuccessVideo = streamSuccessVideo;
        this.streamSuccessAudio = streamSuccessAudio;
        this.streamSuccessScreen = streamSuccessScreen;
        this.streamSuccessAudioSwitch = streamSuccessAudioSwitch;
        this.checkPermission = checkPermission;
        this.updateConsumingDomains = updateConsumingDomains;
        this.receiveRoomMessages = receiveRoomMessages;
    }
    createInjector(inputs) {
        const inj = Injector.create({
            providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
            parent: this.injector,
        });
        return inj;
    }
    // Initial values
    mediaSFUFunctions = () => {
        return {
            updateMiniCardsGrid: this.updateMiniCardsGrid?.updateMiniCardsGrid ||
                (() => {
                    console.log('none');
                }),
            mixStreams: this.mixStreams?.mixStreams ||
                (() => {
                    console.log('none');
                }),
            dispStreams: this.dispStreams?.dispStreams ||
                (() => {
                    console.log('none');
                }),
            stopShareScreen: this.stopShareScreen?.stopShareScreen ||
                (() => {
                    console.log('none');
                }),
            checkScreenShare: this.checkScreenShare?.checkScreenShare ||
                (() => {
                    console.log('none');
                }),
            startShareScreen: this.startShareScreen?.startShareScreen ||
                (() => {
                    console.log('none');
                }),
            requestScreenShare: this.requestScreenShare?.requestScreenShare ||
                (() => {
                    console.log('none');
                }),
            reorderStreams: this.reorderStreams?.reorderStreams ||
                (() => {
                    console.log('none');
                }),
            prepopulateUserMedia: this.prepopulateUserMedia?.prepopulateUserMedia ||
                (() => {
                    console.log('none');
                }),
            getVideos: this.getVideos?.getVideos ||
                (() => {
                    console.log('none');
                }),
            rePort: this.rePort?.rePort ||
                (() => {
                    console.log('none');
                }),
            trigger: this.trigger?.trigger ||
                (() => {
                    console.log('none');
                }),
            consumerResume: this.consumerResume?.consumerResume ||
                (() => {
                    console.log('none');
                }),
            connectSendTransport: this.connectSendTransport?.connectSendTransport ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportAudio: this.connectSendTransportAudio?.connectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportVideo: this.connectSendTransportVideo?.connectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportScreen: this.connectSendTransportScreen?.connectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransports: this.processConsumerTransports?.processConsumerTransports ||
                (() => {
                    console.log('none');
                }),
            resumePauseStreams: this.resumePauseStreams?.resumePauseStreams ||
                (() => {
                    console.log('none');
                }),
            readjust: this.readjust?.readjust ||
                (() => {
                    console.log('none');
                }),
            checkGrid: this.checkGrid?.checkGrid ||
                (() => {
                    console.log('none');
                }),
            getEstimate: this.getEstimate?.getEstimate ||
                (() => {
                    console.log('none');
                }),
            calculateRowsAndColumns: this.calculateRowsAndColumns?.calculateRowsAndColumns ||
                (() => {
                    console.log('none');
                }),
            addVideosGrid: this.addVideosGrid?.addVideosGrid ||
                (() => {
                    console.log('none');
                }),
            onScreenChanges: this.onScreenChanges?.onScreenChanges ||
                (() => {
                    console.log('none');
                }),
            sleep: sleep ||
                (() => {
                    console.log('none');
                }),
            changeVids: this.changeVids?.changeVids ||
                (() => {
                    console.log('none');
                }),
            compareActiveNames: this.compareActiveNames?.compareActiveNames ||
                (() => {
                    console.log('none');
                }),
            compareScreenStates: this.compareScreenStates?.compareScreenStates ||
                (() => {
                    console.log('none');
                }),
            createSendTransport: this.createSendTransport?.createSendTransport ||
                (() => {
                    console.log('none');
                }),
            resumeSendTransportAudio: this.resumeSendTransportAudio?.resumeSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            receiveAllPipedTransports: this.receiveAllPipedTransports?.receiveAllPipedTransports ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportVideo: this.disconnectSendTransportVideo?.disconnectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportAudio: this.disconnectSendTransportAudio?.disconnectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportScreen: this.disconnectSendTransportScreen?.disconnectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            getPipedProducersAlt: this.getPipedProducersAlt?.getPipedProducersAlt ||
                (() => {
                    console.log('none');
                }),
            signalNewConsumerTransport: this.signalNewConsumerTransport?.signalNewConsumerTransport ||
                (() => {
                    console.log('none');
                }),
            connectRecvTransport: this.connectRecvTransport?.connectRecvTransport ||
                (() => {
                    console.log('none');
                }),
            reUpdateInter: this.reUpdateInter?.reUpdateInter ||
                (() => {
                    console.log('none');
                }),
            updateParticipantAudioDecibels: this.updateParticipantAudioDecibels?.updateParticipantAudioDecibels ||
                (() => {
                    console.log('none');
                }),
            closeAndResize: this.closeAndResize?.closeAndResize ||
                (() => {
                    console.log('none');
                }),
            autoAdjust: this.autoAdjust?.autoAdjust ||
                (() => {
                    console.log('none');
                }),
            switchUserVideoAlt: this.switchUserVideoAlt?.switchUserVideoAlt ||
                (() => {
                    console.log('none');
                }),
            switchUserVideo: this.switchUserVideo?.switchUserVideo ||
                (() => {
                    console.log('none');
                }),
            switchUserAudio: this.switchUserAudio?.switchUserAudio ||
                (() => {
                    console.log('none');
                }),
            getDomains: this.getDomains?.getDomains ||
                (() => {
                    console.log('none');
                }),
            formatNumber: this.formatNumber?.formatNumber ||
                (() => {
                    console.log('none');
                }),
            connectIps: this.connectIps?.connectIps ||
                (() => {
                    console.log('none');
                }),
            createDeviceClient: this.createDeviceClient?.createDeviceClient ||
                (() => {
                    console.log('none');
                }),
            handleCreatePoll: this.handleCreatePoll?.handleCreatePoll ||
                (() => {
                    console.log('none');
                }),
            handleEndPoll: this.handleEndPoll?.handleEndPoll ||
                (() => {
                    console.log('none');
                }),
            handleVotePoll: this.handleVotePoll?.handleVotePoll ||
                (() => {
                    console.log('none');
                }),
            captureCanvasStream: this.captureCanvasStream?.captureCanvasStream ||
                (() => {
                    console.log('none');
                }),
            resumePauseAudioStreams: this.resumePauseAudioStreams?.resumePauseAudioStreams ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransportsAudio: this.processConsumerTransportsAudio?.processConsumerTransportsAudio ||
                (() => {
                    console.log('none');
                }),
            checkPermission: this.checkPermission?.checkPermission ||
                (() => {
                    console.log('none');
                }),
            streamSuccessVideo: this.streamSuccessVideo?.streamSuccessVideo ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudio: this.streamSuccessAudio?.streamSuccessAudio ||
                (() => {
                    console.log('none');
                }),
            streamSuccessScreen: this.streamSuccessScreen?.streamSuccessScreen ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudioSwitch: this.streamSuccessAudioSwitch?.streamSuccessAudioSwitch ||
                (() => {
                    console.log('none');
                }),
            clickVideo: this.clickVideo?.clickVideo ||
                (() => {
                    console.log('none');
                }),
            clickAudio: this.clickAudio?.clickAudio ||
                (() => {
                    console.log('none');
                }),
            clickScreenShare: this.clickScreenShare?.clickScreenShare ||
                (() => {
                    console.log('none');
                }),
            switchVideoAlt: this.switchVideoAlt?.switchVideoAlt ||
                (() => {
                    console.log('none');
                }),
            requestPermissionCamera: this.requestPermissionCamera ||
                (() => {
                    console.log('none');
                }),
            requestPermissionAudio: this.requestPermissionAudio ||
                (() => {
                    console.log('none');
                }),
        };
    };
    validated = new BehaviorSubject(false);
    localUIMode = new BehaviorSubject(false);
    socket = new BehaviorSubject({});
    roomData = new BehaviorSubject(null);
    device = new BehaviorSubject(null);
    apiKey = new BehaviorSubject('021193742c935c4434d25d7592362575fcb6d6590b6c38334a2f3e06c83af758');
    apiUserName = new BehaviorSubject('abcdefgh');
    apiToken = new BehaviorSubject('');
    link = new BehaviorSubject('');
    roomName = new BehaviorSubject('');
    member = new BehaviorSubject('');
    adminPasscode = new BehaviorSubject('');
    islevel = new BehaviorSubject('1');
    coHost = new BehaviorSubject('No coHost');
    coHostResponsibility = new BehaviorSubject([
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ]);
    youAreCoHost = new BehaviorSubject(false);
    youAreHost = new BehaviorSubject(false);
    confirmedToRecord = new BehaviorSubject(false);
    meetingDisplayType = new BehaviorSubject('media');
    meetingVideoOptimized = new BehaviorSubject(false);
    eventType = new BehaviorSubject('webinar');
    participants = new BehaviorSubject([]);
    filteredParticipants = new BehaviorSubject([]);
    participantsCounter = new BehaviorSubject(0);
    participantsFilter = new BehaviorSubject('');
    consume_sockets = new BehaviorSubject([]);
    rtpCapabilities = new BehaviorSubject(null);
    roomRecvIPs = new BehaviorSubject([]);
    meetingRoomParams = new BehaviorSubject(null);
    itemPageLimit = new BehaviorSubject(4);
    audioOnlyRoom = new BehaviorSubject(false);
    addForBasic = new BehaviorSubject(false);
    screenPageLimit = new BehaviorSubject(4);
    shareScreenStarted = new BehaviorSubject(false);
    shared = new BehaviorSubject(false);
    targetOrientation = new BehaviorSubject('landscape');
    targetResolution = new BehaviorSubject('sd');
    targetResolutionHost = new BehaviorSubject('sd');
    vidCons = new BehaviorSubject({ width: 640, height: 360 });
    frameRate = new BehaviorSubject(10);
    hParams = new BehaviorSubject({});
    vParams = new BehaviorSubject({});
    screenParams = new BehaviorSubject({});
    aParams = new BehaviorSubject({});
    recordingAudioPausesLimit = new BehaviorSubject(0);
    recordingAudioPausesCount = new BehaviorSubject(0);
    recordingAudioSupport = new BehaviorSubject(false);
    recordingAudioPeopleLimit = new BehaviorSubject(0);
    recordingAudioParticipantsTimeLimit = new BehaviorSubject(0);
    recordingVideoPausesCount = new BehaviorSubject(0);
    recordingVideoPausesLimit = new BehaviorSubject(0);
    recordingVideoSupport = new BehaviorSubject(false);
    recordingVideoPeopleLimit = new BehaviorSubject(0);
    recordingVideoParticipantsTimeLimit = new BehaviorSubject(0);
    recordingAllParticipantsSupport = new BehaviorSubject(false);
    recordingVideoParticipantsSupport = new BehaviorSubject(false);
    recordingAllParticipantsFullRoomSupport = new BehaviorSubject(false);
    recordingVideoParticipantsFullRoomSupport = new BehaviorSubject(false);
    recordingPreferredOrientation = new BehaviorSubject('landscape');
    recordingSupportForOtherOrientation = new BehaviorSubject(false);
    recordingMultiFormatsSupport = new BehaviorSubject(false);
    userRecordingParams = new BehaviorSubject({
        mainSpecs: {
            mediaOptions: 'video', // 'audio', 'video'
            audioOptions: 'all', // 'all', 'onScreen', 'host'
            videoOptions: 'all', // 'all', 'mainScreen'
            videoType: 'fullDisplay', // 'all', 'bestDisplay', 'fullDisplay'
            videoOptimized: false, // true, false
            recordingDisplayType: 'media', // 'media', 'video', 'all'
            addHLS: false, // true, false
        },
        dispSpecs: {
            nameTags: true, // true, false
            backgroundColor: '#000000', // '#000000', '#ffffff'
            nameTagsColor: '#ffffff', // '#000000', '#ffffff'
            orientationVideo: 'portrait', // 'landscape', 'portrait', 'all'
        },
    });
    canRecord = new BehaviorSubject(false);
    startReport = new BehaviorSubject(false);
    endReport = new BehaviorSubject(false);
    recordTimerInterval = new BehaviorSubject(null);
    recordStartTime = new BehaviorSubject(0);
    recordElapsedTime = new BehaviorSubject(0);
    isTimerRunning = new BehaviorSubject(false);
    canPauseResume = new BehaviorSubject(false);
    recordChangeSeconds = new BehaviorSubject(15000);
    pauseLimit = new BehaviorSubject(0);
    pauseRecordCount = new BehaviorSubject(0);
    canLaunchRecord = new BehaviorSubject(true);
    stopLaunchRecord = new BehaviorSubject(false);
    participantsAll = new BehaviorSubject([]);
    firstAll = new BehaviorSubject(false);
    updateMainWindow = new BehaviorSubject(false);
    first_round = new BehaviorSubject(false);
    landScaped = new BehaviorSubject(false);
    lock_screen = new BehaviorSubject(false);
    screenId = new BehaviorSubject('');
    allVideoStreams = new BehaviorSubject([]);
    newLimitedStreams = new BehaviorSubject([]);
    newLimitedStreamsIDs = new BehaviorSubject([]);
    activeSounds = new BehaviorSubject([]);
    screenShareIDStream = new BehaviorSubject('');
    screenShareNameStream = new BehaviorSubject('');
    adminIDStream = new BehaviorSubject('');
    adminNameStream = new BehaviorSubject('');
    youYouStream = new BehaviorSubject([]);
    youYouStreamIDs = new BehaviorSubject([]);
    localStream = new BehaviorSubject(null);
    recordStarted = new BehaviorSubject(false);
    recordResumed = new BehaviorSubject(false);
    recordPaused = new BehaviorSubject(false);
    recordStopped = new BehaviorSubject(false);
    adminRestrictSetting = new BehaviorSubject(false);
    videoRequestState = new BehaviorSubject(null);
    videoRequestTime = new BehaviorSubject(0);
    videoAction = new BehaviorSubject(false);
    localStreamVideo = new BehaviorSubject(null);
    userDefaultVideoInputDevice = new BehaviorSubject('');
    currentFacingMode = new BehaviorSubject('user');
    prevFacingMode = new BehaviorSubject('user');
    defVideoID = new BehaviorSubject('');
    allowed = new BehaviorSubject(false);
    dispActiveNames = new BehaviorSubject([]);
    p_dispActiveNames = new BehaviorSubject([]);
    activeNames = new BehaviorSubject([]);
    prevActiveNames = new BehaviorSubject([]);
    p_activeNames = new BehaviorSubject([]);
    membersReceived = new BehaviorSubject(false);
    deferScreenReceived = new BehaviorSubject(false);
    hostFirstSwitch = new BehaviorSubject(false);
    micAction = new BehaviorSubject(false);
    screenAction = new BehaviorSubject(false);
    chatAction = new BehaviorSubject(false);
    audioRequestState = new BehaviorSubject(null);
    screenRequestState = new BehaviorSubject(null);
    chatRequestState = new BehaviorSubject(null);
    audioRequestTime = new BehaviorSubject(0);
    screenRequestTime = new BehaviorSubject(0);
    chatRequestTime = new BehaviorSubject(0);
    updateRequestIntervalSeconds = new BehaviorSubject(240);
    oldSoundIds = new BehaviorSubject([]);
    hostLabel = new BehaviorSubject('Host');
    mainScreenFilled = new BehaviorSubject(false);
    localStreamScreen = new BehaviorSubject(null);
    screenAlreadyOn = new BehaviorSubject(false);
    chatAlreadyOn = new BehaviorSubject(false);
    redirectURL = new BehaviorSubject('');
    oldAllStreams = new BehaviorSubject([]);
    adminVidID = new BehaviorSubject('');
    streamNames = new BehaviorSubject([]);
    non_alVideoStreams = new BehaviorSubject([]);
    sortAudioLoudness = new BehaviorSubject(false);
    audioDecibels = new BehaviorSubject([]);
    mixed_alVideoStreams = new BehaviorSubject([]);
    non_alVideoStreams_muted = new BehaviorSubject([]);
    paginatedStreams = new BehaviorSubject([]);
    localStreamAudio = new BehaviorSubject(null);
    defAudioID = new BehaviorSubject('');
    userDefaultAudioInputDevice = new BehaviorSubject('');
    userDefaultAudioOutputDevice = new BehaviorSubject('');
    prevAudioInputDevice = new BehaviorSubject('');
    prevVideoInputDevice = new BehaviorSubject('');
    audioPaused = new BehaviorSubject(false);
    mainScreenPerson = new BehaviorSubject('');
    adminOnMainScreen = new BehaviorSubject(false);
    screenStates = new BehaviorSubject([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    prevScreenStates = new BehaviorSubject([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    updateDateState = new BehaviorSubject(null);
    lastUpdate = new BehaviorSubject(null);
    nForReadjustRecord = new BehaviorSubject(0);
    fixedPageLimit = new BehaviorSubject(4);
    removeAltGrid = new BehaviorSubject(false);
    nForReadjust = new BehaviorSubject(0);
    reorderInterval = new BehaviorSubject(30000);
    fastReorderInterval = new BehaviorSubject(10000);
    lastReorderTime = new BehaviorSubject(0);
    audStreamNames = new BehaviorSubject([]);
    currentUserPage = new BehaviorSubject(0);
    mainHeightWidth = new BehaviorSubject(this.eventType.value == 'webinar' ? 67 : this.eventType.value == 'broadcast' ? 100 : 0);
    prevMainHeightWidth = new BehaviorSubject(this.mainHeightWidth.value);
    prevDoPaginate = new BehaviorSubject(false);
    doPaginate = new BehaviorSubject(false);
    shareEnded = new BehaviorSubject(false);
    lStreams = new BehaviorSubject([]);
    chatRefStreams = new BehaviorSubject([]);
    controlHeight = new BehaviorSubject(this.eventType.value === 'webinar' || this.eventType.value === 'conference' ? 0 : 0.06);
    isWideScreen = new BehaviorSubject(false);
    isMediumScreen = new BehaviorSubject(false);
    isSmallScreen = new BehaviorSubject(false);
    addGrid = new BehaviorSubject(false);
    addAltGrid = new BehaviorSubject(false);
    gridRows = new BehaviorSubject(0);
    gridCols = new BehaviorSubject(0);
    altGridRows = new BehaviorSubject(0);
    altGridCols = new BehaviorSubject(0);
    numberPages = new BehaviorSubject(0);
    currentStreams = new BehaviorSubject([]);
    showMiniView = new BehaviorSubject(false);
    nStream = new BehaviorSubject(null);
    defer_receive = new BehaviorSubject(false);
    allAudioStreams = new BehaviorSubject([]);
    remoteScreenStream = new BehaviorSubject([]);
    screenProducer = new BehaviorSubject(null);
    gotAllVids = new BehaviorSubject(false);
    paginationHeightWidth = new BehaviorSubject(40);
    paginationDirection = new BehaviorSubject('horizontal');
    gridSizes = new BehaviorSubject({
        gridWidth: 0,
        gridHeight: 0,
        altGridWidth: 0,
        altGridHeight: 0,
    });
    screenForceFullDisplay = new BehaviorSubject(false);
    mainGridStream = new BehaviorSubject([]);
    otherGridStreams = new BehaviorSubject([]);
    audioOnlyStreams = new BehaviorSubject([]);
    videoInputs = new BehaviorSubject([]);
    audioInputs = new BehaviorSubject([]);
    meetingProgressTime = new BehaviorSubject('00:00:00');
    meetingElapsedTime = new BehaviorSubject(0);
    ref_participants = new BehaviorSubject([]);
    updateValidated = (value) => {
        this.validated.next(value);
    };
    updateSocket = (value) => {
        this.socket.next(value);
    };
    updateDevice = (value) => {
        this.device.next(value);
    };
    updateRoomData = (value) => {
        this.roomData.next(value);
    };
    updateApiKey = (value) => {
        this.apiKey.next(value);
    };
    updateApiUserName = (value) => {
        this.apiUserName.next(value);
    };
    updateApiToken = (value) => {
        this.apiToken.next(value);
    };
    updateLink = (value) => {
        this.link.next(value);
    };
    updateRoomName = (value) => {
        this.roomName.next(value);
    };
    updateMember = (value) => {
        this.member.next(value);
    };
    updateAdminPasscode = (value) => {
        this.adminPasscode.next(value);
    };
    updateIslevel = (value) => {
        this.islevel.next(value);
    };
    updateCoHost = (value) => {
        this.coHost.next(value);
    };
    updateCoHostResponsibility = (value) => {
        this.coHostResponsibility.next(value);
    };
    updateYouAreCoHost = (value) => {
        this.youAreCoHost.next(value);
    };
    updateYouAreHost = (value) => {
        this.youAreHost.next(value);
    };
    updateConfirmedToRecord = (value) => {
        this.confirmedToRecord.next(value);
    };
    updateMeetingDisplayType = (value) => {
        this.meetingDisplayType.next(value);
    };
    updateMeetingVideoOptimized = (value) => {
        this.meetingVideoOptimized.next(value);
    };
    updateEventType = (value) => {
        this.eventType.next(value);
        if (value != 'none') {
            try {
                setTimeout(() => {
                    this.handleResize();
                }, 2000);
            }
            catch {
                /* handle error */
            }
        }
    };
    updateParticipants = (value) => {
        this.participants.next(value);
        this.participantsCounter.next(value.length);
        this.filteredParticipants.next(this.participants.value);
    };
    updateFilteredParticipants = (value) => {
        this.filteredParticipants.next(value);
    };
    updateParticipantsCounter = (value) => {
        this.participantsCounter.next(value);
    };
    updateParticipantsFilter = (value) => {
        this.participantsFilter.next(value);
    };
    updateConsume_sockets = (value) => {
        this.consume_sockets.next(value);
    };
    updateRtpCapabilities = (value) => {
        this.rtpCapabilities.next(value);
    };
    updateRoomRecvIPs = (value) => {
        this.roomRecvIPs.next(value);
    };
    updateMeetingRoomParams = (value) => {
        this.meetingRoomParams.next(value);
    };
    updateItemPageLimit = (value) => {
        this.itemPageLimit.next(value);
    };
    updateAudioOnlyRoom = (value) => {
        this.audioOnlyRoom.next(value);
    };
    updateAddForBasic = (value) => {
        this.addForBasic.next(value);
    };
    updateScreenPageLimit = (value) => {
        this.screenPageLimit.next(value);
    };
    updateShareScreenStarted = (value) => {
        this.shareScreenStarted.next(value);
    };
    updateShared = (value) => {
        this.shared.next(value);
        this.screenShareActive.next(value);
        if (value) {
            setTimeout(async () => {
                window.dispatchEvent(new Event('resize'));
            }, 2000);
        }
    };
    updateTargetOrientation = (value) => {
        this.targetOrientation.next(value);
    };
    updateTargetResolution = (value) => {
        this.targetResolution.next(value);
    };
    updateTargetResolutionHost = (value) => {
        this.targetResolutionHost.next(value);
    };
    updateVidCons = (value) => {
        this.vidCons.next(value);
    };
    updateFrameRate = (value) => {
        this.frameRate.next(value);
    };
    updateHParams = (value) => {
        this.hParams.next(value);
    };
    updateVParams = (value) => {
        this.vParams.next(value);
    };
    updateScreenParams = (value) => {
        this.screenParams.next(value);
    };
    updateAParams = (value) => {
        this.aParams.next(value);
    };
    updateRecordingAudioPausesLimit = (value) => {
        this.recordingAudioPausesLimit.next(value);
    };
    updateRecordingAudioPausesCount = (value) => {
        this.recordingAudioPausesCount.next(value);
    };
    updateRecordingAudioSupport = (value) => {
        this.recordingAudioSupport.next(value);
    };
    updateRecordingAudioPeopleLimit = (value) => {
        this.recordingAudioPeopleLimit.next(value);
    };
    updateRecordingAudioParticipantsTimeLimit = (value) => {
        this.recordingAudioParticipantsTimeLimit.next(value);
    };
    updateRecordingVideoPausesCount = (value) => {
        this.recordingVideoPausesCount.next(value);
    };
    updateRecordingVideoPausesLimit = (value) => {
        this.recordingVideoPausesLimit.next(value);
    };
    updateRecordingVideoSupport = (value) => {
        this.recordingVideoSupport.next(value);
    };
    updateRecordingVideoPeopleLimit = (value) => {
        this.recordingVideoPeopleLimit.next(value);
    };
    updateRecordingVideoParticipantsTimeLimit = (value) => {
        this.recordingVideoParticipantsTimeLimit.next(value);
    };
    updateRecordingAllParticipantsSupport = (value) => {
        this.recordingAllParticipantsSupport.next(value);
    };
    updateRecordingVideoParticipantsSupport = (value) => {
        this.recordingVideoParticipantsSupport.next(value);
    };
    updateRecordingAllParticipantsFullRoomSupport = (value) => {
        this.recordingAllParticipantsFullRoomSupport.next(value);
    };
    updateRecordingVideoParticipantsFullRoomSupport = (value) => {
        this.recordingVideoParticipantsFullRoomSupport.next(value);
    };
    updateRecordingPreferredOrientation = (value) => {
        this.recordingPreferredOrientation.next(value);
    };
    updateRecordingSupportForOtherOrientation = (value) => {
        this.recordingSupportForOtherOrientation.next(value);
    };
    updateRecordingMultiFormatsSupport = (value) => {
        this.recordingMultiFormatsSupport.next(value);
    };
    updateUserRecordingParams = (value) => {
        this.userRecordingParams.next(value);
    };
    updateCanRecord = (value) => {
        this.canRecord.next(value);
    };
    updateStartReport = (value) => {
        this.startReport.next(value);
    };
    updateEndReport = (value) => {
        this.endReport.next(value);
    };
    updateRecordTimerInterval = (value) => {
        this.recordTimerInterval.next(value);
    };
    updateRecordStartTime = (value) => {
        this.recordStartTime.next(value);
    };
    updateRecordElapsedTime = (value) => {
        this.recordElapsedTime.next(value);
    };
    updateIsTimerRunning = (value) => {
        this.isTimerRunning.next(value);
    };
    updateCanPauseResume = (value) => {
        this.canPauseResume.next(value);
    };
    updateRecordChangeSeconds = (value) => {
        this.recordChangeSeconds.next(value);
    };
    updatePauseLimit = (value) => {
        this.pauseLimit.next(value);
    };
    updatePauseRecordCount = (value) => {
        this.pauseRecordCount.next(value);
    };
    updateCanLaunchRecord = (value) => {
        this.canLaunchRecord.next(value);
    };
    updateStopLaunchRecord = (value) => {
        this.stopLaunchRecord.next(value);
    };
    updateParticipantsAll = (value) => {
        this.participantsAll.next(value);
    };
    updateFirstAll = (value) => {
        this.firstAll.next(value);
    };
    updateUpdateMainWindow = (value) => {
        this.updateMainWindow.next(value);
    };
    updateFirst_round = (value) => {
        this.first_round.next(value);
    };
    updateLandScaped = (value) => {
        this.landScaped.next(value);
    };
    updateLock_screen = (value) => {
        this.lock_screen.next(value);
    };
    updateScreenId = (value) => {
        this.screenId.next(value);
    };
    updateAllVideoStreams = (value) => {
        this.allVideoStreams.next(value);
    };
    updateNewLimitedStreams = (value) => {
        this.newLimitedStreams.next(value);
    };
    updateNewLimitedStreamsIDs = (value) => {
        this.newLimitedStreamsIDs.next(value);
    };
    updateActiveSounds = (value) => {
        this.activeSounds.next(value);
    };
    updateScreenShareIDStream = (value) => {
        this.screenShareIDStream.next(value);
    };
    updateScreenShareNameStream = (value) => {
        this.screenShareNameStream.next(value);
    };
    updateAdminIDStream = (value) => {
        this.adminIDStream.next(value);
    };
    updateAdminNameStream = (value) => {
        this.adminNameStream.next(value);
    };
    updateYouYouStream = (value) => {
        this.youYouStream.next(value);
    };
    updateYouYouStreamIDs = (value) => {
        this.youYouStreamIDs.next(value);
    };
    updateLocalStream = (value) => {
        this.localStream.next(value);
    };
    updateRecordStarted = (value) => {
        this.recordStarted.next(value);
    };
    updateRecordResumed = (value) => {
        this.recordResumed.next(value);
    };
    updateRecordPaused = (value) => {
        this.recordPaused.next(value);
    };
    updateRecordStopped = (value) => {
        this.recordStopped.next(value);
    };
    updateAdminRestrictSetting = (value) => {
        this.adminRestrictSetting.next(value);
    };
    updateVideoRequestState = (value) => {
        this.videoRequestState.next(value);
    };
    updateVideoRequestTime = (value) => {
        this.videoRequestTime.next(value);
    };
    updateVideoAction = (value) => {
        this.videoAction.next(value);
    };
    updateLocalStreamVideo = (value) => {
        this.localStreamVideo.next(value);
    };
    updateUserDefaultVideoInputDevice = (value) => {
        this.userDefaultVideoInputDevice.next(value);
    };
    updateCurrentFacingMode = (value) => {
        this.currentFacingMode.next(value);
    };
    updatePrevFacingMode = (value) => {
        this.prevFacingMode.next(value);
    };
    updateDefVideoID = (value) => {
        this.defVideoID.next(value);
    };
    updateAllowed = (value) => {
        this.allowed.next(value);
    };
    updateDispActiveNames = (value) => {
        this.dispActiveNames.next(value);
    };
    updateP_dispActiveNames = (value) => {
        this.p_dispActiveNames.next(value);
    };
    updateActiveNames = (value) => {
        this.activeNames.next(value);
    };
    updatePrevActiveNames = (value) => {
        this.prevActiveNames.next(value);
    };
    updateP_activeNames = (value) => {
        this.p_activeNames.next(value);
    };
    updateMembersReceived = (value) => {
        this.membersReceived.next(value);
    };
    updateDeferScreenReceived = (value) => {
        this.deferScreenReceived.next(value);
    };
    updateHostFirstSwitch = (value) => {
        this.hostFirstSwitch.next(value);
    };
    updateMicAction = (value) => {
        this.micAction.next(value);
    };
    updateScreenAction = (value) => {
        this.screenAction.next(value);
    };
    updateChatAction = (value) => {
        this.chatAction.next(value);
    };
    updateAudioRequestState = (value) => {
        this.audioRequestState.next(value);
    };
    updateScreenRequestState = (value) => {
        this.screenRequestState.next(value);
    };
    updateChatRequestState = (value) => {
        this.chatRequestState.next(value);
    };
    updateAudioRequestTime = (value) => {
        this.audioRequestTime.next(value);
    };
    updateScreenRequestTime = (value) => {
        this.screenRequestTime.next(value);
    };
    updateChatRequestTime = (value) => {
        this.chatRequestTime.next(value);
    };
    updateOldSoundIds = (value) => {
        this.oldSoundIds.next(value);
    };
    updateHostLabel = (value) => {
        this.hostLabel.next(value);
    };
    updateMainScreenFilled = (value) => {
        this.mainScreenFilled.next(value);
    };
    updateLocalStreamScreen = (value) => {
        this.localStreamScreen.next(value);
    };
    updateScreenAlreadyOn = (value) => {
        this.screenAlreadyOn.next(value);
    };
    updateChatAlreadyOn = (value) => {
        this.chatAlreadyOn.next(value);
    };
    updateRedirectURL = (value) => {
        this.redirectURL.next(value);
    };
    updateOldAllStreams = (value) => {
        this.oldAllStreams.next(value);
    };
    updateAdminVidID = (value) => {
        this.adminVidID.next(value);
    };
    updateStreamNames = (value) => {
        this.streamNames.next(value);
    };
    updateNon_alVideoStreams = (value) => {
        this.non_alVideoStreams.next(value);
    };
    updateSortAudioLoudness = (value) => {
        this.sortAudioLoudness.next(value);
    };
    updateAudioDecibels = (value) => {
        this.audioDecibels.next(value);
    };
    updateMixed_alVideoStreams = (value) => {
        this.mixed_alVideoStreams.next(value);
    };
    updateNon_alVideoStreams_muted = (value) => {
        this.non_alVideoStreams_muted.next(value);
    };
    updatePaginatedStreams = (value) => {
        this.paginatedStreams.next(value);
    };
    updateLocalStreamAudio = (value) => {
        this.localStreamAudio.next(value);
    };
    updateDefAudioID = (value) => {
        this.defAudioID.next(value);
    };
    updateUserDefaultAudioInputDevice = (value) => {
        this.userDefaultAudioInputDevice.next(value);
    };
    updateUserDefaultAudioOutputDevice = (value) => {
        this.userDefaultAudioOutputDevice.next(value);
    };
    updatePrevAudioInputDevice = (value) => {
        this.prevAudioInputDevice.next(value);
    };
    updatePrevVideoInputDevice = (value) => {
        this.prevVideoInputDevice.next(value);
    };
    updateAudioPaused = (value) => {
        this.audioPaused.next(value);
    };
    updateMainScreenPerson = (value) => {
        this.mainScreenPerson.next(value);
    };
    updateAdminOnMainScreen = (value) => {
        this.adminOnMainScreen.next(value);
    };
    updateScreenStates = (value) => {
        this.screenStates.next(value);
    };
    updatePrevScreenStates = (value) => {
        this.prevScreenStates.next(value);
    };
    updateUpdateDateState = (value) => {
        this.updateDateState.next(value);
    };
    updateLastUpdate = (value) => {
        this.lastUpdate.next(value);
    };
    updateNForReadjustRecord = (value) => {
        this.nForReadjustRecord.next(value);
    };
    updateFixedPageLimit = (value) => {
        this.fixedPageLimit.next(value);
    };
    updateRemoveAltGrid = (value) => {
        this.removeAltGrid.next(value);
    };
    updateNForReadjust = (value) => {
        this.nForReadjust.next(value);
    };
    updateLastReorderTime = (value) => {
        this.lastReorderTime.next(value);
    };
    updateAudStreamNames = (value) => {
        this.audStreamNames.next(value);
    };
    updateCurrentUserPage = (value) => {
        this.currentUserPage.next(value);
    };
    updateMainHeightWidth = (value) => {
        this.mainHeightWidth.next(value);
    };
    updatePrevMainHeightWidth = (value) => {
        this.prevMainHeightWidth.next(value);
    };
    updatePrevDoPaginate = (value) => {
        this.prevDoPaginate.next(value);
    };
    updateDoPaginate = (value) => {
        this.doPaginate.next(value);
    };
    updateShareEnded = (value) => {
        this.shareEnded.next(value);
    };
    updateLStreams = (value) => {
        this.lStreams.next(value);
    };
    updateChatRefStreams = (value) => {
        this.chatRefStreams.next(value);
    };
    updateControlHeight = (value) => {
        this.controlHeight.next(value);
    };
    updateIsWideScreen = (value) => {
        this.isWideScreen.next(value);
    };
    updateIsMediumScreen = (value) => {
        this.isMediumScreen.next(value);
    };
    updateIsSmallScreen = (value) => {
        this.isSmallScreen.next(value);
    };
    updateAddGrid = (value) => {
        this.addGrid.next(value);
    };
    updateAddAltGrid = (value) => {
        this.addAltGrid.next(value);
    };
    updateGridRows = (value) => {
        this.gridRows.next(value);
    };
    updateGridCols = (value) => {
        this.gridCols.next(value);
    };
    updateAltGridRows = (value) => {
        this.altGridRows.next(value);
    };
    updateAltGridCols = (value) => {
        this.altGridCols.next(value);
    };
    updateNumberPages = (value) => {
        this.numberPages.next(value);
    };
    updateCurrentStreams = (value) => {
        this.currentStreams.next(value);
    };
    updateShowMiniView = (value) => {
        this.showMiniView.next(value);
    };
    updateNStream = (value) => {
        this.nStream.next(value);
    };
    updateDefer_receive = (value) => {
        this.defer_receive.next(value);
    };
    updateAllAudioStreams = (value) => {
        this.allAudioStreams.next(value);
    };
    updateRemoteScreenStream = (value) => {
        this.remoteScreenStream.next(value);
    };
    updateScreenProducer = (value) => {
        this.screenProducer.next(value);
    };
    updateGotAllVids = (value) => {
        this.gotAllVids.next(value);
    };
    updatePaginationHeightWidth = (value) => {
        this.paginationHeightWidth.next(value);
    };
    updatePaginationDirection = (value) => {
        this.paginationDirection.next(value);
    };
    updateGridSizes = (value) => {
        this.gridSizes.next(value);
    };
    updateScreenForceFullDisplay = (value) => {
        this.screenForceFullDisplay.next(value);
    };
    updateMainGridStream = (value) => {
        this.mainGridStream.next(value);
    };
    updateOtherGridStreams = (value) => {
        this.otherGridStreams.next(value);
    };
    updateAudioOnlyStreams = (value) => {
        this.audioOnlyStreams.next(value);
    };
    updateVideoInputs = (value) => {
        this.videoInputs.next(value);
    };
    updateAudioInputs = (value) => {
        this.audioInputs.next(value);
    };
    updateMeetingProgressTime = (value) => {
        this.meetingProgressTime.next(value);
    };
    updateMeetingElapsedTime = (value) => {
        this.meetingElapsedTime.next(value);
    };
    updateRef_participants = (value) => {
        this.ref_participants.next(value);
    };
    // Messages
    messages = new BehaviorSubject([]);
    startDirectMessage = new BehaviorSubject(false);
    directMessageDetails = new BehaviorSubject(null);
    showMessagesBadge = new BehaviorSubject(false);
    // Event Settings
    audioSetting = new BehaviorSubject('allow');
    videoSetting = new BehaviorSubject('allow');
    screenshareSetting = new BehaviorSubject('allow');
    chatSetting = new BehaviorSubject('allow');
    // Display Settings
    displayOption = new BehaviorSubject('media');
    autoWave = new BehaviorSubject(true);
    forceFullDisplay = new BehaviorSubject(true);
    prevForceFullDisplay = new BehaviorSubject(false);
    prevMeetingDisplayType = new BehaviorSubject('video');
    // Waiting Room
    waitingRoomFilter = new BehaviorSubject('');
    waitingRoomList = new BehaviorSubject(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    waitingRoomCounter = new BehaviorSubject(0);
    filteredWaitingRoomList = new BehaviorSubject(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    // Requests
    requestFilter = new BehaviorSubject('');
    requestList = new BehaviorSubject(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    requestCounter = new BehaviorSubject(0);
    filteredRequestList = new BehaviorSubject(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    // Total Requests and Waiting Room
    totalReqWait = new BehaviorSubject(0);
    // Alerts
    alertVisible = new BehaviorSubject(false);
    alertMessage = new BehaviorSubject('');
    alertType = new BehaviorSubject('success');
    alertDuration = new BehaviorSubject(3000);
    // Progress Timer
    progressTimerVisible = new BehaviorSubject(true);
    progressTimerValue = new BehaviorSubject(0);
    // Menu Modals
    isMenuModalVisible = new BehaviorSubject(false);
    isRecordingModalVisible = new BehaviorSubject(false);
    isSettingsModalVisible = new BehaviorSubject(false);
    isRequestsModalVisible = new BehaviorSubject(false);
    isWaitingModalVisible = new BehaviorSubject(false);
    isCoHostModalVisible = new BehaviorSubject(false);
    isMediaSettingsModalVisible = new BehaviorSubject(false);
    isDisplaySettingsModalVisible = new BehaviorSubject(false);
    // Other Modals
    isParticipantsModalVisible = new BehaviorSubject(false);
    isMessagesModalVisible = new BehaviorSubject(false);
    isConfirmExitModalVisible = new BehaviorSubject(false);
    isConfirmHereModalVisible = new BehaviorSubject(false);
    isShareEventModalVisible = new BehaviorSubject(false);
    isLoadingModalVisible = new BehaviorSubject(false);
    // Recording Options
    recordingMediaOptions = new BehaviorSubject('video');
    recordingAudioOptions = new BehaviorSubject('all');
    recordingVideoOptions = new BehaviorSubject('all');
    recordingVideoType = new BehaviorSubject('fullDisplay');
    recordingVideoOptimized = new BehaviorSubject(false);
    recordingDisplayType = new BehaviorSubject('video');
    recordingAddHLS = new BehaviorSubject(true);
    recordingNameTags = new BehaviorSubject(true);
    recordingBackgroundColor = new BehaviorSubject('#83c0e9');
    recordingNameTagsColor = new BehaviorSubject('#ffffff');
    recordingAddText = new BehaviorSubject(false);
    recordingCustomText = new BehaviorSubject('Add Text');
    recordingCustomTextPosition = new BehaviorSubject('top');
    recordingCustomTextColor = new BehaviorSubject('#ffffff');
    recordingOrientationVideo = new BehaviorSubject('landscape');
    clearedToResume = new BehaviorSubject(true);
    clearedToRecord = new BehaviorSubject(true);
    recordState = new BehaviorSubject('green');
    showRecordButtons = new BehaviorSubject(false);
    recordingProgressTime = new BehaviorSubject('00:00:00');
    audioSwitching = new BehaviorSubject(false);
    videoSwitching = new BehaviorSubject(false);
    // Media States
    videoAlreadyOn = new BehaviorSubject(false);
    audioAlreadyOn = new BehaviorSubject(false);
    componentSizes = new BehaviorSubject({
        mainHeight: 0,
        otherHeight: 0,
        mainWidth: 0,
        otherWidth: 0,
    });
    // Permissions
    hasCameraPermission = new BehaviorSubject(false);
    hasAudioPermission = new BehaviorSubject(false);
    // Transports
    transportCreated = new BehaviorSubject(false);
    transportCreatedVideo = new BehaviorSubject(false);
    transportCreatedAudio = new BehaviorSubject(false);
    transportCreatedScreen = new BehaviorSubject(false);
    producerTransport = new BehaviorSubject(null);
    videoProducer = new BehaviorSubject(null);
    params = new BehaviorSubject({});
    videoParams = new BehaviorSubject({});
    audioParams = new BehaviorSubject({});
    audioProducer = new BehaviorSubject(null);
    consumerTransports = new BehaviorSubject([]);
    consumingTransports = new BehaviorSubject([]);
    // Polls
    polls = new BehaviorSubject(this.useSeed && this.seedData?.polls ? this.seedData.polls : []);
    poll = new BehaviorSubject(null);
    isPollModalVisible = new BehaviorSubject(false);
    // Background
    customImage = new BehaviorSubject('');
    selectedImage = new BehaviorSubject('');
    segmentVideo = new BehaviorSubject(null);
    selfieSegmentation = new BehaviorSubject(null);
    pauseSegmentation = new BehaviorSubject(false);
    processedStream = new BehaviorSubject(null);
    keepBackground = new BehaviorSubject(false);
    backgroundHasChanged = new BehaviorSubject(false);
    virtualStream = new BehaviorSubject(null);
    mainCanvas = new BehaviorSubject(null);
    prevKeepBackground = new BehaviorSubject(false);
    appliedBackground = new BehaviorSubject(false);
    isBackgroundModalVisible = new BehaviorSubject(false);
    autoClickBackground = new BehaviorSubject(false);
    // Breakout Rooms
    breakoutRooms = new BehaviorSubject(this.useSeed && this.seedData?.breakoutRooms ? this.seedData.breakoutRooms : []);
    currentRoomIndex = new BehaviorSubject(0);
    canStartBreakout = new BehaviorSubject(false);
    breakOutRoomStarted = new BehaviorSubject(false);
    breakOutRoomEnded = new BehaviorSubject(false);
    hostNewRoom = new BehaviorSubject(-1);
    limitedBreakRoom = new BehaviorSubject([]);
    mainRoomsLength = new BehaviorSubject(0);
    memberRoom = new BehaviorSubject(-1);
    isBreakoutRoomsModalVisible = new BehaviorSubject(false);
    // Whiteboard
    whiteboardUsers = new BehaviorSubject(this.useSeed && this.seedData?.whiteboardUsers ? this.seedData.whiteboardUsers : []);
    currentWhiteboardIndex = new BehaviorSubject(0);
    canStartWhiteboard = new BehaviorSubject(false);
    whiteboardStarted = new BehaviorSubject(false);
    whiteboardEnded = new BehaviorSubject(false);
    whiteboardLimit = new BehaviorSubject(4);
    isWhiteboardModalVisible = new BehaviorSubject(false);
    isConfigureWhiteboardModalVisible = new BehaviorSubject(false);
    shapes = new BehaviorSubject([]);
    useImageBackground = new BehaviorSubject(true);
    redoStack = new BehaviorSubject([]);
    undoStack = new BehaviorSubject([]);
    canvasStream = new BehaviorSubject(null);
    canvasWhiteboard = new BehaviorSubject(null);
    // Screenboard
    canvasScreenboard = new BehaviorSubject(null);
    processedScreenStream = new BehaviorSubject(null);
    annotateScreenStream = new BehaviorSubject(false);
    mainScreenCanvas = new BehaviorSubject(null);
    isScreenboardModalVisible = new BehaviorSubject(false);
    //state variables for the control buttons
    micActive = new BehaviorSubject(this.audioAlreadyOn.value ? this.audioAlreadyOn.value : false);
    videoActive = new BehaviorSubject(this.videoAlreadyOn.value ? this.videoAlreadyOn.value : false);
    screenShareActive = new BehaviorSubject(false);
    endCallActive = new BehaviorSubject(false);
    participantsActive = new BehaviorSubject(false);
    menuActive = new BehaviorSubject(false);
    commentsActive = new BehaviorSubject(false);
    // Update functions
    updateMessages = (value) => {
        this.messages.next(value);
    };
    updateStartDirectMessage = (value) => {
        this.startDirectMessage.next(value);
    };
    updateDirectMessageDetails = (value) => {
        this.directMessageDetails.next(value);
    };
    updateShowMessagesBadge = (value) => {
        this.showMessagesBadge.next(value);
    };
    updateAudioSetting = (value) => {
        this.audioSetting.next(value);
    };
    updateVideoSetting = (value) => {
        this.videoSetting.next(value);
    };
    updateScreenshareSetting = (value) => {
        this.screenshareSetting.next(value);
    };
    updateChatSetting = (value) => {
        this.chatSetting.next(value);
    };
    updateDisplayOption = (value) => {
        this.displayOption.next(value);
    };
    updateAutoWave = (value) => {
        this.autoWave.next(value);
    };
    updateForceFullDisplay = (value) => {
        this.forceFullDisplay.next(value);
    };
    updatePrevForceFullDisplay = (value) => {
        this.prevForceFullDisplay.next(value);
    };
    updatePrevMeetingDisplayType = (value) => {
        this.prevMeetingDisplayType.next(value);
    };
    updateWaitingRoomCounter = (value) => {
        this.waitingRoomCounter.next(value);
    };
    updateWaitingRoomFilter = (value) => {
        this.waitingRoomFilter.next(value);
    };
    updateWaitingRoomList = (value) => {
        this.waitingRoomList.next(value);
        this.filteredWaitingRoomList.next(value);
        this.waitingRoomCounter.next(value.length);
    };
    onWaitingRoomFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredWaitingRoom = this.waitingRoomList
                .getValue()
                .filter((waitingRoom) => {
                return waitingRoom.name.toLowerCase().includes(value.toLowerCase());
            });
            this.filteredWaitingRoomList.next(filteredWaitingRoom);
            this.waitingRoomCounter.next(filteredWaitingRoom.length);
        }
        else {
            this.filteredWaitingRoomList.next(this.waitingRoomList.getValue());
            this.waitingRoomCounter.next(this.waitingRoomList.getValue().length);
        }
    };
    onWaitingRoomClose = () => {
        this.updateIsWaitingModalVisible(false);
    };
    updateRequestCounter = (value) => {
        this.requestCounter.next(value);
    };
    updateRequestFilter = (value) => {
        this.requestFilter.next(value);
    };
    updateRequestList = (value) => {
        this.requestList.next(value);
        this.filteredRequestList.next(value);
        this.requestCounter.next(value.length);
    };
    onRequestFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredRequest = this.requestList.getValue().filter((request) => {
                return request?.name?.toLowerCase().includes(value.toLowerCase());
            });
            this.filteredRequestList.next(filteredRequest);
            this.requestCounter.next(filteredRequest.length);
        }
        else {
            this.filteredRequestList.next(this.requestList.getValue());
            this.requestCounter.next(this.requestList.getValue().length);
        }
    };
    onRequestClose = () => {
        this.updateIsRequestsModalVisible(false);
    };
    updateTotalReqWait = (value) => {
        this.totalReqWait.next(value);
    };
    updateAlertVisible = (value) => {
        this.alertVisible.next(value);
    };
    updateAlertMessage = (value) => {
        this.alertMessage.next(value);
    };
    updateAlertType = (value) => {
        this.alertType.next(value);
    };
    updateAlertDuration = (value) => {
        this.alertDuration.next(value);
    };
    updateProgressTimerVisible = (value) => {
        this.progressTimerVisible.next(value);
    };
    updateProgressTimerValue = (value) => {
        this.progressTimerValue.next(value);
    };
    updateIsMenuModalVisible = (value) => {
        this.isMenuModalVisible.next(value);
    };
    updateIsRecordingModalVisible = (value) => {
        this.isRecordingModalVisible.next(value);
        if (value) {
            this.updateConfirmedToRecord(false);
        }
        else {
            if (this.clearedToRecord.getValue() &&
                this.clearedToResume.getValue() &&
                this.recordStarted.getValue()) {
                this.updateShowRecordButtons(true);
            }
        }
    };
    updateIsSettingsModalVisible = (value) => {
        this.isSettingsModalVisible.next(value);
    };
    updateIsRequestsModalVisible = (value) => {
        this.isRequestsModalVisible.next(value);
    };
    updateIsWaitingModalVisible = (value) => {
        this.isWaitingModalVisible.next(value);
    };
    updateIsCoHostModalVisible = (value) => {
        this.isCoHostModalVisible.next(value);
    };
    updateIsMediaSettingsModalVisible = (value) => {
        this.isMediaSettingsModalVisible.next(value);
    };
    updateIsDisplaySettingsModalVisible = (value) => {
        this.isDisplaySettingsModalVisible.next(value);
    };
    updateIsParticipantsModalVisible = (value) => {
        this.isParticipantsModalVisible.next(value);
    };
    updateIsMessagesModalVisible = (value) => {
        this.isMessagesModalVisible.next(value);
        if (!value) {
            this.updateShowMessagesBadge(false);
        }
    };
    updateIsConfirmExitModalVisible = (value) => {
        this.isConfirmExitModalVisible.next(value);
    };
    updateIsConfirmHereModalVisible = (value) => {
        this.isConfirmHereModalVisible.next(value);
    };
    updateIsLoadingModalVisible = (value) => {
        this.isLoadingModalVisible.next(value);
    };
    updateIsShareEventModalVisible = (value) => {
        this.isShareEventModalVisible.next(value);
    };
    updateRecordingMediaOptions = (value) => {
        this.recordingMediaOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAudioOptions = (value) => {
        this.recordingAudioOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptions = (value) => {
        this.recordingVideoOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoType = (value) => {
        this.recordingVideoType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptimized = (value) => {
        this.recordingVideoOptimized.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingDisplayType = (value) => {
        this.recordingDisplayType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddHLS = (value) => {
        this.recordingAddHLS.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddText = (value) => {
        this.recordingAddText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomText = (value) => {
        this.recordingCustomText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextPosition = (value) => {
        this.recordingCustomTextPosition.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextColor = (value) => {
        this.recordingCustomTextColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTags = (value) => {
        this.recordingNameTags.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingBackgroundColor = (value) => {
        this.recordingBackgroundColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTagsColor = (value) => {
        this.recordingNameTagsColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingOrientationVideo = (value) => {
        this.recordingOrientationVideo.next(value);
        this.clearedToRecord.next(false);
    };
    updateClearedToResume = (value) => {
        this.clearedToResume.next(value);
    };
    updateClearedToRecord = (value) => {
        this.clearedToRecord.next(value);
    };
    updateRecordState = (value) => {
        if (this.recordStarted.value && !this.recordStopped.value) {
            if (!this.recordPaused.value) {
                this.recordState.next('red');
            }
            else {
                this.recordState.next('yellow');
            }
        }
        else {
            this.recordState.next(value);
        }
        this.recordState.next(value);
    };
    updateShowRecordButtons = (value) => {
        this.showRecordButtons.next(value);
    };
    updateRecordingProgressTime = (value) => {
        this.recordingProgressTime.next(value);
        this.updateRecordTimerWidget();
    };
    updateAudioSwitching = (value) => {
        this.audioSwitching.next(value);
    };
    updateVideoSwitching = (value) => {
        this.videoSwitching.next(value);
    };
    updateVideoAlreadyOn = (value) => {
        this.videoAlreadyOn.next(value);
        this.videoActive.next(value);
    };
    updateAudioAlreadyOn = (value) => {
        this.audioAlreadyOn.next(value);
        this.micActive.next(value);
    };
    updateComponentSizes = (sizes) => {
        this.componentSizes.next(sizes);
    };
    updateHasCameraPermission = (value) => {
        this.hasCameraPermission.next(value);
    };
    updateHasAudioPermission = (value) => {
        this.hasAudioPermission.next(value);
    };
    requestPermissionCamera() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    requestPermissionAudio() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    updateTransportCreated = (value) => {
        this.transportCreated.next(value);
    };
    updateTransportCreatedVideo = (value) => {
        this.transportCreatedVideo.next(value);
    };
    updateTransportCreatedAudio = (value) => {
        this.transportCreatedAudio.next(value);
    };
    updateTransportCreatedScreen = (value) => {
        this.transportCreatedScreen.next(value);
    };
    updateProducerTransport = (value) => {
        this.producerTransport.next(value);
    };
    updateVideoProducer = (value) => {
        this.videoProducer.next(value);
    };
    updateParams = (value) => {
        this.params.next(value);
    };
    updateVideoParams = (value) => {
        this.videoParams.next(value);
    };
    updateAudioParams = (value) => {
        this.audioParams.next(value);
    };
    updateAudioProducer = (value) => {
        this.audioProducer.next(value);
    };
    updateConsumerTransports = (value) => {
        this.consumerTransports.next(value);
    };
    updateConsumingTransports = (value) => {
        this.consumingTransports.next(value);
    };
    updatePolls = (value) => {
        this.polls.next(value);
    };
    updatePoll = (value) => {
        this.poll.next(value);
    };
    updateIsPollModalVisible = (value) => {
        this.isPollModalVisible.next(value);
    };
    updateCustomImage = (value) => {
        this.customImage.next(value);
    };
    updateSelectedImage = (value) => {
        this.selectedImage.next(value);
    };
    updateSegmentVideo = (value) => {
        this.segmentVideo.next(value);
    };
    updateSelfieSegmentation = (value) => {
        this.selfieSegmentation.next(value);
    };
    updatePauseSegmentation = (value) => {
        this.pauseSegmentation.next(value);
    };
    updateProcessedStream = (value) => {
        this.processedStream.next(value);
    };
    updateKeepBackground = (value) => {
        this.keepBackground.next(value);
    };
    updateBackgroundHasChanged = (value) => {
        this.backgroundHasChanged.next(value);
    };
    updateVirtualStream = (value) => {
        this.virtualStream.next(value);
    };
    updateMainCanvas = (value) => {
        this.mainCanvas.next(value);
    };
    updatePrevKeepBackground = (value) => {
        this.prevKeepBackground.next(value);
    };
    updateAppliedBackground = (value) => {
        this.appliedBackground.next(value);
    };
    updateIsBackgroundModalVisible = (value) => {
        this.isBackgroundModalVisible.next(value);
    };
    updateAutoClickBackground = (value) => {
        this.autoClickBackground.next(value);
    };
    updateBreakoutRooms = (value) => {
        this.breakoutRooms.next(value);
    };
    updateCurrentRoomIndex = (value) => {
        this.currentRoomIndex.next(value);
    };
    updateCanStartBreakout = (value) => {
        this.canStartBreakout.next(value);
    };
    updateBreakOutRoomStarted = (value) => {
        this.breakOutRoomStarted.next(value);
    };
    updateBreakOutRoomEnded = (value) => {
        this.breakOutRoomEnded.next(value);
    };
    updateHostNewRoom = (value) => {
        this.hostNewRoom.next(value);
    };
    updateLimitedBreakRoom = (value) => {
        this.limitedBreakRoom.next(value);
    };
    updateMainRoomsLength = (value) => {
        this.mainRoomsLength.next(value);
    };
    updateMemberRoom = (value) => {
        this.memberRoom.next(value);
    };
    updateIsBreakoutRoomsModalVisible = (value) => {
        this.isBreakoutRoomsModalVisible.next(value);
    };
    updateWhiteboardUsers = (value) => {
        this.whiteboardUsers.next(value);
    };
    updateCurrentWhiteboardIndex = (value) => {
        this.currentWhiteboardIndex.next(value);
    };
    updateCanStartWhiteboard = (value) => {
        this.canStartWhiteboard.next(value);
    };
    updateWhiteboardStarted = (value) => {
        this.whiteboardStarted.next(value);
    };
    updateWhiteboardEnded = (value) => {
        this.whiteboardEnded.next(value);
    };
    updateWhiteboardLimit = (value) => {
        this.whiteboardLimit.next(value);
    };
    updateIsWhiteboardModalVisible = (value) => {
        this.isWhiteboardModalVisible.next(value);
    };
    updateIsConfigureWhiteboardModalVisible = (value) => {
        this.isConfigureWhiteboardModalVisible.next(value);
    };
    updateShapes = (value) => {
        this.shapes.next(value);
    };
    updateUseImageBackground = (value) => {
        this.useImageBackground.next(value);
    };
    updateRedoStack = (value) => {
        this.redoStack.next(value);
    };
    updateUndoStack = (value) => {
        this.undoStack.next(value);
    };
    updateCanvasStream = (value) => {
        this.canvasStream.next(value);
    };
    updateCanvasWhiteboard = (value) => {
        this.canvasWhiteboard.next(value);
    };
    updateCanvasScreenboard = (value) => {
        this.canvasScreenboard.next(value);
    };
    updateProcessedScreenStream = (value) => {
        this.processedScreenStream.next(value);
    };
    updateAnnotateScreenStream = (value) => {
        this.annotateScreenStream.next(value);
    };
    updateMainScreenCanvas = (value) => {
        this.mainScreenCanvas.next(value);
    };
    updateIsScreenboardModalVisible = (value) => {
        this.isScreenboardModalVisible.next(value);
    };
    checkOrientation = () => {
        const isPortrait = window.matchMedia('(orientation: portrait)').matches;
        return isPortrait ? 'portrait' : 'landscape';
    };
    showAlert = ({ message, type, duration = 3000, }) => {
        this.updateAlertMessage(message);
        this.updateAlertType(type);
        this.updateAlertDuration(duration);
        this.updateAlertVisible(true);
    };
    getAllParams() {
        return {
            localUIMode: this.localUIMode.value, // Local UI mode
            // Room Details
            roomName: this.roomName.value,
            member: this.member.value,
            adminPasscode: this.adminPasscode.value,
            youAreCoHost: this.youAreCoHost.value,
            youAreHost: this.youAreHost.value,
            islevel: this.islevel.value,
            confirmedToRecord: this.confirmedToRecord.value,
            meetingDisplayType: this.meetingDisplayType.value,
            meetingVideoOptimized: this.meetingVideoOptimized.value,
            eventType: this.eventType.value,
            participants: this.participants.value,
            filteredParticipants: this.filteredParticipants.value,
            participantsCounter: this.participantsCounter.value,
            participantsFilter: this.participantsFilter.value,
            // More room details - media
            consume_sockets: this.consume_sockets.value,
            rtpCapabilities: this.rtpCapabilities.value,
            roomRecvIPs: this.roomRecvIPs.value,
            meetingRoomParams: this.meetingRoomParams.value,
            itemPageLimit: this.itemPageLimit.value,
            audioOnlyRoom: this.audioOnlyRoom.value,
            addForBasic: this.addForBasic.value,
            screenPageLimit: this.screenPageLimit.value,
            shareScreenStarted: this.shareScreenStarted.value,
            shared: this.shared.value,
            targetOrientation: this.targetOrientation.value,
            targetResolution: this.targetResolution.value,
            targetResolutionHost: this.targetResolutionHost.value,
            vidCons: this.vidCons.value,
            frameRate: this.frameRate.value,
            hParams: this.hParams.value,
            vParams: this.vParams.value,
            screenParams: this.screenParams.value,
            aParams: this.aParams.value,
            // More room details - recording
            recordingAudioPausesLimit: this.recordingAudioPausesLimit.value,
            recordingAudioPausesCount: this.recordingAudioPausesCount.value,
            recordingAudioSupport: this.recordingAudioSupport.value,
            recordingAudioPeopleLimit: this.recordingAudioPeopleLimit.value,
            recordingAudioParticipantsTimeLimit: this.recordingAudioParticipantsTimeLimit.value,
            recordingVideoPausesCount: this.recordingVideoPausesCount.value,
            recordingVideoPausesLimit: this.recordingVideoPausesLimit.value,
            recordingVideoSupport: this.recordingVideoSupport.value,
            recordingVideoPeopleLimit: this.recordingVideoPeopleLimit.value,
            recordingVideoParticipantsTimeLimit: this.recordingVideoParticipantsTimeLimit.value,
            recordingAllParticipantsSupport: this.recordingAllParticipantsSupport.value,
            recordingVideoParticipantsSupport: this.recordingVideoParticipantsSupport.value,
            recordingAllParticipantsFullRoomSupport: this.recordingAllParticipantsFullRoomSupport.value,
            recordingVideoParticipantsFullRoomSupport: this.recordingVideoParticipantsFullRoomSupport.value,
            recordingPreferredOrientation: this.recordingPreferredOrientation.value,
            recordingSupportForOtherOrientation: this.recordingSupportForOtherOrientation.value,
            recordingMultiFormatsSupport: this.recordingMultiFormatsSupport.value,
            userRecordingParams: this.userRecordingParams.value,
            canRecord: this.canRecord.value,
            startReport: this.startReport.value,
            endReport: this.endReport.value,
            recordStartTime: this.recordStartTime.value,
            recordElapsedTime: this.recordElapsedTime.value,
            isTimerRunning: this.isTimerRunning.value,
            canPauseResume: this.canPauseResume.value,
            recordChangeSeconds: this.recordChangeSeconds.value,
            pauseLimit: this.pauseLimit.value,
            pauseRecordCount: this.pauseRecordCount.value,
            canLaunchRecord: this.canLaunchRecord.value,
            stopLaunchRecord: this.stopLaunchRecord.value,
            participantsAll: this.participantsAll.value,
            firstAll: this.firstAll.value,
            updateMainWindow: this.updateMainWindow.value,
            first_round: this.first_round.value,
            landScaped: this.landScaped.value,
            lock_screen: this.lock_screen.value,
            screenId: this.screenId.value,
            allVideoStreams: this.allVideoStreams.value,
            newLimitedStreams: this.newLimitedStreams.value,
            newLimitedStreamsIDs: this.newLimitedStreamsIDs.value,
            activeSounds: this.activeSounds.value,
            screenShareIDStream: this.screenShareIDStream.value,
            screenShareNameStream: this.screenShareNameStream.value,
            adminIDStream: this.adminIDStream.value,
            adminNameStream: this.adminNameStream.value,
            youYouStream: this.youYouStream.value,
            youYouStreamIDs: this.youYouStreamIDs.value,
            localStream: this.localStream.value,
            recordStarted: this.recordStarted.value,
            recordResumed: this.recordResumed.value,
            recordPaused: this.recordPaused.value,
            recordStopped: this.recordStopped.value,
            adminRestrictSetting: this.adminRestrictSetting.value,
            videoRequestState: this.videoRequestState.value,
            videoRequestTime: this.videoRequestTime.value,
            videoAction: this.videoAction.value,
            localStreamVideo: this.localStreamVideo.value,
            userDefaultVideoInputDevice: this.userDefaultVideoInputDevice.value,
            currentFacingMode: this.currentFacingMode.value,
            prevFacingMode: this.prevFacingMode.value,
            defVideoID: this.defVideoID.value,
            allowed: this.allowed.value,
            dispActiveNames: this.dispActiveNames.value,
            p_dispActiveNames: this.p_dispActiveNames.value,
            activeNames: this.activeNames.value,
            prevActiveNames: this.prevActiveNames.value,
            p_activeNames: this.p_activeNames.value,
            membersReceived: this.membersReceived.value,
            deferScreenReceived: this.deferScreenReceived.value,
            hostFirstSwitch: this.hostFirstSwitch.value,
            micAction: this.micAction.value,
            screenAction: this.screenAction.value,
            chatAction: this.chatAction.value,
            audioRequestState: this.audioRequestState.value,
            screenRequestState: this.screenRequestState.value,
            chatRequestState: this.chatRequestState.value,
            audioRequestTime: this.audioRequestTime.value,
            screenRequestTime: this.screenRequestTime.value,
            chatRequestTime: this.chatRequestTime.value,
            updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
            oldSoundIds: this.oldSoundIds.value,
            hostLabel: this.hostLabel.value,
            mainScreenFilled: this.mainScreenFilled.value,
            localStreamScreen: this.localStreamScreen.value,
            screenAlreadyOn: this.screenAlreadyOn.value,
            chatAlreadyOn: this.chatAlreadyOn.value,
            redirectURL: this.redirectURL.value,
            oldAllStreams: this.oldAllStreams.value,
            adminVidID: this.adminVidID.value,
            streamNames: this.streamNames.value,
            non_alVideoStreams: this.non_alVideoStreams.value,
            sortAudioLoudness: this.sortAudioLoudness.value,
            audioDecibels: this.audioDecibels.value,
            mixed_alVideoStreams: this.mixed_alVideoStreams.value,
            non_alVideoStreams_muted: this.non_alVideoStreams_muted.value,
            paginatedStreams: this.paginatedStreams.value,
            localStreamAudio: this.localStreamAudio.value,
            defAudioID: this.defAudioID.value,
            userDefaultAudioInputDevice: this.userDefaultAudioInputDevice.value,
            userDefaultAudioOutputDevice: this.userDefaultAudioOutputDevice.value,
            prevAudioInputDevice: this.prevAudioInputDevice.value,
            prevVideoInputDevice: this.prevVideoInputDevice.value,
            audioPaused: this.audioPaused.value,
            mainScreenPerson: this.mainScreenPerson.value,
            adminOnMainScreen: this.adminOnMainScreen.value,
            screenStates: this.screenStates.value,
            prevScreenStates: this.prevScreenStates.value,
            updateDateState: this.updateDateState.value,
            lastUpdate: this.lastUpdate.value,
            nForReadjustRecord: this.nForReadjustRecord.value,
            fixedPageLimit: this.fixedPageLimit.value,
            removeAltGrid: this.removeAltGrid.value,
            nForReadjust: this.nForReadjust.value,
            lastReorderTime: this.lastReorderTime.value,
            reorderInterval: this.reorderInterval.value,
            fastReorderInterval: this.fastReorderInterval.value,
            audStreamNames: this.audStreamNames.value,
            currentUserPage: this.currentUserPage.value,
            mainHeightWidth: this.mainHeightWidth.value,
            prevMainHeightWidth: this.prevMainHeightWidth.value,
            prevDoPaginate: this.prevDoPaginate.value,
            doPaginate: this.doPaginate.value,
            shareEnded: this.shareEnded.value,
            lStreams: this.lStreams.value,
            chatRefStreams: this.chatRefStreams.value,
            controlHeight: this.controlHeight.value,
            isWideScreen: this.isWideScreen.value,
            isMediumScreen: this.isMediumScreen.value,
            isSmallScreen: this.isSmallScreen.value,
            addGrid: this.addGrid.value,
            addAltGrid: this.addAltGrid.value,
            gridRows: this.gridRows.value,
            gridCols: this.gridCols.value,
            altGridRows: this.altGridRows.value,
            altGridCols: this.altGridCols.value,
            numberPages: this.numberPages.value,
            currentStreams: this.currentStreams.value,
            showMiniView: this.showMiniView.value,
            nStream: this.nStream.value,
            defer_receive: this.defer_receive.value,
            allAudioStreams: this.allAudioStreams.value,
            screenProducer: this.screenProducer.value,
            remoteScreenStream: this.remoteScreenStream.value,
            gotAllVids: this.gotAllVids.value,
            paginationHeightWidth: this.paginationHeightWidth.value,
            paginationDirection: this.paginationDirection.value,
            gridSizes: this.gridSizes.value,
            screenForceFullDisplay: this.screenForceFullDisplay.value,
            mainGridStream: this.mainGridStream.value,
            otherGridStreams: this.otherGridStreams.value,
            audioOnlyStreams: this.audioOnlyStreams.value,
            videoInputs: this.videoInputs.value,
            audioInputs: this.audioInputs.value,
            meetingProgressTime: this.meetingProgressTime.value,
            meetingElapsedTime: this.meetingElapsedTime.value,
            ref_participants: this.ref_participants.value,
            messages: this.messages.value,
            startDirectMessage: this.startDirectMessage.value,
            directMessageDetails: this.directMessageDetails.value,
            coHost: this.coHost.value,
            coHostResponsibility: this.coHostResponsibility.value,
            // Event settings
            audioSetting: this.audioSetting.value,
            videoSetting: this.videoSetting.value,
            screenshareSetting: this.screenshareSetting.value,
            chatSetting: this.chatSetting.value,
            // Display settings
            autoWave: this.autoWave.value,
            forceFullDisplay: this.forceFullDisplay.value,
            prevForceFullDisplay: this.prevForceFullDisplay.value,
            prevMeetingDisplayType: this.prevMeetingDisplayType.value,
            // Waiting room
            waitingRoomFilter: this.waitingRoomFilter.value,
            waitingRoomList: this.waitingRoomList.value,
            waitingRoomCounter: this.waitingRoomCounter.value,
            filteredWaitingRoomList: this.filteredWaitingRoomList.value,
            // Requests
            requestFilter: this.requestFilter.value,
            requestList: this.requestList.value,
            requestCounter: this.requestCounter.value,
            filteredRequestList: this.filteredRequestList.value,
            // Total requests and waiting room
            totalReqWait: this.totalReqWait.value,
            // Alerts
            alertVisible: this.alertVisible.value,
            alertMessage: this.alertMessage.value,
            alertType: this.alertType.value,
            alertDuration: this.alertDuration.value,
            // Progress Timer
            progressTimerVisible: this.progressTimerVisible.value,
            progressTimerValue: this.progressTimerValue.value,
            // Menu modals
            isMenuModalVisible: this.isMenuModalVisible.value,
            isRecordingModalVisible: this.isRecordingModalVisible.value,
            isSettingsModalVisible: this.isSettingsModalVisible.value,
            isRequestsModalVisible: this.isRequestsModalVisible.value,
            isWaitingModalVisible: this.isWaitingModalVisible.value,
            isCoHostModalVisible: this.isCoHostModalVisible.value,
            isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
            isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            // Other Modals
            isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            isMessagesModalVisible: this.isMessagesModalVisible.value,
            isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            isConfirmHereModalVisible: this.isConfirmHereModalVisible.value,
            isLoadingModalVisible: this.isLoadingModalVisible.value,
            // Recording Options
            recordingMediaOptions: this.recordingMediaOptions.value,
            recordingAudioOptions: this.recordingAudioOptions.value,
            recordingVideoOptions: this.recordingVideoOptions.value,
            recordingVideoType: this.recordingVideoType.value,
            recordingVideoOptimized: this.recordingVideoOptimized.value,
            recordingDisplayType: this.recordingDisplayType.value,
            recordingAddHLS: this.recordingAddHLS.value,
            recordingAddText: this.recordingAddText.value,
            recordingCustomText: this.recordingCustomText.value,
            recordingCustomTextPosition: this.recordingCustomTextPosition.value,
            recordingCustomTextColor: this.recordingCustomTextColor.value,
            recordingNameTags: this.recordingNameTags.value,
            recordingBackgroundColor: this.recordingBackgroundColor.value,
            recordingNameTagsColor: this.recordingNameTagsColor.value,
            recordingOrientationVideo: this.recordingOrientationVideo.value,
            clearedToResume: this.clearedToResume.value,
            clearedToRecord: this.clearedToRecord.value,
            recordState: this.recordState.value,
            showRecordButtons: this.showRecordButtons.value,
            recordingProgressTime: this.recordingProgressTime.value,
            audioSwitching: this.audioSwitching.value,
            videoSwitching: this.videoSwitching.value,
            // Media states
            videoAlreadyOn: this.videoAlreadyOn.value,
            audioAlreadyOn: this.audioAlreadyOn.value,
            componentSizes: this.componentSizes.value,
            // Permissions
            hasCameraPermission: this.hasCameraPermission.value,
            hasAudioPermission: this.hasAudioPermission.value,
            // Transports
            transportCreated: this.transportCreated.value,
            transportCreatedVideo: this.transportCreatedVideo.value,
            transportCreatedAudio: this.transportCreatedAudio.value,
            transportCreatedScreen: this.transportCreatedScreen.value,
            producerTransport: this.producerTransport.value,
            videoProducer: this.videoProducer.value,
            params: this.params.value,
            videoParams: this.videoParams.value,
            audioParams: this.audioParams.value,
            audioProducer: this.audioProducer.value,
            consumerTransports: this.consumerTransports.value,
            consumingTransports: this.consumingTransports.value,
            // Polls
            polls: this.polls.value,
            poll: this.poll.value,
            isPollModalVisible: this.isPollModalVisible.value,
            // Background
            customImage: this.customImage.value,
            selectedImage: this.selectedImage.value,
            segmentVideo: this.segmentVideo.value,
            selfieSegmentation: this.selfieSegmentation.value,
            pauseSegmentation: this.pauseSegmentation.value,
            processedStream: this.processedStream.value,
            keepBackground: this.keepBackground.value,
            backgroundHasChanged: this.backgroundHasChanged.value,
            virtualStream: this.virtualStream.value,
            mainCanvas: this.mainCanvas.value,
            prevKeepBackground: this.prevKeepBackground.value,
            appliedBackground: this.appliedBackground.value,
            isBackgroundModalVisible: this.isBackgroundModalVisible.value,
            autoClickBackground: this.autoClickBackground.value,
            // Breakout rooms
            breakoutRooms: this.breakoutRooms.value,
            currentRoomIndex: this.currentRoomIndex.value,
            canStartBreakout: this.canStartBreakout.value,
            breakOutRoomStarted: this.breakOutRoomStarted.value,
            breakOutRoomEnded: this.breakOutRoomEnded.value,
            hostNewRoom: this.hostNewRoom.value,
            limitedBreakRoom: this.limitedBreakRoom.value,
            mainRoomsLength: this.mainRoomsLength.value,
            memberRoom: this.memberRoom.value,
            isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            // Whiteboard
            whiteboardUsers: this.whiteboardUsers.value,
            currentWhiteboardIndex: this.currentWhiteboardIndex.value,
            canStartWhiteboard: this.canStartWhiteboard.value,
            whiteboardStarted: this.whiteboardStarted.value,
            whiteboardEnded: this.whiteboardEnded.value,
            whiteboardLimit: this.whiteboardLimit.value,
            isWhiteboardModalVisible: this.isWhiteboardModalVisible.value,
            isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            shapes: this.shapes.value,
            useImageBackground: this.useImageBackground.value,
            redoStack: this.redoStack.value,
            undoStack: this.undoStack.value,
            canvasStream: this.canvasStream.value,
            canvasWhiteboard: this.canvasWhiteboard.value,
            // Screenboard
            canvasScreenboard: this.canvasScreenboard.value,
            processedScreenStream: this.processedScreenStream.value,
            annotateScreenStream: this.annotateScreenStream.value,
            mainScreenCanvas: this.mainScreenCanvas.value,
            isScreenboardModalVisible: this.isScreenboardModalVisible.value,
            validated: this.validated.value,
            device: this.device.value,
            socket: this.socket.value,
            checkMediaPermission: false,
            onWeb: true,
            // Update functions
            updateRoomName: this.updateRoomName.bind(this),
            updateMember: this.updateMember.bind(this),
            updateAdminPasscode: this.updateAdminPasscode.bind(this),
            updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
            updateYouAreHost: this.updateYouAreHost.bind(this),
            updateIslevel: this.updateIslevel.bind(this),
            updateCoHost: this.updateCoHost.bind(this),
            updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
            updateConfirmedToRecord: this.updateConfirmedToRecord.bind(this),
            updateMeetingDisplayType: this.updateMeetingDisplayType.bind(this),
            updateMeetingVideoOptimized: this.updateMeetingVideoOptimized.bind(this),
            updateEventType: this.updateEventType.bind(this),
            updateParticipants: this.updateParticipants.bind(this),
            updateParticipantsCounter: this.updateParticipantsCounter.bind(this),
            updateParticipantsFilter: this.updateParticipantsFilter.bind(this),
            // More update functions for media details
            updateConsume_sockets: this.updateConsume_sockets.bind(this),
            updateRtpCapabilities: this.updateRtpCapabilities.bind(this),
            updateRoomRecvIPs: this.updateRoomRecvIPs.bind(this),
            updateMeetingRoomParams: this.updateMeetingRoomParams.bind(this),
            updateItemPageLimit: this.updateItemPageLimit.bind(this),
            updateAudioOnlyRoom: this.updateAudioOnlyRoom.bind(this),
            updateAddForBasic: this.updateAddForBasic.bind(this),
            updateScreenPageLimit: this.updateScreenPageLimit.bind(this),
            updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
            updateShared: this.updateShared.bind(this),
            updateTargetOrientation: this.updateTargetOrientation.bind(this),
            updateTargetResolution: this.updateTargetResolution.bind(this),
            updateTargetResolutionHost: this.updateTargetResolutionHost.bind(this),
            updateVidCons: this.updateVidCons.bind(this),
            updateFrameRate: this.updateFrameRate.bind(this),
            updateHParams: this.updateHParams.bind(this),
            updateVParams: this.updateVParams.bind(this),
            updateScreenParams: this.updateScreenParams.bind(this),
            updateAParams: this.updateAParams.bind(this),
            // More update functions for recording details
            updateRecordingAudioPausesLimit: this.updateRecordingAudioPausesLimit.bind(this),
            updateRecordingAudioPausesCount: this.updateRecordingAudioPausesCount.bind(this),
            updateRecordingAudioSupport: this.updateRecordingAudioSupport.bind(this),
            updateRecordingAudioPeopleLimit: this.updateRecordingAudioPeopleLimit.bind(this),
            updateRecordingAudioParticipantsTimeLimit: this.updateRecordingAudioParticipantsTimeLimit.bind(this),
            updateRecordingVideoPausesCount: this.updateRecordingVideoPausesCount.bind(this),
            updateRecordingVideoPausesLimit: this.updateRecordingVideoPausesLimit.bind(this),
            updateRecordingVideoSupport: this.updateRecordingVideoSupport.bind(this),
            updateRecordingVideoPeopleLimit: this.updateRecordingVideoPeopleLimit.bind(this),
            updateRecordingVideoParticipantsTimeLimit: this.updateRecordingVideoParticipantsTimeLimit.bind(this),
            updateRecordingAllParticipantsSupport: this.updateRecordingAllParticipantsSupport.bind(this),
            updateRecordingVideoParticipantsSupport: this.updateRecordingVideoParticipantsSupport.bind(this),
            updateRecordingAllParticipantsFullRoomSupport: this.updateRecordingAllParticipantsFullRoomSupport.bind(this),
            updateRecordingVideoParticipantsFullRoomSupport: this.updateRecordingVideoParticipantsFullRoomSupport.bind(this),
            updateRecordingPreferredOrientation: this.updateRecordingPreferredOrientation.bind(this),
            updateRecordingSupportForOtherOrientation: this.updateRecordingSupportForOtherOrientation.bind(this),
            updateRecordingMultiFormatsSupport: this.updateRecordingMultiFormatsSupport.bind(this),
            updateUserRecordingParams: this.updateUserRecordingParams.bind(this),
            updateCanRecord: this.updateCanRecord.bind(this),
            updateStartReport: this.updateStartReport.bind(this),
            updateEndReport: this.updateEndReport.bind(this),
            updateRecordTimerInterval: this.updateRecordTimerInterval.bind(this),
            updateRecordStartTime: this.updateRecordStartTime.bind(this),
            updateRecordElapsedTime: this.updateRecordElapsedTime.bind(this),
            updateIsTimerRunning: this.updateIsTimerRunning.bind(this),
            updateCanPauseResume: this.updateCanPauseResume.bind(this),
            updateRecordChangeSeconds: this.updateRecordChangeSeconds.bind(this),
            updatePauseLimit: this.updatePauseLimit.bind(this),
            updatePauseRecordCount: this.updatePauseRecordCount.bind(this),
            updateCanLaunchRecord: this.updateCanLaunchRecord.bind(this),
            updateStopLaunchRecord: this.updateStopLaunchRecord.bind(this),
            updateParticipantsAll: this.updateParticipantsAll.bind(this),
            updateFirstAll: this.updateFirstAll.bind(this),
            updateUpdateMainWindow: this.updateUpdateMainWindow.bind(this),
            updateFirst_round: this.updateFirst_round.bind(this),
            updateLandScaped: this.updateLandScaped.bind(this),
            updateLock_screen: this.updateLock_screen.bind(this),
            updateScreenId: this.updateScreenId.bind(this),
            updateAllVideoStreams: this.updateAllVideoStreams.bind(this),
            updateNewLimitedStreams: this.updateNewLimitedStreams.bind(this),
            updateNewLimitedStreamsIDs: this.updateNewLimitedStreamsIDs.bind(this),
            updateActiveSounds: this.updateActiveSounds.bind(this),
            updateScreenShareIDStream: this.updateScreenShareIDStream.bind(this),
            updateScreenShareNameStream: this.updateScreenShareNameStream.bind(this),
            updateAdminIDStream: this.updateAdminIDStream.bind(this),
            updateAdminNameStream: this.updateAdminNameStream.bind(this),
            updateYouYouStream: this.updateYouYouStream.bind(this),
            updateYouYouStreamIDs: this.updateYouYouStreamIDs.bind(this),
            updateLocalStream: this.updateLocalStream.bind(this),
            updateRecordStarted: this.updateRecordStarted.bind(this),
            updateRecordResumed: this.updateRecordResumed.bind(this),
            updateRecordPaused: this.updateRecordPaused.bind(this),
            updateRecordStopped: this.updateRecordStopped.bind(this),
            updateAdminRestrictSetting: this.updateAdminRestrictSetting.bind(this),
            updateVideoRequestState: this.updateVideoRequestState.bind(this),
            updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
            updateVideoAction: this.updateVideoAction.bind(this),
            updateLocalStreamVideo: this.updateLocalStreamVideo.bind(this),
            updateUserDefaultVideoInputDevice: this.updateUserDefaultVideoInputDevice.bind(this),
            updateCurrentFacingMode: this.updateCurrentFacingMode.bind(this),
            updatePrevFacingMode: this.updatePrevFacingMode.bind(this),
            updateDefVideoID: this.updateDefVideoID.bind(this),
            updateAllowed: this.updateAllowed.bind(this),
            updateDispActiveNames: this.updateDispActiveNames.bind(this),
            updateP_dispActiveNames: this.updateP_dispActiveNames.bind(this),
            updateActiveNames: this.updateActiveNames.bind(this),
            updatePrevActiveNames: this.updatePrevActiveNames.bind(this),
            updateP_activeNames: this.updateP_activeNames.bind(this),
            updateMembersReceived: this.updateMembersReceived.bind(this),
            updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
            updateHostFirstSwitch: this.updateHostFirstSwitch.bind(this),
            updateMicAction: this.updateMicAction.bind(this),
            updateScreenAction: this.updateScreenAction.bind(this),
            updateChatAction: this.updateChatAction.bind(this),
            updateAudioRequestState: this.updateAudioRequestState.bind(this),
            updateScreenRequestState: this.updateScreenRequestState.bind(this),
            updateChatRequestState: this.updateChatRequestState.bind(this),
            updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
            updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
            updateChatRequestTime: this.updateChatRequestTime.bind(this),
            updateOldSoundIds: this.updateOldSoundIds.bind(this),
            updateHostLabel: this.updateHostLabel.bind(this),
            updateMainScreenFilled: this.updateMainScreenFilled.bind(this),
            updateLocalStreamScreen: this.updateLocalStreamScreen.bind(this),
            updateScreenAlreadyOn: this.updateScreenAlreadyOn.bind(this),
            updateChatAlreadyOn: this.updateChatAlreadyOn.bind(this),
            updateRedirectURL: this.updateRedirectURL.bind(this),
            updateOldAllStreams: this.updateOldAllStreams.bind(this),
            updateAdminVidID: this.updateAdminVidID.bind(this),
            updateStreamNames: this.updateStreamNames.bind(this),
            updateNon_alVideoStreams: this.updateNon_alVideoStreams.bind(this),
            updateSortAudioLoudness: this.updateSortAudioLoudness.bind(this),
            updateAudioDecibels: this.updateAudioDecibels.bind(this),
            updateMixed_alVideoStreams: this.updateMixed_alVideoStreams.bind(this),
            updateNon_alVideoStreams_muted: this.updateNon_alVideoStreams_muted.bind(this),
            updatePaginatedStreams: this.updatePaginatedStreams.bind(this),
            updateLocalStreamAudio: this.updateLocalStreamAudio.bind(this),
            updateDefAudioID: this.updateDefAudioID.bind(this),
            updateUserDefaultAudioInputDevice: this.updateUserDefaultAudioInputDevice.bind(this),
            updateUserDefaultAudioOutputDevice: this.updateUserDefaultAudioOutputDevice.bind(this),
            updatePrevAudioInputDevice: this.updatePrevAudioInputDevice.bind(this),
            updatePrevVideoInputDevice: this.updatePrevVideoInputDevice.bind(this),
            updateAudioPaused: this.updateAudioPaused.bind(this),
            updateMainScreenPerson: this.updateMainScreenPerson.bind(this),
            updateAdminOnMainScreen: this.updateAdminOnMainScreen.bind(this),
            updateScreenStates: this.updateScreenStates.bind(this),
            updatePrevScreenStates: this.updatePrevScreenStates.bind(this),
            updateUpdateDateState: this.updateUpdateDateState.bind(this),
            updateLastUpdate: this.updateLastUpdate.bind(this),
            updateNForReadjustRecord: this.updateNForReadjustRecord.bind(this),
            updateFixedPageLimit: this.updateFixedPageLimit.bind(this),
            updateRemoveAltGrid: this.updateRemoveAltGrid.bind(this),
            updateNForReadjust: this.updateNForReadjust.bind(this),
            updateLastReorderTime: this.updateLastReorderTime.bind(this),
            updateAudStreamNames: this.updateAudStreamNames.bind(this),
            updateCurrentUserPage: this.updateCurrentUserPage.bind(this),
            updateMainHeightWidth: this.updateMainHeightWidth.bind(this),
            updatePrevMainHeightWidth: this.updatePrevMainHeightWidth.bind(this),
            updatePrevDoPaginate: this.updatePrevDoPaginate.bind(this),
            updateDoPaginate: this.updateDoPaginate.bind(this),
            updateShareEnded: this.updateShareEnded.bind(this),
            updateLStreams: this.updateLStreams.bind(this),
            updateChatRefStreams: this.updateChatRefStreams.bind(this),
            updateControlHeight: this.updateControlHeight.bind(this),
            updateIsWideScreen: this.updateIsWideScreen.bind(this),
            updateIsMediumScreen: this.updateIsMediumScreen.bind(this),
            updateIsSmallScreen: this.updateIsSmallScreen.bind(this),
            updateAddGrid: this.updateAddGrid.bind(this),
            updateAddAltGrid: this.updateAddAltGrid.bind(this),
            updateGridRows: this.updateGridRows.bind(this),
            updateGridCols: this.updateGridCols.bind(this),
            updateAltGridRows: this.updateAltGridRows.bind(this),
            updateAltGridCols: this.updateAltGridCols.bind(this),
            updateNumberPages: this.updateNumberPages.bind(this),
            updateCurrentStreams: this.updateCurrentStreams.bind(this),
            updateShowMiniView: this.updateShowMiniView.bind(this),
            updateNStream: this.updateNStream.bind(this),
            updateDefer_receive: this.updateDefer_receive.bind(this),
            updateAllAudioStreams: this.updateAllAudioStreams.bind(this),
            updateRemoteScreenStream: this.updateRemoteScreenStream.bind(this),
            updateScreenProducer: this.updateScreenProducer.bind(this),
            updateGotAllVids: this.updateGotAllVids.bind(this),
            updatePaginationHeightWidth: this.updatePaginationHeightWidth.bind(this),
            updatePaginationDirection: this.updatePaginationDirection.bind(this),
            updateGridSizes: this.updateGridSizes.bind(this),
            updateScreenForceFullDisplay: this.updateScreenForceFullDisplay.bind(this),
            updateMainGridStream: this.updateMainGridStream.bind(this),
            updateOtherGridStreams: this.updateOtherGridStreams.bind(this),
            updateAudioOnlyStreams: this.updateAudioOnlyStreams.bind(this),
            updateVideoInputs: this.updateVideoInputs.bind(this),
            updateAudioInputs: this.updateAudioInputs.bind(this),
            updateMeetingProgressTime: this.updateMeetingProgressTime.bind(this),
            updateMeetingElapsedTime: this.updateMeetingElapsedTime.bind(this),
            updateRef_participants: this.updateRef_participants.bind(this),
            updateMessages: this.updateMessages.bind(this),
            updateStartDirectMessage: this.updateStartDirectMessage.bind(this),
            updateDirectMessageDetails: this.updateDirectMessageDetails.bind(this),
            updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
            // Event settings
            updateAudioSetting: this.updateAudioSetting.bind(this),
            updateVideoSetting: this.updateVideoSetting.bind(this),
            updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
            updateChatSetting: this.updateChatSetting.bind(this),
            // Display settings
            updateAutoWave: this.updateAutoWave.bind(this),
            updateForceFullDisplay: this.updateForceFullDisplay.bind(this),
            updatePrevForceFullDisplay: this.updatePrevForceFullDisplay.bind(this),
            updatePrevMeetingDisplayType: this.updatePrevMeetingDisplayType.bind(this),
            // Waiting room
            updateWaitingRoomFilter: this.updateWaitingRoomFilter.bind(this),
            updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
            updateWaitingRoomCounter: this.updateWaitingRoomCounter.bind(this),
            // Requests
            updateRequestFilter: this.updateRequestFilter.bind(this),
            updateRequestList: this.updateRequestList.bind(this),
            updateRequestCounter: this.updateRequestCounter.bind(this),
            // Total requests and waiting room
            updateTotalReqWait: this.updateTotalReqWait.bind(this),
            // Menu modals
            updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
            updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
            updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
            updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
            updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
            updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
            // Other modals
            updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
            updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
            updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
            updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
            updateIsLoadingModalVisible: this.updateIsLoadingModalVisible.bind(this),
            // Recording Options
            updateRecordingMediaOptions: this.updateRecordingMediaOptions.bind(this),
            updateRecordingAudioOptions: this.updateRecordingAudioOptions.bind(this),
            updateRecordingVideoOptions: this.updateRecordingVideoOptions.bind(this),
            updateRecordingVideoType: this.updateRecordingVideoType.bind(this),
            updateRecordingVideoOptimized: this.updateRecordingVideoOptimized.bind(this),
            updateRecordingDisplayType: this.updateRecordingDisplayType.bind(this),
            updateRecordingAddHLS: this.updateRecordingAddHLS.bind(this),
            updateRecordingAddText: this.updateRecordingAddText.bind(this),
            updateRecordingCustomText: this.updateRecordingCustomText.bind(this),
            updateRecordingCustomTextPosition: this.updateRecordingCustomTextPosition.bind(this),
            updateRecordingCustomTextColor: this.updateRecordingCustomTextColor.bind(this),
            updateRecordingNameTags: this.updateRecordingNameTags.bind(this),
            updateRecordingBackgroundColor: this.updateRecordingBackgroundColor.bind(this),
            updateRecordingNameTagsColor: this.updateRecordingNameTagsColor.bind(this),
            updateRecordingOrientationVideo: this.updateRecordingOrientationVideo.bind(this),
            updateClearedToResume: this.updateClearedToResume.bind(this),
            updateClearedToRecord: this.updateClearedToRecord.bind(this),
            updateRecordState: this.updateRecordState.bind(this),
            updateShowRecordButtons: this.updateShowRecordButtons.bind(this),
            updateRecordingProgressTime: this.updateRecordingProgressTime.bind(this),
            updateAudioSwitching: this.updateAudioSwitching.bind(this),
            updateVideoSwitching: this.updateVideoSwitching.bind(this),
            // Media states
            updateVideoAlreadyOn: this.updateVideoAlreadyOn.bind(this),
            updateAudioAlreadyOn: this.updateAudioAlreadyOn.bind(this),
            updateComponentSizes: this.updateComponentSizes.bind(this),
            // Permissions
            updateHasCameraPermission: this.updateHasCameraPermission.bind(this),
            updateHasAudioPermission: this.updateHasAudioPermission.bind(this),
            // Transports
            updateTransportCreated: this.updateTransportCreated.bind(this),
            updateTransportCreatedVideo: this.updateTransportCreatedVideo.bind(this),
            updateTransportCreatedAudio: this.updateTransportCreatedAudio.bind(this),
            updateTransportCreatedScreen: this.updateTransportCreatedScreen.bind(this),
            updateProducerTransport: this.updateProducerTransport.bind(this),
            updateVideoProducer: this.updateVideoProducer.bind(this),
            updateParams: this.updateParams.bind(this),
            updateVideoParams: this.updateVideoParams.bind(this),
            updateAudioParams: this.updateAudioParams.bind(this),
            updateAudioProducer: this.updateAudioProducer.bind(this),
            updateConsumerTransports: this.updateConsumerTransports.bind(this),
            updateConsumingTransports: this.updateConsumingTransports.bind(this),
            // Polls
            updatePolls: this.updatePolls.bind(this),
            updatePoll: this.updatePoll.bind(this),
            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
            // Background
            updateCustomImage: this.updateCustomImage.bind(this),
            updateSelectedImage: this.updateSelectedImage.bind(this),
            updateSegmentVideo: this.updateSegmentVideo.bind(this),
            updateSelfieSegmentation: this.updateSelfieSegmentation.bind(this),
            updatePauseSegmentation: this.updatePauseSegmentation.bind(this),
            updateProcessedStream: this.updateProcessedStream.bind(this),
            updateKeepBackground: this.updateKeepBackground.bind(this),
            updateBackgroundHasChanged: this.updateBackgroundHasChanged.bind(this),
            updateVirtualStream: this.updateVirtualStream.bind(this),
            updateMainCanvas: this.updateMainCanvas.bind(this),
            updatePrevKeepBackground: this.updatePrevKeepBackground.bind(this),
            updateAppliedBackground: this.updateAppliedBackground.bind(this),
            updateIsBackgroundModalVisible: this.updateIsBackgroundModalVisible.bind(this),
            updateAutoClickBackground: this.updateAutoClickBackground.bind(this),
            // Breakout rooms
            updateBreakoutRooms: this.updateBreakoutRooms.bind(this),
            updateCurrentRoomIndex: this.updateCurrentRoomIndex.bind(this),
            updateCanStartBreakout: this.updateCanStartBreakout.bind(this),
            updateBreakOutRoomStarted: this.updateBreakOutRoomStarted.bind(this),
            updateBreakOutRoomEnded: this.updateBreakOutRoomEnded.bind(this),
            updateHostNewRoom: this.updateHostNewRoom.bind(this),
            updateLimitedBreakRoom: this.updateLimitedBreakRoom.bind(this),
            updateMainRoomsLength: this.updateMainRoomsLength.bind(this),
            updateMemberRoom: this.updateMemberRoom.bind(this),
            updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
            // Whiteboard
            updateWhiteboardUsers: this.updateWhiteboardUsers.bind(this),
            updateCurrentWhiteboardIndex: this.updateCurrentWhiteboardIndex.bind(this),
            updateCanStartWhiteboard: this.updateCanStartWhiteboard.bind(this),
            updateWhiteboardStarted: this.updateWhiteboardStarted.bind(this),
            updateWhiteboardEnded: this.updateWhiteboardEnded.bind(this),
            updateWhiteboardLimit: this.updateWhiteboardLimit.bind(this),
            updateIsWhiteboardModalVisible: this.updateIsWhiteboardModalVisible.bind(this),
            updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
            updateShapes: this.updateShapes.bind(this),
            updateUseImageBackground: this.updateUseImageBackground.bind(this),
            updateRedoStack: this.updateRedoStack.bind(this),
            updateUndoStack: this.updateUndoStack.bind(this),
            updateCanvasStream: this.updateCanvasStream.bind(this),
            updateCanvasWhiteboard: this.updateCanvasWhiteboard.bind(this),
            // Screenboard
            updateCanvasScreenboard: this.updateCanvasScreenboard.bind(this),
            updateProcessedScreenStream: this.updateProcessedScreenStream.bind(this),
            updateAnnotateScreenStream: this.updateAnnotateScreenStream.bind(this),
            updateMainScreenCanvas: this.updateMainScreenCanvas.bind(this),
            updateIsScreenboardModalVisible: this.updateIsScreenboardModalVisible.bind(this),
            // Other functions
            checkOrientation: this.checkOrientation.bind(this),
            updateDevice: this.updateDevice.bind(this),
            updateSocket: this.updateSocket.bind(this),
            updateValidated: this.updateValidated.bind(this),
            showAlert: this.showAlert.bind(this),
            getUpdatedAllParams: () => {
                return {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                };
            },
        };
    }
    mediaSFUParameters = {
        ...this.getAllParams(),
        ...this.mediaSFUFunctions(),
    };
    getUpdatedAllParams = () => {
        return {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    };
    updateButtonState(buttonType, value) {
        this.controlButtons = this.controlButtons.map((button) => {
            if (buttonType === 'micActive' && button.icon === this.faMicrophoneSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'videoActive' && button.icon === this.faVideoSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'screenShareActive' && button.icon === this.faDesktop) {
                if (button.alternateIconComponent) {
                    const updatedInjector = this.createInjector({
                        disabled: !value,
                    });
                    return {
                        ...button,
                        active: true,
                        alternateIconComponent: { ...this.screenShareWidget, injector: updatedInjector },
                    }; //always default to true for active
                }
                else {
                    return { ...button, active: true }; //always default to true for active
                }
            }
            if (buttonType === 'endCallActive' && button.icon === this.faPhone) {
                return { ...button, active: value };
            }
            if (buttonType === 'participantsActive' && button.icon === this.faUsers) {
                return { ...button, active: value };
            }
            if (buttonType === 'showMessagesBadge' &&
                button.customName &&
                button.customName === 'Messages') {
                const updatedInjector = this.createInjector({
                    icon: this.faComments,
                    badgeValue: value ? '*' : '',
                    iconColor: 'black',
                    showBadge: value,
                });
                return { ...button, customComponent: { ...this.messageWidget, injector: updatedInjector } };
            }
            if (buttonType === 'showMenuBadge' && button.customName && button.customName === 'Menu') {
                const updatedInjector = this.createInjector({
                    icon: this.faBars,
                    badgeValue: this.totalReqWait.value,
                    iconColor: 'black',
                    showBadge: true,
                });
                return { ...button, customComponent: { ...this.menuWidget, injector: updatedInjector } };
            }
            return button;
        });
        this.cdr.detectChanges();
    }
    PrejoinPageComponent = {
        component: this.PrejoinPage,
        injector: null,
    };
    updatePrejoinPageComponent = () => {
        const PrejoinComp = {
            component: this.PrejoinPage,
            injector: this.createInjector({
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    updateSocket: this.updateSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                credentials: this.credentials,
            }),
        };
        this.PrejoinPageComponent = { ...PrejoinComp };
        this.cdr.detectChanges();
    };
    ngOnInit() {
        if (this.PrejoinPage) {
            this.updatePrejoinPageComponent();
        }
        this.setupResizeListener();
        if (this.validated) {
            this.connectAndAddSocketMethods();
        }
        this.mainHeightWidthSubscription = this.mainHeightWidth.subscribe(() => {
            this.updateMainVideoSize();
        });
        this.recordingSubscription = combineLatest([
            this.recordPaused,
            this.recordStarted,
            this.recordStopped,
            this.recordResumed,
            this.recordingProgressTime,
            this.showRecordButtons,
            this.islevel,
        ]).subscribe(([recordPaused, recordStarted, recordStopped, recordResumed, recordingProgressTime, showRecordButtons, islevel,]) => {
            if (recordPaused ||
                recordStarted ||
                recordStopped ||
                recordResumed ||
                recordingProgressTime ||
                showRecordButtons ||
                islevel) {
                this.updateRecordButtons();
            }
        });
        this.ScreenboardSubscription = combineLatest([
            this.shared,
            this.componentSizes,
            this.annotateScreenStream,
        ]).subscribe(([shared, componentSizes]) => {
            this.ScreenboardWidget = {
                component: Screenboard,
                inputs: {
                    customWidth: componentSizes.mainWidth,
                    customHeight: componentSizes.mainHeight,
                    parameters: this.mediaSFUParameters,
                    showAspect: shared,
                },
            };
        });
        this.validatedSubscription = this.validated.subscribe((validated) => {
            if (validated) {
                this.handleValidated();
            }
        });
        this.islevelSubscription = this.islevel.subscribe((islevel) => {
            if (islevel) {
                this.updateCustomMenuButtons();
                this.updateControlBroadcastButtons();
                this.updateControlChatButtons();
            }
        });
        this.coHostSubscription = combineLatest([this.coHost, this.coHostResponsibility]).subscribe(([coHost, coHostResponsibility]) => {
            if (coHost || coHostResponsibility) {
                this.updateCustomMenuButtons();
                this.updateControlBroadcastButtons();
                this.updateControlChatButtons();
            }
        });
        // Subscribe to changes in BehaviorSubject and update the buttons accordingly
        this.buttonSubscriptions.push(this.micActive.subscribe((value) => {
            this.updateButtonState('micActive', value);
            this.updateControlBroadcastButtons();
            this.updateControlChatButtons();
        }));
        this.buttonSubscriptions.push(this.videoActive.subscribe((value) => {
            this.updateButtonState('videoActive', value);
            this.updateControlBroadcastButtons();
            this.updateControlChatButtons();
        }));
        this.buttonSubscriptions.push(this.screenShareActive.subscribe((value) => {
            this.updateButtonState('screenShareActive', value);
        }));
        this.buttonSubscriptions.push(this.showMessagesBadge.subscribe((value) => {
            this.updateButtonState('showMessagesBadge', value);
        }));
        this.buttonSubscriptions.push(this.totalReqWait.subscribe(() => {
            this.updateButtonState('showMenuBadge', true);
        }));
        this.buttonSubscriptions.push(this.participantsCounter.subscribe((value) => {
            this.updateMenuParticipantsWidget(value);
        }));
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.handleResize);
        window.removeEventListener('orientationchange', this.handleResize);
        if (this.mainHeightWidthSubscription) {
            this.mainHeightWidthSubscription.unsubscribe();
        }
        if (this.validatedSubscription) {
            this.validatedSubscription.unsubscribe();
        }
        if (this.islevelSubscription) {
            this.islevelSubscription.unsubscribe();
        }
        if (this.coHostSubscription) {
            this.coHostSubscription.unsubscribe();
        }
        if (this.ScreenboardSubscription) {
            this.ScreenboardSubscription.unsubscribe();
        }
        if (this.recordingSubscription) {
            this.recordingSubscription.unsubscribe();
        }
    }
    updateMainVideoSize = async () => {
        if (!this.lock_screen.value && !this.shared.value) {
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
        }
        else {
            if (!this.first_round.value) {
                this.prepopulateUserMedia.prepopulateUserMedia({
                    name: this.hostLabel.value,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            }
        }
    };
    async connectAndAddSocketMethods() {
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
        const socket_ = await this.connect_Socket(this.apiUserName.value, '', this.apiToken.value);
        if (socket_) {
            this.updateSocket(socket_);
        }
    }
    async handleValidated() {
        this.updateAllVideoStreams([
            { producerId: 'youyou', stream: undefined, id: 'youyou', name: 'youyou' },
        ]);
        this.updateStreamNames([{ id: 'youyou', name: 'youyou', producerId: '' }]);
        if (this.validated.value) {
            this.updateIsLoadingModalVisible(true);
            try {
                if (!this.localUIMode.value) {
                    await this.connectAndAddSocketMethods();
                }
            }
            catch (error) {
                console.log('error connectAndaAddSocketMethods', error);
            }
            this.startMeetingProgressTimer.startMeetingProgressTimer({
                startTime: Date.now() / 1000,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            this.updateIsLoadingModalVisible(false);
        }
    }
    async handleResize() {
        let fraction = 0;
        if (window.innerHeight < window.innerWidth &&
            (this.eventType.value == 'webinar' || this.eventType.value == 'conference')) {
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        else {
            // Set default control button height for portrait mode or other event types
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            fraction = Number(fraction);
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        const dimensions = this.computeDimensionsMethod({
            containerWidthFraction: 1,
            containerHeightFraction: 1,
            mainSize: this.mainHeightWidth.value,
            doStack: true,
            defaultFraction: this.eventType.value == 'webinar' || this.eventType.value == 'conference'
                ? 1 - fraction
                : 1,
        });
        this.updateComponentSizes(dimensions);
        const orientation = this.checkOrientation();
        if (orientation == 'portrait') {
            if (!this.isWideScreen.value) {
                if (this.shareScreenStarted.value || this.shared.value) {
                    this.updateScreenForceFullDisplay(true);
                }
            }
        }
        // Updates the main grid view
        await this.prepopulateUserMedia.prepopulateUserMedia({
            name: this.hostLabel.value,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
        // Updates the mini grid view
        await this.onScreenChanges.onScreenChanges({
            changed: true,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
    }
    async disconnectAllSockets(consume_sockets) {
        for (const socket of consume_sockets) {
            try {
                const ip = Object.keys(socket)[0];
                await socket[ip].disconnect();
            }
            catch (error) {
                console.log(`Error disconnecting socket with IP: ${Object.keys(socket)[0]}`, error);
            }
        }
    }
    async closeAndReset() {
        //close and clean up all sockets, modals,... and reset all states to initial values
        this.updateIsMessagesModalVisible(false);
        this.updateIsParticipantsModalVisible(false);
        this.updateIsWaitingModalVisible(false);
        this.updateIsRequestsModalVisible(false);
        this.updateIsCoHostModalVisible(false);
        this.updateIsSettingsModalVisible(false);
        this.updateIsDisplaySettingsModalVisible(false);
        this.updateIsMediaSettingsModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsShareEventModalVisible(false);
        this.updateIsConfirmExitModalVisible(false);
        await this.disconnectAllSockets(this.consume_sockets.value);
        await this.updateStatesToInitialValues();
        this.updateMeetingProgressTime('00:00:00');
        this.updateMeetingElapsedTime(0);
        this.updateRecordingProgressTime('00:00:00');
        this.updateRecordElapsedTime(0);
        this.updateShowRecordButtons(false);
        this.updateIsConfigureWhiteboardModalVisible(false);
        this.updateIsWhiteboardModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsRecordingModalVisible(false);
        this.updateIsPollModalVisible(false);
        this.updateIsBreakoutRoomsModalVisible(false);
        this.updateIsBackgroundModalVisible(false);
        this.updateIsLoadingModalVisible(false);
        this.updateIsConfirmHereModalVisible(false);
        await sleep({ ms: 500 });
        this.updateValidated(false);
        //if on web, reload the page
        window.location.reload();
    }
    computeDimensionsMethod = ({ containerWidthFraction = 1, containerHeightFraction = 1, mainSize, doStack = true, defaultFraction, }) => {
        const parentWidth = window.innerWidth * containerWidthFraction;
        const parentHeight = window.innerHeight * containerHeightFraction * defaultFraction;
        let isWideScreen = parentWidth >= 768;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        const dimensions = this.calculateDimensions({
            parentWidth,
            parentHeight,
            isWideScreen,
            mainSize,
            doStack,
        });
        return dimensions;
    };
    calculateDimensions({ parentWidth, parentHeight, isWideScreen, mainSize, doStack, }) {
        if (doStack) {
            return isWideScreen
                ? {
                    mainHeight: Math.floor(parentHeight),
                    otherHeight: Math.floor(parentHeight),
                    mainWidth: Math.floor((mainSize / 100) * parentWidth),
                    otherWidth: Math.floor(((100 - mainSize) / 100) * parentWidth),
                }
                : {
                    mainHeight: Math.floor((mainSize / 100) * parentHeight),
                    otherHeight: Math.floor(((100 - mainSize) / 100) * parentHeight),
                    mainWidth: Math.floor(parentWidth),
                    otherWidth: Math.floor(parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(parentHeight),
                otherHeight: Math.floor(parentHeight),
                mainWidth: Math.floor(parentWidth),
                otherWidth: Math.floor(parentWidth),
            };
        }
    }
    handleOrientationChange() {
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('orientationchange', this.handleResize.bind(this));
    }
    setupResizeListener() {
        this.handleResize();
    }
    orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    async joinRoom(data) {
        const { socket, roomName, islevel, member, sec, apiUserName } = data;
        try {
            const response = await this.joinRoomClient.joinRoomClient({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
            return response;
        }
        catch (error) {
            console.log('Error joining room:', error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    async join_Room({ socket, roomName, islevel, member, sec, apiUserName, }) {
        const data = await this.joinRoom({
            socket: socket,
            roomName: roomName,
            islevel: islevel,
            member: member,
            sec: sec,
            apiUserName: apiUserName,
        });
        if (data && data.success) {
            this.roomData.next(data);
            try {
                this.updateRoomParametersClient.updateRoomParametersClient({
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                        data: data,
                    },
                });
                if (data.isHost) {
                    this.updateIslevel('2');
                }
                else {
                    this.updateIslevel('1');
                }
                if (data.secureCode) {
                    this.updateAdminPasscode(data.secureCode);
                }
                if (data.rtpCapabilities) {
                    const device_ = await this.createDeviceClient.createDeviceClient({
                        rtpCapabilities: data.rtpCapabilities,
                    });
                    if (device_) {
                        this.device.next(device_);
                    }
                }
            }
            catch {
                /* handle error */
            }
        }
        else {
            this.updateValidated(false);
            try {
                if (this.showAlert && data?.reason) {
                    this.showAlert({ message: data?.reason, type: 'danger', duration: 3000 });
                }
            }
            catch {
                /* handle error */
            }
        }
    }
    onParticipantsFilterChange = (value) => {
        if (value && value.length > 0) {
            this.filteredParticipants.next(this.participants.value.filter((participant) => participant.name.toLowerCase().includes(value.toLowerCase())));
            this.participantsCounter.next(this.filteredParticipants.value.length);
        }
        else {
            this.filteredParticipants.next(this.participants.value);
            this.participantsCounter.next(this.participants.value.length);
        }
    };
    updateStatesToInitialValues = async () => {
        const initialValues = initialValuesState;
        const updateFunctions = this.getAllParams();
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                const updateFunctionName = `update${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const updateFunction = updateFunctions[updateFunctionName];
                if (typeof updateFunction === 'function') {
                    try {
                        updateFunction(initialValues[key]);
                    }
                    catch {
                        /* handle error */
                    }
                }
            }
        }
    };
    faRecordVinyl = faRecordVinyl;
    faPlayCircle = faPlayCircle;
    faPauseCircle = faPauseCircle;
    faStopCircle = faStopCircle;
    faDotCircle = faDotCircle;
    faCog = faCog;
    faUsers = faUsers;
    faClock = faClock;
    faUserPlus = faUserPlus;
    faTools = faTools;
    faDesktop = faDesktop;
    faPoll = faPoll;
    faUserFriends = faUserFriends;
    faChalkboardTeacher = faChalkboardTeacher;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faSync = faSync;
    faPhone = faPhone;
    faShareAlt = faShareAlt;
    faBars = faBars;
    faComments = faComments;
    faChartBar = faChartBar;
    onCloseMenuModal = () => {
        this.updateIsMenuModalVisible(false);
    };
    onEventSettingsClose = () => {
        this.updateIsSettingsModalVisible(false);
    };
    onCoHostClose = () => {
        this.updateIsCoHostModalVisible(false);
    };
    onMediaSettingsClose = () => {
        this.updateIsMediaSettingsModalVisible(false);
    };
    onDisplaySettingsClose = () => {
        this.updateIsDisplaySettingsModalVisible(false);
    };
    onPollClose = () => {
        this.updateIsPollModalVisible(false);
    };
    onBreakoutRoomsClose = () => {
        this.updateIsBreakoutRoomsModalVisible(false);
    };
    onConfigureWhiteboardClose = () => {
        this.updateIsConfigureWhiteboardModalVisible(false);
    };
    onMessagesClose = () => {
        this.updateIsMessagesModalVisible(false);
    };
    onRecordingClose = () => {
        this.updateIsRecordingModalVisible(false);
    };
    onParticipantsClose = () => {
        this.updateIsParticipantsModalVisible(false);
    };
    onBackgroundClose = () => {
        this.updateIsBackgroundModalVisible(false);
    };
    onConfirmExitClose = () => {
        this.updateIsConfirmExitModalVisible(false);
    };
    onConfirmHereClose = () => {
        this.updateIsConfirmHereModalVisible(false);
    };
    onScreenboardClose = () => {
        this.updateIsScreenboardModalVisible(false);
    };
    onShareEventClose = () => {
        this.updateIsShareEventModalVisible(false);
    };
    onAlertHide = () => {
        this.updateAlertVisible(false);
    };
    ScreenboardWidget = {
        component: Screenboard,
        inputs: {
            customWidth: this.componentSizes.value.mainWidth,
            customHeight: this.componentSizes.value.mainHeight,
            parameters: this.mediaSFUParameters,
            showAspect: this.shared.value,
        },
    };
    recordTimerWidget = {
        component: RecordTimerWidget,
        injector: this.createInjector({ recordingProgressTime: this.recordingProgressTime.value }),
    };
    updateRecordTimerWidget = (recordingProgressTime = this.recordingProgressTime.value) => {
        const recordTimerWidget = {
            component: RecordTimerWidget,
            injector: this.createInjector({ recordingProgressTime: recordingProgressTime }),
        };
        this.recordTimerWidget = { ...recordTimerWidget };
        this.cdr.markForCheck();
        return recordTimerWidget;
    };
    recordButton = [
        {
            icon: this.faRecordVinyl,
            text: 'Record',
            onPress: () => {
                this.launchRecording.launchRecording({
                    updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                    isRecordingModalVisible: this.isRecordingModalVisible.value,
                    showAlert: this.showAlert.bind(this),
                    stopLaunchRecord: this.stopLaunchRecord.value,
                    canLaunchRecord: this.canLaunchRecord.value,
                    recordingAudioSupport: this.recordingAudioSupport.value,
                    recordingVideoSupport: this.recordingVideoSupport.value,
                    updateCanRecord: this.updateCanRecord.bind(this),
                    updateClearedToRecord: this.updateClearedToRecord.bind(this),
                    recordStarted: this.recordStarted.value,
                    recordPaused: this.recordPaused.value,
                    localUIMode: this.localUIMode.value,
                });
            },
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
    ];
    recordButtons = [];
    recordButtonsArray = [
        {
            icon: this.faPlayCircle,
            active: () => !this.recordPaused.value,
            onPress: () => this.updateRecording.updateRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            alternateIcon: this.faPauseCircle,
            show: () => true,
        },
        {
            icon: this.faStopCircle,
            active: () => false,
            onPress: () => this.stopRecording.stopRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: () => this.updateRecordTimerWidget(),
            show: () => true,
            active: () => false,
        },
        {
            icon: this.faDotCircle,
            active: () => false,
            onPress: () => console.log('Status pressed'),
            activeColor: 'black',
            inActiveColor: () => (this.recordPaused.value ? 'yellow' : 'red'),
            show: () => true,
        },
        {
            icon: this.faCog,
            active: () => false,
            onPress: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
    ];
    async updateRecordButtons() {
        const recordButtons = this.recordButtonsArray.map((button) => {
            return {
                ...button,
                active: typeof button.active === 'function' ? button.active() : button.active,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
                activeColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
                inActiveColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
            };
        });
        this.recordButtons = [...recordButtons];
        await this.updateMenuRecordWidget(recordButtons);
        this.updateCustomMenuButtons();
        this.updateControlBroadcastButtons();
        this.cdr.markForCheck();
    }
    // Create instances of the custom widgets
    menuWidget = {
        component: MenuWidget,
        injector: this.createInjector({
            icon: this.faBars,
            badgeValue: this.totalReqWait.value,
            iconColor: 'black',
            showBadge: true,
        }),
    };
    messageWidget = {
        component: MessageWidget,
        injector: this.createInjector({
            icon: this.faComments,
            showBadge: this.showMessagesBadge.value,
            badgeValue: 1,
            iconColor: 'black',
        }),
    };
    menuRecordWidget = {
        component: MenuRecordWidget,
        injector: this.createInjector({
            buttons: this.recordButtons,
            showAspect: true,
            direction: 'horizontal',
        }),
    };
    updateMenuRecordWidget = (recordButtons = this.recordButtons) => {
        const menuRecordWidget = {
            component: MenuRecordWidget,
            injector: this.createInjector({
                buttons: recordButtons,
                showAspect: true,
                direction: 'horizontal',
            }),
        };
        this.menuRecordWidget = { ...menuRecordWidget };
        this.cdr.markForCheck();
        return menuRecordWidget;
    };
    menuParticipantsWidget = {
        component: MenuParticipantsWidget,
        injector: this.createInjector({
            icon: this.faChartBar,
            participantsCounter: this.participantsCounter.value,
            iconColor: 'black',
        }),
    };
    updateMenuParticipantsWidget = (count = this.participantsCounter.value) => {
        const menuParticipantsWidget = {
            component: MenuParticipantsWidget,
            injector: this.createInjector({
                icon: this.faChartBar,
                participantsCounter: count,
                iconColor: 'black',
            }),
        };
        this.menuParticipantsWidget = { ...menuParticipantsWidget };
        this.cdr.markForCheck();
        return menuParticipantsWidget;
    };
    customMenuButtonsArray = [
        {
            icon: this.faRecordVinyl,
            text: 'Record',
            action: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            show: () => !this.showRecordButtons.value && this.islevel.value == '2',
        },
        {
            customComponent: () => this.updateMenuRecordWidget(),
            show: () => this.showRecordButtons.value && this.islevel.value == '2',
            action: () => console.log('record buttons pressed'),
        },
        {
            icon: this.faCog,
            text: 'Event Settings',
            action: () => this.launchSettings.launchSettings({
                updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
                isSettingsModalVisible: this.isSettingsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faUsers,
            text: 'Requests',
            action: () => this.launchRequests.launchRequests({
                updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
                isRequestsModalVisible: this.isRequestsModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                ((this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    !!this.coHostResponsibility?.value?.find((item) => item.name === 'media')?.value) ??
                    false) ||
                false,
        },
        {
            icon: this.faClock,
            text: 'Waiting',
            action: () => this.launchWaiting.launchWaiting({
                updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
                isWaitingModalVisible: this.isWaitingModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                (this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    this.coHostResponsibility?.value?.find((item) => item.name === 'waiting')?.value ===
                        true) ||
                false,
        },
        {
            icon: this.faUserPlus,
            text: 'Co-host',
            action: () => this.launchCoHost.launchCoHost({
                updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
                isCoHostModalVisible: this.isCoHostModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faTools,
            text: 'Set Media',
            action: () => this.launchMediaSettings.launchMediaSettings({
                updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
                isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
                audioInputs: this.audioInputs.value,
                videoInputs: this.videoInputs.value,
                updateAudioInputs: this.updateAudioInputs.bind(this),
                updateVideoInputs: this.updateVideoInputs.bind(this),
            }),
            show: () => true,
        },
        {
            icon: this.faDesktop,
            text: 'Display',
            action: () => this.launchDisplaySettings.launchDisplaySettings({
                updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
                isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faPoll,
            text: 'Poll',
            action: () => this.launchPoll.launchPoll({
                updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                isPollModalVisible: this.isPollModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faUserFriends,
            text: 'Breakout Rooms',
            action: () => this.launchBreakoutRooms.launchBreakoutRooms({
                updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
                isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faChalkboardTeacher,
            text: 'Whiteboard',
            action: () => this.launchConfigureWhiteboard.launchConfigureWhiteboard({
                updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
                isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
    ];
    customMenuButtons = [];
    updateCustomMenuButtons() {
        this.customMenuButtons = this.customMenuButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
            };
        });
    }
    controlBroadcastButtons = [];
    updateControlBroadcastButtons() {
        this.controlBroadcastButtons = this.controlBroadcastButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                active: typeof button.active === 'function' ? button.active() : button.active,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
            };
        });
    }
    controlBroadcastButtonsArray = [
        {
            icon: this.faUsers,
            active: true,
            alternateIcon: this.faUsers,
            onPress: () => this.launchParticipants.launchParticipants({
                updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
                isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faShareAlt,
            active: true,
            alternateIcon: this.faShareAlt,
            onPress: () => this.updateIsShareEventModalVisible(!this.isShareEventModalVisible.value),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: this.messageWidget,
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faSync,
            active: true,
            alternateIcon: this.faSync,
            onPress: () => this.switchVideoAlt.switchVideoAlt({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: () => this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            show: () => this.islevel.value == '2',
            activeColor: 'green',
            inActiveColor: 'red',
        },
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: () => this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: () => this.islevel.value == '2',
        },
        {
            customComponent: () => this.menuParticipantsWidget,
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: () => true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => console.log('End Call pressed'),
            activeColor: 'transparent',
            inActiveColor: 'transparent',
            backgroundColor: { default: 'transparent' },
            show: () => false,
        },
    ];
    controlChatButtons = [];
    controlChatButtonsArray = [
        {
            icon: this.faShareAlt,
            active: true,
            alternateIcon: this.faShareAlt,
            onPress: () => this.updateIsShareEventModalVisible(!this.isShareEventModalVisible.value),
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
        {
            customComponent: this.messageWidget,
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: true,
        },
        {
            icon: this.faSync,
            active: true,
            alternateIcon: this.faSync,
            onPress: () => this.switchVideoAlt.switchVideoAlt({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: () => this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: () => this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
    ];
    updateControlChatButtons() {
        this.controlChatButtons = this.controlChatButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                active: typeof button.active === 'function' ? button.active() : button.active,
            };
        });
    }
    screenShareWidget = {
        component: ScreenShareWidget,
        injector: this.createInjector({ disabled: !this.screenShareActive.value }),
    };
    controlButtons = [
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.audioSwitching.value,
            show: true,
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                    MediaStream,
                    MediaStreamTrack,
                    mediaDevices: MediaDevices,
                    device: this.device.value,
                    socket: this.socket.value,
                    showAlert: this.showAlert.bind(this),
                    checkPermission: this.checkPermission.checkPermission,
                    streamSuccessVideo: this.streamSuccessVideo.streamSuccessVideo,
                    hasCameraPermission: this.hasCameraPermission.value,
                    requestPermissionCamera: this.requestPermissionCamera.bind(this),
                    checkMediaPermission: 'web' !== 'web',
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.videoSwitching.value,
            show: true,
        },
        {
            //inverted active for inactive state
            icon: faDesktop,
            alternateIconComponent: this.screenShareWidget,
            active: true,
            onPress: () => this.clickScreenShare.clickScreenShare({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faUsers,
            active: this.participantsActive.value,
            onPress: () => this.launchParticipants.launchParticipants({
                updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
                isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            disabled: false,
            show: true,
        },
        {
            customComponent: this.menuWidget,
            customName: 'Menu',
            onPress: () => this.launchMenuModal.launchMenuModal({
                updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
                isMenuModalVisible: this.isMenuModalVisible.value,
            }),
            show: true,
        },
        {
            customComponent: this.messageWidget,
            customName: 'Messages',
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: true,
        },
    ];
    async connect_Socket(apiUserName, apiKey, apiToken) {
        if (this.socket.value && this.socket.value.id) {
            this.socket.value.on('disconnect', async () => {
                await this.disconnect.disconnect({
                    showAlert: this.showAlert.bind(this),
                    redirectURL: this.redirectURL.value,
                    onWeb: true,
                    updateValidated: this.updateValidated.bind(this),
                });
                if (this.videoAlreadyOn.value) {
                    await this.clickVideo.clickVideo({
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                if (this.audioAlreadyOn.value) {
                    await this.clickAudio.clickAudio({
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                await this.closeAndReset();
            });
            this.socket.value.on('allMembers', async (membersData) => {
                if (membersData) {
                    await this.allMembers.allMembers({
                        apiUserName: apiUserName,
                        apiKey: '', //not recommended - use apiToken instead. Use for testing/development only
                        apiToken: apiToken,
                        members: membersData.members,
                        requestss: membersData.requests ? membersData.requests : this.requestList.value,
                        coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                        coHostRes: membersData.coHostResponsibilities
                            ? membersData.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        consume_sockets: this.consume_sockets.value,
                    });
                }
            });
            this.socket.value.on('allMembersRest', async (membersData) => {
                if (membersData) {
                    await this.allMembersRest.allMembersRest({
                        apiUserName: apiUserName,
                        apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                        members: membersData.members,
                        apiToken: apiToken,
                        settings: membersData.settings,
                        coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                        coHostRes: membersData.coHostResponsibilities
                            ? membersData.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        consume_sockets: this.consume_sockets.value,
                    });
                }
            });
            this.socket.value.on('userWaiting', async ({ name }) => {
                await this.userWaiting.userWaiting({
                    name,
                    showAlert: this.showAlert.bind(this),
                    totalReqWait: this.totalReqWait.value,
                    updateTotalReqWait: this.updateTotalReqWait.bind(this),
                });
            });
            this.socket.value.on('personJoined', async ({ name }) => {
                this.personJoined.personJoined({
                    name,
                    showAlert: this.showAlert.bind(this),
                });
            });
            this.socket.value.on('allWaitingRoomMembers', async (waiting_data) => {
                await this.allWaitingRoomMembers.allWaitingRoomMembers({
                    waitingParticipants: waiting_data.waitingParticipants
                        ? waiting_data.waitingParticipants
                        : waiting_data.waitingParticipantss
                            ? waiting_data.waitingParticipantss
                            : this.waitingRoomList.value,
                    updateTotalReqWait: this.updateTotalReqWait.bind(this),
                    updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
                });
            });
            this.socket.value.on('roomRecordParams', async ({ recordParams }) => {
                this.roomRecordParams.roomRecordParams({
                    recordParams,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('ban', async ({ name }) => {
                await this.banParticipant.banParticipant({
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('updatedCoHost', async (cohost_data) => {
                await this.updatedCoHost.updatedCoHost({
                    coHost: cohost_data.coHost ? cohost_data.coHost : this.coHost.value,
                    coHostResponsibility: cohost_data.coHostResponsibilities
                        ? cohost_data.coHostResponsibilities
                        : this.coHostResponsibility.value,
                    youAreCoHost: this.youAreCoHost.value,
                    updateCoHost: this.updateCoHost.bind(this),
                    updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
                    updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
                    showAlert: this.showAlert.bind(this),
                    eventType: this.eventType.value,
                    islevel: this.islevel.value,
                    member: this.member.value,
                });
            });
            this.socket.value.on('participantRequested', async ({ userRequest }) => {
                await this.participantRequested.participantRequested({
                    userRequest,
                    requestList: this.requestList.value,
                    waitingRoomList: this.waitingRoomList.value,
                    updateTotalReqWait: this.updateTotalReqWait.bind(this),
                    updateRequestList: this.updateRequestList.bind(this),
                });
            });
            this.socket.value.on('screenProducerId', async ({ producerId }) => {
                this.screenProducerId.screenProducerId({
                    producerId,
                    screenId: this.screenId.value,
                    membersReceived: this.membersReceived.value,
                    shareScreenStarted: this.shareScreenStarted.value,
                    deferScreenReceived: this.deferScreenReceived.value,
                    participants: this.participants.value,
                    updateScreenId: this.updateScreenId.bind(this),
                    updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
                    updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
                });
            });
            //settings, updateAudioSetting, updateVideoSetting, updateScreenshareSetting, updateChatSetting
            this.socket.value.on('updateMediaSettings', async ({ settings }) => {
                this.updateMediaSettings.updateMediaSettings({
                    settings,
                    updateAudioSetting: this.updateAudioSetting.bind(this),
                    updateVideoSetting: this.updateVideoSetting.bind(this),
                    updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
                    updateChatSetting: this.updateChatSetting.bind(this),
                });
            });
            this.socket.value.on('producer-media-paused', async ({ producerId, kind, name, }) => {
                await this.producerMediaPaused.producerMediaPaused({
                    producerId,
                    kind,
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('producer-media-resumed', async ({ kind, name }) => {
                await this.producerMediaResumed.producerMediaResumed({
                    kind,
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('producer-media-closed', async ({ producerId, kind, }) => {
                if (producerId && kind) {
                    await this.producerMediaClosed.producerMediaClosed({
                        producerId,
                        kind,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
            });
            this.socket.value.on('controlMediaHost', async ({ type }) => {
                await this.controlMediaHost.controlMediaHost({
                    type,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('meetingEnded', async () => {
                await this.meetingEnded.meetingEnded({
                    showAlert: this.showAlert.bind(this),
                    redirectURL: this.redirectURL.value,
                    onWeb: true,
                    eventType: this.eventType.value,
                    updateValidated: this.updateValidated.bind(this),
                });
                if (this.videoAlreadyOn.value) {
                    await this.clickVideo.clickVideo({
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                }
                if (this.audioAlreadyOn.value) {
                    await this.clickAudio.clickAudio({
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                }
                await this.closeAndReset();
            });
            this.socket.value.on('disconnectUserSelf', async () => {
                await this.disconnectUserSelf.disconnectUserSelf({
                    socket: this.socket.value,
                    member: this.member.value,
                    roomName: this.roomName.value,
                });
            });
            this.socket.value.on('receiveMessage', async ({ message }) => {
                await this.receiveMessage.receiveMessage({
                    message,
                    messages: this.messages.value,
                    participantsAll: this.participantsAll.value,
                    member: this.member.value,
                    eventType: this.eventType.value,
                    islevel: this.islevel.value,
                    coHost: this.coHost.value,
                    updateMessages: this.updateMessages.bind(this),
                    updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
                });
            });
            this.socket.value.on('meetingTimeRemaining', async ({ timeRemaining }) => {
                await this.meetingTimeRemaining.meetingTimeRemaining({
                    timeRemaining,
                    showAlert: this.showAlert.bind(this),
                    eventType: this.eventType.value,
                });
            });
            this.socket.value.on('meetingStillThere', async () => {
                this.meetingStillThere.meetingStillThere({
                    updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
                });
            });
            this.socket.value.on('startRecords', async () => {
                await this.startRecords.startRecords({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: this.socket.value,
                });
            });
            this.socket.value.on('reInitiateRecording', async () => {
                await this.reInitiateRecording.reInitiateRecording({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: this.socket.value,
                    adminRestrictSetting: this.adminRestrictSetting.value,
                });
            });
            this.socket.value.on('updateConsumingDomains', async ({ domains, alt_domains }) => {
                await this.updateConsumingDomains.updateConsumingDomains({
                    domains,
                    alt_domains,
                    apiUserName,
                    apiKey,
                    apiToken,
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                    },
                });
            });
            this.socket.value.on('RecordingNotice', async ({ state, userRecordingParam, pauseCount, timeDone }) => {
                await this.recordingNotice.RecordingNotice({
                    state,
                    userRecordingParam,
                    pauseCount,
                    timeDone,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('timeLeftRecording', async ({ timeLeft }) => {
                this.timeLeftRecording.timeLeftRecording({
                    timeLeft,
                    showAlert: this.showAlert.bind(this),
                });
            });
            this.socket.value.on('stoppedRecording', async ({ state, reason }) => {
                await this.stoppedRecording.stoppedRecording({
                    state,
                    reason,
                    showAlert: this.showAlert.bind(this),
                });
            });
            this.socket.value.on('hostRequestResponse', ({ requestResponse }) => {
                this.hostRequestResponse.hostRequestResponse({
                    requestResponse,
                    showAlert: this.showAlert.bind(this),
                    requestList: this.requestList.value,
                    updateRequestList: this.updateRequestList.bind(this),
                    updateMicAction: this.updateMicAction.bind(this),
                    updateVideoAction: this.updateVideoAction.bind(this),
                    updateScreenAction: this.updateScreenAction.bind(this),
                    updateChatAction: this.updateChatAction.bind(this),
                    updateAudioRequestState: this.updateAudioRequestState.bind(this),
                    updateVideoRequestState: this.updateVideoRequestState.bind(this),
                    updateScreenRequestState: this.updateScreenRequestState.bind(this),
                    updateChatRequestState: this.updateChatRequestState.bind(this),
                    updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
                    updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
                    updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
                    updateChatRequestTime: this.updateChatRequestTime.bind(this),
                    updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
                });
            });
            this.socket.value.on('pollUpdated', async (data) => {
                try {
                    await this.pollUpdated.pollUpdated({
                        data,
                        polls: this.polls.value,
                        poll: this.poll.value ? this.poll.value : {},
                        member: this.member.value,
                        islevel: this.islevel.value,
                        showAlert: this.showAlert.bind(this),
                        updatePolls: this.updatePolls.bind(this),
                        updatePoll: this.updatePoll.bind(this),
                        updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                    });
                }
                catch {
                    /* handle error */
                }
            });
            this.socket.value.on('breakoutRoomUpdated', async (data) => {
                try {
                    await this.breakoutRoomUpdated.breakoutRoomUpdated({
                        data,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                catch {
                    /* handle error */
                }
            });
            await this.join_Room({
                socket: this.socket.value,
                roomName: this.roomName.value,
                islevel: this.islevel.value,
                member: this.member.value,
                sec: this.apiToken.value,
                apiUserName: this.apiUserName.value,
            });
            await this.receiveRoomMessages.receiveRoomMessages({
                socket: this.socket.value,
                roomName: this.roomName.value,
                updateMessages: this.updateMessages.bind(this),
            });
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            return this.socket.value;
        }
        else {
            return null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediasfuGeneric, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.Injector }, { token: UpdateMiniCardsGrid }, { token: MixStreams }, { token: DispStreams }, { token: StopShareScreen }, { token: CheckScreenShare }, { token: StartShareScreen }, { token: RequestScreenShare }, { token: ReorderStreams }, { token: PrepopulateUserMedia }, { token: GetVideos }, { token: RePort }, { token: Trigger }, { token: ConsumerResume }, { token: ConnectSendTransport }, { token: ConnectSendTransportAudio }, { token: ConnectSendTransportVideo }, { token: ConnectSendTransportScreen }, { token: ProcessConsumerTransports }, { token: ResumePauseStreams }, { token: Readjust }, { token: CheckGrid }, { token: GetEstimate }, { token: CalculateRowsAndColumns }, { token: AddVideosGrid }, { token: OnScreenChanges }, { token: ChangeVids }, { token: CompareActiveNames }, { token: CompareScreenStates }, { token: CreateSendTransport }, { token: ResumeSendTransportAudio }, { token: ReceiveAllPipedTransports }, { token: DisconnectSendTransportVideo }, { token: DisconnectSendTransportAudio }, { token: DisconnectSendTransportScreen }, { token: GetPipedProducersAlt }, { token: SignalNewConsumerTransport }, { token: ConnectRecvTransport }, { token: ReUpdateInter }, { token: UpdateParticipantAudioDecibels }, { token: CloseAndResize }, { token: AutoAdjust }, { token: SwitchUserVideoAlt }, { token: SwitchUserVideo }, { token: SwitchUserAudio }, { token: GetDomains }, { token: FormatNumber }, { token: ConnectIps }, { token: CreateDeviceClient }, { token: HandleCreatePoll }, { token: HandleEndPoll }, { token: HandleVotePoll }, { token: CaptureCanvasStream }, { token: ResumePauseAudioStreams }, { token: ProcessConsumerTransportsAudio }, { token: LaunchMenuModal }, { token: LaunchRecording }, { token: StartRecording }, { token: ConfirmRecording }, { token: LaunchWaiting }, { token: launchCoHost }, { token: LaunchMediaSettings }, { token: LaunchDisplaySettings }, { token: LaunchSettings }, { token: LaunchRequests }, { token: LaunchParticipants }, { token: LaunchMessages }, { token: LaunchConfirmExit }, { token: LaunchPoll }, { token: LaunchBreakoutRooms }, { token: LaunchConfigureWhiteboard }, { token: StartMeetingProgressTimer }, { token: UpdateRecording }, { token: StopRecording }, { token: UserWaiting }, { token: PersonJoined }, { token: AllWaitingRoomMembers }, { token: RoomRecordParams }, { token: BanParticipant }, { token: UpdatedCoHost }, { token: ParticipantRequested }, { token: ScreenProducerId }, { token: UpdateMediaSettings }, { token: ProducerMediaPaused }, { token: ProducerMediaResumed }, { token: ProducerMediaClosed }, { token: ControlMediaHost }, { token: MeetingEnded }, { token: DisconnectUserSelf }, { token: ReceiveMessage }, { token: MeetingTimeRemaining }, { token: MeetingStillThere }, { token: StartRecords }, { token: ReInitiateRecording }, { token: RecordingNotice }, { token: TimeLeftRecording }, { token: StoppedRecording }, { token: HostRequestResponse }, { token: AllMembers }, { token: AllMembersRest }, { token: Disconnect }, { token: PollUpdated }, { token: BreakoutRoomUpdated }, { token: SocketManager }, { token: JoinRoomClient }, { token: UpdateRoomParametersClient }, { token: ClickVideo }, { token: ClickAudio }, { token: ClickScreenShare }, { token: SwitchVideoAlt }, { token: StreamSuccessVideo }, { token: StreamSuccessAudio }, { token: StreamSuccessScreen }, { token: StreamSuccessAudioSwitch }, { token: CheckPermission }, { token: UpdateConsumingDomains }, { token: ReceiveRoomMessages }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MediasfuGeneric, isStandalone: true, selector: "app-mediasfu-generic", inputs: { PrejoinPage: "PrejoinPage", credentials: "credentials", useLocalUIMode: "useLocalUIMode", seedData: "seedData", useSeed: "useSeed", imgSrc: "imgSrc" }, host: { listeners: { "window:resize": "handleResize()", "window:orientationchange": "handleResize()" } }, providers: [CookieService], ngImport: i0, template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component>
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
                <app-control-buttons-component-touch
                  [buttons]="controlBroadcastButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'broadcast'"
                ></app-control-buttons-component-touch>
                <app-control-buttons-component-touch
                  [buttons]="recordButton"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    !showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>
                <app-control-buttons-component-touch
                  [buttons]="recordButtons"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>
                <app-control-buttons-component-touch
                  [buttons]="controlChatButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'chat'"
                ></app-control-buttons-component-touch>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: BreakoutRoomsModal, selector: "app-breakout-rooms-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onBreakoutRoomsClose"] }, { kind: "component", type: BackgroundModal, selector: "app-background-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onClose"] }, { kind: "component", type: CoHostModal, selector: "app-co-host-modal", inputs: ["isCoHostModalVisible", "currentCohost", "participants", "coHostResponsibility", "position", "backgroundColor", "roomName", "showAlert", "updateCoHostResponsibility", "updateCoHost", "updateIsCoHostModalVisible", "socket", "onCoHostClose", "onModifyCoHost"] }, { kind: "component", type: AlertComponent, selector: "app-alert-component", inputs: ["visible", "message", "type", "duration", "textColor", "onHide"] }, { kind: "component", type: AudioGrid, selector: "app-audio-grid", inputs: ["componentsToRender"] }, { kind: "component", type: ControlButtonsComponentTouch, selector: "app-control-buttons-component-touch", inputs: ["buttons", "position", "location", "direction", "buttonsContainerStyle", "showAspect"] }, { kind: "component", type: ControlButtonsComponent, selector: "app-control-buttons-component", inputs: ["buttons", "buttonColor", "buttonBackgroundColor", "alignment", "vertical", "buttonsContainerStyle"] }, { kind: "component", type: FlexibleGrid, selector: "app-flexible-grid", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "backgroundColor"] }, { kind: "component", type: FlexibleVideo, selector: "app-flexible-video", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "showAspect", "backgroundColor", "Screenboard", "annotateScreenStream", "localStreamScreen"] }, { kind: "component", type: LoadingModal, selector: "app-loading-modal", inputs: ["isVisible", "backgroundColor", "displayColor"] }, { kind: "component", type: Pagination, selector: "app-pagination", inputs: ["totalPages", "currentUserPage", "handlePageChange", "position", "location", "direction", "buttonsContainerStyle", "activePageStyle", "inactivePageStyle", "backgroundColor", "paginationHeight", "showAspect", "parameters"] }, { kind: "component", type: SubAspectComponent, selector: "app-sub-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFractionSub"] }, { kind: "component", type: DisplaySettingsModal, selector: "app-display-settings-modal", inputs: ["isDisplaySettingsModalVisible", "onDisplaySettingsClose", "onModifyDisplaySettings", "parameters", "position", "backgroundColor"] }, { kind: "component", type: EventSettingsModal, selector: "app-event-settings-modal", inputs: ["isEventSettingsModalVisible", "onEventSettingsClose", "onModifyEventSettings", "position", "backgroundColor", "audioSetting", "videoSetting", "screenshareSetting", "chatSetting", "updateAudioSetting", "updateVideoSetting", "updateScreenshareSetting", "updateChatSetting", "updateIsSettingsModalVisible", "roomName", "socket", "showAlert"] }, { kind: "component", type: ConfirmExitModal, selector: "app-confirm-exit-modal", inputs: ["isConfirmExitModalVisible", "onConfirmExitClose", "position", "backgroundColor", "exitEventOnConfirm", "member", "ban", "roomName", "socket", "islevel"] }, { kind: "component", type: MediaSettingsModal, selector: "app-media-settings-modal", inputs: ["isMediaSettingsModalVisible", "onMediaSettingsClose", "switchCameraOnPress", "switchVideoOnPress", "switchAudioOnPress", "parameters", "position", "backgroundColor"] }, { kind: "component", type: MenuModal, selector: "app-menu-modal", inputs: ["backgroundColor", "isVisible", "customButtons", "shareButtons", "position", "roomName", "adminPasscode", "islevel", "eventType", "onClose"] }, { kind: "component", type: MessagesModal, selector: "app-messages-modal", inputs: ["isMessagesModalVisible", "onMessagesClose", "onSendMessagePress", "messages", "position", "backgroundColor", "activeTabBackgroundColor", "eventType", "member", "islevel", "coHostResponsibility", "coHost", "startDirectMessage", "directMessageDetails", "updateStartDirectMessage", "updateDirectMessageDetails", "showAlert", "roomName", "socket", "chatSetting"] }, { kind: "component", type: ConfirmHereModal, selector: "app-confirm-here-modal", inputs: ["isConfirmHereModalVisible", "position", "backgroundColor", "displayColor", "onConfirmHereClose", "countdownDuration", "socket", "roomName", "member"] }, { kind: "component", type: ShareEventModal, selector: "app-share-event-modal", inputs: ["backgroundColor", "isShareEventModalVisible", "onShareEventClose", "roomName", "adminPasscode", "islevel", "position", "shareButtons", "eventType"] }, { kind: "component", type: ParticipantsModal, selector: "app-participants-modal", inputs: ["isParticipantsModalVisible", "onParticipantsClose", "onParticipantsFilterChange", "participantsCounter", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "parameters", "position", "backgroundColor"] }, { kind: "component", type: PollModal, selector: "app-poll-modal", inputs: ["isPollModalVisible", "onClose", "position", "backgroundColor", "member", "islevel", "polls", "poll", "socket", "roomName", "showAlert", "updateIsPollModalVisible", "handleCreatePoll", "handleEndPoll", "handleVotePoll"] }, { kind: "component", type: RecordingModal, selector: "app-recording-modal", inputs: ["isRecordingModalVisible", "onClose", "backgroundColor", "position", "confirmRecording", "startRecording", "parameters"] }, { kind: "component", type: RequestsModal, selector: "app-requests-modal", inputs: ["isRequestsModalVisible", "requestCounter", "requestList", "roomName", "socket", "backgroundColor", "position", "parameters", "onRequestClose", "onRequestFilterChange", "onRequestItemPress", "updateRequestList"] }, { kind: "component", type: MainAspectComponent, selector: "app-main-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "updateIsWideScreen", "updateIsMediumScreen", "updateIsSmallScreen"] }, { kind: "component", type: MainContainerComponent, selector: "app-main-container-component", inputs: ["backgroundColor", "containerWidthFraction", "containerHeightFraction", "marginLeft", "marginRight", "marginTop", "marginBottom", "padding"] }, { kind: "component", type: MainGridComponent, selector: "app-main-grid-component", inputs: ["backgroundColor", "mainSize", "height", "width", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: MainScreenComponent, selector: "app-main-screen-component", inputs: ["mainSize", "doStack", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "showControls", "updateComponentSizes"] }, { kind: "component", type: OtherGridComponent, selector: "app-other-grid-component", inputs: ["backgroundColor", "width", "height", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: ScreenboardModal, selector: "app-screenboard-modal", inputs: ["parameters", "isVisible", "onClose", "position", "backgroundColor"] }, { kind: "component", type: Whiteboard, selector: "app-whiteboard", inputs: ["customWidth", "customHeight", "parameters", "showAspect"] }, { kind: "component", type: ConfigureWhiteboardModal, selector: "app-configure-whiteboard-modal", inputs: ["isVisible", "parameters", "backgroundColor", "position", "onConfigureWhiteboardClose"] }, { kind: "component", type: WaitingRoomModal, selector: "app-waiting-room-modal", inputs: ["isWaitingModalVisible", "waitingRoomCounter", "waitingRoomList", "roomName", "socket", "position", "backgroundColor", "parameters", "onWaitingRoomClose", "onWaitingRoomFilterChange", "updateWaitingList", "onWaitingRoomItemPress"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediasfuGeneric, decorators: [{
            type: Component,
            args: [{ selector: 'app-mediasfu-generic', standalone: true, imports: [
                        RouterOutlet,
                        CommonModule,
                        BreakoutRoomsModal,
                        BackgroundModal,
                        CoHostModal,
                        AlertComponent,
                        AudioGrid,
                        ControlButtonsAltComponent,
                        ControlButtonsComponentTouch,
                        ControlButtonsComponent,
                        FlexibleGrid,
                        FlexibleVideo,
                        LoadingModal,
                        Pagination,
                        SubAspectComponent,
                        DisplaySettingsModal,
                        EventSettingsModal,
                        ConfirmExitModal,
                        MediaSettingsModal,
                        MenuModal,
                        MessagesModal,
                        ConfirmHereModal,
                        ShareEventModal,
                        WelcomePage,
                        ParticipantsModal,
                        PollModal,
                        RecordingModal,
                        RequestsModal,
                        MainAspectComponent,
                        MainContainerComponent,
                        MainGridComponent,
                        MainScreenComponent,
                        OtherGridComponent,
                        Screenboard,
                        ScreenboardModal,
                        Whiteboard,
                        ConfigureWhiteboardModal,
                        WaitingRoomModal,
                        MenuWidget,
                        MessageWidget,
                        MenuRecordWidget,
                        RecordTimerWidget,
                        MenuParticipantsWidget,
                        ScreenShareWidget,
                    ], template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component>
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
                <app-control-buttons-component-touch
                  [buttons]="controlBroadcastButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'broadcast'"
                ></app-control-buttons-component-touch>
                <app-control-buttons-component-touch
                  [buttons]="recordButton"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    !showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>
                <app-control-buttons-component-touch
                  [buttons]="recordButtons"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>
                <app-control-buttons-component-touch
                  [buttons]="controlChatButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'chat'"
                ></app-control-buttons-component-touch>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </div>
  `, providers: [CookieService] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: UpdateMiniCardsGrid }, { type: MixStreams }, { type: DispStreams }, { type: StopShareScreen }, { type: CheckScreenShare }, { type: StartShareScreen }, { type: RequestScreenShare }, { type: ReorderStreams }, { type: PrepopulateUserMedia }, { type: GetVideos }, { type: RePort }, { type: Trigger }, { type: ConsumerResume }, { type: ConnectSendTransport }, { type: ConnectSendTransportAudio }, { type: ConnectSendTransportVideo }, { type: ConnectSendTransportScreen }, { type: ProcessConsumerTransports }, { type: ResumePauseStreams }, { type: Readjust }, { type: CheckGrid }, { type: GetEstimate }, { type: CalculateRowsAndColumns }, { type: AddVideosGrid }, { type: OnScreenChanges }, { type: ChangeVids }, { type: CompareActiveNames }, { type: CompareScreenStates }, { type: CreateSendTransport }, { type: ResumeSendTransportAudio }, { type: ReceiveAllPipedTransports }, { type: DisconnectSendTransportVideo }, { type: DisconnectSendTransportAudio }, { type: DisconnectSendTransportScreen }, { type: GetPipedProducersAlt }, { type: SignalNewConsumerTransport }, { type: ConnectRecvTransport }, { type: ReUpdateInter }, { type: UpdateParticipantAudioDecibels }, { type: CloseAndResize }, { type: AutoAdjust }, { type: SwitchUserVideoAlt }, { type: SwitchUserVideo }, { type: SwitchUserAudio }, { type: GetDomains }, { type: FormatNumber }, { type: ConnectIps }, { type: CreateDeviceClient }, { type: HandleCreatePoll }, { type: HandleEndPoll }, { type: HandleVotePoll }, { type: CaptureCanvasStream }, { type: ResumePauseAudioStreams }, { type: ProcessConsumerTransportsAudio }, { type: LaunchMenuModal }, { type: LaunchRecording }, { type: StartRecording }, { type: ConfirmRecording }, { type: LaunchWaiting }, { type: launchCoHost }, { type: LaunchMediaSettings }, { type: LaunchDisplaySettings }, { type: LaunchSettings }, { type: LaunchRequests }, { type: LaunchParticipants }, { type: LaunchMessages }, { type: LaunchConfirmExit }, { type: LaunchPoll }, { type: LaunchBreakoutRooms }, { type: LaunchConfigureWhiteboard }, { type: StartMeetingProgressTimer }, { type: UpdateRecording }, { type: StopRecording }, { type: UserWaiting }, { type: PersonJoined }, { type: AllWaitingRoomMembers }, { type: RoomRecordParams }, { type: BanParticipant }, { type: UpdatedCoHost }, { type: ParticipantRequested }, { type: ScreenProducerId }, { type: UpdateMediaSettings }, { type: ProducerMediaPaused }, { type: ProducerMediaResumed }, { type: ProducerMediaClosed }, { type: ControlMediaHost }, { type: MeetingEnded }, { type: DisconnectUserSelf }, { type: ReceiveMessage }, { type: MeetingTimeRemaining }, { type: MeetingStillThere }, { type: StartRecords }, { type: ReInitiateRecording }, { type: RecordingNotice }, { type: TimeLeftRecording }, { type: StoppedRecording }, { type: HostRequestResponse }, { type: AllMembers }, { type: AllMembersRest }, { type: Disconnect }, { type: PollUpdated }, { type: BreakoutRoomUpdated }, { type: SocketManager }, { type: JoinRoomClient }, { type: UpdateRoomParametersClient }, { type: ClickVideo }, { type: ClickAudio }, { type: ClickScreenShare }, { type: SwitchVideoAlt }, { type: StreamSuccessVideo }, { type: StreamSuccessAudio }, { type: StreamSuccessScreen }, { type: StreamSuccessAudioSwitch }, { type: CheckPermission }, { type: UpdateConsumingDomains }, { type: ReceiveRoomMessages }], propDecorators: { PrejoinPage: [{
                type: Input
            }], credentials: [{
                type: Input
            }], useLocalUIMode: [{
                type: Input
            }], seedData: [{
                type: Input
            }], useSeed: [{
                type: Input
            }], imgSrc: [{
                type: Input
            }], handleResize: [{
                type: HostListener,
                args: ['window:resize']
            }, {
                type: HostListener,
                args: ['window:orientationchange']
            }] } });

class MediasfuBroadcast {
    cdr;
    injector;
    updateMiniCardsGrid;
    mixStreams;
    dispStreams;
    stopShareScreen;
    checkScreenShare;
    startShareScreen;
    requestScreenShare;
    reorderStreams;
    prepopulateUserMedia;
    getVideos;
    rePort;
    trigger;
    consumerResume;
    connectSendTransport;
    connectSendTransportAudio;
    connectSendTransportVideo;
    connectSendTransportScreen;
    processConsumerTransports;
    resumePauseStreams;
    readjust;
    checkGrid;
    getEstimate;
    calculateRowsAndColumns;
    addVideosGrid;
    onScreenChanges;
    changeVids;
    compareActiveNames;
    compareScreenStates;
    createSendTransport;
    resumeSendTransportAudio;
    receiveAllPipedTransports;
    disconnectSendTransportVideo;
    disconnectSendTransportAudio;
    disconnectSendTransportScreen;
    getPipedProducersAlt;
    signalNewConsumerTransport;
    connectRecvTransport;
    reUpdateInter;
    updateParticipantAudioDecibels;
    closeAndResize;
    autoAdjust;
    switchUserVideoAlt;
    switchUserVideo;
    switchUserAudio;
    getDomains;
    formatNumber;
    connectIps;
    createDeviceClient;
    captureCanvasStream;
    resumePauseAudioStreams;
    processConsumerTransportsAudio;
    launchRecording;
    startRecording;
    confirmRecording;
    launchParticipants;
    launchMessages;
    launchConfirmExit;
    startMeetingProgressTimer;
    updateRecording;
    stopRecording;
    personJoined;
    roomRecordParams;
    banParticipant;
    producerMediaPaused;
    producerMediaResumed;
    producerMediaClosed;
    meetingEnded;
    disconnectUserSelf;
    receiveMessage;
    meetingTimeRemaining;
    meetingStillThere;
    startRecords;
    reInitiateRecording;
    recordingNotice;
    timeLeftRecording;
    stoppedRecording;
    allMembers;
    allMembersRest;
    disconnect;
    socketManager;
    joinRoomClient;
    updateRoomParametersClient;
    clickVideo;
    clickAudio;
    clickScreenShare;
    switchVideoAlt;
    streamSuccessVideo;
    streamSuccessAudio;
    streamSuccessScreen;
    streamSuccessAudioSwitch;
    checkPermission;
    updateConsumingDomains;
    receiveRoomMessages;
    PrejoinPage = WelcomePage;
    credentials = { apiUserName: '', apiKey: '' };
    useLocalUIMode = false;
    seedData;
    useSeed = false;
    imgSrc = 'https://mediasfu.com/images/logo192.png';
    title = 'MediaSFU-Broadcast';
    mainHeightWidthSubscription;
    validatedSubscription;
    islevelSubscription;
    coHostSubscription;
    buttonSubscriptions = [];
    ScreenboardSubscription;
    recordingSubscription;
    constructor(cdr, injector, updateMiniCardsGrid, mixStreams, dispStreams, stopShareScreen, checkScreenShare, startShareScreen, requestScreenShare, reorderStreams, prepopulateUserMedia, getVideos, rePort, trigger, consumerResume, connectSendTransport, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, processConsumerTransports, resumePauseStreams, readjust, checkGrid, getEstimate, calculateRowsAndColumns, addVideosGrid, onScreenChanges, changeVids, compareActiveNames, compareScreenStates, createSendTransport, resumeSendTransportAudio, receiveAllPipedTransports, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, getPipedProducersAlt, signalNewConsumerTransport, connectRecvTransport, reUpdateInter, updateParticipantAudioDecibels, closeAndResize, autoAdjust, switchUserVideoAlt, switchUserVideo, switchUserAudio, getDomains, formatNumber, connectIps, createDeviceClient, captureCanvasStream, resumePauseAudioStreams, processConsumerTransportsAudio, launchRecording, startRecording, confirmRecording, launchParticipants, launchMessages, launchConfirmExit, startMeetingProgressTimer, updateRecording, stopRecording, personJoined, roomRecordParams, banParticipant, producerMediaPaused, producerMediaResumed, producerMediaClosed, meetingEnded, disconnectUserSelf, receiveMessage, meetingTimeRemaining, meetingStillThere, startRecords, reInitiateRecording, recordingNotice, timeLeftRecording, stoppedRecording, allMembers, allMembersRest, disconnect, socketManager, joinRoomClient, updateRoomParametersClient, clickVideo, clickAudio, clickScreenShare, switchVideoAlt, streamSuccessVideo, streamSuccessAudio, streamSuccessScreen, streamSuccessAudioSwitch, checkPermission, updateConsumingDomains, receiveRoomMessages) {
        this.cdr = cdr;
        this.injector = injector;
        this.updateMiniCardsGrid = updateMiniCardsGrid;
        this.mixStreams = mixStreams;
        this.dispStreams = dispStreams;
        this.stopShareScreen = stopShareScreen;
        this.checkScreenShare = checkScreenShare;
        this.startShareScreen = startShareScreen;
        this.requestScreenShare = requestScreenShare;
        this.reorderStreams = reorderStreams;
        this.prepopulateUserMedia = prepopulateUserMedia;
        this.getVideos = getVideos;
        this.rePort = rePort;
        this.trigger = trigger;
        this.consumerResume = consumerResume;
        this.connectSendTransport = connectSendTransport;
        this.connectSendTransportAudio = connectSendTransportAudio;
        this.connectSendTransportVideo = connectSendTransportVideo;
        this.connectSendTransportScreen = connectSendTransportScreen;
        this.processConsumerTransports = processConsumerTransports;
        this.resumePauseStreams = resumePauseStreams;
        this.readjust = readjust;
        this.checkGrid = checkGrid;
        this.getEstimate = getEstimate;
        this.calculateRowsAndColumns = calculateRowsAndColumns;
        this.addVideosGrid = addVideosGrid;
        this.onScreenChanges = onScreenChanges;
        this.changeVids = changeVids;
        this.compareActiveNames = compareActiveNames;
        this.compareScreenStates = compareScreenStates;
        this.createSendTransport = createSendTransport;
        this.resumeSendTransportAudio = resumeSendTransportAudio;
        this.receiveAllPipedTransports = receiveAllPipedTransports;
        this.disconnectSendTransportVideo = disconnectSendTransportVideo;
        this.disconnectSendTransportAudio = disconnectSendTransportAudio;
        this.disconnectSendTransportScreen = disconnectSendTransportScreen;
        this.getPipedProducersAlt = getPipedProducersAlt;
        this.signalNewConsumerTransport = signalNewConsumerTransport;
        this.connectRecvTransport = connectRecvTransport;
        this.reUpdateInter = reUpdateInter;
        this.updateParticipantAudioDecibels = updateParticipantAudioDecibels;
        this.closeAndResize = closeAndResize;
        this.autoAdjust = autoAdjust;
        this.switchUserVideoAlt = switchUserVideoAlt;
        this.switchUserVideo = switchUserVideo;
        this.switchUserAudio = switchUserAudio;
        this.getDomains = getDomains;
        this.formatNumber = formatNumber;
        this.connectIps = connectIps;
        this.createDeviceClient = createDeviceClient;
        this.captureCanvasStream = captureCanvasStream;
        this.resumePauseAudioStreams = resumePauseAudioStreams;
        this.processConsumerTransportsAudio = processConsumerTransportsAudio;
        this.launchRecording = launchRecording;
        this.startRecording = startRecording;
        this.confirmRecording = confirmRecording;
        this.launchParticipants = launchParticipants;
        this.launchMessages = launchMessages;
        this.launchConfirmExit = launchConfirmExit;
        this.startMeetingProgressTimer = startMeetingProgressTimer;
        this.updateRecording = updateRecording;
        this.stopRecording = stopRecording;
        this.personJoined = personJoined;
        this.roomRecordParams = roomRecordParams;
        this.banParticipant = banParticipant;
        this.producerMediaPaused = producerMediaPaused;
        this.producerMediaResumed = producerMediaResumed;
        this.producerMediaClosed = producerMediaClosed;
        this.meetingEnded = meetingEnded;
        this.disconnectUserSelf = disconnectUserSelf;
        this.receiveMessage = receiveMessage;
        this.meetingTimeRemaining = meetingTimeRemaining;
        this.meetingStillThere = meetingStillThere;
        this.startRecords = startRecords;
        this.reInitiateRecording = reInitiateRecording;
        this.recordingNotice = recordingNotice;
        this.timeLeftRecording = timeLeftRecording;
        this.stoppedRecording = stoppedRecording;
        this.allMembers = allMembers;
        this.allMembersRest = allMembersRest;
        this.disconnect = disconnect;
        this.socketManager = socketManager;
        this.joinRoomClient = joinRoomClient;
        this.updateRoomParametersClient = updateRoomParametersClient;
        this.clickVideo = clickVideo;
        this.clickAudio = clickAudio;
        this.clickScreenShare = clickScreenShare;
        this.switchVideoAlt = switchVideoAlt;
        this.streamSuccessVideo = streamSuccessVideo;
        this.streamSuccessAudio = streamSuccessAudio;
        this.streamSuccessScreen = streamSuccessScreen;
        this.streamSuccessAudioSwitch = streamSuccessAudioSwitch;
        this.checkPermission = checkPermission;
        this.updateConsumingDomains = updateConsumingDomains;
        this.receiveRoomMessages = receiveRoomMessages;
    }
    createInjector(inputs) {
        const inj = Injector.create({
            providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
            parent: this.injector,
        });
        return inj;
    }
    // Initial values
    mediaSFUFunctions = () => {
        return {
            updateMiniCardsGrid: this.updateMiniCardsGrid?.updateMiniCardsGrid ||
                (() => {
                    console.log('none');
                }),
            mixStreams: this.mixStreams?.mixStreams ||
                (() => {
                    console.log('none');
                }),
            dispStreams: this.dispStreams?.dispStreams ||
                (() => {
                    console.log('none');
                }),
            stopShareScreen: this.stopShareScreen?.stopShareScreen ||
                (() => {
                    console.log('none');
                }),
            checkScreenShare: this.checkScreenShare?.checkScreenShare ||
                (() => {
                    console.log('none');
                }),
            startShareScreen: this.startShareScreen?.startShareScreen ||
                (() => {
                    console.log('none');
                }),
            requestScreenShare: this.requestScreenShare?.requestScreenShare ||
                (() => {
                    console.log('none');
                }),
            reorderStreams: this.reorderStreams?.reorderStreams ||
                (() => {
                    console.log('none');
                }),
            prepopulateUserMedia: this.prepopulateUserMedia?.prepopulateUserMedia ||
                (() => {
                    console.log('none');
                }),
            getVideos: this.getVideos?.getVideos ||
                (() => {
                    console.log('none');
                }),
            rePort: this.rePort?.rePort ||
                (() => {
                    console.log('none');
                }),
            trigger: this.trigger?.trigger ||
                (() => {
                    console.log('none');
                }),
            consumerResume: this.consumerResume?.consumerResume ||
                (() => {
                    console.log('none');
                }),
            connectSendTransport: this.connectSendTransport?.connectSendTransport ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportAudio: this.connectSendTransportAudio?.connectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportVideo: this.connectSendTransportVideo?.connectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportScreen: this.connectSendTransportScreen?.connectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransports: this.processConsumerTransports?.processConsumerTransports ||
                (() => {
                    console.log('none');
                }),
            resumePauseStreams: this.resumePauseStreams?.resumePauseStreams ||
                (() => {
                    console.log('none');
                }),
            readjust: this.readjust?.readjust ||
                (() => {
                    console.log('none');
                }),
            checkGrid: this.checkGrid?.checkGrid ||
                (() => {
                    console.log('none');
                }),
            getEstimate: this.getEstimate?.getEstimate ||
                (() => {
                    console.log('none');
                }),
            calculateRowsAndColumns: this.calculateRowsAndColumns?.calculateRowsAndColumns ||
                (() => {
                    console.log('none');
                }),
            addVideosGrid: this.addVideosGrid?.addVideosGrid ||
                (() => {
                    console.log('none');
                }),
            onScreenChanges: this.onScreenChanges?.onScreenChanges ||
                (() => {
                    console.log('none');
                }),
            sleep: sleep ||
                (() => {
                    console.log('none');
                }),
            changeVids: this.changeVids?.changeVids ||
                (() => {
                    console.log('none');
                }),
            compareActiveNames: this.compareActiveNames?.compareActiveNames ||
                (() => {
                    console.log('none');
                }),
            compareScreenStates: this.compareScreenStates?.compareScreenStates ||
                (() => {
                    console.log('none');
                }),
            createSendTransport: this.createSendTransport?.createSendTransport ||
                (() => {
                    console.log('none');
                }),
            resumeSendTransportAudio: this.resumeSendTransportAudio?.resumeSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            receiveAllPipedTransports: this.receiveAllPipedTransports?.receiveAllPipedTransports ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportVideo: this.disconnectSendTransportVideo?.disconnectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportAudio: this.disconnectSendTransportAudio?.disconnectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportScreen: this.disconnectSendTransportScreen?.disconnectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            getPipedProducersAlt: this.getPipedProducersAlt?.getPipedProducersAlt ||
                (() => {
                    console.log('none');
                }),
            signalNewConsumerTransport: this.signalNewConsumerTransport?.signalNewConsumerTransport ||
                (() => {
                    console.log('none');
                }),
            connectRecvTransport: this.connectRecvTransport?.connectRecvTransport ||
                (() => {
                    console.log('none');
                }),
            reUpdateInter: this.reUpdateInter?.reUpdateInter ||
                (() => {
                    console.log('none');
                }),
            updateParticipantAudioDecibels: this.updateParticipantAudioDecibels?.updateParticipantAudioDecibels ||
                (() => {
                    console.log('none');
                }),
            closeAndResize: this.closeAndResize?.closeAndResize ||
                (() => {
                    console.log('none');
                }),
            autoAdjust: this.autoAdjust?.autoAdjust ||
                (() => {
                    console.log('none');
                }),
            switchUserVideoAlt: this.switchUserVideoAlt?.switchUserVideoAlt ||
                (() => {
                    console.log('none');
                }),
            switchUserVideo: this.switchUserVideo?.switchUserVideo ||
                (() => {
                    console.log('none');
                }),
            switchUserAudio: this.switchUserAudio?.switchUserAudio ||
                (() => {
                    console.log('none');
                }),
            getDomains: this.getDomains?.getDomains ||
                (() => {
                    console.log('none');
                }),
            formatNumber: this.formatNumber?.formatNumber ||
                (() => {
                    console.log('none');
                }),
            connectIps: this.connectIps?.connectIps ||
                (() => {
                    console.log('none');
                }),
            createDeviceClient: this.createDeviceClient?.createDeviceClient ||
                (() => {
                    console.log('none');
                }),
            captureCanvasStream: this.captureCanvasStream?.captureCanvasStream ||
                (() => {
                    console.log('none');
                }),
            resumePauseAudioStreams: this.resumePauseAudioStreams?.resumePauseAudioStreams ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransportsAudio: this.processConsumerTransportsAudio?.processConsumerTransportsAudio ||
                (() => {
                    console.log('none');
                }),
            checkPermission: this.checkPermission?.checkPermission ||
                (() => {
                    console.log('none');
                }),
            streamSuccessVideo: this.streamSuccessVideo?.streamSuccessVideo ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudio: this.streamSuccessAudio?.streamSuccessAudio ||
                (() => {
                    console.log('none');
                }),
            streamSuccessScreen: this.streamSuccessScreen?.streamSuccessScreen ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudioSwitch: this.streamSuccessAudioSwitch?.streamSuccessAudioSwitch ||
                (() => {
                    console.log('none');
                }),
            clickVideo: this.clickVideo?.clickVideo ||
                (() => {
                    console.log('none');
                }),
            clickAudio: this.clickAudio?.clickAudio ||
                (() => {
                    console.log('none');
                }),
            clickScreenShare: this.clickScreenShare?.clickScreenShare ||
                (() => {
                    console.log('none');
                }),
            switchVideoAlt: this.switchVideoAlt?.switchVideoAlt ||
                (() => {
                    console.log('none');
                }),
            requestPermissionCamera: this.requestPermissionCamera ||
                (() => {
                    console.log('none');
                }),
            requestPermissionAudio: this.requestPermissionAudio ||
                (() => {
                    console.log('none');
                }),
        };
    };
    validated = new BehaviorSubject(false);
    localUIMode = new BehaviorSubject(false);
    socket = new BehaviorSubject({});
    roomData = new BehaviorSubject(null);
    device = new BehaviorSubject(null);
    apiKey = new BehaviorSubject('');
    apiUserName = new BehaviorSubject('');
    apiToken = new BehaviorSubject('');
    link = new BehaviorSubject('');
    roomName = new BehaviorSubject('');
    member = new BehaviorSubject('');
    adminPasscode = new BehaviorSubject('');
    islevel = new BehaviorSubject('1');
    coHost = new BehaviorSubject('No coHost');
    coHostResponsibility = new BehaviorSubject([
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ]);
    youAreCoHost = new BehaviorSubject(false);
    youAreHost = new BehaviorSubject(false);
    confirmedToRecord = new BehaviorSubject(false);
    meetingDisplayType = new BehaviorSubject('media');
    meetingVideoOptimized = new BehaviorSubject(false);
    eventType = new BehaviorSubject('broadcast');
    participants = new BehaviorSubject([]);
    filteredParticipants = new BehaviorSubject([]);
    participantsCounter = new BehaviorSubject(0);
    participantsFilter = new BehaviorSubject('');
    consume_sockets = new BehaviorSubject([]);
    rtpCapabilities = new BehaviorSubject(null);
    roomRecvIPs = new BehaviorSubject([]);
    meetingRoomParams = new BehaviorSubject(null);
    itemPageLimit = new BehaviorSubject(4);
    audioOnlyRoom = new BehaviorSubject(false);
    addForBasic = new BehaviorSubject(false);
    screenPageLimit = new BehaviorSubject(4);
    shareScreenStarted = new BehaviorSubject(false);
    shared = new BehaviorSubject(false);
    targetOrientation = new BehaviorSubject('landscape');
    targetResolution = new BehaviorSubject('sd');
    targetResolutionHost = new BehaviorSubject('sd');
    vidCons = new BehaviorSubject({ width: 640, height: 360 });
    frameRate = new BehaviorSubject(10);
    hParams = new BehaviorSubject({});
    vParams = new BehaviorSubject({});
    screenParams = new BehaviorSubject({});
    aParams = new BehaviorSubject({});
    recordingAudioPausesLimit = new BehaviorSubject(0);
    recordingAudioPausesCount = new BehaviorSubject(0);
    recordingAudioSupport = new BehaviorSubject(false);
    recordingAudioPeopleLimit = new BehaviorSubject(0);
    recordingAudioParticipantsTimeLimit = new BehaviorSubject(0);
    recordingVideoPausesCount = new BehaviorSubject(0);
    recordingVideoPausesLimit = new BehaviorSubject(0);
    recordingVideoSupport = new BehaviorSubject(false);
    recordingVideoPeopleLimit = new BehaviorSubject(0);
    recordingVideoParticipantsTimeLimit = new BehaviorSubject(0);
    recordingAllParticipantsSupport = new BehaviorSubject(false);
    recordingVideoParticipantsSupport = new BehaviorSubject(false);
    recordingAllParticipantsFullRoomSupport = new BehaviorSubject(false);
    recordingVideoParticipantsFullRoomSupport = new BehaviorSubject(false);
    recordingPreferredOrientation = new BehaviorSubject('landscape');
    recordingSupportForOtherOrientation = new BehaviorSubject(false);
    recordingMultiFormatsSupport = new BehaviorSubject(false);
    userRecordingParams = new BehaviorSubject({
        mainSpecs: {
            mediaOptions: 'video', // 'audio', 'video'
            audioOptions: 'all', // 'all', 'onScreen', 'host'
            videoOptions: 'all', // 'all', 'mainScreen'
            videoType: 'fullDisplay', // 'all', 'bestDisplay', 'fullDisplay'
            videoOptimized: false, // true, false
            recordingDisplayType: 'media', // 'media', 'video', 'all'
            addHLS: false, // true, false
        },
        dispSpecs: {
            nameTags: true, // true, false
            backgroundColor: '#000000', // '#000000', '#ffffff'
            nameTagsColor: '#ffffff', // '#000000', '#ffffff'
            orientationVideo: 'portrait', // 'landscape', 'portrait', 'all'
        },
    });
    canRecord = new BehaviorSubject(false);
    startReport = new BehaviorSubject(false);
    endReport = new BehaviorSubject(false);
    recordTimerInterval = new BehaviorSubject(null);
    recordStartTime = new BehaviorSubject(0);
    recordElapsedTime = new BehaviorSubject(0);
    isTimerRunning = new BehaviorSubject(false);
    canPauseResume = new BehaviorSubject(false);
    recordChangeSeconds = new BehaviorSubject(15000);
    pauseLimit = new BehaviorSubject(0);
    pauseRecordCount = new BehaviorSubject(0);
    canLaunchRecord = new BehaviorSubject(true);
    stopLaunchRecord = new BehaviorSubject(false);
    participantsAll = new BehaviorSubject([]);
    firstAll = new BehaviorSubject(false);
    updateMainWindow = new BehaviorSubject(false);
    first_round = new BehaviorSubject(false);
    landScaped = new BehaviorSubject(false);
    lock_screen = new BehaviorSubject(false);
    screenId = new BehaviorSubject('');
    allVideoStreams = new BehaviorSubject([]);
    newLimitedStreams = new BehaviorSubject([]);
    newLimitedStreamsIDs = new BehaviorSubject([]);
    activeSounds = new BehaviorSubject([]);
    screenShareIDStream = new BehaviorSubject('');
    screenShareNameStream = new BehaviorSubject('');
    adminIDStream = new BehaviorSubject('');
    adminNameStream = new BehaviorSubject('');
    youYouStream = new BehaviorSubject([]);
    youYouStreamIDs = new BehaviorSubject([]);
    localStream = new BehaviorSubject(null);
    recordStarted = new BehaviorSubject(false);
    recordResumed = new BehaviorSubject(false);
    recordPaused = new BehaviorSubject(false);
    recordStopped = new BehaviorSubject(false);
    adminRestrictSetting = new BehaviorSubject(false);
    videoRequestState = new BehaviorSubject(null);
    videoRequestTime = new BehaviorSubject(0);
    videoAction = new BehaviorSubject(false);
    localStreamVideo = new BehaviorSubject(null);
    userDefaultVideoInputDevice = new BehaviorSubject('');
    currentFacingMode = new BehaviorSubject('user');
    prevFacingMode = new BehaviorSubject('user');
    defVideoID = new BehaviorSubject('');
    allowed = new BehaviorSubject(false);
    dispActiveNames = new BehaviorSubject([]);
    p_dispActiveNames = new BehaviorSubject([]);
    activeNames = new BehaviorSubject([]);
    prevActiveNames = new BehaviorSubject([]);
    p_activeNames = new BehaviorSubject([]);
    membersReceived = new BehaviorSubject(false);
    deferScreenReceived = new BehaviorSubject(false);
    hostFirstSwitch = new BehaviorSubject(false);
    micAction = new BehaviorSubject(false);
    screenAction = new BehaviorSubject(false);
    chatAction = new BehaviorSubject(false);
    audioRequestState = new BehaviorSubject(null);
    screenRequestState = new BehaviorSubject(null);
    chatRequestState = new BehaviorSubject(null);
    audioRequestTime = new BehaviorSubject(0);
    screenRequestTime = new BehaviorSubject(0);
    chatRequestTime = new BehaviorSubject(0);
    updateRequestIntervalSeconds = new BehaviorSubject(240);
    oldSoundIds = new BehaviorSubject([]);
    hostLabel = new BehaviorSubject('Host');
    mainScreenFilled = new BehaviorSubject(false);
    localStreamScreen = new BehaviorSubject(null);
    screenAlreadyOn = new BehaviorSubject(false);
    chatAlreadyOn = new BehaviorSubject(false);
    redirectURL = new BehaviorSubject('');
    oldAllStreams = new BehaviorSubject([]);
    adminVidID = new BehaviorSubject('');
    streamNames = new BehaviorSubject([]);
    non_alVideoStreams = new BehaviorSubject([]);
    sortAudioLoudness = new BehaviorSubject(false);
    audioDecibels = new BehaviorSubject([]);
    mixed_alVideoStreams = new BehaviorSubject([]);
    non_alVideoStreams_muted = new BehaviorSubject([]);
    paginatedStreams = new BehaviorSubject([]);
    localStreamAudio = new BehaviorSubject(null);
    defAudioID = new BehaviorSubject('');
    userDefaultAudioInputDevice = new BehaviorSubject('');
    userDefaultAudioOutputDevice = new BehaviorSubject('');
    prevAudioInputDevice = new BehaviorSubject('');
    prevVideoInputDevice = new BehaviorSubject('');
    audioPaused = new BehaviorSubject(false);
    mainScreenPerson = new BehaviorSubject('');
    adminOnMainScreen = new BehaviorSubject(false);
    screenStates = new BehaviorSubject([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    prevScreenStates = new BehaviorSubject([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    updateDateState = new BehaviorSubject(null);
    lastUpdate = new BehaviorSubject(null);
    nForReadjustRecord = new BehaviorSubject(0);
    fixedPageLimit = new BehaviorSubject(4);
    removeAltGrid = new BehaviorSubject(false);
    nForReadjust = new BehaviorSubject(0);
    reorderInterval = new BehaviorSubject(30000);
    fastReorderInterval = new BehaviorSubject(10000);
    lastReorderTime = new BehaviorSubject(0);
    audStreamNames = new BehaviorSubject([]);
    currentUserPage = new BehaviorSubject(0);
    mainHeightWidth = new BehaviorSubject(100);
    prevMainHeightWidth = new BehaviorSubject(this.mainHeightWidth.value);
    prevDoPaginate = new BehaviorSubject(false);
    doPaginate = new BehaviorSubject(false);
    shareEnded = new BehaviorSubject(false);
    lStreams = new BehaviorSubject([]);
    chatRefStreams = new BehaviorSubject([]);
    controlHeight = new BehaviorSubject(this.eventType.value === 'webinar' || this.eventType.value === 'conference' ? 0 : 0.06);
    isWideScreen = new BehaviorSubject(false);
    isMediumScreen = new BehaviorSubject(false);
    isSmallScreen = new BehaviorSubject(false);
    addGrid = new BehaviorSubject(false);
    addAltGrid = new BehaviorSubject(false);
    gridRows = new BehaviorSubject(0);
    gridCols = new BehaviorSubject(0);
    altGridRows = new BehaviorSubject(0);
    altGridCols = new BehaviorSubject(0);
    numberPages = new BehaviorSubject(0);
    currentStreams = new BehaviorSubject([]);
    showMiniView = new BehaviorSubject(false);
    nStream = new BehaviorSubject(null);
    defer_receive = new BehaviorSubject(false);
    allAudioStreams = new BehaviorSubject([]);
    remoteScreenStream = new BehaviorSubject([]);
    screenProducer = new BehaviorSubject(null);
    gotAllVids = new BehaviorSubject(false);
    paginationHeightWidth = new BehaviorSubject(40);
    paginationDirection = new BehaviorSubject('horizontal');
    gridSizes = new BehaviorSubject({
        gridWidth: 0,
        gridHeight: 0,
        altGridWidth: 0,
        altGridHeight: 0,
    });
    screenForceFullDisplay = new BehaviorSubject(false);
    mainGridStream = new BehaviorSubject([]);
    otherGridStreams = new BehaviorSubject([]);
    audioOnlyStreams = new BehaviorSubject([]);
    videoInputs = new BehaviorSubject([]);
    audioInputs = new BehaviorSubject([]);
    meetingProgressTime = new BehaviorSubject('00:00:00');
    meetingElapsedTime = new BehaviorSubject(0);
    ref_participants = new BehaviorSubject([]);
    updateValidated = (value) => {
        this.validated.next(value);
    };
    updateSocket = (value) => {
        this.socket.next(value);
    };
    updateDevice = (value) => {
        this.device.next(value);
    };
    updateRoomData = (value) => {
        this.roomData.next(value);
    };
    updateApiKey = (value) => {
        this.apiKey.next(value);
    };
    updateApiUserName = (value) => {
        this.apiUserName.next(value);
    };
    updateApiToken = (value) => {
        this.apiToken.next(value);
    };
    updateLink = (value) => {
        this.link.next(value);
    };
    updateRoomName = (value) => {
        this.roomName.next(value);
    };
    updateMember = (value) => {
        this.member.next(value);
    };
    updateAdminPasscode = (value) => {
        this.adminPasscode.next(value);
    };
    updateIslevel = (value) => {
        this.islevel.next(value);
    };
    updateCoHost = (value) => {
        this.coHost.next(value);
    };
    updateCoHostResponsibility = (value) => {
        this.coHostResponsibility.next(value);
    };
    updateYouAreCoHost = (value) => {
        this.youAreCoHost.next(value);
    };
    updateYouAreHost = (value) => {
        this.youAreHost.next(value);
    };
    updateConfirmedToRecord = (value) => {
        this.confirmedToRecord.next(value);
    };
    updateMeetingDisplayType = (value) => {
        this.meetingDisplayType.next(value);
    };
    updateMeetingVideoOptimized = (value) => {
        this.meetingVideoOptimized.next(value);
    };
    updateEventType = (value) => {
        this.eventType.next(value);
    };
    updateParticipants = (value) => {
        this.participants.next(value);
        this.participantsCounter.next(value.length);
        this.filteredParticipants.next(this.participants.value);
    };
    updateFilteredParticipants = (value) => {
        this.filteredParticipants.next(value);
    };
    updateParticipantsCounter = (value) => {
        this.participantsCounter.next(value);
    };
    updateParticipantsFilter = (value) => {
        this.participantsFilter.next(value);
    };
    updateConsume_sockets = (value) => {
        this.consume_sockets.next(value);
    };
    updateRtpCapabilities = (value) => {
        this.rtpCapabilities.next(value);
    };
    updateRoomRecvIPs = (value) => {
        this.roomRecvIPs.next(value);
    };
    updateMeetingRoomParams = (value) => {
        this.meetingRoomParams.next(value);
    };
    updateItemPageLimit = (value) => {
        this.itemPageLimit.next(value);
    };
    updateAudioOnlyRoom = (value) => {
        this.audioOnlyRoom.next(value);
    };
    updateAddForBasic = (value) => {
        this.addForBasic.next(value);
    };
    updateScreenPageLimit = (value) => {
        this.screenPageLimit.next(value);
    };
    updateShareScreenStarted = (value) => {
        this.shareScreenStarted.next(value);
    };
    updateShared = (value) => {
        this.shared.next(value);
        this.screenShareActive.next(value);
        if (value) {
            setTimeout(async () => {
                window.dispatchEvent(new Event('resize'));
            }, 2000);
        }
    };
    updateTargetOrientation = (value) => {
        this.targetOrientation.next(value);
    };
    updateTargetResolution = (value) => {
        this.targetResolution.next(value);
    };
    updateTargetResolutionHost = (value) => {
        this.targetResolutionHost.next(value);
    };
    updateVidCons = (value) => {
        this.vidCons.next(value);
    };
    updateFrameRate = (value) => {
        this.frameRate.next(value);
    };
    updateHParams = (value) => {
        this.hParams.next(value);
    };
    updateVParams = (value) => {
        this.vParams.next(value);
    };
    updateScreenParams = (value) => {
        this.screenParams.next(value);
    };
    updateAParams = (value) => {
        this.aParams.next(value);
    };
    updateRecordingAudioPausesLimit = (value) => {
        this.recordingAudioPausesLimit.next(value);
    };
    updateRecordingAudioPausesCount = (value) => {
        this.recordingAudioPausesCount.next(value);
    };
    updateRecordingAudioSupport = (value) => {
        this.recordingAudioSupport.next(value);
    };
    updateRecordingAudioPeopleLimit = (value) => {
        this.recordingAudioPeopleLimit.next(value);
    };
    updateRecordingAudioParticipantsTimeLimit = (value) => {
        this.recordingAudioParticipantsTimeLimit.next(value);
    };
    updateRecordingVideoPausesCount = (value) => {
        this.recordingVideoPausesCount.next(value);
    };
    updateRecordingVideoPausesLimit = (value) => {
        this.recordingVideoPausesLimit.next(value);
    };
    updateRecordingVideoSupport = (value) => {
        this.recordingVideoSupport.next(value);
    };
    updateRecordingVideoPeopleLimit = (value) => {
        this.recordingVideoPeopleLimit.next(value);
    };
    updateRecordingVideoParticipantsTimeLimit = (value) => {
        this.recordingVideoParticipantsTimeLimit.next(value);
    };
    updateRecordingAllParticipantsSupport = (value) => {
        this.recordingAllParticipantsSupport.next(value);
    };
    updateRecordingVideoParticipantsSupport = (value) => {
        this.recordingVideoParticipantsSupport.next(value);
    };
    updateRecordingAllParticipantsFullRoomSupport = (value) => {
        this.recordingAllParticipantsFullRoomSupport.next(value);
    };
    updateRecordingVideoParticipantsFullRoomSupport = (value) => {
        this.recordingVideoParticipantsFullRoomSupport.next(value);
    };
    updateRecordingPreferredOrientation = (value) => {
        this.recordingPreferredOrientation.next(value);
    };
    updateRecordingSupportForOtherOrientation = (value) => {
        this.recordingSupportForOtherOrientation.next(value);
    };
    updateRecordingMultiFormatsSupport = (value) => {
        this.recordingMultiFormatsSupport.next(value);
    };
    updateUserRecordingParams = (value) => {
        this.userRecordingParams.next(value);
    };
    updateCanRecord = (value) => {
        this.canRecord.next(value);
    };
    updateStartReport = (value) => {
        this.startReport.next(value);
    };
    updateEndReport = (value) => {
        this.endReport.next(value);
    };
    updateRecordTimerInterval = (value) => {
        this.recordTimerInterval.next(value);
    };
    updateRecordStartTime = (value) => {
        this.recordStartTime.next(value);
    };
    updateRecordElapsedTime = (value) => {
        this.recordElapsedTime.next(value);
    };
    updateIsTimerRunning = (value) => {
        this.isTimerRunning.next(value);
    };
    updateCanPauseResume = (value) => {
        this.canPauseResume.next(value);
    };
    updateRecordChangeSeconds = (value) => {
        this.recordChangeSeconds.next(value);
    };
    updatePauseLimit = (value) => {
        this.pauseLimit.next(value);
    };
    updatePauseRecordCount = (value) => {
        this.pauseRecordCount.next(value);
    };
    updateCanLaunchRecord = (value) => {
        this.canLaunchRecord.next(value);
    };
    updateStopLaunchRecord = (value) => {
        this.stopLaunchRecord.next(value);
    };
    updateParticipantsAll = (value) => {
        this.participantsAll.next(value);
    };
    updateFirstAll = (value) => {
        this.firstAll.next(value);
    };
    updateUpdateMainWindow = (value) => {
        this.updateMainWindow.next(value);
    };
    updateFirst_round = (value) => {
        this.first_round.next(value);
    };
    updateLandScaped = (value) => {
        this.landScaped.next(value);
    };
    updateLock_screen = (value) => {
        this.lock_screen.next(value);
    };
    updateScreenId = (value) => {
        this.screenId.next(value);
    };
    updateAllVideoStreams = (value) => {
        this.allVideoStreams.next(value);
    };
    updateNewLimitedStreams = (value) => {
        this.newLimitedStreams.next(value);
    };
    updateNewLimitedStreamsIDs = (value) => {
        this.newLimitedStreamsIDs.next(value);
    };
    updateActiveSounds = (value) => {
        this.activeSounds.next(value);
    };
    updateScreenShareIDStream = (value) => {
        this.screenShareIDStream.next(value);
    };
    updateScreenShareNameStream = (value) => {
        this.screenShareNameStream.next(value);
    };
    updateAdminIDStream = (value) => {
        this.adminIDStream.next(value);
    };
    updateAdminNameStream = (value) => {
        this.adminNameStream.next(value);
    };
    updateYouYouStream = (value) => {
        this.youYouStream.next(value);
    };
    updateYouYouStreamIDs = (value) => {
        this.youYouStreamIDs.next(value);
    };
    updateLocalStream = (value) => {
        this.localStream.next(value);
    };
    updateRecordStarted = (value) => {
        this.recordStarted.next(value);
    };
    updateRecordResumed = (value) => {
        this.recordResumed.next(value);
    };
    updateRecordPaused = (value) => {
        this.recordPaused.next(value);
    };
    updateRecordStopped = (value) => {
        this.recordStopped.next(value);
    };
    updateAdminRestrictSetting = (value) => {
        this.adminRestrictSetting.next(value);
    };
    updateVideoRequestState = (value) => {
        this.videoRequestState.next(value);
    };
    updateVideoRequestTime = (value) => {
        this.videoRequestTime.next(value);
    };
    updateVideoAction = (value) => {
        this.videoAction.next(value);
    };
    updateLocalStreamVideo = (value) => {
        this.localStreamVideo.next(value);
    };
    updateUserDefaultVideoInputDevice = (value) => {
        this.userDefaultVideoInputDevice.next(value);
    };
    updateCurrentFacingMode = (value) => {
        this.currentFacingMode.next(value);
    };
    updatePrevFacingMode = (value) => {
        this.prevFacingMode.next(value);
    };
    updateDefVideoID = (value) => {
        this.defVideoID.next(value);
    };
    updateAllowed = (value) => {
        this.allowed.next(value);
    };
    updateDispActiveNames = (value) => {
        this.dispActiveNames.next(value);
    };
    updateP_dispActiveNames = (value) => {
        this.p_dispActiveNames.next(value);
    };
    updateActiveNames = (value) => {
        this.activeNames.next(value);
    };
    updatePrevActiveNames = (value) => {
        this.prevActiveNames.next(value);
    };
    updateP_activeNames = (value) => {
        this.p_activeNames.next(value);
    };
    updateMembersReceived = (value) => {
        this.membersReceived.next(value);
    };
    updateDeferScreenReceived = (value) => {
        this.deferScreenReceived.next(value);
    };
    updateHostFirstSwitch = (value) => {
        this.hostFirstSwitch.next(value);
    };
    updateMicAction = (value) => {
        this.micAction.next(value);
    };
    updateScreenAction = (value) => {
        this.screenAction.next(value);
    };
    updateChatAction = (value) => {
        this.chatAction.next(value);
    };
    updateAudioRequestState = (value) => {
        this.audioRequestState.next(value);
    };
    updateScreenRequestState = (value) => {
        this.screenRequestState.next(value);
    };
    updateChatRequestState = (value) => {
        this.chatRequestState.next(value);
    };
    updateAudioRequestTime = (value) => {
        this.audioRequestTime.next(value);
    };
    updateScreenRequestTime = (value) => {
        this.screenRequestTime.next(value);
    };
    updateChatRequestTime = (value) => {
        this.chatRequestTime.next(value);
    };
    updateOldSoundIds = (value) => {
        this.oldSoundIds.next(value);
    };
    updateHostLabel = (value) => {
        this.hostLabel.next(value);
    };
    updateMainScreenFilled = (value) => {
        this.mainScreenFilled.next(value);
    };
    updateLocalStreamScreen = (value) => {
        this.localStreamScreen.next(value);
    };
    updateScreenAlreadyOn = (value) => {
        this.screenAlreadyOn.next(value);
    };
    updateChatAlreadyOn = (value) => {
        this.chatAlreadyOn.next(value);
    };
    updateRedirectURL = (value) => {
        this.redirectURL.next(value);
    };
    updateOldAllStreams = (value) => {
        this.oldAllStreams.next(value);
    };
    updateAdminVidID = (value) => {
        this.adminVidID.next(value);
    };
    updateStreamNames = (value) => {
        this.streamNames.next(value);
    };
    updateNon_alVideoStreams = (value) => {
        this.non_alVideoStreams.next(value);
    };
    updateSortAudioLoudness = (value) => {
        this.sortAudioLoudness.next(value);
    };
    updateAudioDecibels = (value) => {
        this.audioDecibels.next(value);
    };
    updateMixed_alVideoStreams = (value) => {
        this.mixed_alVideoStreams.next(value);
    };
    updateNon_alVideoStreams_muted = (value) => {
        this.non_alVideoStreams_muted.next(value);
    };
    updatePaginatedStreams = (value) => {
        this.paginatedStreams.next(value);
    };
    updateLocalStreamAudio = (value) => {
        this.localStreamAudio.next(value);
    };
    updateDefAudioID = (value) => {
        this.defAudioID.next(value);
    };
    updateUserDefaultAudioInputDevice = (value) => {
        this.userDefaultAudioInputDevice.next(value);
    };
    updateUserDefaultAudioOutputDevice = (value) => {
        this.userDefaultAudioOutputDevice.next(value);
    };
    updatePrevAudioInputDevice = (value) => {
        this.prevAudioInputDevice.next(value);
    };
    updatePrevVideoInputDevice = (value) => {
        this.prevVideoInputDevice.next(value);
    };
    updateAudioPaused = (value) => {
        this.audioPaused.next(value);
    };
    updateMainScreenPerson = (value) => {
        this.mainScreenPerson.next(value);
    };
    updateAdminOnMainScreen = (value) => {
        this.adminOnMainScreen.next(value);
    };
    updateScreenStates = (value) => {
        this.screenStates.next(value);
    };
    updatePrevScreenStates = (value) => {
        this.prevScreenStates.next(value);
    };
    updateUpdateDateState = (value) => {
        this.updateDateState.next(value);
    };
    updateLastUpdate = (value) => {
        this.lastUpdate.next(value);
    };
    updateNForReadjustRecord = (value) => {
        this.nForReadjustRecord.next(value);
    };
    updateFixedPageLimit = (value) => {
        this.fixedPageLimit.next(value);
    };
    updateRemoveAltGrid = (value) => {
        this.removeAltGrid.next(value);
    };
    updateNForReadjust = (value) => {
        this.nForReadjust.next(value);
    };
    updateLastReorderTime = (value) => {
        this.lastReorderTime.next(value);
    };
    updateAudStreamNames = (value) => {
        this.audStreamNames.next(value);
    };
    updateCurrentUserPage = (value) => {
        this.currentUserPage.next(value);
    };
    updateMainHeightWidth = (value) => {
        this.mainHeightWidth.next(value);
    };
    updatePrevMainHeightWidth = (value) => {
        this.prevMainHeightWidth.next(value);
    };
    updatePrevDoPaginate = (value) => {
        this.prevDoPaginate.next(value);
    };
    updateDoPaginate = (value) => {
        this.doPaginate.next(value);
    };
    updateShareEnded = (value) => {
        this.shareEnded.next(value);
    };
    updateLStreams = (value) => {
        this.lStreams.next(value);
    };
    updateChatRefStreams = (value) => {
        this.chatRefStreams.next(value);
    };
    updateControlHeight = (value) => {
        this.controlHeight.next(value);
    };
    updateIsWideScreen = (value) => {
        this.isWideScreen.next(value);
    };
    updateIsMediumScreen = (value) => {
        this.isMediumScreen.next(value);
    };
    updateIsSmallScreen = (value) => {
        this.isSmallScreen.next(value);
    };
    updateAddGrid = (value) => {
        this.addGrid.next(value);
    };
    updateAddAltGrid = (value) => {
        this.addAltGrid.next(value);
    };
    updateGridRows = (value) => {
        this.gridRows.next(value);
    };
    updateGridCols = (value) => {
        this.gridCols.next(value);
    };
    updateAltGridRows = (value) => {
        this.altGridRows.next(value);
    };
    updateAltGridCols = (value) => {
        this.altGridCols.next(value);
    };
    updateNumberPages = (value) => {
        this.numberPages.next(value);
    };
    updateCurrentStreams = (value) => {
        this.currentStreams.next(value);
    };
    updateShowMiniView = (value) => {
        this.showMiniView.next(value);
    };
    updateNStream = (value) => {
        this.nStream.next(value);
    };
    updateDefer_receive = (value) => {
        this.defer_receive.next(value);
    };
    updateAllAudioStreams = (value) => {
        this.allAudioStreams.next(value);
    };
    updateRemoteScreenStream = (value) => {
        this.remoteScreenStream.next(value);
    };
    updateScreenProducer = (value) => {
        this.screenProducer.next(value);
    };
    updateGotAllVids = (value) => {
        this.gotAllVids.next(value);
    };
    updatePaginationHeightWidth = (value) => {
        this.paginationHeightWidth.next(value);
    };
    updatePaginationDirection = (value) => {
        this.paginationDirection.next(value);
    };
    updateGridSizes = (value) => {
        this.gridSizes.next(value);
    };
    updateScreenForceFullDisplay = (value) => {
        this.screenForceFullDisplay.next(value);
    };
    updateMainGridStream = (value) => {
        this.mainGridStream.next(value);
    };
    updateOtherGridStreams = (value) => {
        this.otherGridStreams.next(value);
    };
    updateAudioOnlyStreams = (value) => {
        this.audioOnlyStreams.next(value);
    };
    updateVideoInputs = (value) => {
        this.videoInputs.next(value);
    };
    updateAudioInputs = (value) => {
        this.audioInputs.next(value);
    };
    updateMeetingProgressTime = (value) => {
        this.meetingProgressTime.next(value);
    };
    updateMeetingElapsedTime = (value) => {
        this.meetingElapsedTime.next(value);
    };
    updateRef_participants = (value) => {
        this.ref_participants.next(value);
    };
    // Messages
    messages = new BehaviorSubject([]);
    startDirectMessage = new BehaviorSubject(false);
    directMessageDetails = new BehaviorSubject(null);
    showMessagesBadge = new BehaviorSubject(false);
    // Event Settings
    audioSetting = new BehaviorSubject('allow');
    videoSetting = new BehaviorSubject('allow');
    screenshareSetting = new BehaviorSubject('allow');
    chatSetting = new BehaviorSubject('allow');
    // Display Settings
    displayOption = new BehaviorSubject('media');
    autoWave = new BehaviorSubject(true);
    forceFullDisplay = new BehaviorSubject(true);
    prevForceFullDisplay = new BehaviorSubject(false);
    prevMeetingDisplayType = new BehaviorSubject('video');
    // Waiting Room
    waitingRoomFilter = new BehaviorSubject('');
    waitingRoomList = new BehaviorSubject([]);
    waitingRoomCounter = new BehaviorSubject(0);
    filteredWaitingRoomList = new BehaviorSubject([]);
    // Requests
    requestFilter = new BehaviorSubject('');
    requestList = new BehaviorSubject([]);
    requestCounter = new BehaviorSubject(0);
    filteredRequestList = new BehaviorSubject([]);
    // Total Requests and Waiting Room
    totalReqWait = new BehaviorSubject(0);
    // Alerts
    alertVisible = new BehaviorSubject(false);
    alertMessage = new BehaviorSubject('');
    alertType = new BehaviorSubject('success');
    alertDuration = new BehaviorSubject(3000);
    // Progress Timer
    progressTimerVisible = new BehaviorSubject(true);
    progressTimerValue = new BehaviorSubject(0);
    // Menu Modals
    isMenuModalVisible = new BehaviorSubject(false);
    isRecordingModalVisible = new BehaviorSubject(false);
    isSettingsModalVisible = new BehaviorSubject(false);
    isRequestsModalVisible = new BehaviorSubject(false);
    isWaitingModalVisible = new BehaviorSubject(false);
    isCoHostModalVisible = new BehaviorSubject(false);
    isMediaSettingsModalVisible = new BehaviorSubject(false);
    isDisplaySettingsModalVisible = new BehaviorSubject(false);
    // Other Modals
    isParticipantsModalVisible = new BehaviorSubject(false);
    isMessagesModalVisible = new BehaviorSubject(false);
    isConfirmExitModalVisible = new BehaviorSubject(false);
    isConfirmHereModalVisible = new BehaviorSubject(false);
    isShareEventModalVisible = new BehaviorSubject(false);
    isLoadingModalVisible = new BehaviorSubject(false);
    // Recording Options
    recordingMediaOptions = new BehaviorSubject('video');
    recordingAudioOptions = new BehaviorSubject('all');
    recordingVideoOptions = new BehaviorSubject('all');
    recordingVideoType = new BehaviorSubject('fullDisplay');
    recordingVideoOptimized = new BehaviorSubject(false);
    recordingDisplayType = new BehaviorSubject('video');
    recordingAddHLS = new BehaviorSubject(true);
    recordingNameTags = new BehaviorSubject(true);
    recordingBackgroundColor = new BehaviorSubject('#83c0e9');
    recordingNameTagsColor = new BehaviorSubject('#ffffff');
    recordingAddText = new BehaviorSubject(false);
    recordingCustomText = new BehaviorSubject('Add Text');
    recordingCustomTextPosition = new BehaviorSubject('top');
    recordingCustomTextColor = new BehaviorSubject('#ffffff');
    recordingOrientationVideo = new BehaviorSubject('landscape');
    clearedToResume = new BehaviorSubject(true);
    clearedToRecord = new BehaviorSubject(true);
    recordState = new BehaviorSubject('green');
    showRecordButtons = new BehaviorSubject(false);
    recordingProgressTime = new BehaviorSubject('00:00:00');
    audioSwitching = new BehaviorSubject(false);
    videoSwitching = new BehaviorSubject(false);
    // Media States
    videoAlreadyOn = new BehaviorSubject(false);
    audioAlreadyOn = new BehaviorSubject(false);
    componentSizes = new BehaviorSubject({
        mainHeight: 0,
        otherHeight: 0,
        mainWidth: 0,
        otherWidth: 0,
    });
    // Permissions
    hasCameraPermission = new BehaviorSubject(false);
    hasAudioPermission = new BehaviorSubject(false);
    // Transports
    transportCreated = new BehaviorSubject(false);
    transportCreatedVideo = new BehaviorSubject(false);
    transportCreatedAudio = new BehaviorSubject(false);
    transportCreatedScreen = new BehaviorSubject(false);
    producerTransport = new BehaviorSubject(null);
    videoProducer = new BehaviorSubject(null);
    params = new BehaviorSubject({});
    videoParams = new BehaviorSubject({});
    audioParams = new BehaviorSubject({});
    audioProducer = new BehaviorSubject(null);
    consumerTransports = new BehaviorSubject([]);
    consumingTransports = new BehaviorSubject([]);
    // Polls
    polls = new BehaviorSubject([]);
    poll = new BehaviorSubject(null);
    isPollModalVisible = new BehaviorSubject(false);
    // Background
    customImage = new BehaviorSubject('');
    selectedImage = new BehaviorSubject('');
    segmentVideo = new BehaviorSubject(null);
    selfieSegmentation = new BehaviorSubject(null);
    pauseSegmentation = new BehaviorSubject(false);
    processedStream = new BehaviorSubject(null);
    keepBackground = new BehaviorSubject(false);
    backgroundHasChanged = new BehaviorSubject(false);
    virtualStream = new BehaviorSubject(null);
    mainCanvas = new BehaviorSubject(null);
    prevKeepBackground = new BehaviorSubject(false);
    appliedBackground = new BehaviorSubject(false);
    isBackgroundModalVisible = new BehaviorSubject(false);
    autoClickBackground = new BehaviorSubject(false);
    // Breakout Rooms
    breakoutRooms = new BehaviorSubject([]);
    currentRoomIndex = new BehaviorSubject(0);
    canStartBreakout = new BehaviorSubject(false);
    breakOutRoomStarted = new BehaviorSubject(false);
    breakOutRoomEnded = new BehaviorSubject(false);
    hostNewRoom = new BehaviorSubject(-1);
    limitedBreakRoom = new BehaviorSubject([]);
    mainRoomsLength = new BehaviorSubject(0);
    memberRoom = new BehaviorSubject(-1);
    isBreakoutRoomsModalVisible = new BehaviorSubject(false);
    // Whiteboard
    whiteboardUsers = new BehaviorSubject([]);
    currentWhiteboardIndex = new BehaviorSubject(0);
    canStartWhiteboard = new BehaviorSubject(false);
    whiteboardStarted = new BehaviorSubject(false);
    whiteboardEnded = new BehaviorSubject(false);
    whiteboardLimit = new BehaviorSubject(4);
    isWhiteboardModalVisible = new BehaviorSubject(false);
    isConfigureWhiteboardModalVisible = new BehaviorSubject(false);
    shapes = new BehaviorSubject([]);
    useImageBackground = new BehaviorSubject(true);
    redoStack = new BehaviorSubject([]);
    undoStack = new BehaviorSubject([]);
    canvasStream = new BehaviorSubject(null);
    canvasWhiteboard = new BehaviorSubject(null);
    // Screenboard
    canvasScreenboard = new BehaviorSubject(null);
    processedScreenStream = new BehaviorSubject(null);
    annotateScreenStream = new BehaviorSubject(false);
    mainScreenCanvas = new BehaviorSubject(null);
    isScreenboardModalVisible = new BehaviorSubject(false);
    //state variables for the control buttons
    micActive = new BehaviorSubject(this.audioAlreadyOn.value ? this.audioAlreadyOn.value : false);
    videoActive = new BehaviorSubject(this.videoAlreadyOn.value ? this.videoAlreadyOn.value : false);
    screenShareActive = new BehaviorSubject(false);
    endCallActive = new BehaviorSubject(false);
    participantsActive = new BehaviorSubject(false);
    menuActive = new BehaviorSubject(false);
    commentsActive = new BehaviorSubject(false);
    // Update functions
    updateMessages = (value) => {
        this.messages.next(value);
    };
    updateStartDirectMessage = (value) => {
        this.startDirectMessage.next(value);
    };
    updateDirectMessageDetails = (value) => {
        this.directMessageDetails.next(value);
    };
    updateShowMessagesBadge = (value) => {
        this.showMessagesBadge.next(value);
    };
    updateAudioSetting = (value) => {
        this.audioSetting.next(value);
    };
    updateVideoSetting = (value) => {
        this.videoSetting.next(value);
    };
    updateScreenshareSetting = (value) => {
        this.screenshareSetting.next(value);
    };
    updateChatSetting = (value) => {
        this.chatSetting.next(value);
    };
    updateDisplayOption = (value) => {
        this.displayOption.next(value);
    };
    updateAutoWave = (value) => {
        this.autoWave.next(value);
    };
    updateForceFullDisplay = (value) => {
        this.forceFullDisplay.next(value);
    };
    updatePrevForceFullDisplay = (value) => {
        this.prevForceFullDisplay.next(value);
    };
    updatePrevMeetingDisplayType = (value) => {
        this.prevMeetingDisplayType.next(value);
    };
    updateWaitingRoomCounter = (value) => {
        this.waitingRoomCounter.next(value);
    };
    updateWaitingRoomFilter = (value) => {
        this.waitingRoomFilter.next(value);
    };
    updateWaitingRoomList = (value) => {
        this.waitingRoomList.next(value);
        this.filteredWaitingRoomList.next(value);
        this.waitingRoomCounter.next(value.length);
    };
    onWaitingRoomClose = () => {
        this.updateIsWaitingModalVisible(false);
    };
    updateRequestCounter = (value) => {
        this.requestCounter.next(value);
    };
    updateRequestFilter = (value) => {
        this.requestFilter.next(value);
    };
    updateRequestList = (value) => {
        this.requestList.next(value);
        this.filteredRequestList.next(value);
        this.requestCounter.next(value.length);
    };
    onRequestClose = () => {
        this.updateIsRequestsModalVisible(false);
    };
    updateTotalReqWait = (value) => {
        this.totalReqWait.next(value);
    };
    updateAlertVisible = (value) => {
        this.alertVisible.next(value);
    };
    updateAlertMessage = (value) => {
        this.alertMessage.next(value);
    };
    updateAlertType = (value) => {
        this.alertType.next(value);
    };
    updateAlertDuration = (value) => {
        this.alertDuration.next(value);
    };
    updateProgressTimerVisible = (value) => {
        this.progressTimerVisible.next(value);
    };
    updateProgressTimerValue = (value) => {
        this.progressTimerValue.next(value);
    };
    updateIsMenuModalVisible = (value) => {
        this.isMenuModalVisible.next(value);
    };
    updateIsRecordingModalVisible = (value) => {
        this.isRecordingModalVisible.next(value);
        if (value) {
            this.updateConfirmedToRecord(false);
        }
        else {
            if (this.clearedToRecord.getValue() &&
                this.clearedToResume.getValue() &&
                this.recordStarted.getValue()) {
                this.updateShowRecordButtons(true);
            }
        }
    };
    updateIsSettingsModalVisible = (value) => {
        this.isSettingsModalVisible.next(value);
    };
    updateIsRequestsModalVisible = (value) => {
        this.isRequestsModalVisible.next(value);
    };
    updateIsWaitingModalVisible = (value) => {
        this.isWaitingModalVisible.next(value);
    };
    updateIsCoHostModalVisible = (value) => {
        this.isCoHostModalVisible.next(value);
    };
    updateIsMediaSettingsModalVisible = (value) => {
        this.isMediaSettingsModalVisible.next(value);
    };
    updateIsDisplaySettingsModalVisible = (value) => {
        this.isDisplaySettingsModalVisible.next(value);
    };
    updateIsParticipantsModalVisible = (value) => {
        this.isParticipantsModalVisible.next(value);
    };
    updateIsMessagesModalVisible = (value) => {
        this.isMessagesModalVisible.next(value);
        if (!value) {
            this.updateShowMessagesBadge(false);
        }
    };
    updateIsConfirmExitModalVisible = (value) => {
        this.isConfirmExitModalVisible.next(value);
    };
    updateIsConfirmHereModalVisible = (value) => {
        this.isConfirmHereModalVisible.next(value);
    };
    updateIsLoadingModalVisible = (value) => {
        this.isLoadingModalVisible.next(value);
    };
    updateIsShareEventModalVisible = (value) => {
        this.isShareEventModalVisible.next(value);
    };
    updateRecordingMediaOptions = (value) => {
        this.recordingMediaOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAudioOptions = (value) => {
        this.recordingAudioOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptions = (value) => {
        this.recordingVideoOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoType = (value) => {
        this.recordingVideoType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptimized = (value) => {
        this.recordingVideoOptimized.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingDisplayType = (value) => {
        this.recordingDisplayType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddHLS = (value) => {
        this.recordingAddHLS.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddText = (value) => {
        this.recordingAddText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomText = (value) => {
        this.recordingCustomText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextPosition = (value) => {
        this.recordingCustomTextPosition.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextColor = (value) => {
        this.recordingCustomTextColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTags = (value) => {
        this.recordingNameTags.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingBackgroundColor = (value) => {
        this.recordingBackgroundColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTagsColor = (value) => {
        this.recordingNameTagsColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingOrientationVideo = (value) => {
        this.recordingOrientationVideo.next(value);
        this.clearedToRecord.next(false);
    };
    updateClearedToResume = (value) => {
        this.clearedToResume.next(value);
    };
    updateClearedToRecord = (value) => {
        this.clearedToRecord.next(value);
    };
    updateRecordState = (value) => {
        if (this.recordStarted.value && !this.recordStopped.value) {
            if (!this.recordPaused.value) {
                this.recordState.next('red');
            }
            else {
                this.recordState.next('yellow');
            }
        }
        else {
            this.recordState.next(value);
        }
        this.recordState.next(value);
    };
    updateShowRecordButtons = (value) => {
        this.showRecordButtons.next(value);
    };
    updateRecordingProgressTime = (value) => {
        this.recordingProgressTime.next(value);
        this.updateRecordTimerWidget();
    };
    updateAudioSwitching = (value) => {
        this.audioSwitching.next(value);
    };
    updateVideoSwitching = (value) => {
        this.videoSwitching.next(value);
    };
    updateVideoAlreadyOn = (value) => {
        this.videoAlreadyOn.next(value);
        this.videoActive.next(value);
    };
    updateAudioAlreadyOn = (value) => {
        this.audioAlreadyOn.next(value);
        this.micActive.next(value);
    };
    updateComponentSizes = (sizes) => {
        this.componentSizes.next(sizes);
    };
    updateHasCameraPermission = (value) => {
        this.hasCameraPermission.next(value);
    };
    updateHasAudioPermission = (value) => {
        this.hasAudioPermission.next(value);
    };
    requestPermissionCamera() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    requestPermissionAudio() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    updateTransportCreated = (value) => {
        this.transportCreated.next(value);
    };
    updateTransportCreatedVideo = (value) => {
        this.transportCreatedVideo.next(value);
    };
    updateTransportCreatedAudio = (value) => {
        this.transportCreatedAudio.next(value);
    };
    updateTransportCreatedScreen = (value) => {
        this.transportCreatedScreen.next(value);
    };
    updateProducerTransport = (value) => {
        this.producerTransport.next(value);
    };
    updateVideoProducer = (value) => {
        this.videoProducer.next(value);
    };
    updateParams = (value) => {
        this.params.next(value);
    };
    updateVideoParams = (value) => {
        this.videoParams.next(value);
    };
    updateAudioParams = (value) => {
        this.audioParams.next(value);
    };
    updateAudioProducer = (value) => {
        this.audioProducer.next(value);
    };
    updateConsumerTransports = (value) => {
        this.consumerTransports.next(value);
    };
    updateConsumingTransports = (value) => {
        this.consumingTransports.next(value);
    };
    updatePolls = (value) => {
        this.polls.next(value);
    };
    updatePoll = (value) => {
        this.poll.next(value);
    };
    updateIsPollModalVisible = (value) => {
        this.isPollModalVisible.next(value);
    };
    updateCustomImage = (value) => {
        this.customImage.next(value);
    };
    updateSelectedImage = (value) => {
        this.selectedImage.next(value);
    };
    updateSegmentVideo = (value) => {
        this.segmentVideo.next(value);
    };
    updateSelfieSegmentation = (value) => {
        this.selfieSegmentation.next(value);
    };
    updatePauseSegmentation = (value) => {
        this.pauseSegmentation.next(value);
    };
    updateProcessedStream = (value) => {
        this.processedStream.next(value);
    };
    updateKeepBackground = (value) => {
        this.keepBackground.next(value);
    };
    updateBackgroundHasChanged = (value) => {
        this.backgroundHasChanged.next(value);
    };
    updateVirtualStream = (value) => {
        this.virtualStream.next(value);
    };
    updateMainCanvas = (value) => {
        this.mainCanvas.next(value);
    };
    updatePrevKeepBackground = (value) => {
        this.prevKeepBackground.next(value);
    };
    updateAppliedBackground = (value) => {
        this.appliedBackground.next(value);
    };
    updateIsBackgroundModalVisible = (value) => {
        this.isBackgroundModalVisible.next(value);
    };
    updateAutoClickBackground = (value) => {
        this.autoClickBackground.next(value);
    };
    updateBreakoutRooms = (value) => {
        this.breakoutRooms.next(value);
    };
    updateCurrentRoomIndex = (value) => {
        this.currentRoomIndex.next(value);
    };
    updateCanStartBreakout = (value) => {
        this.canStartBreakout.next(value);
    };
    updateBreakOutRoomStarted = (value) => {
        this.breakOutRoomStarted.next(value);
    };
    updateBreakOutRoomEnded = (value) => {
        this.breakOutRoomEnded.next(value);
    };
    updateHostNewRoom = (value) => {
        this.hostNewRoom.next(value);
    };
    updateLimitedBreakRoom = (value) => {
        this.limitedBreakRoom.next(value);
    };
    updateMainRoomsLength = (value) => {
        this.mainRoomsLength.next(value);
    };
    updateMemberRoom = (value) => {
        this.memberRoom.next(value);
    };
    updateIsBreakoutRoomsModalVisible = (value) => {
        this.isBreakoutRoomsModalVisible.next(value);
    };
    updateWhiteboardUsers = (value) => {
        this.whiteboardUsers.next(value);
    };
    updateCurrentWhiteboardIndex = (value) => {
        this.currentWhiteboardIndex.next(value);
    };
    updateCanStartWhiteboard = (value) => {
        this.canStartWhiteboard.next(value);
    };
    updateWhiteboardStarted = (value) => {
        this.whiteboardStarted.next(value);
    };
    updateWhiteboardEnded = (value) => {
        this.whiteboardEnded.next(value);
    };
    updateWhiteboardLimit = (value) => {
        this.whiteboardLimit.next(value);
    };
    updateIsWhiteboardModalVisible = (value) => {
        this.isWhiteboardModalVisible.next(value);
    };
    updateIsConfigureWhiteboardModalVisible = (value) => {
        this.isConfigureWhiteboardModalVisible.next(value);
    };
    updateShapes = (value) => {
        this.shapes.next(value);
    };
    updateUseImageBackground = (value) => {
        this.useImageBackground.next(value);
    };
    updateRedoStack = (value) => {
        this.redoStack.next(value);
    };
    updateUndoStack = (value) => {
        this.undoStack.next(value);
    };
    updateCanvasStream = (value) => {
        this.canvasStream.next(value);
    };
    updateCanvasWhiteboard = (value) => {
        this.canvasWhiteboard.next(value);
    };
    updateCanvasScreenboard = (value) => {
        this.canvasScreenboard.next(value);
    };
    updateProcessedScreenStream = (value) => {
        this.processedScreenStream.next(value);
    };
    updateAnnotateScreenStream = (value) => {
        this.annotateScreenStream.next(value);
    };
    updateMainScreenCanvas = (value) => {
        this.mainScreenCanvas.next(value);
    };
    updateIsScreenboardModalVisible = (value) => {
        this.isScreenboardModalVisible.next(value);
    };
    checkOrientation = () => {
        const isPortrait = window.matchMedia('(orientation: portrait)').matches;
        return isPortrait ? 'portrait' : 'landscape';
    };
    showAlert = ({ message, type, duration = 3000, }) => {
        this.updateAlertMessage(message);
        this.updateAlertType(type);
        this.updateAlertDuration(duration);
        this.updateAlertVisible(true);
    };
    getAllParams() {
        return {
            localUIMode: this.localUIMode.value, // Local UI mode
            // Room Details
            roomName: this.roomName.value,
            member: this.member.value,
            adminPasscode: this.adminPasscode.value,
            youAreCoHost: this.youAreCoHost.value,
            youAreHost: this.youAreHost.value,
            islevel: this.islevel.value,
            confirmedToRecord: this.confirmedToRecord.value,
            meetingDisplayType: this.meetingDisplayType.value,
            meetingVideoOptimized: this.meetingVideoOptimized.value,
            eventType: this.eventType.value,
            participants: this.participants.value,
            filteredParticipants: this.filteredParticipants.value,
            participantsCounter: this.participantsCounter.value,
            participantsFilter: this.participantsFilter.value,
            // More room details - media
            consume_sockets: this.consume_sockets.value,
            rtpCapabilities: this.rtpCapabilities.value,
            roomRecvIPs: this.roomRecvIPs.value,
            meetingRoomParams: this.meetingRoomParams.value,
            itemPageLimit: this.itemPageLimit.value,
            audioOnlyRoom: this.audioOnlyRoom.value,
            addForBasic: this.addForBasic.value,
            screenPageLimit: this.screenPageLimit.value,
            shareScreenStarted: this.shareScreenStarted.value,
            shared: this.shared.value,
            targetOrientation: this.targetOrientation.value,
            targetResolution: this.targetResolution.value,
            targetResolutionHost: this.targetResolutionHost.value,
            vidCons: this.vidCons.value,
            frameRate: this.frameRate.value,
            hParams: this.hParams.value,
            vParams: this.vParams.value,
            screenParams: this.screenParams.value,
            aParams: this.aParams.value,
            // More room details - recording
            recordingAudioPausesLimit: this.recordingAudioPausesLimit.value,
            recordingAudioPausesCount: this.recordingAudioPausesCount.value,
            recordingAudioSupport: this.recordingAudioSupport.value,
            recordingAudioPeopleLimit: this.recordingAudioPeopleLimit.value,
            recordingAudioParticipantsTimeLimit: this.recordingAudioParticipantsTimeLimit.value,
            recordingVideoPausesCount: this.recordingVideoPausesCount.value,
            recordingVideoPausesLimit: this.recordingVideoPausesLimit.value,
            recordingVideoSupport: this.recordingVideoSupport.value,
            recordingVideoPeopleLimit: this.recordingVideoPeopleLimit.value,
            recordingVideoParticipantsTimeLimit: this.recordingVideoParticipantsTimeLimit.value,
            recordingAllParticipantsSupport: this.recordingAllParticipantsSupport.value,
            recordingVideoParticipantsSupport: this.recordingVideoParticipantsSupport.value,
            recordingAllParticipantsFullRoomSupport: this.recordingAllParticipantsFullRoomSupport.value,
            recordingVideoParticipantsFullRoomSupport: this.recordingVideoParticipantsFullRoomSupport.value,
            recordingPreferredOrientation: this.recordingPreferredOrientation.value,
            recordingSupportForOtherOrientation: this.recordingSupportForOtherOrientation.value,
            recordingMultiFormatsSupport: this.recordingMultiFormatsSupport.value,
            userRecordingParams: this.userRecordingParams.value,
            canRecord: this.canRecord.value,
            startReport: this.startReport.value,
            endReport: this.endReport.value,
            recordStartTime: this.recordStartTime.value,
            recordElapsedTime: this.recordElapsedTime.value,
            isTimerRunning: this.isTimerRunning.value,
            canPauseResume: this.canPauseResume.value,
            recordChangeSeconds: this.recordChangeSeconds.value,
            pauseLimit: this.pauseLimit.value,
            pauseRecordCount: this.pauseRecordCount.value,
            canLaunchRecord: this.canLaunchRecord.value,
            stopLaunchRecord: this.stopLaunchRecord.value,
            participantsAll: this.participantsAll.value,
            firstAll: this.firstAll.value,
            updateMainWindow: this.updateMainWindow.value,
            first_round: this.first_round.value,
            landScaped: this.landScaped.value,
            lock_screen: this.lock_screen.value,
            screenId: this.screenId.value,
            allVideoStreams: this.allVideoStreams.value,
            newLimitedStreams: this.newLimitedStreams.value,
            newLimitedStreamsIDs: this.newLimitedStreamsIDs.value,
            activeSounds: this.activeSounds.value,
            screenShareIDStream: this.screenShareIDStream.value,
            screenShareNameStream: this.screenShareNameStream.value,
            adminIDStream: this.adminIDStream.value,
            adminNameStream: this.adminNameStream.value,
            youYouStream: this.youYouStream.value,
            youYouStreamIDs: this.youYouStreamIDs.value,
            localStream: this.localStream.value,
            recordStarted: this.recordStarted.value,
            recordResumed: this.recordResumed.value,
            recordPaused: this.recordPaused.value,
            recordStopped: this.recordStopped.value,
            adminRestrictSetting: this.adminRestrictSetting.value,
            videoRequestState: this.videoRequestState.value,
            videoRequestTime: this.videoRequestTime.value,
            videoAction: this.videoAction.value,
            localStreamVideo: this.localStreamVideo.value,
            userDefaultVideoInputDevice: this.userDefaultVideoInputDevice.value,
            currentFacingMode: this.currentFacingMode.value,
            prevFacingMode: this.prevFacingMode.value,
            defVideoID: this.defVideoID.value,
            allowed: this.allowed.value,
            dispActiveNames: this.dispActiveNames.value,
            p_dispActiveNames: this.p_dispActiveNames.value,
            activeNames: this.activeNames.value,
            prevActiveNames: this.prevActiveNames.value,
            p_activeNames: this.p_activeNames.value,
            membersReceived: this.membersReceived.value,
            deferScreenReceived: this.deferScreenReceived.value,
            hostFirstSwitch: this.hostFirstSwitch.value,
            micAction: this.micAction.value,
            screenAction: this.screenAction.value,
            chatAction: this.chatAction.value,
            audioRequestState: this.audioRequestState.value,
            screenRequestState: this.screenRequestState.value,
            chatRequestState: this.chatRequestState.value,
            audioRequestTime: this.audioRequestTime.value,
            screenRequestTime: this.screenRequestTime.value,
            chatRequestTime: this.chatRequestTime.value,
            updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
            oldSoundIds: this.oldSoundIds.value,
            hostLabel: this.hostLabel.value,
            mainScreenFilled: this.mainScreenFilled.value,
            localStreamScreen: this.localStreamScreen.value,
            screenAlreadyOn: this.screenAlreadyOn.value,
            chatAlreadyOn: this.chatAlreadyOn.value,
            redirectURL: this.redirectURL.value,
            oldAllStreams: this.oldAllStreams.value,
            adminVidID: this.adminVidID.value,
            streamNames: this.streamNames.value,
            non_alVideoStreams: this.non_alVideoStreams.value,
            sortAudioLoudness: this.sortAudioLoudness.value,
            audioDecibels: this.audioDecibels.value,
            mixed_alVideoStreams: this.mixed_alVideoStreams.value,
            non_alVideoStreams_muted: this.non_alVideoStreams_muted.value,
            paginatedStreams: this.paginatedStreams.value,
            localStreamAudio: this.localStreamAudio.value,
            defAudioID: this.defAudioID.value,
            userDefaultAudioInputDevice: this.userDefaultAudioInputDevice.value,
            userDefaultAudioOutputDevice: this.userDefaultAudioOutputDevice.value,
            prevAudioInputDevice: this.prevAudioInputDevice.value,
            prevVideoInputDevice: this.prevVideoInputDevice.value,
            audioPaused: this.audioPaused.value,
            mainScreenPerson: this.mainScreenPerson.value,
            adminOnMainScreen: this.adminOnMainScreen.value,
            screenStates: this.screenStates.value,
            prevScreenStates: this.prevScreenStates.value,
            updateDateState: this.updateDateState.value,
            lastUpdate: this.lastUpdate.value,
            nForReadjustRecord: this.nForReadjustRecord.value,
            fixedPageLimit: this.fixedPageLimit.value,
            removeAltGrid: this.removeAltGrid.value,
            nForReadjust: this.nForReadjust.value,
            lastReorderTime: this.lastReorderTime.value,
            reorderInterval: this.reorderInterval.value,
            fastReorderInterval: this.fastReorderInterval.value,
            audStreamNames: this.audStreamNames.value,
            currentUserPage: this.currentUserPage.value,
            mainHeightWidth: this.mainHeightWidth.value,
            prevMainHeightWidth: this.prevMainHeightWidth.value,
            prevDoPaginate: this.prevDoPaginate.value,
            doPaginate: this.doPaginate.value,
            shareEnded: this.shareEnded.value,
            lStreams: this.lStreams.value,
            chatRefStreams: this.chatRefStreams.value,
            controlHeight: this.controlHeight.value,
            isWideScreen: this.isWideScreen.value,
            isMediumScreen: this.isMediumScreen.value,
            isSmallScreen: this.isSmallScreen.value,
            addGrid: this.addGrid.value,
            addAltGrid: this.addAltGrid.value,
            gridRows: this.gridRows.value,
            gridCols: this.gridCols.value,
            altGridRows: this.altGridRows.value,
            altGridCols: this.altGridCols.value,
            numberPages: this.numberPages.value,
            currentStreams: this.currentStreams.value,
            showMiniView: this.showMiniView.value,
            nStream: this.nStream.value,
            defer_receive: this.defer_receive.value,
            allAudioStreams: this.allAudioStreams.value,
            screenProducer: this.screenProducer.value,
            remoteScreenStream: this.remoteScreenStream.value,
            gotAllVids: this.gotAllVids.value,
            paginationHeightWidth: this.paginationHeightWidth.value,
            paginationDirection: this.paginationDirection.value,
            gridSizes: this.gridSizes.value,
            screenForceFullDisplay: this.screenForceFullDisplay.value,
            mainGridStream: this.mainGridStream.value,
            otherGridStreams: this.otherGridStreams.value,
            audioOnlyStreams: this.audioOnlyStreams.value,
            videoInputs: this.videoInputs.value,
            audioInputs: this.audioInputs.value,
            meetingProgressTime: this.meetingProgressTime.value,
            meetingElapsedTime: this.meetingElapsedTime.value,
            ref_participants: this.ref_participants.value,
            messages: this.messages.value,
            startDirectMessage: this.startDirectMessage.value,
            directMessageDetails: this.directMessageDetails.value,
            coHost: this.coHost.value,
            coHostResponsibility: this.coHostResponsibility.value,
            // Event settings
            audioSetting: this.audioSetting.value,
            videoSetting: this.videoSetting.value,
            screenshareSetting: this.screenshareSetting.value,
            chatSetting: this.chatSetting.value,
            // Display settings
            autoWave: this.autoWave.value,
            forceFullDisplay: this.forceFullDisplay.value,
            prevForceFullDisplay: this.prevForceFullDisplay.value,
            prevMeetingDisplayType: this.prevMeetingDisplayType.value,
            // Waiting room
            waitingRoomFilter: this.waitingRoomFilter.value,
            waitingRoomList: this.waitingRoomList.value,
            waitingRoomCounter: this.waitingRoomCounter.value,
            filteredWaitingRoomList: this.filteredWaitingRoomList.value,
            // Requests
            requestFilter: this.requestFilter.value,
            requestList: this.requestList.value,
            requestCounter: this.requestCounter.value,
            filteredRequestList: this.filteredRequestList.value,
            // Total requests and waiting room
            totalReqWait: this.totalReqWait.value,
            // Alerts
            alertVisible: this.alertVisible.value,
            alertMessage: this.alertMessage.value,
            alertType: this.alertType.value,
            alertDuration: this.alertDuration.value,
            // Progress Timer
            progressTimerVisible: this.progressTimerVisible.value,
            progressTimerValue: this.progressTimerValue.value,
            // Menu modals
            isMenuModalVisible: this.isMenuModalVisible.value,
            isRecordingModalVisible: this.isRecordingModalVisible.value,
            isSettingsModalVisible: this.isSettingsModalVisible.value,
            isRequestsModalVisible: this.isRequestsModalVisible.value,
            isWaitingModalVisible: this.isWaitingModalVisible.value,
            isCoHostModalVisible: this.isCoHostModalVisible.value,
            isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
            isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            // Other Modals
            isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            isMessagesModalVisible: this.isMessagesModalVisible.value,
            isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            isConfirmHereModalVisible: this.isConfirmHereModalVisible.value,
            isLoadingModalVisible: this.isLoadingModalVisible.value,
            // Recording Options
            recordingMediaOptions: this.recordingMediaOptions.value,
            recordingAudioOptions: this.recordingAudioOptions.value,
            recordingVideoOptions: this.recordingVideoOptions.value,
            recordingVideoType: this.recordingVideoType.value,
            recordingVideoOptimized: this.recordingVideoOptimized.value,
            recordingDisplayType: this.recordingDisplayType.value,
            recordingAddHLS: this.recordingAddHLS.value,
            recordingAddText: this.recordingAddText.value,
            recordingCustomText: this.recordingCustomText.value,
            recordingCustomTextPosition: this.recordingCustomTextPosition.value,
            recordingCustomTextColor: this.recordingCustomTextColor.value,
            recordingNameTags: this.recordingNameTags.value,
            recordingBackgroundColor: this.recordingBackgroundColor.value,
            recordingNameTagsColor: this.recordingNameTagsColor.value,
            recordingOrientationVideo: this.recordingOrientationVideo.value,
            clearedToResume: this.clearedToResume.value,
            clearedToRecord: this.clearedToRecord.value,
            recordState: this.recordState.value,
            showRecordButtons: this.showRecordButtons.value,
            recordingProgressTime: this.recordingProgressTime.value,
            audioSwitching: this.audioSwitching.value,
            videoSwitching: this.videoSwitching.value,
            // Media states
            videoAlreadyOn: this.videoAlreadyOn.value,
            audioAlreadyOn: this.audioAlreadyOn.value,
            componentSizes: this.componentSizes.value,
            // Permissions
            hasCameraPermission: this.hasCameraPermission.value,
            hasAudioPermission: this.hasAudioPermission.value,
            // Transports
            transportCreated: this.transportCreated.value,
            transportCreatedVideo: this.transportCreatedVideo.value,
            transportCreatedAudio: this.transportCreatedAudio.value,
            transportCreatedScreen: this.transportCreatedScreen.value,
            producerTransport: this.producerTransport.value,
            videoProducer: this.videoProducer.value,
            params: this.params.value,
            videoParams: this.videoParams.value,
            audioParams: this.audioParams.value,
            audioProducer: this.audioProducer.value,
            consumerTransports: this.consumerTransports.value,
            consumingTransports: this.consumingTransports.value,
            // Polls
            polls: this.polls.value,
            poll: this.poll.value,
            isPollModalVisible: this.isPollModalVisible.value,
            // Background
            customImage: this.customImage.value,
            selectedImage: this.selectedImage.value,
            segmentVideo: this.segmentVideo.value,
            selfieSegmentation: this.selfieSegmentation.value,
            pauseSegmentation: this.pauseSegmentation.value,
            processedStream: this.processedStream.value,
            keepBackground: this.keepBackground.value,
            backgroundHasChanged: this.backgroundHasChanged.value,
            virtualStream: this.virtualStream.value,
            mainCanvas: this.mainCanvas.value,
            prevKeepBackground: this.prevKeepBackground.value,
            appliedBackground: this.appliedBackground.value,
            isBackgroundModalVisible: this.isBackgroundModalVisible.value,
            autoClickBackground: this.autoClickBackground.value,
            // Breakout rooms
            breakoutRooms: this.breakoutRooms.value,
            currentRoomIndex: this.currentRoomIndex.value,
            canStartBreakout: this.canStartBreakout.value,
            breakOutRoomStarted: this.breakOutRoomStarted.value,
            breakOutRoomEnded: this.breakOutRoomEnded.value,
            hostNewRoom: this.hostNewRoom.value,
            limitedBreakRoom: this.limitedBreakRoom.value,
            mainRoomsLength: this.mainRoomsLength.value,
            memberRoom: this.memberRoom.value,
            isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            // Whiteboard
            whiteboardUsers: this.whiteboardUsers.value,
            currentWhiteboardIndex: this.currentWhiteboardIndex.value,
            canStartWhiteboard: this.canStartWhiteboard.value,
            whiteboardStarted: this.whiteboardStarted.value,
            whiteboardEnded: this.whiteboardEnded.value,
            whiteboardLimit: this.whiteboardLimit.value,
            isWhiteboardModalVisible: this.isWhiteboardModalVisible.value,
            isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            shapes: this.shapes.value,
            useImageBackground: this.useImageBackground.value,
            redoStack: this.redoStack.value,
            undoStack: this.undoStack.value,
            canvasStream: this.canvasStream.value,
            canvasWhiteboard: this.canvasWhiteboard.value,
            // Screenboard
            canvasScreenboard: this.canvasScreenboard.value,
            processedScreenStream: this.processedScreenStream.value,
            annotateScreenStream: this.annotateScreenStream.value,
            mainScreenCanvas: this.mainScreenCanvas.value,
            isScreenboardModalVisible: this.isScreenboardModalVisible.value,
            validated: this.validated.value,
            device: this.device.value,
            socket: this.socket.value,
            checkMediaPermission: false,
            onWeb: true,
            // Update functions
            updateRoomName: this.updateRoomName.bind(this),
            updateMember: this.updateMember.bind(this),
            updateAdminPasscode: this.updateAdminPasscode.bind(this),
            updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
            updateYouAreHost: this.updateYouAreHost.bind(this),
            updateIslevel: this.updateIslevel.bind(this),
            updateCoHost: this.updateCoHost.bind(this),
            updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
            updateConfirmedToRecord: this.updateConfirmedToRecord.bind(this),
            updateMeetingDisplayType: this.updateMeetingDisplayType.bind(this),
            updateMeetingVideoOptimized: this.updateMeetingVideoOptimized.bind(this),
            updateEventType: this.updateEventType.bind(this),
            updateParticipants: this.updateParticipants.bind(this),
            updateParticipantsCounter: this.updateParticipantsCounter.bind(this),
            updateParticipantsFilter: this.updateParticipantsFilter.bind(this),
            // More update functions for media details
            updateConsume_sockets: this.updateConsume_sockets.bind(this),
            updateRtpCapabilities: this.updateRtpCapabilities.bind(this),
            updateRoomRecvIPs: this.updateRoomRecvIPs.bind(this),
            updateMeetingRoomParams: this.updateMeetingRoomParams.bind(this),
            updateItemPageLimit: this.updateItemPageLimit.bind(this),
            updateAudioOnlyRoom: this.updateAudioOnlyRoom.bind(this),
            updateAddForBasic: this.updateAddForBasic.bind(this),
            updateScreenPageLimit: this.updateScreenPageLimit.bind(this),
            updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
            updateShared: this.updateShared.bind(this),
            updateTargetOrientation: this.updateTargetOrientation.bind(this),
            updateTargetResolution: this.updateTargetResolution.bind(this),
            updateTargetResolutionHost: this.updateTargetResolutionHost.bind(this),
            updateVidCons: this.updateVidCons.bind(this),
            updateFrameRate: this.updateFrameRate.bind(this),
            updateHParams: this.updateHParams.bind(this),
            updateVParams: this.updateVParams.bind(this),
            updateScreenParams: this.updateScreenParams.bind(this),
            updateAParams: this.updateAParams.bind(this),
            // More update functions for recording details
            updateRecordingAudioPausesLimit: this.updateRecordingAudioPausesLimit.bind(this),
            updateRecordingAudioPausesCount: this.updateRecordingAudioPausesCount.bind(this),
            updateRecordingAudioSupport: this.updateRecordingAudioSupport.bind(this),
            updateRecordingAudioPeopleLimit: this.updateRecordingAudioPeopleLimit.bind(this),
            updateRecordingAudioParticipantsTimeLimit: this.updateRecordingAudioParticipantsTimeLimit.bind(this),
            updateRecordingVideoPausesCount: this.updateRecordingVideoPausesCount.bind(this),
            updateRecordingVideoPausesLimit: this.updateRecordingVideoPausesLimit.bind(this),
            updateRecordingVideoSupport: this.updateRecordingVideoSupport.bind(this),
            updateRecordingVideoPeopleLimit: this.updateRecordingVideoPeopleLimit.bind(this),
            updateRecordingVideoParticipantsTimeLimit: this.updateRecordingVideoParticipantsTimeLimit.bind(this),
            updateRecordingAllParticipantsSupport: this.updateRecordingAllParticipantsSupport.bind(this),
            updateRecordingVideoParticipantsSupport: this.updateRecordingVideoParticipantsSupport.bind(this),
            updateRecordingAllParticipantsFullRoomSupport: this.updateRecordingAllParticipantsFullRoomSupport.bind(this),
            updateRecordingVideoParticipantsFullRoomSupport: this.updateRecordingVideoParticipantsFullRoomSupport.bind(this),
            updateRecordingPreferredOrientation: this.updateRecordingPreferredOrientation.bind(this),
            updateRecordingSupportForOtherOrientation: this.updateRecordingSupportForOtherOrientation.bind(this),
            updateRecordingMultiFormatsSupport: this.updateRecordingMultiFormatsSupport.bind(this),
            updateUserRecordingParams: this.updateUserRecordingParams.bind(this),
            updateCanRecord: this.updateCanRecord.bind(this),
            updateStartReport: this.updateStartReport.bind(this),
            updateEndReport: this.updateEndReport.bind(this),
            updateRecordTimerInterval: this.updateRecordTimerInterval.bind(this),
            updateRecordStartTime: this.updateRecordStartTime.bind(this),
            updateRecordElapsedTime: this.updateRecordElapsedTime.bind(this),
            updateIsTimerRunning: this.updateIsTimerRunning.bind(this),
            updateCanPauseResume: this.updateCanPauseResume.bind(this),
            updateRecordChangeSeconds: this.updateRecordChangeSeconds.bind(this),
            updatePauseLimit: this.updatePauseLimit.bind(this),
            updatePauseRecordCount: this.updatePauseRecordCount.bind(this),
            updateCanLaunchRecord: this.updateCanLaunchRecord.bind(this),
            updateStopLaunchRecord: this.updateStopLaunchRecord.bind(this),
            updateParticipantsAll: this.updateParticipantsAll.bind(this),
            updateFirstAll: this.updateFirstAll.bind(this),
            updateUpdateMainWindow: this.updateUpdateMainWindow.bind(this),
            updateFirst_round: this.updateFirst_round.bind(this),
            updateLandScaped: this.updateLandScaped.bind(this),
            updateLock_screen: this.updateLock_screen.bind(this),
            updateScreenId: this.updateScreenId.bind(this),
            updateAllVideoStreams: this.updateAllVideoStreams.bind(this),
            updateNewLimitedStreams: this.updateNewLimitedStreams.bind(this),
            updateNewLimitedStreamsIDs: this.updateNewLimitedStreamsIDs.bind(this),
            updateActiveSounds: this.updateActiveSounds.bind(this),
            updateScreenShareIDStream: this.updateScreenShareIDStream.bind(this),
            updateScreenShareNameStream: this.updateScreenShareNameStream.bind(this),
            updateAdminIDStream: this.updateAdminIDStream.bind(this),
            updateAdminNameStream: this.updateAdminNameStream.bind(this),
            updateYouYouStream: this.updateYouYouStream.bind(this),
            updateYouYouStreamIDs: this.updateYouYouStreamIDs.bind(this),
            updateLocalStream: this.updateLocalStream.bind(this),
            updateRecordStarted: this.updateRecordStarted.bind(this),
            updateRecordResumed: this.updateRecordResumed.bind(this),
            updateRecordPaused: this.updateRecordPaused.bind(this),
            updateRecordStopped: this.updateRecordStopped.bind(this),
            updateAdminRestrictSetting: this.updateAdminRestrictSetting.bind(this),
            updateVideoRequestState: this.updateVideoRequestState.bind(this),
            updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
            updateVideoAction: this.updateVideoAction.bind(this),
            updateLocalStreamVideo: this.updateLocalStreamVideo.bind(this),
            updateUserDefaultVideoInputDevice: this.updateUserDefaultVideoInputDevice.bind(this),
            updateCurrentFacingMode: this.updateCurrentFacingMode.bind(this),
            updatePrevFacingMode: this.updatePrevFacingMode.bind(this),
            updateDefVideoID: this.updateDefVideoID.bind(this),
            updateAllowed: this.updateAllowed.bind(this),
            updateDispActiveNames: this.updateDispActiveNames.bind(this),
            updateP_dispActiveNames: this.updateP_dispActiveNames.bind(this),
            updateActiveNames: this.updateActiveNames.bind(this),
            updatePrevActiveNames: this.updatePrevActiveNames.bind(this),
            updateP_activeNames: this.updateP_activeNames.bind(this),
            updateMembersReceived: this.updateMembersReceived.bind(this),
            updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
            updateHostFirstSwitch: this.updateHostFirstSwitch.bind(this),
            updateMicAction: this.updateMicAction.bind(this),
            updateScreenAction: this.updateScreenAction.bind(this),
            updateChatAction: this.updateChatAction.bind(this),
            updateAudioRequestState: this.updateAudioRequestState.bind(this),
            updateScreenRequestState: this.updateScreenRequestState.bind(this),
            updateChatRequestState: this.updateChatRequestState.bind(this),
            updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
            updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
            updateChatRequestTime: this.updateChatRequestTime.bind(this),
            updateOldSoundIds: this.updateOldSoundIds.bind(this),
            updateHostLabel: this.updateHostLabel.bind(this),
            updateMainScreenFilled: this.updateMainScreenFilled.bind(this),
            updateLocalStreamScreen: this.updateLocalStreamScreen.bind(this),
            updateScreenAlreadyOn: this.updateScreenAlreadyOn.bind(this),
            updateChatAlreadyOn: this.updateChatAlreadyOn.bind(this),
            updateRedirectURL: this.updateRedirectURL.bind(this),
            updateOldAllStreams: this.updateOldAllStreams.bind(this),
            updateAdminVidID: this.updateAdminVidID.bind(this),
            updateStreamNames: this.updateStreamNames.bind(this),
            updateNon_alVideoStreams: this.updateNon_alVideoStreams.bind(this),
            updateSortAudioLoudness: this.updateSortAudioLoudness.bind(this),
            updateAudioDecibels: this.updateAudioDecibels.bind(this),
            updateMixed_alVideoStreams: this.updateMixed_alVideoStreams.bind(this),
            updateNon_alVideoStreams_muted: this.updateNon_alVideoStreams_muted.bind(this),
            updatePaginatedStreams: this.updatePaginatedStreams.bind(this),
            updateLocalStreamAudio: this.updateLocalStreamAudio.bind(this),
            updateDefAudioID: this.updateDefAudioID.bind(this),
            updateUserDefaultAudioInputDevice: this.updateUserDefaultAudioInputDevice.bind(this),
            updateUserDefaultAudioOutputDevice: this.updateUserDefaultAudioOutputDevice.bind(this),
            updatePrevAudioInputDevice: this.updatePrevAudioInputDevice.bind(this),
            updatePrevVideoInputDevice: this.updatePrevVideoInputDevice.bind(this),
            updateAudioPaused: this.updateAudioPaused.bind(this),
            updateMainScreenPerson: this.updateMainScreenPerson.bind(this),
            updateAdminOnMainScreen: this.updateAdminOnMainScreen.bind(this),
            updateScreenStates: this.updateScreenStates.bind(this),
            updatePrevScreenStates: this.updatePrevScreenStates.bind(this),
            updateUpdateDateState: this.updateUpdateDateState.bind(this),
            updateLastUpdate: this.updateLastUpdate.bind(this),
            updateNForReadjustRecord: this.updateNForReadjustRecord.bind(this),
            updateFixedPageLimit: this.updateFixedPageLimit.bind(this),
            updateRemoveAltGrid: this.updateRemoveAltGrid.bind(this),
            updateNForReadjust: this.updateNForReadjust.bind(this),
            updateLastReorderTime: this.updateLastReorderTime.bind(this),
            updateAudStreamNames: this.updateAudStreamNames.bind(this),
            updateCurrentUserPage: this.updateCurrentUserPage.bind(this),
            updateMainHeightWidth: this.updateMainHeightWidth.bind(this),
            updatePrevMainHeightWidth: this.updatePrevMainHeightWidth.bind(this),
            updatePrevDoPaginate: this.updatePrevDoPaginate.bind(this),
            updateDoPaginate: this.updateDoPaginate.bind(this),
            updateShareEnded: this.updateShareEnded.bind(this),
            updateLStreams: this.updateLStreams.bind(this),
            updateChatRefStreams: this.updateChatRefStreams.bind(this),
            updateControlHeight: this.updateControlHeight.bind(this),
            updateIsWideScreen: this.updateIsWideScreen.bind(this),
            updateIsMediumScreen: this.updateIsMediumScreen.bind(this),
            updateIsSmallScreen: this.updateIsSmallScreen.bind(this),
            updateAddGrid: this.updateAddGrid.bind(this),
            updateAddAltGrid: this.updateAddAltGrid.bind(this),
            updateGridRows: this.updateGridRows.bind(this),
            updateGridCols: this.updateGridCols.bind(this),
            updateAltGridRows: this.updateAltGridRows.bind(this),
            updateAltGridCols: this.updateAltGridCols.bind(this),
            updateNumberPages: this.updateNumberPages.bind(this),
            updateCurrentStreams: this.updateCurrentStreams.bind(this),
            updateShowMiniView: this.updateShowMiniView.bind(this),
            updateNStream: this.updateNStream.bind(this),
            updateDefer_receive: this.updateDefer_receive.bind(this),
            updateAllAudioStreams: this.updateAllAudioStreams.bind(this),
            updateRemoteScreenStream: this.updateRemoteScreenStream.bind(this),
            updateScreenProducer: this.updateScreenProducer.bind(this),
            updateGotAllVids: this.updateGotAllVids.bind(this),
            updatePaginationHeightWidth: this.updatePaginationHeightWidth.bind(this),
            updatePaginationDirection: this.updatePaginationDirection.bind(this),
            updateGridSizes: this.updateGridSizes.bind(this),
            updateScreenForceFullDisplay: this.updateScreenForceFullDisplay.bind(this),
            updateMainGridStream: this.updateMainGridStream.bind(this),
            updateOtherGridStreams: this.updateOtherGridStreams.bind(this),
            updateAudioOnlyStreams: this.updateAudioOnlyStreams.bind(this),
            updateVideoInputs: this.updateVideoInputs.bind(this),
            updateAudioInputs: this.updateAudioInputs.bind(this),
            updateMeetingProgressTime: this.updateMeetingProgressTime.bind(this),
            updateMeetingElapsedTime: this.updateMeetingElapsedTime.bind(this),
            updateRef_participants: this.updateRef_participants.bind(this),
            updateMessages: this.updateMessages.bind(this),
            updateStartDirectMessage: this.updateStartDirectMessage.bind(this),
            updateDirectMessageDetails: this.updateDirectMessageDetails.bind(this),
            updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
            // Event settings
            updateAudioSetting: this.updateAudioSetting.bind(this),
            updateVideoSetting: this.updateVideoSetting.bind(this),
            updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
            updateChatSetting: this.updateChatSetting.bind(this),
            // Display settings
            updateAutoWave: this.updateAutoWave.bind(this),
            updateForceFullDisplay: this.updateForceFullDisplay.bind(this),
            updatePrevForceFullDisplay: this.updatePrevForceFullDisplay.bind(this),
            updatePrevMeetingDisplayType: this.updatePrevMeetingDisplayType.bind(this),
            // Waiting room
            updateWaitingRoomFilter: this.updateWaitingRoomFilter.bind(this),
            updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
            updateWaitingRoomCounter: this.updateWaitingRoomCounter.bind(this),
            // Requests
            updateRequestFilter: this.updateRequestFilter.bind(this),
            updateRequestList: this.updateRequestList.bind(this),
            updateRequestCounter: this.updateRequestCounter.bind(this),
            // Total requests and waiting room
            updateTotalReqWait: this.updateTotalReqWait.bind(this),
            // Menu modals
            updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
            updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
            updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
            updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
            updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
            updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
            // Other modals
            updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
            updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
            updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
            updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
            updateIsLoadingModalVisible: this.updateIsLoadingModalVisible.bind(this),
            // Recording Options
            updateRecordingMediaOptions: this.updateRecordingMediaOptions.bind(this),
            updateRecordingAudioOptions: this.updateRecordingAudioOptions.bind(this),
            updateRecordingVideoOptions: this.updateRecordingVideoOptions.bind(this),
            updateRecordingVideoType: this.updateRecordingVideoType.bind(this),
            updateRecordingVideoOptimized: this.updateRecordingVideoOptimized.bind(this),
            updateRecordingDisplayType: this.updateRecordingDisplayType.bind(this),
            updateRecordingAddHLS: this.updateRecordingAddHLS.bind(this),
            updateRecordingAddText: this.updateRecordingAddText.bind(this),
            updateRecordingCustomText: this.updateRecordingCustomText.bind(this),
            updateRecordingCustomTextPosition: this.updateRecordingCustomTextPosition.bind(this),
            updateRecordingCustomTextColor: this.updateRecordingCustomTextColor.bind(this),
            updateRecordingNameTags: this.updateRecordingNameTags.bind(this),
            updateRecordingBackgroundColor: this.updateRecordingBackgroundColor.bind(this),
            updateRecordingNameTagsColor: this.updateRecordingNameTagsColor.bind(this),
            updateRecordingOrientationVideo: this.updateRecordingOrientationVideo.bind(this),
            updateClearedToResume: this.updateClearedToResume.bind(this),
            updateClearedToRecord: this.updateClearedToRecord.bind(this),
            updateRecordState: this.updateRecordState.bind(this),
            updateShowRecordButtons: this.updateShowRecordButtons.bind(this),
            updateRecordingProgressTime: this.updateRecordingProgressTime.bind(this),
            updateAudioSwitching: this.updateAudioSwitching.bind(this),
            updateVideoSwitching: this.updateVideoSwitching.bind(this),
            // Media states
            updateVideoAlreadyOn: this.updateVideoAlreadyOn.bind(this),
            updateAudioAlreadyOn: this.updateAudioAlreadyOn.bind(this),
            updateComponentSizes: this.updateComponentSizes.bind(this),
            // Permissions
            updateHasCameraPermission: this.updateHasCameraPermission.bind(this),
            updateHasAudioPermission: this.updateHasAudioPermission.bind(this),
            // Transports
            updateTransportCreated: this.updateTransportCreated.bind(this),
            updateTransportCreatedVideo: this.updateTransportCreatedVideo.bind(this),
            updateTransportCreatedAudio: this.updateTransportCreatedAudio.bind(this),
            updateTransportCreatedScreen: this.updateTransportCreatedScreen.bind(this),
            updateProducerTransport: this.updateProducerTransport.bind(this),
            updateVideoProducer: this.updateVideoProducer.bind(this),
            updateParams: this.updateParams.bind(this),
            updateVideoParams: this.updateVideoParams.bind(this),
            updateAudioParams: this.updateAudioParams.bind(this),
            updateAudioProducer: this.updateAudioProducer.bind(this),
            updateConsumerTransports: this.updateConsumerTransports.bind(this),
            updateConsumingTransports: this.updateConsumingTransports.bind(this),
            // Polls
            updatePolls: this.updatePolls.bind(this),
            updatePoll: this.updatePoll.bind(this),
            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
            // Background
            updateCustomImage: this.updateCustomImage.bind(this),
            updateSelectedImage: this.updateSelectedImage.bind(this),
            updateSegmentVideo: this.updateSegmentVideo.bind(this),
            updateSelfieSegmentation: this.updateSelfieSegmentation.bind(this),
            updatePauseSegmentation: this.updatePauseSegmentation.bind(this),
            updateProcessedStream: this.updateProcessedStream.bind(this),
            updateKeepBackground: this.updateKeepBackground.bind(this),
            updateBackgroundHasChanged: this.updateBackgroundHasChanged.bind(this),
            updateVirtualStream: this.updateVirtualStream.bind(this),
            updateMainCanvas: this.updateMainCanvas.bind(this),
            updatePrevKeepBackground: this.updatePrevKeepBackground.bind(this),
            updateAppliedBackground: this.updateAppliedBackground.bind(this),
            updateIsBackgroundModalVisible: this.updateIsBackgroundModalVisible.bind(this),
            updateAutoClickBackground: this.updateAutoClickBackground.bind(this),
            // Breakout rooms
            updateBreakoutRooms: this.updateBreakoutRooms.bind(this),
            updateCurrentRoomIndex: this.updateCurrentRoomIndex.bind(this),
            updateCanStartBreakout: this.updateCanStartBreakout.bind(this),
            updateBreakOutRoomStarted: this.updateBreakOutRoomStarted.bind(this),
            updateBreakOutRoomEnded: this.updateBreakOutRoomEnded.bind(this),
            updateHostNewRoom: this.updateHostNewRoom.bind(this),
            updateLimitedBreakRoom: this.updateLimitedBreakRoom.bind(this),
            updateMainRoomsLength: this.updateMainRoomsLength.bind(this),
            updateMemberRoom: this.updateMemberRoom.bind(this),
            updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
            // Whiteboard
            updateWhiteboardUsers: this.updateWhiteboardUsers.bind(this),
            updateCurrentWhiteboardIndex: this.updateCurrentWhiteboardIndex.bind(this),
            updateCanStartWhiteboard: this.updateCanStartWhiteboard.bind(this),
            updateWhiteboardStarted: this.updateWhiteboardStarted.bind(this),
            updateWhiteboardEnded: this.updateWhiteboardEnded.bind(this),
            updateWhiteboardLimit: this.updateWhiteboardLimit.bind(this),
            updateIsWhiteboardModalVisible: this.updateIsWhiteboardModalVisible.bind(this),
            updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
            updateShapes: this.updateShapes.bind(this),
            updateUseImageBackground: this.updateUseImageBackground.bind(this),
            updateRedoStack: this.updateRedoStack.bind(this),
            updateUndoStack: this.updateUndoStack.bind(this),
            updateCanvasStream: this.updateCanvasStream.bind(this),
            updateCanvasWhiteboard: this.updateCanvasWhiteboard.bind(this),
            // Screenboard
            updateCanvasScreenboard: this.updateCanvasScreenboard.bind(this),
            updateProcessedScreenStream: this.updateProcessedScreenStream.bind(this),
            updateAnnotateScreenStream: this.updateAnnotateScreenStream.bind(this),
            updateMainScreenCanvas: this.updateMainScreenCanvas.bind(this),
            updateIsScreenboardModalVisible: this.updateIsScreenboardModalVisible.bind(this),
            // Other functions
            checkOrientation: this.checkOrientation.bind(this),
            updateDevice: this.updateDevice.bind(this),
            updateSocket: this.updateSocket.bind(this),
            updateValidated: this.updateValidated.bind(this),
            showAlert: this.showAlert.bind(this),
            getUpdatedAllParams: () => {
                return {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                };
            },
        };
    }
    mediaSFUParameters = {
        ...this.getAllParams(),
        ...this.mediaSFUFunctions(),
    };
    getUpdatedAllParams = () => {
        return {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    };
    PrejoinPageComponent = {
        component: this.PrejoinPage,
        injector: null,
    };
    updatePrejoinPageComponent = () => {
        const PrejoinComp = {
            component: this.PrejoinPage,
            injector: this.createInjector({
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    updateSocket: this.updateSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                credentials: this.credentials,
            }),
        };
        this.PrejoinPageComponent = { ...PrejoinComp };
        this.cdr.detectChanges();
    };
    ngOnInit() {
        if (this.PrejoinPage) {
            this.updatePrejoinPageComponent();
        }
        this.setupResizeListener();
        if (this.validated) {
            this.connectAndAddSocketMethods();
        }
        this.mainHeightWidthSubscription = this.mainHeightWidth.subscribe(() => {
            this.updateMainVideoSize();
        });
        this.recordingSubscription = combineLatest([
            this.recordPaused,
            this.recordStarted,
            this.recordStopped,
            this.recordResumed,
            this.recordingProgressTime,
            this.showRecordButtons,
            this.islevel,
        ]).subscribe(([recordPaused, recordStarted, recordStopped, recordResumed, recordingProgressTime, showRecordButtons, islevel,]) => {
            if (recordPaused ||
                recordStarted ||
                recordStopped ||
                recordResumed ||
                recordingProgressTime ||
                showRecordButtons ||
                islevel) {
                this.updateRecordButtons();
            }
        });
        this.validatedSubscription = this.validated.subscribe((validated) => {
            if (validated) {
                this.handleValidated();
            }
        });
        this.islevelSubscription = this.islevel.subscribe((islevel) => {
            if (islevel) {
                this.updateControlBroadcastButtons();
            }
        });
        this.coHostSubscription = combineLatest([this.coHost, this.coHostResponsibility]).subscribe(([coHost, coHostResponsibility]) => {
            if (coHost || coHostResponsibility) {
                this.updateControlBroadcastButtons();
            }
        });
        // Subscribe to changes in BehaviorSubject and update the buttons accordingly
        this.buttonSubscriptions.push(this.micActive.subscribe(() => {
            this.updateControlBroadcastButtons();
        }));
        this.buttonSubscriptions.push(this.videoActive.subscribe(() => {
            this.updateControlBroadcastButtons();
        }));
        this.buttonSubscriptions.push(this.participantsCounter.subscribe((value) => {
            this.updateMenuParticipantsWidget(value);
        }));
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.handleResize);
        window.removeEventListener('orientationchange', this.handleResize);
        if (this.mainHeightWidthSubscription) {
            this.mainHeightWidthSubscription.unsubscribe();
        }
        if (this.validatedSubscription) {
            this.validatedSubscription.unsubscribe();
        }
        if (this.islevelSubscription) {
            this.islevelSubscription.unsubscribe();
        }
        if (this.coHostSubscription) {
            this.coHostSubscription.unsubscribe();
        }
        if (this.ScreenboardSubscription) {
            this.ScreenboardSubscription.unsubscribe();
        }
        if (this.recordingSubscription) {
            this.recordingSubscription.unsubscribe();
        }
    }
    updateMainVideoSize = async () => {
        if (!this.lock_screen.value && !this.shared.value) {
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
        }
        else {
            if (!this.first_round.value) {
                this.prepopulateUserMedia.prepopulateUserMedia({
                    name: this.hostLabel.value,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            }
        }
    };
    async connectAndAddSocketMethods() {
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
        const socket_ = await this.connect_Socket(this.apiUserName.value, '', this.apiToken.value);
        if (socket_) {
            this.updateSocket(socket_);
        }
    }
    async handleValidated() {
        this.updateAllVideoStreams([
            { producerId: 'youyou', stream: undefined, id: 'youyou', name: 'youyou' },
        ]);
        this.updateStreamNames([{ id: 'youyou', name: 'youyou', producerId: '' }]);
        if (this.validated.value) {
            this.updateIsLoadingModalVisible(true);
            try {
                if (!this.localUIMode.value) {
                    await this.connectAndAddSocketMethods();
                }
            }
            catch (error) {
                console.log('error connectAndaAddSocketMethods', error);
            }
            this.startMeetingProgressTimer.startMeetingProgressTimer({
                startTime: Date.now() / 1000,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            this.updateIsLoadingModalVisible(false);
        }
    }
    async handleResize() {
        let fraction = 0;
        if (window.innerHeight < window.innerWidth &&
            (this.eventType.value == 'webinar' || this.eventType.value == 'conference')) {
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        else {
            // Set default control button height for portrait mode or other event types
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            fraction = Number(fraction);
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        const dimensions = this.computeDimensionsMethod({
            containerWidthFraction: 1,
            containerHeightFraction: 1,
            mainSize: this.mainHeightWidth.value,
            doStack: true,
            defaultFraction: this.eventType.value == 'webinar' || this.eventType.value == 'conference'
                ? 1 - fraction
                : 1,
        });
        this.updateComponentSizes(dimensions);
        const orientation = this.checkOrientation();
        if (orientation == 'portrait') {
            if (!this.isWideScreen.value) {
                if (this.shareScreenStarted.value || this.shared.value) {
                    this.updateScreenForceFullDisplay(true);
                }
            }
        }
        // Updates the main grid view
        await this.prepopulateUserMedia.prepopulateUserMedia({
            name: this.hostLabel.value,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
        // Updates the mini grid view
        await this.onScreenChanges.onScreenChanges({
            changed: true,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
    }
    async disconnectAllSockets(consume_sockets) {
        for (const socket of consume_sockets) {
            try {
                const ip = Object.keys(socket)[0];
                await socket[ip].disconnect();
            }
            catch (error) {
                console.log(`Error disconnecting socket with IP: ${Object.keys(socket)[0]}`, error);
            }
        }
    }
    async closeAndReset() {
        //close and clean up all sockets, modals,... and reset all states to initial values
        this.updateIsMessagesModalVisible(false);
        this.updateIsParticipantsModalVisible(false);
        this.updateIsWaitingModalVisible(false);
        this.updateIsRequestsModalVisible(false);
        this.updateIsCoHostModalVisible(false);
        this.updateIsSettingsModalVisible(false);
        this.updateIsDisplaySettingsModalVisible(false);
        this.updateIsMediaSettingsModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsShareEventModalVisible(false);
        this.updateIsConfirmExitModalVisible(false);
        await this.disconnectAllSockets(this.consume_sockets.value);
        await this.updateStatesToInitialValues();
        this.updateMeetingProgressTime('00:00:00');
        this.updateMeetingElapsedTime(0);
        this.updateRecordingProgressTime('00:00:00');
        this.updateRecordElapsedTime(0);
        this.updateShowRecordButtons(false);
        this.updateIsConfigureWhiteboardModalVisible(false);
        this.updateIsWhiteboardModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsRecordingModalVisible(false);
        this.updateIsPollModalVisible(false);
        this.updateIsBreakoutRoomsModalVisible(false);
        this.updateIsBackgroundModalVisible(false);
        this.updateIsLoadingModalVisible(false);
        this.updateIsConfirmHereModalVisible(false);
        await sleep({ ms: 500 });
        this.updateValidated(false);
        //if on web, reload the page
        window.location.reload();
    }
    computeDimensionsMethod = ({ containerWidthFraction = 1, containerHeightFraction = 1, mainSize, doStack = true, defaultFraction, }) => {
        const parentWidth = window.innerWidth * containerWidthFraction;
        const parentHeight = window.innerHeight * containerHeightFraction * defaultFraction;
        let isWideScreen = parentWidth >= 768;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        const dimensions = this.calculateDimensions({
            parentWidth,
            parentHeight,
            isWideScreen,
            mainSize,
            doStack,
        });
        return dimensions;
    };
    calculateDimensions({ parentWidth, parentHeight, isWideScreen, mainSize, doStack, }) {
        if (doStack) {
            return isWideScreen
                ? {
                    mainHeight: Math.floor(parentHeight),
                    otherHeight: Math.floor(parentHeight),
                    mainWidth: Math.floor((mainSize / 100) * parentWidth),
                    otherWidth: Math.floor(((100 - mainSize) / 100) * parentWidth),
                }
                : {
                    mainHeight: Math.floor((mainSize / 100) * parentHeight),
                    otherHeight: Math.floor(((100 - mainSize) / 100) * parentHeight),
                    mainWidth: Math.floor(parentWidth),
                    otherWidth: Math.floor(parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(parentHeight),
                otherHeight: Math.floor(parentHeight),
                mainWidth: Math.floor(parentWidth),
                otherWidth: Math.floor(parentWidth),
            };
        }
    }
    handleOrientationChange() {
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('orientationchange', this.handleResize.bind(this));
    }
    setupResizeListener() {
        this.handleResize();
    }
    orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    async joinRoom(data) {
        const { socket, roomName, islevel, member, sec, apiUserName } = data;
        try {
            const response = await this.joinRoomClient.joinRoomClient({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
            return response;
        }
        catch (error) {
            console.log('Error joining room:', error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    async join_Room({ socket, roomName, islevel, member, sec, apiUserName, }) {
        const data = await this.joinRoom({
            socket: socket,
            roomName: roomName,
            islevel: islevel,
            member: member,
            sec: sec,
            apiUserName: apiUserName,
        });
        if (data && data.success) {
            this.roomData.next(data);
            try {
                this.updateRoomParametersClient.updateRoomParametersClient({
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                        data: data,
                    },
                });
                if (data.isHost) {
                    this.updateIslevel('2');
                }
                else {
                    this.updateIslevel('1');
                }
                if (data.secureCode) {
                    this.updateAdminPasscode(data.secureCode);
                }
                if (data.rtpCapabilities) {
                    const device_ = await this.createDeviceClient.createDeviceClient({
                        rtpCapabilities: data.rtpCapabilities,
                    });
                    if (device_) {
                        this.device.next(device_);
                    }
                }
            }
            catch {
                /* handle error */
            }
        }
        else {
            this.updateValidated(false);
            try {
                if (this.showAlert && data?.reason) {
                    this.showAlert({ message: data?.reason, type: 'danger', duration: 3000 });
                }
            }
            catch {
                /* handle error */
            }
        }
    }
    onParticipantsFilterChange = (value) => {
        if (value && value.length > 0) {
            this.filteredParticipants.next(this.participants.value.filter((participant) => participant.name.toLowerCase().includes(value.toLowerCase())));
            this.participantsCounter.next(this.filteredParticipants.value.length);
        }
        else {
            this.filteredParticipants.next(this.participants.value);
            this.participantsCounter.next(this.participants.value.length);
        }
    };
    updateStatesToInitialValues = async () => {
        const initialValues = initialValuesState;
        const updateFunctions = this.getAllParams();
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                const updateFunctionName = `update${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const updateFunction = updateFunctions[updateFunctionName];
                if (typeof updateFunction === 'function') {
                    try {
                        updateFunction(initialValues[key]);
                    }
                    catch {
                        /* handle error */
                    }
                }
            }
        }
    };
    faRecordVinyl = faRecordVinyl;
    faPlayCircle = faPlayCircle;
    faPauseCircle = faPauseCircle;
    faStopCircle = faStopCircle;
    faDotCircle = faDotCircle;
    faCog = faCog;
    faUsers = faUsers;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faSync = faSync;
    faPhone = faPhone;
    faShareAlt = faShareAlt;
    faComments = faComments;
    faChartBar = faChartBar;
    onCloseMenuModal = () => {
        this.updateIsMenuModalVisible(false);
    };
    onEventSettingsClose = () => {
        this.updateIsSettingsModalVisible(false);
    };
    onCoHostClose = () => {
        this.updateIsCoHostModalVisible(false);
    };
    onMediaSettingsClose = () => {
        this.updateIsMediaSettingsModalVisible(false);
    };
    onDisplaySettingsClose = () => {
        this.updateIsDisplaySettingsModalVisible(false);
    };
    onPollClose = () => {
        this.updateIsPollModalVisible(false);
    };
    onBreakoutRoomsClose = () => {
        this.updateIsBreakoutRoomsModalVisible(false);
    };
    onConfigureWhiteboardClose = () => {
        this.updateIsConfigureWhiteboardModalVisible(false);
    };
    onMessagesClose = () => {
        this.updateIsMessagesModalVisible(false);
    };
    onRecordingClose = () => {
        this.updateIsRecordingModalVisible(false);
    };
    onParticipantsClose = () => {
        this.updateIsParticipantsModalVisible(false);
    };
    onBackgroundClose = () => {
        this.updateIsBackgroundModalVisible(false);
    };
    onConfirmExitClose = () => {
        this.updateIsConfirmExitModalVisible(false);
    };
    onConfirmHereClose = () => {
        this.updateIsConfirmHereModalVisible(false);
    };
    onScreenboardClose = () => {
        this.updateIsScreenboardModalVisible(false);
    };
    onShareEventClose = () => {
        this.updateIsShareEventModalVisible(false);
    };
    onAlertHide = () => {
        this.updateAlertVisible(false);
    };
    recordTimerWidget = {
        component: RecordTimerWidget,
        injector: this.createInjector({ recordingProgressTime: this.recordingProgressTime.value }),
    };
    updateRecordTimerWidget = (recordingProgressTime = this.recordingProgressTime.value) => {
        const recordTimerWidget = {
            component: RecordTimerWidget,
            injector: this.createInjector({ recordingProgressTime: recordingProgressTime }),
        };
        this.recordTimerWidget = { ...recordTimerWidget };
        this.cdr.markForCheck();
        return recordTimerWidget;
    };
    recordButton = [
        {
            icon: this.faRecordVinyl,
            text: 'Record',
            onPress: () => {
                this.launchRecording.launchRecording({
                    updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                    isRecordingModalVisible: this.isRecordingModalVisible.value,
                    showAlert: this.showAlert.bind(this),
                    stopLaunchRecord: this.stopLaunchRecord.value,
                    canLaunchRecord: this.canLaunchRecord.value,
                    recordingAudioSupport: this.recordingAudioSupport.value,
                    recordingVideoSupport: this.recordingVideoSupport.value,
                    updateCanRecord: this.updateCanRecord.bind(this),
                    updateClearedToRecord: this.updateClearedToRecord.bind(this),
                    recordStarted: this.recordStarted.value,
                    recordPaused: this.recordPaused.value,
                    localUIMode: this.localUIMode.value,
                });
            },
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
    ];
    recordButtons = [];
    recordButtonsArray = [
        {
            icon: this.faPlayCircle,
            active: () => !this.recordPaused.value,
            onPress: () => this.updateRecording.updateRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            alternateIcon: this.faPauseCircle,
            show: () => true,
        },
        {
            icon: this.faStopCircle,
            active: () => false,
            onPress: () => this.stopRecording.stopRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: () => this.updateRecordTimerWidget(),
            show: () => true,
            active: () => false,
        },
        {
            icon: this.faDotCircle,
            active: () => false,
            onPress: () => console.log('Status pressed'),
            activeColor: 'black',
            inActiveColor: () => (this.recordPaused.value ? 'yellow' : 'red'),
            show: () => true,
        },
        {
            icon: this.faCog,
            active: () => false,
            onPress: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
    ];
    async updateRecordButtons() {
        const recordButtons = this.recordButtonsArray.map((button) => {
            return {
                ...button,
                active: typeof button.active === 'function' ? button.active() : button.active,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
                activeColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
                inActiveColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
            };
        });
        this.recordButtons = [...recordButtons];
        await this.updateMenuRecordWidget(recordButtons);
        this.updateControlBroadcastButtons();
        this.cdr.markForCheck();
    }
    // Create instances of the custom widgets
    messageWidget = {
        component: MessageWidget,
        injector: this.createInjector({
            icon: this.faComments,
            showBadge: this.showMessagesBadge.value,
            badgeValue: 1,
            iconColor: 'black',
        }),
    };
    menuRecordWidget = {
        component: MenuRecordWidget,
        injector: this.createInjector({
            buttons: this.recordButtons,
            showAspect: true,
            direction: 'horizontal',
        }),
    };
    updateMenuRecordWidget = (recordButtons = this.recordButtons) => {
        const menuRecordWidget = {
            component: MenuRecordWidget,
            injector: this.createInjector({
                buttons: recordButtons,
                showAspect: true,
                direction: 'horizontal',
            }),
        };
        this.menuRecordWidget = { ...menuRecordWidget };
        this.cdr.markForCheck();
        return menuRecordWidget;
    };
    menuParticipantsWidget = {
        component: MenuParticipantsWidget,
        injector: this.createInjector({
            icon: this.faChartBar,
            participantsCounter: this.participantsCounter.value,
            iconColor: 'black',
        }),
    };
    updateMenuParticipantsWidget = (count = this.participantsCounter.value) => {
        const menuParticipantsWidget = {
            component: MenuParticipantsWidget,
            injector: this.createInjector({
                icon: this.faChartBar,
                participantsCounter: count,
                iconColor: 'black',
            }),
        };
        this.menuParticipantsWidget = { ...menuParticipantsWidget };
        this.cdr.markForCheck();
        return menuParticipantsWidget;
    };
    controlBroadcastButtons = [];
    updateControlBroadcastButtons() {
        this.controlBroadcastButtons = this.controlBroadcastButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                active: typeof button.active === 'function' ? button.active() : button.active,
            };
        });
    }
    controlBroadcastButtonsArray = [
        {
            icon: this.faUsers,
            active: true,
            alternateIcon: this.faUsers,
            onPress: () => this.launchParticipants.launchParticipants({
                updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
                isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faShareAlt,
            active: true,
            alternateIcon: this.faShareAlt,
            onPress: () => this.updateIsShareEventModalVisible(!this.isShareEventModalVisible.value),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: this.messageWidget,
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faSync,
            active: true,
            alternateIcon: this.faSync,
            onPress: () => this.switchVideoAlt.switchVideoAlt({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: () => this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            show: () => this.islevel.value == '2',
            activeColor: 'green',
            inActiveColor: 'red',
        },
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: () => this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: () => this.islevel.value == '2',
        },
        {
            customComponent: () => this.menuParticipantsWidget,
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: () => true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => console.log('End Call pressed'),
            activeColor: 'transparent',
            inActiveColor: 'transparent',
            backgroundColor: { default: 'transparent' },
            show: () => false,
        },
    ];
    async connect_Socket(apiUserName, apiKey, apiToken) {
        if (this.socket.value && this.socket.value.id) {
            this.socket.value.on('disconnect', async () => {
                await this.disconnect.disconnect({
                    showAlert: this.showAlert.bind(this),
                    redirectURL: this.redirectURL.value,
                    onWeb: true,
                    updateValidated: this.updateValidated.bind(this),
                });
                if (this.videoAlreadyOn.value) {
                    await this.clickVideo.clickVideo({
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                if (this.audioAlreadyOn.value) {
                    await this.clickAudio.clickAudio({
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                await this.closeAndReset();
            });
            this.socket.value.on('allMembers', async (membersData) => {
                if (membersData) {
                    await this.allMembers.allMembers({
                        apiUserName: apiUserName,
                        apiKey: '', //not recommended - use apiToken instead. Use for testing/development only
                        apiToken: apiToken,
                        members: membersData.members,
                        requestss: membersData.requests ? membersData.requests : this.requestList.value,
                        coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                        coHostRes: membersData.coHostResponsibilities
                            ? membersData.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        consume_sockets: this.consume_sockets.value,
                    });
                }
            });
            this.socket.value.on('allMembersRest', async (membersData) => {
                if (membersData) {
                    await this.allMembersRest.allMembersRest({
                        apiUserName: apiUserName,
                        apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                        members: membersData.members,
                        apiToken: apiToken,
                        settings: membersData.settings,
                        coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                        coHostRes: membersData.coHostResponsibilities
                            ? membersData.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        consume_sockets: this.consume_sockets.value,
                    });
                }
            });
            this.socket.value.on('personJoined', async ({ name }) => {
                this.personJoined.personJoined({
                    name,
                    showAlert: this.showAlert.bind(this),
                });
            });
            this.socket.value.on('roomRecordParams', async ({ recordParams }) => {
                this.roomRecordParams.roomRecordParams({
                    recordParams,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('ban', async ({ name }) => {
                await this.banParticipant.banParticipant({
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('producer-media-paused', async ({ producerId, kind, name, }) => {
                await this.producerMediaPaused.producerMediaPaused({
                    producerId,
                    kind,
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('producer-media-resumed', async ({ kind, name }) => {
                await this.producerMediaResumed.producerMediaResumed({
                    kind,
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('producer-media-closed', async ({ producerId, kind, }) => {
                if (producerId && kind) {
                    await this.producerMediaClosed.producerMediaClosed({
                        producerId,
                        kind,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
            });
            this.socket.value.on('meetingEnded', async () => {
                await this.meetingEnded.meetingEnded({
                    showAlert: this.showAlert.bind(this),
                    redirectURL: this.redirectURL.value,
                    onWeb: true,
                    eventType: this.eventType.value,
                    updateValidated: this.updateValidated.bind(this),
                });
                if (this.videoAlreadyOn.value) {
                    await this.clickVideo.clickVideo({
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                }
                if (this.audioAlreadyOn.value) {
                    await this.clickAudio.clickAudio({
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                }
                await this.closeAndReset();
            });
            this.socket.value.on('disconnectUserSelf', async () => {
                await this.disconnectUserSelf.disconnectUserSelf({
                    socket: this.socket.value,
                    member: this.member.value,
                    roomName: this.roomName.value,
                });
            });
            this.socket.value.on('receiveMessage', async ({ message }) => {
                await this.receiveMessage.receiveMessage({
                    message,
                    messages: this.messages.value,
                    participantsAll: this.participantsAll.value,
                    member: this.member.value,
                    eventType: this.eventType.value,
                    islevel: this.islevel.value,
                    coHost: this.coHost.value,
                    updateMessages: this.updateMessages.bind(this),
                    updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
                });
            });
            this.socket.value.on('meetingTimeRemaining', async ({ timeRemaining }) => {
                await this.meetingTimeRemaining.meetingTimeRemaining({
                    timeRemaining,
                    showAlert: this.showAlert.bind(this),
                    eventType: this.eventType.value,
                });
            });
            this.socket.value.on('meetingStillThere', async () => {
                this.meetingStillThere.meetingStillThere({
                    updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
                });
            });
            this.socket.value.on('startRecords', async () => {
                await this.startRecords.startRecords({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: this.socket.value,
                });
            });
            this.socket.value.on('reInitiateRecording', async () => {
                await this.reInitiateRecording.reInitiateRecording({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: this.socket.value,
                    adminRestrictSetting: this.adminRestrictSetting.value,
                });
            });
            this.socket.value.on('updateConsumingDomains', async ({ domains, alt_domains }) => {
                await this.updateConsumingDomains.updateConsumingDomains({
                    domains,
                    alt_domains,
                    apiUserName,
                    apiKey,
                    apiToken,
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                    },
                });
            });
            this.socket.value.on('RecordingNotice', async ({ state, userRecordingParam, pauseCount, timeDone }) => {
                await this.recordingNotice.RecordingNotice({
                    state,
                    userRecordingParam,
                    pauseCount,
                    timeDone,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('timeLeftRecording', async ({ timeLeft }) => {
                this.timeLeftRecording.timeLeftRecording({
                    timeLeft,
                    showAlert: this.showAlert.bind(this),
                });
            });
            this.socket.value.on('stoppedRecording', async ({ state, reason }) => {
                await this.stoppedRecording.stoppedRecording({
                    state,
                    reason,
                    showAlert: this.showAlert.bind(this),
                });
            });
            await this.join_Room({
                socket: this.socket.value,
                roomName: this.roomName.value,
                islevel: this.islevel.value,
                member: this.member.value,
                sec: this.apiToken.value,
                apiUserName: this.apiUserName.value,
            });
            await this.receiveRoomMessages.receiveRoomMessages({
                socket: this.socket.value,
                roomName: this.roomName.value,
                updateMessages: this.updateMessages.bind(this),
            });
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            return this.socket.value;
        }
        else {
            return null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediasfuBroadcast, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.Injector }, { token: UpdateMiniCardsGrid }, { token: MixStreams }, { token: DispStreams }, { token: StopShareScreen }, { token: CheckScreenShare }, { token: StartShareScreen }, { token: RequestScreenShare }, { token: ReorderStreams }, { token: PrepopulateUserMedia }, { token: GetVideos }, { token: RePort }, { token: Trigger }, { token: ConsumerResume }, { token: ConnectSendTransport }, { token: ConnectSendTransportAudio }, { token: ConnectSendTransportVideo }, { token: ConnectSendTransportScreen }, { token: ProcessConsumerTransports }, { token: ResumePauseStreams }, { token: Readjust }, { token: CheckGrid }, { token: GetEstimate }, { token: CalculateRowsAndColumns }, { token: AddVideosGrid }, { token: OnScreenChanges }, { token: ChangeVids }, { token: CompareActiveNames }, { token: CompareScreenStates }, { token: CreateSendTransport }, { token: ResumeSendTransportAudio }, { token: ReceiveAllPipedTransports }, { token: DisconnectSendTransportVideo }, { token: DisconnectSendTransportAudio }, { token: DisconnectSendTransportScreen }, { token: GetPipedProducersAlt }, { token: SignalNewConsumerTransport }, { token: ConnectRecvTransport }, { token: ReUpdateInter }, { token: UpdateParticipantAudioDecibels }, { token: CloseAndResize }, { token: AutoAdjust }, { token: SwitchUserVideoAlt }, { token: SwitchUserVideo }, { token: SwitchUserAudio }, { token: GetDomains }, { token: FormatNumber }, { token: ConnectIps }, { token: CreateDeviceClient }, { token: CaptureCanvasStream }, { token: ResumePauseAudioStreams }, { token: ProcessConsumerTransportsAudio }, { token: LaunchRecording }, { token: StartRecording }, { token: ConfirmRecording }, { token: LaunchParticipants }, { token: LaunchMessages }, { token: LaunchConfirmExit }, { token: StartMeetingProgressTimer }, { token: UpdateRecording }, { token: StopRecording }, { token: PersonJoined }, { token: RoomRecordParams }, { token: BanParticipant }, { token: ProducerMediaPaused }, { token: ProducerMediaResumed }, { token: ProducerMediaClosed }, { token: MeetingEnded }, { token: DisconnectUserSelf }, { token: ReceiveMessage }, { token: MeetingTimeRemaining }, { token: MeetingStillThere }, { token: StartRecords }, { token: ReInitiateRecording }, { token: RecordingNotice }, { token: TimeLeftRecording }, { token: StoppedRecording }, { token: AllMembers }, { token: AllMembersRest }, { token: Disconnect }, { token: SocketManager }, { token: JoinRoomClient }, { token: UpdateRoomParametersClient }, { token: ClickVideo }, { token: ClickAudio }, { token: ClickScreenShare }, { token: SwitchVideoAlt }, { token: StreamSuccessVideo }, { token: StreamSuccessAudio }, { token: StreamSuccessScreen }, { token: StreamSuccessAudioSwitch }, { token: CheckPermission }, { token: UpdateConsumingDomains }, { token: ReceiveRoomMessages }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MediasfuBroadcast, isStandalone: true, selector: "app-mediasfu-broadcast", inputs: { PrejoinPage: "PrejoinPage", credentials: "credentials", useLocalUIMode: "useLocalUIMode", seedData: "seedData", useSeed: "useSeed", imgSrc: "imgSrc" }, host: { listeners: { "window:resize": "handleResize()", "window:orientationchange": "handleResize()" } }, providers: [CookieService], ngImport: i0, template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <!-- Conditional Rendering: PrejoinPage or Main Content -->
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <!-- Main Content -->
      <ng-template #mainContent>
        <app-main-container-component>
          <!-- Main Aspect Component -->
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <!-- Main Screen Component -->
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <!-- Main Grid Component -->
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                >
                </app-flexible-video>

                <!-- Control Buttons for Broadcast -->
                <app-control-buttons-component-touch
                  [buttons]="controlBroadcastButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'broadcast'"
                ></app-control-buttons-component-touch>

                <!-- Recording Buttons -->
                <app-control-buttons-component-touch
                  [buttons]="recordButton"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    !showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>

                <app-control-buttons-component-touch
                  [buttons]="recordButtons"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>

                <!-- AudioGrid -->
                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>
              </app-main-grid-component>

              <!-- Other Grid Component is not included in MediasfuBroadcast -->
            </app-main-screen-component>
          </app-main-aspect-component>
        </app-main-container-component>
      </ng-template>

      <!-- Modals to include -->
      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
          updateParticipants: updateParticipants,
          updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
          updateDirectMessageDetails: updateDirectMessageDetails,
          updateStartDirectMessage: updateStartDirectMessage,
          updateIsMessagesModalVisible: updateIsMessagesModalVisible,
          showAlert: showAlert,
          filteredParticipants: filteredParticipants.value,
          participants: filteredParticipants.value,
          roomName: roomName.value,
          islevel: islevel.value,
          member: member.value,
          coHostResponsibility: coHostResponsibility.value,
          coHost: coHost.value,
          eventType: eventType.value,
          startDirectMessage: startDirectMessage.value,
          directMessageDetails: directMessageDetails.value,
          socket: socket.value,
          getUpdatedAllParams: getUpdatedAllParams,
        }"
      ></app-participants-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
      ></app-share-event-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: AlertComponent, selector: "app-alert-component", inputs: ["visible", "message", "type", "duration", "textColor", "onHide"] }, { kind: "component", type: AudioGrid, selector: "app-audio-grid", inputs: ["componentsToRender"] }, { kind: "component", type: ControlButtonsComponentTouch, selector: "app-control-buttons-component-touch", inputs: ["buttons", "position", "location", "direction", "buttonsContainerStyle", "showAspect"] }, { kind: "component", type: FlexibleVideo, selector: "app-flexible-video", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "showAspect", "backgroundColor", "Screenboard", "annotateScreenStream", "localStreamScreen"] }, { kind: "component", type: LoadingModal, selector: "app-loading-modal", inputs: ["isVisible", "backgroundColor", "displayColor"] }, { kind: "component", type: ConfirmExitModal, selector: "app-confirm-exit-modal", inputs: ["isConfirmExitModalVisible", "onConfirmExitClose", "position", "backgroundColor", "exitEventOnConfirm", "member", "ban", "roomName", "socket", "islevel"] }, { kind: "component", type: MessagesModal, selector: "app-messages-modal", inputs: ["isMessagesModalVisible", "onMessagesClose", "onSendMessagePress", "messages", "position", "backgroundColor", "activeTabBackgroundColor", "eventType", "member", "islevel", "coHostResponsibility", "coHost", "startDirectMessage", "directMessageDetails", "updateStartDirectMessage", "updateDirectMessageDetails", "showAlert", "roomName", "socket", "chatSetting"] }, { kind: "component", type: ConfirmHereModal, selector: "app-confirm-here-modal", inputs: ["isConfirmHereModalVisible", "position", "backgroundColor", "displayColor", "onConfirmHereClose", "countdownDuration", "socket", "roomName", "member"] }, { kind: "component", type: ShareEventModal, selector: "app-share-event-modal", inputs: ["backgroundColor", "isShareEventModalVisible", "onShareEventClose", "roomName", "adminPasscode", "islevel", "position", "shareButtons", "eventType"] }, { kind: "component", type: ParticipantsModal, selector: "app-participants-modal", inputs: ["isParticipantsModalVisible", "onParticipantsClose", "onParticipantsFilterChange", "participantsCounter", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "parameters", "position", "backgroundColor"] }, { kind: "component", type: RecordingModal, selector: "app-recording-modal", inputs: ["isRecordingModalVisible", "onClose", "backgroundColor", "position", "confirmRecording", "startRecording", "parameters"] }, { kind: "component", type: MainAspectComponent, selector: "app-main-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "updateIsWideScreen", "updateIsMediumScreen", "updateIsSmallScreen"] }, { kind: "component", type: MainContainerComponent, selector: "app-main-container-component", inputs: ["backgroundColor", "containerWidthFraction", "containerHeightFraction", "marginLeft", "marginRight", "marginTop", "marginBottom", "padding"] }, { kind: "component", type: MainGridComponent, selector: "app-main-grid-component", inputs: ["backgroundColor", "mainSize", "height", "width", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: MainScreenComponent, selector: "app-main-screen-component", inputs: ["mainSize", "doStack", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "showControls", "updateComponentSizes"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediasfuBroadcast, decorators: [{
            type: Component,
            args: [{ selector: 'app-mediasfu-broadcast', standalone: true, imports: [
                        RouterOutlet,
                        CommonModule,
                        AlertComponent,
                        AudioGrid,
                        ControlButtonsComponentTouch,
                        FlexibleVideo,
                        LoadingModal,
                        ConfirmExitModal,
                        MessagesModal,
                        ConfirmHereModal,
                        ShareEventModal,
                        WelcomePage,
                        ParticipantsModal,
                        RecordingModal,
                        MainAspectComponent,
                        MainContainerComponent,
                        MainGridComponent,
                        MainScreenComponent,
                        MessageWidget,
                        MenuRecordWidget,
                        RecordTimerWidget,
                        MenuParticipantsWidget,
                    ], template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <!-- Conditional Rendering: PrejoinPage or Main Content -->
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <!-- Main Content -->
      <ng-template #mainContent>
        <app-main-container-component>
          <!-- Main Aspect Component -->
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <!-- Main Screen Component -->
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <!-- Main Grid Component -->
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                >
                </app-flexible-video>

                <!-- Control Buttons for Broadcast -->
                <app-control-buttons-component-touch
                  [buttons]="controlBroadcastButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'broadcast'"
                ></app-control-buttons-component-touch>

                <!-- Recording Buttons -->
                <app-control-buttons-component-touch
                  [buttons]="recordButton"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    !showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>

                <app-control-buttons-component-touch
                  [buttons]="recordButtons"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>

                <!-- AudioGrid -->
                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>
              </app-main-grid-component>

              <!-- Other Grid Component is not included in MediasfuBroadcast -->
            </app-main-screen-component>
          </app-main-aspect-component>
        </app-main-container-component>
      </ng-template>

      <!-- Modals to include -->
      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
          updateParticipants: updateParticipants,
          updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
          updateDirectMessageDetails: updateDirectMessageDetails,
          updateStartDirectMessage: updateStartDirectMessage,
          updateIsMessagesModalVisible: updateIsMessagesModalVisible,
          showAlert: showAlert,
          filteredParticipants: filteredParticipants.value,
          participants: filteredParticipants.value,
          roomName: roomName.value,
          islevel: islevel.value,
          member: member.value,
          coHostResponsibility: coHostResponsibility.value,
          coHost: coHost.value,
          eventType: eventType.value,
          startDirectMessage: startDirectMessage.value,
          directMessageDetails: directMessageDetails.value,
          socket: socket.value,
          getUpdatedAllParams: getUpdatedAllParams,
        }"
      ></app-participants-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
      ></app-share-event-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </div>
  `, providers: [CookieService] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: UpdateMiniCardsGrid }, { type: MixStreams }, { type: DispStreams }, { type: StopShareScreen }, { type: CheckScreenShare }, { type: StartShareScreen }, { type: RequestScreenShare }, { type: ReorderStreams }, { type: PrepopulateUserMedia }, { type: GetVideos }, { type: RePort }, { type: Trigger }, { type: ConsumerResume }, { type: ConnectSendTransport }, { type: ConnectSendTransportAudio }, { type: ConnectSendTransportVideo }, { type: ConnectSendTransportScreen }, { type: ProcessConsumerTransports }, { type: ResumePauseStreams }, { type: Readjust }, { type: CheckGrid }, { type: GetEstimate }, { type: CalculateRowsAndColumns }, { type: AddVideosGrid }, { type: OnScreenChanges }, { type: ChangeVids }, { type: CompareActiveNames }, { type: CompareScreenStates }, { type: CreateSendTransport }, { type: ResumeSendTransportAudio }, { type: ReceiveAllPipedTransports }, { type: DisconnectSendTransportVideo }, { type: DisconnectSendTransportAudio }, { type: DisconnectSendTransportScreen }, { type: GetPipedProducersAlt }, { type: SignalNewConsumerTransport }, { type: ConnectRecvTransport }, { type: ReUpdateInter }, { type: UpdateParticipantAudioDecibels }, { type: CloseAndResize }, { type: AutoAdjust }, { type: SwitchUserVideoAlt }, { type: SwitchUserVideo }, { type: SwitchUserAudio }, { type: GetDomains }, { type: FormatNumber }, { type: ConnectIps }, { type: CreateDeviceClient }, { type: CaptureCanvasStream }, { type: ResumePauseAudioStreams }, { type: ProcessConsumerTransportsAudio }, { type: LaunchRecording }, { type: StartRecording }, { type: ConfirmRecording }, { type: LaunchParticipants }, { type: LaunchMessages }, { type: LaunchConfirmExit }, { type: StartMeetingProgressTimer }, { type: UpdateRecording }, { type: StopRecording }, { type: PersonJoined }, { type: RoomRecordParams }, { type: BanParticipant }, { type: ProducerMediaPaused }, { type: ProducerMediaResumed }, { type: ProducerMediaClosed }, { type: MeetingEnded }, { type: DisconnectUserSelf }, { type: ReceiveMessage }, { type: MeetingTimeRemaining }, { type: MeetingStillThere }, { type: StartRecords }, { type: ReInitiateRecording }, { type: RecordingNotice }, { type: TimeLeftRecording }, { type: StoppedRecording }, { type: AllMembers }, { type: AllMembersRest }, { type: Disconnect }, { type: SocketManager }, { type: JoinRoomClient }, { type: UpdateRoomParametersClient }, { type: ClickVideo }, { type: ClickAudio }, { type: ClickScreenShare }, { type: SwitchVideoAlt }, { type: StreamSuccessVideo }, { type: StreamSuccessAudio }, { type: StreamSuccessScreen }, { type: StreamSuccessAudioSwitch }, { type: CheckPermission }, { type: UpdateConsumingDomains }, { type: ReceiveRoomMessages }], propDecorators: { PrejoinPage: [{
                type: Input
            }], credentials: [{
                type: Input
            }], useLocalUIMode: [{
                type: Input
            }], seedData: [{
                type: Input
            }], useSeed: [{
                type: Input
            }], imgSrc: [{
                type: Input
            }], handleResize: [{
                type: HostListener,
                args: ['window:resize']
            }, {
                type: HostListener,
                args: ['window:orientationchange']
            }] } });

class MediasfuWebinar {
    cdr;
    injector;
    updateMiniCardsGrid;
    mixStreams;
    dispStreams;
    stopShareScreen;
    checkScreenShare;
    startShareScreen;
    requestScreenShare;
    reorderStreams;
    prepopulateUserMedia;
    getVideos;
    rePort;
    trigger;
    consumerResume;
    connectSendTransport;
    connectSendTransportAudio;
    connectSendTransportVideo;
    connectSendTransportScreen;
    processConsumerTransports;
    resumePauseStreams;
    readjust;
    checkGrid;
    getEstimate;
    calculateRowsAndColumns;
    addVideosGrid;
    onScreenChanges;
    changeVids;
    compareActiveNames;
    compareScreenStates;
    createSendTransport;
    resumeSendTransportAudio;
    receiveAllPipedTransports;
    disconnectSendTransportVideo;
    disconnectSendTransportAudio;
    disconnectSendTransportScreen;
    getPipedProducersAlt;
    signalNewConsumerTransport;
    connectRecvTransport;
    reUpdateInter;
    updateParticipantAudioDecibels;
    closeAndResize;
    autoAdjust;
    switchUserVideoAlt;
    switchUserVideo;
    switchUserAudio;
    getDomains;
    formatNumber;
    connectIps;
    createDeviceClient;
    handleCreatePoll;
    handleEndPoll;
    handleVotePoll;
    captureCanvasStream;
    resumePauseAudioStreams;
    processConsumerTransportsAudio;
    launchMenuModal;
    launchRecording;
    startRecording;
    confirmRecording;
    launchWaiting;
    launchCoHost;
    launchMediaSettings;
    launchDisplaySettings;
    launchSettings;
    launchRequests;
    launchParticipants;
    launchMessages;
    launchConfirmExit;
    launchPoll;
    launchBreakoutRooms;
    launchConfigureWhiteboard;
    startMeetingProgressTimer;
    updateRecording;
    stopRecording;
    userWaiting;
    personJoined;
    allWaitingRoomMembers;
    roomRecordParams;
    banParticipant;
    updatedCoHost;
    participantRequested;
    screenProducerId;
    updateMediaSettings;
    producerMediaPaused;
    producerMediaResumed;
    producerMediaClosed;
    controlMediaHost;
    meetingEnded;
    disconnectUserSelf;
    receiveMessage;
    meetingTimeRemaining;
    meetingStillThere;
    startRecords;
    reInitiateRecording;
    recordingNotice;
    timeLeftRecording;
    stoppedRecording;
    hostRequestResponse;
    allMembers;
    allMembersRest;
    disconnect;
    pollUpdated;
    breakoutRoomUpdated;
    socketManager;
    joinRoomClient;
    updateRoomParametersClient;
    clickVideo;
    clickAudio;
    clickScreenShare;
    streamSuccessVideo;
    streamSuccessAudio;
    streamSuccessScreen;
    streamSuccessAudioSwitch;
    checkPermission;
    updateConsumingDomains;
    receiveRoomMessages;
    PrejoinPage = WelcomePage;
    credentials = { apiUserName: '', apiKey: '' };
    useLocalUIMode = false;
    seedData;
    useSeed = false;
    imgSrc = 'https://mediasfu.com/images/logo192.png';
    title = 'MediaSFU-Webinar';
    mainHeightWidthSubscription;
    validatedSubscription;
    islevelSubscription;
    coHostSubscription;
    buttonSubscriptions = [];
    ScreenboardSubscription;
    recordingSubscription;
    constructor(cdr, injector, updateMiniCardsGrid, mixStreams, dispStreams, stopShareScreen, checkScreenShare, startShareScreen, requestScreenShare, reorderStreams, prepopulateUserMedia, getVideos, rePort, trigger, consumerResume, connectSendTransport, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, processConsumerTransports, resumePauseStreams, readjust, checkGrid, getEstimate, calculateRowsAndColumns, addVideosGrid, onScreenChanges, changeVids, compareActiveNames, compareScreenStates, createSendTransport, resumeSendTransportAudio, receiveAllPipedTransports, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, getPipedProducersAlt, signalNewConsumerTransport, connectRecvTransport, reUpdateInter, updateParticipantAudioDecibels, closeAndResize, autoAdjust, switchUserVideoAlt, switchUserVideo, switchUserAudio, getDomains, formatNumber, connectIps, createDeviceClient, handleCreatePoll, handleEndPoll, handleVotePoll, captureCanvasStream, resumePauseAudioStreams, processConsumerTransportsAudio, launchMenuModal, launchRecording, startRecording, confirmRecording, launchWaiting, launchCoHost, launchMediaSettings, launchDisplaySettings, launchSettings, launchRequests, launchParticipants, launchMessages, launchConfirmExit, launchPoll, launchBreakoutRooms, launchConfigureWhiteboard, startMeetingProgressTimer, updateRecording, stopRecording, userWaiting, personJoined, allWaitingRoomMembers, roomRecordParams, banParticipant, updatedCoHost, participantRequested, screenProducerId, updateMediaSettings, producerMediaPaused, producerMediaResumed, producerMediaClosed, controlMediaHost, meetingEnded, disconnectUserSelf, receiveMessage, meetingTimeRemaining, meetingStillThere, startRecords, reInitiateRecording, recordingNotice, timeLeftRecording, stoppedRecording, hostRequestResponse, allMembers, allMembersRest, disconnect, pollUpdated, breakoutRoomUpdated, socketManager, joinRoomClient, updateRoomParametersClient, clickVideo, clickAudio, clickScreenShare, streamSuccessVideo, streamSuccessAudio, streamSuccessScreen, streamSuccessAudioSwitch, checkPermission, updateConsumingDomains, receiveRoomMessages) {
        this.cdr = cdr;
        this.injector = injector;
        this.updateMiniCardsGrid = updateMiniCardsGrid;
        this.mixStreams = mixStreams;
        this.dispStreams = dispStreams;
        this.stopShareScreen = stopShareScreen;
        this.checkScreenShare = checkScreenShare;
        this.startShareScreen = startShareScreen;
        this.requestScreenShare = requestScreenShare;
        this.reorderStreams = reorderStreams;
        this.prepopulateUserMedia = prepopulateUserMedia;
        this.getVideos = getVideos;
        this.rePort = rePort;
        this.trigger = trigger;
        this.consumerResume = consumerResume;
        this.connectSendTransport = connectSendTransport;
        this.connectSendTransportAudio = connectSendTransportAudio;
        this.connectSendTransportVideo = connectSendTransportVideo;
        this.connectSendTransportScreen = connectSendTransportScreen;
        this.processConsumerTransports = processConsumerTransports;
        this.resumePauseStreams = resumePauseStreams;
        this.readjust = readjust;
        this.checkGrid = checkGrid;
        this.getEstimate = getEstimate;
        this.calculateRowsAndColumns = calculateRowsAndColumns;
        this.addVideosGrid = addVideosGrid;
        this.onScreenChanges = onScreenChanges;
        this.changeVids = changeVids;
        this.compareActiveNames = compareActiveNames;
        this.compareScreenStates = compareScreenStates;
        this.createSendTransport = createSendTransport;
        this.resumeSendTransportAudio = resumeSendTransportAudio;
        this.receiveAllPipedTransports = receiveAllPipedTransports;
        this.disconnectSendTransportVideo = disconnectSendTransportVideo;
        this.disconnectSendTransportAudio = disconnectSendTransportAudio;
        this.disconnectSendTransportScreen = disconnectSendTransportScreen;
        this.getPipedProducersAlt = getPipedProducersAlt;
        this.signalNewConsumerTransport = signalNewConsumerTransport;
        this.connectRecvTransport = connectRecvTransport;
        this.reUpdateInter = reUpdateInter;
        this.updateParticipantAudioDecibels = updateParticipantAudioDecibels;
        this.closeAndResize = closeAndResize;
        this.autoAdjust = autoAdjust;
        this.switchUserVideoAlt = switchUserVideoAlt;
        this.switchUserVideo = switchUserVideo;
        this.switchUserAudio = switchUserAudio;
        this.getDomains = getDomains;
        this.formatNumber = formatNumber;
        this.connectIps = connectIps;
        this.createDeviceClient = createDeviceClient;
        this.handleCreatePoll = handleCreatePoll;
        this.handleEndPoll = handleEndPoll;
        this.handleVotePoll = handleVotePoll;
        this.captureCanvasStream = captureCanvasStream;
        this.resumePauseAudioStreams = resumePauseAudioStreams;
        this.processConsumerTransportsAudio = processConsumerTransportsAudio;
        this.launchMenuModal = launchMenuModal;
        this.launchRecording = launchRecording;
        this.startRecording = startRecording;
        this.confirmRecording = confirmRecording;
        this.launchWaiting = launchWaiting;
        this.launchCoHost = launchCoHost;
        this.launchMediaSettings = launchMediaSettings;
        this.launchDisplaySettings = launchDisplaySettings;
        this.launchSettings = launchSettings;
        this.launchRequests = launchRequests;
        this.launchParticipants = launchParticipants;
        this.launchMessages = launchMessages;
        this.launchConfirmExit = launchConfirmExit;
        this.launchPoll = launchPoll;
        this.launchBreakoutRooms = launchBreakoutRooms;
        this.launchConfigureWhiteboard = launchConfigureWhiteboard;
        this.startMeetingProgressTimer = startMeetingProgressTimer;
        this.updateRecording = updateRecording;
        this.stopRecording = stopRecording;
        this.userWaiting = userWaiting;
        this.personJoined = personJoined;
        this.allWaitingRoomMembers = allWaitingRoomMembers;
        this.roomRecordParams = roomRecordParams;
        this.banParticipant = banParticipant;
        this.updatedCoHost = updatedCoHost;
        this.participantRequested = participantRequested;
        this.screenProducerId = screenProducerId;
        this.updateMediaSettings = updateMediaSettings;
        this.producerMediaPaused = producerMediaPaused;
        this.producerMediaResumed = producerMediaResumed;
        this.producerMediaClosed = producerMediaClosed;
        this.controlMediaHost = controlMediaHost;
        this.meetingEnded = meetingEnded;
        this.disconnectUserSelf = disconnectUserSelf;
        this.receiveMessage = receiveMessage;
        this.meetingTimeRemaining = meetingTimeRemaining;
        this.meetingStillThere = meetingStillThere;
        this.startRecords = startRecords;
        this.reInitiateRecording = reInitiateRecording;
        this.recordingNotice = recordingNotice;
        this.timeLeftRecording = timeLeftRecording;
        this.stoppedRecording = stoppedRecording;
        this.hostRequestResponse = hostRequestResponse;
        this.allMembers = allMembers;
        this.allMembersRest = allMembersRest;
        this.disconnect = disconnect;
        this.pollUpdated = pollUpdated;
        this.breakoutRoomUpdated = breakoutRoomUpdated;
        this.socketManager = socketManager;
        this.joinRoomClient = joinRoomClient;
        this.updateRoomParametersClient = updateRoomParametersClient;
        this.clickVideo = clickVideo;
        this.clickAudio = clickAudio;
        this.clickScreenShare = clickScreenShare;
        this.streamSuccessVideo = streamSuccessVideo;
        this.streamSuccessAudio = streamSuccessAudio;
        this.streamSuccessScreen = streamSuccessScreen;
        this.streamSuccessAudioSwitch = streamSuccessAudioSwitch;
        this.checkPermission = checkPermission;
        this.updateConsumingDomains = updateConsumingDomains;
        this.receiveRoomMessages = receiveRoomMessages;
    }
    createInjector(inputs) {
        const inj = Injector.create({
            providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
            parent: this.injector,
        });
        return inj;
    }
    // Initial values
    mediaSFUFunctions = () => {
        return {
            updateMiniCardsGrid: this.updateMiniCardsGrid?.updateMiniCardsGrid ||
                (() => {
                    console.log('none');
                }),
            mixStreams: this.mixStreams?.mixStreams ||
                (() => {
                    console.log('none');
                }),
            dispStreams: this.dispStreams?.dispStreams ||
                (() => {
                    console.log('none');
                }),
            stopShareScreen: this.stopShareScreen?.stopShareScreen ||
                (() => {
                    console.log('none');
                }),
            checkScreenShare: this.checkScreenShare?.checkScreenShare ||
                (() => {
                    console.log('none');
                }),
            startShareScreen: this.startShareScreen?.startShareScreen ||
                (() => {
                    console.log('none');
                }),
            requestScreenShare: this.requestScreenShare?.requestScreenShare ||
                (() => {
                    console.log('none');
                }),
            reorderStreams: this.reorderStreams?.reorderStreams ||
                (() => {
                    console.log('none');
                }),
            prepopulateUserMedia: this.prepopulateUserMedia?.prepopulateUserMedia ||
                (() => {
                    console.log('none');
                }),
            getVideos: this.getVideos?.getVideos ||
                (() => {
                    console.log('none');
                }),
            rePort: this.rePort?.rePort ||
                (() => {
                    console.log('none');
                }),
            trigger: this.trigger?.trigger ||
                (() => {
                    console.log('none');
                }),
            consumerResume: this.consumerResume?.consumerResume ||
                (() => {
                    console.log('none');
                }),
            connectSendTransport: this.connectSendTransport?.connectSendTransport ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportAudio: this.connectSendTransportAudio?.connectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportVideo: this.connectSendTransportVideo?.connectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportScreen: this.connectSendTransportScreen?.connectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransports: this.processConsumerTransports?.processConsumerTransports ||
                (() => {
                    console.log('none');
                }),
            resumePauseStreams: this.resumePauseStreams?.resumePauseStreams ||
                (() => {
                    console.log('none');
                }),
            readjust: this.readjust?.readjust ||
                (() => {
                    console.log('none');
                }),
            checkGrid: this.checkGrid?.checkGrid ||
                (() => {
                    console.log('none');
                }),
            getEstimate: this.getEstimate?.getEstimate ||
                (() => {
                    console.log('none');
                }),
            calculateRowsAndColumns: this.calculateRowsAndColumns?.calculateRowsAndColumns ||
                (() => {
                    console.log('none');
                }),
            addVideosGrid: this.addVideosGrid?.addVideosGrid ||
                (() => {
                    console.log('none');
                }),
            onScreenChanges: this.onScreenChanges?.onScreenChanges ||
                (() => {
                    console.log('none');
                }),
            sleep: sleep ||
                (() => {
                    console.log('none');
                }),
            changeVids: this.changeVids?.changeVids ||
                (() => {
                    console.log('none');
                }),
            compareActiveNames: this.compareActiveNames?.compareActiveNames ||
                (() => {
                    console.log('none');
                }),
            compareScreenStates: this.compareScreenStates?.compareScreenStates ||
                (() => {
                    console.log('none');
                }),
            createSendTransport: this.createSendTransport?.createSendTransport ||
                (() => {
                    console.log('none');
                }),
            resumeSendTransportAudio: this.resumeSendTransportAudio?.resumeSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            receiveAllPipedTransports: this.receiveAllPipedTransports?.receiveAllPipedTransports ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportVideo: this.disconnectSendTransportVideo?.disconnectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportAudio: this.disconnectSendTransportAudio?.disconnectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportScreen: this.disconnectSendTransportScreen?.disconnectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            getPipedProducersAlt: this.getPipedProducersAlt?.getPipedProducersAlt ||
                (() => {
                    console.log('none');
                }),
            signalNewConsumerTransport: this.signalNewConsumerTransport?.signalNewConsumerTransport ||
                (() => {
                    console.log('none');
                }),
            connectRecvTransport: this.connectRecvTransport?.connectRecvTransport ||
                (() => {
                    console.log('none');
                }),
            reUpdateInter: this.reUpdateInter?.reUpdateInter ||
                (() => {
                    console.log('none');
                }),
            updateParticipantAudioDecibels: this.updateParticipantAudioDecibels?.updateParticipantAudioDecibels ||
                (() => {
                    console.log('none');
                }),
            closeAndResize: this.closeAndResize?.closeAndResize ||
                (() => {
                    console.log('none');
                }),
            autoAdjust: this.autoAdjust?.autoAdjust ||
                (() => {
                    console.log('none');
                }),
            switchUserVideoAlt: this.switchUserVideoAlt?.switchUserVideoAlt ||
                (() => {
                    console.log('none');
                }),
            switchUserVideo: this.switchUserVideo?.switchUserVideo ||
                (() => {
                    console.log('none');
                }),
            switchUserAudio: this.switchUserAudio?.switchUserAudio ||
                (() => {
                    console.log('none');
                }),
            getDomains: this.getDomains?.getDomains ||
                (() => {
                    console.log('none');
                }),
            formatNumber: this.formatNumber?.formatNumber ||
                (() => {
                    console.log('none');
                }),
            connectIps: this.connectIps?.connectIps ||
                (() => {
                    console.log('none');
                }),
            createDeviceClient: this.createDeviceClient?.createDeviceClient ||
                (() => {
                    console.log('none');
                }),
            handleCreatePoll: this.handleCreatePoll?.handleCreatePoll ||
                (() => {
                    console.log('none');
                }),
            handleEndPoll: this.handleEndPoll?.handleEndPoll ||
                (() => {
                    console.log('none');
                }),
            handleVotePoll: this.handleVotePoll?.handleVotePoll ||
                (() => {
                    console.log('none');
                }),
            captureCanvasStream: this.captureCanvasStream?.captureCanvasStream ||
                (() => {
                    console.log('none');
                }),
            resumePauseAudioStreams: this.resumePauseAudioStreams?.resumePauseAudioStreams ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransportsAudio: this.processConsumerTransportsAudio?.processConsumerTransportsAudio ||
                (() => {
                    console.log('none');
                }),
            checkPermission: this.checkPermission?.checkPermission ||
                (() => {
                    console.log('none');
                }),
            streamSuccessVideo: this.streamSuccessVideo?.streamSuccessVideo ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudio: this.streamSuccessAudio?.streamSuccessAudio ||
                (() => {
                    console.log('none');
                }),
            streamSuccessScreen: this.streamSuccessScreen?.streamSuccessScreen ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudioSwitch: this.streamSuccessAudioSwitch?.streamSuccessAudioSwitch ||
                (() => {
                    console.log('none');
                }),
            clickVideo: this.clickVideo?.clickVideo ||
                (() => {
                    console.log('none');
                }),
            clickAudio: this.clickAudio?.clickAudio ||
                (() => {
                    console.log('none');
                }),
            clickScreenShare: this.clickScreenShare?.clickScreenShare ||
                (() => {
                    console.log('none');
                }),
            requestPermissionCamera: this.requestPermissionCamera ||
                (() => {
                    console.log('none');
                }),
            requestPermissionAudio: this.requestPermissionAudio ||
                (() => {
                    console.log('none');
                }),
        };
    };
    validated = new BehaviorSubject(false);
    localUIMode = new BehaviorSubject(false);
    socket = new BehaviorSubject({});
    roomData = new BehaviorSubject(null);
    device = new BehaviorSubject(null);
    apiKey = new BehaviorSubject('021193742c935c4434d25d7592362575fcb6d6590b6c38334a2f3e06c83af758');
    apiUserName = new BehaviorSubject('abcdefgh');
    apiToken = new BehaviorSubject('');
    link = new BehaviorSubject('');
    roomName = new BehaviorSubject('');
    member = new BehaviorSubject('');
    adminPasscode = new BehaviorSubject('');
    islevel = new BehaviorSubject('1');
    coHost = new BehaviorSubject('No coHost');
    coHostResponsibility = new BehaviorSubject([
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ]);
    youAreCoHost = new BehaviorSubject(false);
    youAreHost = new BehaviorSubject(false);
    confirmedToRecord = new BehaviorSubject(false);
    meetingDisplayType = new BehaviorSubject('media');
    meetingVideoOptimized = new BehaviorSubject(false);
    eventType = new BehaviorSubject('webinar');
    participants = new BehaviorSubject([]);
    filteredParticipants = new BehaviorSubject([]);
    participantsCounter = new BehaviorSubject(0);
    participantsFilter = new BehaviorSubject('');
    consume_sockets = new BehaviorSubject([]);
    rtpCapabilities = new BehaviorSubject(null);
    roomRecvIPs = new BehaviorSubject([]);
    meetingRoomParams = new BehaviorSubject(null);
    itemPageLimit = new BehaviorSubject(4);
    audioOnlyRoom = new BehaviorSubject(false);
    addForBasic = new BehaviorSubject(false);
    screenPageLimit = new BehaviorSubject(4);
    shareScreenStarted = new BehaviorSubject(false);
    shared = new BehaviorSubject(false);
    targetOrientation = new BehaviorSubject('landscape');
    targetResolution = new BehaviorSubject('sd');
    targetResolutionHost = new BehaviorSubject('sd');
    vidCons = new BehaviorSubject({ width: 640, height: 360 });
    frameRate = new BehaviorSubject(10);
    hParams = new BehaviorSubject({});
    vParams = new BehaviorSubject({});
    screenParams = new BehaviorSubject({});
    aParams = new BehaviorSubject({});
    recordingAudioPausesLimit = new BehaviorSubject(0);
    recordingAudioPausesCount = new BehaviorSubject(0);
    recordingAudioSupport = new BehaviorSubject(false);
    recordingAudioPeopleLimit = new BehaviorSubject(0);
    recordingAudioParticipantsTimeLimit = new BehaviorSubject(0);
    recordingVideoPausesCount = new BehaviorSubject(0);
    recordingVideoPausesLimit = new BehaviorSubject(0);
    recordingVideoSupport = new BehaviorSubject(false);
    recordingVideoPeopleLimit = new BehaviorSubject(0);
    recordingVideoParticipantsTimeLimit = new BehaviorSubject(0);
    recordingAllParticipantsSupport = new BehaviorSubject(false);
    recordingVideoParticipantsSupport = new BehaviorSubject(false);
    recordingAllParticipantsFullRoomSupport = new BehaviorSubject(false);
    recordingVideoParticipantsFullRoomSupport = new BehaviorSubject(false);
    recordingPreferredOrientation = new BehaviorSubject('landscape');
    recordingSupportForOtherOrientation = new BehaviorSubject(false);
    recordingMultiFormatsSupport = new BehaviorSubject(false);
    userRecordingParams = new BehaviorSubject({
        mainSpecs: {
            mediaOptions: 'video', // 'audio', 'video'
            audioOptions: 'all', // 'all', 'onScreen', 'host'
            videoOptions: 'all', // 'all', 'mainScreen'
            videoType: 'fullDisplay', // 'all', 'bestDisplay', 'fullDisplay'
            videoOptimized: false, // true, false
            recordingDisplayType: 'media', // 'media', 'video', 'all'
            addHLS: false, // true, false
        },
        dispSpecs: {
            nameTags: true, // true, false
            backgroundColor: '#000000', // '#000000', '#ffffff'
            nameTagsColor: '#ffffff', // '#000000', '#ffffff'
            orientationVideo: 'portrait', // 'landscape', 'portrait', 'all'
        },
    });
    canRecord = new BehaviorSubject(false);
    startReport = new BehaviorSubject(false);
    endReport = new BehaviorSubject(false);
    recordTimerInterval = new BehaviorSubject(null);
    recordStartTime = new BehaviorSubject(0);
    recordElapsedTime = new BehaviorSubject(0);
    isTimerRunning = new BehaviorSubject(false);
    canPauseResume = new BehaviorSubject(false);
    recordChangeSeconds = new BehaviorSubject(15000);
    pauseLimit = new BehaviorSubject(0);
    pauseRecordCount = new BehaviorSubject(0);
    canLaunchRecord = new BehaviorSubject(true);
    stopLaunchRecord = new BehaviorSubject(false);
    participantsAll = new BehaviorSubject([]);
    firstAll = new BehaviorSubject(false);
    updateMainWindow = new BehaviorSubject(false);
    first_round = new BehaviorSubject(false);
    landScaped = new BehaviorSubject(false);
    lock_screen = new BehaviorSubject(false);
    screenId = new BehaviorSubject('');
    allVideoStreams = new BehaviorSubject([]);
    newLimitedStreams = new BehaviorSubject([]);
    newLimitedStreamsIDs = new BehaviorSubject([]);
    activeSounds = new BehaviorSubject([]);
    screenShareIDStream = new BehaviorSubject('');
    screenShareNameStream = new BehaviorSubject('');
    adminIDStream = new BehaviorSubject('');
    adminNameStream = new BehaviorSubject('');
    youYouStream = new BehaviorSubject([]);
    youYouStreamIDs = new BehaviorSubject([]);
    localStream = new BehaviorSubject(null);
    recordStarted = new BehaviorSubject(false);
    recordResumed = new BehaviorSubject(false);
    recordPaused = new BehaviorSubject(false);
    recordStopped = new BehaviorSubject(false);
    adminRestrictSetting = new BehaviorSubject(false);
    videoRequestState = new BehaviorSubject(null);
    videoRequestTime = new BehaviorSubject(0);
    videoAction = new BehaviorSubject(false);
    localStreamVideo = new BehaviorSubject(null);
    userDefaultVideoInputDevice = new BehaviorSubject('');
    currentFacingMode = new BehaviorSubject('user');
    prevFacingMode = new BehaviorSubject('user');
    defVideoID = new BehaviorSubject('');
    allowed = new BehaviorSubject(false);
    dispActiveNames = new BehaviorSubject([]);
    p_dispActiveNames = new BehaviorSubject([]);
    activeNames = new BehaviorSubject([]);
    prevActiveNames = new BehaviorSubject([]);
    p_activeNames = new BehaviorSubject([]);
    membersReceived = new BehaviorSubject(false);
    deferScreenReceived = new BehaviorSubject(false);
    hostFirstSwitch = new BehaviorSubject(false);
    micAction = new BehaviorSubject(false);
    screenAction = new BehaviorSubject(false);
    chatAction = new BehaviorSubject(false);
    audioRequestState = new BehaviorSubject(null);
    screenRequestState = new BehaviorSubject(null);
    chatRequestState = new BehaviorSubject(null);
    audioRequestTime = new BehaviorSubject(0);
    screenRequestTime = new BehaviorSubject(0);
    chatRequestTime = new BehaviorSubject(0);
    updateRequestIntervalSeconds = new BehaviorSubject(240);
    oldSoundIds = new BehaviorSubject([]);
    hostLabel = new BehaviorSubject('Host');
    mainScreenFilled = new BehaviorSubject(false);
    localStreamScreen = new BehaviorSubject(null);
    screenAlreadyOn = new BehaviorSubject(false);
    chatAlreadyOn = new BehaviorSubject(false);
    redirectURL = new BehaviorSubject('');
    oldAllStreams = new BehaviorSubject([]);
    adminVidID = new BehaviorSubject('');
    streamNames = new BehaviorSubject([]);
    non_alVideoStreams = new BehaviorSubject([]);
    sortAudioLoudness = new BehaviorSubject(false);
    audioDecibels = new BehaviorSubject([]);
    mixed_alVideoStreams = new BehaviorSubject([]);
    non_alVideoStreams_muted = new BehaviorSubject([]);
    paginatedStreams = new BehaviorSubject([]);
    localStreamAudio = new BehaviorSubject(null);
    defAudioID = new BehaviorSubject('');
    userDefaultAudioInputDevice = new BehaviorSubject('');
    userDefaultAudioOutputDevice = new BehaviorSubject('');
    prevAudioInputDevice = new BehaviorSubject('');
    prevVideoInputDevice = new BehaviorSubject('');
    audioPaused = new BehaviorSubject(false);
    mainScreenPerson = new BehaviorSubject('');
    adminOnMainScreen = new BehaviorSubject(false);
    screenStates = new BehaviorSubject([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    prevScreenStates = new BehaviorSubject([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    updateDateState = new BehaviorSubject(null);
    lastUpdate = new BehaviorSubject(null);
    nForReadjustRecord = new BehaviorSubject(0);
    fixedPageLimit = new BehaviorSubject(4);
    removeAltGrid = new BehaviorSubject(false);
    nForReadjust = new BehaviorSubject(0);
    reorderInterval = new BehaviorSubject(30000);
    fastReorderInterval = new BehaviorSubject(10000);
    lastReorderTime = new BehaviorSubject(0);
    audStreamNames = new BehaviorSubject([]);
    currentUserPage = new BehaviorSubject(0);
    mainHeightWidth = new BehaviorSubject(this.eventType.value == 'webinar' ? 67 : this.eventType.value == 'broadcast' ? 100 : 0);
    prevMainHeightWidth = new BehaviorSubject(this.mainHeightWidth.value);
    prevDoPaginate = new BehaviorSubject(false);
    doPaginate = new BehaviorSubject(false);
    shareEnded = new BehaviorSubject(false);
    lStreams = new BehaviorSubject([]);
    chatRefStreams = new BehaviorSubject([]);
    controlHeight = new BehaviorSubject(this.eventType.value === 'webinar' || this.eventType.value === 'conference' ? 0 : 0.06);
    isWideScreen = new BehaviorSubject(false);
    isMediumScreen = new BehaviorSubject(false);
    isSmallScreen = new BehaviorSubject(false);
    addGrid = new BehaviorSubject(false);
    addAltGrid = new BehaviorSubject(false);
    gridRows = new BehaviorSubject(0);
    gridCols = new BehaviorSubject(0);
    altGridRows = new BehaviorSubject(0);
    altGridCols = new BehaviorSubject(0);
    numberPages = new BehaviorSubject(0);
    currentStreams = new BehaviorSubject([]);
    showMiniView = new BehaviorSubject(false);
    nStream = new BehaviorSubject(null);
    defer_receive = new BehaviorSubject(false);
    allAudioStreams = new BehaviorSubject([]);
    remoteScreenStream = new BehaviorSubject([]);
    screenProducer = new BehaviorSubject(null);
    gotAllVids = new BehaviorSubject(false);
    paginationHeightWidth = new BehaviorSubject(40);
    paginationDirection = new BehaviorSubject('horizontal');
    gridSizes = new BehaviorSubject({
        gridWidth: 0,
        gridHeight: 0,
        altGridWidth: 0,
        altGridHeight: 0,
    });
    screenForceFullDisplay = new BehaviorSubject(false);
    mainGridStream = new BehaviorSubject([]);
    otherGridStreams = new BehaviorSubject([]);
    audioOnlyStreams = new BehaviorSubject([]);
    videoInputs = new BehaviorSubject([]);
    audioInputs = new BehaviorSubject([]);
    meetingProgressTime = new BehaviorSubject('00:00:00');
    meetingElapsedTime = new BehaviorSubject(0);
    ref_participants = new BehaviorSubject([]);
    updateValidated = (value) => {
        this.validated.next(value);
    };
    updateSocket = (value) => {
        this.socket.next(value);
    };
    updateDevice = (value) => {
        this.device.next(value);
    };
    updateRoomData = (value) => {
        this.roomData.next(value);
    };
    updateApiKey = (value) => {
        this.apiKey.next(value);
    };
    updateApiUserName = (value) => {
        this.apiUserName.next(value);
    };
    updateApiToken = (value) => {
        this.apiToken.next(value);
    };
    updateLink = (value) => {
        this.link.next(value);
    };
    updateRoomName = (value) => {
        this.roomName.next(value);
    };
    updateMember = (value) => {
        this.member.next(value);
    };
    updateAdminPasscode = (value) => {
        this.adminPasscode.next(value);
    };
    updateIslevel = (value) => {
        this.islevel.next(value);
    };
    updateCoHost = (value) => {
        this.coHost.next(value);
    };
    updateCoHostResponsibility = (value) => {
        this.coHostResponsibility.next(value);
    };
    updateYouAreCoHost = (value) => {
        this.youAreCoHost.next(value);
    };
    updateYouAreHost = (value) => {
        this.youAreHost.next(value);
    };
    updateConfirmedToRecord = (value) => {
        this.confirmedToRecord.next(value);
    };
    updateMeetingDisplayType = (value) => {
        this.meetingDisplayType.next(value);
    };
    updateMeetingVideoOptimized = (value) => {
        this.meetingVideoOptimized.next(value);
    };
    updateEventType = (value) => {
        this.eventType.next(value);
        if (value != 'none') {
            try {
                setTimeout(() => {
                    this.handleResize();
                }, 2000);
            }
            catch {
                /* handle error */
            }
        }
    };
    updateParticipants = (value) => {
        this.participants.next(value);
        this.participantsCounter.next(value.length);
        this.filteredParticipants.next(this.participants.value);
    };
    updateFilteredParticipants = (value) => {
        this.filteredParticipants.next(value);
    };
    updateParticipantsCounter = (value) => {
        this.participantsCounter.next(value);
    };
    updateParticipantsFilter = (value) => {
        this.participantsFilter.next(value);
    };
    updateConsume_sockets = (value) => {
        this.consume_sockets.next(value);
    };
    updateRtpCapabilities = (value) => {
        this.rtpCapabilities.next(value);
    };
    updateRoomRecvIPs = (value) => {
        this.roomRecvIPs.next(value);
    };
    updateMeetingRoomParams = (value) => {
        this.meetingRoomParams.next(value);
    };
    updateItemPageLimit = (value) => {
        this.itemPageLimit.next(value);
    };
    updateAudioOnlyRoom = (value) => {
        this.audioOnlyRoom.next(value);
    };
    updateAddForBasic = (value) => {
        this.addForBasic.next(value);
    };
    updateScreenPageLimit = (value) => {
        this.screenPageLimit.next(value);
    };
    updateShareScreenStarted = (value) => {
        this.shareScreenStarted.next(value);
    };
    updateShared = (value) => {
        this.shared.next(value);
        this.screenShareActive.next(value);
        if (value) {
            setTimeout(async () => {
                window.dispatchEvent(new Event('resize'));
            }, 2000);
        }
    };
    updateTargetOrientation = (value) => {
        this.targetOrientation.next(value);
    };
    updateTargetResolution = (value) => {
        this.targetResolution.next(value);
    };
    updateTargetResolutionHost = (value) => {
        this.targetResolutionHost.next(value);
    };
    updateVidCons = (value) => {
        this.vidCons.next(value);
    };
    updateFrameRate = (value) => {
        this.frameRate.next(value);
    };
    updateHParams = (value) => {
        this.hParams.next(value);
    };
    updateVParams = (value) => {
        this.vParams.next(value);
    };
    updateScreenParams = (value) => {
        this.screenParams.next(value);
    };
    updateAParams = (value) => {
        this.aParams.next(value);
    };
    updateRecordingAudioPausesLimit = (value) => {
        this.recordingAudioPausesLimit.next(value);
    };
    updateRecordingAudioPausesCount = (value) => {
        this.recordingAudioPausesCount.next(value);
    };
    updateRecordingAudioSupport = (value) => {
        this.recordingAudioSupport.next(value);
    };
    updateRecordingAudioPeopleLimit = (value) => {
        this.recordingAudioPeopleLimit.next(value);
    };
    updateRecordingAudioParticipantsTimeLimit = (value) => {
        this.recordingAudioParticipantsTimeLimit.next(value);
    };
    updateRecordingVideoPausesCount = (value) => {
        this.recordingVideoPausesCount.next(value);
    };
    updateRecordingVideoPausesLimit = (value) => {
        this.recordingVideoPausesLimit.next(value);
    };
    updateRecordingVideoSupport = (value) => {
        this.recordingVideoSupport.next(value);
    };
    updateRecordingVideoPeopleLimit = (value) => {
        this.recordingVideoPeopleLimit.next(value);
    };
    updateRecordingVideoParticipantsTimeLimit = (value) => {
        this.recordingVideoParticipantsTimeLimit.next(value);
    };
    updateRecordingAllParticipantsSupport = (value) => {
        this.recordingAllParticipantsSupport.next(value);
    };
    updateRecordingVideoParticipantsSupport = (value) => {
        this.recordingVideoParticipantsSupport.next(value);
    };
    updateRecordingAllParticipantsFullRoomSupport = (value) => {
        this.recordingAllParticipantsFullRoomSupport.next(value);
    };
    updateRecordingVideoParticipantsFullRoomSupport = (value) => {
        this.recordingVideoParticipantsFullRoomSupport.next(value);
    };
    updateRecordingPreferredOrientation = (value) => {
        this.recordingPreferredOrientation.next(value);
    };
    updateRecordingSupportForOtherOrientation = (value) => {
        this.recordingSupportForOtherOrientation.next(value);
    };
    updateRecordingMultiFormatsSupport = (value) => {
        this.recordingMultiFormatsSupport.next(value);
    };
    updateUserRecordingParams = (value) => {
        this.userRecordingParams.next(value);
    };
    updateCanRecord = (value) => {
        this.canRecord.next(value);
    };
    updateStartReport = (value) => {
        this.startReport.next(value);
    };
    updateEndReport = (value) => {
        this.endReport.next(value);
    };
    updateRecordTimerInterval = (value) => {
        this.recordTimerInterval.next(value);
    };
    updateRecordStartTime = (value) => {
        this.recordStartTime.next(value);
    };
    updateRecordElapsedTime = (value) => {
        this.recordElapsedTime.next(value);
    };
    updateIsTimerRunning = (value) => {
        this.isTimerRunning.next(value);
    };
    updateCanPauseResume = (value) => {
        this.canPauseResume.next(value);
    };
    updateRecordChangeSeconds = (value) => {
        this.recordChangeSeconds.next(value);
    };
    updatePauseLimit = (value) => {
        this.pauseLimit.next(value);
    };
    updatePauseRecordCount = (value) => {
        this.pauseRecordCount.next(value);
    };
    updateCanLaunchRecord = (value) => {
        this.canLaunchRecord.next(value);
    };
    updateStopLaunchRecord = (value) => {
        this.stopLaunchRecord.next(value);
    };
    updateParticipantsAll = (value) => {
        this.participantsAll.next(value);
    };
    updateFirstAll = (value) => {
        this.firstAll.next(value);
    };
    updateUpdateMainWindow = (value) => {
        this.updateMainWindow.next(value);
    };
    updateFirst_round = (value) => {
        this.first_round.next(value);
    };
    updateLandScaped = (value) => {
        this.landScaped.next(value);
    };
    updateLock_screen = (value) => {
        this.lock_screen.next(value);
    };
    updateScreenId = (value) => {
        this.screenId.next(value);
    };
    updateAllVideoStreams = (value) => {
        this.allVideoStreams.next(value);
    };
    updateNewLimitedStreams = (value) => {
        this.newLimitedStreams.next(value);
    };
    updateNewLimitedStreamsIDs = (value) => {
        this.newLimitedStreamsIDs.next(value);
    };
    updateActiveSounds = (value) => {
        this.activeSounds.next(value);
    };
    updateScreenShareIDStream = (value) => {
        this.screenShareIDStream.next(value);
    };
    updateScreenShareNameStream = (value) => {
        this.screenShareNameStream.next(value);
    };
    updateAdminIDStream = (value) => {
        this.adminIDStream.next(value);
    };
    updateAdminNameStream = (value) => {
        this.adminNameStream.next(value);
    };
    updateYouYouStream = (value) => {
        this.youYouStream.next(value);
    };
    updateYouYouStreamIDs = (value) => {
        this.youYouStreamIDs.next(value);
    };
    updateLocalStream = (value) => {
        this.localStream.next(value);
    };
    updateRecordStarted = (value) => {
        this.recordStarted.next(value);
    };
    updateRecordResumed = (value) => {
        this.recordResumed.next(value);
    };
    updateRecordPaused = (value) => {
        this.recordPaused.next(value);
    };
    updateRecordStopped = (value) => {
        this.recordStopped.next(value);
    };
    updateAdminRestrictSetting = (value) => {
        this.adminRestrictSetting.next(value);
    };
    updateVideoRequestState = (value) => {
        this.videoRequestState.next(value);
    };
    updateVideoRequestTime = (value) => {
        this.videoRequestTime.next(value);
    };
    updateVideoAction = (value) => {
        this.videoAction.next(value);
    };
    updateLocalStreamVideo = (value) => {
        this.localStreamVideo.next(value);
    };
    updateUserDefaultVideoInputDevice = (value) => {
        this.userDefaultVideoInputDevice.next(value);
    };
    updateCurrentFacingMode = (value) => {
        this.currentFacingMode.next(value);
    };
    updatePrevFacingMode = (value) => {
        this.prevFacingMode.next(value);
    };
    updateDefVideoID = (value) => {
        this.defVideoID.next(value);
    };
    updateAllowed = (value) => {
        this.allowed.next(value);
    };
    updateDispActiveNames = (value) => {
        this.dispActiveNames.next(value);
    };
    updateP_dispActiveNames = (value) => {
        this.p_dispActiveNames.next(value);
    };
    updateActiveNames = (value) => {
        this.activeNames.next(value);
    };
    updatePrevActiveNames = (value) => {
        this.prevActiveNames.next(value);
    };
    updateP_activeNames = (value) => {
        this.p_activeNames.next(value);
    };
    updateMembersReceived = (value) => {
        this.membersReceived.next(value);
    };
    updateDeferScreenReceived = (value) => {
        this.deferScreenReceived.next(value);
    };
    updateHostFirstSwitch = (value) => {
        this.hostFirstSwitch.next(value);
    };
    updateMicAction = (value) => {
        this.micAction.next(value);
    };
    updateScreenAction = (value) => {
        this.screenAction.next(value);
    };
    updateChatAction = (value) => {
        this.chatAction.next(value);
    };
    updateAudioRequestState = (value) => {
        this.audioRequestState.next(value);
    };
    updateScreenRequestState = (value) => {
        this.screenRequestState.next(value);
    };
    updateChatRequestState = (value) => {
        this.chatRequestState.next(value);
    };
    updateAudioRequestTime = (value) => {
        this.audioRequestTime.next(value);
    };
    updateScreenRequestTime = (value) => {
        this.screenRequestTime.next(value);
    };
    updateChatRequestTime = (value) => {
        this.chatRequestTime.next(value);
    };
    updateOldSoundIds = (value) => {
        this.oldSoundIds.next(value);
    };
    updateHostLabel = (value) => {
        this.hostLabel.next(value);
    };
    updateMainScreenFilled = (value) => {
        this.mainScreenFilled.next(value);
    };
    updateLocalStreamScreen = (value) => {
        this.localStreamScreen.next(value);
    };
    updateScreenAlreadyOn = (value) => {
        this.screenAlreadyOn.next(value);
    };
    updateChatAlreadyOn = (value) => {
        this.chatAlreadyOn.next(value);
    };
    updateRedirectURL = (value) => {
        this.redirectURL.next(value);
    };
    updateOldAllStreams = (value) => {
        this.oldAllStreams.next(value);
    };
    updateAdminVidID = (value) => {
        this.adminVidID.next(value);
    };
    updateStreamNames = (value) => {
        this.streamNames.next(value);
    };
    updateNon_alVideoStreams = (value) => {
        this.non_alVideoStreams.next(value);
    };
    updateSortAudioLoudness = (value) => {
        this.sortAudioLoudness.next(value);
    };
    updateAudioDecibels = (value) => {
        this.audioDecibels.next(value);
    };
    updateMixed_alVideoStreams = (value) => {
        this.mixed_alVideoStreams.next(value);
    };
    updateNon_alVideoStreams_muted = (value) => {
        this.non_alVideoStreams_muted.next(value);
    };
    updatePaginatedStreams = (value) => {
        this.paginatedStreams.next(value);
    };
    updateLocalStreamAudio = (value) => {
        this.localStreamAudio.next(value);
    };
    updateDefAudioID = (value) => {
        this.defAudioID.next(value);
    };
    updateUserDefaultAudioInputDevice = (value) => {
        this.userDefaultAudioInputDevice.next(value);
    };
    updateUserDefaultAudioOutputDevice = (value) => {
        this.userDefaultAudioOutputDevice.next(value);
    };
    updatePrevAudioInputDevice = (value) => {
        this.prevAudioInputDevice.next(value);
    };
    updatePrevVideoInputDevice = (value) => {
        this.prevVideoInputDevice.next(value);
    };
    updateAudioPaused = (value) => {
        this.audioPaused.next(value);
    };
    updateMainScreenPerson = (value) => {
        this.mainScreenPerson.next(value);
    };
    updateAdminOnMainScreen = (value) => {
        this.adminOnMainScreen.next(value);
    };
    updateScreenStates = (value) => {
        this.screenStates.next(value);
    };
    updatePrevScreenStates = (value) => {
        this.prevScreenStates.next(value);
    };
    updateUpdateDateState = (value) => {
        this.updateDateState.next(value);
    };
    updateLastUpdate = (value) => {
        this.lastUpdate.next(value);
    };
    updateNForReadjustRecord = (value) => {
        this.nForReadjustRecord.next(value);
    };
    updateFixedPageLimit = (value) => {
        this.fixedPageLimit.next(value);
    };
    updateRemoveAltGrid = (value) => {
        this.removeAltGrid.next(value);
    };
    updateNForReadjust = (value) => {
        this.nForReadjust.next(value);
    };
    updateLastReorderTime = (value) => {
        this.lastReorderTime.next(value);
    };
    updateAudStreamNames = (value) => {
        this.audStreamNames.next(value);
    };
    updateCurrentUserPage = (value) => {
        this.currentUserPage.next(value);
    };
    updateMainHeightWidth = (value) => {
        this.mainHeightWidth.next(value);
    };
    updatePrevMainHeightWidth = (value) => {
        this.prevMainHeightWidth.next(value);
    };
    updatePrevDoPaginate = (value) => {
        this.prevDoPaginate.next(value);
    };
    updateDoPaginate = (value) => {
        this.doPaginate.next(value);
    };
    updateShareEnded = (value) => {
        this.shareEnded.next(value);
    };
    updateLStreams = (value) => {
        this.lStreams.next(value);
    };
    updateChatRefStreams = (value) => {
        this.chatRefStreams.next(value);
    };
    updateControlHeight = (value) => {
        this.controlHeight.next(value);
    };
    updateIsWideScreen = (value) => {
        this.isWideScreen.next(value);
    };
    updateIsMediumScreen = (value) => {
        this.isMediumScreen.next(value);
    };
    updateIsSmallScreen = (value) => {
        this.isSmallScreen.next(value);
    };
    updateAddGrid = (value) => {
        this.addGrid.next(value);
    };
    updateAddAltGrid = (value) => {
        this.addAltGrid.next(value);
    };
    updateGridRows = (value) => {
        this.gridRows.next(value);
    };
    updateGridCols = (value) => {
        this.gridCols.next(value);
    };
    updateAltGridRows = (value) => {
        this.altGridRows.next(value);
    };
    updateAltGridCols = (value) => {
        this.altGridCols.next(value);
    };
    updateNumberPages = (value) => {
        this.numberPages.next(value);
    };
    updateCurrentStreams = (value) => {
        this.currentStreams.next(value);
    };
    updateShowMiniView = (value) => {
        this.showMiniView.next(value);
    };
    updateNStream = (value) => {
        this.nStream.next(value);
    };
    updateDefer_receive = (value) => {
        this.defer_receive.next(value);
    };
    updateAllAudioStreams = (value) => {
        this.allAudioStreams.next(value);
    };
    updateRemoteScreenStream = (value) => {
        this.remoteScreenStream.next(value);
    };
    updateScreenProducer = (value) => {
        this.screenProducer.next(value);
    };
    updateGotAllVids = (value) => {
        this.gotAllVids.next(value);
    };
    updatePaginationHeightWidth = (value) => {
        this.paginationHeightWidth.next(value);
    };
    updatePaginationDirection = (value) => {
        this.paginationDirection.next(value);
    };
    updateGridSizes = (value) => {
        this.gridSizes.next(value);
    };
    updateScreenForceFullDisplay = (value) => {
        this.screenForceFullDisplay.next(value);
    };
    updateMainGridStream = (value) => {
        this.mainGridStream.next(value);
    };
    updateOtherGridStreams = (value) => {
        this.otherGridStreams.next(value);
    };
    updateAudioOnlyStreams = (value) => {
        this.audioOnlyStreams.next(value);
    };
    updateVideoInputs = (value) => {
        this.videoInputs.next(value);
    };
    updateAudioInputs = (value) => {
        this.audioInputs.next(value);
    };
    updateMeetingProgressTime = (value) => {
        this.meetingProgressTime.next(value);
    };
    updateMeetingElapsedTime = (value) => {
        this.meetingElapsedTime.next(value);
    };
    updateRef_participants = (value) => {
        this.ref_participants.next(value);
    };
    // Messages
    messages = new BehaviorSubject([]);
    startDirectMessage = new BehaviorSubject(false);
    directMessageDetails = new BehaviorSubject(null);
    showMessagesBadge = new BehaviorSubject(false);
    // Event Settings
    audioSetting = new BehaviorSubject('allow');
    videoSetting = new BehaviorSubject('allow');
    screenshareSetting = new BehaviorSubject('allow');
    chatSetting = new BehaviorSubject('allow');
    // Display Settings
    displayOption = new BehaviorSubject('media');
    autoWave = new BehaviorSubject(true);
    forceFullDisplay = new BehaviorSubject(true);
    prevForceFullDisplay = new BehaviorSubject(false);
    prevMeetingDisplayType = new BehaviorSubject('video');
    // Waiting Room
    waitingRoomFilter = new BehaviorSubject('');
    waitingRoomList = new BehaviorSubject(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    waitingRoomCounter = new BehaviorSubject(0);
    filteredWaitingRoomList = new BehaviorSubject(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    // Requests
    requestFilter = new BehaviorSubject('');
    requestList = new BehaviorSubject(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    requestCounter = new BehaviorSubject(0);
    filteredRequestList = new BehaviorSubject(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    // Total Requests and Waiting Room
    totalReqWait = new BehaviorSubject(0);
    // Alerts
    alertVisible = new BehaviorSubject(false);
    alertMessage = new BehaviorSubject('');
    alertType = new BehaviorSubject('success');
    alertDuration = new BehaviorSubject(3000);
    // Progress Timer
    progressTimerVisible = new BehaviorSubject(true);
    progressTimerValue = new BehaviorSubject(0);
    // Menu Modals
    isMenuModalVisible = new BehaviorSubject(false);
    isRecordingModalVisible = new BehaviorSubject(false);
    isSettingsModalVisible = new BehaviorSubject(false);
    isRequestsModalVisible = new BehaviorSubject(false);
    isWaitingModalVisible = new BehaviorSubject(false);
    isCoHostModalVisible = new BehaviorSubject(false);
    isMediaSettingsModalVisible = new BehaviorSubject(false);
    isDisplaySettingsModalVisible = new BehaviorSubject(false);
    // Other Modals
    isParticipantsModalVisible = new BehaviorSubject(false);
    isMessagesModalVisible = new BehaviorSubject(false);
    isConfirmExitModalVisible = new BehaviorSubject(false);
    isConfirmHereModalVisible = new BehaviorSubject(false);
    isShareEventModalVisible = new BehaviorSubject(false);
    isLoadingModalVisible = new BehaviorSubject(false);
    // Recording Options
    recordingMediaOptions = new BehaviorSubject('video');
    recordingAudioOptions = new BehaviorSubject('all');
    recordingVideoOptions = new BehaviorSubject('all');
    recordingVideoType = new BehaviorSubject('fullDisplay');
    recordingVideoOptimized = new BehaviorSubject(false);
    recordingDisplayType = new BehaviorSubject('video');
    recordingAddHLS = new BehaviorSubject(true);
    recordingNameTags = new BehaviorSubject(true);
    recordingBackgroundColor = new BehaviorSubject('#83c0e9');
    recordingNameTagsColor = new BehaviorSubject('#ffffff');
    recordingAddText = new BehaviorSubject(false);
    recordingCustomText = new BehaviorSubject('Add Text');
    recordingCustomTextPosition = new BehaviorSubject('top');
    recordingCustomTextColor = new BehaviorSubject('#ffffff');
    recordingOrientationVideo = new BehaviorSubject('landscape');
    clearedToResume = new BehaviorSubject(true);
    clearedToRecord = new BehaviorSubject(true);
    recordState = new BehaviorSubject('green');
    showRecordButtons = new BehaviorSubject(false);
    recordingProgressTime = new BehaviorSubject('00:00:00');
    audioSwitching = new BehaviorSubject(false);
    videoSwitching = new BehaviorSubject(false);
    // Media States
    videoAlreadyOn = new BehaviorSubject(false);
    audioAlreadyOn = new BehaviorSubject(false);
    componentSizes = new BehaviorSubject({
        mainHeight: 0,
        otherHeight: 0,
        mainWidth: 0,
        otherWidth: 0,
    });
    // Permissions
    hasCameraPermission = new BehaviorSubject(false);
    hasAudioPermission = new BehaviorSubject(false);
    // Transports
    transportCreated = new BehaviorSubject(false);
    transportCreatedVideo = new BehaviorSubject(false);
    transportCreatedAudio = new BehaviorSubject(false);
    transportCreatedScreen = new BehaviorSubject(false);
    producerTransport = new BehaviorSubject(null);
    videoProducer = new BehaviorSubject(null);
    params = new BehaviorSubject({});
    videoParams = new BehaviorSubject({});
    audioParams = new BehaviorSubject({});
    audioProducer = new BehaviorSubject(null);
    consumerTransports = new BehaviorSubject([]);
    consumingTransports = new BehaviorSubject([]);
    // Polls
    polls = new BehaviorSubject(this.useSeed && this.seedData?.polls ? this.seedData.polls : []);
    poll = new BehaviorSubject(null);
    isPollModalVisible = new BehaviorSubject(false);
    // Background
    customImage = new BehaviorSubject('');
    selectedImage = new BehaviorSubject('');
    segmentVideo = new BehaviorSubject(null);
    selfieSegmentation = new BehaviorSubject(null);
    pauseSegmentation = new BehaviorSubject(false);
    processedStream = new BehaviorSubject(null);
    keepBackground = new BehaviorSubject(false);
    backgroundHasChanged = new BehaviorSubject(false);
    virtualStream = new BehaviorSubject(null);
    mainCanvas = new BehaviorSubject(null);
    prevKeepBackground = new BehaviorSubject(false);
    appliedBackground = new BehaviorSubject(false);
    isBackgroundModalVisible = new BehaviorSubject(false);
    autoClickBackground = new BehaviorSubject(false);
    // Breakout Rooms
    breakoutRooms = new BehaviorSubject(this.useSeed && this.seedData?.breakoutRooms ? this.seedData.breakoutRooms : []);
    currentRoomIndex = new BehaviorSubject(0);
    canStartBreakout = new BehaviorSubject(false);
    breakOutRoomStarted = new BehaviorSubject(false);
    breakOutRoomEnded = new BehaviorSubject(false);
    hostNewRoom = new BehaviorSubject(-1);
    limitedBreakRoom = new BehaviorSubject([]);
    mainRoomsLength = new BehaviorSubject(0);
    memberRoom = new BehaviorSubject(-1);
    isBreakoutRoomsModalVisible = new BehaviorSubject(false);
    // Whiteboard
    whiteboardUsers = new BehaviorSubject(this.useSeed && this.seedData?.whiteboardUsers ? this.seedData.whiteboardUsers : []);
    currentWhiteboardIndex = new BehaviorSubject(0);
    canStartWhiteboard = new BehaviorSubject(false);
    whiteboardStarted = new BehaviorSubject(false);
    whiteboardEnded = new BehaviorSubject(false);
    whiteboardLimit = new BehaviorSubject(4);
    isWhiteboardModalVisible = new BehaviorSubject(false);
    isConfigureWhiteboardModalVisible = new BehaviorSubject(false);
    shapes = new BehaviorSubject([]);
    useImageBackground = new BehaviorSubject(true);
    redoStack = new BehaviorSubject([]);
    undoStack = new BehaviorSubject([]);
    canvasStream = new BehaviorSubject(null);
    canvasWhiteboard = new BehaviorSubject(null);
    // Screenboard
    canvasScreenboard = new BehaviorSubject(null);
    processedScreenStream = new BehaviorSubject(null);
    annotateScreenStream = new BehaviorSubject(false);
    mainScreenCanvas = new BehaviorSubject(null);
    isScreenboardModalVisible = new BehaviorSubject(false);
    //state variables for the control buttons
    micActive = new BehaviorSubject(this.audioAlreadyOn.value ? this.audioAlreadyOn.value : false);
    videoActive = new BehaviorSubject(this.videoAlreadyOn.value ? this.videoAlreadyOn.value : false);
    screenShareActive = new BehaviorSubject(false);
    endCallActive = new BehaviorSubject(false);
    participantsActive = new BehaviorSubject(false);
    menuActive = new BehaviorSubject(false);
    commentsActive = new BehaviorSubject(false);
    // Update functions
    updateMessages = (value) => {
        this.messages.next(value);
    };
    updateStartDirectMessage = (value) => {
        this.startDirectMessage.next(value);
    };
    updateDirectMessageDetails = (value) => {
        this.directMessageDetails.next(value);
    };
    updateShowMessagesBadge = (value) => {
        this.showMessagesBadge.next(value);
    };
    updateAudioSetting = (value) => {
        this.audioSetting.next(value);
    };
    updateVideoSetting = (value) => {
        this.videoSetting.next(value);
    };
    updateScreenshareSetting = (value) => {
        this.screenshareSetting.next(value);
    };
    updateChatSetting = (value) => {
        this.chatSetting.next(value);
    };
    updateDisplayOption = (value) => {
        this.displayOption.next(value);
    };
    updateAutoWave = (value) => {
        this.autoWave.next(value);
    };
    updateForceFullDisplay = (value) => {
        this.forceFullDisplay.next(value);
    };
    updatePrevForceFullDisplay = (value) => {
        this.prevForceFullDisplay.next(value);
    };
    updatePrevMeetingDisplayType = (value) => {
        this.prevMeetingDisplayType.next(value);
    };
    updateWaitingRoomCounter = (value) => {
        this.waitingRoomCounter.next(value);
    };
    updateWaitingRoomFilter = (value) => {
        this.waitingRoomFilter.next(value);
    };
    updateWaitingRoomList = (value) => {
        this.waitingRoomList.next(value);
        this.filteredWaitingRoomList.next(value);
        this.waitingRoomCounter.next(value.length);
    };
    onWaitingRoomFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredWaitingRoom = this.waitingRoomList
                .getValue()
                .filter((waitingRoom) => {
                return waitingRoom.name.toLowerCase().includes(value.toLowerCase());
            });
            this.filteredWaitingRoomList.next(filteredWaitingRoom);
            this.waitingRoomCounter.next(filteredWaitingRoom.length);
        }
        else {
            this.filteredWaitingRoomList.next(this.waitingRoomList.getValue());
            this.waitingRoomCounter.next(this.waitingRoomList.getValue().length);
        }
    };
    onWaitingRoomClose = () => {
        this.updateIsWaitingModalVisible(false);
    };
    updateRequestCounter = (value) => {
        this.requestCounter.next(value);
    };
    updateRequestFilter = (value) => {
        this.requestFilter.next(value);
    };
    updateRequestList = (value) => {
        this.requestList.next(value);
        this.filteredRequestList.next(value);
        this.requestCounter.next(value.length);
    };
    onRequestFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredRequest = this.requestList.getValue().filter((request) => {
                return request?.name?.toLowerCase().includes(value.toLowerCase()) ?? false;
            });
            this.filteredRequestList.next(filteredRequest);
            this.requestCounter.next(filteredRequest.length);
        }
        else {
            this.filteredRequestList.next(this.requestList.getValue());
            this.requestCounter.next(this.requestList.getValue().length);
        }
    };
    onRequestClose = () => {
        this.updateIsRequestsModalVisible(false);
    };
    updateTotalReqWait = (value) => {
        this.totalReqWait.next(value);
    };
    updateAlertVisible = (value) => {
        this.alertVisible.next(value);
    };
    updateAlertMessage = (value) => {
        this.alertMessage.next(value);
    };
    updateAlertType = (value) => {
        this.alertType.next(value);
    };
    updateAlertDuration = (value) => {
        this.alertDuration.next(value);
    };
    updateProgressTimerVisible = (value) => {
        this.progressTimerVisible.next(value);
    };
    updateProgressTimerValue = (value) => {
        this.progressTimerValue.next(value);
    };
    updateIsMenuModalVisible = (value) => {
        this.isMenuModalVisible.next(value);
    };
    updateIsRecordingModalVisible = (value) => {
        this.isRecordingModalVisible.next(value);
        if (value) {
            this.updateConfirmedToRecord(false);
        }
        else {
            if (this.clearedToRecord.getValue() &&
                this.clearedToResume.getValue() &&
                this.recordStarted.getValue()) {
                this.updateShowRecordButtons(true);
            }
        }
    };
    updateIsSettingsModalVisible = (value) => {
        this.isSettingsModalVisible.next(value);
    };
    updateIsRequestsModalVisible = (value) => {
        this.isRequestsModalVisible.next(value);
    };
    updateIsWaitingModalVisible = (value) => {
        this.isWaitingModalVisible.next(value);
    };
    updateIsCoHostModalVisible = (value) => {
        this.isCoHostModalVisible.next(value);
    };
    updateIsMediaSettingsModalVisible = (value) => {
        this.isMediaSettingsModalVisible.next(value);
    };
    updateIsDisplaySettingsModalVisible = (value) => {
        this.isDisplaySettingsModalVisible.next(value);
    };
    updateIsParticipantsModalVisible = (value) => {
        this.isParticipantsModalVisible.next(value);
    };
    updateIsMessagesModalVisible = (value) => {
        this.isMessagesModalVisible.next(value);
        if (!value) {
            this.updateShowMessagesBadge(false);
        }
    };
    updateIsConfirmExitModalVisible = (value) => {
        this.isConfirmExitModalVisible.next(value);
    };
    updateIsConfirmHereModalVisible = (value) => {
        this.isConfirmHereModalVisible.next(value);
    };
    updateIsLoadingModalVisible = (value) => {
        this.isLoadingModalVisible.next(value);
    };
    updateIsShareEventModalVisible = (value) => {
        this.isShareEventModalVisible.next(value);
    };
    updateRecordingMediaOptions = (value) => {
        this.recordingMediaOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAudioOptions = (value) => {
        this.recordingAudioOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptions = (value) => {
        this.recordingVideoOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoType = (value) => {
        this.recordingVideoType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptimized = (value) => {
        this.recordingVideoOptimized.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingDisplayType = (value) => {
        this.recordingDisplayType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddHLS = (value) => {
        this.recordingAddHLS.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddText = (value) => {
        this.recordingAddText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomText = (value) => {
        this.recordingCustomText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextPosition = (value) => {
        this.recordingCustomTextPosition.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextColor = (value) => {
        this.recordingCustomTextColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTags = (value) => {
        this.recordingNameTags.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingBackgroundColor = (value) => {
        this.recordingBackgroundColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTagsColor = (value) => {
        this.recordingNameTagsColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingOrientationVideo = (value) => {
        this.recordingOrientationVideo.next(value);
        this.clearedToRecord.next(false);
    };
    updateClearedToResume = (value) => {
        this.clearedToResume.next(value);
    };
    updateClearedToRecord = (value) => {
        this.clearedToRecord.next(value);
    };
    updateRecordState = (value) => {
        if (this.recordStarted.value && !this.recordStopped.value) {
            if (!this.recordPaused.value) {
                this.recordState.next('red');
            }
            else {
                this.recordState.next('yellow');
            }
        }
        else {
            this.recordState.next(value);
        }
        this.recordState.next(value);
    };
    updateShowRecordButtons = (value) => {
        this.showRecordButtons.next(value);
    };
    updateRecordingProgressTime = (value) => {
        this.recordingProgressTime.next(value);
        this.updateRecordTimerWidget();
    };
    updateAudioSwitching = (value) => {
        this.audioSwitching.next(value);
    };
    updateVideoSwitching = (value) => {
        this.videoSwitching.next(value);
    };
    updateVideoAlreadyOn = (value) => {
        this.videoAlreadyOn.next(value);
        this.videoActive.next(value);
    };
    updateAudioAlreadyOn = (value) => {
        this.audioAlreadyOn.next(value);
        this.micActive.next(value);
    };
    updateComponentSizes = (sizes) => {
        this.componentSizes.next(sizes);
    };
    updateHasCameraPermission = (value) => {
        this.hasCameraPermission.next(value);
    };
    updateHasAudioPermission = (value) => {
        this.hasAudioPermission.next(value);
    };
    requestPermissionCamera() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    requestPermissionAudio() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    updateTransportCreated = (value) => {
        this.transportCreated.next(value);
    };
    updateTransportCreatedVideo = (value) => {
        this.transportCreatedVideo.next(value);
    };
    updateTransportCreatedAudio = (value) => {
        this.transportCreatedAudio.next(value);
    };
    updateTransportCreatedScreen = (value) => {
        this.transportCreatedScreen.next(value);
    };
    updateProducerTransport = (value) => {
        this.producerTransport.next(value);
    };
    updateVideoProducer = (value) => {
        this.videoProducer.next(value);
    };
    updateParams = (value) => {
        this.params.next(value);
    };
    updateVideoParams = (value) => {
        this.videoParams.next(value);
    };
    updateAudioParams = (value) => {
        this.audioParams.next(value);
    };
    updateAudioProducer = (value) => {
        this.audioProducer.next(value);
    };
    updateConsumerTransports = (value) => {
        this.consumerTransports.next(value);
    };
    updateConsumingTransports = (value) => {
        this.consumingTransports.next(value);
    };
    updatePolls = (value) => {
        this.polls.next(value);
    };
    updatePoll = (value) => {
        this.poll.next(value);
    };
    updateIsPollModalVisible = (value) => {
        this.isPollModalVisible.next(value);
    };
    updateCustomImage = (value) => {
        this.customImage.next(value);
    };
    updateSelectedImage = (value) => {
        this.selectedImage.next(value);
    };
    updateSegmentVideo = (value) => {
        this.segmentVideo.next(value);
    };
    updateSelfieSegmentation = (value) => {
        this.selfieSegmentation.next(value);
    };
    updatePauseSegmentation = (value) => {
        this.pauseSegmentation.next(value);
    };
    updateProcessedStream = (value) => {
        this.processedStream.next(value);
    };
    updateKeepBackground = (value) => {
        this.keepBackground.next(value);
    };
    updateBackgroundHasChanged = (value) => {
        this.backgroundHasChanged.next(value);
    };
    updateVirtualStream = (value) => {
        this.virtualStream.next(value);
    };
    updateMainCanvas = (value) => {
        this.mainCanvas.next(value);
    };
    updatePrevKeepBackground = (value) => {
        this.prevKeepBackground.next(value);
    };
    updateAppliedBackground = (value) => {
        this.appliedBackground.next(value);
    };
    updateIsBackgroundModalVisible = (value) => {
        this.isBackgroundModalVisible.next(value);
    };
    updateAutoClickBackground = (value) => {
        this.autoClickBackground.next(value);
    };
    updateBreakoutRooms = (value) => {
        this.breakoutRooms.next(value);
    };
    updateCurrentRoomIndex = (value) => {
        this.currentRoomIndex.next(value);
    };
    updateCanStartBreakout = (value) => {
        this.canStartBreakout.next(value);
    };
    updateBreakOutRoomStarted = (value) => {
        this.breakOutRoomStarted.next(value);
    };
    updateBreakOutRoomEnded = (value) => {
        this.breakOutRoomEnded.next(value);
    };
    updateHostNewRoom = (value) => {
        this.hostNewRoom.next(value);
    };
    updateLimitedBreakRoom = (value) => {
        this.limitedBreakRoom.next(value);
    };
    updateMainRoomsLength = (value) => {
        this.mainRoomsLength.next(value);
    };
    updateMemberRoom = (value) => {
        this.memberRoom.next(value);
    };
    updateIsBreakoutRoomsModalVisible = (value) => {
        this.isBreakoutRoomsModalVisible.next(value);
    };
    updateWhiteboardUsers = (value) => {
        this.whiteboardUsers.next(value);
    };
    updateCurrentWhiteboardIndex = (value) => {
        this.currentWhiteboardIndex.next(value);
    };
    updateCanStartWhiteboard = (value) => {
        this.canStartWhiteboard.next(value);
    };
    updateWhiteboardStarted = (value) => {
        this.whiteboardStarted.next(value);
    };
    updateWhiteboardEnded = (value) => {
        this.whiteboardEnded.next(value);
    };
    updateWhiteboardLimit = (value) => {
        this.whiteboardLimit.next(value);
    };
    updateIsWhiteboardModalVisible = (value) => {
        this.isWhiteboardModalVisible.next(value);
    };
    updateIsConfigureWhiteboardModalVisible = (value) => {
        this.isConfigureWhiteboardModalVisible.next(value);
    };
    updateShapes = (value) => {
        this.shapes.next(value);
    };
    updateUseImageBackground = (value) => {
        this.useImageBackground.next(value);
    };
    updateRedoStack = (value) => {
        this.redoStack.next(value);
    };
    updateUndoStack = (value) => {
        this.undoStack.next(value);
    };
    updateCanvasStream = (value) => {
        this.canvasStream.next(value);
    };
    updateCanvasWhiteboard = (value) => {
        this.canvasWhiteboard.next(value);
    };
    updateCanvasScreenboard = (value) => {
        this.canvasScreenboard.next(value);
    };
    updateProcessedScreenStream = (value) => {
        this.processedScreenStream.next(value);
    };
    updateAnnotateScreenStream = (value) => {
        this.annotateScreenStream.next(value);
    };
    updateMainScreenCanvas = (value) => {
        this.mainScreenCanvas.next(value);
    };
    updateIsScreenboardModalVisible = (value) => {
        this.isScreenboardModalVisible.next(value);
    };
    checkOrientation = () => {
        const isPortrait = window.matchMedia('(orientation: portrait)').matches;
        return isPortrait ? 'portrait' : 'landscape';
    };
    showAlert = ({ message, type, duration = 3000, }) => {
        this.updateAlertMessage(message);
        this.updateAlertType(type);
        this.updateAlertDuration(duration);
        this.updateAlertVisible(true);
    };
    getAllParams() {
        return {
            localUIMode: this.localUIMode.value, // Local UI mode
            // Room Details
            roomName: this.roomName.value,
            member: this.member.value,
            adminPasscode: this.adminPasscode.value,
            youAreCoHost: this.youAreCoHost.value,
            youAreHost: this.youAreHost.value,
            islevel: this.islevel.value,
            confirmedToRecord: this.confirmedToRecord.value,
            meetingDisplayType: this.meetingDisplayType.value,
            meetingVideoOptimized: this.meetingVideoOptimized.value,
            eventType: this.eventType.value,
            participants: this.participants.value,
            filteredParticipants: this.filteredParticipants.value,
            participantsCounter: this.participantsCounter.value,
            participantsFilter: this.participantsFilter.value,
            // More room details - media
            consume_sockets: this.consume_sockets.value,
            rtpCapabilities: this.rtpCapabilities.value,
            roomRecvIPs: this.roomRecvIPs.value,
            meetingRoomParams: this.meetingRoomParams.value,
            itemPageLimit: this.itemPageLimit.value,
            audioOnlyRoom: this.audioOnlyRoom.value,
            addForBasic: this.addForBasic.value,
            screenPageLimit: this.screenPageLimit.value,
            shareScreenStarted: this.shareScreenStarted.value,
            shared: this.shared.value,
            targetOrientation: this.targetOrientation.value,
            targetResolution: this.targetResolution.value,
            targetResolutionHost: this.targetResolutionHost.value,
            vidCons: this.vidCons.value,
            frameRate: this.frameRate.value,
            hParams: this.hParams.value,
            vParams: this.vParams.value,
            screenParams: this.screenParams.value,
            aParams: this.aParams.value,
            // More room details - recording
            recordingAudioPausesLimit: this.recordingAudioPausesLimit.value,
            recordingAudioPausesCount: this.recordingAudioPausesCount.value,
            recordingAudioSupport: this.recordingAudioSupport.value,
            recordingAudioPeopleLimit: this.recordingAudioPeopleLimit.value,
            recordingAudioParticipantsTimeLimit: this.recordingAudioParticipantsTimeLimit.value,
            recordingVideoPausesCount: this.recordingVideoPausesCount.value,
            recordingVideoPausesLimit: this.recordingVideoPausesLimit.value,
            recordingVideoSupport: this.recordingVideoSupport.value,
            recordingVideoPeopleLimit: this.recordingVideoPeopleLimit.value,
            recordingVideoParticipantsTimeLimit: this.recordingVideoParticipantsTimeLimit.value,
            recordingAllParticipantsSupport: this.recordingAllParticipantsSupport.value,
            recordingVideoParticipantsSupport: this.recordingVideoParticipantsSupport.value,
            recordingAllParticipantsFullRoomSupport: this.recordingAllParticipantsFullRoomSupport.value,
            recordingVideoParticipantsFullRoomSupport: this.recordingVideoParticipantsFullRoomSupport.value,
            recordingPreferredOrientation: this.recordingPreferredOrientation.value,
            recordingSupportForOtherOrientation: this.recordingSupportForOtherOrientation.value,
            recordingMultiFormatsSupport: this.recordingMultiFormatsSupport.value,
            userRecordingParams: this.userRecordingParams.value,
            canRecord: this.canRecord.value,
            startReport: this.startReport.value,
            endReport: this.endReport.value,
            recordStartTime: this.recordStartTime.value,
            recordElapsedTime: this.recordElapsedTime.value,
            isTimerRunning: this.isTimerRunning.value,
            canPauseResume: this.canPauseResume.value,
            recordChangeSeconds: this.recordChangeSeconds.value,
            pauseLimit: this.pauseLimit.value,
            pauseRecordCount: this.pauseRecordCount.value,
            canLaunchRecord: this.canLaunchRecord.value,
            stopLaunchRecord: this.stopLaunchRecord.value,
            participantsAll: this.participantsAll.value,
            firstAll: this.firstAll.value,
            updateMainWindow: this.updateMainWindow.value,
            first_round: this.first_round.value,
            landScaped: this.landScaped.value,
            lock_screen: this.lock_screen.value,
            screenId: this.screenId.value,
            allVideoStreams: this.allVideoStreams.value,
            newLimitedStreams: this.newLimitedStreams.value,
            newLimitedStreamsIDs: this.newLimitedStreamsIDs.value,
            activeSounds: this.activeSounds.value,
            screenShareIDStream: this.screenShareIDStream.value,
            screenShareNameStream: this.screenShareNameStream.value,
            adminIDStream: this.adminIDStream.value,
            adminNameStream: this.adminNameStream.value,
            youYouStream: this.youYouStream.value,
            youYouStreamIDs: this.youYouStreamIDs.value,
            localStream: this.localStream.value,
            recordStarted: this.recordStarted.value,
            recordResumed: this.recordResumed.value,
            recordPaused: this.recordPaused.value,
            recordStopped: this.recordStopped.value,
            adminRestrictSetting: this.adminRestrictSetting.value,
            videoRequestState: this.videoRequestState.value,
            videoRequestTime: this.videoRequestTime.value,
            videoAction: this.videoAction.value,
            localStreamVideo: this.localStreamVideo.value,
            userDefaultVideoInputDevice: this.userDefaultVideoInputDevice.value,
            currentFacingMode: this.currentFacingMode.value,
            prevFacingMode: this.prevFacingMode.value,
            defVideoID: this.defVideoID.value,
            allowed: this.allowed.value,
            dispActiveNames: this.dispActiveNames.value,
            p_dispActiveNames: this.p_dispActiveNames.value,
            activeNames: this.activeNames.value,
            prevActiveNames: this.prevActiveNames.value,
            p_activeNames: this.p_activeNames.value,
            membersReceived: this.membersReceived.value,
            deferScreenReceived: this.deferScreenReceived.value,
            hostFirstSwitch: this.hostFirstSwitch.value,
            micAction: this.micAction.value,
            screenAction: this.screenAction.value,
            chatAction: this.chatAction.value,
            audioRequestState: this.audioRequestState.value,
            screenRequestState: this.screenRequestState.value,
            chatRequestState: this.chatRequestState.value,
            audioRequestTime: this.audioRequestTime.value,
            screenRequestTime: this.screenRequestTime.value,
            chatRequestTime: this.chatRequestTime.value,
            updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
            oldSoundIds: this.oldSoundIds.value,
            hostLabel: this.hostLabel.value,
            mainScreenFilled: this.mainScreenFilled.value,
            localStreamScreen: this.localStreamScreen.value,
            screenAlreadyOn: this.screenAlreadyOn.value,
            chatAlreadyOn: this.chatAlreadyOn.value,
            redirectURL: this.redirectURL.value,
            oldAllStreams: this.oldAllStreams.value,
            adminVidID: this.adminVidID.value,
            streamNames: this.streamNames.value,
            non_alVideoStreams: this.non_alVideoStreams.value,
            sortAudioLoudness: this.sortAudioLoudness.value,
            audioDecibels: this.audioDecibels.value,
            mixed_alVideoStreams: this.mixed_alVideoStreams.value,
            non_alVideoStreams_muted: this.non_alVideoStreams_muted.value,
            paginatedStreams: this.paginatedStreams.value,
            localStreamAudio: this.localStreamAudio.value,
            defAudioID: this.defAudioID.value,
            userDefaultAudioInputDevice: this.userDefaultAudioInputDevice.value,
            userDefaultAudioOutputDevice: this.userDefaultAudioOutputDevice.value,
            prevAudioInputDevice: this.prevAudioInputDevice.value,
            prevVideoInputDevice: this.prevVideoInputDevice.value,
            audioPaused: this.audioPaused.value,
            mainScreenPerson: this.mainScreenPerson.value,
            adminOnMainScreen: this.adminOnMainScreen.value,
            screenStates: this.screenStates.value,
            prevScreenStates: this.prevScreenStates.value,
            updateDateState: this.updateDateState.value,
            lastUpdate: this.lastUpdate.value,
            nForReadjustRecord: this.nForReadjustRecord.value,
            fixedPageLimit: this.fixedPageLimit.value,
            removeAltGrid: this.removeAltGrid.value,
            nForReadjust: this.nForReadjust.value,
            lastReorderTime: this.lastReorderTime.value,
            reorderInterval: this.reorderInterval.value,
            fastReorderInterval: this.fastReorderInterval.value,
            audStreamNames: this.audStreamNames.value,
            currentUserPage: this.currentUserPage.value,
            mainHeightWidth: this.mainHeightWidth.value,
            prevMainHeightWidth: this.prevMainHeightWidth.value,
            prevDoPaginate: this.prevDoPaginate.value,
            doPaginate: this.doPaginate.value,
            shareEnded: this.shareEnded.value,
            lStreams: this.lStreams.value,
            chatRefStreams: this.chatRefStreams.value,
            controlHeight: this.controlHeight.value,
            isWideScreen: this.isWideScreen.value,
            isMediumScreen: this.isMediumScreen.value,
            isSmallScreen: this.isSmallScreen.value,
            addGrid: this.addGrid.value,
            addAltGrid: this.addAltGrid.value,
            gridRows: this.gridRows.value,
            gridCols: this.gridCols.value,
            altGridRows: this.altGridRows.value,
            altGridCols: this.altGridCols.value,
            numberPages: this.numberPages.value,
            currentStreams: this.currentStreams.value,
            showMiniView: this.showMiniView.value,
            nStream: this.nStream.value,
            defer_receive: this.defer_receive.value,
            allAudioStreams: this.allAudioStreams.value,
            screenProducer: this.screenProducer.value,
            remoteScreenStream: this.remoteScreenStream.value,
            gotAllVids: this.gotAllVids.value,
            paginationHeightWidth: this.paginationHeightWidth.value,
            paginationDirection: this.paginationDirection.value,
            gridSizes: this.gridSizes.value,
            screenForceFullDisplay: this.screenForceFullDisplay.value,
            mainGridStream: this.mainGridStream.value,
            otherGridStreams: this.otherGridStreams.value,
            audioOnlyStreams: this.audioOnlyStreams.value,
            videoInputs: this.videoInputs.value,
            audioInputs: this.audioInputs.value,
            meetingProgressTime: this.meetingProgressTime.value,
            meetingElapsedTime: this.meetingElapsedTime.value,
            ref_participants: this.ref_participants.value,
            messages: this.messages.value,
            startDirectMessage: this.startDirectMessage.value,
            directMessageDetails: this.directMessageDetails.value,
            coHost: this.coHost.value,
            coHostResponsibility: this.coHostResponsibility.value,
            // Event settings
            audioSetting: this.audioSetting.value,
            videoSetting: this.videoSetting.value,
            screenshareSetting: this.screenshareSetting.value,
            chatSetting: this.chatSetting.value,
            // Display settings
            autoWave: this.autoWave.value,
            forceFullDisplay: this.forceFullDisplay.value,
            prevForceFullDisplay: this.prevForceFullDisplay.value,
            prevMeetingDisplayType: this.prevMeetingDisplayType.value,
            // Waiting room
            waitingRoomFilter: this.waitingRoomFilter.value,
            waitingRoomList: this.waitingRoomList.value,
            waitingRoomCounter: this.waitingRoomCounter.value,
            filteredWaitingRoomList: this.filteredWaitingRoomList.value,
            // Requests
            requestFilter: this.requestFilter.value,
            requestList: this.requestList.value,
            requestCounter: this.requestCounter.value,
            filteredRequestList: this.filteredRequestList.value,
            // Total requests and waiting room
            totalReqWait: this.totalReqWait.value,
            // Alerts
            alertVisible: this.alertVisible.value,
            alertMessage: this.alertMessage.value,
            alertType: this.alertType.value,
            alertDuration: this.alertDuration.value,
            // Progress Timer
            progressTimerVisible: this.progressTimerVisible.value,
            progressTimerValue: this.progressTimerValue.value,
            // Menu modals
            isMenuModalVisible: this.isMenuModalVisible.value,
            isRecordingModalVisible: this.isRecordingModalVisible.value,
            isSettingsModalVisible: this.isSettingsModalVisible.value,
            isRequestsModalVisible: this.isRequestsModalVisible.value,
            isWaitingModalVisible: this.isWaitingModalVisible.value,
            isCoHostModalVisible: this.isCoHostModalVisible.value,
            isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
            isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            // Other Modals
            isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            isMessagesModalVisible: this.isMessagesModalVisible.value,
            isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            isConfirmHereModalVisible: this.isConfirmHereModalVisible.value,
            isLoadingModalVisible: this.isLoadingModalVisible.value,
            // Recording Options
            recordingMediaOptions: this.recordingMediaOptions.value,
            recordingAudioOptions: this.recordingAudioOptions.value,
            recordingVideoOptions: this.recordingVideoOptions.value,
            recordingVideoType: this.recordingVideoType.value,
            recordingVideoOptimized: this.recordingVideoOptimized.value,
            recordingDisplayType: this.recordingDisplayType.value,
            recordingAddHLS: this.recordingAddHLS.value,
            recordingAddText: this.recordingAddText.value,
            recordingCustomText: this.recordingCustomText.value,
            recordingCustomTextPosition: this.recordingCustomTextPosition.value,
            recordingCustomTextColor: this.recordingCustomTextColor.value,
            recordingNameTags: this.recordingNameTags.value,
            recordingBackgroundColor: this.recordingBackgroundColor.value,
            recordingNameTagsColor: this.recordingNameTagsColor.value,
            recordingOrientationVideo: this.recordingOrientationVideo.value,
            clearedToResume: this.clearedToResume.value,
            clearedToRecord: this.clearedToRecord.value,
            recordState: this.recordState.value,
            showRecordButtons: this.showRecordButtons.value,
            recordingProgressTime: this.recordingProgressTime.value,
            audioSwitching: this.audioSwitching.value,
            videoSwitching: this.videoSwitching.value,
            // Media states
            videoAlreadyOn: this.videoAlreadyOn.value,
            audioAlreadyOn: this.audioAlreadyOn.value,
            componentSizes: this.componentSizes.value,
            // Permissions
            hasCameraPermission: this.hasCameraPermission.value,
            hasAudioPermission: this.hasAudioPermission.value,
            // Transports
            transportCreated: this.transportCreated.value,
            transportCreatedVideo: this.transportCreatedVideo.value,
            transportCreatedAudio: this.transportCreatedAudio.value,
            transportCreatedScreen: this.transportCreatedScreen.value,
            producerTransport: this.producerTransport.value,
            videoProducer: this.videoProducer.value,
            params: this.params.value,
            videoParams: this.videoParams.value,
            audioParams: this.audioParams.value,
            audioProducer: this.audioProducer.value,
            consumerTransports: this.consumerTransports.value,
            consumingTransports: this.consumingTransports.value,
            // Polls
            polls: this.polls.value,
            poll: this.poll.value,
            isPollModalVisible: this.isPollModalVisible.value,
            // Background
            customImage: this.customImage.value,
            selectedImage: this.selectedImage.value,
            segmentVideo: this.segmentVideo.value,
            selfieSegmentation: this.selfieSegmentation.value,
            pauseSegmentation: this.pauseSegmentation.value,
            processedStream: this.processedStream.value,
            keepBackground: this.keepBackground.value,
            backgroundHasChanged: this.backgroundHasChanged.value,
            virtualStream: this.virtualStream.value,
            mainCanvas: this.mainCanvas.value,
            prevKeepBackground: this.prevKeepBackground.value,
            appliedBackground: this.appliedBackground.value,
            isBackgroundModalVisible: this.isBackgroundModalVisible.value,
            autoClickBackground: this.autoClickBackground.value,
            // Breakout rooms
            breakoutRooms: this.breakoutRooms.value,
            currentRoomIndex: this.currentRoomIndex.value,
            canStartBreakout: this.canStartBreakout.value,
            breakOutRoomStarted: this.breakOutRoomStarted.value,
            breakOutRoomEnded: this.breakOutRoomEnded.value,
            hostNewRoom: this.hostNewRoom.value,
            limitedBreakRoom: this.limitedBreakRoom.value,
            mainRoomsLength: this.mainRoomsLength.value,
            memberRoom: this.memberRoom.value,
            isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            // Whiteboard
            whiteboardUsers: this.whiteboardUsers.value,
            currentWhiteboardIndex: this.currentWhiteboardIndex.value,
            canStartWhiteboard: this.canStartWhiteboard.value,
            whiteboardStarted: this.whiteboardStarted.value,
            whiteboardEnded: this.whiteboardEnded.value,
            whiteboardLimit: this.whiteboardLimit.value,
            isWhiteboardModalVisible: this.isWhiteboardModalVisible.value,
            isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            shapes: this.shapes.value,
            useImageBackground: this.useImageBackground.value,
            redoStack: this.redoStack.value,
            undoStack: this.undoStack.value,
            canvasStream: this.canvasStream.value,
            canvasWhiteboard: this.canvasWhiteboard.value,
            // Screenboard
            canvasScreenboard: this.canvasScreenboard.value,
            processedScreenStream: this.processedScreenStream.value,
            annotateScreenStream: this.annotateScreenStream.value,
            mainScreenCanvas: this.mainScreenCanvas.value,
            isScreenboardModalVisible: this.isScreenboardModalVisible.value,
            validated: this.validated.value,
            device: this.device.value,
            socket: this.socket.value,
            checkMediaPermission: false,
            onWeb: true,
            // Update functions
            updateRoomName: this.updateRoomName.bind(this),
            updateMember: this.updateMember.bind(this),
            updateAdminPasscode: this.updateAdminPasscode.bind(this),
            updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
            updateYouAreHost: this.updateYouAreHost.bind(this),
            updateIslevel: this.updateIslevel.bind(this),
            updateCoHost: this.updateCoHost.bind(this),
            updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
            updateConfirmedToRecord: this.updateConfirmedToRecord.bind(this),
            updateMeetingDisplayType: this.updateMeetingDisplayType.bind(this),
            updateMeetingVideoOptimized: this.updateMeetingVideoOptimized.bind(this),
            updateEventType: this.updateEventType.bind(this),
            updateParticipants: this.updateParticipants.bind(this),
            updateParticipantsCounter: this.updateParticipantsCounter.bind(this),
            updateParticipantsFilter: this.updateParticipantsFilter.bind(this),
            // More update functions for media details
            updateConsume_sockets: this.updateConsume_sockets.bind(this),
            updateRtpCapabilities: this.updateRtpCapabilities.bind(this),
            updateRoomRecvIPs: this.updateRoomRecvIPs.bind(this),
            updateMeetingRoomParams: this.updateMeetingRoomParams.bind(this),
            updateItemPageLimit: this.updateItemPageLimit.bind(this),
            updateAudioOnlyRoom: this.updateAudioOnlyRoom.bind(this),
            updateAddForBasic: this.updateAddForBasic.bind(this),
            updateScreenPageLimit: this.updateScreenPageLimit.bind(this),
            updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
            updateShared: this.updateShared.bind(this),
            updateTargetOrientation: this.updateTargetOrientation.bind(this),
            updateTargetResolution: this.updateTargetResolution.bind(this),
            updateTargetResolutionHost: this.updateTargetResolutionHost.bind(this),
            updateVidCons: this.updateVidCons.bind(this),
            updateFrameRate: this.updateFrameRate.bind(this),
            updateHParams: this.updateHParams.bind(this),
            updateVParams: this.updateVParams.bind(this),
            updateScreenParams: this.updateScreenParams.bind(this),
            updateAParams: this.updateAParams.bind(this),
            // More update functions for recording details
            updateRecordingAudioPausesLimit: this.updateRecordingAudioPausesLimit.bind(this),
            updateRecordingAudioPausesCount: this.updateRecordingAudioPausesCount.bind(this),
            updateRecordingAudioSupport: this.updateRecordingAudioSupport.bind(this),
            updateRecordingAudioPeopleLimit: this.updateRecordingAudioPeopleLimit.bind(this),
            updateRecordingAudioParticipantsTimeLimit: this.updateRecordingAudioParticipantsTimeLimit.bind(this),
            updateRecordingVideoPausesCount: this.updateRecordingVideoPausesCount.bind(this),
            updateRecordingVideoPausesLimit: this.updateRecordingVideoPausesLimit.bind(this),
            updateRecordingVideoSupport: this.updateRecordingVideoSupport.bind(this),
            updateRecordingVideoPeopleLimit: this.updateRecordingVideoPeopleLimit.bind(this),
            updateRecordingVideoParticipantsTimeLimit: this.updateRecordingVideoParticipantsTimeLimit.bind(this),
            updateRecordingAllParticipantsSupport: this.updateRecordingAllParticipantsSupport.bind(this),
            updateRecordingVideoParticipantsSupport: this.updateRecordingVideoParticipantsSupport.bind(this),
            updateRecordingAllParticipantsFullRoomSupport: this.updateRecordingAllParticipantsFullRoomSupport.bind(this),
            updateRecordingVideoParticipantsFullRoomSupport: this.updateRecordingVideoParticipantsFullRoomSupport.bind(this),
            updateRecordingPreferredOrientation: this.updateRecordingPreferredOrientation.bind(this),
            updateRecordingSupportForOtherOrientation: this.updateRecordingSupportForOtherOrientation.bind(this),
            updateRecordingMultiFormatsSupport: this.updateRecordingMultiFormatsSupport.bind(this),
            updateUserRecordingParams: this.updateUserRecordingParams.bind(this),
            updateCanRecord: this.updateCanRecord.bind(this),
            updateStartReport: this.updateStartReport.bind(this),
            updateEndReport: this.updateEndReport.bind(this),
            updateRecordTimerInterval: this.updateRecordTimerInterval.bind(this),
            updateRecordStartTime: this.updateRecordStartTime.bind(this),
            updateRecordElapsedTime: this.updateRecordElapsedTime.bind(this),
            updateIsTimerRunning: this.updateIsTimerRunning.bind(this),
            updateCanPauseResume: this.updateCanPauseResume.bind(this),
            updateRecordChangeSeconds: this.updateRecordChangeSeconds.bind(this),
            updatePauseLimit: this.updatePauseLimit.bind(this),
            updatePauseRecordCount: this.updatePauseRecordCount.bind(this),
            updateCanLaunchRecord: this.updateCanLaunchRecord.bind(this),
            updateStopLaunchRecord: this.updateStopLaunchRecord.bind(this),
            updateParticipantsAll: this.updateParticipantsAll.bind(this),
            updateFirstAll: this.updateFirstAll.bind(this),
            updateUpdateMainWindow: this.updateUpdateMainWindow.bind(this),
            updateFirst_round: this.updateFirst_round.bind(this),
            updateLandScaped: this.updateLandScaped.bind(this),
            updateLock_screen: this.updateLock_screen.bind(this),
            updateScreenId: this.updateScreenId.bind(this),
            updateAllVideoStreams: this.updateAllVideoStreams.bind(this),
            updateNewLimitedStreams: this.updateNewLimitedStreams.bind(this),
            updateNewLimitedStreamsIDs: this.updateNewLimitedStreamsIDs.bind(this),
            updateActiveSounds: this.updateActiveSounds.bind(this),
            updateScreenShareIDStream: this.updateScreenShareIDStream.bind(this),
            updateScreenShareNameStream: this.updateScreenShareNameStream.bind(this),
            updateAdminIDStream: this.updateAdminIDStream.bind(this),
            updateAdminNameStream: this.updateAdminNameStream.bind(this),
            updateYouYouStream: this.updateYouYouStream.bind(this),
            updateYouYouStreamIDs: this.updateYouYouStreamIDs.bind(this),
            updateLocalStream: this.updateLocalStream.bind(this),
            updateRecordStarted: this.updateRecordStarted.bind(this),
            updateRecordResumed: this.updateRecordResumed.bind(this),
            updateRecordPaused: this.updateRecordPaused.bind(this),
            updateRecordStopped: this.updateRecordStopped.bind(this),
            updateAdminRestrictSetting: this.updateAdminRestrictSetting.bind(this),
            updateVideoRequestState: this.updateVideoRequestState.bind(this),
            updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
            updateVideoAction: this.updateVideoAction.bind(this),
            updateLocalStreamVideo: this.updateLocalStreamVideo.bind(this),
            updateUserDefaultVideoInputDevice: this.updateUserDefaultVideoInputDevice.bind(this),
            updateCurrentFacingMode: this.updateCurrentFacingMode.bind(this),
            updatePrevFacingMode: this.updatePrevFacingMode.bind(this),
            updateDefVideoID: this.updateDefVideoID.bind(this),
            updateAllowed: this.updateAllowed.bind(this),
            updateDispActiveNames: this.updateDispActiveNames.bind(this),
            updateP_dispActiveNames: this.updateP_dispActiveNames.bind(this),
            updateActiveNames: this.updateActiveNames.bind(this),
            updatePrevActiveNames: this.updatePrevActiveNames.bind(this),
            updateP_activeNames: this.updateP_activeNames.bind(this),
            updateMembersReceived: this.updateMembersReceived.bind(this),
            updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
            updateHostFirstSwitch: this.updateHostFirstSwitch.bind(this),
            updateMicAction: this.updateMicAction.bind(this),
            updateScreenAction: this.updateScreenAction.bind(this),
            updateChatAction: this.updateChatAction.bind(this),
            updateAudioRequestState: this.updateAudioRequestState.bind(this),
            updateScreenRequestState: this.updateScreenRequestState.bind(this),
            updateChatRequestState: this.updateChatRequestState.bind(this),
            updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
            updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
            updateChatRequestTime: this.updateChatRequestTime.bind(this),
            updateOldSoundIds: this.updateOldSoundIds.bind(this),
            updateHostLabel: this.updateHostLabel.bind(this),
            updateMainScreenFilled: this.updateMainScreenFilled.bind(this),
            updateLocalStreamScreen: this.updateLocalStreamScreen.bind(this),
            updateScreenAlreadyOn: this.updateScreenAlreadyOn.bind(this),
            updateChatAlreadyOn: this.updateChatAlreadyOn.bind(this),
            updateRedirectURL: this.updateRedirectURL.bind(this),
            updateOldAllStreams: this.updateOldAllStreams.bind(this),
            updateAdminVidID: this.updateAdminVidID.bind(this),
            updateStreamNames: this.updateStreamNames.bind(this),
            updateNon_alVideoStreams: this.updateNon_alVideoStreams.bind(this),
            updateSortAudioLoudness: this.updateSortAudioLoudness.bind(this),
            updateAudioDecibels: this.updateAudioDecibels.bind(this),
            updateMixed_alVideoStreams: this.updateMixed_alVideoStreams.bind(this),
            updateNon_alVideoStreams_muted: this.updateNon_alVideoStreams_muted.bind(this),
            updatePaginatedStreams: this.updatePaginatedStreams.bind(this),
            updateLocalStreamAudio: this.updateLocalStreamAudio.bind(this),
            updateDefAudioID: this.updateDefAudioID.bind(this),
            updateUserDefaultAudioInputDevice: this.updateUserDefaultAudioInputDevice.bind(this),
            updateUserDefaultAudioOutputDevice: this.updateUserDefaultAudioOutputDevice.bind(this),
            updatePrevAudioInputDevice: this.updatePrevAudioInputDevice.bind(this),
            updatePrevVideoInputDevice: this.updatePrevVideoInputDevice.bind(this),
            updateAudioPaused: this.updateAudioPaused.bind(this),
            updateMainScreenPerson: this.updateMainScreenPerson.bind(this),
            updateAdminOnMainScreen: this.updateAdminOnMainScreen.bind(this),
            updateScreenStates: this.updateScreenStates.bind(this),
            updatePrevScreenStates: this.updatePrevScreenStates.bind(this),
            updateUpdateDateState: this.updateUpdateDateState.bind(this),
            updateLastUpdate: this.updateLastUpdate.bind(this),
            updateNForReadjustRecord: this.updateNForReadjustRecord.bind(this),
            updateFixedPageLimit: this.updateFixedPageLimit.bind(this),
            updateRemoveAltGrid: this.updateRemoveAltGrid.bind(this),
            updateNForReadjust: this.updateNForReadjust.bind(this),
            updateLastReorderTime: this.updateLastReorderTime.bind(this),
            updateAudStreamNames: this.updateAudStreamNames.bind(this),
            updateCurrentUserPage: this.updateCurrentUserPage.bind(this),
            updateMainHeightWidth: this.updateMainHeightWidth.bind(this),
            updatePrevMainHeightWidth: this.updatePrevMainHeightWidth.bind(this),
            updatePrevDoPaginate: this.updatePrevDoPaginate.bind(this),
            updateDoPaginate: this.updateDoPaginate.bind(this),
            updateShareEnded: this.updateShareEnded.bind(this),
            updateLStreams: this.updateLStreams.bind(this),
            updateChatRefStreams: this.updateChatRefStreams.bind(this),
            updateControlHeight: this.updateControlHeight.bind(this),
            updateIsWideScreen: this.updateIsWideScreen.bind(this),
            updateIsMediumScreen: this.updateIsMediumScreen.bind(this),
            updateIsSmallScreen: this.updateIsSmallScreen.bind(this),
            updateAddGrid: this.updateAddGrid.bind(this),
            updateAddAltGrid: this.updateAddAltGrid.bind(this),
            updateGridRows: this.updateGridRows.bind(this),
            updateGridCols: this.updateGridCols.bind(this),
            updateAltGridRows: this.updateAltGridRows.bind(this),
            updateAltGridCols: this.updateAltGridCols.bind(this),
            updateNumberPages: this.updateNumberPages.bind(this),
            updateCurrentStreams: this.updateCurrentStreams.bind(this),
            updateShowMiniView: this.updateShowMiniView.bind(this),
            updateNStream: this.updateNStream.bind(this),
            updateDefer_receive: this.updateDefer_receive.bind(this),
            updateAllAudioStreams: this.updateAllAudioStreams.bind(this),
            updateRemoteScreenStream: this.updateRemoteScreenStream.bind(this),
            updateScreenProducer: this.updateScreenProducer.bind(this),
            updateGotAllVids: this.updateGotAllVids.bind(this),
            updatePaginationHeightWidth: this.updatePaginationHeightWidth.bind(this),
            updatePaginationDirection: this.updatePaginationDirection.bind(this),
            updateGridSizes: this.updateGridSizes.bind(this),
            updateScreenForceFullDisplay: this.updateScreenForceFullDisplay.bind(this),
            updateMainGridStream: this.updateMainGridStream.bind(this),
            updateOtherGridStreams: this.updateOtherGridStreams.bind(this),
            updateAudioOnlyStreams: this.updateAudioOnlyStreams.bind(this),
            updateVideoInputs: this.updateVideoInputs.bind(this),
            updateAudioInputs: this.updateAudioInputs.bind(this),
            updateMeetingProgressTime: this.updateMeetingProgressTime.bind(this),
            updateMeetingElapsedTime: this.updateMeetingElapsedTime.bind(this),
            updateRef_participants: this.updateRef_participants.bind(this),
            updateMessages: this.updateMessages.bind(this),
            updateStartDirectMessage: this.updateStartDirectMessage.bind(this),
            updateDirectMessageDetails: this.updateDirectMessageDetails.bind(this),
            updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
            // Event settings
            updateAudioSetting: this.updateAudioSetting.bind(this),
            updateVideoSetting: this.updateVideoSetting.bind(this),
            updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
            updateChatSetting: this.updateChatSetting.bind(this),
            // Display settings
            updateAutoWave: this.updateAutoWave.bind(this),
            updateForceFullDisplay: this.updateForceFullDisplay.bind(this),
            updatePrevForceFullDisplay: this.updatePrevForceFullDisplay.bind(this),
            updatePrevMeetingDisplayType: this.updatePrevMeetingDisplayType.bind(this),
            // Waiting room
            updateWaitingRoomFilter: this.updateWaitingRoomFilter.bind(this),
            updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
            updateWaitingRoomCounter: this.updateWaitingRoomCounter.bind(this),
            // Requests
            updateRequestFilter: this.updateRequestFilter.bind(this),
            updateRequestList: this.updateRequestList.bind(this),
            updateRequestCounter: this.updateRequestCounter.bind(this),
            // Total requests and waiting room
            updateTotalReqWait: this.updateTotalReqWait.bind(this),
            // Menu modals
            updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
            updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
            updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
            updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
            updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
            updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
            // Other modals
            updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
            updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
            updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
            updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
            updateIsLoadingModalVisible: this.updateIsLoadingModalVisible.bind(this),
            // Recording Options
            updateRecordingMediaOptions: this.updateRecordingMediaOptions.bind(this),
            updateRecordingAudioOptions: this.updateRecordingAudioOptions.bind(this),
            updateRecordingVideoOptions: this.updateRecordingVideoOptions.bind(this),
            updateRecordingVideoType: this.updateRecordingVideoType.bind(this),
            updateRecordingVideoOptimized: this.updateRecordingVideoOptimized.bind(this),
            updateRecordingDisplayType: this.updateRecordingDisplayType.bind(this),
            updateRecordingAddHLS: this.updateRecordingAddHLS.bind(this),
            updateRecordingAddText: this.updateRecordingAddText.bind(this),
            updateRecordingCustomText: this.updateRecordingCustomText.bind(this),
            updateRecordingCustomTextPosition: this.updateRecordingCustomTextPosition.bind(this),
            updateRecordingCustomTextColor: this.updateRecordingCustomTextColor.bind(this),
            updateRecordingNameTags: this.updateRecordingNameTags.bind(this),
            updateRecordingBackgroundColor: this.updateRecordingBackgroundColor.bind(this),
            updateRecordingNameTagsColor: this.updateRecordingNameTagsColor.bind(this),
            updateRecordingOrientationVideo: this.updateRecordingOrientationVideo.bind(this),
            updateClearedToResume: this.updateClearedToResume.bind(this),
            updateClearedToRecord: this.updateClearedToRecord.bind(this),
            updateRecordState: this.updateRecordState.bind(this),
            updateShowRecordButtons: this.updateShowRecordButtons.bind(this),
            updateRecordingProgressTime: this.updateRecordingProgressTime.bind(this),
            updateAudioSwitching: this.updateAudioSwitching.bind(this),
            updateVideoSwitching: this.updateVideoSwitching.bind(this),
            // Media states
            updateVideoAlreadyOn: this.updateVideoAlreadyOn.bind(this),
            updateAudioAlreadyOn: this.updateAudioAlreadyOn.bind(this),
            updateComponentSizes: this.updateComponentSizes.bind(this),
            // Permissions
            updateHasCameraPermission: this.updateHasCameraPermission.bind(this),
            updateHasAudioPermission: this.updateHasAudioPermission.bind(this),
            // Transports
            updateTransportCreated: this.updateTransportCreated.bind(this),
            updateTransportCreatedVideo: this.updateTransportCreatedVideo.bind(this),
            updateTransportCreatedAudio: this.updateTransportCreatedAudio.bind(this),
            updateTransportCreatedScreen: this.updateTransportCreatedScreen.bind(this),
            updateProducerTransport: this.updateProducerTransport.bind(this),
            updateVideoProducer: this.updateVideoProducer.bind(this),
            updateParams: this.updateParams.bind(this),
            updateVideoParams: this.updateVideoParams.bind(this),
            updateAudioParams: this.updateAudioParams.bind(this),
            updateAudioProducer: this.updateAudioProducer.bind(this),
            updateConsumerTransports: this.updateConsumerTransports.bind(this),
            updateConsumingTransports: this.updateConsumingTransports.bind(this),
            // Polls
            updatePolls: this.updatePolls.bind(this),
            updatePoll: this.updatePoll.bind(this),
            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
            // Background
            updateCustomImage: this.updateCustomImage.bind(this),
            updateSelectedImage: this.updateSelectedImage.bind(this),
            updateSegmentVideo: this.updateSegmentVideo.bind(this),
            updateSelfieSegmentation: this.updateSelfieSegmentation.bind(this),
            updatePauseSegmentation: this.updatePauseSegmentation.bind(this),
            updateProcessedStream: this.updateProcessedStream.bind(this),
            updateKeepBackground: this.updateKeepBackground.bind(this),
            updateBackgroundHasChanged: this.updateBackgroundHasChanged.bind(this),
            updateVirtualStream: this.updateVirtualStream.bind(this),
            updateMainCanvas: this.updateMainCanvas.bind(this),
            updatePrevKeepBackground: this.updatePrevKeepBackground.bind(this),
            updateAppliedBackground: this.updateAppliedBackground.bind(this),
            updateIsBackgroundModalVisible: this.updateIsBackgroundModalVisible.bind(this),
            updateAutoClickBackground: this.updateAutoClickBackground.bind(this),
            // Breakout rooms
            updateBreakoutRooms: this.updateBreakoutRooms.bind(this),
            updateCurrentRoomIndex: this.updateCurrentRoomIndex.bind(this),
            updateCanStartBreakout: this.updateCanStartBreakout.bind(this),
            updateBreakOutRoomStarted: this.updateBreakOutRoomStarted.bind(this),
            updateBreakOutRoomEnded: this.updateBreakOutRoomEnded.bind(this),
            updateHostNewRoom: this.updateHostNewRoom.bind(this),
            updateLimitedBreakRoom: this.updateLimitedBreakRoom.bind(this),
            updateMainRoomsLength: this.updateMainRoomsLength.bind(this),
            updateMemberRoom: this.updateMemberRoom.bind(this),
            updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
            // Whiteboard
            updateWhiteboardUsers: this.updateWhiteboardUsers.bind(this),
            updateCurrentWhiteboardIndex: this.updateCurrentWhiteboardIndex.bind(this),
            updateCanStartWhiteboard: this.updateCanStartWhiteboard.bind(this),
            updateWhiteboardStarted: this.updateWhiteboardStarted.bind(this),
            updateWhiteboardEnded: this.updateWhiteboardEnded.bind(this),
            updateWhiteboardLimit: this.updateWhiteboardLimit.bind(this),
            updateIsWhiteboardModalVisible: this.updateIsWhiteboardModalVisible.bind(this),
            updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
            updateShapes: this.updateShapes.bind(this),
            updateUseImageBackground: this.updateUseImageBackground.bind(this),
            updateRedoStack: this.updateRedoStack.bind(this),
            updateUndoStack: this.updateUndoStack.bind(this),
            updateCanvasStream: this.updateCanvasStream.bind(this),
            updateCanvasWhiteboard: this.updateCanvasWhiteboard.bind(this),
            // Screenboard
            updateCanvasScreenboard: this.updateCanvasScreenboard.bind(this),
            updateProcessedScreenStream: this.updateProcessedScreenStream.bind(this),
            updateAnnotateScreenStream: this.updateAnnotateScreenStream.bind(this),
            updateMainScreenCanvas: this.updateMainScreenCanvas.bind(this),
            updateIsScreenboardModalVisible: this.updateIsScreenboardModalVisible.bind(this),
            // Other functions
            checkOrientation: this.checkOrientation.bind(this),
            updateDevice: this.updateDevice.bind(this),
            updateSocket: this.updateSocket.bind(this),
            updateValidated: this.updateValidated.bind(this),
            showAlert: this.showAlert.bind(this),
            getUpdatedAllParams: () => {
                return {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                };
            },
        };
    }
    mediaSFUParameters = {
        ...this.getAllParams(),
        ...this.mediaSFUFunctions(),
    };
    getUpdatedAllParams = () => {
        return {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    };
    updateButtonState(buttonType, value) {
        this.controlButtons = this.controlButtons.map((button) => {
            if (buttonType === 'micActive' && button.icon === this.faMicrophoneSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'videoActive' && button.icon === this.faVideoSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'screenShareActive' && button.icon === this.faDesktop) {
                if (button.alternateIconComponent) {
                    const updatedInjector = this.createInjector({
                        disabled: !value,
                    });
                    return {
                        ...button,
                        active: true,
                        alternateIconComponent: { ...this.screenShareWidget, injector: updatedInjector },
                    }; //always default to true for active
                }
                else {
                    return { ...button, active: true }; //always default to true for active
                }
            }
            if (buttonType === 'endCallActive' && button.icon === this.faPhone) {
                return { ...button, active: value };
            }
            if (buttonType === 'participantsActive' && button.icon === this.faUsers) {
                return { ...button, active: value };
            }
            if (buttonType === 'showMessagesBadge' &&
                button.customName &&
                button.customName === 'Messages') {
                const updatedInjector = this.createInjector({
                    icon: this.faComments,
                    badgeValue: value ? '*' : '',
                    iconColor: 'black',
                    showBadge: value,
                });
                return { ...button, customComponent: { ...this.messageWidget, injector: updatedInjector } };
            }
            if (buttonType === 'showMenuBadge' && button.customName && button.customName === 'Menu') {
                const updatedInjector = this.createInjector({
                    icon: this.faBars,
                    badgeValue: this.totalReqWait.value,
                    iconColor: 'black',
                    showBadge: true,
                });
                return { ...button, customComponent: { ...this.menuWidget, injector: updatedInjector } };
            }
            return button;
        });
        this.cdr.detectChanges();
    }
    PrejoinPageComponent = {
        component: this.PrejoinPage,
        injector: null,
    };
    updatePrejoinPageComponent = () => {
        const PrejoinComp = {
            component: this.PrejoinPage,
            injector: this.createInjector({
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('none');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    updateSocket: this.updateSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                credentials: this.credentials,
            }),
        };
        this.PrejoinPageComponent = { ...PrejoinComp };
        this.cdr.detectChanges();
    };
    ngOnInit() {
        if (this.PrejoinPage) {
            this.updatePrejoinPageComponent();
        }
        this.setupResizeListener();
        if (this.validated) {
            this.connectAndAddSocketMethods();
        }
        this.mainHeightWidthSubscription = this.mainHeightWidth.subscribe(() => {
            this.updateMainVideoSize();
        });
        this.recordingSubscription = combineLatest([
            this.recordPaused,
            this.recordStarted,
            this.recordStopped,
            this.recordResumed,
            this.recordingProgressTime,
            this.showRecordButtons,
            this.islevel,
        ]).subscribe(([recordPaused, recordStarted, recordStopped, recordResumed, recordingProgressTime, showRecordButtons, islevel,]) => {
            if (recordPaused ||
                recordStarted ||
                recordStopped ||
                recordResumed ||
                recordingProgressTime ||
                showRecordButtons ||
                islevel) {
                this.updateRecordButtons();
            }
        });
        this.ScreenboardSubscription = combineLatest([
            this.shared,
            this.componentSizes,
            this.annotateScreenStream,
        ]).subscribe(([shared, componentSizes]) => {
            this.ScreenboardWidget = {
                component: Screenboard,
                inputs: {
                    customWidth: componentSizes.mainWidth,
                    customHeight: componentSizes.mainHeight,
                    parameters: this.mediaSFUParameters,
                    showAspect: shared,
                },
            };
        });
        this.validatedSubscription = this.validated.subscribe((validated) => {
            if (validated) {
                this.handleValidated();
            }
        });
        this.islevelSubscription = this.islevel.subscribe((islevel) => {
            if (islevel) {
                this.updateCustomMenuButtons();
            }
        });
        this.coHostSubscription = combineLatest([this.coHost, this.coHostResponsibility]).subscribe(([coHost, coHostResponsibility]) => {
            if (coHost || coHostResponsibility) {
                this.updateCustomMenuButtons();
            }
        });
        // Subscribe to changes in BehaviorSubject and update the buttons accordingly
        this.buttonSubscriptions.push(this.micActive.subscribe((value) => {
            this.updateButtonState('micActive', value);
        }));
        this.buttonSubscriptions.push(this.videoActive.subscribe((value) => {
            this.updateButtonState('videoActive', value);
        }));
        this.buttonSubscriptions.push(this.screenShareActive.subscribe((value) => {
            this.updateButtonState('screenShareActive', value);
        }));
        this.buttonSubscriptions.push(this.showMessagesBadge.subscribe((value) => {
            this.updateButtonState('showMessagesBadge', value);
        }));
        this.buttonSubscriptions.push(this.totalReqWait.subscribe(() => {
            this.updateButtonState('showMenuBadge', true);
        }));
        this.buttonSubscriptions.push(this.participantsCounter.subscribe((value) => {
            this.updateMenuParticipantsWidget(value);
        }));
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.handleResize);
        window.removeEventListener('orientationchange', this.handleResize);
        if (this.mainHeightWidthSubscription) {
            this.mainHeightWidthSubscription.unsubscribe();
        }
        if (this.validatedSubscription) {
            this.validatedSubscription.unsubscribe();
        }
        if (this.islevelSubscription) {
            this.islevelSubscription.unsubscribe();
        }
        if (this.coHostSubscription) {
            this.coHostSubscription.unsubscribe();
        }
        if (this.ScreenboardSubscription) {
            this.ScreenboardSubscription.unsubscribe();
        }
        if (this.recordingSubscription) {
            this.recordingSubscription.unsubscribe();
        }
    }
    updateMainVideoSize = async () => {
        if (!this.lock_screen.value && !this.shared.value) {
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
        }
        else {
            if (!this.first_round.value) {
                this.prepopulateUserMedia.prepopulateUserMedia({
                    name: this.hostLabel.value,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            }
        }
    };
    async connectAndAddSocketMethods() {
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
        const socket_ = await this.connect_Socket(this.apiUserName.value, '', this.apiToken.value);
        if (socket_) {
            this.updateSocket(socket_);
        }
    }
    async handleValidated() {
        this.updateAllVideoStreams([
            { producerId: 'youyou', stream: undefined, id: 'youyou', name: 'youyou' },
        ]);
        this.updateStreamNames([{ id: 'youyou', name: 'youyou', producerId: '' }]);
        if (this.validated.value) {
            this.updateIsLoadingModalVisible(true);
            try {
                if (!this.localUIMode.value) {
                    await this.connectAndAddSocketMethods();
                }
            }
            catch (error) {
                console.log('error connectAndaAddSocketMethods', error);
            }
            this.startMeetingProgressTimer.startMeetingProgressTimer({
                startTime: Date.now() / 1000,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            this.updateIsLoadingModalVisible(false);
        }
    }
    async handleResize() {
        let fraction = 0;
        if (window.innerHeight < window.innerWidth &&
            (this.eventType.value == 'webinar' || this.eventType.value == 'conference')) {
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        else {
            // Set default control button height for portrait mode or other event types
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            fraction = Number(fraction);
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        const dimensions = this.computeDimensionsMethod({
            containerWidthFraction: 1,
            containerHeightFraction: 1,
            mainSize: this.mainHeightWidth.value,
            doStack: true,
            defaultFraction: this.eventType.value == 'webinar' || this.eventType.value == 'conference'
                ? 1 - fraction
                : 1,
        });
        this.updateComponentSizes(dimensions);
        const orientation = this.checkOrientation();
        if (orientation == 'portrait') {
            if (!this.isWideScreen.value) {
                if (this.shareScreenStarted.value || this.shared.value) {
                    this.updateScreenForceFullDisplay(true);
                }
            }
        }
        // Updates the main grid view
        await this.prepopulateUserMedia.prepopulateUserMedia({
            name: this.hostLabel.value,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
        // Updates the mini grid view
        await this.onScreenChanges.onScreenChanges({
            changed: true,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
    }
    async disconnectAllSockets(consume_sockets) {
        for (const socket of consume_sockets) {
            try {
                const ip = Object.keys(socket)[0];
                await socket[ip].disconnect();
            }
            catch (error) {
                console.log(`Error disconnecting socket with IP: ${Object.keys(socket)[0]}`, error);
            }
        }
    }
    async closeAndReset() {
        //close and clean up all sockets, modals,... and reset all states to initial values
        this.updateIsMessagesModalVisible(false);
        this.updateIsParticipantsModalVisible(false);
        this.updateIsWaitingModalVisible(false);
        this.updateIsRequestsModalVisible(false);
        this.updateIsCoHostModalVisible(false);
        this.updateIsSettingsModalVisible(false);
        this.updateIsDisplaySettingsModalVisible(false);
        this.updateIsMediaSettingsModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsShareEventModalVisible(false);
        this.updateIsConfirmExitModalVisible(false);
        await this.disconnectAllSockets(this.consume_sockets.value);
        await this.updateStatesToInitialValues();
        this.updateMeetingProgressTime('00:00:00');
        this.updateMeetingElapsedTime(0);
        this.updateRecordingProgressTime('00:00:00');
        this.updateRecordElapsedTime(0);
        this.updateShowRecordButtons(false);
        this.updateIsConfigureWhiteboardModalVisible(false);
        this.updateIsWhiteboardModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsRecordingModalVisible(false);
        this.updateIsPollModalVisible(false);
        this.updateIsBreakoutRoomsModalVisible(false);
        this.updateIsBackgroundModalVisible(false);
        this.updateIsLoadingModalVisible(false);
        this.updateIsConfirmHereModalVisible(false);
        await sleep({ ms: 500 });
        this.updateValidated(false);
        //if on web, reload the page
        window.location.reload();
    }
    computeDimensionsMethod = ({ containerWidthFraction = 1, containerHeightFraction = 1, mainSize, doStack = true, defaultFraction, }) => {
        const parentWidth = window.innerWidth * containerWidthFraction;
        const parentHeight = window.innerHeight * containerHeightFraction * defaultFraction;
        let isWideScreen = parentWidth >= 768;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        const dimensions = this.calculateDimensions({
            parentWidth,
            parentHeight,
            isWideScreen,
            mainSize,
            doStack,
        });
        return dimensions;
    };
    calculateDimensions({ parentWidth, parentHeight, isWideScreen, mainSize, doStack, }) {
        if (doStack) {
            return isWideScreen
                ? {
                    mainHeight: Math.floor(parentHeight),
                    otherHeight: Math.floor(parentHeight),
                    mainWidth: Math.floor((mainSize / 100) * parentWidth),
                    otherWidth: Math.floor(((100 - mainSize) / 100) * parentWidth),
                }
                : {
                    mainHeight: Math.floor((mainSize / 100) * parentHeight),
                    otherHeight: Math.floor(((100 - mainSize) / 100) * parentHeight),
                    mainWidth: Math.floor(parentWidth),
                    otherWidth: Math.floor(parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(parentHeight),
                otherHeight: Math.floor(parentHeight),
                mainWidth: Math.floor(parentWidth),
                otherWidth: Math.floor(parentWidth),
            };
        }
    }
    handleOrientationChange() {
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('orientationchange', this.handleResize.bind(this));
    }
    setupResizeListener() {
        this.handleResize();
    }
    orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    async joinRoom(data) {
        const { socket, roomName, islevel, member, sec, apiUserName } = data;
        try {
            const response = await this.joinRoomClient.joinRoomClient({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
            return response;
        }
        catch (error) {
            console.log('Error joining room:', error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    async join_Room({ socket, roomName, islevel, member, sec, apiUserName, }) {
        const data = await this.joinRoom({
            socket: socket,
            roomName: roomName,
            islevel: islevel,
            member: member,
            sec: sec,
            apiUserName: apiUserName,
        });
        if (data && data.success) {
            this.roomData.next(data);
            try {
                this.updateRoomParametersClient.updateRoomParametersClient({
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                        data: data,
                    },
                });
                if (data.isHost) {
                    this.updateIslevel('2');
                }
                else {
                    this.updateIslevel('1');
                }
                if (data.secureCode) {
                    this.updateAdminPasscode(data.secureCode);
                }
                if (data.rtpCapabilities) {
                    const device_ = await this.createDeviceClient.createDeviceClient({
                        rtpCapabilities: data.rtpCapabilities,
                    });
                    if (device_) {
                        this.device.next(device_);
                    }
                }
            }
            catch {
                /* handle error */
            }
        }
        else {
            this.updateValidated(false);
            try {
                if (this.showAlert && data?.reason) {
                    this.showAlert({ message: data?.reason, type: 'danger', duration: 3000 });
                }
            }
            catch {
                /* handle error */
            }
        }
    }
    onParticipantsFilterChange = (value) => {
        if (value && value.length > 0) {
            this.filteredParticipants.next(this.participants.value.filter((participant) => participant.name.toLowerCase().includes(value.toLowerCase())));
            this.participantsCounter.next(this.filteredParticipants.value.length);
        }
        else {
            this.filteredParticipants.next(this.participants.value);
            this.participantsCounter.next(this.participants.value.length);
        }
    };
    updateStatesToInitialValues = async () => {
        const initialValues = initialValuesState;
        const updateFunctions = this.getAllParams();
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                const updateFunctionName = `update${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const updateFunction = updateFunctions[updateFunctionName];
                if (typeof updateFunction === 'function') {
                    try {
                        updateFunction(initialValues[key]);
                    }
                    catch {
                        /* handle error */
                    }
                }
            }
        }
    };
    faRecordVinyl = faRecordVinyl;
    faPlayCircle = faPlayCircle;
    faPauseCircle = faPauseCircle;
    faStopCircle = faStopCircle;
    faDotCircle = faDotCircle;
    faCog = faCog;
    faUsers = faUsers;
    faClock = faClock;
    faUserPlus = faUserPlus;
    faTools = faTools;
    faDesktop = faDesktop;
    faPoll = faPoll;
    faUserFriends = faUserFriends;
    faChalkboardTeacher = faChalkboardTeacher;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faPhone = faPhone;
    faBars = faBars;
    faComments = faComments;
    faChartBar = faChartBar;
    onCloseMenuModal = () => {
        this.updateIsMenuModalVisible(false);
    };
    onEventSettingsClose = () => {
        this.updateIsSettingsModalVisible(false);
    };
    onCoHostClose = () => {
        this.updateIsCoHostModalVisible(false);
    };
    onMediaSettingsClose = () => {
        this.updateIsMediaSettingsModalVisible(false);
    };
    onDisplaySettingsClose = () => {
        this.updateIsDisplaySettingsModalVisible(false);
    };
    onPollClose = () => {
        this.updateIsPollModalVisible(false);
    };
    onBreakoutRoomsClose = () => {
        this.updateIsBreakoutRoomsModalVisible(false);
    };
    onConfigureWhiteboardClose = () => {
        this.updateIsConfigureWhiteboardModalVisible(false);
    };
    onMessagesClose = () => {
        this.updateIsMessagesModalVisible(false);
    };
    onRecordingClose = () => {
        this.updateIsRecordingModalVisible(false);
    };
    onParticipantsClose = () => {
        this.updateIsParticipantsModalVisible(false);
    };
    onBackgroundClose = () => {
        this.updateIsBackgroundModalVisible(false);
    };
    onConfirmExitClose = () => {
        this.updateIsConfirmExitModalVisible(false);
    };
    onConfirmHereClose = () => {
        this.updateIsConfirmHereModalVisible(false);
    };
    onScreenboardClose = () => {
        this.updateIsScreenboardModalVisible(false);
    };
    onShareEventClose = () => {
        this.updateIsShareEventModalVisible(false);
    };
    onAlertHide = () => {
        this.updateAlertVisible(false);
    };
    ScreenboardWidget = {
        component: Screenboard,
        inputs: {
            customWidth: this.componentSizes.value.mainWidth,
            customHeight: this.componentSizes.value.mainHeight,
            parameters: this.mediaSFUParameters,
            showAspect: this.shared.value,
        },
    };
    recordTimerWidget = {
        component: RecordTimerWidget,
        injector: this.createInjector({ recordingProgressTime: this.recordingProgressTime.value }),
    };
    updateRecordTimerWidget = (recordingProgressTime = this.recordingProgressTime.value) => {
        const recordTimerWidget = {
            component: RecordTimerWidget,
            injector: this.createInjector({ recordingProgressTime: recordingProgressTime }),
        };
        this.recordTimerWidget = { ...recordTimerWidget };
        this.cdr.markForCheck();
        return recordTimerWidget;
    };
    recordButtons = [];
    recordButtonsArray = [
        {
            icon: this.faPlayCircle,
            active: () => !this.recordPaused.value,
            onPress: () => this.updateRecording.updateRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            alternateIcon: this.faPauseCircle,
            show: () => true,
        },
        {
            icon: this.faStopCircle,
            active: () => false,
            onPress: () => this.stopRecording.stopRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: () => this.updateRecordTimerWidget(),
            show: () => true,
            active: () => false,
        },
        {
            icon: this.faDotCircle,
            active: () => false,
            onPress: () => console.log('Status pressed'),
            activeColor: 'black',
            inActiveColor: () => (this.recordPaused.value ? 'yellow' : 'red'),
            show: () => true,
        },
        {
            icon: this.faCog,
            active: () => false,
            onPress: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
    ];
    async updateRecordButtons() {
        const recordButtons = this.recordButtonsArray.map((button) => {
            return {
                ...button,
                active: typeof button.active === 'function' ? button.active() : button.active,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
                activeColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
                inActiveColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
            };
        });
        this.recordButtons = [...recordButtons];
        await this.updateMenuRecordWidget(recordButtons);
        this.updateCustomMenuButtons();
        this.cdr.markForCheck();
    }
    // Create instances of the custom widgets
    menuWidget = {
        component: MenuWidget,
        injector: this.createInjector({
            icon: this.faBars,
            badgeValue: this.totalReqWait.value,
            iconColor: 'black',
            showBadge: true,
        }),
    };
    messageWidget = {
        component: MessageWidget,
        injector: this.createInjector({
            icon: this.faComments,
            showBadge: this.showMessagesBadge.value,
            badgeValue: 1,
            iconColor: 'black',
        }),
    };
    menuRecordWidget = {
        component: MenuRecordWidget,
        injector: this.createInjector({
            buttons: this.recordButtons,
            showAspect: true,
            direction: 'horizontal',
        }),
    };
    updateMenuRecordWidget = (recordButtons = this.recordButtons) => {
        const menuRecordWidget = {
            component: MenuRecordWidget,
            injector: this.createInjector({
                buttons: recordButtons,
                showAspect: true,
                direction: 'horizontal',
            }),
        };
        this.menuRecordWidget = { ...menuRecordWidget };
        this.cdr.markForCheck();
        return menuRecordWidget;
    };
    menuParticipantsWidget = {
        component: MenuParticipantsWidget,
        injector: this.createInjector({
            icon: this.faChartBar,
            participantsCounter: this.participantsCounter.value,
            iconColor: 'black',
        }),
    };
    updateMenuParticipantsWidget = (count = this.participantsCounter.value) => {
        const menuParticipantsWidget = {
            component: MenuParticipantsWidget,
            injector: this.createInjector({
                icon: this.faChartBar,
                participantsCounter: count,
                iconColor: 'black',
            }),
        };
        this.menuParticipantsWidget = { ...menuParticipantsWidget };
        this.cdr.markForCheck();
        return menuParticipantsWidget;
    };
    customMenuButtonsArray = [
        {
            icon: this.faRecordVinyl,
            text: 'Record',
            action: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            show: () => !this.showRecordButtons.value && this.islevel.value == '2',
        },
        {
            customComponent: () => this.updateMenuRecordWidget(),
            show: () => this.showRecordButtons.value && this.islevel.value == '2',
            action: () => console.log('record buttons pressed'),
        },
        {
            icon: this.faCog,
            text: 'Event Settings',
            action: () => this.launchSettings.launchSettings({
                updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
                isSettingsModalVisible: this.isSettingsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faUsers,
            text: 'Requests',
            action: () => this.launchRequests.launchRequests({
                updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
                isRequestsModalVisible: this.isRequestsModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                (this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    !!this.coHostResponsibility?.value?.find((item) => item.name === 'media')?.value) ||
                false,
        },
        {
            icon: this.faClock,
            text: 'Waiting',
            action: () => this.launchWaiting.launchWaiting({
                updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
                isWaitingModalVisible: this.isWaitingModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                (this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    this.coHostResponsibility?.value?.find((item) => item.name === 'waiting')?.value ===
                        true) ||
                false,
        },
        {
            icon: this.faUserPlus,
            text: 'Co-host',
            action: () => this.launchCoHost.launchCoHost({
                updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
                isCoHostModalVisible: this.isCoHostModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faTools,
            text: 'Set Media',
            action: () => this.launchMediaSettings.launchMediaSettings({
                updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
                isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
                audioInputs: this.audioInputs.value,
                videoInputs: this.videoInputs.value,
                updateAudioInputs: this.updateAudioInputs.bind(this),
                updateVideoInputs: this.updateVideoInputs.bind(this),
            }),
            show: () => true,
        },
        {
            icon: this.faDesktop,
            text: 'Display',
            action: () => this.launchDisplaySettings.launchDisplaySettings({
                updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
                isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faPoll,
            text: 'Poll',
            action: () => this.launchPoll.launchPoll({
                updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                isPollModalVisible: this.isPollModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faUserFriends,
            text: 'Breakout Rooms',
            action: () => this.launchBreakoutRooms.launchBreakoutRooms({
                updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
                isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faChalkboardTeacher,
            text: 'Whiteboard',
            action: () => this.launchConfigureWhiteboard.launchConfigureWhiteboard({
                updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
                isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
    ];
    customMenuButtons = [];
    updateCustomMenuButtons() {
        this.customMenuButtons = this.customMenuButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
            };
        });
    }
    screenShareWidget = {
        component: ScreenShareWidget,
        injector: this.createInjector({ disabled: !this.screenShareActive.value }),
    };
    controlButtons = [
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.audioSwitching.value,
            show: true,
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                    MediaStream,
                    MediaStreamTrack,
                    mediaDevices: MediaDevices,
                    device: this.device.value,
                    socket: this.socket.value,
                    showAlert: this.showAlert.bind(this),
                    checkPermission: this.checkPermission.checkPermission,
                    streamSuccessVideo: this.streamSuccessVideo.streamSuccessVideo,
                    hasCameraPermission: this.hasCameraPermission.value,
                    requestPermissionCamera: this.requestPermissionCamera.bind(this),
                    checkMediaPermission: 'web' !== 'web',
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.videoSwitching.value,
            show: true,
        },
        {
            //inverted active for inactive state
            icon: faDesktop,
            alternateIconComponent: this.screenShareWidget,
            active: true,
            onPress: () => this.clickScreenShare.clickScreenShare({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faUsers,
            active: this.participantsActive.value,
            onPress: () => this.launchParticipants.launchParticipants({
                updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
                isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            disabled: false,
            show: true,
        },
        {
            customComponent: this.menuWidget,
            customName: 'Menu',
            onPress: () => this.launchMenuModal.launchMenuModal({
                updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
                isMenuModalVisible: this.isMenuModalVisible.value,
            }),
            show: true,
        },
        {
            customComponent: this.messageWidget,
            customName: 'Messages',
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: true,
        },
    ];
    async connect_Socket(apiUserName, apiKey, apiToken) {
        if (this.socket.value && this.socket.value.id) {
            this.socket.value.on('disconnect', async () => {
                await this.disconnect.disconnect({
                    showAlert: this.showAlert.bind(this),
                    redirectURL: this.redirectURL.value,
                    onWeb: true,
                    updateValidated: this.updateValidated.bind(this),
                });
                if (this.videoAlreadyOn.value) {
                    await this.clickVideo.clickVideo({
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                if (this.audioAlreadyOn.value) {
                    await this.clickAudio.clickAudio({
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                await this.closeAndReset();
            });
            this.socket.value.on('allMembers', async (membersData) => {
                if (membersData) {
                    await this.allMembers.allMembers({
                        apiUserName: apiUserName,
                        apiKey: '', //not recommended - use apiToken instead. Use for testing/development only
                        apiToken: apiToken,
                        members: membersData.members,
                        requestss: membersData.requests ? membersData.requests : this.requestList.value,
                        coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                        coHostRes: membersData.coHostResponsibilities
                            ? membersData.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        consume_sockets: this.consume_sockets.value,
                    });
                }
            });
            this.socket.value.on('allMembersRest', async (membersData) => {
                if (membersData) {
                    await this.allMembersRest.allMembersRest({
                        apiUserName: apiUserName,
                        apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                        members: membersData.members,
                        apiToken: apiToken,
                        settings: membersData.settings,
                        coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                        coHostRes: membersData.coHostResponsibilities
                            ? membersData.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        consume_sockets: this.consume_sockets.value,
                    });
                }
            });
            this.socket.value.on('userWaiting', async ({ name }) => {
                await this.userWaiting.userWaiting({
                    name,
                    showAlert: this.showAlert.bind(this),
                    totalReqWait: this.totalReqWait.value,
                    updateTotalReqWait: this.updateTotalReqWait.bind(this),
                });
            });
            this.socket.value.on('personJoined', async ({ name }) => {
                this.personJoined.personJoined({
                    name,
                    showAlert: this.showAlert.bind(this),
                });
            });
            this.socket.value.on('allWaitingRoomMembers', async (waiting_data) => {
                await this.allWaitingRoomMembers.allWaitingRoomMembers({
                    waitingParticipants: waiting_data.waitingParticipants
                        ? waiting_data.waitingParticipants
                        : waiting_data.waitingParticipantss
                            ? waiting_data.waitingParticipantss
                            : this.waitingRoomList.value,
                    updateTotalReqWait: this.updateTotalReqWait.bind(this),
                    updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
                });
            });
            this.socket.value.on('roomRecordParams', async ({ recordParams }) => {
                this.roomRecordParams.roomRecordParams({
                    recordParams,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('ban', async ({ name }) => {
                await this.banParticipant.banParticipant({
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('updatedCoHost', async (cohost_data) => {
                await this.updatedCoHost.updatedCoHost({
                    coHost: cohost_data.coHost ? cohost_data.coHost : this.coHost.value,
                    coHostResponsibility: cohost_data.coHostResponsibilities
                        ? cohost_data.coHostResponsibilities
                        : this.coHostResponsibility.value,
                    youAreCoHost: this.youAreCoHost.value,
                    updateCoHost: this.updateCoHost.bind(this),
                    updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
                    updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
                    showAlert: this.showAlert.bind(this),
                    eventType: this.eventType.value,
                    islevel: this.islevel.value,
                    member: this.member.value,
                });
            });
            this.socket.value.on('participantRequested', async ({ userRequest }) => {
                await this.participantRequested.participantRequested({
                    userRequest,
                    requestList: this.requestList.value,
                    waitingRoomList: this.waitingRoomList.value,
                    updateTotalReqWait: this.updateTotalReqWait.bind(this),
                    updateRequestList: this.updateRequestList.bind(this),
                });
            });
            this.socket.value.on('screenProducerId', async ({ producerId }) => {
                this.screenProducerId.screenProducerId({
                    producerId,
                    screenId: this.screenId.value,
                    membersReceived: this.membersReceived.value,
                    shareScreenStarted: this.shareScreenStarted.value,
                    deferScreenReceived: this.deferScreenReceived.value,
                    participants: this.participants.value,
                    updateScreenId: this.updateScreenId.bind(this),
                    updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
                    updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
                });
            });
            //settings, updateAudioSetting, updateVideoSetting, updateScreenshareSetting, updateChatSetting
            this.socket.value.on('updateMediaSettings', async ({ settings }) => {
                this.updateMediaSettings.updateMediaSettings({
                    settings,
                    updateAudioSetting: this.updateAudioSetting.bind(this),
                    updateVideoSetting: this.updateVideoSetting.bind(this),
                    updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
                    updateChatSetting: this.updateChatSetting.bind(this),
                });
            });
            this.socket.value.on('producer-media-paused', async ({ producerId, kind, name, }) => {
                await this.producerMediaPaused.producerMediaPaused({
                    producerId,
                    kind,
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('producer-media-resumed', async ({ kind, name }) => {
                await this.producerMediaResumed.producerMediaResumed({
                    kind,
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('producer-media-closed', async ({ producerId, kind, }) => {
                if (producerId && kind) {
                    await this.producerMediaClosed.producerMediaClosed({
                        producerId,
                        kind,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
            });
            this.socket.value.on('controlMediaHost', async ({ type }) => {
                await this.controlMediaHost.controlMediaHost({
                    type,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('meetingEnded', async () => {
                await this.meetingEnded.meetingEnded({
                    showAlert: this.showAlert.bind(this),
                    redirectURL: this.redirectURL.value,
                    onWeb: true,
                    eventType: this.eventType.value,
                    updateValidated: this.updateValidated.bind(this),
                });
                if (this.videoAlreadyOn.value) {
                    await this.clickVideo.clickVideo({
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                }
                if (this.audioAlreadyOn.value) {
                    await this.clickAudio.clickAudio({
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                }
                await this.closeAndReset();
            });
            this.socket.value.on('disconnectUserSelf', async () => {
                await this.disconnectUserSelf.disconnectUserSelf({
                    socket: this.socket.value,
                    member: this.member.value,
                    roomName: this.roomName.value,
                });
            });
            this.socket.value.on('receiveMessage', async ({ message }) => {
                await this.receiveMessage.receiveMessage({
                    message,
                    messages: this.messages.value,
                    participantsAll: this.participantsAll.value,
                    member: this.member.value,
                    eventType: this.eventType.value,
                    islevel: this.islevel.value,
                    coHost: this.coHost.value,
                    updateMessages: this.updateMessages.bind(this),
                    updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
                });
            });
            this.socket.value.on('meetingTimeRemaining', async ({ timeRemaining }) => {
                await this.meetingTimeRemaining.meetingTimeRemaining({
                    timeRemaining,
                    showAlert: this.showAlert.bind(this),
                    eventType: this.eventType.value,
                });
            });
            this.socket.value.on('meetingStillThere', async () => {
                this.meetingStillThere.meetingStillThere({
                    updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
                });
            });
            this.socket.value.on('startRecords', async () => {
                await this.startRecords.startRecords({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: this.socket.value,
                });
            });
            this.socket.value.on('reInitiateRecording', async () => {
                await this.reInitiateRecording.reInitiateRecording({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: this.socket.value,
                    adminRestrictSetting: this.adminRestrictSetting.value,
                });
            });
            this.socket.value.on('updateConsumingDomains', async ({ domains, alt_domains }) => {
                await this.updateConsumingDomains.updateConsumingDomains({
                    domains,
                    alt_domains,
                    apiUserName,
                    apiKey,
                    apiToken,
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                    },
                });
            });
            this.socket.value.on('RecordingNotice', async ({ state, userRecordingParam, pauseCount, timeDone }) => {
                await this.recordingNotice.RecordingNotice({
                    state,
                    userRecordingParam,
                    pauseCount,
                    timeDone,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('timeLeftRecording', async ({ timeLeft }) => {
                this.timeLeftRecording.timeLeftRecording({
                    timeLeft,
                    showAlert: this.showAlert.bind(this),
                });
            });
            this.socket.value.on('stoppedRecording', async ({ state, reason }) => {
                await this.stoppedRecording.stoppedRecording({
                    state,
                    reason,
                    showAlert: this.showAlert.bind(this),
                });
            });
            this.socket.value.on('hostRequestResponse', ({ requestResponse }) => {
                this.hostRequestResponse.hostRequestResponse({
                    requestResponse,
                    showAlert: this.showAlert.bind(this),
                    requestList: this.requestList.value,
                    updateRequestList: this.updateRequestList.bind(this),
                    updateMicAction: this.updateMicAction.bind(this),
                    updateVideoAction: this.updateVideoAction.bind(this),
                    updateScreenAction: this.updateScreenAction.bind(this),
                    updateChatAction: this.updateChatAction.bind(this),
                    updateAudioRequestState: this.updateAudioRequestState.bind(this),
                    updateVideoRequestState: this.updateVideoRequestState.bind(this),
                    updateScreenRequestState: this.updateScreenRequestState.bind(this),
                    updateChatRequestState: this.updateChatRequestState.bind(this),
                    updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
                    updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
                    updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
                    updateChatRequestTime: this.updateChatRequestTime.bind(this),
                    updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
                });
            });
            this.socket.value.on('pollUpdated', async (data) => {
                try {
                    await this.pollUpdated.pollUpdated({
                        data,
                        polls: this.polls.value,
                        poll: this.poll.value ? this.poll.value : {},
                        member: this.member.value,
                        islevel: this.islevel.value,
                        showAlert: this.showAlert.bind(this),
                        updatePolls: this.updatePolls.bind(this),
                        updatePoll: this.updatePoll.bind(this),
                        updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                    });
                }
                catch {
                    /* handle error */
                }
            });
            this.socket.value.on('breakoutRoomUpdated', async (data) => {
                try {
                    await this.breakoutRoomUpdated.breakoutRoomUpdated({
                        data,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                catch {
                    /* handle error */
                }
            });
            await this.join_Room({
                socket: this.socket.value,
                roomName: this.roomName.value,
                islevel: this.islevel.value,
                member: this.member.value,
                sec: this.apiToken.value,
                apiUserName: this.apiUserName.value,
            });
            await this.receiveRoomMessages.receiveRoomMessages({
                socket: this.socket.value,
                roomName: this.roomName.value,
                updateMessages: this.updateMessages.bind(this),
            });
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            return this.socket.value;
        }
        else {
            return null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediasfuWebinar, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.Injector }, { token: UpdateMiniCardsGrid }, { token: MixStreams }, { token: DispStreams }, { token: StopShareScreen }, { token: CheckScreenShare }, { token: StartShareScreen }, { token: RequestScreenShare }, { token: ReorderStreams }, { token: PrepopulateUserMedia }, { token: GetVideos }, { token: RePort }, { token: Trigger }, { token: ConsumerResume }, { token: ConnectSendTransport }, { token: ConnectSendTransportAudio }, { token: ConnectSendTransportVideo }, { token: ConnectSendTransportScreen }, { token: ProcessConsumerTransports }, { token: ResumePauseStreams }, { token: Readjust }, { token: CheckGrid }, { token: GetEstimate }, { token: CalculateRowsAndColumns }, { token: AddVideosGrid }, { token: OnScreenChanges }, { token: ChangeVids }, { token: CompareActiveNames }, { token: CompareScreenStates }, { token: CreateSendTransport }, { token: ResumeSendTransportAudio }, { token: ReceiveAllPipedTransports }, { token: DisconnectSendTransportVideo }, { token: DisconnectSendTransportAudio }, { token: DisconnectSendTransportScreen }, { token: GetPipedProducersAlt }, { token: SignalNewConsumerTransport }, { token: ConnectRecvTransport }, { token: ReUpdateInter }, { token: UpdateParticipantAudioDecibels }, { token: CloseAndResize }, { token: AutoAdjust }, { token: SwitchUserVideoAlt }, { token: SwitchUserVideo }, { token: SwitchUserAudio }, { token: GetDomains }, { token: FormatNumber }, { token: ConnectIps }, { token: CreateDeviceClient }, { token: HandleCreatePoll }, { token: HandleEndPoll }, { token: HandleVotePoll }, { token: CaptureCanvasStream }, { token: ResumePauseAudioStreams }, { token: ProcessConsumerTransportsAudio }, { token: LaunchMenuModal }, { token: LaunchRecording }, { token: StartRecording }, { token: ConfirmRecording }, { token: LaunchWaiting }, { token: launchCoHost }, { token: LaunchMediaSettings }, { token: LaunchDisplaySettings }, { token: LaunchSettings }, { token: LaunchRequests }, { token: LaunchParticipants }, { token: LaunchMessages }, { token: LaunchConfirmExit }, { token: LaunchPoll }, { token: LaunchBreakoutRooms }, { token: LaunchConfigureWhiteboard }, { token: StartMeetingProgressTimer }, { token: UpdateRecording }, { token: StopRecording }, { token: UserWaiting }, { token: PersonJoined }, { token: AllWaitingRoomMembers }, { token: RoomRecordParams }, { token: BanParticipant }, { token: UpdatedCoHost }, { token: ParticipantRequested }, { token: ScreenProducerId }, { token: UpdateMediaSettings }, { token: ProducerMediaPaused }, { token: ProducerMediaResumed }, { token: ProducerMediaClosed }, { token: ControlMediaHost }, { token: MeetingEnded }, { token: DisconnectUserSelf }, { token: ReceiveMessage }, { token: MeetingTimeRemaining }, { token: MeetingStillThere }, { token: StartRecords }, { token: ReInitiateRecording }, { token: RecordingNotice }, { token: TimeLeftRecording }, { token: StoppedRecording }, { token: HostRequestResponse }, { token: AllMembers }, { token: AllMembersRest }, { token: Disconnect }, { token: PollUpdated }, { token: BreakoutRoomUpdated }, { token: SocketManager }, { token: JoinRoomClient }, { token: UpdateRoomParametersClient }, { token: ClickVideo }, { token: ClickAudio }, { token: ClickScreenShare }, { token: StreamSuccessVideo }, { token: StreamSuccessAudio }, { token: StreamSuccessScreen }, { token: StreamSuccessAudioSwitch }, { token: CheckPermission }, { token: UpdateConsumingDomains }, { token: ReceiveRoomMessages }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MediasfuWebinar, isStandalone: true, selector: "app-mediasfu-webinar", inputs: { PrejoinPage: "PrejoinPage", credentials: "credentials", useLocalUIMode: "useLocalUIMode", seedData: "seedData", useSeed: "useSeed", imgSrc: "imgSrc" }, host: { listeners: { "window:resize": "handleResize()", "window:orientationchange": "handleResize()" } }, providers: [CookieService], ngImport: i0, template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component>
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: BreakoutRoomsModal, selector: "app-breakout-rooms-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onBreakoutRoomsClose"] }, { kind: "component", type: BackgroundModal, selector: "app-background-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onClose"] }, { kind: "component", type: CoHostModal, selector: "app-co-host-modal", inputs: ["isCoHostModalVisible", "currentCohost", "participants", "coHostResponsibility", "position", "backgroundColor", "roomName", "showAlert", "updateCoHostResponsibility", "updateCoHost", "updateIsCoHostModalVisible", "socket", "onCoHostClose", "onModifyCoHost"] }, { kind: "component", type: AlertComponent, selector: "app-alert-component", inputs: ["visible", "message", "type", "duration", "textColor", "onHide"] }, { kind: "component", type: AudioGrid, selector: "app-audio-grid", inputs: ["componentsToRender"] }, { kind: "component", type: ControlButtonsComponent, selector: "app-control-buttons-component", inputs: ["buttons", "buttonColor", "buttonBackgroundColor", "alignment", "vertical", "buttonsContainerStyle"] }, { kind: "component", type: FlexibleGrid, selector: "app-flexible-grid", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "backgroundColor"] }, { kind: "component", type: FlexibleVideo, selector: "app-flexible-video", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "showAspect", "backgroundColor", "Screenboard", "annotateScreenStream", "localStreamScreen"] }, { kind: "component", type: LoadingModal, selector: "app-loading-modal", inputs: ["isVisible", "backgroundColor", "displayColor"] }, { kind: "component", type: Pagination, selector: "app-pagination", inputs: ["totalPages", "currentUserPage", "handlePageChange", "position", "location", "direction", "buttonsContainerStyle", "activePageStyle", "inactivePageStyle", "backgroundColor", "paginationHeight", "showAspect", "parameters"] }, { kind: "component", type: SubAspectComponent, selector: "app-sub-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFractionSub"] }, { kind: "component", type: DisplaySettingsModal, selector: "app-display-settings-modal", inputs: ["isDisplaySettingsModalVisible", "onDisplaySettingsClose", "onModifyDisplaySettings", "parameters", "position", "backgroundColor"] }, { kind: "component", type: EventSettingsModal, selector: "app-event-settings-modal", inputs: ["isEventSettingsModalVisible", "onEventSettingsClose", "onModifyEventSettings", "position", "backgroundColor", "audioSetting", "videoSetting", "screenshareSetting", "chatSetting", "updateAudioSetting", "updateVideoSetting", "updateScreenshareSetting", "updateChatSetting", "updateIsSettingsModalVisible", "roomName", "socket", "showAlert"] }, { kind: "component", type: ConfirmExitModal, selector: "app-confirm-exit-modal", inputs: ["isConfirmExitModalVisible", "onConfirmExitClose", "position", "backgroundColor", "exitEventOnConfirm", "member", "ban", "roomName", "socket", "islevel"] }, { kind: "component", type: MediaSettingsModal, selector: "app-media-settings-modal", inputs: ["isMediaSettingsModalVisible", "onMediaSettingsClose", "switchCameraOnPress", "switchVideoOnPress", "switchAudioOnPress", "parameters", "position", "backgroundColor"] }, { kind: "component", type: MenuModal, selector: "app-menu-modal", inputs: ["backgroundColor", "isVisible", "customButtons", "shareButtons", "position", "roomName", "adminPasscode", "islevel", "eventType", "onClose"] }, { kind: "component", type: MessagesModal, selector: "app-messages-modal", inputs: ["isMessagesModalVisible", "onMessagesClose", "onSendMessagePress", "messages", "position", "backgroundColor", "activeTabBackgroundColor", "eventType", "member", "islevel", "coHostResponsibility", "coHost", "startDirectMessage", "directMessageDetails", "updateStartDirectMessage", "updateDirectMessageDetails", "showAlert", "roomName", "socket", "chatSetting"] }, { kind: "component", type: ConfirmHereModal, selector: "app-confirm-here-modal", inputs: ["isConfirmHereModalVisible", "position", "backgroundColor", "displayColor", "onConfirmHereClose", "countdownDuration", "socket", "roomName", "member"] }, { kind: "component", type: ShareEventModal, selector: "app-share-event-modal", inputs: ["backgroundColor", "isShareEventModalVisible", "onShareEventClose", "roomName", "adminPasscode", "islevel", "position", "shareButtons", "eventType"] }, { kind: "component", type: ParticipantsModal, selector: "app-participants-modal", inputs: ["isParticipantsModalVisible", "onParticipantsClose", "onParticipantsFilterChange", "participantsCounter", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "parameters", "position", "backgroundColor"] }, { kind: "component", type: PollModal, selector: "app-poll-modal", inputs: ["isPollModalVisible", "onClose", "position", "backgroundColor", "member", "islevel", "polls", "poll", "socket", "roomName", "showAlert", "updateIsPollModalVisible", "handleCreatePoll", "handleEndPoll", "handleVotePoll"] }, { kind: "component", type: RecordingModal, selector: "app-recording-modal", inputs: ["isRecordingModalVisible", "onClose", "backgroundColor", "position", "confirmRecording", "startRecording", "parameters"] }, { kind: "component", type: RequestsModal, selector: "app-requests-modal", inputs: ["isRequestsModalVisible", "requestCounter", "requestList", "roomName", "socket", "backgroundColor", "position", "parameters", "onRequestClose", "onRequestFilterChange", "onRequestItemPress", "updateRequestList"] }, { kind: "component", type: MainAspectComponent, selector: "app-main-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "updateIsWideScreen", "updateIsMediumScreen", "updateIsSmallScreen"] }, { kind: "component", type: MainContainerComponent, selector: "app-main-container-component", inputs: ["backgroundColor", "containerWidthFraction", "containerHeightFraction", "marginLeft", "marginRight", "marginTop", "marginBottom", "padding"] }, { kind: "component", type: MainGridComponent, selector: "app-main-grid-component", inputs: ["backgroundColor", "mainSize", "height", "width", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: MainScreenComponent, selector: "app-main-screen-component", inputs: ["mainSize", "doStack", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "showControls", "updateComponentSizes"] }, { kind: "component", type: OtherGridComponent, selector: "app-other-grid-component", inputs: ["backgroundColor", "width", "height", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: ScreenboardModal, selector: "app-screenboard-modal", inputs: ["parameters", "isVisible", "onClose", "position", "backgroundColor"] }, { kind: "component", type: Whiteboard, selector: "app-whiteboard", inputs: ["customWidth", "customHeight", "parameters", "showAspect"] }, { kind: "component", type: ConfigureWhiteboardModal, selector: "app-configure-whiteboard-modal", inputs: ["isVisible", "parameters", "backgroundColor", "position", "onConfigureWhiteboardClose"] }, { kind: "component", type: WaitingRoomModal, selector: "app-waiting-room-modal", inputs: ["isWaitingModalVisible", "waitingRoomCounter", "waitingRoomList", "roomName", "socket", "position", "backgroundColor", "parameters", "onWaitingRoomClose", "onWaitingRoomFilterChange", "updateWaitingList", "onWaitingRoomItemPress"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediasfuWebinar, decorators: [{
            type: Component,
            args: [{ selector: 'app-mediasfu-webinar', standalone: true, imports: [
                        RouterOutlet,
                        CommonModule,
                        BreakoutRoomsModal,
                        BackgroundModal,
                        CoHostModal,
                        AlertComponent,
                        AudioGrid,
                        ControlButtonsAltComponent,
                        ControlButtonsComponent,
                        FlexibleGrid,
                        FlexibleVideo,
                        LoadingModal,
                        Pagination,
                        SubAspectComponent,
                        DisplaySettingsModal,
                        EventSettingsModal,
                        ConfirmExitModal,
                        MediaSettingsModal,
                        MenuModal,
                        MessagesModal,
                        ConfirmHereModal,
                        ShareEventModal,
                        WelcomePage,
                        ParticipantsModal,
                        PollModal,
                        RecordingModal,
                        RequestsModal,
                        MainAspectComponent,
                        MainContainerComponent,
                        MainGridComponent,
                        MainScreenComponent,
                        OtherGridComponent,
                        Screenboard,
                        ScreenboardModal,
                        Whiteboard,
                        ConfigureWhiteboardModal,
                        WaitingRoomModal,
                        MenuWidget,
                        MessageWidget,
                        MenuRecordWidget,
                        RecordTimerWidget,
                        MenuParticipantsWidget,
                        ScreenShareWidget,
                    ], template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component>
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </div>
  `, providers: [CookieService] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: UpdateMiniCardsGrid }, { type: MixStreams }, { type: DispStreams }, { type: StopShareScreen }, { type: CheckScreenShare }, { type: StartShareScreen }, { type: RequestScreenShare }, { type: ReorderStreams }, { type: PrepopulateUserMedia }, { type: GetVideos }, { type: RePort }, { type: Trigger }, { type: ConsumerResume }, { type: ConnectSendTransport }, { type: ConnectSendTransportAudio }, { type: ConnectSendTransportVideo }, { type: ConnectSendTransportScreen }, { type: ProcessConsumerTransports }, { type: ResumePauseStreams }, { type: Readjust }, { type: CheckGrid }, { type: GetEstimate }, { type: CalculateRowsAndColumns }, { type: AddVideosGrid }, { type: OnScreenChanges }, { type: ChangeVids }, { type: CompareActiveNames }, { type: CompareScreenStates }, { type: CreateSendTransport }, { type: ResumeSendTransportAudio }, { type: ReceiveAllPipedTransports }, { type: DisconnectSendTransportVideo }, { type: DisconnectSendTransportAudio }, { type: DisconnectSendTransportScreen }, { type: GetPipedProducersAlt }, { type: SignalNewConsumerTransport }, { type: ConnectRecvTransport }, { type: ReUpdateInter }, { type: UpdateParticipantAudioDecibels }, { type: CloseAndResize }, { type: AutoAdjust }, { type: SwitchUserVideoAlt }, { type: SwitchUserVideo }, { type: SwitchUserAudio }, { type: GetDomains }, { type: FormatNumber }, { type: ConnectIps }, { type: CreateDeviceClient }, { type: HandleCreatePoll }, { type: HandleEndPoll }, { type: HandleVotePoll }, { type: CaptureCanvasStream }, { type: ResumePauseAudioStreams }, { type: ProcessConsumerTransportsAudio }, { type: LaunchMenuModal }, { type: LaunchRecording }, { type: StartRecording }, { type: ConfirmRecording }, { type: LaunchWaiting }, { type: launchCoHost }, { type: LaunchMediaSettings }, { type: LaunchDisplaySettings }, { type: LaunchSettings }, { type: LaunchRequests }, { type: LaunchParticipants }, { type: LaunchMessages }, { type: LaunchConfirmExit }, { type: LaunchPoll }, { type: LaunchBreakoutRooms }, { type: LaunchConfigureWhiteboard }, { type: StartMeetingProgressTimer }, { type: UpdateRecording }, { type: StopRecording }, { type: UserWaiting }, { type: PersonJoined }, { type: AllWaitingRoomMembers }, { type: RoomRecordParams }, { type: BanParticipant }, { type: UpdatedCoHost }, { type: ParticipantRequested }, { type: ScreenProducerId }, { type: UpdateMediaSettings }, { type: ProducerMediaPaused }, { type: ProducerMediaResumed }, { type: ProducerMediaClosed }, { type: ControlMediaHost }, { type: MeetingEnded }, { type: DisconnectUserSelf }, { type: ReceiveMessage }, { type: MeetingTimeRemaining }, { type: MeetingStillThere }, { type: StartRecords }, { type: ReInitiateRecording }, { type: RecordingNotice }, { type: TimeLeftRecording }, { type: StoppedRecording }, { type: HostRequestResponse }, { type: AllMembers }, { type: AllMembersRest }, { type: Disconnect }, { type: PollUpdated }, { type: BreakoutRoomUpdated }, { type: SocketManager }, { type: JoinRoomClient }, { type: UpdateRoomParametersClient }, { type: ClickVideo }, { type: ClickAudio }, { type: ClickScreenShare }, { type: StreamSuccessVideo }, { type: StreamSuccessAudio }, { type: StreamSuccessScreen }, { type: StreamSuccessAudioSwitch }, { type: CheckPermission }, { type: UpdateConsumingDomains }, { type: ReceiveRoomMessages }], propDecorators: { PrejoinPage: [{
                type: Input
            }], credentials: [{
                type: Input
            }], useLocalUIMode: [{
                type: Input
            }], seedData: [{
                type: Input
            }], useSeed: [{
                type: Input
            }], imgSrc: [{
                type: Input
            }], handleResize: [{
                type: HostListener,
                args: ['window:resize']
            }, {
                type: HostListener,
                args: ['window:orientationchange']
            }] } });

class MediasfuConference {
    cdr;
    injector;
    updateMiniCardsGrid;
    mixStreams;
    dispStreams;
    stopShareScreen;
    checkScreenShare;
    startShareScreen;
    requestScreenShare;
    reorderStreams;
    prepopulateUserMedia;
    getVideos;
    rePort;
    trigger;
    consumerResume;
    connectSendTransport;
    connectSendTransportAudio;
    connectSendTransportVideo;
    connectSendTransportScreen;
    processConsumerTransports;
    resumePauseStreams;
    readjust;
    checkGrid;
    getEstimate;
    calculateRowsAndColumns;
    addVideosGrid;
    onScreenChanges;
    changeVids;
    compareActiveNames;
    compareScreenStates;
    createSendTransport;
    resumeSendTransportAudio;
    receiveAllPipedTransports;
    disconnectSendTransportVideo;
    disconnectSendTransportAudio;
    disconnectSendTransportScreen;
    getPipedProducersAlt;
    signalNewConsumerTransport;
    connectRecvTransport;
    reUpdateInter;
    updateParticipantAudioDecibels;
    closeAndResize;
    autoAdjust;
    switchUserVideoAlt;
    switchUserVideo;
    switchUserAudio;
    getDomains;
    formatNumber;
    connectIps;
    createDeviceClient;
    handleCreatePoll;
    handleEndPoll;
    handleVotePoll;
    captureCanvasStream;
    resumePauseAudioStreams;
    processConsumerTransportsAudio;
    launchMenuModal;
    launchRecording;
    startRecording;
    confirmRecording;
    launchWaiting;
    launchCoHost;
    launchMediaSettings;
    launchDisplaySettings;
    launchSettings;
    launchRequests;
    launchParticipants;
    launchMessages;
    launchConfirmExit;
    launchPoll;
    launchBreakoutRooms;
    launchConfigureWhiteboard;
    startMeetingProgressTimer;
    updateRecording;
    stopRecording;
    userWaiting;
    personJoined;
    allWaitingRoomMembers;
    roomRecordParams;
    banParticipant;
    updatedCoHost;
    participantRequested;
    screenProducerId;
    updateMediaSettings;
    producerMediaPaused;
    producerMediaResumed;
    producerMediaClosed;
    controlMediaHost;
    meetingEnded;
    disconnectUserSelf;
    receiveMessage;
    meetingTimeRemaining;
    meetingStillThere;
    startRecords;
    reInitiateRecording;
    recordingNotice;
    timeLeftRecording;
    stoppedRecording;
    hostRequestResponse;
    allMembers;
    allMembersRest;
    disconnect;
    pollUpdated;
    breakoutRoomUpdated;
    socketManager;
    joinRoomClient;
    updateRoomParametersClient;
    clickVideo;
    clickAudio;
    clickScreenShare;
    streamSuccessVideo;
    streamSuccessAudio;
    streamSuccessScreen;
    streamSuccessAudioSwitch;
    checkPermission;
    updateConsumingDomains;
    receiveRoomMessages;
    PrejoinPage = WelcomePage;
    credentials = { apiUserName: '', apiKey: '' };
    useLocalUIMode = false;
    seedData;
    useSeed = false;
    imgSrc = 'https://mediasfu.com/images/logo192.png';
    title = 'MediaSFU-Conference';
    mainHeightWidthSubscription;
    validatedSubscription;
    islevelSubscription;
    coHostSubscription;
    buttonSubscriptions = [];
    ScreenboardSubscription;
    recordingSubscription;
    constructor(cdr, injector, updateMiniCardsGrid, mixStreams, dispStreams, stopShareScreen, checkScreenShare, startShareScreen, requestScreenShare, reorderStreams, prepopulateUserMedia, getVideos, rePort, trigger, consumerResume, connectSendTransport, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, processConsumerTransports, resumePauseStreams, readjust, checkGrid, getEstimate, calculateRowsAndColumns, addVideosGrid, onScreenChanges, changeVids, compareActiveNames, compareScreenStates, createSendTransport, resumeSendTransportAudio, receiveAllPipedTransports, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, getPipedProducersAlt, signalNewConsumerTransport, connectRecvTransport, reUpdateInter, updateParticipantAudioDecibels, closeAndResize, autoAdjust, switchUserVideoAlt, switchUserVideo, switchUserAudio, getDomains, formatNumber, connectIps, createDeviceClient, handleCreatePoll, handleEndPoll, handleVotePoll, captureCanvasStream, resumePauseAudioStreams, processConsumerTransportsAudio, launchMenuModal, launchRecording, startRecording, confirmRecording, launchWaiting, launchCoHost, launchMediaSettings, launchDisplaySettings, launchSettings, launchRequests, launchParticipants, launchMessages, launchConfirmExit, launchPoll, launchBreakoutRooms, launchConfigureWhiteboard, startMeetingProgressTimer, updateRecording, stopRecording, userWaiting, personJoined, allWaitingRoomMembers, roomRecordParams, banParticipant, updatedCoHost, participantRequested, screenProducerId, updateMediaSettings, producerMediaPaused, producerMediaResumed, producerMediaClosed, controlMediaHost, meetingEnded, disconnectUserSelf, receiveMessage, meetingTimeRemaining, meetingStillThere, startRecords, reInitiateRecording, recordingNotice, timeLeftRecording, stoppedRecording, hostRequestResponse, allMembers, allMembersRest, disconnect, pollUpdated, breakoutRoomUpdated, socketManager, joinRoomClient, updateRoomParametersClient, clickVideo, clickAudio, clickScreenShare, streamSuccessVideo, streamSuccessAudio, streamSuccessScreen, streamSuccessAudioSwitch, checkPermission, updateConsumingDomains, receiveRoomMessages) {
        this.cdr = cdr;
        this.injector = injector;
        this.updateMiniCardsGrid = updateMiniCardsGrid;
        this.mixStreams = mixStreams;
        this.dispStreams = dispStreams;
        this.stopShareScreen = stopShareScreen;
        this.checkScreenShare = checkScreenShare;
        this.startShareScreen = startShareScreen;
        this.requestScreenShare = requestScreenShare;
        this.reorderStreams = reorderStreams;
        this.prepopulateUserMedia = prepopulateUserMedia;
        this.getVideos = getVideos;
        this.rePort = rePort;
        this.trigger = trigger;
        this.consumerResume = consumerResume;
        this.connectSendTransport = connectSendTransport;
        this.connectSendTransportAudio = connectSendTransportAudio;
        this.connectSendTransportVideo = connectSendTransportVideo;
        this.connectSendTransportScreen = connectSendTransportScreen;
        this.processConsumerTransports = processConsumerTransports;
        this.resumePauseStreams = resumePauseStreams;
        this.readjust = readjust;
        this.checkGrid = checkGrid;
        this.getEstimate = getEstimate;
        this.calculateRowsAndColumns = calculateRowsAndColumns;
        this.addVideosGrid = addVideosGrid;
        this.onScreenChanges = onScreenChanges;
        this.changeVids = changeVids;
        this.compareActiveNames = compareActiveNames;
        this.compareScreenStates = compareScreenStates;
        this.createSendTransport = createSendTransport;
        this.resumeSendTransportAudio = resumeSendTransportAudio;
        this.receiveAllPipedTransports = receiveAllPipedTransports;
        this.disconnectSendTransportVideo = disconnectSendTransportVideo;
        this.disconnectSendTransportAudio = disconnectSendTransportAudio;
        this.disconnectSendTransportScreen = disconnectSendTransportScreen;
        this.getPipedProducersAlt = getPipedProducersAlt;
        this.signalNewConsumerTransport = signalNewConsumerTransport;
        this.connectRecvTransport = connectRecvTransport;
        this.reUpdateInter = reUpdateInter;
        this.updateParticipantAudioDecibels = updateParticipantAudioDecibels;
        this.closeAndResize = closeAndResize;
        this.autoAdjust = autoAdjust;
        this.switchUserVideoAlt = switchUserVideoAlt;
        this.switchUserVideo = switchUserVideo;
        this.switchUserAudio = switchUserAudio;
        this.getDomains = getDomains;
        this.formatNumber = formatNumber;
        this.connectIps = connectIps;
        this.createDeviceClient = createDeviceClient;
        this.handleCreatePoll = handleCreatePoll;
        this.handleEndPoll = handleEndPoll;
        this.handleVotePoll = handleVotePoll;
        this.captureCanvasStream = captureCanvasStream;
        this.resumePauseAudioStreams = resumePauseAudioStreams;
        this.processConsumerTransportsAudio = processConsumerTransportsAudio;
        this.launchMenuModal = launchMenuModal;
        this.launchRecording = launchRecording;
        this.startRecording = startRecording;
        this.confirmRecording = confirmRecording;
        this.launchWaiting = launchWaiting;
        this.launchCoHost = launchCoHost;
        this.launchMediaSettings = launchMediaSettings;
        this.launchDisplaySettings = launchDisplaySettings;
        this.launchSettings = launchSettings;
        this.launchRequests = launchRequests;
        this.launchParticipants = launchParticipants;
        this.launchMessages = launchMessages;
        this.launchConfirmExit = launchConfirmExit;
        this.launchPoll = launchPoll;
        this.launchBreakoutRooms = launchBreakoutRooms;
        this.launchConfigureWhiteboard = launchConfigureWhiteboard;
        this.startMeetingProgressTimer = startMeetingProgressTimer;
        this.updateRecording = updateRecording;
        this.stopRecording = stopRecording;
        this.userWaiting = userWaiting;
        this.personJoined = personJoined;
        this.allWaitingRoomMembers = allWaitingRoomMembers;
        this.roomRecordParams = roomRecordParams;
        this.banParticipant = banParticipant;
        this.updatedCoHost = updatedCoHost;
        this.participantRequested = participantRequested;
        this.screenProducerId = screenProducerId;
        this.updateMediaSettings = updateMediaSettings;
        this.producerMediaPaused = producerMediaPaused;
        this.producerMediaResumed = producerMediaResumed;
        this.producerMediaClosed = producerMediaClosed;
        this.controlMediaHost = controlMediaHost;
        this.meetingEnded = meetingEnded;
        this.disconnectUserSelf = disconnectUserSelf;
        this.receiveMessage = receiveMessage;
        this.meetingTimeRemaining = meetingTimeRemaining;
        this.meetingStillThere = meetingStillThere;
        this.startRecords = startRecords;
        this.reInitiateRecording = reInitiateRecording;
        this.recordingNotice = recordingNotice;
        this.timeLeftRecording = timeLeftRecording;
        this.stoppedRecording = stoppedRecording;
        this.hostRequestResponse = hostRequestResponse;
        this.allMembers = allMembers;
        this.allMembersRest = allMembersRest;
        this.disconnect = disconnect;
        this.pollUpdated = pollUpdated;
        this.breakoutRoomUpdated = breakoutRoomUpdated;
        this.socketManager = socketManager;
        this.joinRoomClient = joinRoomClient;
        this.updateRoomParametersClient = updateRoomParametersClient;
        this.clickVideo = clickVideo;
        this.clickAudio = clickAudio;
        this.clickScreenShare = clickScreenShare;
        this.streamSuccessVideo = streamSuccessVideo;
        this.streamSuccessAudio = streamSuccessAudio;
        this.streamSuccessScreen = streamSuccessScreen;
        this.streamSuccessAudioSwitch = streamSuccessAudioSwitch;
        this.checkPermission = checkPermission;
        this.updateConsumingDomains = updateConsumingDomains;
        this.receiveRoomMessages = receiveRoomMessages;
    }
    createInjector(inputs) {
        const inj = Injector.create({
            providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
            parent: this.injector,
        });
        return inj;
    }
    // Initial values
    mediaSFUFunctions = () => {
        return {
            updateMiniCardsGrid: this.updateMiniCardsGrid?.updateMiniCardsGrid ||
                (() => {
                    console.log('none');
                }),
            mixStreams: this.mixStreams?.mixStreams ||
                (() => {
                    console.log('none');
                }),
            dispStreams: this.dispStreams?.dispStreams ||
                (() => {
                    console.log('none');
                }),
            stopShareScreen: this.stopShareScreen?.stopShareScreen ||
                (() => {
                    console.log('none');
                }),
            checkScreenShare: this.checkScreenShare?.checkScreenShare ||
                (() => {
                    console.log('none');
                }),
            startShareScreen: this.startShareScreen?.startShareScreen ||
                (() => {
                    console.log('none');
                }),
            requestScreenShare: this.requestScreenShare?.requestScreenShare ||
                (() => {
                    console.log('none');
                }),
            reorderStreams: this.reorderStreams?.reorderStreams ||
                (() => {
                    console.log('none');
                }),
            prepopulateUserMedia: this.prepopulateUserMedia?.prepopulateUserMedia ||
                (() => {
                    console.log('none');
                }),
            getVideos: this.getVideos?.getVideos ||
                (() => {
                    console.log('none');
                }),
            rePort: this.rePort?.rePort ||
                (() => {
                    console.log('none');
                }),
            trigger: this.trigger?.trigger ||
                (() => {
                    console.log('none');
                }),
            consumerResume: this.consumerResume?.consumerResume ||
                (() => {
                    console.log('none');
                }),
            connectSendTransport: this.connectSendTransport?.connectSendTransport ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportAudio: this.connectSendTransportAudio?.connectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportVideo: this.connectSendTransportVideo?.connectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportScreen: this.connectSendTransportScreen?.connectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransports: this.processConsumerTransports?.processConsumerTransports ||
                (() => {
                    console.log('none');
                }),
            resumePauseStreams: this.resumePauseStreams?.resumePauseStreams ||
                (() => {
                    console.log('none');
                }),
            readjust: this.readjust?.readjust ||
                (() => {
                    console.log('none');
                }),
            checkGrid: this.checkGrid?.checkGrid ||
                (() => {
                    console.log('none');
                }),
            getEstimate: this.getEstimate?.getEstimate ||
                (() => {
                    console.log('none');
                }),
            calculateRowsAndColumns: this.calculateRowsAndColumns?.calculateRowsAndColumns ||
                (() => {
                    console.log('none');
                }),
            addVideosGrid: this.addVideosGrid?.addVideosGrid ||
                (() => {
                    console.log('none');
                }),
            onScreenChanges: this.onScreenChanges?.onScreenChanges ||
                (() => {
                    console.log('none');
                }),
            sleep: sleep ||
                (() => {
                    console.log('none');
                }),
            changeVids: this.changeVids?.changeVids ||
                (() => {
                    console.log('none');
                }),
            compareActiveNames: this.compareActiveNames?.compareActiveNames ||
                (() => {
                    console.log('none');
                }),
            compareScreenStates: this.compareScreenStates?.compareScreenStates ||
                (() => {
                    console.log('none');
                }),
            createSendTransport: this.createSendTransport?.createSendTransport ||
                (() => {
                    console.log('none');
                }),
            resumeSendTransportAudio: this.resumeSendTransportAudio?.resumeSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            receiveAllPipedTransports: this.receiveAllPipedTransports?.receiveAllPipedTransports ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportVideo: this.disconnectSendTransportVideo?.disconnectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportAudio: this.disconnectSendTransportAudio?.disconnectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportScreen: this.disconnectSendTransportScreen?.disconnectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            getPipedProducersAlt: this.getPipedProducersAlt?.getPipedProducersAlt ||
                (() => {
                    console.log('none');
                }),
            signalNewConsumerTransport: this.signalNewConsumerTransport?.signalNewConsumerTransport ||
                (() => {
                    console.log('none');
                }),
            connectRecvTransport: this.connectRecvTransport?.connectRecvTransport ||
                (() => {
                    console.log('none');
                }),
            reUpdateInter: this.reUpdateInter?.reUpdateInter ||
                (() => {
                    console.log('none');
                }),
            updateParticipantAudioDecibels: this.updateParticipantAudioDecibels?.updateParticipantAudioDecibels ||
                (() => {
                    console.log('none');
                }),
            closeAndResize: this.closeAndResize?.closeAndResize ||
                (() => {
                    console.log('none');
                }),
            autoAdjust: this.autoAdjust?.autoAdjust ||
                (() => {
                    console.log('none');
                }),
            switchUserVideoAlt: this.switchUserVideoAlt?.switchUserVideoAlt ||
                (() => {
                    console.log('none');
                }),
            switchUserVideo: this.switchUserVideo?.switchUserVideo ||
                (() => {
                    console.log('none');
                }),
            switchUserAudio: this.switchUserAudio?.switchUserAudio ||
                (() => {
                    console.log('none');
                }),
            getDomains: this.getDomains?.getDomains ||
                (() => {
                    console.log('none');
                }),
            formatNumber: this.formatNumber?.formatNumber ||
                (() => {
                    console.log('none');
                }),
            connectIps: this.connectIps?.connectIps ||
                (() => {
                    console.log('none');
                }),
            createDeviceClient: this.createDeviceClient?.createDeviceClient ||
                (() => {
                    console.log('none');
                }),
            handleCreatePoll: this.handleCreatePoll?.handleCreatePoll ||
                (() => {
                    console.log('none');
                }),
            handleEndPoll: this.handleEndPoll?.handleEndPoll ||
                (() => {
                    console.log('none');
                }),
            handleVotePoll: this.handleVotePoll?.handleVotePoll ||
                (() => {
                    console.log('none');
                }),
            captureCanvasStream: this.captureCanvasStream?.captureCanvasStream ||
                (() => {
                    console.log('none');
                }),
            resumePauseAudioStreams: this.resumePauseAudioStreams?.resumePauseAudioStreams ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransportsAudio: this.processConsumerTransportsAudio?.processConsumerTransportsAudio ||
                (() => {
                    console.log('none');
                }),
            checkPermission: this.checkPermission?.checkPermission ||
                (() => {
                    console.log('none');
                }),
            streamSuccessVideo: this.streamSuccessVideo?.streamSuccessVideo ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudio: this.streamSuccessAudio?.streamSuccessAudio ||
                (() => {
                    console.log('none');
                }),
            streamSuccessScreen: this.streamSuccessScreen?.streamSuccessScreen ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudioSwitch: this.streamSuccessAudioSwitch?.streamSuccessAudioSwitch ||
                (() => {
                    console.log('none');
                }),
            clickVideo: this.clickVideo?.clickVideo ||
                (() => {
                    console.log('none');
                }),
            clickAudio: this.clickAudio?.clickAudio ||
                (() => {
                    console.log('none');
                }),
            clickScreenShare: this.clickScreenShare?.clickScreenShare ||
                (() => {
                    console.log('none');
                }),
            requestPermissionCamera: this.requestPermissionCamera ||
                (() => {
                    console.log('none');
                }),
            requestPermissionAudio: this.requestPermissionAudio ||
                (() => {
                    console.log('none');
                }),
        };
    };
    validated = new BehaviorSubject(false);
    localUIMode = new BehaviorSubject(false);
    socket = new BehaviorSubject({});
    roomData = new BehaviorSubject(null);
    device = new BehaviorSubject(null);
    apiKey = new BehaviorSubject('021193742c935c4434d25d7592362575fcb6d6590b6c38334a2f3e06c83af758');
    apiUserName = new BehaviorSubject('abcdefgh');
    apiToken = new BehaviorSubject('');
    link = new BehaviorSubject('');
    roomName = new BehaviorSubject('');
    member = new BehaviorSubject('');
    adminPasscode = new BehaviorSubject('');
    islevel = new BehaviorSubject('1');
    coHost = new BehaviorSubject('No coHost');
    coHostResponsibility = new BehaviorSubject([
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ]);
    youAreCoHost = new BehaviorSubject(false);
    youAreHost = new BehaviorSubject(false);
    confirmedToRecord = new BehaviorSubject(false);
    meetingDisplayType = new BehaviorSubject('media');
    meetingVideoOptimized = new BehaviorSubject(false);
    eventType = new BehaviorSubject('conference');
    participants = new BehaviorSubject([]);
    filteredParticipants = new BehaviorSubject([]);
    participantsCounter = new BehaviorSubject(0);
    participantsFilter = new BehaviorSubject('');
    consume_sockets = new BehaviorSubject([]);
    rtpCapabilities = new BehaviorSubject(null);
    roomRecvIPs = new BehaviorSubject([]);
    meetingRoomParams = new BehaviorSubject(null);
    itemPageLimit = new BehaviorSubject(4);
    audioOnlyRoom = new BehaviorSubject(false);
    addForBasic = new BehaviorSubject(false);
    screenPageLimit = new BehaviorSubject(4);
    shareScreenStarted = new BehaviorSubject(false);
    shared = new BehaviorSubject(false);
    targetOrientation = new BehaviorSubject('landscape');
    targetResolution = new BehaviorSubject('sd');
    targetResolutionHost = new BehaviorSubject('sd');
    vidCons = new BehaviorSubject({ width: 640, height: 360 });
    frameRate = new BehaviorSubject(10);
    hParams = new BehaviorSubject({});
    vParams = new BehaviorSubject({});
    screenParams = new BehaviorSubject({});
    aParams = new BehaviorSubject({});
    recordingAudioPausesLimit = new BehaviorSubject(0);
    recordingAudioPausesCount = new BehaviorSubject(0);
    recordingAudioSupport = new BehaviorSubject(false);
    recordingAudioPeopleLimit = new BehaviorSubject(0);
    recordingAudioParticipantsTimeLimit = new BehaviorSubject(0);
    recordingVideoPausesCount = new BehaviorSubject(0);
    recordingVideoPausesLimit = new BehaviorSubject(0);
    recordingVideoSupport = new BehaviorSubject(false);
    recordingVideoPeopleLimit = new BehaviorSubject(0);
    recordingVideoParticipantsTimeLimit = new BehaviorSubject(0);
    recordingAllParticipantsSupport = new BehaviorSubject(false);
    recordingVideoParticipantsSupport = new BehaviorSubject(false);
    recordingAllParticipantsFullRoomSupport = new BehaviorSubject(false);
    recordingVideoParticipantsFullRoomSupport = new BehaviorSubject(false);
    recordingPreferredOrientation = new BehaviorSubject('landscape');
    recordingSupportForOtherOrientation = new BehaviorSubject(false);
    recordingMultiFormatsSupport = new BehaviorSubject(false);
    userRecordingParams = new BehaviorSubject({
        mainSpecs: {
            mediaOptions: 'video', // 'audio', 'video'
            audioOptions: 'all', // 'all', 'onScreen', 'host'
            videoOptions: 'all', // 'all', 'mainScreen'
            videoType: 'fullDisplay', // 'all', 'bestDisplay', 'fullDisplay'
            videoOptimized: false, // true, false
            recordingDisplayType: 'media', // 'media', 'video', 'all'
            addHLS: false, // true, false
        },
        dispSpecs: {
            nameTags: true, // true, false
            backgroundColor: '#000000', // '#000000', '#ffffff'
            nameTagsColor: '#ffffff', // '#000000', '#ffffff'
            orientationVideo: 'portrait', // 'landscape', 'portrait', 'all'
        },
    });
    canRecord = new BehaviorSubject(false);
    startReport = new BehaviorSubject(false);
    endReport = new BehaviorSubject(false);
    recordTimerInterval = new BehaviorSubject(null);
    recordStartTime = new BehaviorSubject(0);
    recordElapsedTime = new BehaviorSubject(0);
    isTimerRunning = new BehaviorSubject(false);
    canPauseResume = new BehaviorSubject(false);
    recordChangeSeconds = new BehaviorSubject(15000);
    pauseLimit = new BehaviorSubject(0);
    pauseRecordCount = new BehaviorSubject(0);
    canLaunchRecord = new BehaviorSubject(true);
    stopLaunchRecord = new BehaviorSubject(false);
    participantsAll = new BehaviorSubject([]);
    firstAll = new BehaviorSubject(false);
    updateMainWindow = new BehaviorSubject(false);
    first_round = new BehaviorSubject(false);
    landScaped = new BehaviorSubject(false);
    lock_screen = new BehaviorSubject(false);
    screenId = new BehaviorSubject('');
    allVideoStreams = new BehaviorSubject([]);
    newLimitedStreams = new BehaviorSubject([]);
    newLimitedStreamsIDs = new BehaviorSubject([]);
    activeSounds = new BehaviorSubject([]);
    screenShareIDStream = new BehaviorSubject('');
    screenShareNameStream = new BehaviorSubject('');
    adminIDStream = new BehaviorSubject('');
    adminNameStream = new BehaviorSubject('');
    youYouStream = new BehaviorSubject([]);
    youYouStreamIDs = new BehaviorSubject([]);
    localStream = new BehaviorSubject(null);
    recordStarted = new BehaviorSubject(false);
    recordResumed = new BehaviorSubject(false);
    recordPaused = new BehaviorSubject(false);
    recordStopped = new BehaviorSubject(false);
    adminRestrictSetting = new BehaviorSubject(false);
    videoRequestState = new BehaviorSubject(null);
    videoRequestTime = new BehaviorSubject(0);
    videoAction = new BehaviorSubject(false);
    localStreamVideo = new BehaviorSubject(null);
    userDefaultVideoInputDevice = new BehaviorSubject('');
    currentFacingMode = new BehaviorSubject('user');
    prevFacingMode = new BehaviorSubject('user');
    defVideoID = new BehaviorSubject('');
    allowed = new BehaviorSubject(false);
    dispActiveNames = new BehaviorSubject([]);
    p_dispActiveNames = new BehaviorSubject([]);
    activeNames = new BehaviorSubject([]);
    prevActiveNames = new BehaviorSubject([]);
    p_activeNames = new BehaviorSubject([]);
    membersReceived = new BehaviorSubject(false);
    deferScreenReceived = new BehaviorSubject(false);
    hostFirstSwitch = new BehaviorSubject(false);
    micAction = new BehaviorSubject(false);
    screenAction = new BehaviorSubject(false);
    chatAction = new BehaviorSubject(false);
    audioRequestState = new BehaviorSubject(null);
    screenRequestState = new BehaviorSubject(null);
    chatRequestState = new BehaviorSubject(null);
    audioRequestTime = new BehaviorSubject(0);
    screenRequestTime = new BehaviorSubject(0);
    chatRequestTime = new BehaviorSubject(0);
    updateRequestIntervalSeconds = new BehaviorSubject(240);
    oldSoundIds = new BehaviorSubject([]);
    hostLabel = new BehaviorSubject('Host');
    mainScreenFilled = new BehaviorSubject(false);
    localStreamScreen = new BehaviorSubject(null);
    screenAlreadyOn = new BehaviorSubject(false);
    chatAlreadyOn = new BehaviorSubject(false);
    redirectURL = new BehaviorSubject('');
    oldAllStreams = new BehaviorSubject([]);
    adminVidID = new BehaviorSubject('');
    streamNames = new BehaviorSubject([]);
    non_alVideoStreams = new BehaviorSubject([]);
    sortAudioLoudness = new BehaviorSubject(false);
    audioDecibels = new BehaviorSubject([]);
    mixed_alVideoStreams = new BehaviorSubject([]);
    non_alVideoStreams_muted = new BehaviorSubject([]);
    paginatedStreams = new BehaviorSubject([]);
    localStreamAudio = new BehaviorSubject(null);
    defAudioID = new BehaviorSubject('');
    userDefaultAudioInputDevice = new BehaviorSubject('');
    userDefaultAudioOutputDevice = new BehaviorSubject('');
    prevAudioInputDevice = new BehaviorSubject('');
    prevVideoInputDevice = new BehaviorSubject('');
    audioPaused = new BehaviorSubject(false);
    mainScreenPerson = new BehaviorSubject('');
    adminOnMainScreen = new BehaviorSubject(false);
    screenStates = new BehaviorSubject([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    prevScreenStates = new BehaviorSubject([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    updateDateState = new BehaviorSubject(null);
    lastUpdate = new BehaviorSubject(null);
    nForReadjustRecord = new BehaviorSubject(0);
    fixedPageLimit = new BehaviorSubject(4);
    removeAltGrid = new BehaviorSubject(false);
    nForReadjust = new BehaviorSubject(0);
    reorderInterval = new BehaviorSubject(30000);
    fastReorderInterval = new BehaviorSubject(10000);
    lastReorderTime = new BehaviorSubject(0);
    audStreamNames = new BehaviorSubject([]);
    currentUserPage = new BehaviorSubject(0);
    mainHeightWidth = new BehaviorSubject(this.eventType.value == 'webinar' ? 67 : this.eventType.value == 'broadcast' ? 100 : 0);
    prevMainHeightWidth = new BehaviorSubject(this.mainHeightWidth.value);
    prevDoPaginate = new BehaviorSubject(false);
    doPaginate = new BehaviorSubject(false);
    shareEnded = new BehaviorSubject(false);
    lStreams = new BehaviorSubject([]);
    chatRefStreams = new BehaviorSubject([]);
    controlHeight = new BehaviorSubject(this.eventType.value === 'webinar' || this.eventType.value === 'conference' ? 0 : 0.06);
    isWideScreen = new BehaviorSubject(false);
    isMediumScreen = new BehaviorSubject(false);
    isSmallScreen = new BehaviorSubject(false);
    addGrid = new BehaviorSubject(false);
    addAltGrid = new BehaviorSubject(false);
    gridRows = new BehaviorSubject(0);
    gridCols = new BehaviorSubject(0);
    altGridRows = new BehaviorSubject(0);
    altGridCols = new BehaviorSubject(0);
    numberPages = new BehaviorSubject(0);
    currentStreams = new BehaviorSubject([]);
    showMiniView = new BehaviorSubject(false);
    nStream = new BehaviorSubject(null);
    defer_receive = new BehaviorSubject(false);
    allAudioStreams = new BehaviorSubject([]);
    remoteScreenStream = new BehaviorSubject([]);
    screenProducer = new BehaviorSubject(null);
    gotAllVids = new BehaviorSubject(false);
    paginationHeightWidth = new BehaviorSubject(40);
    paginationDirection = new BehaviorSubject('horizontal');
    gridSizes = new BehaviorSubject({
        gridWidth: 0,
        gridHeight: 0,
        altGridWidth: 0,
        altGridHeight: 0,
    });
    screenForceFullDisplay = new BehaviorSubject(false);
    mainGridStream = new BehaviorSubject([]);
    otherGridStreams = new BehaviorSubject([]);
    audioOnlyStreams = new BehaviorSubject([]);
    videoInputs = new BehaviorSubject([]);
    audioInputs = new BehaviorSubject([]);
    meetingProgressTime = new BehaviorSubject('00:00:00');
    meetingElapsedTime = new BehaviorSubject(0);
    ref_participants = new BehaviorSubject([]);
    updateValidated = (value) => {
        this.validated.next(value);
    };
    updateSocket = (value) => {
        this.socket.next(value);
    };
    updateDevice = (value) => {
        this.device.next(value);
    };
    updateRoomData = (value) => {
        this.roomData.next(value);
    };
    updateApiKey = (value) => {
        this.apiKey.next(value);
    };
    updateApiUserName = (value) => {
        this.apiUserName.next(value);
    };
    updateApiToken = (value) => {
        this.apiToken.next(value);
    };
    updateLink = (value) => {
        this.link.next(value);
    };
    updateRoomName = (value) => {
        this.roomName.next(value);
    };
    updateMember = (value) => {
        this.member.next(value);
    };
    updateAdminPasscode = (value) => {
        this.adminPasscode.next(value);
    };
    updateIslevel = (value) => {
        this.islevel.next(value);
    };
    updateCoHost = (value) => {
        this.coHost.next(value);
    };
    updateCoHostResponsibility = (value) => {
        this.coHostResponsibility.next(value);
    };
    updateYouAreCoHost = (value) => {
        this.youAreCoHost.next(value);
    };
    updateYouAreHost = (value) => {
        this.youAreHost.next(value);
    };
    updateConfirmedToRecord = (value) => {
        this.confirmedToRecord.next(value);
    };
    updateMeetingDisplayType = (value) => {
        this.meetingDisplayType.next(value);
    };
    updateMeetingVideoOptimized = (value) => {
        this.meetingVideoOptimized.next(value);
    };
    updateEventType = (value) => {
        this.eventType.next(value);
        if (value != 'none') {
            try {
                setTimeout(() => {
                    this.handleResize();
                }, 2000);
            }
            catch {
                /* handle error */
            }
        }
    };
    updateParticipants = (value) => {
        this.participants.next(value);
        this.participantsCounter.next(value.length);
        this.filteredParticipants.next(this.participants.value);
    };
    updateFilteredParticipants = (value) => {
        this.filteredParticipants.next(value);
    };
    updateParticipantsCounter = (value) => {
        this.participantsCounter.next(value);
    };
    updateParticipantsFilter = (value) => {
        this.participantsFilter.next(value);
    };
    updateConsume_sockets = (value) => {
        this.consume_sockets.next(value);
    };
    updateRtpCapabilities = (value) => {
        this.rtpCapabilities.next(value);
    };
    updateRoomRecvIPs = (value) => {
        this.roomRecvIPs.next(value);
    };
    updateMeetingRoomParams = (value) => {
        this.meetingRoomParams.next(value);
    };
    updateItemPageLimit = (value) => {
        this.itemPageLimit.next(value);
    };
    updateAudioOnlyRoom = (value) => {
        this.audioOnlyRoom.next(value);
    };
    updateAddForBasic = (value) => {
        this.addForBasic.next(value);
    };
    updateScreenPageLimit = (value) => {
        this.screenPageLimit.next(value);
    };
    updateShareScreenStarted = (value) => {
        this.shareScreenStarted.next(value);
    };
    updateShared = (value) => {
        this.shared.next(value);
        this.screenShareActive.next(value);
        if (value) {
            setTimeout(async () => {
                window.dispatchEvent(new Event('resize'));
            }, 2000);
        }
    };
    updateTargetOrientation = (value) => {
        this.targetOrientation.next(value);
    };
    updateTargetResolution = (value) => {
        this.targetResolution.next(value);
    };
    updateTargetResolutionHost = (value) => {
        this.targetResolutionHost.next(value);
    };
    updateVidCons = (value) => {
        this.vidCons.next(value);
    };
    updateFrameRate = (value) => {
        this.frameRate.next(value);
    };
    updateHParams = (value) => {
        this.hParams.next(value);
    };
    updateVParams = (value) => {
        this.vParams.next(value);
    };
    updateScreenParams = (value) => {
        this.screenParams.next(value);
    };
    updateAParams = (value) => {
        this.aParams.next(value);
    };
    updateRecordingAudioPausesLimit = (value) => {
        this.recordingAudioPausesLimit.next(value);
    };
    updateRecordingAudioPausesCount = (value) => {
        this.recordingAudioPausesCount.next(value);
    };
    updateRecordingAudioSupport = (value) => {
        this.recordingAudioSupport.next(value);
    };
    updateRecordingAudioPeopleLimit = (value) => {
        this.recordingAudioPeopleLimit.next(value);
    };
    updateRecordingAudioParticipantsTimeLimit = (value) => {
        this.recordingAudioParticipantsTimeLimit.next(value);
    };
    updateRecordingVideoPausesCount = (value) => {
        this.recordingVideoPausesCount.next(value);
    };
    updateRecordingVideoPausesLimit = (value) => {
        this.recordingVideoPausesLimit.next(value);
    };
    updateRecordingVideoSupport = (value) => {
        this.recordingVideoSupport.next(value);
    };
    updateRecordingVideoPeopleLimit = (value) => {
        this.recordingVideoPeopleLimit.next(value);
    };
    updateRecordingVideoParticipantsTimeLimit = (value) => {
        this.recordingVideoParticipantsTimeLimit.next(value);
    };
    updateRecordingAllParticipantsSupport = (value) => {
        this.recordingAllParticipantsSupport.next(value);
    };
    updateRecordingVideoParticipantsSupport = (value) => {
        this.recordingVideoParticipantsSupport.next(value);
    };
    updateRecordingAllParticipantsFullRoomSupport = (value) => {
        this.recordingAllParticipantsFullRoomSupport.next(value);
    };
    updateRecordingVideoParticipantsFullRoomSupport = (value) => {
        this.recordingVideoParticipantsFullRoomSupport.next(value);
    };
    updateRecordingPreferredOrientation = (value) => {
        this.recordingPreferredOrientation.next(value);
    };
    updateRecordingSupportForOtherOrientation = (value) => {
        this.recordingSupportForOtherOrientation.next(value);
    };
    updateRecordingMultiFormatsSupport = (value) => {
        this.recordingMultiFormatsSupport.next(value);
    };
    updateUserRecordingParams = (value) => {
        this.userRecordingParams.next(value);
    };
    updateCanRecord = (value) => {
        this.canRecord.next(value);
    };
    updateStartReport = (value) => {
        this.startReport.next(value);
    };
    updateEndReport = (value) => {
        this.endReport.next(value);
    };
    updateRecordTimerInterval = (value) => {
        this.recordTimerInterval.next(value);
    };
    updateRecordStartTime = (value) => {
        this.recordStartTime.next(value);
    };
    updateRecordElapsedTime = (value) => {
        this.recordElapsedTime.next(value);
    };
    updateIsTimerRunning = (value) => {
        this.isTimerRunning.next(value);
    };
    updateCanPauseResume = (value) => {
        this.canPauseResume.next(value);
    };
    updateRecordChangeSeconds = (value) => {
        this.recordChangeSeconds.next(value);
    };
    updatePauseLimit = (value) => {
        this.pauseLimit.next(value);
    };
    updatePauseRecordCount = (value) => {
        this.pauseRecordCount.next(value);
    };
    updateCanLaunchRecord = (value) => {
        this.canLaunchRecord.next(value);
    };
    updateStopLaunchRecord = (value) => {
        this.stopLaunchRecord.next(value);
    };
    updateParticipantsAll = (value) => {
        this.participantsAll.next(value);
    };
    updateFirstAll = (value) => {
        this.firstAll.next(value);
    };
    updateUpdateMainWindow = (value) => {
        this.updateMainWindow.next(value);
    };
    updateFirst_round = (value) => {
        this.first_round.next(value);
    };
    updateLandScaped = (value) => {
        this.landScaped.next(value);
    };
    updateLock_screen = (value) => {
        this.lock_screen.next(value);
    };
    updateScreenId = (value) => {
        this.screenId.next(value);
    };
    updateAllVideoStreams = (value) => {
        this.allVideoStreams.next(value);
    };
    updateNewLimitedStreams = (value) => {
        this.newLimitedStreams.next(value);
    };
    updateNewLimitedStreamsIDs = (value) => {
        this.newLimitedStreamsIDs.next(value);
    };
    updateActiveSounds = (value) => {
        this.activeSounds.next(value);
    };
    updateScreenShareIDStream = (value) => {
        this.screenShareIDStream.next(value);
    };
    updateScreenShareNameStream = (value) => {
        this.screenShareNameStream.next(value);
    };
    updateAdminIDStream = (value) => {
        this.adminIDStream.next(value);
    };
    updateAdminNameStream = (value) => {
        this.adminNameStream.next(value);
    };
    updateYouYouStream = (value) => {
        this.youYouStream.next(value);
    };
    updateYouYouStreamIDs = (value) => {
        this.youYouStreamIDs.next(value);
    };
    updateLocalStream = (value) => {
        this.localStream.next(value);
    };
    updateRecordStarted = (value) => {
        this.recordStarted.next(value);
    };
    updateRecordResumed = (value) => {
        this.recordResumed.next(value);
    };
    updateRecordPaused = (value) => {
        this.recordPaused.next(value);
    };
    updateRecordStopped = (value) => {
        this.recordStopped.next(value);
    };
    updateAdminRestrictSetting = (value) => {
        this.adminRestrictSetting.next(value);
    };
    updateVideoRequestState = (value) => {
        this.videoRequestState.next(value);
    };
    updateVideoRequestTime = (value) => {
        this.videoRequestTime.next(value);
    };
    updateVideoAction = (value) => {
        this.videoAction.next(value);
    };
    updateLocalStreamVideo = (value) => {
        this.localStreamVideo.next(value);
    };
    updateUserDefaultVideoInputDevice = (value) => {
        this.userDefaultVideoInputDevice.next(value);
    };
    updateCurrentFacingMode = (value) => {
        this.currentFacingMode.next(value);
    };
    updatePrevFacingMode = (value) => {
        this.prevFacingMode.next(value);
    };
    updateDefVideoID = (value) => {
        this.defVideoID.next(value);
    };
    updateAllowed = (value) => {
        this.allowed.next(value);
    };
    updateDispActiveNames = (value) => {
        this.dispActiveNames.next(value);
    };
    updateP_dispActiveNames = (value) => {
        this.p_dispActiveNames.next(value);
    };
    updateActiveNames = (value) => {
        this.activeNames.next(value);
    };
    updatePrevActiveNames = (value) => {
        this.prevActiveNames.next(value);
    };
    updateP_activeNames = (value) => {
        this.p_activeNames.next(value);
    };
    updateMembersReceived = (value) => {
        this.membersReceived.next(value);
    };
    updateDeferScreenReceived = (value) => {
        this.deferScreenReceived.next(value);
    };
    updateHostFirstSwitch = (value) => {
        this.hostFirstSwitch.next(value);
    };
    updateMicAction = (value) => {
        this.micAction.next(value);
    };
    updateScreenAction = (value) => {
        this.screenAction.next(value);
    };
    updateChatAction = (value) => {
        this.chatAction.next(value);
    };
    updateAudioRequestState = (value) => {
        this.audioRequestState.next(value);
    };
    updateScreenRequestState = (value) => {
        this.screenRequestState.next(value);
    };
    updateChatRequestState = (value) => {
        this.chatRequestState.next(value);
    };
    updateAudioRequestTime = (value) => {
        this.audioRequestTime.next(value);
    };
    updateScreenRequestTime = (value) => {
        this.screenRequestTime.next(value);
    };
    updateChatRequestTime = (value) => {
        this.chatRequestTime.next(value);
    };
    updateOldSoundIds = (value) => {
        this.oldSoundIds.next(value);
    };
    updateHostLabel = (value) => {
        this.hostLabel.next(value);
    };
    updateMainScreenFilled = (value) => {
        this.mainScreenFilled.next(value);
    };
    updateLocalStreamScreen = (value) => {
        this.localStreamScreen.next(value);
    };
    updateScreenAlreadyOn = (value) => {
        this.screenAlreadyOn.next(value);
    };
    updateChatAlreadyOn = (value) => {
        this.chatAlreadyOn.next(value);
    };
    updateRedirectURL = (value) => {
        this.redirectURL.next(value);
    };
    updateOldAllStreams = (value) => {
        this.oldAllStreams.next(value);
    };
    updateAdminVidID = (value) => {
        this.adminVidID.next(value);
    };
    updateStreamNames = (value) => {
        this.streamNames.next(value);
    };
    updateNon_alVideoStreams = (value) => {
        this.non_alVideoStreams.next(value);
    };
    updateSortAudioLoudness = (value) => {
        this.sortAudioLoudness.next(value);
    };
    updateAudioDecibels = (value) => {
        this.audioDecibels.next(value);
    };
    updateMixed_alVideoStreams = (value) => {
        this.mixed_alVideoStreams.next(value);
    };
    updateNon_alVideoStreams_muted = (value) => {
        this.non_alVideoStreams_muted.next(value);
    };
    updatePaginatedStreams = (value) => {
        this.paginatedStreams.next(value);
    };
    updateLocalStreamAudio = (value) => {
        this.localStreamAudio.next(value);
    };
    updateDefAudioID = (value) => {
        this.defAudioID.next(value);
    };
    updateUserDefaultAudioInputDevice = (value) => {
        this.userDefaultAudioInputDevice.next(value);
    };
    updateUserDefaultAudioOutputDevice = (value) => {
        this.userDefaultAudioOutputDevice.next(value);
    };
    updatePrevAudioInputDevice = (value) => {
        this.prevAudioInputDevice.next(value);
    };
    updatePrevVideoInputDevice = (value) => {
        this.prevVideoInputDevice.next(value);
    };
    updateAudioPaused = (value) => {
        this.audioPaused.next(value);
    };
    updateMainScreenPerson = (value) => {
        this.mainScreenPerson.next(value);
    };
    updateAdminOnMainScreen = (value) => {
        this.adminOnMainScreen.next(value);
    };
    updateScreenStates = (value) => {
        this.screenStates.next(value);
    };
    updatePrevScreenStates = (value) => {
        this.prevScreenStates.next(value);
    };
    updateUpdateDateState = (value) => {
        this.updateDateState.next(value);
    };
    updateLastUpdate = (value) => {
        this.lastUpdate.next(value);
    };
    updateNForReadjustRecord = (value) => {
        this.nForReadjustRecord.next(value);
    };
    updateFixedPageLimit = (value) => {
        this.fixedPageLimit.next(value);
    };
    updateRemoveAltGrid = (value) => {
        this.removeAltGrid.next(value);
    };
    updateNForReadjust = (value) => {
        this.nForReadjust.next(value);
    };
    updateLastReorderTime = (value) => {
        this.lastReorderTime.next(value);
    };
    updateAudStreamNames = (value) => {
        this.audStreamNames.next(value);
    };
    updateCurrentUserPage = (value) => {
        this.currentUserPage.next(value);
    };
    updateMainHeightWidth = (value) => {
        this.mainHeightWidth.next(value);
    };
    updatePrevMainHeightWidth = (value) => {
        this.prevMainHeightWidth.next(value);
    };
    updatePrevDoPaginate = (value) => {
        this.prevDoPaginate.next(value);
    };
    updateDoPaginate = (value) => {
        this.doPaginate.next(value);
    };
    updateShareEnded = (value) => {
        this.shareEnded.next(value);
    };
    updateLStreams = (value) => {
        this.lStreams.next(value);
    };
    updateChatRefStreams = (value) => {
        this.chatRefStreams.next(value);
    };
    updateControlHeight = (value) => {
        this.controlHeight.next(value);
    };
    updateIsWideScreen = (value) => {
        this.isWideScreen.next(value);
    };
    updateIsMediumScreen = (value) => {
        this.isMediumScreen.next(value);
    };
    updateIsSmallScreen = (value) => {
        this.isSmallScreen.next(value);
    };
    updateAddGrid = (value) => {
        this.addGrid.next(value);
    };
    updateAddAltGrid = (value) => {
        this.addAltGrid.next(value);
    };
    updateGridRows = (value) => {
        this.gridRows.next(value);
    };
    updateGridCols = (value) => {
        this.gridCols.next(value);
    };
    updateAltGridRows = (value) => {
        this.altGridRows.next(value);
    };
    updateAltGridCols = (value) => {
        this.altGridCols.next(value);
    };
    updateNumberPages = (value) => {
        this.numberPages.next(value);
    };
    updateCurrentStreams = (value) => {
        this.currentStreams.next(value);
    };
    updateShowMiniView = (value) => {
        this.showMiniView.next(value);
    };
    updateNStream = (value) => {
        this.nStream.next(value);
    };
    updateDefer_receive = (value) => {
        this.defer_receive.next(value);
    };
    updateAllAudioStreams = (value) => {
        this.allAudioStreams.next(value);
    };
    updateRemoteScreenStream = (value) => {
        this.remoteScreenStream.next(value);
    };
    updateScreenProducer = (value) => {
        this.screenProducer.next(value);
    };
    updateGotAllVids = (value) => {
        this.gotAllVids.next(value);
    };
    updatePaginationHeightWidth = (value) => {
        this.paginationHeightWidth.next(value);
    };
    updatePaginationDirection = (value) => {
        this.paginationDirection.next(value);
    };
    updateGridSizes = (value) => {
        this.gridSizes.next(value);
    };
    updateScreenForceFullDisplay = (value) => {
        this.screenForceFullDisplay.next(value);
    };
    updateMainGridStream = (value) => {
        this.mainGridStream.next(value);
    };
    updateOtherGridStreams = (value) => {
        this.otherGridStreams.next(value);
    };
    updateAudioOnlyStreams = (value) => {
        this.audioOnlyStreams.next(value);
    };
    updateVideoInputs = (value) => {
        this.videoInputs.next(value);
    };
    updateAudioInputs = (value) => {
        this.audioInputs.next(value);
    };
    updateMeetingProgressTime = (value) => {
        this.meetingProgressTime.next(value);
    };
    updateMeetingElapsedTime = (value) => {
        this.meetingElapsedTime.next(value);
    };
    updateRef_participants = (value) => {
        this.ref_participants.next(value);
    };
    // Messages
    messages = new BehaviorSubject([]);
    startDirectMessage = new BehaviorSubject(false);
    directMessageDetails = new BehaviorSubject(null);
    showMessagesBadge = new BehaviorSubject(false);
    // Event Settings
    audioSetting = new BehaviorSubject('allow');
    videoSetting = new BehaviorSubject('allow');
    screenshareSetting = new BehaviorSubject('allow');
    chatSetting = new BehaviorSubject('allow');
    // Display Settings
    displayOption = new BehaviorSubject('media');
    autoWave = new BehaviorSubject(true);
    forceFullDisplay = new BehaviorSubject(true);
    prevForceFullDisplay = new BehaviorSubject(false);
    prevMeetingDisplayType = new BehaviorSubject('video');
    // Waiting Room
    waitingRoomFilter = new BehaviorSubject('');
    waitingRoomList = new BehaviorSubject(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    waitingRoomCounter = new BehaviorSubject(0);
    filteredWaitingRoomList = new BehaviorSubject(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    // Requests
    requestFilter = new BehaviorSubject('');
    requestList = new BehaviorSubject(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    requestCounter = new BehaviorSubject(0);
    filteredRequestList = new BehaviorSubject(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    // Total Requests and Waiting Room
    totalReqWait = new BehaviorSubject(0);
    // Alerts
    alertVisible = new BehaviorSubject(false);
    alertMessage = new BehaviorSubject('');
    alertType = new BehaviorSubject('success');
    alertDuration = new BehaviorSubject(3000);
    // Progress Timer
    progressTimerVisible = new BehaviorSubject(true);
    progressTimerValue = new BehaviorSubject(0);
    // Menu Modals
    isMenuModalVisible = new BehaviorSubject(false);
    isRecordingModalVisible = new BehaviorSubject(false);
    isSettingsModalVisible = new BehaviorSubject(false);
    isRequestsModalVisible = new BehaviorSubject(false);
    isWaitingModalVisible = new BehaviorSubject(false);
    isCoHostModalVisible = new BehaviorSubject(false);
    isMediaSettingsModalVisible = new BehaviorSubject(false);
    isDisplaySettingsModalVisible = new BehaviorSubject(false);
    // Other Modals
    isParticipantsModalVisible = new BehaviorSubject(false);
    isMessagesModalVisible = new BehaviorSubject(false);
    isConfirmExitModalVisible = new BehaviorSubject(false);
    isConfirmHereModalVisible = new BehaviorSubject(false);
    isShareEventModalVisible = new BehaviorSubject(false);
    isLoadingModalVisible = new BehaviorSubject(false);
    // Recording Options
    recordingMediaOptions = new BehaviorSubject('video');
    recordingAudioOptions = new BehaviorSubject('all');
    recordingVideoOptions = new BehaviorSubject('all');
    recordingVideoType = new BehaviorSubject('fullDisplay');
    recordingVideoOptimized = new BehaviorSubject(false);
    recordingDisplayType = new BehaviorSubject('video');
    recordingAddHLS = new BehaviorSubject(true);
    recordingNameTags = new BehaviorSubject(true);
    recordingBackgroundColor = new BehaviorSubject('#83c0e9');
    recordingNameTagsColor = new BehaviorSubject('#ffffff');
    recordingAddText = new BehaviorSubject(false);
    recordingCustomText = new BehaviorSubject('Add Text');
    recordingCustomTextPosition = new BehaviorSubject('top');
    recordingCustomTextColor = new BehaviorSubject('#ffffff');
    recordingOrientationVideo = new BehaviorSubject('landscape');
    clearedToResume = new BehaviorSubject(true);
    clearedToRecord = new BehaviorSubject(true);
    recordState = new BehaviorSubject('green');
    showRecordButtons = new BehaviorSubject(false);
    recordingProgressTime = new BehaviorSubject('00:00:00');
    audioSwitching = new BehaviorSubject(false);
    videoSwitching = new BehaviorSubject(false);
    // Media States
    videoAlreadyOn = new BehaviorSubject(false);
    audioAlreadyOn = new BehaviorSubject(false);
    componentSizes = new BehaviorSubject({
        mainHeight: 0,
        otherHeight: 0,
        mainWidth: 0,
        otherWidth: 0,
    });
    // Permissions
    hasCameraPermission = new BehaviorSubject(false);
    hasAudioPermission = new BehaviorSubject(false);
    // Transports
    transportCreated = new BehaviorSubject(false);
    transportCreatedVideo = new BehaviorSubject(false);
    transportCreatedAudio = new BehaviorSubject(false);
    transportCreatedScreen = new BehaviorSubject(false);
    producerTransport = new BehaviorSubject(null);
    videoProducer = new BehaviorSubject(null);
    params = new BehaviorSubject({});
    videoParams = new BehaviorSubject({});
    audioParams = new BehaviorSubject({});
    audioProducer = new BehaviorSubject(null);
    consumerTransports = new BehaviorSubject([]);
    consumingTransports = new BehaviorSubject([]);
    // Polls
    polls = new BehaviorSubject(this.useSeed && this.seedData?.polls ? this.seedData.polls : []);
    poll = new BehaviorSubject(null);
    isPollModalVisible = new BehaviorSubject(false);
    // Background
    customImage = new BehaviorSubject('');
    selectedImage = new BehaviorSubject('');
    segmentVideo = new BehaviorSubject(null);
    selfieSegmentation = new BehaviorSubject(null);
    pauseSegmentation = new BehaviorSubject(false);
    processedStream = new BehaviorSubject(null);
    keepBackground = new BehaviorSubject(false);
    backgroundHasChanged = new BehaviorSubject(false);
    virtualStream = new BehaviorSubject(null);
    mainCanvas = new BehaviorSubject(null);
    prevKeepBackground = new BehaviorSubject(false);
    appliedBackground = new BehaviorSubject(false);
    isBackgroundModalVisible = new BehaviorSubject(false);
    autoClickBackground = new BehaviorSubject(false);
    // Breakout Rooms
    breakoutRooms = new BehaviorSubject(this.useSeed && this.seedData?.breakoutRooms ? this.seedData.breakoutRooms : []);
    currentRoomIndex = new BehaviorSubject(0);
    canStartBreakout = new BehaviorSubject(false);
    breakOutRoomStarted = new BehaviorSubject(false);
    breakOutRoomEnded = new BehaviorSubject(false);
    hostNewRoom = new BehaviorSubject(-1);
    limitedBreakRoom = new BehaviorSubject([]);
    mainRoomsLength = new BehaviorSubject(0);
    memberRoom = new BehaviorSubject(-1);
    isBreakoutRoomsModalVisible = new BehaviorSubject(false);
    // Whiteboard
    whiteboardUsers = new BehaviorSubject(this.useSeed && this.seedData?.whiteboardUsers ? this.seedData.whiteboardUsers : []);
    currentWhiteboardIndex = new BehaviorSubject(0);
    canStartWhiteboard = new BehaviorSubject(false);
    whiteboardStarted = new BehaviorSubject(false);
    whiteboardEnded = new BehaviorSubject(false);
    whiteboardLimit = new BehaviorSubject(4);
    isWhiteboardModalVisible = new BehaviorSubject(false);
    isConfigureWhiteboardModalVisible = new BehaviorSubject(false);
    shapes = new BehaviorSubject([]);
    useImageBackground = new BehaviorSubject(true);
    redoStack = new BehaviorSubject([]);
    undoStack = new BehaviorSubject([]);
    canvasStream = new BehaviorSubject(null);
    canvasWhiteboard = new BehaviorSubject(null);
    // Screenboard
    canvasScreenboard = new BehaviorSubject(null);
    processedScreenStream = new BehaviorSubject(null);
    annotateScreenStream = new BehaviorSubject(false);
    mainScreenCanvas = new BehaviorSubject(null);
    isScreenboardModalVisible = new BehaviorSubject(false);
    //state variables for the control buttons
    micActive = new BehaviorSubject(this.audioAlreadyOn.value ? this.audioAlreadyOn.value : false);
    videoActive = new BehaviorSubject(this.videoAlreadyOn.value ? this.videoAlreadyOn.value : false);
    screenShareActive = new BehaviorSubject(false);
    endCallActive = new BehaviorSubject(false);
    participantsActive = new BehaviorSubject(false);
    menuActive = new BehaviorSubject(false);
    commentsActive = new BehaviorSubject(false);
    // Update functions
    updateMessages = (value) => {
        this.messages.next(value);
    };
    updateStartDirectMessage = (value) => {
        this.startDirectMessage.next(value);
    };
    updateDirectMessageDetails = (value) => {
        this.directMessageDetails.next(value);
    };
    updateShowMessagesBadge = (value) => {
        this.showMessagesBadge.next(value);
    };
    updateAudioSetting = (value) => {
        this.audioSetting.next(value);
    };
    updateVideoSetting = (value) => {
        this.videoSetting.next(value);
    };
    updateScreenshareSetting = (value) => {
        this.screenshareSetting.next(value);
    };
    updateChatSetting = (value) => {
        this.chatSetting.next(value);
    };
    updateDisplayOption = (value) => {
        this.displayOption.next(value);
    };
    updateAutoWave = (value) => {
        this.autoWave.next(value);
    };
    updateForceFullDisplay = (value) => {
        this.forceFullDisplay.next(value);
    };
    updatePrevForceFullDisplay = (value) => {
        this.prevForceFullDisplay.next(value);
    };
    updatePrevMeetingDisplayType = (value) => {
        this.prevMeetingDisplayType.next(value);
    };
    updateWaitingRoomCounter = (value) => {
        this.waitingRoomCounter.next(value);
    };
    updateWaitingRoomFilter = (value) => {
        this.waitingRoomFilter.next(value);
    };
    updateWaitingRoomList = (value) => {
        this.waitingRoomList.next(value);
        this.filteredWaitingRoomList.next(value);
        this.waitingRoomCounter.next(value.length);
    };
    onWaitingRoomFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredWaitingRoom = this.waitingRoomList
                .getValue()
                .filter((waitingRoom) => {
                return waitingRoom.name.toLowerCase().includes(value.toLowerCase());
            });
            this.filteredWaitingRoomList.next(filteredWaitingRoom);
            this.waitingRoomCounter.next(filteredWaitingRoom.length);
        }
        else {
            this.filteredWaitingRoomList.next(this.waitingRoomList.getValue());
            this.waitingRoomCounter.next(this.waitingRoomList.getValue().length);
        }
    };
    onWaitingRoomClose = () => {
        this.updateIsWaitingModalVisible(false);
    };
    updateRequestCounter = (value) => {
        this.requestCounter.next(value);
    };
    updateRequestFilter = (value) => {
        this.requestFilter.next(value);
    };
    updateRequestList = (value) => {
        this.requestList.next(value);
        this.filteredRequestList.next(value);
        this.requestCounter.next(value.length);
    };
    onRequestFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredRequest = this.requestList.getValue().filter((request) => {
                return request?.name?.toLowerCase().includes(value.toLowerCase());
            });
            this.filteredRequestList.next(filteredRequest);
            this.requestCounter.next(filteredRequest.length);
        }
        else {
            this.filteredRequestList.next(this.requestList.getValue());
            this.requestCounter.next(this.requestList.getValue().length);
        }
    };
    onRequestClose = () => {
        this.updateIsRequestsModalVisible(false);
    };
    updateTotalReqWait = (value) => {
        this.totalReqWait.next(value);
    };
    updateAlertVisible = (value) => {
        this.alertVisible.next(value);
    };
    updateAlertMessage = (value) => {
        this.alertMessage.next(value);
    };
    updateAlertType = (value) => {
        this.alertType.next(value);
    };
    updateAlertDuration = (value) => {
        this.alertDuration.next(value);
    };
    updateProgressTimerVisible = (value) => {
        this.progressTimerVisible.next(value);
    };
    updateProgressTimerValue = (value) => {
        this.progressTimerValue.next(value);
    };
    updateIsMenuModalVisible = (value) => {
        this.isMenuModalVisible.next(value);
    };
    updateIsRecordingModalVisible = (value) => {
        this.isRecordingModalVisible.next(value);
        if (value) {
            this.updateConfirmedToRecord(false);
        }
        else {
            if (this.clearedToRecord.getValue() &&
                this.clearedToResume.getValue() &&
                this.recordStarted.getValue()) {
                this.updateShowRecordButtons(true);
            }
        }
    };
    updateIsSettingsModalVisible = (value) => {
        this.isSettingsModalVisible.next(value);
    };
    updateIsRequestsModalVisible = (value) => {
        this.isRequestsModalVisible.next(value);
    };
    updateIsWaitingModalVisible = (value) => {
        this.isWaitingModalVisible.next(value);
    };
    updateIsCoHostModalVisible = (value) => {
        this.isCoHostModalVisible.next(value);
    };
    updateIsMediaSettingsModalVisible = (value) => {
        this.isMediaSettingsModalVisible.next(value);
    };
    updateIsDisplaySettingsModalVisible = (value) => {
        this.isDisplaySettingsModalVisible.next(value);
    };
    updateIsParticipantsModalVisible = (value) => {
        this.isParticipantsModalVisible.next(value);
    };
    updateIsMessagesModalVisible = (value) => {
        this.isMessagesModalVisible.next(value);
        if (!value) {
            this.updateShowMessagesBadge(false);
        }
    };
    updateIsConfirmExitModalVisible = (value) => {
        this.isConfirmExitModalVisible.next(value);
    };
    updateIsConfirmHereModalVisible = (value) => {
        this.isConfirmHereModalVisible.next(value);
    };
    updateIsLoadingModalVisible = (value) => {
        this.isLoadingModalVisible.next(value);
    };
    updateIsShareEventModalVisible = (value) => {
        this.isShareEventModalVisible.next(value);
    };
    updateRecordingMediaOptions = (value) => {
        this.recordingMediaOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAudioOptions = (value) => {
        this.recordingAudioOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptions = (value) => {
        this.recordingVideoOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoType = (value) => {
        this.recordingVideoType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptimized = (value) => {
        this.recordingVideoOptimized.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingDisplayType = (value) => {
        this.recordingDisplayType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddHLS = (value) => {
        this.recordingAddHLS.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddText = (value) => {
        this.recordingAddText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomText = (value) => {
        this.recordingCustomText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextPosition = (value) => {
        this.recordingCustomTextPosition.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextColor = (value) => {
        this.recordingCustomTextColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTags = (value) => {
        this.recordingNameTags.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingBackgroundColor = (value) => {
        this.recordingBackgroundColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTagsColor = (value) => {
        this.recordingNameTagsColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingOrientationVideo = (value) => {
        this.recordingOrientationVideo.next(value);
        this.clearedToRecord.next(false);
    };
    updateClearedToResume = (value) => {
        this.clearedToResume.next(value);
    };
    updateClearedToRecord = (value) => {
        this.clearedToRecord.next(value);
    };
    updateRecordState = (value) => {
        if (this.recordStarted.value && !this.recordStopped.value) {
            if (!this.recordPaused.value) {
                this.recordState.next('red');
            }
            else {
                this.recordState.next('yellow');
            }
        }
        else {
            this.recordState.next(value);
        }
        this.recordState.next(value);
    };
    updateShowRecordButtons = (value) => {
        this.showRecordButtons.next(value);
    };
    updateRecordingProgressTime = (value) => {
        this.recordingProgressTime.next(value);
        this.updateRecordTimerWidget();
    };
    updateAudioSwitching = (value) => {
        this.audioSwitching.next(value);
    };
    updateVideoSwitching = (value) => {
        this.videoSwitching.next(value);
    };
    updateVideoAlreadyOn = (value) => {
        this.videoAlreadyOn.next(value);
        this.videoActive.next(value);
    };
    updateAudioAlreadyOn = (value) => {
        this.audioAlreadyOn.next(value);
        this.micActive.next(value);
    };
    updateComponentSizes = (sizes) => {
        this.componentSizes.next(sizes);
    };
    updateHasCameraPermission = (value) => {
        this.hasCameraPermission.next(value);
    };
    updateHasAudioPermission = (value) => {
        this.hasAudioPermission.next(value);
    };
    requestPermissionCamera() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    requestPermissionAudio() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    updateTransportCreated = (value) => {
        this.transportCreated.next(value);
    };
    updateTransportCreatedVideo = (value) => {
        this.transportCreatedVideo.next(value);
    };
    updateTransportCreatedAudio = (value) => {
        this.transportCreatedAudio.next(value);
    };
    updateTransportCreatedScreen = (value) => {
        this.transportCreatedScreen.next(value);
    };
    updateProducerTransport = (value) => {
        this.producerTransport.next(value);
    };
    updateVideoProducer = (value) => {
        this.videoProducer.next(value);
    };
    updateParams = (value) => {
        this.params.next(value);
    };
    updateVideoParams = (value) => {
        this.videoParams.next(value);
    };
    updateAudioParams = (value) => {
        this.audioParams.next(value);
    };
    updateAudioProducer = (value) => {
        this.audioProducer.next(value);
    };
    updateConsumerTransports = (value) => {
        this.consumerTransports.next(value);
    };
    updateConsumingTransports = (value) => {
        this.consumingTransports.next(value);
    };
    updatePolls = (value) => {
        this.polls.next(value);
    };
    updatePoll = (value) => {
        this.poll.next(value);
    };
    updateIsPollModalVisible = (value) => {
        this.isPollModalVisible.next(value);
    };
    updateCustomImage = (value) => {
        this.customImage.next(value);
    };
    updateSelectedImage = (value) => {
        this.selectedImage.next(value);
    };
    updateSegmentVideo = (value) => {
        this.segmentVideo.next(value);
    };
    updateSelfieSegmentation = (value) => {
        this.selfieSegmentation.next(value);
    };
    updatePauseSegmentation = (value) => {
        this.pauseSegmentation.next(value);
    };
    updateProcessedStream = (value) => {
        this.processedStream.next(value);
    };
    updateKeepBackground = (value) => {
        this.keepBackground.next(value);
    };
    updateBackgroundHasChanged = (value) => {
        this.backgroundHasChanged.next(value);
    };
    updateVirtualStream = (value) => {
        this.virtualStream.next(value);
    };
    updateMainCanvas = (value) => {
        this.mainCanvas.next(value);
    };
    updatePrevKeepBackground = (value) => {
        this.prevKeepBackground.next(value);
    };
    updateAppliedBackground = (value) => {
        this.appliedBackground.next(value);
    };
    updateIsBackgroundModalVisible = (value) => {
        this.isBackgroundModalVisible.next(value);
    };
    updateAutoClickBackground = (value) => {
        this.autoClickBackground.next(value);
    };
    updateBreakoutRooms = (value) => {
        this.breakoutRooms.next(value);
    };
    updateCurrentRoomIndex = (value) => {
        this.currentRoomIndex.next(value);
    };
    updateCanStartBreakout = (value) => {
        this.canStartBreakout.next(value);
    };
    updateBreakOutRoomStarted = (value) => {
        this.breakOutRoomStarted.next(value);
    };
    updateBreakOutRoomEnded = (value) => {
        this.breakOutRoomEnded.next(value);
    };
    updateHostNewRoom = (value) => {
        this.hostNewRoom.next(value);
    };
    updateLimitedBreakRoom = (value) => {
        this.limitedBreakRoom.next(value);
    };
    updateMainRoomsLength = (value) => {
        this.mainRoomsLength.next(value);
    };
    updateMemberRoom = (value) => {
        this.memberRoom.next(value);
    };
    updateIsBreakoutRoomsModalVisible = (value) => {
        this.isBreakoutRoomsModalVisible.next(value);
    };
    updateWhiteboardUsers = (value) => {
        this.whiteboardUsers.next(value);
    };
    updateCurrentWhiteboardIndex = (value) => {
        this.currentWhiteboardIndex.next(value);
    };
    updateCanStartWhiteboard = (value) => {
        this.canStartWhiteboard.next(value);
    };
    updateWhiteboardStarted = (value) => {
        this.whiteboardStarted.next(value);
    };
    updateWhiteboardEnded = (value) => {
        this.whiteboardEnded.next(value);
    };
    updateWhiteboardLimit = (value) => {
        this.whiteboardLimit.next(value);
    };
    updateIsWhiteboardModalVisible = (value) => {
        this.isWhiteboardModalVisible.next(value);
    };
    updateIsConfigureWhiteboardModalVisible = (value) => {
        this.isConfigureWhiteboardModalVisible.next(value);
    };
    updateShapes = (value) => {
        this.shapes.next(value);
    };
    updateUseImageBackground = (value) => {
        this.useImageBackground.next(value);
    };
    updateRedoStack = (value) => {
        this.redoStack.next(value);
    };
    updateUndoStack = (value) => {
        this.undoStack.next(value);
    };
    updateCanvasStream = (value) => {
        this.canvasStream.next(value);
    };
    updateCanvasWhiteboard = (value) => {
        this.canvasWhiteboard.next(value);
    };
    updateCanvasScreenboard = (value) => {
        this.canvasScreenboard.next(value);
    };
    updateProcessedScreenStream = (value) => {
        this.processedScreenStream.next(value);
    };
    updateAnnotateScreenStream = (value) => {
        this.annotateScreenStream.next(value);
    };
    updateMainScreenCanvas = (value) => {
        this.mainScreenCanvas.next(value);
    };
    updateIsScreenboardModalVisible = (value) => {
        this.isScreenboardModalVisible.next(value);
    };
    checkOrientation = () => {
        const isPortrait = window.matchMedia('(orientation: portrait)').matches;
        return isPortrait ? 'portrait' : 'landscape';
    };
    showAlert = ({ message, type, duration = 3000, }) => {
        this.updateAlertMessage(message);
        this.updateAlertType(type);
        this.updateAlertDuration(duration);
        this.updateAlertVisible(true);
    };
    getAllParams() {
        return {
            localUIMode: this.localUIMode.value, // Local UI mode
            // Room Details
            roomName: this.roomName.value,
            member: this.member.value,
            adminPasscode: this.adminPasscode.value,
            youAreCoHost: this.youAreCoHost.value,
            youAreHost: this.youAreHost.value,
            islevel: this.islevel.value,
            confirmedToRecord: this.confirmedToRecord.value,
            meetingDisplayType: this.meetingDisplayType.value,
            meetingVideoOptimized: this.meetingVideoOptimized.value,
            eventType: this.eventType.value,
            participants: this.participants.value,
            filteredParticipants: this.filteredParticipants.value,
            participantsCounter: this.participantsCounter.value,
            participantsFilter: this.participantsFilter.value,
            // More room details - media
            consume_sockets: this.consume_sockets.value,
            rtpCapabilities: this.rtpCapabilities.value,
            roomRecvIPs: this.roomRecvIPs.value,
            meetingRoomParams: this.meetingRoomParams.value,
            itemPageLimit: this.itemPageLimit.value,
            audioOnlyRoom: this.audioOnlyRoom.value,
            addForBasic: this.addForBasic.value,
            screenPageLimit: this.screenPageLimit.value,
            shareScreenStarted: this.shareScreenStarted.value,
            shared: this.shared.value,
            targetOrientation: this.targetOrientation.value,
            targetResolution: this.targetResolution.value,
            targetResolutionHost: this.targetResolutionHost.value,
            vidCons: this.vidCons.value,
            frameRate: this.frameRate.value,
            hParams: this.hParams.value,
            vParams: this.vParams.value,
            screenParams: this.screenParams.value,
            aParams: this.aParams.value,
            // More room details - recording
            recordingAudioPausesLimit: this.recordingAudioPausesLimit.value,
            recordingAudioPausesCount: this.recordingAudioPausesCount.value,
            recordingAudioSupport: this.recordingAudioSupport.value,
            recordingAudioPeopleLimit: this.recordingAudioPeopleLimit.value,
            recordingAudioParticipantsTimeLimit: this.recordingAudioParticipantsTimeLimit.value,
            recordingVideoPausesCount: this.recordingVideoPausesCount.value,
            recordingVideoPausesLimit: this.recordingVideoPausesLimit.value,
            recordingVideoSupport: this.recordingVideoSupport.value,
            recordingVideoPeopleLimit: this.recordingVideoPeopleLimit.value,
            recordingVideoParticipantsTimeLimit: this.recordingVideoParticipantsTimeLimit.value,
            recordingAllParticipantsSupport: this.recordingAllParticipantsSupport.value,
            recordingVideoParticipantsSupport: this.recordingVideoParticipantsSupport.value,
            recordingAllParticipantsFullRoomSupport: this.recordingAllParticipantsFullRoomSupport.value,
            recordingVideoParticipantsFullRoomSupport: this.recordingVideoParticipantsFullRoomSupport.value,
            recordingPreferredOrientation: this.recordingPreferredOrientation.value,
            recordingSupportForOtherOrientation: this.recordingSupportForOtherOrientation.value,
            recordingMultiFormatsSupport: this.recordingMultiFormatsSupport.value,
            userRecordingParams: this.userRecordingParams.value,
            canRecord: this.canRecord.value,
            startReport: this.startReport.value,
            endReport: this.endReport.value,
            recordStartTime: this.recordStartTime.value,
            recordElapsedTime: this.recordElapsedTime.value,
            isTimerRunning: this.isTimerRunning.value,
            canPauseResume: this.canPauseResume.value,
            recordChangeSeconds: this.recordChangeSeconds.value,
            pauseLimit: this.pauseLimit.value,
            pauseRecordCount: this.pauseRecordCount.value,
            canLaunchRecord: this.canLaunchRecord.value,
            stopLaunchRecord: this.stopLaunchRecord.value,
            participantsAll: this.participantsAll.value,
            firstAll: this.firstAll.value,
            updateMainWindow: this.updateMainWindow.value,
            first_round: this.first_round.value,
            landScaped: this.landScaped.value,
            lock_screen: this.lock_screen.value,
            screenId: this.screenId.value,
            allVideoStreams: this.allVideoStreams.value,
            newLimitedStreams: this.newLimitedStreams.value,
            newLimitedStreamsIDs: this.newLimitedStreamsIDs.value,
            activeSounds: this.activeSounds.value,
            screenShareIDStream: this.screenShareIDStream.value,
            screenShareNameStream: this.screenShareNameStream.value,
            adminIDStream: this.adminIDStream.value,
            adminNameStream: this.adminNameStream.value,
            youYouStream: this.youYouStream.value,
            youYouStreamIDs: this.youYouStreamIDs.value,
            localStream: this.localStream.value,
            recordStarted: this.recordStarted.value,
            recordResumed: this.recordResumed.value,
            recordPaused: this.recordPaused.value,
            recordStopped: this.recordStopped.value,
            adminRestrictSetting: this.adminRestrictSetting.value,
            videoRequestState: this.videoRequestState.value,
            videoRequestTime: this.videoRequestTime.value,
            videoAction: this.videoAction.value,
            localStreamVideo: this.localStreamVideo.value,
            userDefaultVideoInputDevice: this.userDefaultVideoInputDevice.value,
            currentFacingMode: this.currentFacingMode.value,
            prevFacingMode: this.prevFacingMode.value,
            defVideoID: this.defVideoID.value,
            allowed: this.allowed.value,
            dispActiveNames: this.dispActiveNames.value,
            p_dispActiveNames: this.p_dispActiveNames.value,
            activeNames: this.activeNames.value,
            prevActiveNames: this.prevActiveNames.value,
            p_activeNames: this.p_activeNames.value,
            membersReceived: this.membersReceived.value,
            deferScreenReceived: this.deferScreenReceived.value,
            hostFirstSwitch: this.hostFirstSwitch.value,
            micAction: this.micAction.value,
            screenAction: this.screenAction.value,
            chatAction: this.chatAction.value,
            audioRequestState: this.audioRequestState.value,
            screenRequestState: this.screenRequestState.value,
            chatRequestState: this.chatRequestState.value,
            audioRequestTime: this.audioRequestTime.value,
            screenRequestTime: this.screenRequestTime.value,
            chatRequestTime: this.chatRequestTime.value,
            updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
            oldSoundIds: this.oldSoundIds.value,
            hostLabel: this.hostLabel.value,
            mainScreenFilled: this.mainScreenFilled.value,
            localStreamScreen: this.localStreamScreen.value,
            screenAlreadyOn: this.screenAlreadyOn.value,
            chatAlreadyOn: this.chatAlreadyOn.value,
            redirectURL: this.redirectURL.value,
            oldAllStreams: this.oldAllStreams.value,
            adminVidID: this.adminVidID.value,
            streamNames: this.streamNames.value,
            non_alVideoStreams: this.non_alVideoStreams.value,
            sortAudioLoudness: this.sortAudioLoudness.value,
            audioDecibels: this.audioDecibels.value,
            mixed_alVideoStreams: this.mixed_alVideoStreams.value,
            non_alVideoStreams_muted: this.non_alVideoStreams_muted.value,
            paginatedStreams: this.paginatedStreams.value,
            localStreamAudio: this.localStreamAudio.value,
            defAudioID: this.defAudioID.value,
            userDefaultAudioInputDevice: this.userDefaultAudioInputDevice.value,
            userDefaultAudioOutputDevice: this.userDefaultAudioOutputDevice.value,
            prevAudioInputDevice: this.prevAudioInputDevice.value,
            prevVideoInputDevice: this.prevVideoInputDevice.value,
            audioPaused: this.audioPaused.value,
            mainScreenPerson: this.mainScreenPerson.value,
            adminOnMainScreen: this.adminOnMainScreen.value,
            screenStates: this.screenStates.value,
            prevScreenStates: this.prevScreenStates.value,
            updateDateState: this.updateDateState.value,
            lastUpdate: this.lastUpdate.value,
            nForReadjustRecord: this.nForReadjustRecord.value,
            fixedPageLimit: this.fixedPageLimit.value,
            removeAltGrid: this.removeAltGrid.value,
            nForReadjust: this.nForReadjust.value,
            lastReorderTime: this.lastReorderTime.value,
            reorderInterval: this.reorderInterval.value,
            fastReorderInterval: this.fastReorderInterval.value,
            audStreamNames: this.audStreamNames.value,
            currentUserPage: this.currentUserPage.value,
            mainHeightWidth: this.mainHeightWidth.value,
            prevMainHeightWidth: this.prevMainHeightWidth.value,
            prevDoPaginate: this.prevDoPaginate.value,
            doPaginate: this.doPaginate.value,
            shareEnded: this.shareEnded.value,
            lStreams: this.lStreams.value,
            chatRefStreams: this.chatRefStreams.value,
            controlHeight: this.controlHeight.value,
            isWideScreen: this.isWideScreen.value,
            isMediumScreen: this.isMediumScreen.value,
            isSmallScreen: this.isSmallScreen.value,
            addGrid: this.addGrid.value,
            addAltGrid: this.addAltGrid.value,
            gridRows: this.gridRows.value,
            gridCols: this.gridCols.value,
            altGridRows: this.altGridRows.value,
            altGridCols: this.altGridCols.value,
            numberPages: this.numberPages.value,
            currentStreams: this.currentStreams.value,
            showMiniView: this.showMiniView.value,
            nStream: this.nStream.value,
            defer_receive: this.defer_receive.value,
            allAudioStreams: this.allAudioStreams.value,
            screenProducer: this.screenProducer.value,
            remoteScreenStream: this.remoteScreenStream.value,
            gotAllVids: this.gotAllVids.value,
            paginationHeightWidth: this.paginationHeightWidth.value,
            paginationDirection: this.paginationDirection.value,
            gridSizes: this.gridSizes.value,
            screenForceFullDisplay: this.screenForceFullDisplay.value,
            mainGridStream: this.mainGridStream.value,
            otherGridStreams: this.otherGridStreams.value,
            audioOnlyStreams: this.audioOnlyStreams.value,
            videoInputs: this.videoInputs.value,
            audioInputs: this.audioInputs.value,
            meetingProgressTime: this.meetingProgressTime.value,
            meetingElapsedTime: this.meetingElapsedTime.value,
            ref_participants: this.ref_participants.value,
            messages: this.messages.value,
            startDirectMessage: this.startDirectMessage.value,
            directMessageDetails: this.directMessageDetails.value,
            coHost: this.coHost.value,
            coHostResponsibility: this.coHostResponsibility.value,
            // Event settings
            audioSetting: this.audioSetting.value,
            videoSetting: this.videoSetting.value,
            screenshareSetting: this.screenshareSetting.value,
            chatSetting: this.chatSetting.value,
            // Display settings
            autoWave: this.autoWave.value,
            forceFullDisplay: this.forceFullDisplay.value,
            prevForceFullDisplay: this.prevForceFullDisplay.value,
            prevMeetingDisplayType: this.prevMeetingDisplayType.value,
            // Waiting room
            waitingRoomFilter: this.waitingRoomFilter.value,
            waitingRoomList: this.waitingRoomList.value,
            waitingRoomCounter: this.waitingRoomCounter.value,
            filteredWaitingRoomList: this.filteredWaitingRoomList.value,
            // Requests
            requestFilter: this.requestFilter.value,
            requestList: this.requestList.value,
            requestCounter: this.requestCounter.value,
            filteredRequestList: this.filteredRequestList.value,
            // Total requests and waiting room
            totalReqWait: this.totalReqWait.value,
            // Alerts
            alertVisible: this.alertVisible.value,
            alertMessage: this.alertMessage.value,
            alertType: this.alertType.value,
            alertDuration: this.alertDuration.value,
            // Progress Timer
            progressTimerVisible: this.progressTimerVisible.value,
            progressTimerValue: this.progressTimerValue.value,
            // Menu modals
            isMenuModalVisible: this.isMenuModalVisible.value,
            isRecordingModalVisible: this.isRecordingModalVisible.value,
            isSettingsModalVisible: this.isSettingsModalVisible.value,
            isRequestsModalVisible: this.isRequestsModalVisible.value,
            isWaitingModalVisible: this.isWaitingModalVisible.value,
            isCoHostModalVisible: this.isCoHostModalVisible.value,
            isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
            isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            // Other Modals
            isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            isMessagesModalVisible: this.isMessagesModalVisible.value,
            isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            isConfirmHereModalVisible: this.isConfirmHereModalVisible.value,
            isLoadingModalVisible: this.isLoadingModalVisible.value,
            // Recording Options
            recordingMediaOptions: this.recordingMediaOptions.value,
            recordingAudioOptions: this.recordingAudioOptions.value,
            recordingVideoOptions: this.recordingVideoOptions.value,
            recordingVideoType: this.recordingVideoType.value,
            recordingVideoOptimized: this.recordingVideoOptimized.value,
            recordingDisplayType: this.recordingDisplayType.value,
            recordingAddHLS: this.recordingAddHLS.value,
            recordingAddText: this.recordingAddText.value,
            recordingCustomText: this.recordingCustomText.value,
            recordingCustomTextPosition: this.recordingCustomTextPosition.value,
            recordingCustomTextColor: this.recordingCustomTextColor.value,
            recordingNameTags: this.recordingNameTags.value,
            recordingBackgroundColor: this.recordingBackgroundColor.value,
            recordingNameTagsColor: this.recordingNameTagsColor.value,
            recordingOrientationVideo: this.recordingOrientationVideo.value,
            clearedToResume: this.clearedToResume.value,
            clearedToRecord: this.clearedToRecord.value,
            recordState: this.recordState.value,
            showRecordButtons: this.showRecordButtons.value,
            recordingProgressTime: this.recordingProgressTime.value,
            audioSwitching: this.audioSwitching.value,
            videoSwitching: this.videoSwitching.value,
            // Media states
            videoAlreadyOn: this.videoAlreadyOn.value,
            audioAlreadyOn: this.audioAlreadyOn.value,
            componentSizes: this.componentSizes.value,
            // Permissions
            hasCameraPermission: this.hasCameraPermission.value,
            hasAudioPermission: this.hasAudioPermission.value,
            // Transports
            transportCreated: this.transportCreated.value,
            transportCreatedVideo: this.transportCreatedVideo.value,
            transportCreatedAudio: this.transportCreatedAudio.value,
            transportCreatedScreen: this.transportCreatedScreen.value,
            producerTransport: this.producerTransport.value,
            videoProducer: this.videoProducer.value,
            params: this.params.value,
            videoParams: this.videoParams.value,
            audioParams: this.audioParams.value,
            audioProducer: this.audioProducer.value,
            consumerTransports: this.consumerTransports.value,
            consumingTransports: this.consumingTransports.value,
            // Polls
            polls: this.polls.value,
            poll: this.poll.value,
            isPollModalVisible: this.isPollModalVisible.value,
            // Background
            customImage: this.customImage.value,
            selectedImage: this.selectedImage.value,
            segmentVideo: this.segmentVideo.value,
            selfieSegmentation: this.selfieSegmentation.value,
            pauseSegmentation: this.pauseSegmentation.value,
            processedStream: this.processedStream.value,
            keepBackground: this.keepBackground.value,
            backgroundHasChanged: this.backgroundHasChanged.value,
            virtualStream: this.virtualStream.value,
            mainCanvas: this.mainCanvas.value,
            prevKeepBackground: this.prevKeepBackground.value,
            appliedBackground: this.appliedBackground.value,
            isBackgroundModalVisible: this.isBackgroundModalVisible.value,
            autoClickBackground: this.autoClickBackground.value,
            // Breakout rooms
            breakoutRooms: this.breakoutRooms.value,
            currentRoomIndex: this.currentRoomIndex.value,
            canStartBreakout: this.canStartBreakout.value,
            breakOutRoomStarted: this.breakOutRoomStarted.value,
            breakOutRoomEnded: this.breakOutRoomEnded.value,
            hostNewRoom: this.hostNewRoom.value,
            limitedBreakRoom: this.limitedBreakRoom.value,
            mainRoomsLength: this.mainRoomsLength.value,
            memberRoom: this.memberRoom.value,
            isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            // Whiteboard
            whiteboardUsers: this.whiteboardUsers.value,
            currentWhiteboardIndex: this.currentWhiteboardIndex.value,
            canStartWhiteboard: this.canStartWhiteboard.value,
            whiteboardStarted: this.whiteboardStarted.value,
            whiteboardEnded: this.whiteboardEnded.value,
            whiteboardLimit: this.whiteboardLimit.value,
            isWhiteboardModalVisible: this.isWhiteboardModalVisible.value,
            isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            shapes: this.shapes.value,
            useImageBackground: this.useImageBackground.value,
            redoStack: this.redoStack.value,
            undoStack: this.undoStack.value,
            canvasStream: this.canvasStream.value,
            canvasWhiteboard: this.canvasWhiteboard.value,
            // Screenboard
            canvasScreenboard: this.canvasScreenboard.value,
            processedScreenStream: this.processedScreenStream.value,
            annotateScreenStream: this.annotateScreenStream.value,
            mainScreenCanvas: this.mainScreenCanvas.value,
            isScreenboardModalVisible: this.isScreenboardModalVisible.value,
            validated: this.validated.value,
            device: this.device.value,
            socket: this.socket.value,
            checkMediaPermission: false,
            onWeb: true,
            // Update functions
            updateRoomName: this.updateRoomName.bind(this),
            updateMember: this.updateMember.bind(this),
            updateAdminPasscode: this.updateAdminPasscode.bind(this),
            updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
            updateYouAreHost: this.updateYouAreHost.bind(this),
            updateIslevel: this.updateIslevel.bind(this),
            updateCoHost: this.updateCoHost.bind(this),
            updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
            updateConfirmedToRecord: this.updateConfirmedToRecord.bind(this),
            updateMeetingDisplayType: this.updateMeetingDisplayType.bind(this),
            updateMeetingVideoOptimized: this.updateMeetingVideoOptimized.bind(this),
            updateEventType: this.updateEventType.bind(this),
            updateParticipants: this.updateParticipants.bind(this),
            updateParticipantsCounter: this.updateParticipantsCounter.bind(this),
            updateParticipantsFilter: this.updateParticipantsFilter.bind(this),
            // More update functions for media details
            updateConsume_sockets: this.updateConsume_sockets.bind(this),
            updateRtpCapabilities: this.updateRtpCapabilities.bind(this),
            updateRoomRecvIPs: this.updateRoomRecvIPs.bind(this),
            updateMeetingRoomParams: this.updateMeetingRoomParams.bind(this),
            updateItemPageLimit: this.updateItemPageLimit.bind(this),
            updateAudioOnlyRoom: this.updateAudioOnlyRoom.bind(this),
            updateAddForBasic: this.updateAddForBasic.bind(this),
            updateScreenPageLimit: this.updateScreenPageLimit.bind(this),
            updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
            updateShared: this.updateShared.bind(this),
            updateTargetOrientation: this.updateTargetOrientation.bind(this),
            updateTargetResolution: this.updateTargetResolution.bind(this),
            updateTargetResolutionHost: this.updateTargetResolutionHost.bind(this),
            updateVidCons: this.updateVidCons.bind(this),
            updateFrameRate: this.updateFrameRate.bind(this),
            updateHParams: this.updateHParams.bind(this),
            updateVParams: this.updateVParams.bind(this),
            updateScreenParams: this.updateScreenParams.bind(this),
            updateAParams: this.updateAParams.bind(this),
            // More update functions for recording details
            updateRecordingAudioPausesLimit: this.updateRecordingAudioPausesLimit.bind(this),
            updateRecordingAudioPausesCount: this.updateRecordingAudioPausesCount.bind(this),
            updateRecordingAudioSupport: this.updateRecordingAudioSupport.bind(this),
            updateRecordingAudioPeopleLimit: this.updateRecordingAudioPeopleLimit.bind(this),
            updateRecordingAudioParticipantsTimeLimit: this.updateRecordingAudioParticipantsTimeLimit.bind(this),
            updateRecordingVideoPausesCount: this.updateRecordingVideoPausesCount.bind(this),
            updateRecordingVideoPausesLimit: this.updateRecordingVideoPausesLimit.bind(this),
            updateRecordingVideoSupport: this.updateRecordingVideoSupport.bind(this),
            updateRecordingVideoPeopleLimit: this.updateRecordingVideoPeopleLimit.bind(this),
            updateRecordingVideoParticipantsTimeLimit: this.updateRecordingVideoParticipantsTimeLimit.bind(this),
            updateRecordingAllParticipantsSupport: this.updateRecordingAllParticipantsSupport.bind(this),
            updateRecordingVideoParticipantsSupport: this.updateRecordingVideoParticipantsSupport.bind(this),
            updateRecordingAllParticipantsFullRoomSupport: this.updateRecordingAllParticipantsFullRoomSupport.bind(this),
            updateRecordingVideoParticipantsFullRoomSupport: this.updateRecordingVideoParticipantsFullRoomSupport.bind(this),
            updateRecordingPreferredOrientation: this.updateRecordingPreferredOrientation.bind(this),
            updateRecordingSupportForOtherOrientation: this.updateRecordingSupportForOtherOrientation.bind(this),
            updateRecordingMultiFormatsSupport: this.updateRecordingMultiFormatsSupport.bind(this),
            updateUserRecordingParams: this.updateUserRecordingParams.bind(this),
            updateCanRecord: this.updateCanRecord.bind(this),
            updateStartReport: this.updateStartReport.bind(this),
            updateEndReport: this.updateEndReport.bind(this),
            updateRecordTimerInterval: this.updateRecordTimerInterval.bind(this),
            updateRecordStartTime: this.updateRecordStartTime.bind(this),
            updateRecordElapsedTime: this.updateRecordElapsedTime.bind(this),
            updateIsTimerRunning: this.updateIsTimerRunning.bind(this),
            updateCanPauseResume: this.updateCanPauseResume.bind(this),
            updateRecordChangeSeconds: this.updateRecordChangeSeconds.bind(this),
            updatePauseLimit: this.updatePauseLimit.bind(this),
            updatePauseRecordCount: this.updatePauseRecordCount.bind(this),
            updateCanLaunchRecord: this.updateCanLaunchRecord.bind(this),
            updateStopLaunchRecord: this.updateStopLaunchRecord.bind(this),
            updateParticipantsAll: this.updateParticipantsAll.bind(this),
            updateFirstAll: this.updateFirstAll.bind(this),
            updateUpdateMainWindow: this.updateUpdateMainWindow.bind(this),
            updateFirst_round: this.updateFirst_round.bind(this),
            updateLandScaped: this.updateLandScaped.bind(this),
            updateLock_screen: this.updateLock_screen.bind(this),
            updateScreenId: this.updateScreenId.bind(this),
            updateAllVideoStreams: this.updateAllVideoStreams.bind(this),
            updateNewLimitedStreams: this.updateNewLimitedStreams.bind(this),
            updateNewLimitedStreamsIDs: this.updateNewLimitedStreamsIDs.bind(this),
            updateActiveSounds: this.updateActiveSounds.bind(this),
            updateScreenShareIDStream: this.updateScreenShareIDStream.bind(this),
            updateScreenShareNameStream: this.updateScreenShareNameStream.bind(this),
            updateAdminIDStream: this.updateAdminIDStream.bind(this),
            updateAdminNameStream: this.updateAdminNameStream.bind(this),
            updateYouYouStream: this.updateYouYouStream.bind(this),
            updateYouYouStreamIDs: this.updateYouYouStreamIDs.bind(this),
            updateLocalStream: this.updateLocalStream.bind(this),
            updateRecordStarted: this.updateRecordStarted.bind(this),
            updateRecordResumed: this.updateRecordResumed.bind(this),
            updateRecordPaused: this.updateRecordPaused.bind(this),
            updateRecordStopped: this.updateRecordStopped.bind(this),
            updateAdminRestrictSetting: this.updateAdminRestrictSetting.bind(this),
            updateVideoRequestState: this.updateVideoRequestState.bind(this),
            updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
            updateVideoAction: this.updateVideoAction.bind(this),
            updateLocalStreamVideo: this.updateLocalStreamVideo.bind(this),
            updateUserDefaultVideoInputDevice: this.updateUserDefaultVideoInputDevice.bind(this),
            updateCurrentFacingMode: this.updateCurrentFacingMode.bind(this),
            updatePrevFacingMode: this.updatePrevFacingMode.bind(this),
            updateDefVideoID: this.updateDefVideoID.bind(this),
            updateAllowed: this.updateAllowed.bind(this),
            updateDispActiveNames: this.updateDispActiveNames.bind(this),
            updateP_dispActiveNames: this.updateP_dispActiveNames.bind(this),
            updateActiveNames: this.updateActiveNames.bind(this),
            updatePrevActiveNames: this.updatePrevActiveNames.bind(this),
            updateP_activeNames: this.updateP_activeNames.bind(this),
            updateMembersReceived: this.updateMembersReceived.bind(this),
            updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
            updateHostFirstSwitch: this.updateHostFirstSwitch.bind(this),
            updateMicAction: this.updateMicAction.bind(this),
            updateScreenAction: this.updateScreenAction.bind(this),
            updateChatAction: this.updateChatAction.bind(this),
            updateAudioRequestState: this.updateAudioRequestState.bind(this),
            updateScreenRequestState: this.updateScreenRequestState.bind(this),
            updateChatRequestState: this.updateChatRequestState.bind(this),
            updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
            updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
            updateChatRequestTime: this.updateChatRequestTime.bind(this),
            updateOldSoundIds: this.updateOldSoundIds.bind(this),
            updateHostLabel: this.updateHostLabel.bind(this),
            updateMainScreenFilled: this.updateMainScreenFilled.bind(this),
            updateLocalStreamScreen: this.updateLocalStreamScreen.bind(this),
            updateScreenAlreadyOn: this.updateScreenAlreadyOn.bind(this),
            updateChatAlreadyOn: this.updateChatAlreadyOn.bind(this),
            updateRedirectURL: this.updateRedirectURL.bind(this),
            updateOldAllStreams: this.updateOldAllStreams.bind(this),
            updateAdminVidID: this.updateAdminVidID.bind(this),
            updateStreamNames: this.updateStreamNames.bind(this),
            updateNon_alVideoStreams: this.updateNon_alVideoStreams.bind(this),
            updateSortAudioLoudness: this.updateSortAudioLoudness.bind(this),
            updateAudioDecibels: this.updateAudioDecibels.bind(this),
            updateMixed_alVideoStreams: this.updateMixed_alVideoStreams.bind(this),
            updateNon_alVideoStreams_muted: this.updateNon_alVideoStreams_muted.bind(this),
            updatePaginatedStreams: this.updatePaginatedStreams.bind(this),
            updateLocalStreamAudio: this.updateLocalStreamAudio.bind(this),
            updateDefAudioID: this.updateDefAudioID.bind(this),
            updateUserDefaultAudioInputDevice: this.updateUserDefaultAudioInputDevice.bind(this),
            updateUserDefaultAudioOutputDevice: this.updateUserDefaultAudioOutputDevice.bind(this),
            updatePrevAudioInputDevice: this.updatePrevAudioInputDevice.bind(this),
            updatePrevVideoInputDevice: this.updatePrevVideoInputDevice.bind(this),
            updateAudioPaused: this.updateAudioPaused.bind(this),
            updateMainScreenPerson: this.updateMainScreenPerson.bind(this),
            updateAdminOnMainScreen: this.updateAdminOnMainScreen.bind(this),
            updateScreenStates: this.updateScreenStates.bind(this),
            updatePrevScreenStates: this.updatePrevScreenStates.bind(this),
            updateUpdateDateState: this.updateUpdateDateState.bind(this),
            updateLastUpdate: this.updateLastUpdate.bind(this),
            updateNForReadjustRecord: this.updateNForReadjustRecord.bind(this),
            updateFixedPageLimit: this.updateFixedPageLimit.bind(this),
            updateRemoveAltGrid: this.updateRemoveAltGrid.bind(this),
            updateNForReadjust: this.updateNForReadjust.bind(this),
            updateLastReorderTime: this.updateLastReorderTime.bind(this),
            updateAudStreamNames: this.updateAudStreamNames.bind(this),
            updateCurrentUserPage: this.updateCurrentUserPage.bind(this),
            updateMainHeightWidth: this.updateMainHeightWidth.bind(this),
            updatePrevMainHeightWidth: this.updatePrevMainHeightWidth.bind(this),
            updatePrevDoPaginate: this.updatePrevDoPaginate.bind(this),
            updateDoPaginate: this.updateDoPaginate.bind(this),
            updateShareEnded: this.updateShareEnded.bind(this),
            updateLStreams: this.updateLStreams.bind(this),
            updateChatRefStreams: this.updateChatRefStreams.bind(this),
            updateControlHeight: this.updateControlHeight.bind(this),
            updateIsWideScreen: this.updateIsWideScreen.bind(this),
            updateIsMediumScreen: this.updateIsMediumScreen.bind(this),
            updateIsSmallScreen: this.updateIsSmallScreen.bind(this),
            updateAddGrid: this.updateAddGrid.bind(this),
            updateAddAltGrid: this.updateAddAltGrid.bind(this),
            updateGridRows: this.updateGridRows.bind(this),
            updateGridCols: this.updateGridCols.bind(this),
            updateAltGridRows: this.updateAltGridRows.bind(this),
            updateAltGridCols: this.updateAltGridCols.bind(this),
            updateNumberPages: this.updateNumberPages.bind(this),
            updateCurrentStreams: this.updateCurrentStreams.bind(this),
            updateShowMiniView: this.updateShowMiniView.bind(this),
            updateNStream: this.updateNStream.bind(this),
            updateDefer_receive: this.updateDefer_receive.bind(this),
            updateAllAudioStreams: this.updateAllAudioStreams.bind(this),
            updateRemoteScreenStream: this.updateRemoteScreenStream.bind(this),
            updateScreenProducer: this.updateScreenProducer.bind(this),
            updateGotAllVids: this.updateGotAllVids.bind(this),
            updatePaginationHeightWidth: this.updatePaginationHeightWidth.bind(this),
            updatePaginationDirection: this.updatePaginationDirection.bind(this),
            updateGridSizes: this.updateGridSizes.bind(this),
            updateScreenForceFullDisplay: this.updateScreenForceFullDisplay.bind(this),
            updateMainGridStream: this.updateMainGridStream.bind(this),
            updateOtherGridStreams: this.updateOtherGridStreams.bind(this),
            updateAudioOnlyStreams: this.updateAudioOnlyStreams.bind(this),
            updateVideoInputs: this.updateVideoInputs.bind(this),
            updateAudioInputs: this.updateAudioInputs.bind(this),
            updateMeetingProgressTime: this.updateMeetingProgressTime.bind(this),
            updateMeetingElapsedTime: this.updateMeetingElapsedTime.bind(this),
            updateRef_participants: this.updateRef_participants.bind(this),
            updateMessages: this.updateMessages.bind(this),
            updateStartDirectMessage: this.updateStartDirectMessage.bind(this),
            updateDirectMessageDetails: this.updateDirectMessageDetails.bind(this),
            updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
            // Event settings
            updateAudioSetting: this.updateAudioSetting.bind(this),
            updateVideoSetting: this.updateVideoSetting.bind(this),
            updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
            updateChatSetting: this.updateChatSetting.bind(this),
            // Display settings
            updateAutoWave: this.updateAutoWave.bind(this),
            updateForceFullDisplay: this.updateForceFullDisplay.bind(this),
            updatePrevForceFullDisplay: this.updatePrevForceFullDisplay.bind(this),
            updatePrevMeetingDisplayType: this.updatePrevMeetingDisplayType.bind(this),
            // Waiting room
            updateWaitingRoomFilter: this.updateWaitingRoomFilter.bind(this),
            updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
            updateWaitingRoomCounter: this.updateWaitingRoomCounter.bind(this),
            // Requests
            updateRequestFilter: this.updateRequestFilter.bind(this),
            updateRequestList: this.updateRequestList.bind(this),
            updateRequestCounter: this.updateRequestCounter.bind(this),
            // Total requests and waiting room
            updateTotalReqWait: this.updateTotalReqWait.bind(this),
            // Menu modals
            updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
            updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
            updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
            updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
            updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
            updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
            // Other modals
            updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
            updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
            updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
            updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
            updateIsLoadingModalVisible: this.updateIsLoadingModalVisible.bind(this),
            // Recording Options
            updateRecordingMediaOptions: this.updateRecordingMediaOptions.bind(this),
            updateRecordingAudioOptions: this.updateRecordingAudioOptions.bind(this),
            updateRecordingVideoOptions: this.updateRecordingVideoOptions.bind(this),
            updateRecordingVideoType: this.updateRecordingVideoType.bind(this),
            updateRecordingVideoOptimized: this.updateRecordingVideoOptimized.bind(this),
            updateRecordingDisplayType: this.updateRecordingDisplayType.bind(this),
            updateRecordingAddHLS: this.updateRecordingAddHLS.bind(this),
            updateRecordingAddText: this.updateRecordingAddText.bind(this),
            updateRecordingCustomText: this.updateRecordingCustomText.bind(this),
            updateRecordingCustomTextPosition: this.updateRecordingCustomTextPosition.bind(this),
            updateRecordingCustomTextColor: this.updateRecordingCustomTextColor.bind(this),
            updateRecordingNameTags: this.updateRecordingNameTags.bind(this),
            updateRecordingBackgroundColor: this.updateRecordingBackgroundColor.bind(this),
            updateRecordingNameTagsColor: this.updateRecordingNameTagsColor.bind(this),
            updateRecordingOrientationVideo: this.updateRecordingOrientationVideo.bind(this),
            updateClearedToResume: this.updateClearedToResume.bind(this),
            updateClearedToRecord: this.updateClearedToRecord.bind(this),
            updateRecordState: this.updateRecordState.bind(this),
            updateShowRecordButtons: this.updateShowRecordButtons.bind(this),
            updateRecordingProgressTime: this.updateRecordingProgressTime.bind(this),
            updateAudioSwitching: this.updateAudioSwitching.bind(this),
            updateVideoSwitching: this.updateVideoSwitching.bind(this),
            // Media states
            updateVideoAlreadyOn: this.updateVideoAlreadyOn.bind(this),
            updateAudioAlreadyOn: this.updateAudioAlreadyOn.bind(this),
            updateComponentSizes: this.updateComponentSizes.bind(this),
            // Permissions
            updateHasCameraPermission: this.updateHasCameraPermission.bind(this),
            updateHasAudioPermission: this.updateHasAudioPermission.bind(this),
            // Transports
            updateTransportCreated: this.updateTransportCreated.bind(this),
            updateTransportCreatedVideo: this.updateTransportCreatedVideo.bind(this),
            updateTransportCreatedAudio: this.updateTransportCreatedAudio.bind(this),
            updateTransportCreatedScreen: this.updateTransportCreatedScreen.bind(this),
            updateProducerTransport: this.updateProducerTransport.bind(this),
            updateVideoProducer: this.updateVideoProducer.bind(this),
            updateParams: this.updateParams.bind(this),
            updateVideoParams: this.updateVideoParams.bind(this),
            updateAudioParams: this.updateAudioParams.bind(this),
            updateAudioProducer: this.updateAudioProducer.bind(this),
            updateConsumerTransports: this.updateConsumerTransports.bind(this),
            updateConsumingTransports: this.updateConsumingTransports.bind(this),
            // Polls
            updatePolls: this.updatePolls.bind(this),
            updatePoll: this.updatePoll.bind(this),
            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
            // Background
            updateCustomImage: this.updateCustomImage.bind(this),
            updateSelectedImage: this.updateSelectedImage.bind(this),
            updateSegmentVideo: this.updateSegmentVideo.bind(this),
            updateSelfieSegmentation: this.updateSelfieSegmentation.bind(this),
            updatePauseSegmentation: this.updatePauseSegmentation.bind(this),
            updateProcessedStream: this.updateProcessedStream.bind(this),
            updateKeepBackground: this.updateKeepBackground.bind(this),
            updateBackgroundHasChanged: this.updateBackgroundHasChanged.bind(this),
            updateVirtualStream: this.updateVirtualStream.bind(this),
            updateMainCanvas: this.updateMainCanvas.bind(this),
            updatePrevKeepBackground: this.updatePrevKeepBackground.bind(this),
            updateAppliedBackground: this.updateAppliedBackground.bind(this),
            updateIsBackgroundModalVisible: this.updateIsBackgroundModalVisible.bind(this),
            updateAutoClickBackground: this.updateAutoClickBackground.bind(this),
            // Breakout rooms
            updateBreakoutRooms: this.updateBreakoutRooms.bind(this),
            updateCurrentRoomIndex: this.updateCurrentRoomIndex.bind(this),
            updateCanStartBreakout: this.updateCanStartBreakout.bind(this),
            updateBreakOutRoomStarted: this.updateBreakOutRoomStarted.bind(this),
            updateBreakOutRoomEnded: this.updateBreakOutRoomEnded.bind(this),
            updateHostNewRoom: this.updateHostNewRoom.bind(this),
            updateLimitedBreakRoom: this.updateLimitedBreakRoom.bind(this),
            updateMainRoomsLength: this.updateMainRoomsLength.bind(this),
            updateMemberRoom: this.updateMemberRoom.bind(this),
            updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
            // Whiteboard
            updateWhiteboardUsers: this.updateWhiteboardUsers.bind(this),
            updateCurrentWhiteboardIndex: this.updateCurrentWhiteboardIndex.bind(this),
            updateCanStartWhiteboard: this.updateCanStartWhiteboard.bind(this),
            updateWhiteboardStarted: this.updateWhiteboardStarted.bind(this),
            updateWhiteboardEnded: this.updateWhiteboardEnded.bind(this),
            updateWhiteboardLimit: this.updateWhiteboardLimit.bind(this),
            updateIsWhiteboardModalVisible: this.updateIsWhiteboardModalVisible.bind(this),
            updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
            updateShapes: this.updateShapes.bind(this),
            updateUseImageBackground: this.updateUseImageBackground.bind(this),
            updateRedoStack: this.updateRedoStack.bind(this),
            updateUndoStack: this.updateUndoStack.bind(this),
            updateCanvasStream: this.updateCanvasStream.bind(this),
            updateCanvasWhiteboard: this.updateCanvasWhiteboard.bind(this),
            // Screenboard
            updateCanvasScreenboard: this.updateCanvasScreenboard.bind(this),
            updateProcessedScreenStream: this.updateProcessedScreenStream.bind(this),
            updateAnnotateScreenStream: this.updateAnnotateScreenStream.bind(this),
            updateMainScreenCanvas: this.updateMainScreenCanvas.bind(this),
            updateIsScreenboardModalVisible: this.updateIsScreenboardModalVisible.bind(this),
            // Other functions
            checkOrientation: this.checkOrientation.bind(this),
            updateDevice: this.updateDevice.bind(this),
            updateSocket: this.updateSocket.bind(this),
            updateValidated: this.updateValidated.bind(this),
            showAlert: this.showAlert.bind(this),
            getUpdatedAllParams: () => {
                return {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                };
            },
        };
    }
    mediaSFUParameters = {
        ...this.getAllParams(),
        ...this.mediaSFUFunctions(),
    };
    getUpdatedAllParams = () => {
        return {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    };
    updateButtonState(buttonType, value) {
        this.controlButtons = this.controlButtons.map((button) => {
            if (buttonType === 'micActive' && button.icon === this.faMicrophoneSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'videoActive' && button.icon === this.faVideoSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'screenShareActive' && button.icon === this.faDesktop) {
                if (button.alternateIconComponent) {
                    const updatedInjector = this.createInjector({
                        disabled: !value,
                    });
                    return {
                        ...button,
                        active: true,
                        alternateIconComponent: { ...this.screenShareWidget, injector: updatedInjector },
                    }; //always default to true for active
                }
                else {
                    return { ...button, active: true }; //always default to true for active
                }
            }
            if (buttonType === 'endCallActive' && button.icon === this.faPhone) {
                return { ...button, active: value };
            }
            if (buttonType === 'participantsActive' && button.icon === this.faUsers) {
                return { ...button, active: value };
            }
            if (buttonType === 'showMessagesBadge' &&
                button.customName &&
                button.customName === 'Messages') {
                const updatedInjector = this.createInjector({
                    icon: this.faComments,
                    badgeValue: value ? '*' : '',
                    iconColor: 'black',
                    showBadge: value,
                });
                return { ...button, customComponent: { ...this.messageWidget, injector: updatedInjector } };
            }
            if (buttonType === 'showMenuBadge' && button.customName && button.customName === 'Menu') {
                const updatedInjector = this.createInjector({
                    icon: this.faBars,
                    badgeValue: this.totalReqWait.value,
                    iconColor: 'black',
                    showBadge: true,
                });
                return { ...button, customComponent: { ...this.menuWidget, injector: updatedInjector } };
            }
            return button;
        });
        this.cdr.detectChanges();
    }
    PrejoinPageComponent = {
        component: this.PrejoinPage,
        injector: null,
    };
    updatePrejoinPageComponent = () => {
        const PrejoinComp = {
            component: this.PrejoinPage,
            injector: this.createInjector({
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    updateSocket: this.updateSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                credentials: this.credentials,
            }),
        };
        this.PrejoinPageComponent = { ...PrejoinComp };
        this.cdr.detectChanges();
    };
    ngOnInit() {
        if (this.PrejoinPage) {
            this.updatePrejoinPageComponent();
        }
        this.setupResizeListener();
        if (this.validated) {
            this.connectAndAddSocketMethods();
        }
        this.mainHeightWidthSubscription = this.mainHeightWidth.subscribe(() => {
            this.updateMainVideoSize();
        });
        this.recordingSubscription = combineLatest([
            this.recordPaused,
            this.recordStarted,
            this.recordStopped,
            this.recordResumed,
            this.recordingProgressTime,
            this.showRecordButtons,
            this.islevel,
        ]).subscribe(([recordPaused, recordStarted, recordStopped, recordResumed, recordingProgressTime, showRecordButtons, islevel,]) => {
            if (recordPaused ||
                recordStarted ||
                recordStopped ||
                recordResumed ||
                recordingProgressTime ||
                showRecordButtons ||
                islevel) {
                this.updateRecordButtons();
            }
        });
        this.ScreenboardSubscription = combineLatest([
            this.shared,
            this.componentSizes,
            this.annotateScreenStream,
        ]).subscribe(([shared, componentSizes]) => {
            this.ScreenboardWidget = {
                component: Screenboard,
                inputs: {
                    customWidth: componentSizes.mainWidth,
                    customHeight: componentSizes.mainHeight,
                    parameters: this.mediaSFUParameters,
                    showAspect: shared,
                },
            };
        });
        this.validatedSubscription = this.validated.subscribe((validated) => {
            if (validated) {
                this.handleValidated();
            }
        });
        this.islevelSubscription = this.islevel.subscribe((islevel) => {
            if (islevel) {
                this.updateCustomMenuButtons();
            }
        });
        this.coHostSubscription = combineLatest([this.coHost, this.coHostResponsibility]).subscribe(([coHost, coHostResponsibility]) => {
            if (coHost || coHostResponsibility) {
                this.updateCustomMenuButtons();
            }
        });
        // Subscribe to changes in BehaviorSubject and update the buttons accordingly
        this.buttonSubscriptions.push(this.micActive.subscribe((value) => {
            this.updateButtonState('micActive', value);
        }));
        this.buttonSubscriptions.push(this.videoActive.subscribe((value) => {
            this.updateButtonState('videoActive', value);
        }));
        this.buttonSubscriptions.push(this.screenShareActive.subscribe((value) => {
            this.updateButtonState('screenShareActive', value);
        }));
        this.buttonSubscriptions.push(this.showMessagesBadge.subscribe((value) => {
            this.updateButtonState('showMessagesBadge', value);
        }));
        this.buttonSubscriptions.push(this.totalReqWait.subscribe(() => {
            this.updateButtonState('showMenuBadge', true);
        }));
        this.buttonSubscriptions.push(this.participantsCounter.subscribe((value) => {
            this.updateMenuParticipantsWidget(value);
        }));
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.handleResize);
        window.removeEventListener('orientationchange', this.handleResize);
        if (this.mainHeightWidthSubscription) {
            this.mainHeightWidthSubscription.unsubscribe();
        }
        if (this.validatedSubscription) {
            this.validatedSubscription.unsubscribe();
        }
        if (this.islevelSubscription) {
            this.islevelSubscription.unsubscribe();
        }
        if (this.coHostSubscription) {
            this.coHostSubscription.unsubscribe();
        }
        if (this.ScreenboardSubscription) {
            this.ScreenboardSubscription.unsubscribe();
        }
        if (this.recordingSubscription) {
            this.recordingSubscription.unsubscribe();
        }
    }
    updateMainVideoSize = async () => {
        if (!this.lock_screen.value && !this.shared.value) {
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
        }
        else {
            if (!this.first_round.value) {
                this.prepopulateUserMedia.prepopulateUserMedia({
                    name: this.hostLabel.value,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            }
        }
    };
    async connectAndAddSocketMethods() {
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
        const socket_ = await this.connect_Socket(this.apiUserName.value, '', this.apiToken.value);
        if (socket_) {
            this.updateSocket(socket_);
        }
    }
    async handleValidated() {
        this.updateAllVideoStreams([
            { producerId: 'youyou', stream: undefined, id: 'youyou', name: 'youyou' },
        ]);
        this.updateStreamNames([{ id: 'youyou', name: 'youyou', producerId: '' }]);
        if (this.validated.value) {
            this.updateIsLoadingModalVisible(true);
            try {
                if (!this.localUIMode.value) {
                    await this.connectAndAddSocketMethods();
                }
            }
            catch (error) {
                console.log('error connectAndaAddSocketMethods', error);
            }
            this.startMeetingProgressTimer.startMeetingProgressTimer({
                startTime: Date.now() / 1000,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            this.updateIsLoadingModalVisible(false);
        }
    }
    async handleResize() {
        let fraction = 0;
        if (window.innerHeight < window.innerWidth &&
            (this.eventType.value == 'webinar' || this.eventType.value == 'conference')) {
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        else {
            // Set default control button height for portrait mode or other event types
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            fraction = Number(fraction);
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        const dimensions = this.computeDimensionsMethod({
            containerWidthFraction: 1,
            containerHeightFraction: 1,
            mainSize: this.mainHeightWidth.value,
            doStack: true,
            defaultFraction: this.eventType.value == 'webinar' || this.eventType.value == 'conference'
                ? 1 - fraction
                : 1,
        });
        this.updateComponentSizes(dimensions);
        const orientation = this.checkOrientation();
        if (orientation == 'portrait') {
            if (!this.isWideScreen.value) {
                if (this.shareScreenStarted.value || this.shared.value) {
                    this.updateScreenForceFullDisplay(true);
                }
            }
        }
        // Updates the main grid view
        await this.prepopulateUserMedia.prepopulateUserMedia({
            name: this.hostLabel.value,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
        // Updates the mini grid view
        await this.onScreenChanges.onScreenChanges({
            changed: true,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
    }
    async disconnectAllSockets(consume_sockets) {
        for (const socket of consume_sockets) {
            try {
                const ip = Object.keys(socket)[0];
                await socket[ip].disconnect();
            }
            catch (error) {
                console.log(`Error disconnecting socket with IP: ${Object.keys(socket)[0]}`, error);
            }
        }
    }
    async closeAndReset() {
        //close and clean up all sockets, modals,... and reset all states to initial values
        this.updateIsMessagesModalVisible(false);
        this.updateIsParticipantsModalVisible(false);
        this.updateIsWaitingModalVisible(false);
        this.updateIsRequestsModalVisible(false);
        this.updateIsCoHostModalVisible(false);
        this.updateIsSettingsModalVisible(false);
        this.updateIsDisplaySettingsModalVisible(false);
        this.updateIsMediaSettingsModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsShareEventModalVisible(false);
        this.updateIsConfirmExitModalVisible(false);
        await this.disconnectAllSockets(this.consume_sockets.value);
        await this.updateStatesToInitialValues();
        this.updateMeetingProgressTime('00:00:00');
        this.updateMeetingElapsedTime(0);
        this.updateRecordingProgressTime('00:00:00');
        this.updateRecordElapsedTime(0);
        this.updateShowRecordButtons(false);
        this.updateIsConfigureWhiteboardModalVisible(false);
        this.updateIsWhiteboardModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsRecordingModalVisible(false);
        this.updateIsPollModalVisible(false);
        this.updateIsBreakoutRoomsModalVisible(false);
        this.updateIsBackgroundModalVisible(false);
        this.updateIsLoadingModalVisible(false);
        this.updateIsConfirmHereModalVisible(false);
        await sleep({ ms: 500 });
        this.updateValidated(false);
        //if on web, reload the page
        window.location.reload();
    }
    computeDimensionsMethod = ({ containerWidthFraction = 1, containerHeightFraction = 1, mainSize, doStack = true, defaultFraction, }) => {
        const parentWidth = window.innerWidth * containerWidthFraction;
        const parentHeight = window.innerHeight * containerHeightFraction * defaultFraction;
        let isWideScreen = parentWidth >= 768;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        const dimensions = this.calculateDimensions({
            parentWidth,
            parentHeight,
            isWideScreen,
            mainSize,
            doStack,
        });
        return dimensions;
    };
    calculateDimensions({ parentWidth, parentHeight, isWideScreen, mainSize, doStack, }) {
        if (doStack) {
            return isWideScreen
                ? {
                    mainHeight: Math.floor(parentHeight),
                    otherHeight: Math.floor(parentHeight),
                    mainWidth: Math.floor((mainSize / 100) * parentWidth),
                    otherWidth: Math.floor(((100 - mainSize) / 100) * parentWidth),
                }
                : {
                    mainHeight: Math.floor((mainSize / 100) * parentHeight),
                    otherHeight: Math.floor(((100 - mainSize) / 100) * parentHeight),
                    mainWidth: Math.floor(parentWidth),
                    otherWidth: Math.floor(parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(parentHeight),
                otherHeight: Math.floor(parentHeight),
                mainWidth: Math.floor(parentWidth),
                otherWidth: Math.floor(parentWidth),
            };
        }
    }
    handleOrientationChange() {
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('orientationchange', this.handleResize.bind(this));
    }
    setupResizeListener() {
        this.handleResize();
    }
    orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    async joinRoom(data) {
        const { socket, roomName, islevel, member, sec, apiUserName } = data;
        try {
            const response = await this.joinRoomClient.joinRoomClient({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
            return response;
        }
        catch (error) {
            console.log('Error joining room:', error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    async join_Room({ socket, roomName, islevel, member, sec, apiUserName, }) {
        const data = await this.joinRoom({
            socket: socket,
            roomName: roomName,
            islevel: islevel,
            member: member,
            sec: sec,
            apiUserName: apiUserName,
        });
        if (data && data.success) {
            this.roomData.next(data);
            try {
                this.updateRoomParametersClient.updateRoomParametersClient({
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                        data: data,
                    },
                });
                if (data.isHost) {
                    this.updateIslevel('2');
                }
                else {
                    this.updateIslevel('1');
                }
                if (data.secureCode) {
                    this.updateAdminPasscode(data.secureCode);
                }
                if (data.rtpCapabilities) {
                    const device_ = await this.createDeviceClient.createDeviceClient({
                        rtpCapabilities: data.rtpCapabilities,
                    });
                    if (device_) {
                        this.device.next(device_);
                    }
                }
            }
            catch {
                /* handle error */
            }
        }
        else {
            this.updateValidated(false);
            try {
                if (this.showAlert && data?.reason) {
                    this.showAlert({ message: data?.reason, type: 'danger', duration: 3000 });
                }
            }
            catch {
                /* handle error */
            }
        }
    }
    onParticipantsFilterChange = (value) => {
        if (value && value.length > 0) {
            this.filteredParticipants.next(this.participants.value.filter((participant) => participant.name.toLowerCase().includes(value.toLowerCase())));
            this.participantsCounter.next(this.filteredParticipants.value.length);
        }
        else {
            this.filteredParticipants.next(this.participants.value);
            this.participantsCounter.next(this.participants.value.length);
        }
    };
    updateStatesToInitialValues = async () => {
        const initialValues = initialValuesState;
        const updateFunctions = this.getAllParams();
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                const updateFunctionName = `update${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const updateFunction = updateFunctions[updateFunctionName];
                if (typeof updateFunction === 'function') {
                    try {
                        updateFunction(initialValues[key]);
                    }
                    catch {
                        /* handle error */
                    }
                }
            }
        }
    };
    faRecordVinyl = faRecordVinyl;
    faPlayCircle = faPlayCircle;
    faPauseCircle = faPauseCircle;
    faStopCircle = faStopCircle;
    faDotCircle = faDotCircle;
    faCog = faCog;
    faUsers = faUsers;
    faClock = faClock;
    faUserPlus = faUserPlus;
    faTools = faTools;
    faDesktop = faDesktop;
    faPoll = faPoll;
    faUserFriends = faUserFriends;
    faChalkboardTeacher = faChalkboardTeacher;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faPhone = faPhone;
    faBars = faBars;
    faComments = faComments;
    faChartBar = faChartBar;
    onCloseMenuModal = () => {
        this.updateIsMenuModalVisible(false);
    };
    onEventSettingsClose = () => {
        this.updateIsSettingsModalVisible(false);
    };
    onCoHostClose = () => {
        this.updateIsCoHostModalVisible(false);
    };
    onMediaSettingsClose = () => {
        this.updateIsMediaSettingsModalVisible(false);
    };
    onDisplaySettingsClose = () => {
        this.updateIsDisplaySettingsModalVisible(false);
    };
    onPollClose = () => {
        this.updateIsPollModalVisible(false);
    };
    onBreakoutRoomsClose = () => {
        this.updateIsBreakoutRoomsModalVisible(false);
    };
    onConfigureWhiteboardClose = () => {
        this.updateIsConfigureWhiteboardModalVisible(false);
    };
    onMessagesClose = () => {
        this.updateIsMessagesModalVisible(false);
    };
    onRecordingClose = () => {
        this.updateIsRecordingModalVisible(false);
    };
    onParticipantsClose = () => {
        this.updateIsParticipantsModalVisible(false);
    };
    onBackgroundClose = () => {
        this.updateIsBackgroundModalVisible(false);
    };
    onConfirmExitClose = () => {
        this.updateIsConfirmExitModalVisible(false);
    };
    onConfirmHereClose = () => {
        this.updateIsConfirmHereModalVisible(false);
    };
    onScreenboardClose = () => {
        this.updateIsScreenboardModalVisible(false);
    };
    onShareEventClose = () => {
        this.updateIsShareEventModalVisible(false);
    };
    onAlertHide = () => {
        this.updateAlertVisible(false);
    };
    ScreenboardWidget = {
        component: Screenboard,
        inputs: {
            customWidth: this.componentSizes.value.mainWidth,
            customHeight: this.componentSizes.value.mainHeight,
            parameters: this.mediaSFUParameters,
            showAspect: this.shared.value,
        },
    };
    recordTimerWidget = {
        component: RecordTimerWidget,
        injector: this.createInjector({ recordingProgressTime: this.recordingProgressTime.value }),
    };
    updateRecordTimerWidget = (recordingProgressTime = this.recordingProgressTime.value) => {
        const recordTimerWidget = {
            component: RecordTimerWidget,
            injector: this.createInjector({ recordingProgressTime: recordingProgressTime }),
        };
        this.recordTimerWidget = { ...recordTimerWidget };
        this.cdr.markForCheck();
        return recordTimerWidget;
    };
    recordButtons = [];
    recordButtonsArray = [
        {
            icon: this.faPlayCircle,
            active: () => !this.recordPaused.value,
            onPress: () => this.updateRecording.updateRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            alternateIcon: this.faPauseCircle,
            show: () => true,
        },
        {
            icon: this.faStopCircle,
            active: () => false,
            onPress: () => this.stopRecording.stopRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: () => this.updateRecordTimerWidget(),
            show: () => true,
            active: () => false,
        },
        {
            icon: this.faDotCircle,
            active: () => false,
            onPress: () => console.log('Status pressed'),
            activeColor: 'black',
            inActiveColor: () => (this.recordPaused.value ? 'yellow' : 'red'),
            show: () => true,
        },
        {
            icon: this.faCog,
            active: () => false,
            onPress: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
    ];
    async updateRecordButtons() {
        const recordButtons = this.recordButtonsArray.map((button) => {
            return {
                ...button,
                active: typeof button.active === 'function' ? button.active() : button.active,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
                activeColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
                inActiveColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
            };
        });
        this.recordButtons = [...recordButtons];
        await this.updateMenuRecordWidget(recordButtons);
        this.updateCustomMenuButtons();
        this.cdr.markForCheck();
    }
    // Create instances of the custom widgets
    menuWidget = {
        component: MenuWidget,
        injector: this.createInjector({
            icon: this.faBars,
            badgeValue: this.totalReqWait.value,
            iconColor: 'black',
            showBadge: true,
        }),
    };
    messageWidget = {
        component: MessageWidget,
        injector: this.createInjector({
            icon: this.faComments,
            showBadge: this.showMessagesBadge.value,
            badgeValue: 1,
            iconColor: 'black',
        }),
    };
    menuRecordWidget = {
        component: MenuRecordWidget,
        injector: this.createInjector({
            buttons: this.recordButtons,
            showAspect: true,
            direction: 'horizontal',
        }),
    };
    updateMenuRecordWidget = (recordButtons = this.recordButtons) => {
        const menuRecordWidget = {
            component: MenuRecordWidget,
            injector: this.createInjector({
                buttons: recordButtons,
                showAspect: true,
                direction: 'horizontal',
            }),
        };
        this.menuRecordWidget = { ...menuRecordWidget };
        this.cdr.markForCheck();
        return menuRecordWidget;
    };
    menuParticipantsWidget = {
        component: MenuParticipantsWidget,
        injector: this.createInjector({
            icon: this.faChartBar,
            participantsCounter: this.participantsCounter.value,
            iconColor: 'black',
        }),
    };
    updateMenuParticipantsWidget = (count = this.participantsCounter.value) => {
        const menuParticipantsWidget = {
            component: MenuParticipantsWidget,
            injector: this.createInjector({
                icon: this.faChartBar,
                participantsCounter: count,
                iconColor: 'black',
            }),
        };
        this.menuParticipantsWidget = { ...menuParticipantsWidget };
        this.cdr.markForCheck();
        return menuParticipantsWidget;
    };
    customMenuButtonsArray = [
        {
            icon: this.faRecordVinyl,
            text: 'Record',
            action: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            show: () => !this.showRecordButtons.value && this.islevel.value == '2',
        },
        {
            customComponent: () => this.updateMenuRecordWidget(),
            show: () => this.showRecordButtons.value && this.islevel.value == '2',
            action: () => console.log('record buttons pressed'),
        },
        {
            icon: this.faCog,
            text: 'Event Settings',
            action: () => this.launchSettings.launchSettings({
                updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
                isSettingsModalVisible: this.isSettingsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faUsers,
            text: 'Requests',
            action: () => this.launchRequests.launchRequests({
                updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
                isRequestsModalVisible: this.isRequestsModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                ((this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    !!this.coHostResponsibility?.value?.find((item) => item.name === 'media')?.value) ??
                    false) ||
                false,
        },
        {
            icon: this.faClock,
            text: 'Waiting',
            action: () => this.launchWaiting.launchWaiting({
                updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
                isWaitingModalVisible: this.isWaitingModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                (this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    this.coHostResponsibility?.value?.find((item) => item.name === 'waiting')?.value ===
                        true) ||
                false,
        },
        {
            icon: this.faUserPlus,
            text: 'Co-host',
            action: () => this.launchCoHost.launchCoHost({
                updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
                isCoHostModalVisible: this.isCoHostModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faTools,
            text: 'Set Media',
            action: () => this.launchMediaSettings.launchMediaSettings({
                updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
                isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
                audioInputs: this.audioInputs.value,
                videoInputs: this.videoInputs.value,
                updateAudioInputs: this.updateAudioInputs.bind(this),
                updateVideoInputs: this.updateVideoInputs.bind(this),
            }),
            show: () => true,
        },
        {
            icon: this.faDesktop,
            text: 'Display',
            action: () => this.launchDisplaySettings.launchDisplaySettings({
                updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
                isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faPoll,
            text: 'Poll',
            action: () => this.launchPoll.launchPoll({
                updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                isPollModalVisible: this.isPollModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faUserFriends,
            text: 'Breakout Rooms',
            action: () => this.launchBreakoutRooms.launchBreakoutRooms({
                updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
                isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faChalkboardTeacher,
            text: 'Whiteboard',
            action: () => this.launchConfigureWhiteboard.launchConfigureWhiteboard({
                updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
                isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
    ];
    customMenuButtons = [];
    updateCustomMenuButtons() {
        this.customMenuButtons = this.customMenuButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
            };
        });
    }
    screenShareWidget = {
        component: ScreenShareWidget,
        injector: this.createInjector({ disabled: !this.screenShareActive.value }),
    };
    controlButtons = [
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.audioSwitching.value,
            show: true,
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                    MediaStream,
                    MediaStreamTrack,
                    mediaDevices: MediaDevices,
                    device: this.device.value,
                    socket: this.socket.value,
                    showAlert: this.showAlert.bind(this),
                    checkPermission: this.checkPermission.checkPermission,
                    streamSuccessVideo: this.streamSuccessVideo.streamSuccessVideo,
                    hasCameraPermission: this.hasCameraPermission.value,
                    requestPermissionCamera: this.requestPermissionCamera.bind(this),
                    checkMediaPermission: 'web' !== 'web',
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.videoSwitching.value,
            show: true,
        },
        {
            //inverted active for inactive state
            icon: faDesktop,
            alternateIconComponent: this.screenShareWidget,
            active: true,
            onPress: () => this.clickScreenShare.clickScreenShare({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faUsers,
            active: this.participantsActive.value,
            onPress: () => this.launchParticipants.launchParticipants({
                updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
                isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            disabled: false,
            show: true,
        },
        {
            customComponent: this.menuWidget,
            customName: 'Menu',
            onPress: () => this.launchMenuModal.launchMenuModal({
                updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
                isMenuModalVisible: this.isMenuModalVisible.value,
            }),
            show: true,
        },
        {
            customComponent: this.messageWidget,
            customName: 'Messages',
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: true,
        },
    ];
    async connect_Socket(apiUserName, apiKey, apiToken) {
        if (this.socket.value && this.socket.value.id) {
            this.socket.value.on('disconnect', async () => {
                await this.disconnect.disconnect({
                    showAlert: this.showAlert.bind(this),
                    redirectURL: this.redirectURL.value,
                    onWeb: true,
                    updateValidated: this.updateValidated.bind(this),
                });
                if (this.videoAlreadyOn.value) {
                    await this.clickVideo.clickVideo({
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                if (this.audioAlreadyOn.value) {
                    await this.clickAudio.clickAudio({
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                await this.closeAndReset();
            });
            this.socket.value.on('allMembers', async (membersData) => {
                if (membersData) {
                    await this.allMembers.allMembers({
                        apiUserName: apiUserName,
                        apiKey: '', //not recommended - use apiToken instead. Use for testing/development only
                        apiToken: apiToken,
                        members: membersData.members,
                        requestss: membersData.requests ? membersData.requests : this.requestList.value,
                        coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                        coHostRes: membersData.coHostResponsibilities
                            ? membersData.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        consume_sockets: this.consume_sockets.value,
                    });
                }
            });
            this.socket.value.on('allMembersRest', async (membersData) => {
                if (membersData) {
                    await this.allMembersRest.allMembersRest({
                        apiUserName: apiUserName,
                        apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                        members: membersData.members,
                        apiToken: apiToken,
                        settings: membersData.settings,
                        coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                        coHostRes: membersData.coHostResponsibilities
                            ? membersData.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        consume_sockets: this.consume_sockets.value,
                    });
                }
            });
            this.socket.value.on('userWaiting', async ({ name }) => {
                await this.userWaiting.userWaiting({
                    name,
                    showAlert: this.showAlert.bind(this),
                    totalReqWait: this.totalReqWait.value,
                    updateTotalReqWait: this.updateTotalReqWait.bind(this),
                });
            });
            this.socket.value.on('personJoined', async ({ name }) => {
                this.personJoined.personJoined({
                    name,
                    showAlert: this.showAlert.bind(this),
                });
            });
            this.socket.value.on('allWaitingRoomMembers', async (waiting_data) => {
                await this.allWaitingRoomMembers.allWaitingRoomMembers({
                    waitingParticipants: waiting_data.waitingParticipants
                        ? waiting_data.waitingParticipants
                        : waiting_data.waitingParticipantss
                            ? waiting_data.waitingParticipantss
                            : this.waitingRoomList.value,
                    updateTotalReqWait: this.updateTotalReqWait.bind(this),
                    updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
                });
            });
            this.socket.value.on('roomRecordParams', async ({ recordParams }) => {
                this.roomRecordParams.roomRecordParams({
                    recordParams,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('ban', async ({ name }) => {
                await this.banParticipant.banParticipant({
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('updatedCoHost', async (cohost_data) => {
                await this.updatedCoHost.updatedCoHost({
                    coHost: cohost_data.coHost ? cohost_data.coHost : this.coHost.value,
                    coHostResponsibility: cohost_data.coHostResponsibilities
                        ? cohost_data.coHostResponsibilities
                        : this.coHostResponsibility.value,
                    youAreCoHost: this.youAreCoHost.value,
                    updateCoHost: this.updateCoHost.bind(this),
                    updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
                    updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
                    showAlert: this.showAlert.bind(this),
                    eventType: this.eventType.value,
                    islevel: this.islevel.value,
                    member: this.member.value,
                });
            });
            this.socket.value.on('participantRequested', async ({ userRequest }) => {
                await this.participantRequested.participantRequested({
                    userRequest,
                    requestList: this.requestList.value,
                    waitingRoomList: this.waitingRoomList.value,
                    updateTotalReqWait: this.updateTotalReqWait.bind(this),
                    updateRequestList: this.updateRequestList.bind(this),
                });
            });
            this.socket.value.on('screenProducerId', async ({ producerId }) => {
                this.screenProducerId.screenProducerId({
                    producerId,
                    screenId: this.screenId.value,
                    membersReceived: this.membersReceived.value,
                    shareScreenStarted: this.shareScreenStarted.value,
                    deferScreenReceived: this.deferScreenReceived.value,
                    participants: this.participants.value,
                    updateScreenId: this.updateScreenId.bind(this),
                    updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
                    updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
                });
            });
            //settings, updateAudioSetting, updateVideoSetting, updateScreenshareSetting, updateChatSetting
            this.socket.value.on('updateMediaSettings', async ({ settings }) => {
                this.updateMediaSettings.updateMediaSettings({
                    settings,
                    updateAudioSetting: this.updateAudioSetting.bind(this),
                    updateVideoSetting: this.updateVideoSetting.bind(this),
                    updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
                    updateChatSetting: this.updateChatSetting.bind(this),
                });
            });
            this.socket.value.on('producer-media-paused', async ({ producerId, kind, name, }) => {
                await this.producerMediaPaused.producerMediaPaused({
                    producerId,
                    kind,
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('producer-media-resumed', async ({ kind, name }) => {
                await this.producerMediaResumed.producerMediaResumed({
                    kind,
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('producer-media-closed', async ({ producerId, kind, }) => {
                if (producerId && kind) {
                    await this.producerMediaClosed.producerMediaClosed({
                        producerId,
                        kind,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
            });
            this.socket.value.on('controlMediaHost', async ({ type }) => {
                await this.controlMediaHost.controlMediaHost({
                    type,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('meetingEnded', async () => {
                await this.meetingEnded.meetingEnded({
                    showAlert: this.showAlert.bind(this),
                    redirectURL: this.redirectURL.value,
                    onWeb: true,
                    eventType: this.eventType.value,
                    updateValidated: this.updateValidated.bind(this),
                });
                if (this.videoAlreadyOn.value) {
                    await this.clickVideo.clickVideo({
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                }
                if (this.audioAlreadyOn.value) {
                    await this.clickAudio.clickAudio({
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                }
                await this.closeAndReset();
            });
            this.socket.value.on('disconnectUserSelf', async () => {
                await this.disconnectUserSelf.disconnectUserSelf({
                    socket: this.socket.value,
                    member: this.member.value,
                    roomName: this.roomName.value,
                });
            });
            this.socket.value.on('receiveMessage', async ({ message }) => {
                await this.receiveMessage.receiveMessage({
                    message,
                    messages: this.messages.value,
                    participantsAll: this.participantsAll.value,
                    member: this.member.value,
                    eventType: this.eventType.value,
                    islevel: this.islevel.value,
                    coHost: this.coHost.value,
                    updateMessages: this.updateMessages.bind(this),
                    updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
                });
            });
            this.socket.value.on('meetingTimeRemaining', async ({ timeRemaining }) => {
                await this.meetingTimeRemaining.meetingTimeRemaining({
                    timeRemaining,
                    showAlert: this.showAlert.bind(this),
                    eventType: this.eventType.value,
                });
            });
            this.socket.value.on('meetingStillThere', async () => {
                this.meetingStillThere.meetingStillThere({
                    updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
                });
            });
            this.socket.value.on('startRecords', async () => {
                await this.startRecords.startRecords({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: this.socket.value,
                });
            });
            this.socket.value.on('reInitiateRecording', async () => {
                await this.reInitiateRecording.reInitiateRecording({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: this.socket.value,
                    adminRestrictSetting: this.adminRestrictSetting.value,
                });
            });
            this.socket.value.on('updateConsumingDomains', async ({ domains, alt_domains }) => {
                await this.updateConsumingDomains.updateConsumingDomains({
                    domains,
                    alt_domains,
                    apiUserName,
                    apiKey,
                    apiToken,
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                    },
                });
            });
            this.socket.value.on('RecordingNotice', async ({ state, userRecordingParam, pauseCount, timeDone }) => {
                await this.recordingNotice.RecordingNotice({
                    state,
                    userRecordingParam,
                    pauseCount,
                    timeDone,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('timeLeftRecording', async ({ timeLeft }) => {
                this.timeLeftRecording.timeLeftRecording({
                    timeLeft,
                    showAlert: this.showAlert.bind(this),
                });
            });
            this.socket.value.on('stoppedRecording', async ({ state, reason }) => {
                await this.stoppedRecording.stoppedRecording({
                    state,
                    reason,
                    showAlert: this.showAlert.bind(this),
                });
            });
            this.socket.value.on('hostRequestResponse', ({ requestResponse }) => {
                this.hostRequestResponse.hostRequestResponse({
                    requestResponse,
                    showAlert: this.showAlert.bind(this),
                    requestList: this.requestList.value,
                    updateRequestList: this.updateRequestList.bind(this),
                    updateMicAction: this.updateMicAction.bind(this),
                    updateVideoAction: this.updateVideoAction.bind(this),
                    updateScreenAction: this.updateScreenAction.bind(this),
                    updateChatAction: this.updateChatAction.bind(this),
                    updateAudioRequestState: this.updateAudioRequestState.bind(this),
                    updateVideoRequestState: this.updateVideoRequestState.bind(this),
                    updateScreenRequestState: this.updateScreenRequestState.bind(this),
                    updateChatRequestState: this.updateChatRequestState.bind(this),
                    updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
                    updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
                    updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
                    updateChatRequestTime: this.updateChatRequestTime.bind(this),
                    updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
                });
            });
            this.socket.value.on('pollUpdated', async (data) => {
                try {
                    await this.pollUpdated.pollUpdated({
                        data,
                        polls: this.polls.value,
                        poll: this.poll.value ? this.poll.value : {},
                        member: this.member.value,
                        islevel: this.islevel.value,
                        showAlert: this.showAlert.bind(this),
                        updatePolls: this.updatePolls.bind(this),
                        updatePoll: this.updatePoll.bind(this),
                        updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                    });
                }
                catch {
                    /* handle error */
                }
            });
            this.socket.value.on('breakoutRoomUpdated', async (data) => {
                try {
                    await this.breakoutRoomUpdated.breakoutRoomUpdated({
                        data,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                catch {
                    /* handle error */
                }
            });
            await this.join_Room({
                socket: this.socket.value,
                roomName: this.roomName.value,
                islevel: this.islevel.value,
                member: this.member.value,
                sec: this.apiToken.value,
                apiUserName: this.apiUserName.value,
            });
            await this.receiveRoomMessages.receiveRoomMessages({
                socket: this.socket.value,
                roomName: this.roomName.value,
                updateMessages: this.updateMessages.bind(this),
            });
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            return this.socket.value;
        }
        else {
            return null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediasfuConference, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.Injector }, { token: UpdateMiniCardsGrid }, { token: MixStreams }, { token: DispStreams }, { token: StopShareScreen }, { token: CheckScreenShare }, { token: StartShareScreen }, { token: RequestScreenShare }, { token: ReorderStreams }, { token: PrepopulateUserMedia }, { token: GetVideos }, { token: RePort }, { token: Trigger }, { token: ConsumerResume }, { token: ConnectSendTransport }, { token: ConnectSendTransportAudio }, { token: ConnectSendTransportVideo }, { token: ConnectSendTransportScreen }, { token: ProcessConsumerTransports }, { token: ResumePauseStreams }, { token: Readjust }, { token: CheckGrid }, { token: GetEstimate }, { token: CalculateRowsAndColumns }, { token: AddVideosGrid }, { token: OnScreenChanges }, { token: ChangeVids }, { token: CompareActiveNames }, { token: CompareScreenStates }, { token: CreateSendTransport }, { token: ResumeSendTransportAudio }, { token: ReceiveAllPipedTransports }, { token: DisconnectSendTransportVideo }, { token: DisconnectSendTransportAudio }, { token: DisconnectSendTransportScreen }, { token: GetPipedProducersAlt }, { token: SignalNewConsumerTransport }, { token: ConnectRecvTransport }, { token: ReUpdateInter }, { token: UpdateParticipantAudioDecibels }, { token: CloseAndResize }, { token: AutoAdjust }, { token: SwitchUserVideoAlt }, { token: SwitchUserVideo }, { token: SwitchUserAudio }, { token: GetDomains }, { token: FormatNumber }, { token: ConnectIps }, { token: CreateDeviceClient }, { token: HandleCreatePoll }, { token: HandleEndPoll }, { token: HandleVotePoll }, { token: CaptureCanvasStream }, { token: ResumePauseAudioStreams }, { token: ProcessConsumerTransportsAudio }, { token: LaunchMenuModal }, { token: LaunchRecording }, { token: StartRecording }, { token: ConfirmRecording }, { token: LaunchWaiting }, { token: launchCoHost }, { token: LaunchMediaSettings }, { token: LaunchDisplaySettings }, { token: LaunchSettings }, { token: LaunchRequests }, { token: LaunchParticipants }, { token: LaunchMessages }, { token: LaunchConfirmExit }, { token: LaunchPoll }, { token: LaunchBreakoutRooms }, { token: LaunchConfigureWhiteboard }, { token: StartMeetingProgressTimer }, { token: UpdateRecording }, { token: StopRecording }, { token: UserWaiting }, { token: PersonJoined }, { token: AllWaitingRoomMembers }, { token: RoomRecordParams }, { token: BanParticipant }, { token: UpdatedCoHost }, { token: ParticipantRequested }, { token: ScreenProducerId }, { token: UpdateMediaSettings }, { token: ProducerMediaPaused }, { token: ProducerMediaResumed }, { token: ProducerMediaClosed }, { token: ControlMediaHost }, { token: MeetingEnded }, { token: DisconnectUserSelf }, { token: ReceiveMessage }, { token: MeetingTimeRemaining }, { token: MeetingStillThere }, { token: StartRecords }, { token: ReInitiateRecording }, { token: RecordingNotice }, { token: TimeLeftRecording }, { token: StoppedRecording }, { token: HostRequestResponse }, { token: AllMembers }, { token: AllMembersRest }, { token: Disconnect }, { token: PollUpdated }, { token: BreakoutRoomUpdated }, { token: SocketManager }, { token: JoinRoomClient }, { token: UpdateRoomParametersClient }, { token: ClickVideo }, { token: ClickAudio }, { token: ClickScreenShare }, { token: StreamSuccessVideo }, { token: StreamSuccessAudio }, { token: StreamSuccessScreen }, { token: StreamSuccessAudioSwitch }, { token: CheckPermission }, { token: UpdateConsumingDomains }, { token: ReceiveRoomMessages }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MediasfuConference, isStandalone: true, selector: "app-mediasfu-conference", inputs: { PrejoinPage: "PrejoinPage", credentials: "credentials", useLocalUIMode: "useLocalUIMode", seedData: "seedData", useSeed: "useSeed", imgSrc: "imgSrc" }, host: { listeners: { "window:resize": "handleResize()", "window:orientationchange": "handleResize()" } }, providers: [CookieService], ngImport: i0, template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component>
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: BreakoutRoomsModal, selector: "app-breakout-rooms-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onBreakoutRoomsClose"] }, { kind: "component", type: BackgroundModal, selector: "app-background-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onClose"] }, { kind: "component", type: CoHostModal, selector: "app-co-host-modal", inputs: ["isCoHostModalVisible", "currentCohost", "participants", "coHostResponsibility", "position", "backgroundColor", "roomName", "showAlert", "updateCoHostResponsibility", "updateCoHost", "updateIsCoHostModalVisible", "socket", "onCoHostClose", "onModifyCoHost"] }, { kind: "component", type: AlertComponent, selector: "app-alert-component", inputs: ["visible", "message", "type", "duration", "textColor", "onHide"] }, { kind: "component", type: AudioGrid, selector: "app-audio-grid", inputs: ["componentsToRender"] }, { kind: "component", type: ControlButtonsComponent, selector: "app-control-buttons-component", inputs: ["buttons", "buttonColor", "buttonBackgroundColor", "alignment", "vertical", "buttonsContainerStyle"] }, { kind: "component", type: FlexibleGrid, selector: "app-flexible-grid", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "backgroundColor"] }, { kind: "component", type: FlexibleVideo, selector: "app-flexible-video", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "showAspect", "backgroundColor", "Screenboard", "annotateScreenStream", "localStreamScreen"] }, { kind: "component", type: LoadingModal, selector: "app-loading-modal", inputs: ["isVisible", "backgroundColor", "displayColor"] }, { kind: "component", type: Pagination, selector: "app-pagination", inputs: ["totalPages", "currentUserPage", "handlePageChange", "position", "location", "direction", "buttonsContainerStyle", "activePageStyle", "inactivePageStyle", "backgroundColor", "paginationHeight", "showAspect", "parameters"] }, { kind: "component", type: SubAspectComponent, selector: "app-sub-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFractionSub"] }, { kind: "component", type: DisplaySettingsModal, selector: "app-display-settings-modal", inputs: ["isDisplaySettingsModalVisible", "onDisplaySettingsClose", "onModifyDisplaySettings", "parameters", "position", "backgroundColor"] }, { kind: "component", type: EventSettingsModal, selector: "app-event-settings-modal", inputs: ["isEventSettingsModalVisible", "onEventSettingsClose", "onModifyEventSettings", "position", "backgroundColor", "audioSetting", "videoSetting", "screenshareSetting", "chatSetting", "updateAudioSetting", "updateVideoSetting", "updateScreenshareSetting", "updateChatSetting", "updateIsSettingsModalVisible", "roomName", "socket", "showAlert"] }, { kind: "component", type: ConfirmExitModal, selector: "app-confirm-exit-modal", inputs: ["isConfirmExitModalVisible", "onConfirmExitClose", "position", "backgroundColor", "exitEventOnConfirm", "member", "ban", "roomName", "socket", "islevel"] }, { kind: "component", type: MediaSettingsModal, selector: "app-media-settings-modal", inputs: ["isMediaSettingsModalVisible", "onMediaSettingsClose", "switchCameraOnPress", "switchVideoOnPress", "switchAudioOnPress", "parameters", "position", "backgroundColor"] }, { kind: "component", type: MenuModal, selector: "app-menu-modal", inputs: ["backgroundColor", "isVisible", "customButtons", "shareButtons", "position", "roomName", "adminPasscode", "islevel", "eventType", "onClose"] }, { kind: "component", type: MessagesModal, selector: "app-messages-modal", inputs: ["isMessagesModalVisible", "onMessagesClose", "onSendMessagePress", "messages", "position", "backgroundColor", "activeTabBackgroundColor", "eventType", "member", "islevel", "coHostResponsibility", "coHost", "startDirectMessage", "directMessageDetails", "updateStartDirectMessage", "updateDirectMessageDetails", "showAlert", "roomName", "socket", "chatSetting"] }, { kind: "component", type: ConfirmHereModal, selector: "app-confirm-here-modal", inputs: ["isConfirmHereModalVisible", "position", "backgroundColor", "displayColor", "onConfirmHereClose", "countdownDuration", "socket", "roomName", "member"] }, { kind: "component", type: ShareEventModal, selector: "app-share-event-modal", inputs: ["backgroundColor", "isShareEventModalVisible", "onShareEventClose", "roomName", "adminPasscode", "islevel", "position", "shareButtons", "eventType"] }, { kind: "component", type: ParticipantsModal, selector: "app-participants-modal", inputs: ["isParticipantsModalVisible", "onParticipantsClose", "onParticipantsFilterChange", "participantsCounter", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "parameters", "position", "backgroundColor"] }, { kind: "component", type: PollModal, selector: "app-poll-modal", inputs: ["isPollModalVisible", "onClose", "position", "backgroundColor", "member", "islevel", "polls", "poll", "socket", "roomName", "showAlert", "updateIsPollModalVisible", "handleCreatePoll", "handleEndPoll", "handleVotePoll"] }, { kind: "component", type: RecordingModal, selector: "app-recording-modal", inputs: ["isRecordingModalVisible", "onClose", "backgroundColor", "position", "confirmRecording", "startRecording", "parameters"] }, { kind: "component", type: RequestsModal, selector: "app-requests-modal", inputs: ["isRequestsModalVisible", "requestCounter", "requestList", "roomName", "socket", "backgroundColor", "position", "parameters", "onRequestClose", "onRequestFilterChange", "onRequestItemPress", "updateRequestList"] }, { kind: "component", type: MainAspectComponent, selector: "app-main-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "updateIsWideScreen", "updateIsMediumScreen", "updateIsSmallScreen"] }, { kind: "component", type: MainContainerComponent, selector: "app-main-container-component", inputs: ["backgroundColor", "containerWidthFraction", "containerHeightFraction", "marginLeft", "marginRight", "marginTop", "marginBottom", "padding"] }, { kind: "component", type: MainGridComponent, selector: "app-main-grid-component", inputs: ["backgroundColor", "mainSize", "height", "width", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: MainScreenComponent, selector: "app-main-screen-component", inputs: ["mainSize", "doStack", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "showControls", "updateComponentSizes"] }, { kind: "component", type: OtherGridComponent, selector: "app-other-grid-component", inputs: ["backgroundColor", "width", "height", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: ScreenboardModal, selector: "app-screenboard-modal", inputs: ["parameters", "isVisible", "onClose", "position", "backgroundColor"] }, { kind: "component", type: Whiteboard, selector: "app-whiteboard", inputs: ["customWidth", "customHeight", "parameters", "showAspect"] }, { kind: "component", type: ConfigureWhiteboardModal, selector: "app-configure-whiteboard-modal", inputs: ["isVisible", "parameters", "backgroundColor", "position", "onConfigureWhiteboardClose"] }, { kind: "component", type: WaitingRoomModal, selector: "app-waiting-room-modal", inputs: ["isWaitingModalVisible", "waitingRoomCounter", "waitingRoomList", "roomName", "socket", "position", "backgroundColor", "parameters", "onWaitingRoomClose", "onWaitingRoomFilterChange", "updateWaitingList", "onWaitingRoomItemPress"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediasfuConference, decorators: [{
            type: Component,
            args: [{ selector: 'app-mediasfu-conference', standalone: true, imports: [
                        RouterOutlet,
                        CommonModule,
                        BreakoutRoomsModal,
                        BackgroundModal,
                        CoHostModal,
                        AlertComponent,
                        AudioGrid,
                        ControlButtonsAltComponent,
                        ControlButtonsComponent,
                        FlexibleGrid,
                        FlexibleVideo,
                        LoadingModal,
                        Pagination,
                        SubAspectComponent,
                        DisplaySettingsModal,
                        EventSettingsModal,
                        ConfirmExitModal,
                        MediaSettingsModal,
                        MenuModal,
                        MessagesModal,
                        ConfirmHereModal,
                        ShareEventModal,
                        WelcomePage,
                        ParticipantsModal,
                        PollModal,
                        RecordingModal,
                        RequestsModal,
                        MainAspectComponent,
                        MainContainerComponent,
                        MainGridComponent,
                        MainScreenComponent,
                        OtherGridComponent,
                        Screenboard,
                        ScreenboardModal,
                        Whiteboard,
                        ConfigureWhiteboardModal,
                        WaitingRoomModal,
                        MenuWidget,
                        MessageWidget,
                        MenuRecordWidget,
                        RecordTimerWidget,
                        MenuParticipantsWidget,
                        ScreenShareWidget,
                    ], template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component>
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </div>
  `, providers: [CookieService] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: UpdateMiniCardsGrid }, { type: MixStreams }, { type: DispStreams }, { type: StopShareScreen }, { type: CheckScreenShare }, { type: StartShareScreen }, { type: RequestScreenShare }, { type: ReorderStreams }, { type: PrepopulateUserMedia }, { type: GetVideos }, { type: RePort }, { type: Trigger }, { type: ConsumerResume }, { type: ConnectSendTransport }, { type: ConnectSendTransportAudio }, { type: ConnectSendTransportVideo }, { type: ConnectSendTransportScreen }, { type: ProcessConsumerTransports }, { type: ResumePauseStreams }, { type: Readjust }, { type: CheckGrid }, { type: GetEstimate }, { type: CalculateRowsAndColumns }, { type: AddVideosGrid }, { type: OnScreenChanges }, { type: ChangeVids }, { type: CompareActiveNames }, { type: CompareScreenStates }, { type: CreateSendTransport }, { type: ResumeSendTransportAudio }, { type: ReceiveAllPipedTransports }, { type: DisconnectSendTransportVideo }, { type: DisconnectSendTransportAudio }, { type: DisconnectSendTransportScreen }, { type: GetPipedProducersAlt }, { type: SignalNewConsumerTransport }, { type: ConnectRecvTransport }, { type: ReUpdateInter }, { type: UpdateParticipantAudioDecibels }, { type: CloseAndResize }, { type: AutoAdjust }, { type: SwitchUserVideoAlt }, { type: SwitchUserVideo }, { type: SwitchUserAudio }, { type: GetDomains }, { type: FormatNumber }, { type: ConnectIps }, { type: CreateDeviceClient }, { type: HandleCreatePoll }, { type: HandleEndPoll }, { type: HandleVotePoll }, { type: CaptureCanvasStream }, { type: ResumePauseAudioStreams }, { type: ProcessConsumerTransportsAudio }, { type: LaunchMenuModal }, { type: LaunchRecording }, { type: StartRecording }, { type: ConfirmRecording }, { type: LaunchWaiting }, { type: launchCoHost }, { type: LaunchMediaSettings }, { type: LaunchDisplaySettings }, { type: LaunchSettings }, { type: LaunchRequests }, { type: LaunchParticipants }, { type: LaunchMessages }, { type: LaunchConfirmExit }, { type: LaunchPoll }, { type: LaunchBreakoutRooms }, { type: LaunchConfigureWhiteboard }, { type: StartMeetingProgressTimer }, { type: UpdateRecording }, { type: StopRecording }, { type: UserWaiting }, { type: PersonJoined }, { type: AllWaitingRoomMembers }, { type: RoomRecordParams }, { type: BanParticipant }, { type: UpdatedCoHost }, { type: ParticipantRequested }, { type: ScreenProducerId }, { type: UpdateMediaSettings }, { type: ProducerMediaPaused }, { type: ProducerMediaResumed }, { type: ProducerMediaClosed }, { type: ControlMediaHost }, { type: MeetingEnded }, { type: DisconnectUserSelf }, { type: ReceiveMessage }, { type: MeetingTimeRemaining }, { type: MeetingStillThere }, { type: StartRecords }, { type: ReInitiateRecording }, { type: RecordingNotice }, { type: TimeLeftRecording }, { type: StoppedRecording }, { type: HostRequestResponse }, { type: AllMembers }, { type: AllMembersRest }, { type: Disconnect }, { type: PollUpdated }, { type: BreakoutRoomUpdated }, { type: SocketManager }, { type: JoinRoomClient }, { type: UpdateRoomParametersClient }, { type: ClickVideo }, { type: ClickAudio }, { type: ClickScreenShare }, { type: StreamSuccessVideo }, { type: StreamSuccessAudio }, { type: StreamSuccessScreen }, { type: StreamSuccessAudioSwitch }, { type: CheckPermission }, { type: UpdateConsumingDomains }, { type: ReceiveRoomMessages }], propDecorators: { PrejoinPage: [{
                type: Input
            }], credentials: [{
                type: Input
            }], useLocalUIMode: [{
                type: Input
            }], seedData: [{
                type: Input
            }], useSeed: [{
                type: Input
            }], imgSrc: [{
                type: Input
            }], handleResize: [{
                type: HostListener,
                args: ['window:resize']
            }, {
                type: HostListener,
                args: ['window:orientationchange']
            }] } });

class MediasfuChat {
    cdr;
    injector;
    updateMiniCardsGrid;
    mixStreams;
    dispStreams;
    stopShareScreen;
    checkScreenShare;
    startShareScreen;
    requestScreenShare;
    reorderStreams;
    prepopulateUserMedia;
    getVideos;
    rePort;
    trigger;
    consumerResume;
    connectSendTransport;
    connectSendTransportAudio;
    connectSendTransportVideo;
    connectSendTransportScreen;
    processConsumerTransports;
    resumePauseStreams;
    readjust;
    checkGrid;
    getEstimate;
    calculateRowsAndColumns;
    addVideosGrid;
    onScreenChanges;
    changeVids;
    compareActiveNames;
    compareScreenStates;
    createSendTransport;
    resumeSendTransportAudio;
    receiveAllPipedTransports;
    disconnectSendTransportVideo;
    disconnectSendTransportAudio;
    disconnectSendTransportScreen;
    getPipedProducersAlt;
    signalNewConsumerTransport;
    connectRecvTransport;
    reUpdateInter;
    updateParticipantAudioDecibels;
    closeAndResize;
    autoAdjust;
    switchUserVideoAlt;
    switchUserVideo;
    switchUserAudio;
    getDomains;
    formatNumber;
    connectIps;
    createDeviceClient;
    captureCanvasStream;
    resumePauseAudioStreams;
    processConsumerTransportsAudio;
    launchMessages;
    launchConfirmExit;
    startMeetingProgressTimer;
    producerMediaPaused;
    producerMediaResumed;
    producerMediaClosed;
    meetingEnded;
    disconnectUserSelf;
    receiveMessage;
    meetingTimeRemaining;
    meetingStillThere;
    allMembers;
    allMembersRest;
    disconnect;
    socketManager;
    joinRoomClient;
    updateRoomParametersClient;
    clickVideo;
    clickAudio;
    clickScreenShare;
    switchVideoAlt;
    streamSuccessVideo;
    streamSuccessAudio;
    streamSuccessScreen;
    streamSuccessAudioSwitch;
    checkPermission;
    updateConsumingDomains;
    receiveRoomMessages;
    PrejoinPage = WelcomePage;
    credentials = { apiUserName: '', apiKey: '' };
    useLocalUIMode = false;
    seedData;
    useSeed = false;
    imgSrc = 'https://mediasfu.com/images/logo192.png';
    title = 'MediaSFU-Chat';
    mainHeightWidthSubscription;
    validatedSubscription;
    islevelSubscription;
    coHostSubscription;
    ScreenboardSubscription;
    recordingSubscription;
    constructor(cdr, injector, updateMiniCardsGrid, mixStreams, dispStreams, stopShareScreen, checkScreenShare, startShareScreen, requestScreenShare, reorderStreams, prepopulateUserMedia, getVideos, rePort, trigger, consumerResume, connectSendTransport, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, processConsumerTransports, resumePauseStreams, readjust, checkGrid, getEstimate, calculateRowsAndColumns, addVideosGrid, onScreenChanges, changeVids, compareActiveNames, compareScreenStates, createSendTransport, resumeSendTransportAudio, receiveAllPipedTransports, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, getPipedProducersAlt, signalNewConsumerTransport, connectRecvTransport, reUpdateInter, updateParticipantAudioDecibels, closeAndResize, autoAdjust, switchUserVideoAlt, switchUserVideo, switchUserAudio, getDomains, formatNumber, connectIps, createDeviceClient, captureCanvasStream, resumePauseAudioStreams, processConsumerTransportsAudio, launchMessages, launchConfirmExit, startMeetingProgressTimer, producerMediaPaused, producerMediaResumed, producerMediaClosed, meetingEnded, disconnectUserSelf, receiveMessage, meetingTimeRemaining, meetingStillThere, allMembers, allMembersRest, disconnect, socketManager, joinRoomClient, updateRoomParametersClient, clickVideo, clickAudio, clickScreenShare, switchVideoAlt, streamSuccessVideo, streamSuccessAudio, streamSuccessScreen, streamSuccessAudioSwitch, checkPermission, updateConsumingDomains, receiveRoomMessages) {
        this.cdr = cdr;
        this.injector = injector;
        this.updateMiniCardsGrid = updateMiniCardsGrid;
        this.mixStreams = mixStreams;
        this.dispStreams = dispStreams;
        this.stopShareScreen = stopShareScreen;
        this.checkScreenShare = checkScreenShare;
        this.startShareScreen = startShareScreen;
        this.requestScreenShare = requestScreenShare;
        this.reorderStreams = reorderStreams;
        this.prepopulateUserMedia = prepopulateUserMedia;
        this.getVideos = getVideos;
        this.rePort = rePort;
        this.trigger = trigger;
        this.consumerResume = consumerResume;
        this.connectSendTransport = connectSendTransport;
        this.connectSendTransportAudio = connectSendTransportAudio;
        this.connectSendTransportVideo = connectSendTransportVideo;
        this.connectSendTransportScreen = connectSendTransportScreen;
        this.processConsumerTransports = processConsumerTransports;
        this.resumePauseStreams = resumePauseStreams;
        this.readjust = readjust;
        this.checkGrid = checkGrid;
        this.getEstimate = getEstimate;
        this.calculateRowsAndColumns = calculateRowsAndColumns;
        this.addVideosGrid = addVideosGrid;
        this.onScreenChanges = onScreenChanges;
        this.changeVids = changeVids;
        this.compareActiveNames = compareActiveNames;
        this.compareScreenStates = compareScreenStates;
        this.createSendTransport = createSendTransport;
        this.resumeSendTransportAudio = resumeSendTransportAudio;
        this.receiveAllPipedTransports = receiveAllPipedTransports;
        this.disconnectSendTransportVideo = disconnectSendTransportVideo;
        this.disconnectSendTransportAudio = disconnectSendTransportAudio;
        this.disconnectSendTransportScreen = disconnectSendTransportScreen;
        this.getPipedProducersAlt = getPipedProducersAlt;
        this.signalNewConsumerTransport = signalNewConsumerTransport;
        this.connectRecvTransport = connectRecvTransport;
        this.reUpdateInter = reUpdateInter;
        this.updateParticipantAudioDecibels = updateParticipantAudioDecibels;
        this.closeAndResize = closeAndResize;
        this.autoAdjust = autoAdjust;
        this.switchUserVideoAlt = switchUserVideoAlt;
        this.switchUserVideo = switchUserVideo;
        this.switchUserAudio = switchUserAudio;
        this.getDomains = getDomains;
        this.formatNumber = formatNumber;
        this.connectIps = connectIps;
        this.createDeviceClient = createDeviceClient;
        this.captureCanvasStream = captureCanvasStream;
        this.resumePauseAudioStreams = resumePauseAudioStreams;
        this.processConsumerTransportsAudio = processConsumerTransportsAudio;
        this.launchMessages = launchMessages;
        this.launchConfirmExit = launchConfirmExit;
        this.startMeetingProgressTimer = startMeetingProgressTimer;
        this.producerMediaPaused = producerMediaPaused;
        this.producerMediaResumed = producerMediaResumed;
        this.producerMediaClosed = producerMediaClosed;
        this.meetingEnded = meetingEnded;
        this.disconnectUserSelf = disconnectUserSelf;
        this.receiveMessage = receiveMessage;
        this.meetingTimeRemaining = meetingTimeRemaining;
        this.meetingStillThere = meetingStillThere;
        this.allMembers = allMembers;
        this.allMembersRest = allMembersRest;
        this.disconnect = disconnect;
        this.socketManager = socketManager;
        this.joinRoomClient = joinRoomClient;
        this.updateRoomParametersClient = updateRoomParametersClient;
        this.clickVideo = clickVideo;
        this.clickAudio = clickAudio;
        this.clickScreenShare = clickScreenShare;
        this.switchVideoAlt = switchVideoAlt;
        this.streamSuccessVideo = streamSuccessVideo;
        this.streamSuccessAudio = streamSuccessAudio;
        this.streamSuccessScreen = streamSuccessScreen;
        this.streamSuccessAudioSwitch = streamSuccessAudioSwitch;
        this.checkPermission = checkPermission;
        this.updateConsumingDomains = updateConsumingDomains;
        this.receiveRoomMessages = receiveRoomMessages;
    }
    createInjector(inputs) {
        const inj = Injector.create({
            providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
            parent: this.injector,
        });
        return inj;
    }
    // Initial values
    mediaSFUFunctions = () => {
        return {
            updateMiniCardsGrid: this.updateMiniCardsGrid?.updateMiniCardsGrid ||
                (() => {
                    console.log('none');
                }),
            mixStreams: this.mixStreams?.mixStreams ||
                (() => {
                    console.log('none');
                }),
            dispStreams: this.dispStreams?.dispStreams ||
                (() => {
                    console.log('none');
                }),
            stopShareScreen: this.stopShareScreen?.stopShareScreen ||
                (() => {
                    console.log('none');
                }),
            checkScreenShare: this.checkScreenShare?.checkScreenShare ||
                (() => {
                    console.log('none');
                }),
            startShareScreen: this.startShareScreen?.startShareScreen ||
                (() => {
                    console.log('none');
                }),
            requestScreenShare: this.requestScreenShare?.requestScreenShare ||
                (() => {
                    console.log('none');
                }),
            reorderStreams: this.reorderStreams?.reorderStreams ||
                (() => {
                    console.log('none');
                }),
            prepopulateUserMedia: this.prepopulateUserMedia?.prepopulateUserMedia ||
                (() => {
                    console.log('none');
                }),
            getVideos: this.getVideos?.getVideos ||
                (() => {
                    console.log('none');
                }),
            rePort: this.rePort?.rePort ||
                (() => {
                    console.log('none');
                }),
            trigger: this.trigger?.trigger ||
                (() => {
                    console.log('none');
                }),
            consumerResume: this.consumerResume?.consumerResume ||
                (() => {
                    console.log('none');
                }),
            connectSendTransport: this.connectSendTransport?.connectSendTransport ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportAudio: this.connectSendTransportAudio?.connectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportVideo: this.connectSendTransportVideo?.connectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportScreen: this.connectSendTransportScreen?.connectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransports: this.processConsumerTransports?.processConsumerTransports ||
                (() => {
                    console.log('none');
                }),
            resumePauseStreams: this.resumePauseStreams?.resumePauseStreams ||
                (() => {
                    console.log('none');
                }),
            readjust: this.readjust?.readjust ||
                (() => {
                    console.log('none');
                }),
            checkGrid: this.checkGrid?.checkGrid ||
                (() => {
                    console.log('none');
                }),
            getEstimate: this.getEstimate?.getEstimate ||
                (() => {
                    console.log('none');
                }),
            calculateRowsAndColumns: this.calculateRowsAndColumns?.calculateRowsAndColumns ||
                (() => {
                    console.log('none');
                }),
            addVideosGrid: this.addVideosGrid?.addVideosGrid ||
                (() => {
                    console.log('none');
                }),
            onScreenChanges: this.onScreenChanges?.onScreenChanges ||
                (() => {
                    console.log('none');
                }),
            sleep: sleep ||
                (() => {
                    console.log('none');
                }),
            changeVids: this.changeVids?.changeVids ||
                (() => {
                    console.log('none');
                }),
            compareActiveNames: this.compareActiveNames?.compareActiveNames ||
                (() => {
                    console.log('none');
                }),
            compareScreenStates: this.compareScreenStates?.compareScreenStates ||
                (() => {
                    console.log('none');
                }),
            createSendTransport: this.createSendTransport?.createSendTransport ||
                (() => {
                    console.log('none');
                }),
            resumeSendTransportAudio: this.resumeSendTransportAudio?.resumeSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            receiveAllPipedTransports: this.receiveAllPipedTransports?.receiveAllPipedTransports ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportVideo: this.disconnectSendTransportVideo?.disconnectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportAudio: this.disconnectSendTransportAudio?.disconnectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportScreen: this.disconnectSendTransportScreen?.disconnectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            getPipedProducersAlt: this.getPipedProducersAlt?.getPipedProducersAlt ||
                (() => {
                    console.log('none');
                }),
            signalNewConsumerTransport: this.signalNewConsumerTransport?.signalNewConsumerTransport ||
                (() => {
                    console.log('none');
                }),
            connectRecvTransport: this.connectRecvTransport?.connectRecvTransport ||
                (() => {
                    console.log('none');
                }),
            reUpdateInter: this.reUpdateInter?.reUpdateInter ||
                (() => {
                    console.log('none');
                }),
            updateParticipantAudioDecibels: this.updateParticipantAudioDecibels?.updateParticipantAudioDecibels ||
                (() => {
                    console.log('none');
                }),
            closeAndResize: this.closeAndResize?.closeAndResize ||
                (() => {
                    console.log('none');
                }),
            autoAdjust: this.autoAdjust?.autoAdjust ||
                (() => {
                    console.log('none');
                }),
            switchUserVideoAlt: this.switchUserVideoAlt?.switchUserVideoAlt ||
                (() => {
                    console.log('none');
                }),
            switchUserVideo: this.switchUserVideo?.switchUserVideo ||
                (() => {
                    console.log('none');
                }),
            switchUserAudio: this.switchUserAudio?.switchUserAudio ||
                (() => {
                    console.log('none');
                }),
            getDomains: this.getDomains?.getDomains ||
                (() => {
                    console.log('none');
                }),
            formatNumber: this.formatNumber?.formatNumber ||
                (() => {
                    console.log('none');
                }),
            connectIps: this.connectIps?.connectIps ||
                (() => {
                    console.log('none');
                }),
            createDeviceClient: this.createDeviceClient?.createDeviceClient ||
                (() => {
                    console.log('none');
                }),
            captureCanvasStream: this.captureCanvasStream?.captureCanvasStream ||
                (() => {
                    console.log('none');
                }),
            resumePauseAudioStreams: this.resumePauseAudioStreams?.resumePauseAudioStreams ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransportsAudio: this.processConsumerTransportsAudio?.processConsumerTransportsAudio ||
                (() => {
                    console.log('none');
                }),
            checkPermission: this.checkPermission?.checkPermission ||
                (() => {
                    console.log('none');
                }),
            streamSuccessVideo: this.streamSuccessVideo?.streamSuccessVideo ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudio: this.streamSuccessAudio?.streamSuccessAudio ||
                (() => {
                    console.log('none');
                }),
            streamSuccessScreen: this.streamSuccessScreen?.streamSuccessScreen ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudioSwitch: this.streamSuccessAudioSwitch?.streamSuccessAudioSwitch ||
                (() => {
                    console.log('none');
                }),
            clickVideo: this.clickVideo?.clickVideo ||
                (() => {
                    console.log('none');
                }),
            clickAudio: this.clickAudio?.clickAudio ||
                (() => {
                    console.log('none');
                }),
            clickScreenShare: this.clickScreenShare?.clickScreenShare ||
                (() => {
                    console.log('none');
                }),
            switchVideoAlt: this.switchVideoAlt?.switchVideoAlt ||
                (() => {
                    console.log('none');
                }),
            requestPermissionCamera: this.requestPermissionCamera ||
                (() => {
                    console.log('none');
                }),
            requestPermissionAudio: this.requestPermissionAudio ||
                (() => {
                    console.log('none');
                }),
        };
    };
    validated = new BehaviorSubject(false);
    localUIMode = new BehaviorSubject(false);
    socket = new BehaviorSubject({});
    roomData = new BehaviorSubject(null);
    device = new BehaviorSubject(null);
    apiKey = new BehaviorSubject('');
    apiUserName = new BehaviorSubject('');
    apiToken = new BehaviorSubject('');
    link = new BehaviorSubject('');
    roomName = new BehaviorSubject('');
    member = new BehaviorSubject('');
    adminPasscode = new BehaviorSubject('');
    islevel = new BehaviorSubject('1');
    coHost = new BehaviorSubject('No coHost');
    coHostResponsibility = new BehaviorSubject([
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ]);
    youAreCoHost = new BehaviorSubject(false);
    youAreHost = new BehaviorSubject(false);
    confirmedToRecord = new BehaviorSubject(false);
    meetingDisplayType = new BehaviorSubject('media');
    meetingVideoOptimized = new BehaviorSubject(false);
    eventType = new BehaviorSubject('chat');
    participants = new BehaviorSubject([]);
    filteredParticipants = new BehaviorSubject([]);
    participantsCounter = new BehaviorSubject(0);
    participantsFilter = new BehaviorSubject('');
    consume_sockets = new BehaviorSubject([]);
    rtpCapabilities = new BehaviorSubject(null);
    roomRecvIPs = new BehaviorSubject([]);
    meetingRoomParams = new BehaviorSubject(null);
    itemPageLimit = new BehaviorSubject(4);
    audioOnlyRoom = new BehaviorSubject(false);
    addForBasic = new BehaviorSubject(false);
    screenPageLimit = new BehaviorSubject(4);
    shareScreenStarted = new BehaviorSubject(false);
    shared = new BehaviorSubject(false);
    targetOrientation = new BehaviorSubject('landscape');
    targetResolution = new BehaviorSubject('sd');
    targetResolutionHost = new BehaviorSubject('sd');
    vidCons = new BehaviorSubject({ width: 640, height: 360 });
    frameRate = new BehaviorSubject(10);
    hParams = new BehaviorSubject({});
    vParams = new BehaviorSubject({});
    screenParams = new BehaviorSubject({});
    aParams = new BehaviorSubject({});
    recordingAudioPausesLimit = new BehaviorSubject(0);
    recordingAudioPausesCount = new BehaviorSubject(0);
    recordingAudioSupport = new BehaviorSubject(false);
    recordingAudioPeopleLimit = new BehaviorSubject(0);
    recordingAudioParticipantsTimeLimit = new BehaviorSubject(0);
    recordingVideoPausesCount = new BehaviorSubject(0);
    recordingVideoPausesLimit = new BehaviorSubject(0);
    recordingVideoSupport = new BehaviorSubject(false);
    recordingVideoPeopleLimit = new BehaviorSubject(0);
    recordingVideoParticipantsTimeLimit = new BehaviorSubject(0);
    recordingAllParticipantsSupport = new BehaviorSubject(false);
    recordingVideoParticipantsSupport = new BehaviorSubject(false);
    recordingAllParticipantsFullRoomSupport = new BehaviorSubject(false);
    recordingVideoParticipantsFullRoomSupport = new BehaviorSubject(false);
    recordingPreferredOrientation = new BehaviorSubject('landscape');
    recordingSupportForOtherOrientation = new BehaviorSubject(false);
    recordingMultiFormatsSupport = new BehaviorSubject(false);
    userRecordingParams = new BehaviorSubject({
        mainSpecs: {
            mediaOptions: 'video', // 'audio', 'video'
            audioOptions: 'all', // 'all', 'onScreen', 'host'
            videoOptions: 'all', // 'all', 'mainScreen'
            videoType: 'fullDisplay', // 'all', 'bestDisplay', 'fullDisplay'
            videoOptimized: false, // true, false
            recordingDisplayType: 'media', // 'media', 'video', 'all'
            addHLS: false, // true, false
        },
        dispSpecs: {
            nameTags: true, // true, false
            backgroundColor: '#000000', // '#000000', '#ffffff'
            nameTagsColor: '#ffffff', // '#000000', '#ffffff'
            orientationVideo: 'portrait', // 'landscape', 'portrait', 'all'
        },
    });
    canRecord = new BehaviorSubject(false);
    startReport = new BehaviorSubject(false);
    endReport = new BehaviorSubject(false);
    recordTimerInterval = new BehaviorSubject(null);
    recordStartTime = new BehaviorSubject(0);
    recordElapsedTime = new BehaviorSubject(0);
    isTimerRunning = new BehaviorSubject(false);
    canPauseResume = new BehaviorSubject(false);
    recordChangeSeconds = new BehaviorSubject(15000);
    pauseLimit = new BehaviorSubject(0);
    pauseRecordCount = new BehaviorSubject(0);
    canLaunchRecord = new BehaviorSubject(true);
    stopLaunchRecord = new BehaviorSubject(false);
    participantsAll = new BehaviorSubject([]);
    firstAll = new BehaviorSubject(false);
    updateMainWindow = new BehaviorSubject(false);
    first_round = new BehaviorSubject(false);
    landScaped = new BehaviorSubject(false);
    lock_screen = new BehaviorSubject(false);
    screenId = new BehaviorSubject('');
    allVideoStreams = new BehaviorSubject([]);
    newLimitedStreams = new BehaviorSubject([]);
    newLimitedStreamsIDs = new BehaviorSubject([]);
    activeSounds = new BehaviorSubject([]);
    screenShareIDStream = new BehaviorSubject('');
    screenShareNameStream = new BehaviorSubject('');
    adminIDStream = new BehaviorSubject('');
    adminNameStream = new BehaviorSubject('');
    youYouStream = new BehaviorSubject([]);
    youYouStreamIDs = new BehaviorSubject([]);
    localStream = new BehaviorSubject(null);
    recordStarted = new BehaviorSubject(false);
    recordResumed = new BehaviorSubject(false);
    recordPaused = new BehaviorSubject(false);
    recordStopped = new BehaviorSubject(false);
    adminRestrictSetting = new BehaviorSubject(false);
    videoRequestState = new BehaviorSubject(null);
    videoRequestTime = new BehaviorSubject(0);
    videoAction = new BehaviorSubject(false);
    localStreamVideo = new BehaviorSubject(null);
    userDefaultVideoInputDevice = new BehaviorSubject('');
    currentFacingMode = new BehaviorSubject('user');
    prevFacingMode = new BehaviorSubject('user');
    defVideoID = new BehaviorSubject('');
    allowed = new BehaviorSubject(false);
    dispActiveNames = new BehaviorSubject([]);
    p_dispActiveNames = new BehaviorSubject([]);
    activeNames = new BehaviorSubject([]);
    prevActiveNames = new BehaviorSubject([]);
    p_activeNames = new BehaviorSubject([]);
    membersReceived = new BehaviorSubject(false);
    deferScreenReceived = new BehaviorSubject(false);
    hostFirstSwitch = new BehaviorSubject(false);
    micAction = new BehaviorSubject(false);
    screenAction = new BehaviorSubject(false);
    chatAction = new BehaviorSubject(false);
    audioRequestState = new BehaviorSubject(null);
    screenRequestState = new BehaviorSubject(null);
    chatRequestState = new BehaviorSubject(null);
    audioRequestTime = new BehaviorSubject(0);
    screenRequestTime = new BehaviorSubject(0);
    chatRequestTime = new BehaviorSubject(0);
    updateRequestIntervalSeconds = new BehaviorSubject(240);
    oldSoundIds = new BehaviorSubject([]);
    hostLabel = new BehaviorSubject('Host');
    mainScreenFilled = new BehaviorSubject(false);
    localStreamScreen = new BehaviorSubject(null);
    screenAlreadyOn = new BehaviorSubject(false);
    chatAlreadyOn = new BehaviorSubject(false);
    redirectURL = new BehaviorSubject('');
    oldAllStreams = new BehaviorSubject([]);
    adminVidID = new BehaviorSubject('');
    streamNames = new BehaviorSubject([]);
    non_alVideoStreams = new BehaviorSubject([]);
    sortAudioLoudness = new BehaviorSubject(false);
    audioDecibels = new BehaviorSubject([]);
    mixed_alVideoStreams = new BehaviorSubject([]);
    non_alVideoStreams_muted = new BehaviorSubject([]);
    paginatedStreams = new BehaviorSubject([]);
    localStreamAudio = new BehaviorSubject(null);
    defAudioID = new BehaviorSubject('');
    userDefaultAudioInputDevice = new BehaviorSubject('');
    userDefaultAudioOutputDevice = new BehaviorSubject('');
    prevAudioInputDevice = new BehaviorSubject('');
    prevVideoInputDevice = new BehaviorSubject('');
    audioPaused = new BehaviorSubject(false);
    mainScreenPerson = new BehaviorSubject('');
    adminOnMainScreen = new BehaviorSubject(false);
    screenStates = new BehaviorSubject([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    prevScreenStates = new BehaviorSubject([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    updateDateState = new BehaviorSubject(null);
    lastUpdate = new BehaviorSubject(null);
    nForReadjustRecord = new BehaviorSubject(0);
    fixedPageLimit = new BehaviorSubject(4);
    removeAltGrid = new BehaviorSubject(false);
    nForReadjust = new BehaviorSubject(0);
    reorderInterval = new BehaviorSubject(30000);
    fastReorderInterval = new BehaviorSubject(10000);
    lastReorderTime = new BehaviorSubject(0);
    audStreamNames = new BehaviorSubject([]);
    currentUserPage = new BehaviorSubject(0);
    mainHeightWidth = new BehaviorSubject(0);
    prevMainHeightWidth = new BehaviorSubject(this.mainHeightWidth.value);
    prevDoPaginate = new BehaviorSubject(false);
    doPaginate = new BehaviorSubject(false);
    shareEnded = new BehaviorSubject(false);
    lStreams = new BehaviorSubject([]);
    chatRefStreams = new BehaviorSubject([]);
    controlHeight = new BehaviorSubject(this.eventType.value === 'webinar' || this.eventType.value === 'conference' ? 0 : 0.06);
    isWideScreen = new BehaviorSubject(false);
    isMediumScreen = new BehaviorSubject(false);
    isSmallScreen = new BehaviorSubject(false);
    addGrid = new BehaviorSubject(false);
    addAltGrid = new BehaviorSubject(false);
    gridRows = new BehaviorSubject(0);
    gridCols = new BehaviorSubject(0);
    altGridRows = new BehaviorSubject(0);
    altGridCols = new BehaviorSubject(0);
    numberPages = new BehaviorSubject(0);
    currentStreams = new BehaviorSubject([]);
    showMiniView = new BehaviorSubject(false);
    nStream = new BehaviorSubject(null);
    defer_receive = new BehaviorSubject(false);
    allAudioStreams = new BehaviorSubject([]);
    remoteScreenStream = new BehaviorSubject([]);
    screenProducer = new BehaviorSubject(null);
    gotAllVids = new BehaviorSubject(false);
    paginationHeightWidth = new BehaviorSubject(40);
    paginationDirection = new BehaviorSubject('horizontal');
    gridSizes = new BehaviorSubject({
        gridWidth: 0,
        gridHeight: 0,
        altGridWidth: 0,
        altGridHeight: 0,
    });
    screenForceFullDisplay = new BehaviorSubject(false);
    mainGridStream = new BehaviorSubject([]);
    otherGridStreams = new BehaviorSubject([]);
    audioOnlyStreams = new BehaviorSubject([]);
    videoInputs = new BehaviorSubject([]);
    audioInputs = new BehaviorSubject([]);
    meetingProgressTime = new BehaviorSubject('00:00:00');
    meetingElapsedTime = new BehaviorSubject(0);
    ref_participants = new BehaviorSubject([]);
    updateValidated = (value) => {
        this.validated.next(value);
    };
    updateSocket = (value) => {
        this.socket.next(value);
    };
    updateDevice = (value) => {
        this.device.next(value);
    };
    updateRoomData = (value) => {
        this.roomData.next(value);
    };
    updateApiKey = (value) => {
        this.apiKey.next(value);
    };
    updateApiUserName = (value) => {
        this.apiUserName.next(value);
    };
    updateApiToken = (value) => {
        this.apiToken.next(value);
    };
    updateLink = (value) => {
        this.link.next(value);
    };
    updateRoomName = (value) => {
        this.roomName.next(value);
    };
    updateMember = (value) => {
        this.member.next(value);
    };
    updateAdminPasscode = (value) => {
        this.adminPasscode.next(value);
    };
    updateIslevel = (value) => {
        this.islevel.next(value);
    };
    updateCoHost = (value) => {
        this.coHost.next(value);
    };
    updateCoHostResponsibility = (value) => {
        this.coHostResponsibility.next(value);
    };
    updateYouAreCoHost = (value) => {
        this.youAreCoHost.next(value);
    };
    updateYouAreHost = (value) => {
        this.youAreHost.next(value);
    };
    updateConfirmedToRecord = (value) => {
        this.confirmedToRecord.next(value);
    };
    updateMeetingDisplayType = (value) => {
        this.meetingDisplayType.next(value);
    };
    updateMeetingVideoOptimized = (value) => {
        this.meetingVideoOptimized.next(value);
    };
    updateEventType = (value) => {
        this.eventType.next(value);
    };
    updateParticipants = (value) => {
        this.participants.next(value);
        this.participantsCounter.next(value.length);
        this.filteredParticipants.next(this.participants.value);
    };
    updateFilteredParticipants = (value) => {
        this.filteredParticipants.next(value);
    };
    updateParticipantsCounter = (value) => {
        this.participantsCounter.next(value);
    };
    updateParticipantsFilter = (value) => {
        this.participantsFilter.next(value);
    };
    updateConsume_sockets = (value) => {
        this.consume_sockets.next(value);
    };
    updateRtpCapabilities = (value) => {
        this.rtpCapabilities.next(value);
    };
    updateRoomRecvIPs = (value) => {
        this.roomRecvIPs.next(value);
    };
    updateMeetingRoomParams = (value) => {
        this.meetingRoomParams.next(value);
    };
    updateItemPageLimit = (value) => {
        this.itemPageLimit.next(value);
    };
    updateAudioOnlyRoom = (value) => {
        this.audioOnlyRoom.next(value);
    };
    updateAddForBasic = (value) => {
        this.addForBasic.next(value);
    };
    updateScreenPageLimit = (value) => {
        this.screenPageLimit.next(value);
    };
    updateShareScreenStarted = (value) => {
        this.shareScreenStarted.next(value);
    };
    updateShared = (value) => {
        this.shared.next(value);
    };
    updateTargetOrientation = (value) => {
        this.targetOrientation.next(value);
    };
    updateTargetResolution = (value) => {
        this.targetResolution.next(value);
    };
    updateTargetResolutionHost = (value) => {
        this.targetResolutionHost.next(value);
    };
    updateVidCons = (value) => {
        this.vidCons.next(value);
    };
    updateFrameRate = (value) => {
        this.frameRate.next(value);
    };
    updateHParams = (value) => {
        this.hParams.next(value);
    };
    updateVParams = (value) => {
        this.vParams.next(value);
    };
    updateScreenParams = (value) => {
        this.screenParams.next(value);
    };
    updateAParams = (value) => {
        this.aParams.next(value);
    };
    updateRecordingAudioPausesLimit = (value) => {
        this.recordingAudioPausesLimit.next(value);
    };
    updateRecordingAudioPausesCount = (value) => {
        this.recordingAudioPausesCount.next(value);
    };
    updateRecordingAudioSupport = (value) => {
        this.recordingAudioSupport.next(value);
    };
    updateRecordingAudioPeopleLimit = (value) => {
        this.recordingAudioPeopleLimit.next(value);
    };
    updateRecordingAudioParticipantsTimeLimit = (value) => {
        this.recordingAudioParticipantsTimeLimit.next(value);
    };
    updateRecordingVideoPausesCount = (value) => {
        this.recordingVideoPausesCount.next(value);
    };
    updateRecordingVideoPausesLimit = (value) => {
        this.recordingVideoPausesLimit.next(value);
    };
    updateRecordingVideoSupport = (value) => {
        this.recordingVideoSupport.next(value);
    };
    updateRecordingVideoPeopleLimit = (value) => {
        this.recordingVideoPeopleLimit.next(value);
    };
    updateRecordingVideoParticipantsTimeLimit = (value) => {
        this.recordingVideoParticipantsTimeLimit.next(value);
    };
    updateRecordingAllParticipantsSupport = (value) => {
        this.recordingAllParticipantsSupport.next(value);
    };
    updateRecordingVideoParticipantsSupport = (value) => {
        this.recordingVideoParticipantsSupport.next(value);
    };
    updateRecordingAllParticipantsFullRoomSupport = (value) => {
        this.recordingAllParticipantsFullRoomSupport.next(value);
    };
    updateRecordingVideoParticipantsFullRoomSupport = (value) => {
        this.recordingVideoParticipantsFullRoomSupport.next(value);
    };
    updateRecordingPreferredOrientation = (value) => {
        this.recordingPreferredOrientation.next(value);
    };
    updateRecordingSupportForOtherOrientation = (value) => {
        this.recordingSupportForOtherOrientation.next(value);
    };
    updateRecordingMultiFormatsSupport = (value) => {
        this.recordingMultiFormatsSupport.next(value);
    };
    updateUserRecordingParams = (value) => {
        this.userRecordingParams.next(value);
    };
    updateCanRecord = (value) => {
        this.canRecord.next(value);
    };
    updateStartReport = (value) => {
        this.startReport.next(value);
    };
    updateEndReport = (value) => {
        this.endReport.next(value);
    };
    updateRecordTimerInterval = (value) => {
        this.recordTimerInterval.next(value);
    };
    updateRecordStartTime = (value) => {
        this.recordStartTime.next(value);
    };
    updateRecordElapsedTime = (value) => {
        this.recordElapsedTime.next(value);
    };
    updateIsTimerRunning = (value) => {
        this.isTimerRunning.next(value);
    };
    updateCanPauseResume = (value) => {
        this.canPauseResume.next(value);
    };
    updateRecordChangeSeconds = (value) => {
        this.recordChangeSeconds.next(value);
    };
    updatePauseLimit = (value) => {
        this.pauseLimit.next(value);
    };
    updatePauseRecordCount = (value) => {
        this.pauseRecordCount.next(value);
    };
    updateCanLaunchRecord = (value) => {
        this.canLaunchRecord.next(value);
    };
    updateStopLaunchRecord = (value) => {
        this.stopLaunchRecord.next(value);
    };
    updateParticipantsAll = (value) => {
        this.participantsAll.next(value);
    };
    updateFirstAll = (value) => {
        this.firstAll.next(value);
    };
    updateUpdateMainWindow = (value) => {
        this.updateMainWindow.next(value);
    };
    updateFirst_round = (value) => {
        this.first_round.next(value);
    };
    updateLandScaped = (value) => {
        this.landScaped.next(value);
    };
    updateLock_screen = (value) => {
        this.lock_screen.next(value);
    };
    updateScreenId = (value) => {
        this.screenId.next(value);
    };
    updateAllVideoStreams = (value) => {
        this.allVideoStreams.next(value);
    };
    updateNewLimitedStreams = (value) => {
        this.newLimitedStreams.next(value);
    };
    updateNewLimitedStreamsIDs = (value) => {
        this.newLimitedStreamsIDs.next(value);
    };
    updateActiveSounds = (value) => {
        this.activeSounds.next(value);
    };
    updateScreenShareIDStream = (value) => {
        this.screenShareIDStream.next(value);
    };
    updateScreenShareNameStream = (value) => {
        this.screenShareNameStream.next(value);
    };
    updateAdminIDStream = (value) => {
        this.adminIDStream.next(value);
    };
    updateAdminNameStream = (value) => {
        this.adminNameStream.next(value);
    };
    updateYouYouStream = (value) => {
        this.youYouStream.next(value);
    };
    updateYouYouStreamIDs = (value) => {
        this.youYouStreamIDs.next(value);
    };
    updateLocalStream = (value) => {
        this.localStream.next(value);
    };
    updateRecordStarted = (value) => {
        this.recordStarted.next(value);
    };
    updateRecordResumed = (value) => {
        this.recordResumed.next(value);
    };
    updateRecordPaused = (value) => {
        this.recordPaused.next(value);
    };
    updateRecordStopped = (value) => {
        this.recordStopped.next(value);
    };
    updateAdminRestrictSetting = (value) => {
        this.adminRestrictSetting.next(value);
    };
    updateVideoRequestState = (value) => {
        this.videoRequestState.next(value);
    };
    updateVideoRequestTime = (value) => {
        this.videoRequestTime.next(value);
    };
    updateVideoAction = (value) => {
        this.videoAction.next(value);
    };
    updateLocalStreamVideo = (value) => {
        this.localStreamVideo.next(value);
    };
    updateUserDefaultVideoInputDevice = (value) => {
        this.userDefaultVideoInputDevice.next(value);
    };
    updateCurrentFacingMode = (value) => {
        this.currentFacingMode.next(value);
    };
    updatePrevFacingMode = (value) => {
        this.prevFacingMode.next(value);
    };
    updateDefVideoID = (value) => {
        this.defVideoID.next(value);
    };
    updateAllowed = (value) => {
        this.allowed.next(value);
    };
    updateDispActiveNames = (value) => {
        this.dispActiveNames.next(value);
    };
    updateP_dispActiveNames = (value) => {
        this.p_dispActiveNames.next(value);
    };
    updateActiveNames = (value) => {
        this.activeNames.next(value);
    };
    updatePrevActiveNames = (value) => {
        this.prevActiveNames.next(value);
    };
    updateP_activeNames = (value) => {
        this.p_activeNames.next(value);
    };
    updateMembersReceived = (value) => {
        this.membersReceived.next(value);
    };
    updateDeferScreenReceived = (value) => {
        this.deferScreenReceived.next(value);
    };
    updateHostFirstSwitch = (value) => {
        this.hostFirstSwitch.next(value);
    };
    updateMicAction = (value) => {
        this.micAction.next(value);
    };
    updateScreenAction = (value) => {
        this.screenAction.next(value);
    };
    updateChatAction = (value) => {
        this.chatAction.next(value);
    };
    updateAudioRequestState = (value) => {
        this.audioRequestState.next(value);
    };
    updateScreenRequestState = (value) => {
        this.screenRequestState.next(value);
    };
    updateChatRequestState = (value) => {
        this.chatRequestState.next(value);
    };
    updateAudioRequestTime = (value) => {
        this.audioRequestTime.next(value);
    };
    updateScreenRequestTime = (value) => {
        this.screenRequestTime.next(value);
    };
    updateChatRequestTime = (value) => {
        this.chatRequestTime.next(value);
    };
    updateOldSoundIds = (value) => {
        this.oldSoundIds.next(value);
    };
    updateHostLabel = (value) => {
        this.hostLabel.next(value);
    };
    updateMainScreenFilled = (value) => {
        this.mainScreenFilled.next(value);
    };
    updateLocalStreamScreen = (value) => {
        this.localStreamScreen.next(value);
    };
    updateScreenAlreadyOn = (value) => {
        this.screenAlreadyOn.next(value);
    };
    updateChatAlreadyOn = (value) => {
        this.chatAlreadyOn.next(value);
    };
    updateRedirectURL = (value) => {
        this.redirectURL.next(value);
    };
    updateOldAllStreams = (value) => {
        this.oldAllStreams.next(value);
    };
    updateAdminVidID = (value) => {
        this.adminVidID.next(value);
    };
    updateStreamNames = (value) => {
        this.streamNames.next(value);
    };
    updateNon_alVideoStreams = (value) => {
        this.non_alVideoStreams.next(value);
    };
    updateSortAudioLoudness = (value) => {
        this.sortAudioLoudness.next(value);
    };
    updateAudioDecibels = (value) => {
        this.audioDecibels.next(value);
    };
    updateMixed_alVideoStreams = (value) => {
        this.mixed_alVideoStreams.next(value);
    };
    updateNon_alVideoStreams_muted = (value) => {
        this.non_alVideoStreams_muted.next(value);
    };
    updatePaginatedStreams = (value) => {
        this.paginatedStreams.next(value);
    };
    updateLocalStreamAudio = (value) => {
        this.localStreamAudio.next(value);
    };
    updateDefAudioID = (value) => {
        this.defAudioID.next(value);
    };
    updateUserDefaultAudioInputDevice = (value) => {
        this.userDefaultAudioInputDevice.next(value);
    };
    updateUserDefaultAudioOutputDevice = (value) => {
        this.userDefaultAudioOutputDevice.next(value);
    };
    updatePrevAudioInputDevice = (value) => {
        this.prevAudioInputDevice.next(value);
    };
    updatePrevVideoInputDevice = (value) => {
        this.prevVideoInputDevice.next(value);
    };
    updateAudioPaused = (value) => {
        this.audioPaused.next(value);
    };
    updateMainScreenPerson = (value) => {
        this.mainScreenPerson.next(value);
    };
    updateAdminOnMainScreen = (value) => {
        this.adminOnMainScreen.next(value);
    };
    updateScreenStates = (value) => {
        this.screenStates.next(value);
    };
    updatePrevScreenStates = (value) => {
        this.prevScreenStates.next(value);
    };
    updateUpdateDateState = (value) => {
        this.updateDateState.next(value);
    };
    updateLastUpdate = (value) => {
        this.lastUpdate.next(value);
    };
    updateNForReadjustRecord = (value) => {
        this.nForReadjustRecord.next(value);
    };
    updateFixedPageLimit = (value) => {
        this.fixedPageLimit.next(value);
    };
    updateRemoveAltGrid = (value) => {
        this.removeAltGrid.next(value);
    };
    updateNForReadjust = (value) => {
        this.nForReadjust.next(value);
    };
    updateLastReorderTime = (value) => {
        this.lastReorderTime.next(value);
    };
    updateAudStreamNames = (value) => {
        this.audStreamNames.next(value);
    };
    updateCurrentUserPage = (value) => {
        this.currentUserPage.next(value);
    };
    updateMainHeightWidth = (value) => {
        this.mainHeightWidth.next(value);
    };
    updatePrevMainHeightWidth = (value) => {
        this.prevMainHeightWidth.next(value);
    };
    updatePrevDoPaginate = (value) => {
        this.prevDoPaginate.next(value);
    };
    updateDoPaginate = (value) => {
        this.doPaginate.next(value);
    };
    updateShareEnded = (value) => {
        this.shareEnded.next(value);
    };
    updateLStreams = (value) => {
        this.lStreams.next(value);
    };
    updateChatRefStreams = (value) => {
        this.chatRefStreams.next(value);
    };
    updateControlHeight = (value) => {
        this.controlHeight.next(value);
    };
    updateIsWideScreen = (value) => {
        this.isWideScreen.next(value);
    };
    updateIsMediumScreen = (value) => {
        this.isMediumScreen.next(value);
    };
    updateIsSmallScreen = (value) => {
        this.isSmallScreen.next(value);
    };
    updateAddGrid = (value) => {
        this.addGrid.next(value);
    };
    updateAddAltGrid = (value) => {
        this.addAltGrid.next(value);
    };
    updateGridRows = (value) => {
        this.gridRows.next(value);
    };
    updateGridCols = (value) => {
        this.gridCols.next(value);
    };
    updateAltGridRows = (value) => {
        this.altGridRows.next(value);
    };
    updateAltGridCols = (value) => {
        this.altGridCols.next(value);
    };
    updateNumberPages = (value) => {
        this.numberPages.next(value);
    };
    updateCurrentStreams = (value) => {
        this.currentStreams.next(value);
    };
    updateShowMiniView = (value) => {
        this.showMiniView.next(value);
    };
    updateNStream = (value) => {
        this.nStream.next(value);
    };
    updateDefer_receive = (value) => {
        this.defer_receive.next(value);
    };
    updateAllAudioStreams = (value) => {
        this.allAudioStreams.next(value);
    };
    updateRemoteScreenStream = (value) => {
        this.remoteScreenStream.next(value);
    };
    updateScreenProducer = (value) => {
        this.screenProducer.next(value);
    };
    updateGotAllVids = (value) => {
        this.gotAllVids.next(value);
    };
    updatePaginationHeightWidth = (value) => {
        this.paginationHeightWidth.next(value);
    };
    updatePaginationDirection = (value) => {
        this.paginationDirection.next(value);
    };
    updateGridSizes = (value) => {
        this.gridSizes.next(value);
    };
    updateScreenForceFullDisplay = (value) => {
        this.screenForceFullDisplay.next(value);
    };
    updateMainGridStream = (value) => {
        this.mainGridStream.next(value);
    };
    updateOtherGridStreams = (value) => {
        this.otherGridStreams.next(value);
    };
    updateAudioOnlyStreams = (value) => {
        this.audioOnlyStreams.next(value);
    };
    updateVideoInputs = (value) => {
        this.videoInputs.next(value);
    };
    updateAudioInputs = (value) => {
        this.audioInputs.next(value);
    };
    updateMeetingProgressTime = (value) => {
        this.meetingProgressTime.next(value);
    };
    updateMeetingElapsedTime = (value) => {
        this.meetingElapsedTime.next(value);
    };
    updateRef_participants = (value) => {
        this.ref_participants.next(value);
    };
    // Messages
    messages = new BehaviorSubject([]);
    startDirectMessage = new BehaviorSubject(false);
    directMessageDetails = new BehaviorSubject(null);
    showMessagesBadge = new BehaviorSubject(false);
    // Event Settings
    audioSetting = new BehaviorSubject('allow');
    videoSetting = new BehaviorSubject('allow');
    screenshareSetting = new BehaviorSubject('allow');
    chatSetting = new BehaviorSubject('allow');
    // Display Settings
    displayOption = new BehaviorSubject('media');
    autoWave = new BehaviorSubject(true);
    forceFullDisplay = new BehaviorSubject(true);
    prevForceFullDisplay = new BehaviorSubject(false);
    prevMeetingDisplayType = new BehaviorSubject('video');
    // Waiting Room
    waitingRoomFilter = new BehaviorSubject('');
    waitingRoomList = new BehaviorSubject([]);
    waitingRoomCounter = new BehaviorSubject(0);
    filteredWaitingRoomList = new BehaviorSubject([]);
    // Requests
    requestFilter = new BehaviorSubject('');
    requestList = new BehaviorSubject([]);
    requestCounter = new BehaviorSubject(0);
    filteredRequestList = new BehaviorSubject([]);
    // Total Requests and Waiting Room
    totalReqWait = new BehaviorSubject(0);
    // Alerts
    alertVisible = new BehaviorSubject(false);
    alertMessage = new BehaviorSubject('');
    alertType = new BehaviorSubject('success');
    alertDuration = new BehaviorSubject(3000);
    // Progress Timer
    progressTimerVisible = new BehaviorSubject(true);
    progressTimerValue = new BehaviorSubject(0);
    // Menu Modals
    isMenuModalVisible = new BehaviorSubject(false);
    isRecordingModalVisible = new BehaviorSubject(false);
    isSettingsModalVisible = new BehaviorSubject(false);
    isRequestsModalVisible = new BehaviorSubject(false);
    isWaitingModalVisible = new BehaviorSubject(false);
    isCoHostModalVisible = new BehaviorSubject(false);
    isMediaSettingsModalVisible = new BehaviorSubject(false);
    isDisplaySettingsModalVisible = new BehaviorSubject(false);
    // Other Modals
    isParticipantsModalVisible = new BehaviorSubject(false);
    isMessagesModalVisible = new BehaviorSubject(false);
    isConfirmExitModalVisible = new BehaviorSubject(false);
    isConfirmHereModalVisible = new BehaviorSubject(false);
    isShareEventModalVisible = new BehaviorSubject(false);
    isLoadingModalVisible = new BehaviorSubject(false);
    // Recording Options
    recordingMediaOptions = new BehaviorSubject('video');
    recordingAudioOptions = new BehaviorSubject('all');
    recordingVideoOptions = new BehaviorSubject('all');
    recordingVideoType = new BehaviorSubject('fullDisplay');
    recordingVideoOptimized = new BehaviorSubject(false);
    recordingDisplayType = new BehaviorSubject('video');
    recordingAddHLS = new BehaviorSubject(true);
    recordingNameTags = new BehaviorSubject(true);
    recordingBackgroundColor = new BehaviorSubject('#83c0e9');
    recordingNameTagsColor = new BehaviorSubject('#ffffff');
    recordingAddText = new BehaviorSubject(false);
    recordingCustomText = new BehaviorSubject('Add Text');
    recordingCustomTextPosition = new BehaviorSubject('top');
    recordingCustomTextColor = new BehaviorSubject('#ffffff');
    recordingOrientationVideo = new BehaviorSubject('landscape');
    clearedToResume = new BehaviorSubject(true);
    clearedToRecord = new BehaviorSubject(true);
    recordState = new BehaviorSubject('green');
    showRecordButtons = new BehaviorSubject(false);
    recordingProgressTime = new BehaviorSubject('00:00:00');
    audioSwitching = new BehaviorSubject(false);
    videoSwitching = new BehaviorSubject(false);
    // Media States
    videoAlreadyOn = new BehaviorSubject(false);
    audioAlreadyOn = new BehaviorSubject(false);
    componentSizes = new BehaviorSubject({
        mainHeight: 0,
        otherHeight: 0,
        mainWidth: 0,
        otherWidth: 0,
    });
    // Permissions
    hasCameraPermission = new BehaviorSubject(false);
    hasAudioPermission = new BehaviorSubject(false);
    // Transports
    transportCreated = new BehaviorSubject(false);
    transportCreatedVideo = new BehaviorSubject(false);
    transportCreatedAudio = new BehaviorSubject(false);
    transportCreatedScreen = new BehaviorSubject(false);
    producerTransport = new BehaviorSubject(null);
    videoProducer = new BehaviorSubject(null);
    params = new BehaviorSubject({});
    videoParams = new BehaviorSubject({});
    audioParams = new BehaviorSubject({});
    audioProducer = new BehaviorSubject(null);
    consumerTransports = new BehaviorSubject([]);
    consumingTransports = new BehaviorSubject([]);
    // Polls
    polls = new BehaviorSubject([]);
    poll = new BehaviorSubject(null);
    isPollModalVisible = new BehaviorSubject(false);
    // Background
    customImage = new BehaviorSubject('');
    selectedImage = new BehaviorSubject('');
    segmentVideo = new BehaviorSubject(null);
    selfieSegmentation = new BehaviorSubject(null);
    pauseSegmentation = new BehaviorSubject(false);
    processedStream = new BehaviorSubject(null);
    keepBackground = new BehaviorSubject(false);
    backgroundHasChanged = new BehaviorSubject(false);
    virtualStream = new BehaviorSubject(null);
    mainCanvas = new BehaviorSubject(null);
    prevKeepBackground = new BehaviorSubject(false);
    appliedBackground = new BehaviorSubject(false);
    isBackgroundModalVisible = new BehaviorSubject(false);
    autoClickBackground = new BehaviorSubject(false);
    // Breakout Rooms
    breakoutRooms = new BehaviorSubject([]);
    currentRoomIndex = new BehaviorSubject(0);
    canStartBreakout = new BehaviorSubject(false);
    breakOutRoomStarted = new BehaviorSubject(false);
    breakOutRoomEnded = new BehaviorSubject(false);
    hostNewRoom = new BehaviorSubject(-1);
    limitedBreakRoom = new BehaviorSubject([]);
    mainRoomsLength = new BehaviorSubject(0);
    memberRoom = new BehaviorSubject(-1);
    isBreakoutRoomsModalVisible = new BehaviorSubject(false);
    // Whiteboard
    whiteboardUsers = new BehaviorSubject([]);
    currentWhiteboardIndex = new BehaviorSubject(0);
    canStartWhiteboard = new BehaviorSubject(false);
    whiteboardStarted = new BehaviorSubject(false);
    whiteboardEnded = new BehaviorSubject(false);
    whiteboardLimit = new BehaviorSubject(4);
    isWhiteboardModalVisible = new BehaviorSubject(false);
    isConfigureWhiteboardModalVisible = new BehaviorSubject(false);
    shapes = new BehaviorSubject([]);
    useImageBackground = new BehaviorSubject(true);
    redoStack = new BehaviorSubject([]);
    undoStack = new BehaviorSubject([]);
    canvasStream = new BehaviorSubject(null);
    canvasWhiteboard = new BehaviorSubject(null);
    // Screenboard
    canvasScreenboard = new BehaviorSubject(null);
    processedScreenStream = new BehaviorSubject(null);
    annotateScreenStream = new BehaviorSubject(false);
    mainScreenCanvas = new BehaviorSubject(null);
    isScreenboardModalVisible = new BehaviorSubject(false);
    //state variables for the control buttons
    micActive = new BehaviorSubject(this.audioAlreadyOn.value ? this.audioAlreadyOn.value : false);
    videoActive = new BehaviorSubject(this.videoAlreadyOn.value ? this.videoAlreadyOn.value : false);
    screenShareActive = new BehaviorSubject(false);
    endCallActive = new BehaviorSubject(false);
    participantsActive = new BehaviorSubject(false);
    menuActive = new BehaviorSubject(false);
    commentsActive = new BehaviorSubject(false);
    // Update functions
    updateMessages = (value) => {
        this.messages.next(value);
    };
    updateStartDirectMessage = (value) => {
        this.startDirectMessage.next(value);
    };
    updateDirectMessageDetails = (value) => {
        this.directMessageDetails.next(value);
    };
    updateShowMessagesBadge = (value) => {
        this.showMessagesBadge.next(value);
    };
    updateAudioSetting = (value) => {
        this.audioSetting.next(value);
    };
    updateVideoSetting = (value) => {
        this.videoSetting.next(value);
    };
    updateScreenshareSetting = (value) => {
        this.screenshareSetting.next(value);
    };
    updateChatSetting = (value) => {
        this.chatSetting.next(value);
    };
    updateDisplayOption = (value) => {
        this.displayOption.next(value);
    };
    updateAutoWave = (value) => {
        this.autoWave.next(value);
    };
    updateForceFullDisplay = (value) => {
        this.forceFullDisplay.next(value);
    };
    updatePrevForceFullDisplay = (value) => {
        this.prevForceFullDisplay.next(value);
    };
    updatePrevMeetingDisplayType = (value) => {
        this.prevMeetingDisplayType.next(value);
    };
    updateWaitingRoomCounter = (value) => {
        this.waitingRoomCounter.next(value);
    };
    updateWaitingRoomFilter = (value) => {
        this.waitingRoomFilter.next(value);
    };
    updateWaitingRoomList = (value) => {
        this.waitingRoomList.next(value);
        this.filteredWaitingRoomList.next(value);
        this.waitingRoomCounter.next(value.length);
    };
    onWaitingRoomClose = () => {
        this.updateIsWaitingModalVisible(false);
    };
    updateRequestCounter = (value) => {
        this.requestCounter.next(value);
    };
    updateRequestFilter = (value) => {
        this.requestFilter.next(value);
    };
    updateRequestList = (value) => {
        this.requestList.next(value);
        this.filteredRequestList.next(value);
        this.requestCounter.next(value.length);
    };
    onRequestClose = () => {
        this.updateIsRequestsModalVisible(false);
    };
    updateTotalReqWait = (value) => {
        this.totalReqWait.next(value);
    };
    updateAlertVisible = (value) => {
        this.alertVisible.next(value);
    };
    updateAlertMessage = (value) => {
        this.alertMessage.next(value);
    };
    updateAlertType = (value) => {
        this.alertType.next(value);
    };
    updateAlertDuration = (value) => {
        this.alertDuration.next(value);
    };
    updateProgressTimerVisible = (value) => {
        this.progressTimerVisible.next(value);
    };
    updateProgressTimerValue = (value) => {
        this.progressTimerValue.next(value);
    };
    updateIsMenuModalVisible = (value) => {
        this.isMenuModalVisible.next(value);
    };
    updateIsRecordingModalVisible = (value) => {
        this.isRecordingModalVisible.next(value);
        if (value) {
            this.updateConfirmedToRecord(false);
        }
        else {
            if (this.clearedToRecord.getValue() &&
                this.clearedToResume.getValue() &&
                this.recordStarted.getValue()) {
                this.updateShowRecordButtons(true);
            }
        }
    };
    updateIsSettingsModalVisible = (value) => {
        this.isSettingsModalVisible.next(value);
    };
    updateIsRequestsModalVisible = (value) => {
        this.isRequestsModalVisible.next(value);
    };
    updateIsWaitingModalVisible = (value) => {
        this.isWaitingModalVisible.next(value);
    };
    updateIsCoHostModalVisible = (value) => {
        this.isCoHostModalVisible.next(value);
    };
    updateIsMediaSettingsModalVisible = (value) => {
        this.isMediaSettingsModalVisible.next(value);
    };
    updateIsDisplaySettingsModalVisible = (value) => {
        this.isDisplaySettingsModalVisible.next(value);
    };
    updateIsParticipantsModalVisible = (value) => {
        this.isParticipantsModalVisible.next(value);
    };
    updateIsMessagesModalVisible = (value) => {
        this.isMessagesModalVisible.next(value);
        if (!value) {
            this.updateShowMessagesBadge(false);
        }
    };
    updateIsConfirmExitModalVisible = (value) => {
        this.isConfirmExitModalVisible.next(value);
    };
    updateIsConfirmHereModalVisible = (value) => {
        this.isConfirmHereModalVisible.next(value);
    };
    updateIsLoadingModalVisible = (value) => {
        this.isLoadingModalVisible.next(value);
    };
    updateIsShareEventModalVisible = (value) => {
        this.isShareEventModalVisible.next(value);
    };
    updateRecordingMediaOptions = (value) => {
        this.recordingMediaOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAudioOptions = (value) => {
        this.recordingAudioOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptions = (value) => {
        this.recordingVideoOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoType = (value) => {
        this.recordingVideoType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptimized = (value) => {
        this.recordingVideoOptimized.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingDisplayType = (value) => {
        this.recordingDisplayType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddHLS = (value) => {
        this.recordingAddHLS.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddText = (value) => {
        this.recordingAddText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomText = (value) => {
        this.recordingCustomText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextPosition = (value) => {
        this.recordingCustomTextPosition.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextColor = (value) => {
        this.recordingCustomTextColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTags = (value) => {
        this.recordingNameTags.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingBackgroundColor = (value) => {
        this.recordingBackgroundColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTagsColor = (value) => {
        this.recordingNameTagsColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingOrientationVideo = (value) => {
        this.recordingOrientationVideo.next(value);
        this.clearedToRecord.next(false);
    };
    updateClearedToResume = (value) => {
        this.clearedToResume.next(value);
    };
    updateClearedToRecord = (value) => {
        this.clearedToRecord.next(value);
    };
    updateRecordState = (value) => {
        if (this.recordStarted.value && !this.recordStopped.value) {
            if (!this.recordPaused.value) {
                this.recordState.next('red');
            }
            else {
                this.recordState.next('yellow');
            }
        }
        else {
            this.recordState.next(value);
        }
        this.recordState.next(value);
    };
    updateShowRecordButtons = (value) => {
        this.showRecordButtons.next(value);
    };
    updateRecordingProgressTime = (value) => {
        this.recordingProgressTime.next(value);
    };
    updateAudioSwitching = (value) => {
        this.audioSwitching.next(value);
    };
    updateVideoSwitching = (value) => {
        this.videoSwitching.next(value);
    };
    updateVideoAlreadyOn = (value) => {
        this.videoAlreadyOn.next(value);
        this.videoActive.next(value);
    };
    updateAudioAlreadyOn = (value) => {
        this.audioAlreadyOn.next(value);
        this.micActive.next(value);
    };
    updateComponentSizes = (sizes) => {
        this.componentSizes.next(sizes);
    };
    updateHasCameraPermission = (value) => {
        this.hasCameraPermission.next(value);
    };
    updateHasAudioPermission = (value) => {
        this.hasAudioPermission.next(value);
    };
    requestPermissionCamera() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    requestPermissionAudio() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    updateTransportCreated = (value) => {
        this.transportCreated.next(value);
    };
    updateTransportCreatedVideo = (value) => {
        this.transportCreatedVideo.next(value);
    };
    updateTransportCreatedAudio = (value) => {
        this.transportCreatedAudio.next(value);
    };
    updateTransportCreatedScreen = (value) => {
        this.transportCreatedScreen.next(value);
    };
    updateProducerTransport = (value) => {
        this.producerTransport.next(value);
    };
    updateVideoProducer = (value) => {
        this.videoProducer.next(value);
    };
    updateParams = (value) => {
        this.params.next(value);
    };
    updateVideoParams = (value) => {
        this.videoParams.next(value);
    };
    updateAudioParams = (value) => {
        this.audioParams.next(value);
    };
    updateAudioProducer = (value) => {
        this.audioProducer.next(value);
    };
    updateConsumerTransports = (value) => {
        this.consumerTransports.next(value);
    };
    updateConsumingTransports = (value) => {
        this.consumingTransports.next(value);
    };
    updatePolls = (value) => {
        this.polls.next(value);
    };
    updatePoll = (value) => {
        this.poll.next(value);
    };
    updateIsPollModalVisible = (value) => {
        this.isPollModalVisible.next(value);
    };
    updateCustomImage = (value) => {
        this.customImage.next(value);
    };
    updateSelectedImage = (value) => {
        this.selectedImage.next(value);
    };
    updateSegmentVideo = (value) => {
        this.segmentVideo.next(value);
    };
    updateSelfieSegmentation = (value) => {
        this.selfieSegmentation.next(value);
    };
    updatePauseSegmentation = (value) => {
        this.pauseSegmentation.next(value);
    };
    updateProcessedStream = (value) => {
        this.processedStream.next(value);
    };
    updateKeepBackground = (value) => {
        this.keepBackground.next(value);
    };
    updateBackgroundHasChanged = (value) => {
        this.backgroundHasChanged.next(value);
    };
    updateVirtualStream = (value) => {
        this.virtualStream.next(value);
    };
    updateMainCanvas = (value) => {
        this.mainCanvas.next(value);
    };
    updatePrevKeepBackground = (value) => {
        this.prevKeepBackground.next(value);
    };
    updateAppliedBackground = (value) => {
        this.appliedBackground.next(value);
    };
    updateIsBackgroundModalVisible = (value) => {
        this.isBackgroundModalVisible.next(value);
    };
    updateAutoClickBackground = (value) => {
        this.autoClickBackground.next(value);
    };
    updateBreakoutRooms = (value) => {
        this.breakoutRooms.next(value);
    };
    updateCurrentRoomIndex = (value) => {
        this.currentRoomIndex.next(value);
    };
    updateCanStartBreakout = (value) => {
        this.canStartBreakout.next(value);
    };
    updateBreakOutRoomStarted = (value) => {
        this.breakOutRoomStarted.next(value);
    };
    updateBreakOutRoomEnded = (value) => {
        this.breakOutRoomEnded.next(value);
    };
    updateHostNewRoom = (value) => {
        this.hostNewRoom.next(value);
    };
    updateLimitedBreakRoom = (value) => {
        this.limitedBreakRoom.next(value);
    };
    updateMainRoomsLength = (value) => {
        this.mainRoomsLength.next(value);
    };
    updateMemberRoom = (value) => {
        this.memberRoom.next(value);
    };
    updateIsBreakoutRoomsModalVisible = (value) => {
        this.isBreakoutRoomsModalVisible.next(value);
    };
    updateWhiteboardUsers = (value) => {
        this.whiteboardUsers.next(value);
    };
    updateCurrentWhiteboardIndex = (value) => {
        this.currentWhiteboardIndex.next(value);
    };
    updateCanStartWhiteboard = (value) => {
        this.canStartWhiteboard.next(value);
    };
    updateWhiteboardStarted = (value) => {
        this.whiteboardStarted.next(value);
    };
    updateWhiteboardEnded = (value) => {
        this.whiteboardEnded.next(value);
    };
    updateWhiteboardLimit = (value) => {
        this.whiteboardLimit.next(value);
    };
    updateIsWhiteboardModalVisible = (value) => {
        this.isWhiteboardModalVisible.next(value);
    };
    updateIsConfigureWhiteboardModalVisible = (value) => {
        this.isConfigureWhiteboardModalVisible.next(value);
    };
    updateShapes = (value) => {
        this.shapes.next(value);
    };
    updateUseImageBackground = (value) => {
        this.useImageBackground.next(value);
    };
    updateRedoStack = (value) => {
        this.redoStack.next(value);
    };
    updateUndoStack = (value) => {
        this.undoStack.next(value);
    };
    updateCanvasStream = (value) => {
        this.canvasStream.next(value);
    };
    updateCanvasWhiteboard = (value) => {
        this.canvasWhiteboard.next(value);
    };
    updateCanvasScreenboard = (value) => {
        this.canvasScreenboard.next(value);
    };
    updateProcessedScreenStream = (value) => {
        this.processedScreenStream.next(value);
    };
    updateAnnotateScreenStream = (value) => {
        this.annotateScreenStream.next(value);
    };
    updateMainScreenCanvas = (value) => {
        this.mainScreenCanvas.next(value);
    };
    updateIsScreenboardModalVisible = (value) => {
        this.isScreenboardModalVisible.next(value);
    };
    checkOrientation = () => {
        const isPortrait = window.matchMedia('(orientation: portrait)').matches;
        return isPortrait ? 'portrait' : 'landscape';
    };
    showAlert = ({ message, type, duration = 3000, }) => {
        this.updateAlertMessage(message);
        this.updateAlertType(type);
        this.updateAlertDuration(duration);
        this.updateAlertVisible(true);
    };
    getAllParams() {
        return {
            localUIMode: this.localUIMode.value, // Local UI mode
            // Room Details
            roomName: this.roomName.value,
            member: this.member.value,
            adminPasscode: this.adminPasscode.value,
            youAreCoHost: this.youAreCoHost.value,
            youAreHost: this.youAreHost.value,
            islevel: this.islevel.value,
            confirmedToRecord: this.confirmedToRecord.value,
            meetingDisplayType: this.meetingDisplayType.value,
            meetingVideoOptimized: this.meetingVideoOptimized.value,
            eventType: this.eventType.value,
            participants: this.participants.value,
            filteredParticipants: this.filteredParticipants.value,
            participantsCounter: this.participantsCounter.value,
            participantsFilter: this.participantsFilter.value,
            // More room details - media
            consume_sockets: this.consume_sockets.value,
            rtpCapabilities: this.rtpCapabilities.value,
            roomRecvIPs: this.roomRecvIPs.value,
            meetingRoomParams: this.meetingRoomParams.value,
            itemPageLimit: this.itemPageLimit.value,
            audioOnlyRoom: this.audioOnlyRoom.value,
            addForBasic: this.addForBasic.value,
            screenPageLimit: this.screenPageLimit.value,
            shareScreenStarted: this.shareScreenStarted.value,
            shared: this.shared.value,
            targetOrientation: this.targetOrientation.value,
            targetResolution: this.targetResolution.value,
            targetResolutionHost: this.targetResolutionHost.value,
            vidCons: this.vidCons.value,
            frameRate: this.frameRate.value,
            hParams: this.hParams.value,
            vParams: this.vParams.value,
            screenParams: this.screenParams.value,
            aParams: this.aParams.value,
            // More room details - recording
            recordingAudioPausesLimit: this.recordingAudioPausesLimit.value,
            recordingAudioPausesCount: this.recordingAudioPausesCount.value,
            recordingAudioSupport: this.recordingAudioSupport.value,
            recordingAudioPeopleLimit: this.recordingAudioPeopleLimit.value,
            recordingAudioParticipantsTimeLimit: this.recordingAudioParticipantsTimeLimit.value,
            recordingVideoPausesCount: this.recordingVideoPausesCount.value,
            recordingVideoPausesLimit: this.recordingVideoPausesLimit.value,
            recordingVideoSupport: this.recordingVideoSupport.value,
            recordingVideoPeopleLimit: this.recordingVideoPeopleLimit.value,
            recordingVideoParticipantsTimeLimit: this.recordingVideoParticipantsTimeLimit.value,
            recordingAllParticipantsSupport: this.recordingAllParticipantsSupport.value,
            recordingVideoParticipantsSupport: this.recordingVideoParticipantsSupport.value,
            recordingAllParticipantsFullRoomSupport: this.recordingAllParticipantsFullRoomSupport.value,
            recordingVideoParticipantsFullRoomSupport: this.recordingVideoParticipantsFullRoomSupport.value,
            recordingPreferredOrientation: this.recordingPreferredOrientation.value,
            recordingSupportForOtherOrientation: this.recordingSupportForOtherOrientation.value,
            recordingMultiFormatsSupport: this.recordingMultiFormatsSupport.value,
            userRecordingParams: this.userRecordingParams.value,
            canRecord: this.canRecord.value,
            startReport: this.startReport.value,
            endReport: this.endReport.value,
            recordStartTime: this.recordStartTime.value,
            recordElapsedTime: this.recordElapsedTime.value,
            isTimerRunning: this.isTimerRunning.value,
            canPauseResume: this.canPauseResume.value,
            recordChangeSeconds: this.recordChangeSeconds.value,
            pauseLimit: this.pauseLimit.value,
            pauseRecordCount: this.pauseRecordCount.value,
            canLaunchRecord: this.canLaunchRecord.value,
            stopLaunchRecord: this.stopLaunchRecord.value,
            participantsAll: this.participantsAll.value,
            firstAll: this.firstAll.value,
            updateMainWindow: this.updateMainWindow.value,
            first_round: this.first_round.value,
            landScaped: this.landScaped.value,
            lock_screen: this.lock_screen.value,
            screenId: this.screenId.value,
            allVideoStreams: this.allVideoStreams.value,
            newLimitedStreams: this.newLimitedStreams.value,
            newLimitedStreamsIDs: this.newLimitedStreamsIDs.value,
            activeSounds: this.activeSounds.value,
            screenShareIDStream: this.screenShareIDStream.value,
            screenShareNameStream: this.screenShareNameStream.value,
            adminIDStream: this.adminIDStream.value,
            adminNameStream: this.adminNameStream.value,
            youYouStream: this.youYouStream.value,
            youYouStreamIDs: this.youYouStreamIDs.value,
            localStream: this.localStream.value,
            recordStarted: this.recordStarted.value,
            recordResumed: this.recordResumed.value,
            recordPaused: this.recordPaused.value,
            recordStopped: this.recordStopped.value,
            adminRestrictSetting: this.adminRestrictSetting.value,
            videoRequestState: this.videoRequestState.value,
            videoRequestTime: this.videoRequestTime.value,
            videoAction: this.videoAction.value,
            localStreamVideo: this.localStreamVideo.value,
            userDefaultVideoInputDevice: this.userDefaultVideoInputDevice.value,
            currentFacingMode: this.currentFacingMode.value,
            prevFacingMode: this.prevFacingMode.value,
            defVideoID: this.defVideoID.value,
            allowed: this.allowed.value,
            dispActiveNames: this.dispActiveNames.value,
            p_dispActiveNames: this.p_dispActiveNames.value,
            activeNames: this.activeNames.value,
            prevActiveNames: this.prevActiveNames.value,
            p_activeNames: this.p_activeNames.value,
            membersReceived: this.membersReceived.value,
            deferScreenReceived: this.deferScreenReceived.value,
            hostFirstSwitch: this.hostFirstSwitch.value,
            micAction: this.micAction.value,
            screenAction: this.screenAction.value,
            chatAction: this.chatAction.value,
            audioRequestState: this.audioRequestState.value,
            screenRequestState: this.screenRequestState.value,
            chatRequestState: this.chatRequestState.value,
            audioRequestTime: this.audioRequestTime.value,
            screenRequestTime: this.screenRequestTime.value,
            chatRequestTime: this.chatRequestTime.value,
            updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
            oldSoundIds: this.oldSoundIds.value,
            hostLabel: this.hostLabel.value,
            mainScreenFilled: this.mainScreenFilled.value,
            localStreamScreen: this.localStreamScreen.value,
            screenAlreadyOn: this.screenAlreadyOn.value,
            chatAlreadyOn: this.chatAlreadyOn.value,
            redirectURL: this.redirectURL.value,
            oldAllStreams: this.oldAllStreams.value,
            adminVidID: this.adminVidID.value,
            streamNames: this.streamNames.value,
            non_alVideoStreams: this.non_alVideoStreams.value,
            sortAudioLoudness: this.sortAudioLoudness.value,
            audioDecibels: this.audioDecibels.value,
            mixed_alVideoStreams: this.mixed_alVideoStreams.value,
            non_alVideoStreams_muted: this.non_alVideoStreams_muted.value,
            paginatedStreams: this.paginatedStreams.value,
            localStreamAudio: this.localStreamAudio.value,
            defAudioID: this.defAudioID.value,
            userDefaultAudioInputDevice: this.userDefaultAudioInputDevice.value,
            userDefaultAudioOutputDevice: this.userDefaultAudioOutputDevice.value,
            prevAudioInputDevice: this.prevAudioInputDevice.value,
            prevVideoInputDevice: this.prevVideoInputDevice.value,
            audioPaused: this.audioPaused.value,
            mainScreenPerson: this.mainScreenPerson.value,
            adminOnMainScreen: this.adminOnMainScreen.value,
            screenStates: this.screenStates.value,
            prevScreenStates: this.prevScreenStates.value,
            updateDateState: this.updateDateState.value,
            lastUpdate: this.lastUpdate.value,
            nForReadjustRecord: this.nForReadjustRecord.value,
            fixedPageLimit: this.fixedPageLimit.value,
            removeAltGrid: this.removeAltGrid.value,
            nForReadjust: this.nForReadjust.value,
            lastReorderTime: this.lastReorderTime.value,
            reorderInterval: this.reorderInterval.value,
            fastReorderInterval: this.fastReorderInterval.value,
            audStreamNames: this.audStreamNames.value,
            currentUserPage: this.currentUserPage.value,
            mainHeightWidth: this.mainHeightWidth.value,
            prevMainHeightWidth: this.prevMainHeightWidth.value,
            prevDoPaginate: this.prevDoPaginate.value,
            doPaginate: this.doPaginate.value,
            shareEnded: this.shareEnded.value,
            lStreams: this.lStreams.value,
            chatRefStreams: this.chatRefStreams.value,
            controlHeight: this.controlHeight.value,
            isWideScreen: this.isWideScreen.value,
            isMediumScreen: this.isMediumScreen.value,
            isSmallScreen: this.isSmallScreen.value,
            addGrid: this.addGrid.value,
            addAltGrid: this.addAltGrid.value,
            gridRows: this.gridRows.value,
            gridCols: this.gridCols.value,
            altGridRows: this.altGridRows.value,
            altGridCols: this.altGridCols.value,
            numberPages: this.numberPages.value,
            currentStreams: this.currentStreams.value,
            showMiniView: this.showMiniView.value,
            nStream: this.nStream.value,
            defer_receive: this.defer_receive.value,
            allAudioStreams: this.allAudioStreams.value,
            screenProducer: this.screenProducer.value,
            remoteScreenStream: this.remoteScreenStream.value,
            gotAllVids: this.gotAllVids.value,
            paginationHeightWidth: this.paginationHeightWidth.value,
            paginationDirection: this.paginationDirection.value,
            gridSizes: this.gridSizes.value,
            screenForceFullDisplay: this.screenForceFullDisplay.value,
            mainGridStream: this.mainGridStream.value,
            otherGridStreams: this.otherGridStreams.value,
            audioOnlyStreams: this.audioOnlyStreams.value,
            videoInputs: this.videoInputs.value,
            audioInputs: this.audioInputs.value,
            meetingProgressTime: this.meetingProgressTime.value,
            meetingElapsedTime: this.meetingElapsedTime.value,
            ref_participants: this.ref_participants.value,
            messages: this.messages.value,
            startDirectMessage: this.startDirectMessage.value,
            directMessageDetails: this.directMessageDetails.value,
            coHost: this.coHost.value,
            coHostResponsibility: this.coHostResponsibility.value,
            // Event settings
            audioSetting: this.audioSetting.value,
            videoSetting: this.videoSetting.value,
            screenshareSetting: this.screenshareSetting.value,
            chatSetting: this.chatSetting.value,
            // Display settings
            autoWave: this.autoWave.value,
            forceFullDisplay: this.forceFullDisplay.value,
            prevForceFullDisplay: this.prevForceFullDisplay.value,
            prevMeetingDisplayType: this.prevMeetingDisplayType.value,
            // Waiting room
            waitingRoomFilter: this.waitingRoomFilter.value,
            waitingRoomList: this.waitingRoomList.value,
            waitingRoomCounter: this.waitingRoomCounter.value,
            filteredWaitingRoomList: this.filteredWaitingRoomList.value,
            // Requests
            requestFilter: this.requestFilter.value,
            requestList: this.requestList.value,
            requestCounter: this.requestCounter.value,
            filteredRequestList: this.filteredRequestList.value,
            // Total requests and waiting room
            totalReqWait: this.totalReqWait.value,
            // Alerts
            alertVisible: this.alertVisible.value,
            alertMessage: this.alertMessage.value,
            alertType: this.alertType.value,
            alertDuration: this.alertDuration.value,
            // Progress Timer
            progressTimerVisible: this.progressTimerVisible.value,
            progressTimerValue: this.progressTimerValue.value,
            // Menu modals
            isMenuModalVisible: this.isMenuModalVisible.value,
            isRecordingModalVisible: this.isRecordingModalVisible.value,
            isSettingsModalVisible: this.isSettingsModalVisible.value,
            isRequestsModalVisible: this.isRequestsModalVisible.value,
            isWaitingModalVisible: this.isWaitingModalVisible.value,
            isCoHostModalVisible: this.isCoHostModalVisible.value,
            isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
            isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            // Other Modals
            isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            isMessagesModalVisible: this.isMessagesModalVisible.value,
            isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            isConfirmHereModalVisible: this.isConfirmHereModalVisible.value,
            isLoadingModalVisible: this.isLoadingModalVisible.value,
            // Recording Options
            recordingMediaOptions: this.recordingMediaOptions.value,
            recordingAudioOptions: this.recordingAudioOptions.value,
            recordingVideoOptions: this.recordingVideoOptions.value,
            recordingVideoType: this.recordingVideoType.value,
            recordingVideoOptimized: this.recordingVideoOptimized.value,
            recordingDisplayType: this.recordingDisplayType.value,
            recordingAddHLS: this.recordingAddHLS.value,
            recordingAddText: this.recordingAddText.value,
            recordingCustomText: this.recordingCustomText.value,
            recordingCustomTextPosition: this.recordingCustomTextPosition.value,
            recordingCustomTextColor: this.recordingCustomTextColor.value,
            recordingNameTags: this.recordingNameTags.value,
            recordingBackgroundColor: this.recordingBackgroundColor.value,
            recordingNameTagsColor: this.recordingNameTagsColor.value,
            recordingOrientationVideo: this.recordingOrientationVideo.value,
            clearedToResume: this.clearedToResume.value,
            clearedToRecord: this.clearedToRecord.value,
            recordState: this.recordState.value,
            showRecordButtons: this.showRecordButtons.value,
            recordingProgressTime: this.recordingProgressTime.value,
            audioSwitching: this.audioSwitching.value,
            videoSwitching: this.videoSwitching.value,
            // Media states
            videoAlreadyOn: this.videoAlreadyOn.value,
            audioAlreadyOn: this.audioAlreadyOn.value,
            componentSizes: this.componentSizes.value,
            // Permissions
            hasCameraPermission: this.hasCameraPermission.value,
            hasAudioPermission: this.hasAudioPermission.value,
            // Transports
            transportCreated: this.transportCreated.value,
            transportCreatedVideo: this.transportCreatedVideo.value,
            transportCreatedAudio: this.transportCreatedAudio.value,
            transportCreatedScreen: this.transportCreatedScreen.value,
            producerTransport: this.producerTransport.value,
            videoProducer: this.videoProducer.value,
            params: this.params.value,
            videoParams: this.videoParams.value,
            audioParams: this.audioParams.value,
            audioProducer: this.audioProducer.value,
            consumerTransports: this.consumerTransports.value,
            consumingTransports: this.consumingTransports.value,
            // Polls
            polls: this.polls.value,
            poll: this.poll.value,
            isPollModalVisible: this.isPollModalVisible.value,
            // Background
            customImage: this.customImage.value,
            selectedImage: this.selectedImage.value,
            segmentVideo: this.segmentVideo.value,
            selfieSegmentation: this.selfieSegmentation.value,
            pauseSegmentation: this.pauseSegmentation.value,
            processedStream: this.processedStream.value,
            keepBackground: this.keepBackground.value,
            backgroundHasChanged: this.backgroundHasChanged.value,
            virtualStream: this.virtualStream.value,
            mainCanvas: this.mainCanvas.value,
            prevKeepBackground: this.prevKeepBackground.value,
            appliedBackground: this.appliedBackground.value,
            isBackgroundModalVisible: this.isBackgroundModalVisible.value,
            autoClickBackground: this.autoClickBackground.value,
            // Breakout rooms
            breakoutRooms: this.breakoutRooms.value,
            currentRoomIndex: this.currentRoomIndex.value,
            canStartBreakout: this.canStartBreakout.value,
            breakOutRoomStarted: this.breakOutRoomStarted.value,
            breakOutRoomEnded: this.breakOutRoomEnded.value,
            hostNewRoom: this.hostNewRoom.value,
            limitedBreakRoom: this.limitedBreakRoom.value,
            mainRoomsLength: this.mainRoomsLength.value,
            memberRoom: this.memberRoom.value,
            isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            // Whiteboard
            whiteboardUsers: this.whiteboardUsers.value,
            currentWhiteboardIndex: this.currentWhiteboardIndex.value,
            canStartWhiteboard: this.canStartWhiteboard.value,
            whiteboardStarted: this.whiteboardStarted.value,
            whiteboardEnded: this.whiteboardEnded.value,
            whiteboardLimit: this.whiteboardLimit.value,
            isWhiteboardModalVisible: this.isWhiteboardModalVisible.value,
            isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            shapes: this.shapes.value,
            useImageBackground: this.useImageBackground.value,
            redoStack: this.redoStack.value,
            undoStack: this.undoStack.value,
            canvasStream: this.canvasStream.value,
            canvasWhiteboard: this.canvasWhiteboard.value,
            // Screenboard
            canvasScreenboard: this.canvasScreenboard.value,
            processedScreenStream: this.processedScreenStream.value,
            annotateScreenStream: this.annotateScreenStream.value,
            mainScreenCanvas: this.mainScreenCanvas.value,
            isScreenboardModalVisible: this.isScreenboardModalVisible.value,
            validated: this.validated.value,
            device: this.device.value,
            socket: this.socket.value,
            checkMediaPermission: false,
            onWeb: true,
            // Update functions
            updateRoomName: this.updateRoomName.bind(this),
            updateMember: this.updateMember.bind(this),
            updateAdminPasscode: this.updateAdminPasscode.bind(this),
            updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
            updateYouAreHost: this.updateYouAreHost.bind(this),
            updateIslevel: this.updateIslevel.bind(this),
            updateCoHost: this.updateCoHost.bind(this),
            updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
            updateConfirmedToRecord: this.updateConfirmedToRecord.bind(this),
            updateMeetingDisplayType: this.updateMeetingDisplayType.bind(this),
            updateMeetingVideoOptimized: this.updateMeetingVideoOptimized.bind(this),
            updateEventType: this.updateEventType.bind(this),
            updateParticipants: this.updateParticipants.bind(this),
            updateParticipantsCounter: this.updateParticipantsCounter.bind(this),
            updateParticipantsFilter: this.updateParticipantsFilter.bind(this),
            // More update functions for media details
            updateConsume_sockets: this.updateConsume_sockets.bind(this),
            updateRtpCapabilities: this.updateRtpCapabilities.bind(this),
            updateRoomRecvIPs: this.updateRoomRecvIPs.bind(this),
            updateMeetingRoomParams: this.updateMeetingRoomParams.bind(this),
            updateItemPageLimit: this.updateItemPageLimit.bind(this),
            updateAudioOnlyRoom: this.updateAudioOnlyRoom.bind(this),
            updateAddForBasic: this.updateAddForBasic.bind(this),
            updateScreenPageLimit: this.updateScreenPageLimit.bind(this),
            updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
            updateShared: this.updateShared.bind(this),
            updateTargetOrientation: this.updateTargetOrientation.bind(this),
            updateTargetResolution: this.updateTargetResolution.bind(this),
            updateTargetResolutionHost: this.updateTargetResolutionHost.bind(this),
            updateVidCons: this.updateVidCons.bind(this),
            updateFrameRate: this.updateFrameRate.bind(this),
            updateHParams: this.updateHParams.bind(this),
            updateVParams: this.updateVParams.bind(this),
            updateScreenParams: this.updateScreenParams.bind(this),
            updateAParams: this.updateAParams.bind(this),
            // More update functions for recording details
            updateRecordingAudioPausesLimit: this.updateRecordingAudioPausesLimit.bind(this),
            updateRecordingAudioPausesCount: this.updateRecordingAudioPausesCount.bind(this),
            updateRecordingAudioSupport: this.updateRecordingAudioSupport.bind(this),
            updateRecordingAudioPeopleLimit: this.updateRecordingAudioPeopleLimit.bind(this),
            updateRecordingAudioParticipantsTimeLimit: this.updateRecordingAudioParticipantsTimeLimit.bind(this),
            updateRecordingVideoPausesCount: this.updateRecordingVideoPausesCount.bind(this),
            updateRecordingVideoPausesLimit: this.updateRecordingVideoPausesLimit.bind(this),
            updateRecordingVideoSupport: this.updateRecordingVideoSupport.bind(this),
            updateRecordingVideoPeopleLimit: this.updateRecordingVideoPeopleLimit.bind(this),
            updateRecordingVideoParticipantsTimeLimit: this.updateRecordingVideoParticipantsTimeLimit.bind(this),
            updateRecordingAllParticipantsSupport: this.updateRecordingAllParticipantsSupport.bind(this),
            updateRecordingVideoParticipantsSupport: this.updateRecordingVideoParticipantsSupport.bind(this),
            updateRecordingAllParticipantsFullRoomSupport: this.updateRecordingAllParticipantsFullRoomSupport.bind(this),
            updateRecordingVideoParticipantsFullRoomSupport: this.updateRecordingVideoParticipantsFullRoomSupport.bind(this),
            updateRecordingPreferredOrientation: this.updateRecordingPreferredOrientation.bind(this),
            updateRecordingSupportForOtherOrientation: this.updateRecordingSupportForOtherOrientation.bind(this),
            updateRecordingMultiFormatsSupport: this.updateRecordingMultiFormatsSupport.bind(this),
            updateUserRecordingParams: this.updateUserRecordingParams.bind(this),
            updateCanRecord: this.updateCanRecord.bind(this),
            updateStartReport: this.updateStartReport.bind(this),
            updateEndReport: this.updateEndReport.bind(this),
            updateRecordTimerInterval: this.updateRecordTimerInterval.bind(this),
            updateRecordStartTime: this.updateRecordStartTime.bind(this),
            updateRecordElapsedTime: this.updateRecordElapsedTime.bind(this),
            updateIsTimerRunning: this.updateIsTimerRunning.bind(this),
            updateCanPauseResume: this.updateCanPauseResume.bind(this),
            updateRecordChangeSeconds: this.updateRecordChangeSeconds.bind(this),
            updatePauseLimit: this.updatePauseLimit.bind(this),
            updatePauseRecordCount: this.updatePauseRecordCount.bind(this),
            updateCanLaunchRecord: this.updateCanLaunchRecord.bind(this),
            updateStopLaunchRecord: this.updateStopLaunchRecord.bind(this),
            updateParticipantsAll: this.updateParticipantsAll.bind(this),
            updateFirstAll: this.updateFirstAll.bind(this),
            updateUpdateMainWindow: this.updateUpdateMainWindow.bind(this),
            updateFirst_round: this.updateFirst_round.bind(this),
            updateLandScaped: this.updateLandScaped.bind(this),
            updateLock_screen: this.updateLock_screen.bind(this),
            updateScreenId: this.updateScreenId.bind(this),
            updateAllVideoStreams: this.updateAllVideoStreams.bind(this),
            updateNewLimitedStreams: this.updateNewLimitedStreams.bind(this),
            updateNewLimitedStreamsIDs: this.updateNewLimitedStreamsIDs.bind(this),
            updateActiveSounds: this.updateActiveSounds.bind(this),
            updateScreenShareIDStream: this.updateScreenShareIDStream.bind(this),
            updateScreenShareNameStream: this.updateScreenShareNameStream.bind(this),
            updateAdminIDStream: this.updateAdminIDStream.bind(this),
            updateAdminNameStream: this.updateAdminNameStream.bind(this),
            updateYouYouStream: this.updateYouYouStream.bind(this),
            updateYouYouStreamIDs: this.updateYouYouStreamIDs.bind(this),
            updateLocalStream: this.updateLocalStream.bind(this),
            updateRecordStarted: this.updateRecordStarted.bind(this),
            updateRecordResumed: this.updateRecordResumed.bind(this),
            updateRecordPaused: this.updateRecordPaused.bind(this),
            updateRecordStopped: this.updateRecordStopped.bind(this),
            updateAdminRestrictSetting: this.updateAdminRestrictSetting.bind(this),
            updateVideoRequestState: this.updateVideoRequestState.bind(this),
            updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
            updateVideoAction: this.updateVideoAction.bind(this),
            updateLocalStreamVideo: this.updateLocalStreamVideo.bind(this),
            updateUserDefaultVideoInputDevice: this.updateUserDefaultVideoInputDevice.bind(this),
            updateCurrentFacingMode: this.updateCurrentFacingMode.bind(this),
            updatePrevFacingMode: this.updatePrevFacingMode.bind(this),
            updateDefVideoID: this.updateDefVideoID.bind(this),
            updateAllowed: this.updateAllowed.bind(this),
            updateDispActiveNames: this.updateDispActiveNames.bind(this),
            updateP_dispActiveNames: this.updateP_dispActiveNames.bind(this),
            updateActiveNames: this.updateActiveNames.bind(this),
            updatePrevActiveNames: this.updatePrevActiveNames.bind(this),
            updateP_activeNames: this.updateP_activeNames.bind(this),
            updateMembersReceived: this.updateMembersReceived.bind(this),
            updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
            updateHostFirstSwitch: this.updateHostFirstSwitch.bind(this),
            updateMicAction: this.updateMicAction.bind(this),
            updateScreenAction: this.updateScreenAction.bind(this),
            updateChatAction: this.updateChatAction.bind(this),
            updateAudioRequestState: this.updateAudioRequestState.bind(this),
            updateScreenRequestState: this.updateScreenRequestState.bind(this),
            updateChatRequestState: this.updateChatRequestState.bind(this),
            updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
            updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
            updateChatRequestTime: this.updateChatRequestTime.bind(this),
            updateOldSoundIds: this.updateOldSoundIds.bind(this),
            updateHostLabel: this.updateHostLabel.bind(this),
            updateMainScreenFilled: this.updateMainScreenFilled.bind(this),
            updateLocalStreamScreen: this.updateLocalStreamScreen.bind(this),
            updateScreenAlreadyOn: this.updateScreenAlreadyOn.bind(this),
            updateChatAlreadyOn: this.updateChatAlreadyOn.bind(this),
            updateRedirectURL: this.updateRedirectURL.bind(this),
            updateOldAllStreams: this.updateOldAllStreams.bind(this),
            updateAdminVidID: this.updateAdminVidID.bind(this),
            updateStreamNames: this.updateStreamNames.bind(this),
            updateNon_alVideoStreams: this.updateNon_alVideoStreams.bind(this),
            updateSortAudioLoudness: this.updateSortAudioLoudness.bind(this),
            updateAudioDecibels: this.updateAudioDecibels.bind(this),
            updateMixed_alVideoStreams: this.updateMixed_alVideoStreams.bind(this),
            updateNon_alVideoStreams_muted: this.updateNon_alVideoStreams_muted.bind(this),
            updatePaginatedStreams: this.updatePaginatedStreams.bind(this),
            updateLocalStreamAudio: this.updateLocalStreamAudio.bind(this),
            updateDefAudioID: this.updateDefAudioID.bind(this),
            updateUserDefaultAudioInputDevice: this.updateUserDefaultAudioInputDevice.bind(this),
            updateUserDefaultAudioOutputDevice: this.updateUserDefaultAudioOutputDevice.bind(this),
            updatePrevAudioInputDevice: this.updatePrevAudioInputDevice.bind(this),
            updatePrevVideoInputDevice: this.updatePrevVideoInputDevice.bind(this),
            updateAudioPaused: this.updateAudioPaused.bind(this),
            updateMainScreenPerson: this.updateMainScreenPerson.bind(this),
            updateAdminOnMainScreen: this.updateAdminOnMainScreen.bind(this),
            updateScreenStates: this.updateScreenStates.bind(this),
            updatePrevScreenStates: this.updatePrevScreenStates.bind(this),
            updateUpdateDateState: this.updateUpdateDateState.bind(this),
            updateLastUpdate: this.updateLastUpdate.bind(this),
            updateNForReadjustRecord: this.updateNForReadjustRecord.bind(this),
            updateFixedPageLimit: this.updateFixedPageLimit.bind(this),
            updateRemoveAltGrid: this.updateRemoveAltGrid.bind(this),
            updateNForReadjust: this.updateNForReadjust.bind(this),
            updateLastReorderTime: this.updateLastReorderTime.bind(this),
            updateAudStreamNames: this.updateAudStreamNames.bind(this),
            updateCurrentUserPage: this.updateCurrentUserPage.bind(this),
            updateMainHeightWidth: this.updateMainHeightWidth.bind(this),
            updatePrevMainHeightWidth: this.updatePrevMainHeightWidth.bind(this),
            updatePrevDoPaginate: this.updatePrevDoPaginate.bind(this),
            updateDoPaginate: this.updateDoPaginate.bind(this),
            updateShareEnded: this.updateShareEnded.bind(this),
            updateLStreams: this.updateLStreams.bind(this),
            updateChatRefStreams: this.updateChatRefStreams.bind(this),
            updateControlHeight: this.updateControlHeight.bind(this),
            updateIsWideScreen: this.updateIsWideScreen.bind(this),
            updateIsMediumScreen: this.updateIsMediumScreen.bind(this),
            updateIsSmallScreen: this.updateIsSmallScreen.bind(this),
            updateAddGrid: this.updateAddGrid.bind(this),
            updateAddAltGrid: this.updateAddAltGrid.bind(this),
            updateGridRows: this.updateGridRows.bind(this),
            updateGridCols: this.updateGridCols.bind(this),
            updateAltGridRows: this.updateAltGridRows.bind(this),
            updateAltGridCols: this.updateAltGridCols.bind(this),
            updateNumberPages: this.updateNumberPages.bind(this),
            updateCurrentStreams: this.updateCurrentStreams.bind(this),
            updateShowMiniView: this.updateShowMiniView.bind(this),
            updateNStream: this.updateNStream.bind(this),
            updateDefer_receive: this.updateDefer_receive.bind(this),
            updateAllAudioStreams: this.updateAllAudioStreams.bind(this),
            updateRemoteScreenStream: this.updateRemoteScreenStream.bind(this),
            updateScreenProducer: this.updateScreenProducer.bind(this),
            updateGotAllVids: this.updateGotAllVids.bind(this),
            updatePaginationHeightWidth: this.updatePaginationHeightWidth.bind(this),
            updatePaginationDirection: this.updatePaginationDirection.bind(this),
            updateGridSizes: this.updateGridSizes.bind(this),
            updateScreenForceFullDisplay: this.updateScreenForceFullDisplay.bind(this),
            updateMainGridStream: this.updateMainGridStream.bind(this),
            updateOtherGridStreams: this.updateOtherGridStreams.bind(this),
            updateAudioOnlyStreams: this.updateAudioOnlyStreams.bind(this),
            updateVideoInputs: this.updateVideoInputs.bind(this),
            updateAudioInputs: this.updateAudioInputs.bind(this),
            updateMeetingProgressTime: this.updateMeetingProgressTime.bind(this),
            updateMeetingElapsedTime: this.updateMeetingElapsedTime.bind(this),
            updateRef_participants: this.updateRef_participants.bind(this),
            updateMessages: this.updateMessages.bind(this),
            updateStartDirectMessage: this.updateStartDirectMessage.bind(this),
            updateDirectMessageDetails: this.updateDirectMessageDetails.bind(this),
            updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
            // Event settings
            updateAudioSetting: this.updateAudioSetting.bind(this),
            updateVideoSetting: this.updateVideoSetting.bind(this),
            updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
            updateChatSetting: this.updateChatSetting.bind(this),
            // Display settings
            updateAutoWave: this.updateAutoWave.bind(this),
            updateForceFullDisplay: this.updateForceFullDisplay.bind(this),
            updatePrevForceFullDisplay: this.updatePrevForceFullDisplay.bind(this),
            updatePrevMeetingDisplayType: this.updatePrevMeetingDisplayType.bind(this),
            // Waiting room
            updateWaitingRoomFilter: this.updateWaitingRoomFilter.bind(this),
            updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
            updateWaitingRoomCounter: this.updateWaitingRoomCounter.bind(this),
            // Requests
            updateRequestFilter: this.updateRequestFilter.bind(this),
            updateRequestList: this.updateRequestList.bind(this),
            updateRequestCounter: this.updateRequestCounter.bind(this),
            // Total requests and waiting room
            updateTotalReqWait: this.updateTotalReqWait.bind(this),
            // Menu modals
            updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
            updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
            updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
            updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
            updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
            updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
            // Other modals
            updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
            updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
            updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
            updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
            updateIsLoadingModalVisible: this.updateIsLoadingModalVisible.bind(this),
            // Recording Options
            updateRecordingMediaOptions: this.updateRecordingMediaOptions.bind(this),
            updateRecordingAudioOptions: this.updateRecordingAudioOptions.bind(this),
            updateRecordingVideoOptions: this.updateRecordingVideoOptions.bind(this),
            updateRecordingVideoType: this.updateRecordingVideoType.bind(this),
            updateRecordingVideoOptimized: this.updateRecordingVideoOptimized.bind(this),
            updateRecordingDisplayType: this.updateRecordingDisplayType.bind(this),
            updateRecordingAddHLS: this.updateRecordingAddHLS.bind(this),
            updateRecordingAddText: this.updateRecordingAddText.bind(this),
            updateRecordingCustomText: this.updateRecordingCustomText.bind(this),
            updateRecordingCustomTextPosition: this.updateRecordingCustomTextPosition.bind(this),
            updateRecordingCustomTextColor: this.updateRecordingCustomTextColor.bind(this),
            updateRecordingNameTags: this.updateRecordingNameTags.bind(this),
            updateRecordingBackgroundColor: this.updateRecordingBackgroundColor.bind(this),
            updateRecordingNameTagsColor: this.updateRecordingNameTagsColor.bind(this),
            updateRecordingOrientationVideo: this.updateRecordingOrientationVideo.bind(this),
            updateClearedToResume: this.updateClearedToResume.bind(this),
            updateClearedToRecord: this.updateClearedToRecord.bind(this),
            updateRecordState: this.updateRecordState.bind(this),
            updateShowRecordButtons: this.updateShowRecordButtons.bind(this),
            updateRecordingProgressTime: this.updateRecordingProgressTime.bind(this),
            updateAudioSwitching: this.updateAudioSwitching.bind(this),
            updateVideoSwitching: this.updateVideoSwitching.bind(this),
            // Media states
            updateVideoAlreadyOn: this.updateVideoAlreadyOn.bind(this),
            updateAudioAlreadyOn: this.updateAudioAlreadyOn.bind(this),
            updateComponentSizes: this.updateComponentSizes.bind(this),
            // Permissions
            updateHasCameraPermission: this.updateHasCameraPermission.bind(this),
            updateHasAudioPermission: this.updateHasAudioPermission.bind(this),
            // Transports
            updateTransportCreated: this.updateTransportCreated.bind(this),
            updateTransportCreatedVideo: this.updateTransportCreatedVideo.bind(this),
            updateTransportCreatedAudio: this.updateTransportCreatedAudio.bind(this),
            updateTransportCreatedScreen: this.updateTransportCreatedScreen.bind(this),
            updateProducerTransport: this.updateProducerTransport.bind(this),
            updateVideoProducer: this.updateVideoProducer.bind(this),
            updateParams: this.updateParams.bind(this),
            updateVideoParams: this.updateVideoParams.bind(this),
            updateAudioParams: this.updateAudioParams.bind(this),
            updateAudioProducer: this.updateAudioProducer.bind(this),
            updateConsumerTransports: this.updateConsumerTransports.bind(this),
            updateConsumingTransports: this.updateConsumingTransports.bind(this),
            // Polls
            updatePolls: this.updatePolls.bind(this),
            updatePoll: this.updatePoll.bind(this),
            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
            // Background
            updateCustomImage: this.updateCustomImage.bind(this),
            updateSelectedImage: this.updateSelectedImage.bind(this),
            updateSegmentVideo: this.updateSegmentVideo.bind(this),
            updateSelfieSegmentation: this.updateSelfieSegmentation.bind(this),
            updatePauseSegmentation: this.updatePauseSegmentation.bind(this),
            updateProcessedStream: this.updateProcessedStream.bind(this),
            updateKeepBackground: this.updateKeepBackground.bind(this),
            updateBackgroundHasChanged: this.updateBackgroundHasChanged.bind(this),
            updateVirtualStream: this.updateVirtualStream.bind(this),
            updateMainCanvas: this.updateMainCanvas.bind(this),
            updatePrevKeepBackground: this.updatePrevKeepBackground.bind(this),
            updateAppliedBackground: this.updateAppliedBackground.bind(this),
            updateIsBackgroundModalVisible: this.updateIsBackgroundModalVisible.bind(this),
            updateAutoClickBackground: this.updateAutoClickBackground.bind(this),
            // Breakout rooms
            updateBreakoutRooms: this.updateBreakoutRooms.bind(this),
            updateCurrentRoomIndex: this.updateCurrentRoomIndex.bind(this),
            updateCanStartBreakout: this.updateCanStartBreakout.bind(this),
            updateBreakOutRoomStarted: this.updateBreakOutRoomStarted.bind(this),
            updateBreakOutRoomEnded: this.updateBreakOutRoomEnded.bind(this),
            updateHostNewRoom: this.updateHostNewRoom.bind(this),
            updateLimitedBreakRoom: this.updateLimitedBreakRoom.bind(this),
            updateMainRoomsLength: this.updateMainRoomsLength.bind(this),
            updateMemberRoom: this.updateMemberRoom.bind(this),
            updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
            // Whiteboard
            updateWhiteboardUsers: this.updateWhiteboardUsers.bind(this),
            updateCurrentWhiteboardIndex: this.updateCurrentWhiteboardIndex.bind(this),
            updateCanStartWhiteboard: this.updateCanStartWhiteboard.bind(this),
            updateWhiteboardStarted: this.updateWhiteboardStarted.bind(this),
            updateWhiteboardEnded: this.updateWhiteboardEnded.bind(this),
            updateWhiteboardLimit: this.updateWhiteboardLimit.bind(this),
            updateIsWhiteboardModalVisible: this.updateIsWhiteboardModalVisible.bind(this),
            updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
            updateShapes: this.updateShapes.bind(this),
            updateUseImageBackground: this.updateUseImageBackground.bind(this),
            updateRedoStack: this.updateRedoStack.bind(this),
            updateUndoStack: this.updateUndoStack.bind(this),
            updateCanvasStream: this.updateCanvasStream.bind(this),
            updateCanvasWhiteboard: this.updateCanvasWhiteboard.bind(this),
            // Screenboard
            updateCanvasScreenboard: this.updateCanvasScreenboard.bind(this),
            updateProcessedScreenStream: this.updateProcessedScreenStream.bind(this),
            updateAnnotateScreenStream: this.updateAnnotateScreenStream.bind(this),
            updateMainScreenCanvas: this.updateMainScreenCanvas.bind(this),
            updateIsScreenboardModalVisible: this.updateIsScreenboardModalVisible.bind(this),
            // Other functions
            checkOrientation: this.checkOrientation.bind(this),
            updateDevice: this.updateDevice.bind(this),
            updateSocket: this.updateSocket.bind(this),
            updateValidated: this.updateValidated.bind(this),
            showAlert: this.showAlert.bind(this),
            getUpdatedAllParams: () => {
                return {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                };
            },
        };
    }
    mediaSFUParameters = {
        ...this.getAllParams(),
        ...this.mediaSFUFunctions(),
    };
    getUpdatedAllParams = () => {
        return {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    };
    PrejoinPageComponent = {
        component: this.PrejoinPage,
        injector: null,
    };
    updatePrejoinPageComponent = () => {
        const PrejoinComp = {
            component: this.PrejoinPage,
            injector: this.createInjector({
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    updateSocket: this.updateSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                credentials: this.credentials,
            }),
        };
        this.PrejoinPageComponent = { ...PrejoinComp };
        this.cdr.detectChanges();
    };
    ngOnInit() {
        if (this.PrejoinPage) {
            this.updatePrejoinPageComponent();
        }
        this.setupResizeListener();
        if (this.validated) {
            this.connectAndAddSocketMethods();
        }
        this.mainHeightWidthSubscription = this.mainHeightWidth.subscribe(() => {
            this.updateMainVideoSize();
        });
        this.validatedSubscription = this.validated.subscribe((validated) => {
            if (validated) {
                this.handleValidated();
            }
        });
        this.islevelSubscription = this.islevel.subscribe((islevel) => {
            if (islevel) {
                this.updateControlChatButtons();
            }
        });
        this.coHostSubscription = combineLatest([this.coHost, this.coHostResponsibility]).subscribe(([coHost, coHostResponsibility]) => {
            if (coHost || coHostResponsibility) {
                this.updateControlChatButtons();
            }
        });
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.handleResize);
        window.removeEventListener('orientationchange', this.handleResize);
        if (this.mainHeightWidthSubscription) {
            this.mainHeightWidthSubscription.unsubscribe();
        }
        if (this.validatedSubscription) {
            this.validatedSubscription.unsubscribe();
        }
        if (this.islevelSubscription) {
            this.islevelSubscription.unsubscribe();
        }
        if (this.coHostSubscription) {
            this.coHostSubscription.unsubscribe();
        }
        if (this.ScreenboardSubscription) {
            this.ScreenboardSubscription.unsubscribe();
        }
        if (this.recordingSubscription) {
            this.recordingSubscription.unsubscribe();
        }
    }
    updateMainVideoSize = async () => {
        if (!this.lock_screen.value && !this.shared.value) {
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
        }
        else {
            if (!this.first_round.value) {
                this.prepopulateUserMedia.prepopulateUserMedia({
                    name: this.hostLabel.value,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            }
        }
    };
    async connectAndAddSocketMethods() {
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
        const socket_ = await this.connect_Socket(this.apiUserName.value, '', this.apiToken.value);
        if (socket_) {
            this.updateSocket(socket_);
        }
    }
    async handleValidated() {
        this.updateAllVideoStreams([
            { producerId: 'youyou', stream: undefined, id: 'youyou', name: 'youyou' },
        ]);
        this.updateStreamNames([{ id: 'youyou', name: 'youyou', producerId: '' }]);
        if (this.validated.value) {
            this.updateIsLoadingModalVisible(true);
            try {
                if (!this.localUIMode.value) {
                    await this.connectAndAddSocketMethods();
                }
            }
            catch (error) {
                console.log('error connectAndaAddSocketMethods', error);
            }
            this.startMeetingProgressTimer.startMeetingProgressTimer({
                startTime: Date.now() / 1000,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            this.updateIsLoadingModalVisible(false);
        }
    }
    async handleResize() {
        let fraction = 0;
        if (window.innerHeight < window.innerWidth &&
            (this.eventType.value == 'webinar' || this.eventType.value == 'conference')) {
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        else {
            // Set default control button height for portrait mode or other event types
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            fraction = Number(fraction);
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        const dimensions = this.computeDimensionsMethod({
            containerWidthFraction: 1,
            containerHeightFraction: 1,
            mainSize: this.mainHeightWidth.value,
            doStack: true,
            defaultFraction: this.eventType.value == 'webinar' || this.eventType.value == 'conference'
                ? 1 - fraction
                : 1,
        });
        this.updateComponentSizes(dimensions);
        const orientation = this.checkOrientation();
        if (orientation == 'portrait') {
            if (!this.isWideScreen.value) {
                if (this.shareScreenStarted.value || this.shared.value) {
                    this.updateScreenForceFullDisplay(true);
                }
            }
        }
        // Updates the main grid view
        await this.prepopulateUserMedia.prepopulateUserMedia({
            name: this.hostLabel.value,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
        // Updates the mini grid view
        await this.onScreenChanges.onScreenChanges({
            changed: true,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
    }
    async disconnectAllSockets(consume_sockets) {
        for (const socket of consume_sockets) {
            try {
                const ip = Object.keys(socket)[0];
                await socket[ip].disconnect();
            }
            catch (error) {
                console.log(`Error disconnecting socket with IP: ${Object.keys(socket)[0]}`, error);
            }
        }
    }
    async closeAndReset() {
        //close and clean up all sockets, modals,... and reset all states to initial values
        this.updateIsMessagesModalVisible(false);
        this.updateIsParticipantsModalVisible(false);
        this.updateIsWaitingModalVisible(false);
        this.updateIsRequestsModalVisible(false);
        this.updateIsCoHostModalVisible(false);
        this.updateIsSettingsModalVisible(false);
        this.updateIsDisplaySettingsModalVisible(false);
        this.updateIsMediaSettingsModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsShareEventModalVisible(false);
        this.updateIsConfirmExitModalVisible(false);
        await this.disconnectAllSockets(this.consume_sockets.value);
        await this.updateStatesToInitialValues();
        this.updateMeetingProgressTime('00:00:00');
        this.updateMeetingElapsedTime(0);
        this.updateRecordingProgressTime('00:00:00');
        this.updateRecordElapsedTime(0);
        this.updateShowRecordButtons(false);
        this.updateIsConfigureWhiteboardModalVisible(false);
        this.updateIsWhiteboardModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsRecordingModalVisible(false);
        this.updateIsPollModalVisible(false);
        this.updateIsBreakoutRoomsModalVisible(false);
        this.updateIsBackgroundModalVisible(false);
        this.updateIsLoadingModalVisible(false);
        this.updateIsConfirmHereModalVisible(false);
        await sleep({ ms: 500 });
        this.updateValidated(false);
        //if on web, reload the page
        window.location.reload();
    }
    computeDimensionsMethod = ({ containerWidthFraction = 1, containerHeightFraction = 1, mainSize, doStack = true, defaultFraction, }) => {
        const parentWidth = window.innerWidth * containerWidthFraction;
        const parentHeight = window.innerHeight * containerHeightFraction * defaultFraction;
        let isWideScreen = parentWidth >= 768;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        const dimensions = this.calculateDimensions({
            parentWidth,
            parentHeight,
            isWideScreen,
            mainSize,
            doStack,
        });
        return dimensions;
    };
    calculateDimensions({ parentWidth, parentHeight, isWideScreen, mainSize, doStack, }) {
        if (doStack) {
            return isWideScreen
                ? {
                    mainHeight: Math.floor(parentHeight),
                    otherHeight: Math.floor(parentHeight),
                    mainWidth: Math.floor((mainSize / 100) * parentWidth),
                    otherWidth: Math.floor(((100 - mainSize) / 100) * parentWidth),
                }
                : {
                    mainHeight: Math.floor((mainSize / 100) * parentHeight),
                    otherHeight: Math.floor(((100 - mainSize) / 100) * parentHeight),
                    mainWidth: Math.floor(parentWidth),
                    otherWidth: Math.floor(parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(parentHeight),
                otherHeight: Math.floor(parentHeight),
                mainWidth: Math.floor(parentWidth),
                otherWidth: Math.floor(parentWidth),
            };
        }
    }
    handleOrientationChange() {
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('orientationchange', this.handleResize.bind(this));
    }
    setupResizeListener() {
        this.handleResize();
    }
    orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    async joinRoom(data) {
        const { socket, roomName, islevel, member, sec, apiUserName } = data;
        try {
            const response = await this.joinRoomClient.joinRoomClient({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
            return response;
        }
        catch (error) {
            console.log('Error joining room:', error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    async join_Room({ socket, roomName, islevel, member, sec, apiUserName, }) {
        const data = await this.joinRoom({
            socket: socket,
            roomName: roomName,
            islevel: islevel,
            member: member,
            sec: sec,
            apiUserName: apiUserName,
        });
        if (data && data.success) {
            this.roomData.next(data);
            try {
                this.updateRoomParametersClient.updateRoomParametersClient({
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                        data: data,
                    },
                });
                if (data.isHost) {
                    this.updateIslevel('2');
                }
                else {
                    this.updateIslevel('1');
                }
                if (data.secureCode) {
                    this.updateAdminPasscode(data.secureCode);
                }
                if (data.rtpCapabilities) {
                    const device_ = await this.createDeviceClient.createDeviceClient({
                        rtpCapabilities: data.rtpCapabilities,
                    });
                    if (device_) {
                        this.device.next(device_);
                    }
                }
            }
            catch {
                /* handle error */
            }
        }
        else {
            this.updateValidated(false);
            try {
                if (this.showAlert && data?.reason) {
                    this.showAlert({ message: data?.reason, type: 'danger', duration: 3000 });
                }
            }
            catch {
                /* handle error */
            }
        }
    }
    updateStatesToInitialValues = async () => {
        const initialValues = initialValuesState;
        const updateFunctions = this.getAllParams();
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                const updateFunctionName = `update${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const updateFunction = updateFunctions[updateFunctionName];
                if (typeof updateFunction === 'function') {
                    try {
                        updateFunction(initialValues[key]);
                    }
                    catch {
                        /* handle error */
                    }
                }
            }
        }
    };
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faSync = faSync;
    faPhone = faPhone;
    faShareAlt = faShareAlt;
    faComments = faComments;
    onCloseMenuModal = () => {
        this.updateIsMenuModalVisible(false);
    };
    onEventSettingsClose = () => {
        this.updateIsSettingsModalVisible(false);
    };
    onCoHostClose = () => {
        this.updateIsCoHostModalVisible(false);
    };
    onMediaSettingsClose = () => {
        this.updateIsMediaSettingsModalVisible(false);
    };
    onDisplaySettingsClose = () => {
        this.updateIsDisplaySettingsModalVisible(false);
    };
    onPollClose = () => {
        this.updateIsPollModalVisible(false);
    };
    onBreakoutRoomsClose = () => {
        this.updateIsBreakoutRoomsModalVisible(false);
    };
    onConfigureWhiteboardClose = () => {
        this.updateIsConfigureWhiteboardModalVisible(false);
    };
    onMessagesClose = () => {
        this.updateIsMessagesModalVisible(false);
    };
    onRecordingClose = () => {
        this.updateIsRecordingModalVisible(false);
    };
    onParticipantsClose = () => {
        this.updateIsParticipantsModalVisible(false);
    };
    onBackgroundClose = () => {
        this.updateIsBackgroundModalVisible(false);
    };
    onConfirmExitClose = () => {
        this.updateIsConfirmExitModalVisible(false);
    };
    onConfirmHereClose = () => {
        this.updateIsConfirmHereModalVisible(false);
    };
    onScreenboardClose = () => {
        this.updateIsScreenboardModalVisible(false);
    };
    onShareEventClose = () => {
        this.updateIsShareEventModalVisible(false);
    };
    onAlertHide = () => {
        this.updateAlertVisible(false);
    };
    messageWidget = {
        component: MessageWidget,
        injector: this.createInjector({
            icon: this.faComments,
            showBadge: this.showMessagesBadge.value,
            badgeValue: 1,
            iconColor: 'black',
        }),
    };
    controlChatButtons = [];
    controlChatButtonsArray = [
        {
            icon: this.faShareAlt,
            active: true,
            alternateIcon: this.faShareAlt,
            onPress: () => this.updateIsShareEventModalVisible(!this.isShareEventModalVisible.value),
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
        {
            customComponent: this.messageWidget,
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: true,
        },
        {
            icon: this.faSync,
            active: true,
            alternateIcon: this.faSync,
            onPress: () => this.switchVideoAlt.switchVideoAlt({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: () => this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: () => this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
    ];
    updateControlChatButtons() {
        this.controlChatButtons = this.controlChatButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                active: typeof button.active === 'function' ? button.active() : button.active,
            };
        });
    }
    async connect_Socket(apiUserName, apiKey, apiToken) {
        if (this.socket.value && this.socket.value.id) {
            this.socket.value.on('disconnect', async () => {
                await this.disconnect.disconnect({
                    showAlert: this.showAlert.bind(this),
                    redirectURL: this.redirectURL.value,
                    onWeb: true,
                    updateValidated: this.updateValidated.bind(this),
                });
                if (this.videoAlreadyOn.value) {
                    await this.clickVideo.clickVideo({
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                if (this.audioAlreadyOn.value) {
                    await this.clickAudio.clickAudio({
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                await this.closeAndReset();
            });
            this.socket.value.on('allMembers', async (membersData) => {
                if (membersData) {
                    await this.allMembers.allMembers({
                        apiUserName: apiUserName,
                        apiKey: '', //not recommended - use apiToken instead. Use for testing/development only
                        apiToken: apiToken,
                        members: membersData.members,
                        requestss: membersData.requests ? membersData.requests : this.requestList.value,
                        coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                        coHostRes: membersData.coHostResponsibilities
                            ? membersData.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        consume_sockets: this.consume_sockets.value,
                    });
                }
            });
            this.socket.value.on('allMembersRest', async (membersData) => {
                if (membersData) {
                    await this.allMembersRest.allMembersRest({
                        apiUserName: apiUserName,
                        apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                        members: membersData.members,
                        apiToken: apiToken,
                        settings: membersData.settings,
                        coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                        coHostRes: membersData.coHostResponsibilities
                            ? membersData.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        consume_sockets: this.consume_sockets.value,
                    });
                }
            });
            this.socket.value.on('producer-media-paused', async ({ producerId, kind, name, }) => {
                await this.producerMediaPaused.producerMediaPaused({
                    producerId,
                    kind,
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('producer-media-resumed', async ({ kind, name }) => {
                await this.producerMediaResumed.producerMediaResumed({
                    kind,
                    name,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            this.socket.value.on('producer-media-closed', async ({ producerId, kind, }) => {
                if (producerId && kind) {
                    await this.producerMediaClosed.producerMediaClosed({
                        producerId,
                        kind,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
            });
            this.socket.value.on('meetingEnded', async () => {
                await this.meetingEnded.meetingEnded({
                    showAlert: this.showAlert.bind(this),
                    redirectURL: this.redirectURL.value,
                    onWeb: true,
                    eventType: this.eventType.value,
                    updateValidated: this.updateValidated.bind(this),
                });
                if (this.videoAlreadyOn.value) {
                    await this.clickVideo.clickVideo({
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                }
                if (this.audioAlreadyOn.value) {
                    await this.clickAudio.clickAudio({
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                }
                await this.closeAndReset();
            });
            this.socket.value.on('disconnectUserSelf', async () => {
                await this.disconnectUserSelf.disconnectUserSelf({
                    socket: this.socket.value,
                    member: this.member.value,
                    roomName: this.roomName.value,
                });
            });
            this.socket.value.on('receiveMessage', async ({ message }) => {
                await this.receiveMessage.receiveMessage({
                    message,
                    messages: this.messages.value,
                    participantsAll: this.participantsAll.value,
                    member: this.member.value,
                    eventType: this.eventType.value,
                    islevel: this.islevel.value,
                    coHost: this.coHost.value,
                    updateMessages: this.updateMessages.bind(this),
                    updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
                });
            });
            this.socket.value.on('meetingTimeRemaining', async ({ timeRemaining }) => {
                await this.meetingTimeRemaining.meetingTimeRemaining({
                    timeRemaining,
                    showAlert: this.showAlert.bind(this),
                    eventType: this.eventType.value,
                });
            });
            this.socket.value.on('meetingStillThere', async () => {
                this.meetingStillThere.meetingStillThere({
                    updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
                });
            });
            this.socket.value.on('updateConsumingDomains', async ({ domains, alt_domains }) => {
                await this.updateConsumingDomains.updateConsumingDomains({
                    domains,
                    alt_domains,
                    apiUserName,
                    apiKey,
                    apiToken,
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                    },
                });
            });
            await this.join_Room({
                socket: this.socket.value,
                roomName: this.roomName.value,
                islevel: this.islevel.value,
                member: this.member.value,
                sec: this.apiToken.value,
                apiUserName: this.apiUserName.value,
            });
            await this.receiveRoomMessages.receiveRoomMessages({
                socket: this.socket.value,
                roomName: this.roomName.value,
                updateMessages: this.updateMessages.bind(this),
            });
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            return this.socket.value;
        }
        else {
            return null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediasfuChat, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.Injector }, { token: UpdateMiniCardsGrid }, { token: MixStreams }, { token: DispStreams }, { token: StopShareScreen }, { token: CheckScreenShare }, { token: StartShareScreen }, { token: RequestScreenShare }, { token: ReorderStreams }, { token: PrepopulateUserMedia }, { token: GetVideos }, { token: RePort }, { token: Trigger }, { token: ConsumerResume }, { token: ConnectSendTransport }, { token: ConnectSendTransportAudio }, { token: ConnectSendTransportVideo }, { token: ConnectSendTransportScreen }, { token: ProcessConsumerTransports }, { token: ResumePauseStreams }, { token: Readjust }, { token: CheckGrid }, { token: GetEstimate }, { token: CalculateRowsAndColumns }, { token: AddVideosGrid }, { token: OnScreenChanges }, { token: ChangeVids }, { token: CompareActiveNames }, { token: CompareScreenStates }, { token: CreateSendTransport }, { token: ResumeSendTransportAudio }, { token: ReceiveAllPipedTransports }, { token: DisconnectSendTransportVideo }, { token: DisconnectSendTransportAudio }, { token: DisconnectSendTransportScreen }, { token: GetPipedProducersAlt }, { token: SignalNewConsumerTransport }, { token: ConnectRecvTransport }, { token: ReUpdateInter }, { token: UpdateParticipantAudioDecibels }, { token: CloseAndResize }, { token: AutoAdjust }, { token: SwitchUserVideoAlt }, { token: SwitchUserVideo }, { token: SwitchUserAudio }, { token: GetDomains }, { token: FormatNumber }, { token: ConnectIps }, { token: CreateDeviceClient }, { token: CaptureCanvasStream }, { token: ResumePauseAudioStreams }, { token: ProcessConsumerTransportsAudio }, { token: LaunchMessages }, { token: LaunchConfirmExit }, { token: StartMeetingProgressTimer }, { token: ProducerMediaPaused }, { token: ProducerMediaResumed }, { token: ProducerMediaClosed }, { token: MeetingEnded }, { token: DisconnectUserSelf }, { token: ReceiveMessage }, { token: MeetingTimeRemaining }, { token: MeetingStillThere }, { token: AllMembers }, { token: AllMembersRest }, { token: Disconnect }, { token: SocketManager }, { token: JoinRoomClient }, { token: UpdateRoomParametersClient }, { token: ClickVideo }, { token: ClickAudio }, { token: ClickScreenShare }, { token: SwitchVideoAlt }, { token: StreamSuccessVideo }, { token: StreamSuccessAudio }, { token: StreamSuccessScreen }, { token: StreamSuccessAudioSwitch }, { token: CheckPermission }, { token: UpdateConsumingDomains }, { token: ReceiveRoomMessages }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MediasfuChat, isStandalone: true, selector: "app-mediasfu-chat", inputs: { PrejoinPage: "PrejoinPage", credentials: "credentials", useLocalUIMode: "useLocalUIMode", seedData: "seedData", useSeed: "useSeed", imgSrc: "imgSrc" }, host: { listeners: { "window:resize": "handleResize()", "window:orientationchange": "handleResize()" } }, providers: [CookieService], ngImport: i0, template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component>
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <!-- MainGridComponent removed -->

              <!-- OtherGridComponent -->
              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <!-- AudioGrid -->
                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <!-- Control Buttons for Chat -->
                <app-control-buttons-component-touch
                  [buttons]="controlChatButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'chat'"
                ></app-control-buttons-component-touch>

                <!-- Flexible Grid -->
                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <!-- SubAspectComponent removed -->
        </app-main-container-component>
      </ng-template>

      <!-- Modals to include -->
      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
      ></app-share-event-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: AlertComponent, selector: "app-alert-component", inputs: ["visible", "message", "type", "duration", "textColor", "onHide"] }, { kind: "component", type: AudioGrid, selector: "app-audio-grid", inputs: ["componentsToRender"] }, { kind: "component", type: ControlButtonsComponentTouch, selector: "app-control-buttons-component-touch", inputs: ["buttons", "position", "location", "direction", "buttonsContainerStyle", "showAspect"] }, { kind: "component", type: FlexibleGrid, selector: "app-flexible-grid", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "backgroundColor"] }, { kind: "component", type: LoadingModal, selector: "app-loading-modal", inputs: ["isVisible", "backgroundColor", "displayColor"] }, { kind: "component", type: ConfirmExitModal, selector: "app-confirm-exit-modal", inputs: ["isConfirmExitModalVisible", "onConfirmExitClose", "position", "backgroundColor", "exitEventOnConfirm", "member", "ban", "roomName", "socket", "islevel"] }, { kind: "component", type: MessagesModal, selector: "app-messages-modal", inputs: ["isMessagesModalVisible", "onMessagesClose", "onSendMessagePress", "messages", "position", "backgroundColor", "activeTabBackgroundColor", "eventType", "member", "islevel", "coHostResponsibility", "coHost", "startDirectMessage", "directMessageDetails", "updateStartDirectMessage", "updateDirectMessageDetails", "showAlert", "roomName", "socket", "chatSetting"] }, { kind: "component", type: ConfirmHereModal, selector: "app-confirm-here-modal", inputs: ["isConfirmHereModalVisible", "position", "backgroundColor", "displayColor", "onConfirmHereClose", "countdownDuration", "socket", "roomName", "member"] }, { kind: "component", type: ShareEventModal, selector: "app-share-event-modal", inputs: ["backgroundColor", "isShareEventModalVisible", "onShareEventClose", "roomName", "adminPasscode", "islevel", "position", "shareButtons", "eventType"] }, { kind: "component", type: MainAspectComponent, selector: "app-main-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "updateIsWideScreen", "updateIsMediumScreen", "updateIsSmallScreen"] }, { kind: "component", type: MainContainerComponent, selector: "app-main-container-component", inputs: ["backgroundColor", "containerWidthFraction", "containerHeightFraction", "marginLeft", "marginRight", "marginTop", "marginBottom", "padding"] }, { kind: "component", type: MainScreenComponent, selector: "app-main-screen-component", inputs: ["mainSize", "doStack", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "showControls", "updateComponentSizes"] }, { kind: "component", type: OtherGridComponent, selector: "app-other-grid-component", inputs: ["backgroundColor", "width", "height", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MediasfuChat, decorators: [{
            type: Component,
            args: [{ selector: 'app-mediasfu-chat', standalone: true, imports: [
                        RouterOutlet,
                        CommonModule,
                        AlertComponent,
                        AudioGrid,
                        ControlButtonsComponentTouch,
                        FlexibleGrid,
                        LoadingModal,
                        ConfirmExitModal,
                        MessagesModal,
                        ConfirmHereModal,
                        ShareEventModal,
                        WelcomePage,
                        MainAspectComponent,
                        MainContainerComponent,
                        MainScreenComponent,
                        OtherGridComponent,
                        MessageWidget,
                    ], template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component>
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <!-- MainGridComponent removed -->

              <!-- OtherGridComponent -->
              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <!-- AudioGrid -->
                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <!-- Control Buttons for Chat -->
                <app-control-buttons-component-touch
                  [buttons]="controlChatButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'chat'"
                ></app-control-buttons-component-touch>

                <!-- Flexible Grid -->
                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <!-- SubAspectComponent removed -->
        </app-main-container-component>
      </ng-template>

      <!-- Modals to include -->
      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
      ></app-share-event-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </div>
  `, providers: [CookieService] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: UpdateMiniCardsGrid }, { type: MixStreams }, { type: DispStreams }, { type: StopShareScreen }, { type: CheckScreenShare }, { type: StartShareScreen }, { type: RequestScreenShare }, { type: ReorderStreams }, { type: PrepopulateUserMedia }, { type: GetVideos }, { type: RePort }, { type: Trigger }, { type: ConsumerResume }, { type: ConnectSendTransport }, { type: ConnectSendTransportAudio }, { type: ConnectSendTransportVideo }, { type: ConnectSendTransportScreen }, { type: ProcessConsumerTransports }, { type: ResumePauseStreams }, { type: Readjust }, { type: CheckGrid }, { type: GetEstimate }, { type: CalculateRowsAndColumns }, { type: AddVideosGrid }, { type: OnScreenChanges }, { type: ChangeVids }, { type: CompareActiveNames }, { type: CompareScreenStates }, { type: CreateSendTransport }, { type: ResumeSendTransportAudio }, { type: ReceiveAllPipedTransports }, { type: DisconnectSendTransportVideo }, { type: DisconnectSendTransportAudio }, { type: DisconnectSendTransportScreen }, { type: GetPipedProducersAlt }, { type: SignalNewConsumerTransport }, { type: ConnectRecvTransport }, { type: ReUpdateInter }, { type: UpdateParticipantAudioDecibels }, { type: CloseAndResize }, { type: AutoAdjust }, { type: SwitchUserVideoAlt }, { type: SwitchUserVideo }, { type: SwitchUserAudio }, { type: GetDomains }, { type: FormatNumber }, { type: ConnectIps }, { type: CreateDeviceClient }, { type: CaptureCanvasStream }, { type: ResumePauseAudioStreams }, { type: ProcessConsumerTransportsAudio }, { type: LaunchMessages }, { type: LaunchConfirmExit }, { type: StartMeetingProgressTimer }, { type: ProducerMediaPaused }, { type: ProducerMediaResumed }, { type: ProducerMediaClosed }, { type: MeetingEnded }, { type: DisconnectUserSelf }, { type: ReceiveMessage }, { type: MeetingTimeRemaining }, { type: MeetingStillThere }, { type: AllMembers }, { type: AllMembersRest }, { type: Disconnect }, { type: SocketManager }, { type: JoinRoomClient }, { type: UpdateRoomParametersClient }, { type: ClickVideo }, { type: ClickAudio }, { type: ClickScreenShare }, { type: SwitchVideoAlt }, { type: StreamSuccessVideo }, { type: StreamSuccessAudio }, { type: StreamSuccessScreen }, { type: StreamSuccessAudioSwitch }, { type: CheckPermission }, { type: UpdateConsumingDomains }, { type: ReceiveRoomMessages }], propDecorators: { PrejoinPage: [{
                type: Input
            }], credentials: [{
                type: Input
            }], useLocalUIMode: [{
                type: Input
            }], seedData: [{
                type: Input
            }], useSeed: [{
                type: Input
            }], imgSrc: [{
                type: Input
            }], handleResize: [{
                type: HostListener,
                args: ['window:resize']
            }, {
                type: HostListener,
                args: ['window:orientationchange']
            }] } });

class GenerateRandomParticipants {
    /**
     * Generates a list of random participants with specified options.
     *
     * @param {Object} options - The options for generating participants.
     * @param {string} options.member - The member to include in the participants list.
     * @param {string} [options.coHost=""] - The co-host to include in the participants list.
     * @param {string} options.host - The host to include in the participants list.
     * @param {boolean} [options.forChatBroadcast=false] - Whether the participants are for a chat broadcast.
     * @returns {Participant[]} An array of generated participants.
     */
    generateRandomParticipants({ member, coHost = '', host, forChatBroadcast = false, }) {
        const participants = [];
        let names = [
            'Alice',
            'Bob',
            'Charlie',
            'David',
            'Eve',
            'Frank',
            'Grace',
            'Hank',
            'Ivy',
            'Jack',
            'Kate',
            'Liam',
            'Mia',
            'Nina',
            'Olivia',
            'Pete',
            'Quinn',
            'Rachel',
            'Steve',
            'Tina',
            'Ursula',
            'Vince',
            'Wendy',
            'Xander',
            'Yvonne',
            'Zack',
        ];
        // Limit names to 2 for chat broadcast
        if (forChatBroadcast) {
            names.splice(2);
        }
        // Place member, coHost, and host at the beginning if not already included
        if (!names.includes(member)) {
            names.unshift(member);
        }
        if (!names.includes(coHost) && !forChatBroadcast) {
            names.unshift(coHost);
        }
        if (!names.includes(host)) {
            names.unshift(host);
        }
        // Limit names to 2 for chat broadcast
        if (forChatBroadcast) {
            names.splice(2);
        }
        // Remove names of length 1 or less
        names = names.filter((name) => name.length > 1);
        // Shuffle the names array to ensure unique names for each participant
        const shuffledNames = [...names];
        for (let i = shuffledNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledNames[i], shuffledNames[j]] = [shuffledNames[j], shuffledNames[i]];
        }
        let hasLevel2Participant = false;
        // Generate participant objects
        for (let i = 0; i < shuffledNames.length; i++) {
            const randomName = shuffledNames[i];
            const randomLevel = hasLevel2Participant ? '1' : randomName == host ? '2' : '1'; // Set islevel to '2' only once
            const randomMuted = forChatBroadcast ? true : Math.random() < 0.5; // Set muted to false for chat broadcast
            if (randomLevel === '2') {
                hasLevel2Participant = true;
            }
            participants.push({
                name: randomName,
                islevel: randomLevel,
                muted: randomMuted,
                id: i.toString(),
                audioID: `audio-${i}`,
                videoID: `video-${i}`,
            });
        }
        return participants;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomParticipants, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomParticipants, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomParticipants, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class GenerateRandomMessages {
    /**
     * Generates random messages for a given set of participants.
     *
     * @param {Object} options - The options for generating random messages.
     * @param {Array} options.participants - The list of participants.
     * @param {string} options.member - The member who is part of the chat.
     * @param {string} [options.coHost=""] - The co-host of the chat.
     * @param {string} options.host - The host of the chat.
     * @param {boolean} [options.forChatBroadcast=false] - Flag to indicate if the messages are for chat broadcast.
     * @returns {Message[]} An array of generated messages.
     */
    generateRandomMessages({ participants, member, coHost = '', host, forChatBroadcast = false, }) {
        const messages = [];
        // Function to get a random participant other than the sender
        const getRandomReceiver = (sender) => {
            const potentialReceivers = participants.filter((participant) => participant.name !== sender);
            const randomReceiver = potentialReceivers[Math.floor(Math.random() * potentialReceivers.length)];
            return randomReceiver.name || '';
        };
        // Force add messages for specific participants
        let refNames = [];
        if (forChatBroadcast) {
            refNames = [member, host];
        }
        else {
            if (coHost) {
                refNames = [
                    member,
                    coHost,
                    host,
                    ...participants
                        .map((participant) => participant.name)
                        .filter((name) => name !== undefined),
                ];
            }
            else {
                refNames = [
                    member,
                    host,
                    ...participants
                        .map((participant) => participant.name)
                        .filter((name) => name !== undefined),
                ];
            }
        }
        // Return unique names for the refNames
        refNames = [...new Set(refNames)];
        // Generate messages
        let timeIncrement = 0;
        refNames.forEach((sender) => {
            // Send direct messages
            const directMessage = {
                sender: sender,
                receivers: [getRandomReceiver(sender)],
                message: `Direct message from ${sender}`,
                timestamp: new Date(Date.now() + timeIncrement).toLocaleTimeString(),
                group: false,
            };
            messages.push(directMessage);
            // Send group messages
            const groupMessage = {
                sender: sender,
                receivers: participants
                    .map((participant) => participant.name)
                    .filter((name) => name !== undefined),
                message: `Group message from ${sender}`,
                timestamp: new Date(Date.now() + timeIncrement).toLocaleTimeString(),
                group: true,
            };
            messages.push(groupMessage);
            timeIncrement += 15000; // Increment time by 15 seconds for each message
        });
        return messages;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomMessages, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomMessages, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomMessages, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class GenerateRandomRequestList {
    /**
     * Generates a list of random requests for participants, excluding the host and co-host.
     *
     * @param {GenerateRandomRequestListOptions} options - The options for generating the request list.
     * @param {Participant[]} options.participants - The list of participants.
     * @param {string} options.hostName - The name of the host.
     * @param {string} options.coHostName - The name of the co-host.
     * @param {number} options.numberOfRequests - The number of requests to generate for each participant.
     * @returns {Request[]} The generated list of requests.
     */
    generateRandomRequestList({ participants, hostName, coHostName, numberOfRequests, }) {
        // Filter out the host and co-host from the participants
        const filteredParticipants = participants.filter((participant) => participant.name !== hostName && participant.name !== coHostName);
        // Create an array with three possible request icons
        const requestIcons = ['fa-video', 'fa-desktop', 'fa-microphone'];
        // Shuffle the request icons array to ensure unique icons for each participant and randomly select a minimum of 1 and a maximum of 3 icons
        for (let i = requestIcons.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [requestIcons[i], requestIcons[j]] = [requestIcons[j], requestIcons[i]];
        }
        // Generate unique requests for each participant with unique icons
        const requestList = filteredParticipants.flatMap((participant) => {
            const uniqueIcons = new Set(); // To ensure unique icons for each participant
            const requests = [];
            for (let i = 0; i < numberOfRequests; i++) {
                let randomIcon;
                do {
                    randomIcon = requestIcons[Math.floor(Math.random() * requestIcons.length)];
                } while (uniqueIcons.has(randomIcon));
                uniqueIcons.add(randomIcon);
                requests.push({
                    id: participant.id || '',
                    name: participant.name.toLowerCase().replace(/\s/g, '_'),
                    icon: randomIcon,
                    username: participant.name.toLowerCase().replace(/\s/g, '_'),
                });
            }
            return requests;
        });
        return requestList;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomRequestList, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomRequestList, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomRequestList, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class GenerateRandomWaitingRoomList {
    /**
     * Generates a random list of participants for a waiting room.
     *
     * @param options - Configuration options for generating the waiting room list.
     * @returns An array of `WaitingRoomParticipant` objects, each with a random name, mute status, and unique ID.
     *
     * @example
     * const options = {};
     * const waitingRoomList = generateRandomWaitingRoomList(options);
     * console.log(waitingRoomList);
     */
    generateRandomWaitingRoomList() {
        // Array of random names to assign to participants in the waiting room
        const names = ['Dimen', 'Nore', 'Ker', 'Lor', 'Mik'];
        // Loop through the names array and add participants to the waiting room list
        const waitingRoomList = [];
        for (let i = 0; i < names.length; i++) {
            const randomName = names[i];
            waitingRoomList.push({
                name: randomName,
                id: i.toString(),
            });
        }
        return waitingRoomList;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomWaitingRoomList, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomWaitingRoomList, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomWaitingRoomList, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class GenerateRandomPolls {
    /**
     * Generates an array of random poll objects.
     *
     * @param {GenerateRandomPollsOptions} options - An object containing the number of polls to generate.
     * @param {number} options.numberOfPolls - The number of random polls to generate.
     * @returns {Poll[]} An array of random poll objects.
     */
    generateRandomPolls({ numberOfPolls }) {
        const pollTypes = ['trueFalse', 'yesNo', 'custom'];
        const polls = [];
        for (let i = 0; i < numberOfPolls; i++) {
            const type = pollTypes[Math.floor(Math.random() * pollTypes.length)];
            let options;
            switch (type) {
                case 'trueFalse':
                    options = ['True', 'False'];
                    break;
                case 'yesNo':
                    options = ['Yes', 'No'];
                    break;
                case 'custom':
                    options = Array.from({ length: Math.floor(Math.random() * 5) + 2 }, (_, idx) => `Option ${idx + 1}`);
                    break;
                default:
                    options = [];
            }
            const poll = {
                id: `${i + 1}`,
                question: `Random Question ${i + 1}`,
                type,
                options,
                votes: Array(options.length).fill(0),
                status: 'inactive', // or 'active'
                voters: {},
            };
            polls.push(poll);
        }
        return polls;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomPolls, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomPolls, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: GenerateRandomPolls, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * MiniCardAudio component displays an audio card with optional waveform animation.
 *
 * @component
 * @selector app-mini-card-audio
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * The template includes:
 * - A card container with customizable styles.
 * - An optional background image.
 * - An overlay with the name and waveform animation.
 *
 * @styles
 * The styles include:
 * - Card dimensions and background color.
 * - Overlay positioning and grid layout.
 * - Name column styling.
 * - Waveform bar styling.
 * - Background image positioning and optional rounded corners.
 *
 * @inputs
 * @param {any} customStyle - Custom styles for the card.
 * @param {string} name - The name to display on the card.
 * @param {boolean} showWaveform - Flag to show or hide the waveform animation.
 * @param {string} overlayPosition - Position of the overlay on the card.
 * @param {string} barColor - Color of the waveform bars.
 * @param {string} textColor - Color of the name text.
 * @param {string} imageSource - Source URL for the background image.
 * @param {boolean} roundedImage - Flag to apply rounded corners to the background image.
 * @param {any} imageStyle - Custom styles for the background image.
 *
 * @class
 * @implements OnInit, OnDestroy
 *
 * @constructor
 * @param {Partial<CSSStyleDeclaration>} injectedCustomStyle - Injected custom styles for the card.
 * @param {string} injectedName - Injected name to display on the card.
 * @param {boolean} injectedShowWaveform - Injected flag to show or hide the waveform animation.
 * @param {string} injectedOverlayPosition - Injected position of the overlay on the card.
 * @param {string} injectedBarColor - Injected color of the waveform bars.
 * @param {string} injectedTextColor - Injected color of the name text.
 * @param {string} injectedImageSource - Injected source URL for the background image.
 * @param {boolean} injectedRoundedImage - Injected flag to apply rounded corners to the background image.
 * @param {Partial<CSSStyleDeclaration>} injectedImageStyle - Injected custom styles for the background image.
 *
 * @methods
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnDestroy - Lifecycle hook that is called just before the component is destroyed.
 * @method animateWaveform - Starts the waveform animation.
 * @method resetWaveform - Resets the waveform animation.
 * @method clearIntervals - Clears all animation intervals.
 * @method getAnimationDuration - Returns the animation duration for a given index.
 * @method getImageStyle - Returns the styles for the background image.
 * @method getOverlayPosition - Returns the styles for the overlay position.
 */
class MiniCardAudio {
    customStyle;
    name = '';
    showWaveform = false;
    overlayPosition = 'bottomLeft';
    barColor = 'white';
    textColor = 'white';
    imageSource = '';
    roundedImage = false;
    imageStyle = {};
    waveformAnimations = Array.from({ length: 9 }, () => 0);
    intervals = [];
    constructor(injectedCustomStyle, injectedName, injectedShowWaveform, injectedOverlayPosition, injectedBarColor, injectedTextColor, injectedImageSource, injectedRoundedImage, injectedImageStyle) {
        // Use injected values if available
        this.customStyle = injectedCustomStyle || this.customStyle;
        this.name = injectedName || this.name;
        this.showWaveform = injectedShowWaveform || this.showWaveform;
        this.overlayPosition = injectedOverlayPosition || this.overlayPosition;
        this.barColor = injectedBarColor || this.barColor;
        this.textColor = injectedTextColor || this.textColor;
        this.imageSource = injectedImageSource || this.imageSource;
        this.roundedImage = injectedRoundedImage || this.roundedImage;
        this.imageStyle = injectedImageStyle || this.imageStyle;
    }
    ngOnInit() {
        if (this.showWaveform) {
            this.animateWaveform();
        }
        else {
            this.resetWaveform();
        }
    }
    ngOnDestroy() {
        this.clearIntervals();
    }
    animateWaveform() {
        this.intervals = this.waveformAnimations.map((_, index) => setInterval(() => {
            this.waveformAnimations[index] = (this.waveformAnimations[index] + 1) % 2;
        }, this.getAnimationDuration(index)));
    }
    resetWaveform() {
        this.waveformAnimations.fill(0);
    }
    clearIntervals() {
        this.intervals.forEach((interval) => clearInterval(interval));
    }
    getAnimationDuration(index) {
        const durations = [474, 433, 407, 458, 400, 427, 441, 419, 487];
        return durations[index] || 0;
    }
    getImageStyle() {
        return {
            ...this.imageStyle,
            ...(this.roundedImage ? { borderRadius: '20%' } : {}),
        };
    }
    getOverlayPosition(position) {
        return getOverlayPosition({ position });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MiniCardAudio, deps: [{ token: 'customStyle', optional: true }, { token: 'name', optional: true }, { token: 'showWaveform', optional: true }, { token: 'overlayPosition', optional: true }, { token: 'barColor', optional: true }, { token: 'textColor', optional: true }, { token: 'imageSource', optional: true }, { token: 'roundedImage', optional: true }, { token: 'imageStyle', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.8", type: MiniCardAudio, isStandalone: true, selector: "app-mini-card-audio", inputs: { customStyle: "customStyle", name: "name", showWaveform: "showWaveform", overlayPosition: "overlayPosition", barColor: "barColor", textColor: "textColor", imageSource: "imageSource", roundedImage: "roundedImage", imageStyle: "imageStyle" }, ngImport: i0, template: `
    <div class="card" [ngStyle]="customStyle">
      <img *ngIf="imageSource" [src]="imageSource" [ngStyle]="getImageStyle()" alt="Background" />
      <div [ngStyle]="getOverlayPosition(overlayPosition)" [class.overlay-web]="true">
        <div class="name-column">
          <span class="name-text" [ngStyle]="{ color: textColor }">{{ name }}</span>
        </div>
        <div [class.waveform-web]="true">
          <div
            *ngFor="let animation of waveformAnimations"
            [ngStyle]="{
              height: animation === 0 ? '1px' : '16px',
              backgroundColor: barColor
            }"
            class="bar"
          ></div>
        </div>
      </div>
    </div>
  `, isInline: true, styles: [".card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f}.overlay-web{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.name-column{display:flex;justify-content:center;align-items:center;background-color:#00000080;padding:5px 10px;margin-right:2px;font-size:14px}.name-text{font-size:14px;color:#fff}.waveform-web{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin:0 1px}.background-image{position:absolute;width:80px;height:80px;display:flex;justify-content:center;align-items:center;top:50%;left:50%;transform:translate(-40px,-40px)}.rounded-image{border-radius:20%}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.8", ngImport: i0, type: MiniCardAudio, decorators: [{
            type: Component,
            args: [{ selector: 'app-mini-card-audio', standalone: true, imports: [CommonModule], template: `
    <div class="card" [ngStyle]="customStyle">
      <img *ngIf="imageSource" [src]="imageSource" [ngStyle]="getImageStyle()" alt="Background" />
      <div [ngStyle]="getOverlayPosition(overlayPosition)" [class.overlay-web]="true">
        <div class="name-column">
          <span class="name-text" [ngStyle]="{ color: textColor }">{{ name }}</span>
        </div>
        <div [class.waveform-web]="true">
          <div
            *ngFor="let animation of waveformAnimations"
            [ngStyle]="{
              height: animation === 0 ? '1px' : '16px',
              backgroundColor: barColor
            }"
            class="bar"
          ></div>
        </div>
      </div>
    </div>
  `, styles: [".card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f}.overlay-web{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.name-column{display:flex;justify-content:center;align-items:center;background-color:#00000080;padding:5px 10px;margin-right:2px;font-size:14px}.name-text{font-size:14px;color:#fff}.waveform-web{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin:0 1px}.background-image{position:absolute;width:80px;height:80px;display:flex;justify-content:center;align-items:center;top:50%;left:50%;transform:translate(-40px,-40px)}.rounded-image{border-radius:20%}\n"] }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['name']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showWaveform']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['overlayPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['barColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['textColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageSource']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['roundedImage']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageStyle']
                }] }], propDecorators: { customStyle: [{
                type: Input
            }], name: [{
                type: Input
            }], showWaveform: [{
                type: Input
            }], overlayPosition: [{
                type: Input
            }], barColor: [{
                type: Input
            }], textColor: [{
                type: Input
            }], imageSource: [{
                type: Input
            }], roundedImage: [{
                type: Input
            }], imageStyle: [{
                type: Input
            }] } });

//initial values

/**
 * Generated bundle index. Do not edit.
 */

export { AddVideosGrid, AlertComponent, AllMembers, AllMembersRest, AllWaitingRoomMembers, AudioCard, AudioGrid, AutoAdjust, BackgroundModal, BanParticipant, BreakoutRoomUpdated, BreakoutRoomsModal, CalculateRowsAndColumns, CaptureCanvasStream, CardVideoDisplay, ChangeVids, CheckGrid, CheckPermission, CheckScreenShare, ClickAudio, ClickScreenShare, ClickVideo, CloseAndResize, CoHostModal, CompareActiveNames, CompareScreenStates, ConfigureWhiteboardModal, ConfirmExitModal, ConfirmHereModal, ConfirmRecording, ConnectIps, ConnectRecvTransport, ConnectSendTransport, ConnectSendTransportAudio, ConnectSendTransportScreen, ConnectSendTransportVideo, ConsumerResume, ControlButtonsAltComponent, ControlButtonsComponent, ControlButtonsComponentTouch, ControlMediaHost, CreateDeviceClient, CreateSendTransport, Disconnect, DisconnectSendTransportAudio, DisconnectSendTransportScreen, DisconnectSendTransportVideo, DisconnectUserSelf, DispStreams, DisplaySettingsModal, EventSettingsModal, FlexibleGrid, FlexibleVideo, FormatNumber, GenerateRandomMessages, GenerateRandomParticipants, GenerateRandomPolls, GenerateRandomRequestList, GenerateRandomWaitingRoomList, GetDomains, GetEstimate, GetPipedProducersAlt, GetVideos, HandleCreatePoll, HandleEndPoll, HandleVotePoll, HostRequestResponse, JoinRoomClient, LaunchBackground, LaunchBreakoutRooms, LaunchConfigureWhiteboard, LaunchConfirmExit, LaunchDisplaySettings, LaunchMediaSettings, LaunchMenuModal, LaunchMessages, LaunchParticipants, LaunchPoll, LaunchRecording, LaunchRequests, LaunchSettings, LaunchWaiting, LoadingModal, MainAspectComponent, MainContainerComponent, MainGridComponent, MainScreenComponent, MediaSettingsModal, MediasfuBroadcast, MediasfuChat, MediasfuConference, MediasfuGeneric, MediasfuWebinar, MeetingEnded, MeetingProgressTimer, MeetingStillThere, MeetingTimeRemaining, MenuModal, MessagesModal, MiniAudio, MiniAudioPlayer, MiniCard, MiniCardAudio, MixStreams, NewPipeProducer, OnScreenChanges, OtherGridComponent, Pagination, ParticipantRequested, ParticipantsModal, PersonJoined, PollModal, PollUpdated, PreJoinPage, PrepopulateUserMedia, ProcessConsumerTransports, ProcessConsumerTransportsAudio, ProducerClosed, ProducerMediaClosed, ProducerMediaPaused, ProducerMediaResumed, ReInitiateRecording, RePort, ReUpdateInter, Readjust, ReceiveAllPipedTransports, ReceiveMessage, ReceiveRoomMessages, RecordingModal, RecordingNotice, ReorderStreams, RequestScreenShare, RequestsModal, ResumePauseAudioStreams, ResumePauseStreams, ResumeSendTransportAudio, RoomRecordParams, ScreenProducerId, Screenboard, ScreenboardModal, ShareEventModal, SignalNewConsumerTransport, SocketManager, SoundPlayer, StartMeetingProgressTimer, StartRecording, StartRecords, StartShareScreen, StopRecording, StopShareScreen, StoppedRecording, StreamSuccessAudio, StreamSuccessAudioSwitch, StreamSuccessScreen, StreamSuccessVideo, SubAspectComponent, SwitchUserAudio, SwitchUserVideo, SwitchUserVideoAlt, TimeLeftRecording, Trigger, UpdateConsumingDomains, UpdateMediaSettings, UpdateMiniCardsGrid, UpdateParticipantAudioDecibels, UpdateRecording, UpdateRoomParametersClient, UpdatedCoHost, UserWaiting, VideoCard, WaitingRoomModal, WelcomePage, Whiteboard, initialValuesState, launchCoHost, sleep };
//# sourceMappingURL=mediasfu-angular.mjs.map
