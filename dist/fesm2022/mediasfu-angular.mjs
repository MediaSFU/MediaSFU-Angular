import * as i0 from '@angular/core';
import { Injectable, Component, Optional, Inject, Input, ViewChild, HostListener, Injector, EventEmitter, Output, ContentChildren, ViewEncapsulation } from '@angular/core';
import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i2 from '@fortawesome/angular-fontawesome';
import { FontAwesomeModule } from '@fortawesome/angular-fontawesome';
import { faMicrophone, faMicrophoneSlash, faVideo, faVideoSlash, faTimes, faPen, faUsers, faPlus, faDoorOpen, faRandom, faHandPointer, faSave, faPlay, faSyncAlt, faStop, faStar, faLock, faCamera, faPhotoFilm, faSpinner, faCopy, faEnvelope, faBars, faPaperPlane, faReply, faQrcode, faComment, faTrash, faDotCircle, faCircle, faCheck, faDesktop, faComments, faChevronRight, faChevronLeft, faPencilAlt, faPaintBrush, faShapes, faEraser, faSearch, faSearchPlus, faSearchMinus, faFont, faTextHeight, faUndo, faRedo, faMousePointer, faHandPaper, faUpload, faBan, faRecordVinyl, faPlayCircle, faPauseCircle, faStopCircle, faCog, faClock, faUserPlus, faTools, faPoll, faUserFriends, faChalkboardTeacher, faSync, faPhone, faShareAlt, faChartBar } from '@fortawesome/free-solid-svg-icons';
import io, { Socket } from 'socket.io-client';
import * as i2$1 from 'mediasoup-client/lib/types';
import * as mediasoupClient from 'mediasoup-client';
import * as i1$1 from 'ngx-cookie-service';
import { CookieService } from 'ngx-cookie-service';
import { SelfieSegmentation } from '@mediapipe/selfie_segmentation';
import * as i2$2 from '@angular/forms';
import { FormsModule, Validators, ReactiveFormsModule } from '@angular/forms';
import { faFacebook, faWhatsapp, faTelegram } from '@fortawesome/free-brands-svg-icons';
import { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';
import * as i3 from '@zxing/ngx-scanner';
import { ZXingScannerModule } from '@zxing/ngx-scanner';
import { BehaviorSubject as BehaviorSubject$1, combineLatest } from 'rxjs';

/**
 * Service to validate if a given string contains only alphanumeric characters.
 *
 * @class ValidateAlphanumeric
 *
 * @example
 * ```typescript
 * const validator = new ValidateAlphanumeric();
 * validator.validateAlphanumeric({ str: 'abc123' }).then(isValid => console.log(isValid)); // true
 * validator.validateAlphanumeric({ str: 'abc 123!' }).then(isValid => console.log(isValid)); // false
 * ```
 *
 * @param {ValidateAlphanumericOptions} options - Contains the string to validate.
 * @param {string} options.str - The input string that needs to be validated.
 * @returns {Promise<boolean>} - A promise resolving to `true` if the input string is alphanumeric, otherwise `false`.
 */
class ValidateAlphanumeric {
    /**
     * Validates if the given string contains only alphanumeric characters.
     *
     * @param {ValidateAlphanumericOptions} options - The options containing the string to validate.
     * @param {string} options.str - The string to be validated.
     * @returns {Promise<boolean>} - A promise that resolves to `true` if the string is alphanumeric, otherwise `false`.
     */
    async validateAlphanumeric({ str }) {
        let code, i, len;
        for (i = 0, len = str.length; i < len; i++) {
            code = str.charCodeAt(i);
            if (!(code > 47 && code < 58) && // numeric (0-9)
                !(code > 64 && code < 91) && // upper alpha (A-Z)
                !(code > 96 && code < 123)) {
                // lower alpha (a-z)
                return false;
            }
        }
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ValidateAlphanumeric, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ValidateAlphanumeric, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ValidateAlphanumeric, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Joins a conference room with the provided options and performs validation checks.
 *
 * @param {JoinConRoomOptions} options - Contains:
 *   - socket: Socket instance for communication.
 *   - roomName: Name of the room to join.
 *   - islevel: User level within the room.
 *   - member: Member identifier.
 *   - sec: Security token.
 *   - apiUserName: API username for authentication.
 *
 * - **Validation**:
 *   - Checks that `roomName`, `apiUserName`, and `member` are alphanumeric.
 *   - Ensures `roomName` starts with 's' or 'p' and meets length requirements.
 *   - Verifies `sec`, `islevel`, and `apiUserName` comply with length and format expectations.
 *
 * - **Response Handling**:
 *   - Resolves to the server's response data upon a successful join.
 *   - Rejects with specific reasons if the user is banned, suspended, or if the room host is not present.
 *
 * @returns {Promise<JoinConRoomResponse>} Resolves with the join response data, or rejects with error details.
 * @throws {Error} Throws validation errors or issues encountered while joining the room.
 *
 * @example
 * ```typescript
 * const joinOptions = {
 *   socket: mySocket,
 *   roomName: 'sMyRoom',
 *   islevel: '1',
 *   member: 'participant123',
 *   sec: '64-character-long-secret-key-here...',
 *   apiUserName: 'apiUser123',
 * };
 * joinConRoom(joinOptions)
 *   .then(response => console.log('Joined room:', response))
 *   .catch(error => console.error('Failed to join room:', error));
 * ```
 */
class JoinConRoom {
    validateAlphanumeric;
    constructor(validateAlphanumeric) {
        this.validateAlphanumeric = validateAlphanumeric;
    }
    /**
     * Joins a conference room using the provided options.
     *
     * @param {JoinConRoomOptions} options - The options for joining the conference room.
     * @param {Socket} options.socket - The socket instance to use for communication.
     * @param {string} options.roomName - The name of the room to join.
     * @param {string} options.islevel - The level of the user.
     * @param {string} options.member - The member identifier.
     * @param {string} options.sec - The security token.
     * @param {string} options.apiUserName - The API username.
     * @returns {Promise<JoinConRoomResponse>} A promise that resolves with the response of the join operation.
     *
     * @throws {Error} If any of the required parameters are missing or invalid.
     * @throws {Error} If the user is banned, suspended, or if the host has not joined the room yet.
     */
    async joinConRoom({ socket, roomName, islevel, member, sec, apiUserName, }) {
        return new Promise((resolve, reject) => {
            // Validate inputs
            if (!(sec && roomName && islevel && apiUserName && member)) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Missing required parameters',
                };
                reject(validationError);
                return;
            }
            // Validate alphanumeric for roomName, apiUserName, and member
            try {
                this.validateAlphanumeric.validateAlphanumeric({ str: roomName });
                this.validateAlphanumeric.validateAlphanumeric({ str: apiUserName });
                this.validateAlphanumeric.validateAlphanumeric({ str: member });
            }
            catch (error) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName or apiUserName or member',
                };
                reject(validationError);
                return;
            }
            // Validate roomName starts with 's' or 'p'
            if (!(roomName.startsWith('s') || roomName.startsWith('p'))) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName, must start with s or p',
                };
                reject(validationError);
                return;
            }
            // Validate other conditions for sec, roomName, islevel, apiUserName
            if (!(sec.length === 64 &&
                roomName.length >= 8 &&
                islevel.length === 1 &&
                apiUserName.length >= 6 &&
                (islevel === '0' || islevel === '1' || islevel === '2'))) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName or islevel or apiUserName or secret',
                };
                reject(validationError);
                return;
            }
            socket.emit('joinConRoom', { roomName, islevel, member, sec, apiUserName }, async (data) => {
                try {
                    // Check if rtpCapabilities is null
                    if (data.rtpCapabilities === null) {
                        // Check if banned, suspended, or noAdmin
                        if (data.banned) {
                            throw new Error('User is banned.');
                        }
                        if (data.suspended) {
                            throw new Error('User is suspended.');
                        }
                        if (data.noAdmin) {
                            throw new Error('Host has not joined the room yet.');
                        }
                        // Resolve with the data received from the 'joinConRoom' event
                        resolve(data);
                    }
                    else {
                        // Resolve with the data received from the 'joinConRoom' event
                        resolve(data);
                    }
                }
                catch (error) {
                    // Handle errors during the joinConRoom process
                    console.log('Error joining room:', error);
                    reject(error);
                }
            });
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinConRoom, deps: [{ token: ValidateAlphanumeric }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinConRoom, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinConRoom, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: ValidateAlphanumeric }] });

/**
 * @service JoinConsumeRoom
 * @description Service to join a media consumption room, setup device, and manage piped transports.
 *
 * @method joinConsumeRoom
 * Joins a consumption room by sending a request to the server and performing necessary device and transport setup.
 *
 * @param {JoinConsumeRoomOptions} options - Options for joining the consumption room.
 * @param {Socket} options.remote_sock - The remote socket used for joining the room.
 * @param {string} options.apiToken - API token for authentication.
 * @param {string} options.apiUserName - API username for authentication.
 * @param {JoinConsumeRoomParameters} options.parameters - Parameters required for the function.
 *
 * @returns {Promise<JoinConsumeRoomResponse>} A promise that resolves with the result of the join request.
 *
 * @example
 * ```typescript
 * const joinConsumeRoomResponse = await joinConsumeRoomService.joinConsumeRoom({
 *   remote_sock: mySocket,
 *   apiToken: 'apiToken123',
 *   apiUserName: 'myUser',
 *   parameters: {
 *     roomName: 'room1',
 *     islevel: '2',
 *     member: 'JohnDoe',
 *     device: null,
 *     updateDevice: updateDeviceFunction,
 *     receiveAllPipedTransports: receiveAllPipedTransportsFunction,
 *     createDeviceClient: createDeviceClientFunction,
 *   }
 * });
 * ```
 */
class JoinConsumeRoom {
    JoinConRoomService;
    constructor(JoinConRoomService) {
        this.JoinConRoomService = JoinConRoomService;
    }
    /**
     * Joins a consumption room by sending a request to the server and handles the necessary setup.
     * @param {Object} options - The options object containing necessary variables.
     * @param {any} options.remote_sock - The remote socket information.
     * @param {string} options.apiToken - The API token for authentication.
     * @param {string} options.apiUserName - The API username for authentication.
     * @param {any} options.parameters - Additional parameters required for the function.
     * @returns {Promise<any>} - A promise that resolves with data related to the success of joining the room.
     */
    joinConsumeRoom = async ({ remote_sock, apiToken, apiUserName, parameters, }) => {
        let { roomName, islevel, member, device, updateDevice, 
        //Mediasfu functions
        receiveAllPipedTransports, createDeviceClient, } = parameters;
        try {
            // Join the consumption room
            const data = await this.JoinConRoomService.joinConRoom({
                socket: remote_sock,
                roomName,
                islevel,
                member,
                sec: apiToken,
                apiUserName,
            });
            if (data && data.success) {
                // Setup media device if not already set
                if (!device) {
                    if (data.rtpCapabilities) {
                        const device_ = await createDeviceClient({
                            rtpCapabilities: data.rtpCapabilities,
                        });
                        if (device_) {
                            updateDevice(device_);
                        }
                    }
                }
                // Receive all piped transports
                await receiveAllPipedTransports({ nsock: remote_sock, parameters });
            }
            return data;
        }
        catch (error) {
            console.log('Error in joinConsumeRoom:', error);
            throw new Error('Failed to join the consumption room or set up necessary components.');
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinConsumeRoom, deps: [{ token: JoinConRoom }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinConsumeRoom, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinConsumeRoom, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: JoinConRoom }] });

/**
 * @service ProducerClosed
 * @description Service to manage the closing of a producer, including resizing video elements and updating consumer transports.
 *
 * @method producerClosed
 * Closes a specific producer by its ID, adjusts any associated video elements, and updates the list of consumer transports.
 *
 * @param {ProducerClosedOptions} options - Options for closing the specified producer.
 * @param {string} options.remoteProducerId - Unique ID for the producer to close.
 * @param {ProducerClosedParameters} options.parameters - Parameters to configure the producer closure and related updates.
 *
 * @returns {Promise<void>} A promise that resolves when the producer has been closed and relevant updates have been made.
 *
 * @example
 * ```typescript
 * await producerClosedService.producerClosed({
 *   remoteProducerId: 'producer123',
 *   parameters: {
 *     consumerTransports: currentTransports,
 *     screenId: 'screen123',
 *     updateConsumerTransports: updateTransportList,
 *     closeAndResize: closeAndResizeFunction,
 *     getUpdatedAllParams: getUpdatedParamsFunction,
 *   }
 * });
 * ```
 */
class ProducerClosed {
    /**
     * Handles the closing of a producer and resizes video elements.
     * @param {Object} options - The options object containing necessary variables.
     * @param {string} options.remoteProducerId - The ID of the remote producer.
     * @param {any} options.parameters - Additional parameters required for the function.
     * @returns {Promise<void>}
     */
    producerClosed = async ({ remoteProducerId, parameters, }) => {
        let { consumerTransports, screenId, updateConsumerTransports, 
        // mediasfu functions
        closeAndResize, } = parameters;
        // Handle producer closed
        const producerToClose = consumerTransports.find((transportData) => transportData.producerId === remoteProducerId);
        if (!producerToClose) {
            return;
        }
        // Check if the ID of the producer to close is == screenId
        let kind = producerToClose.consumer.kind;
        if (producerToClose.producerId == screenId) {
            kind = 'screenshare';
        }
        try {
            await producerToClose['consumerTransport'].close();
        }
        catch (error) {
            console.error('Error closing consumerTransport:', error);
        }
        try {
            producerToClose.consumer.close();
        }
        catch (error) {
            console.error('Error closing consumer:', error);
        }
        consumerTransports = consumerTransports.filter((transportData) => transportData.producerId !== remoteProducerId);
        updateConsumerTransports(consumerTransports);
        // Close and resize the videos
        await closeAndResize({ producerId: remoteProducerId, kind: kind, parameters: parameters });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerClosed, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerClosed, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerClosed, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
   * Signals the creation of a new consumer transport.
   *
   * @param {Object} options - The options for signaling a new consumer transport.
   * @param {string} options.remoteProducerId - The ID of the remote producer.
   * @param {boolean} options.islevel - Indicates the level of the consumer.
   * @param {any} options.nsock - The socket instance for communication.
   * @param {SignalNewConsumerTransportOptions} options.parameters - The parameters for the transport.
   *
   * @returns {Promise<string[] | void>} A promise that resolves to an array of consuming transports or void.
   *
   * @throws Will throw an error if the signaling process fails.
   *
   * @example
   * const options = {
   *   remoteProducerId: 'producer-id',
   *   islevel: true,
   *   nsock: socketInstance,
   *   parameters: {
   *     device: mediaDevice,
   *     consumingTransports: [],
   *     lock_screen: false,
   *     updateConsumingTransports: updateFunction,
   *     connectRecvTransport: connectFunction,
   *     reorderStreams: reorderFunction,
   *     getUpdatedAllParams: getUpdatedParamsFunction,
   *   },
   * };
   *
   * signalNewConsumerTransport(options)
   *   .then(consumingTransports => {
   *     console.log('Consuming Transports:', consumingTransports);
   *   })
   *   .catch(error => {
   *     console.error('Error signaling new consumer transport:', error);
   *   });
   */
class SignalNewConsumerTransport {
    signalNewConsumerTransport = async ({ remoteProducerId, islevel, nsock, parameters, }) => {
        try {
            let { device, consumingTransports, lock_screen, updateConsumingTransports, connectRecvTransport, reorderStreams, } = parameters;
            // Get updated parameters
            const updatedParams = parameters.getUpdatedAllParams();
            device = updatedParams.device;
            consumingTransports = updatedParams.consumingTransports;
            // Check if already consuming
            if (consumingTransports.includes(remoteProducerId)) {
                return consumingTransports;
            }
            // Add remote producer ID to consumingTransports array
            consumingTransports.push(remoteProducerId);
            updateConsumingTransports(consumingTransports);
            // Emit createWebRtcTransport event to signal a new consumer
            nsock.emit('createWebRtcTransport', { consumer: true, islevel }, async ({ params }) => {
                if (params.error) {
                    // Handle error
                    return;
                }
                try {
                    // Create a new receiving transport using the received parameters
                    if (!device) {
                        throw new Error('Device is not initialized');
                    }
                    const consumerTransport = device.createRecvTransport({ ...params });
                    // Handle 'connect' event for the consumer transport
                    consumerTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
                        try {
                            // Emit transport-recv-connect event to signal connection
                            nsock.emit('transport-recv-connect', {
                                dtlsParameters,
                                serverConsumerTransportId: params.id,
                            });
                            callback();
                        }
                        catch (error) {
                            errback(error);
                        }
                    });
                    // Listen for connection state change
                    consumerTransport.on('connectionstatechange', async (state) => {
                        switch (state) {
                            case 'connecting':
                                // Handle connecting state
                                break;
                            case 'connected':
                                // Handle connected state
                                break;
                            case 'failed':
                                // Handle failed state
                                consumerTransport.close();
                                // Reorder streams based on conditions
                                if (lock_screen) {
                                    await reorderStreams({ add: true, parameters });
                                }
                                else {
                                    await reorderStreams({ add: false, parameters });
                                }
                                break;
                            default:
                                break;
                        }
                    });
                    // Connect the receiving transport
                    await connectRecvTransport({
                        consumerTransport,
                        remoteProducerId,
                        serverConsumerTransportId: params.id,
                        nsock,
                        parameters,
                    });
                }
                catch (error) {
                    console.log(error, 'createRecvTransport error');
                    // Handle error
                    return;
                }
            });
        }
        catch (error) {
            console.log(error, 'signalNewConsumerTransport error');
            // Handle error
            return;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SignalNewConsumerTransport, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SignalNewConsumerTransport, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SignalNewConsumerTransport, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * @service NewPipeProducer
 * @description Service to manage new pipe producer events, update state, and handle screen orientation for optimal experience.
 *
 * @method newPipeProducer
 * Handles the setup of a new pipe producer and manages user notifications or orientation changes as needed.
 *
 * @param {NewPipeProducerOptions} options - Options for setting up a new pipe producer.
 * @param {string} options.producerId - Unique ID for the new producer.
 * @param {string} options.islevel - Level designation for the producer.
 * @param {Socket} options.nsock - The socket used for communication.
 * @param {NewPipeProducerParameters} options.parameters - Parameters to configure the new pipe producer.
 *
 * @returns {Promise<void>} A promise that completes when the new pipe producer is set up.
 *
 * @example
 * ```typescript
 * await newPipeProducerService.newPipeProducer({
 *   producerId: 'producer123',
 *   islevel: '2',
 *   nsock: mySocket,
 *   parameters: {
 *     first_round: true,
 *     shareScreenStarted: false,
 *     shared: false,
 *     landScaped: false,
 *     showAlert: alertFunction,
 *     isWideScreen: true,
 *     updateFirst_round: updateFirstRoundFunction,
 *     updateLandScaped: updateLandScapedFunction,
 *     device: myDevice,
 *     consumingTransports: [],
 *     connectRecvTransport: connectRecvTransportFunction,
 *     reorderStreams: reorderStreamsFunction,
 *     getUpdatedAllParams: getUpdatedParamsFunction,
 *   }
 * });
 * ```
 */
class NewPipeProducer {
    signalNewConsumerTransportService;
    constructor(signalNewConsumerTransportService) {
        this.signalNewConsumerTransportService = signalNewConsumerTransportService;
    }
    /**
     * Handles new pipe producer events and updates relevant states.
     * @param {Object} options - The options object containing necessary variables.
     * @param {string} options.producerId - The ID of the producer.
     * @param {string} options.islevel - The level of the producer.
     * @param {any} options.nsock - The socket object.
     * @param {any} options.parameters - Additional parameters required for the function.
     * @returns {Promise<void>}
     */
    newPipeProducer = async ({ producerId, islevel, nsock, parameters, }) => {
        let { first_round, shareScreenStarted, shared, landScaped, showAlert, isWideScreen, updateFirst_round, updateLandScaped, } = parameters;
        try {
            // Perform signaling for new consumer transport
            await this.signalNewConsumerTransportService.signalNewConsumerTransport({
                remoteProducerId: producerId,
                islevel: islevel,
                nsock: nsock,
                parameters: parameters,
            });
            first_round = false;
            if (shareScreenStarted || shared) {
                if (!isWideScreen) {
                    if (!landScaped) {
                        if (showAlert) {
                            showAlert({
                                message: 'Please rotate your device to landscape mode for better experience',
                                type: 'success',
                                duration: 3000,
                            });
                        }
                        landScaped = true;
                        updateLandScaped(landScaped);
                    }
                }
                first_round = true;
                updateFirst_round(first_round);
            }
        }
        catch (error) {
            console.error('Error in newPipeProducer:', error);
            throw new Error('Failed to handle new pipe producer event.');
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: NewPipeProducer, deps: [{ token: SignalNewConsumerTransport }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: NewPipeProducer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: NewPipeProducer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: SignalNewConsumerTransport }] });

/**
 * MiniCard component displays a customizable card with an image or initials.
 *
 * @component
 * @selector app-mini-card
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * ```html
 * <div class="mini-card" [ngStyle]="getMergedCardStyles()">
 *   <div *ngIf="imageSource; else noImage" class="image-container">
 *     <img [src]="imageSource" alt="Profile" [ngStyle]="getMergedImageStyles()" />
 *   </div>
 *   <ng-template #noImage>
 *     <div class="initials" [ngStyle]="getInitialsStyle()">{{ initials }}</div>
 *   </ng-template>
 * </div>
 * ```
 *
 * @styleUrls ['./mini-card.component.css']
 *
 * @inputs
 * - `initials` (string): Initials to display if no image is provided.
 * - `fontSize` (number): Font size for initials text, default is 14.
 * - `customStyle` (CSSStyleDeclaration): Custom styles for the card.
 * - `imageSource` (string): Source URL for the image.
 * - `roundedImage` (boolean): Whether the image should be rounded, default is false.
 * - `imageStyle` (CSSStyleDeclaration): Custom styles for the image.
 *
 * @constructor
 * - Optionally accepts injected values for each input property.
 *
 * @methods
 * - `getMergedCardStyles()`: Returns merged styles for the card.
 * - `getMergedImageStyles()`: Returns merged styles for the image.
 * - `getInitialsStyle()`: Returns styles for the initials text.
 *
 * @example
 * ```html
 * <app-mini-card initials="AB" fontSize="20" [roundedImage]="true" imageSource="/path/to/image.jpg"></app-mini-card>
 * ```
 */
class MiniCard {
    initials;
    fontSize = 14;
    customStyle = {};
    imageSource;
    roundedImage = false;
    imageStyle = {};
    constructor(injectedInitials, injectedFontSize, injectedCustomStyle, injectedImageSource, injectedRoundedImage, injectedImageStyle) {
        this.initials = injectedInitials || this.initials || '';
        this.fontSize = injectedFontSize || this.fontSize || 14;
        this.customStyle = injectedCustomStyle || this.customStyle || {};
        this.imageSource = injectedImageSource || this.imageSource || '';
        this.roundedImage = injectedRoundedImage || this.roundedImage || true;
        this.imageStyle = injectedImageStyle || this.imageStyle || {};
    }
    getMergedCardStyles() {
        return {
            'font-size': this.fontSize + 'px',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            borderRadius: '0',
            width: '100%',
            height: '100%',
            color: 'black',
            fontFamily: "'Nunito', sans-serif",
            overflow: 'hidden',
            border: '2px solid black',
            ...this.customStyle,
        };
    }
    getMergedImageStyles() {
        return {
            width: '60%',
            height: '60%',
            objectFit: 'cover',
            ...(this.roundedImage ? { borderRadius: '50%' } : {}),
            ...this.imageStyle,
        };
    }
    getInitialsStyle() {
        return {
            textAlign: 'center',
            'font-size': this.fontSize + 'px',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MiniCard, deps: [{ token: 'initials', optional: true }, { token: 'fontSize', optional: true }, { token: 'customStyle', optional: true }, { token: 'imageSource', optional: true }, { token: 'roundedImage', optional: true }, { token: 'imageStyle', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MiniCard, isStandalone: true, selector: "app-mini-card", inputs: { initials: "initials", fontSize: "fontSize", customStyle: "customStyle", imageSource: "imageSource", roundedImage: "roundedImage", imageStyle: "imageStyle" }, ngImport: i0, template: `
    <div class="mini-card" [ngStyle]="getMergedCardStyles()">
      <div *ngIf="imageSource; else noImage" class="image-container">
        <img [src]="imageSource" alt="Profile" [ngStyle]="getMergedImageStyles()" />
      </div>
      <ng-template #noImage>
        <div class="initials" [ngStyle]="getInitialsStyle()">{{ initials }}</div>
      </ng-template>
    </div>
  `, isInline: true, styles: [".mini-card{display:flex;justify-content:center;align-items:center;border-radius:0;width:100%;height:100%;color:#000;font-family:Nunito,sans-serif;overflow:hidden;border:2px solid black}.image-container{display:flex;justify-content:center;align-items:center;width:100%;height:100%}.backgroundImage{width:60%;height:60%;object-fit:cover}.roundedImage{border-radius:50%}.initials{text-align:center;font-size:14px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MiniCard, decorators: [{
            type: Component,
            args: [{ selector: 'app-mini-card', imports: [CommonModule], template: `
    <div class="mini-card" [ngStyle]="getMergedCardStyles()">
      <div *ngIf="imageSource; else noImage" class="image-container">
        <img [src]="imageSource" alt="Profile" [ngStyle]="getMergedImageStyles()" />
      </div>
      <ng-template #noImage>
        <div class="initials" [ngStyle]="getInitialsStyle()">{{ initials }}</div>
      </ng-template>
    </div>
  `, styles: [".mini-card{display:flex;justify-content:center;align-items:center;border-radius:0;width:100%;height:100%;color:#000;font-family:Nunito,sans-serif;overflow:hidden;border:2px solid black}.image-container{display:flex;justify-content:center;align-items:center;width:100%;height:100%}.backgroundImage{width:60%;height:60%;object-fit:cover}.roundedImage{border-radius:50%}.initials{text-align:center;font-size:14px}\n"] }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['initials']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['fontSize']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageSource']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['roundedImage']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageStyle']
                }] }], propDecorators: { initials: [{
                type: Input
            }], fontSize: [{
                type: Input
            }], customStyle: [{
                type: Input
            }], imageSource: [{
                type: Input
            }], roundedImage: [{
                type: Input
            }], imageStyle: [{
                type: Input
            }] } });

/**
 * CardVideoDisplay component displays a video stream with options for full display, mirroring, and background color customization.
 *
 * @selector app-card-video-display
 * @standalone true
 * @imports CommonModule
 *
 * @inputs
 * - `remoteProducerId` (string): Identifier for the remote producer.
 * - `eventType` (EventType): Type of event, such as 'webinar'. Default is 'webinar'.
 * - `forceFullDisplay` (boolean): Forces full video display if true. Default is false.
 * - `videoStream` (MediaStream | null): The media stream to display in the video element.
 * - `backgroundColor` (string): Background color for the video container. Default is 'transparent'.
 * - `doMirror` (boolean): Mirrors the video if true. Default is false.
 *
 * @methods
 * - `ngOnInit()`: Initializes the video stream and sets the container style on component load.
 * - `ngOnChanges(changes: SimpleChanges)`: Updates the video stream or container style when inputs change.
 * - `updateVideoStream()`: Assigns the video stream to the video element if it differs from the current stream.
 * - `setVideoContainerStyle()`: Sets the style of the video container based on the provided background color.
 * - `getBaseVideoContainerStyle()`: Returns base styles for the video container.
 * - `getVideoStyle()`: Returns styles for the video element, including optional mirroring and sizing.
 *
 * @example
 * ```html
 * <app-card-video-display
 *  [remoteProducerId]="producerId"
 * [eventType]="'conference'"
 * [forceFullDisplay]="true"
 * [videoStream]="stream"
 * [backgroundColor]="'black'"
 * [doMirror]="true">
 * </app-card-video-display>
 * ```
 **/
class CardVideoDisplay {
    remoteProducerId = '';
    eventType = 'webinar';
    forceFullDisplay = false;
    videoStream = null;
    backgroundColor = 'transparent';
    doMirror = false;
    videoElement;
    videoContainerStyle;
    ngOnInit() {
        this.updateVideoStream();
        this.setVideoContainerStyle();
    }
    ngOnChanges(changes) {
        if (changes['videoStream'] && this.videoStream) {
            const currentStream = changes['videoStream'].currentValue;
            const previousStream = changes['videoStream'].previousValue;
            if (!previousStream ||
                currentStream.id !== previousStream.id ||
                currentStream.active !== previousStream.active) {
                this.updateVideoStream();
            }
        }
        if (changes['backgroundColor'] &&
            changes['backgroundColor'].currentValue !== changes['backgroundColor'].previousValue) {
            this.setVideoContainerStyle();
        }
    }
    updateVideoStream() {
        if (this.videoElement && this.videoStream) {
            const videoElement = this.videoElement.nativeElement;
            // Update the video element's srcObject only if it has changed
            if (videoElement.srcObject !== this.videoStream) {
                videoElement.srcObject = this.videoStream;
            }
        }
    }
    setVideoContainerStyle() {
        this.videoContainerStyle = {
            ...this.getBaseVideoContainerStyle(),
            backgroundColor: this.backgroundColor,
        };
    }
    getBaseVideoContainerStyle() {
        return {
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            width: '100%',
            height: '100%',
            backgroundColor: 'black',
        };
    }
    getVideoStyle() {
        const baseStyles = {
            width: this.forceFullDisplay ? '100%' : 'auto',
            height: '100%',
            maxWidth: '100%',
            maxHeight: '100%',
            objectFit: this.forceFullDisplay ? 'cover' : 'contain',
            backgroundColor: this.backgroundColor,
        };
        if (this.doMirror) {
            baseStyles.transform = 'rotateY(180deg)';
        }
        return baseStyles;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CardVideoDisplay, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: CardVideoDisplay, isStandalone: true, selector: "app-card-video-display", inputs: { remoteProducerId: "remoteProducerId", eventType: "eventType", forceFullDisplay: "forceFullDisplay", videoStream: "videoStream", backgroundColor: "backgroundColor", doMirror: "doMirror" }, viewQueries: [{ propertyName: "videoElement", first: true, predicate: ["videoElement"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"videoContainerStyle\">\r\n  <video #videoElement autoplay muted playsinline [ngStyle]=\"getVideoStyle()\"></video>\r\n</div>\r\n", styles: [".videoContainer{display:flex;justify-content:center;align-items:center;width:100%;height:100%;background-color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CardVideoDisplay, decorators: [{
            type: Component,
            args: [{ selector: 'app-card-video-display', imports: [CommonModule], template: "<div [ngStyle]=\"videoContainerStyle\">\r\n  <video #videoElement autoplay muted playsinline [ngStyle]=\"getVideoStyle()\"></video>\r\n</div>\r\n", styles: [".videoContainer{display:flex;justify-content:center;align-items:center;width:100%;height:100%;background-color:#000}\n"] }]
        }], propDecorators: { remoteProducerId: [{
                type: Input
            }], eventType: [{
                type: Input
            }], forceFullDisplay: [{
                type: Input
            }], videoStream: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], doMirror: [{
                type: Input
            }], videoElement: [{
                type: ViewChild,
                args: ['videoElement', { static: true }]
            }] } });

/**
 * Gets the style for positioning an overlay based on the specified position.
 *
 * @param {GetOverlayPositionOptions} options - Contains the desired position for the overlay.
 * @param {string} options.position - The position for the overlay ('topLeft', 'topRight', 'bottomLeft', 'bottomRight').
 * @returns {OverlayPositionStyle} - Style object defining the overlay position.
 *
 * @example
 * ```typescript
 * const topLeftPosition = getOverlayPosition({ position: 'topLeft' });
 * // Output: { top: 0, left: 0 }
 *
 * const bottomRightPosition = getOverlayPosition({ position: 'bottomRight' });
 * // Output: { bottom: 0, right: 0 }
 * ```
 */
function getOverlayPosition({ position }) {
    switch (position) {
        case 'topLeft':
            return { top: 0, left: 0 };
        case 'topRight':
            return { top: 0, right: 0 };
        case 'bottomLeft':
            return { bottom: 0, left: 0 };
        case 'bottomRight':
            return { bottom: 0, right: 0 };
        default:
            return {};
    }
}

/**
 * Controls the media of a participant in a media session if certain conditions are met.
 *
 * @param {ControlMediaOptions} options - The options for controlling media.
 * @param {string} options.participantId - The ID of the participant to control.
 * @param {string} options.participantName - The name of the participant to control.
 * @param {'audio' | 'video' | 'screenshare' | 'all'} options.type - The type of media to control.
 * @param {Socket} options.socket - The socket instance for communication.
 * @param {CoHostResponsibility[]} options.coHostResponsibility - List of co-host responsibilities.
 * @param {Participant[]} options.participants - List of participants in the session.
 * @param {string} options.member - The current member attempting to control media.
 * @param {string} options.islevel - The level of the current member.
 * @param {Function} [options.showAlert] - Optional function to show alerts.
 * @param {string} options.coHost - The co-host information.
 * @param {string} options.roomName - The name of the room.
 *
 * @returns {Promise<void>} A promise that resolves when the media control operation is complete.
 *
 * @throws Will log an error message if the operation fails.
 *
 * @example
 * ```typescript
 * const options = {
 *   participantId: '12345',
 *   participantName: 'John Doe',
 *   type: 'audio',
 *   socket: socketInstance,
 *   coHostResponsibility: [{ name: 'media', value: true }],
 *   participants: participantList,
 *   member: 'currentMember',
 *   islevel: '2',
 *   showAlert: showAlertFunction,
 *   coHost: 'coHostName',
 *   roomName: 'Room A',
 * };
 *
 * controlMediaService.controlMedia(options)
 *   .then(() => {
 *     console.log('Media control action completed');
 *   })
 *   .catch((error) => {
 *     console.error('Error controlling media:', error);
 *   });
 * ```
 */
class ControlMedia {
    /**
     * Controls the media of a participant in a media session if certain conditions are met.
     *
     * @param {Object} options - The options for controlling media.
     * @param {string} options.participantId - The ID of the participant to control.
     * @param {string} options.participantName - The name of the participant to control.
     * @param {string} options.type - The type of media to control.
     * @param {Socket} options.socket - The socket instance for communication.
     * @param {Array} options.coHostResponsibility - List of co-host responsibilities.
     * @param {Array} options.participants - List of participants in the session.
     * @param {string} options.member - The current member attempting to control media.
     * @param {string} options.islevel - The level of the current member.
     * @param {Function} [options.showAlert] - Optional function to show alerts.
     * @param {string} options.coHost - The co-host information.
     * @param {string} options.roomName - The name of the room.
     *
     * @returns {Promise<void>} A promise that resolves when the media control operation is complete.
     */
    async controlMedia({ participantId, participantName, type, socket, coHostResponsibility, participants, member, islevel, showAlert, coHost, roomName, }) {
        try {
            // Destructure parameters
            let mediaValue = false;
            try {
                mediaValue =
                    coHostResponsibility.find((item) => item.name === 'media')?.value ?? false;
            }
            catch {
                /* handle error */
            }
            let participant = participants.find((obj) => obj.name === participantName);
            if (islevel === '2' || (coHost === member && mediaValue === true)) {
                // Check if the participant is not muted and is not a host
                if (participant &&
                    ((!participant.muted && participant.islevel !== '2' && type == 'audio') ||
                        (participant.islevel !== '2' && type == 'video' && participant['videoOn']))) {
                    // Emit controlMedia event to the server
                    socket.emit('controlMedia', { participantId, participantName, type, roomName });
                }
            }
            else {
                // Display an alert if the participant is not allowed to mute other participants
                if (showAlert) {
                    showAlert({
                        message: 'You are not allowed to control media for other participants.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
        }
        catch (error) {
            console.log('controlMedia error', error);
            // throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlMedia, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlMedia, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlMedia, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * VideoCard component represents a customizable video display card with participant controls for toggling audio and video.
 * It also animates an audio waveform if sound is detected in the participant's audio stream.
 *
 * @selector app-video-card
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule, CardVideoDisplay]
 *
 * @example
 * ```html
 * <app-video-card
 *   [name]="participant.name"
 *   [videoStream]="videoStream"
 *   [audioDecibels]="audioDecibels"
 *   [participant]="participant"
 *   [parameters]="videoCardParameters"
 * ></app-video-card>
 * ```
 *
 * @input {Partial<CSSStyleDeclaration>} customStyle - Styles for the card container.
 * @input {string} name - Name of the participant displayed on the card.
 * @input {string} barColor - Color of the waveform bars. Default is 'red'.
 * @input {string} textColor - Color of the name text. Default is 'white'.
 * @input {string} imageSource - Source URL of the participant's image.
 * @input {boolean} roundedImage - Whether the image should have rounded corners.
 * @input {Partial<CSSStyleDeclaration>} imageStyle - Additional styles for the image.
 * @input {string} remoteProducerId - ID of the remote media producer.
 * @input {EventType} eventType - Type of event (used for internal logic).
 * @input {boolean} forceFullDisplay - Forces full display if true.
 * @input {MediaStream | null} videoStream - Stream of the video to be displayed.
 * @input {boolean} showControls - Determines if the controls are displayed. Default is true.
 * @input {boolean} showInfo - Determines if info (e.g., participant name) is shown. Default is true.
 * @input {HTMLElement | CustomComponent} videoInfoComponent - Custom component for video info display.
 * @input {HTMLElement | CustomComponent} videoControlsComponent - Custom component for video controls.
 * @input {'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight'} controlsPosition - Position of controls overlay.
 * @input {'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight'} infoPosition - Position of info overlay.
 * @input {Participant} participant - Participant data object.
 * @input {string} backgroundColor - Background color of the video card.
 * @input {AudioDecibels[]} audioDecibels - Audio decibel data for animating waveform.
 * @input {boolean} doMirror - If true, mirrors the video display.
 * @input {VideoCardParameters} parameters - Additional parameters including socket and alert configuration.
 *
 * @property {number[]} waveformAnimations - Array representing animation states for waveform bars.
 * @property {boolean} showWaveform - Flag to toggle waveform animation. Default is true.
 * @property {any} interval - Interval reference for audio decibel checks.
 * @property {IconDefinition} faMicrophone - FontAwesome icon for microphone.
 * @property {IconDefinition} faMicrophoneSlash - FontAwesome icon for muted microphone.
 * @property {IconDefinition} faVideo - FontAwesome icon for video.
 * @property {IconDefinition} faVideoSlash - FontAwesome icon for video off.
 *
 * @method ngOnInit - Lifecycle hook to initialize audio decibel interval check.
 * @method ngOnDestroy - Lifecycle hook to clear intervals.
 * @method animateWaveform - Starts audio waveform animation.
 * @method resetWaveform - Resets waveform animations.
 * @method getAnimationDuration - Returns animation duration for given bar index.
 * @method toggleAudio - Toggles participant's audio status.
 * @method toggleVideo - Toggles participant's video status.
 * @method renderControls - Renders the control buttons (audio and video) based on participant status.
 * @method getOverlayPosition - Returns overlay position styles based on the input position string.
 * @method isCustomComponent - Checks if a component is a custom component.
 * @method isFunctionComponent - Checks if a component is a function component.
 */
class VideoCard {
    controlMediaService;
    customStyle = {};
    name;
    barColor = 'red';
    textColor = 'white';
    imageSource;
    roundedImage = false;
    imageStyle = {};
    remoteProducerId;
    eventType;
    forceFullDisplay;
    videoStream = null;
    showControls = true;
    showInfo = true;
    videoInfoComponent;
    videoControlsComponent;
    controlsPosition = 'topLeft';
    infoPosition = 'topRight';
    participant;
    backgroundColor;
    audioDecibels = [];
    doMirror;
    parameters;
    waveformAnimations = Array.from({ length: 9 }, () => 0);
    showWaveform = true;
    interval;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    constructor(controlMediaService, injectedCustomStyle, injectedName, injectedBarColor, injectedTextColor, injectedImageSource, injectedRoundedImage, injectedImageStyle, injectedRemoteProducerId, injectedEventType, injectedForceFullDisplay, injectedVideoStream, injectedShowControls, injectedShowInfo, injectedVideoInfoComponent, injectedVideoControlsComponent, injectedControlsPosition, injectedInfoPosition, injectedParticipant, injectedBackgroundColor, injectedAudioDecibels, injectedDoMirror, injectedParameters) {
        this.controlMediaService = controlMediaService;
        this.customStyle = injectedCustomStyle || this.customStyle;
        this.name = injectedName || this.name;
        this.barColor = injectedBarColor || this.barColor;
        this.textColor = injectedTextColor || this.textColor;
        this.imageSource = injectedImageSource || this.imageSource;
        this.roundedImage = injectedRoundedImage || this.roundedImage;
        this.imageStyle = injectedImageStyle || this.imageStyle;
        this.remoteProducerId = injectedRemoteProducerId || this.remoteProducerId;
        this.eventType = injectedEventType || this.eventType;
        this.forceFullDisplay = injectedForceFullDisplay || this.forceFullDisplay;
        this.videoStream = injectedVideoStream || this.videoStream;
        this.showControls = injectedShowControls != null ? injectedShowControls : this.showControls;
        this.showInfo = injectedShowInfo != null ? injectedShowInfo : this.showInfo;
        this.videoInfoComponent = injectedVideoInfoComponent || this.videoInfoComponent;
        this.videoControlsComponent = injectedVideoControlsComponent || this.videoControlsComponent;
        this.controlsPosition = injectedControlsPosition || this.controlsPosition;
        this.infoPosition = injectedInfoPosition || this.infoPosition;
        this.participant = injectedParticipant || this.participant;
        this.backgroundColor = injectedBackgroundColor || this.backgroundColor;
        this.audioDecibels = injectedAudioDecibels || this.audioDecibels;
        this.doMirror = injectedDoMirror || this.doMirror;
        this.parameters = injectedParameters || this.parameters;
    }
    ngOnInit() {
        this.interval = setInterval(() => {
            const params = this.parameters.getUpdatedAllParams();
            const { audioDecibels, participants } = params;
            const existingEntry = audioDecibels && audioDecibels.find((entry) => entry.name === this.name);
            const participantEntry = participants && participants.find((p) => p.name === this.name);
            if (existingEntry &&
                existingEntry.averageLoudness > 127.5 &&
                participantEntry &&
                !participantEntry.muted) {
                this.animateWaveform();
            }
            else {
                this.resetWaveform();
            }
        }, 1000);
    }
    ngOnDestroy() {
        clearInterval(this.interval);
    }
    animateWaveform() {
        this.waveformAnimations.forEach((_, index) => {
            setInterval(() => this.animateBar(index), this.getAnimationDuration(index) * 2);
        });
    }
    animateBar(index) {
        this.waveformAnimations[index] = 1;
        setTimeout(() => {
            this.waveformAnimations[index] = 0;
        }, this.getAnimationDuration(index));
    }
    resetWaveform() {
        this.waveformAnimations.fill(0);
    }
    getAnimationDuration(index) {
        const durations = [474, 433, 407, 458, 400, 427, 441, 419, 487];
        return durations[index] || 0;
    }
    async toggleAudio() {
        if (this.participant && !this.participant.muted) {
            const params = this.parameters;
            await this.controlMediaService.controlMedia({
                participantId: this.participant.id || '',
                participantName: this.participant.name,
                type: 'audio',
                socket: params.socket,
                roomName: params.roomName,
                coHostResponsibility: params.coHostResponsibility,
                showAlert: params.showAlert,
                coHost: params.coHost,
                participants: params.participants,
                member: params.member,
                islevel: params.islevel,
            });
        }
    }
    async toggleVideo() {
        if (this.participant) {
            const params = this.parameters.getUpdatedAllParams();
            await this.controlMediaService.controlMedia({
                participantId: this.participant.id || '',
                participantName: this.participant.name,
                type: 'video',
                socket: params.socket,
                roomName: params.roomName,
                coHostResponsibility: params.coHostResponsibility,
                showAlert: params.showAlert,
                coHost: params.coHost,
                participants: params.participants,
                member: params.member,
                islevel: params.islevel,
            });
        }
    }
    renderControls() {
        if (!this.showControls) {
            return null;
        }
        if (this.videoControlsComponent) {
            return this.videoControlsComponent;
        }
        return `
      <div class="overlayControls">
        <button class="controlButton" (click)="toggleAudio()">
          <fa-icon [icon]="participant?.muted ? faMicrophoneSlash : faMicrophone" [style.color]="participant?.muted ? 'red' : 'green'"></fa-icon>
        </button>
        <button class="controlButton" (click)="toggleVideo()">
          <fa-icon [icon]="participant?.videoOn ? faVideo : faVideoSlash" [style.color]="participant?.videoOn ? 'green' : 'red'"></fa-icon>
        </button>
      </div>
    `;
    }
    getOverlayPosition(position) {
        return getOverlayPosition({ position });
    }
    isCustomComponent(comp) {
        return (typeof comp.component !== 'function' &&
            comp.component !== undefined);
    }
    isFunctionComponent(comp) {
        return typeof comp === 'function';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: VideoCard, deps: [{ token: ControlMedia }, { token: 'customStyle', optional: true }, { token: 'name', optional: true }, { token: 'barColor', optional: true }, { token: 'textColor', optional: true }, { token: 'imageSource', optional: true }, { token: 'roundedImage', optional: true }, { token: 'imageStyle', optional: true }, { token: 'remoteProducerId', optional: true }, { token: 'eventType', optional: true }, { token: 'forceFullDisplay', optional: true }, { token: 'videoStream', optional: true }, { token: 'showControls', optional: true }, { token: 'showInfo', optional: true }, { token: 'videoInfoComponent', optional: true }, { token: 'videoControlsComponent', optional: true }, { token: 'controlsPosition', optional: true }, { token: 'infoPosition', optional: true }, { token: 'participant', optional: true }, { token: 'backgroundColor', optional: true }, { token: 'audioDecibels', optional: true }, { token: 'doMirror', optional: true }, { token: 'parameters', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: VideoCard, isStandalone: true, selector: "app-video-card", inputs: { customStyle: "customStyle", name: "name", barColor: "barColor", textColor: "textColor", imageSource: "imageSource", roundedImage: "roundedImage", imageStyle: "imageStyle", remoteProducerId: "remoteProducerId", eventType: "eventType", forceFullDisplay: "forceFullDisplay", videoStream: "videoStream", showControls: "showControls", showInfo: "showInfo", videoInfoComponent: "videoInfoComponent", videoControlsComponent: "videoControlsComponent", controlsPosition: "controlsPosition", infoPosition: "infoPosition", participant: "participant", backgroundColor: "backgroundColor", audioDecibels: "audioDecibels", doMirror: "doMirror", parameters: "parameters" }, ngImport: i0, template: "<div\r\n  [ngStyle]=\"customStyle\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n  class=\"video-card\"\r\n>\r\n  <app-card-video-display\r\n    [remoteProducerId]=\"remoteProducerId\"\r\n    [eventType]=\"eventType\"\r\n    [forceFullDisplay]=\"forceFullDisplay\"\r\n    [videoStream]=\"videoStream\"\r\n    [backgroundColor]=\"backgroundColor\"\r\n    [doMirror]=\"doMirror\"\r\n  ></app-card-video-display>\r\n\r\n  <div\r\n    *ngIf=\"showInfo\"\r\n    [ngClass]=\"showControls ? 'overlayWeb' : 'overlayWebAlt'\"\r\n    [ngStyle]=\"getOverlayPosition(infoPosition)\"\r\n  >\r\n    <div class=\"nameColumn\">\r\n      <span class=\"nameText\" [style.color]=\"textColor\">{{\r\n        participant.name\r\n      }}</span>\r\n    </div>\r\n    <div *ngIf=\"showWaveform\" class=\"waveformWeb\">\r\n      <div\r\n        *ngFor=\"let animation of waveformAnimations; let i = index\"\r\n        class=\"bar\"\r\n        [ngStyle]=\"{\r\n          height: animation === 0 ? '1px' : '16px',\r\n          backgroundColor: barColor\r\n        }\"\r\n      ></div>\r\n    </div>\r\n  </div>\r\n\r\n  <div\r\n    *ngIf=\"showControls\"\r\n    class=\"overlayControls\"\r\n    [ngStyle]=\"getOverlayPosition(controlsPosition)\"\r\n  >\r\n    <ng-container *ngIf=\"!videoControlsComponent\">\r\n      <div class=\"overlayControls\">\r\n        <button class=\"controlButton\" (click)=\"toggleAudio()\">\r\n          <fa-icon\r\n            [icon]=\"participant.muted ? faMicrophoneSlash : faMicrophone\"\r\n            [style.color]=\"participant.muted ? 'red' : 'green'\"\r\n          ></fa-icon>\r\n        </button>\r\n        <button class=\"controlButton\" (click)=\"toggleVideo()\">\r\n          <fa-icon\r\n            [icon]=\"participant['videoOn'] ? faVideo : faVideoSlash\"\r\n            [style.color]=\"participant['videoOn'] ? 'green' : 'red'\"\r\n          ></fa-icon>\r\n        </button>\r\n      </div>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"videoControlsComponent\">\r\n      <ng-container *ngIf=\"isCustomComponent(videoControlsComponent)\">\r\n        <ng-container\r\n          *ngComponentOutlet=\"\r\n            videoControlsComponent.component;\r\n            injector: videoControlsComponent.injector\r\n          \"\r\n        ></ng-container>\r\n      </ng-container>\r\n      <ng-container *ngIf=\"!isCustomComponent(videoControlsComponent)\">\r\n        <div [innerHTML]=\"videoControlsComponent.outerHTML\"></div>\r\n      </ng-container>\r\n    </ng-container>\r\n  </div>\r\n</div>\r\n", styles: [".video-card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f;border:2px solid black;position:relative}.overlayWeb{position:absolute;min-width:40%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.overlayWebAlt{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr;grid-gap:0px;top:0;right:0}.overlayControls{display:flex;flex-direction:row;padding:0;position:absolute;top:0;left:0}.controlButton{justify-content:center;align-items:center;background-color:#0003;padding:2px 4px;margin-right:2px;font-size:medium;border:none;cursor:pointer}.nameColumn{justify-content:center;align-items:center;background-color:#00000080;padding:5px;margin-right:2px;font-size:small;text-align:center}.nameText{font-size:small;font-weight:bolder}.waveformWeb{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin:0 1px;transition:height .5s ease}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: CardVideoDisplay, selector: "app-card-video-display", inputs: ["remoteProducerId", "eventType", "forceFullDisplay", "videoStream", "backgroundColor", "doMirror"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: VideoCard, decorators: [{
            type: Component,
            args: [{ selector: 'app-video-card', imports: [CommonModule, FontAwesomeModule, CardVideoDisplay], template: "<div\r\n  [ngStyle]=\"customStyle\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n  class=\"video-card\"\r\n>\r\n  <app-card-video-display\r\n    [remoteProducerId]=\"remoteProducerId\"\r\n    [eventType]=\"eventType\"\r\n    [forceFullDisplay]=\"forceFullDisplay\"\r\n    [videoStream]=\"videoStream\"\r\n    [backgroundColor]=\"backgroundColor\"\r\n    [doMirror]=\"doMirror\"\r\n  ></app-card-video-display>\r\n\r\n  <div\r\n    *ngIf=\"showInfo\"\r\n    [ngClass]=\"showControls ? 'overlayWeb' : 'overlayWebAlt'\"\r\n    [ngStyle]=\"getOverlayPosition(infoPosition)\"\r\n  >\r\n    <div class=\"nameColumn\">\r\n      <span class=\"nameText\" [style.color]=\"textColor\">{{\r\n        participant.name\r\n      }}</span>\r\n    </div>\r\n    <div *ngIf=\"showWaveform\" class=\"waveformWeb\">\r\n      <div\r\n        *ngFor=\"let animation of waveformAnimations; let i = index\"\r\n        class=\"bar\"\r\n        [ngStyle]=\"{\r\n          height: animation === 0 ? '1px' : '16px',\r\n          backgroundColor: barColor\r\n        }\"\r\n      ></div>\r\n    </div>\r\n  </div>\r\n\r\n  <div\r\n    *ngIf=\"showControls\"\r\n    class=\"overlayControls\"\r\n    [ngStyle]=\"getOverlayPosition(controlsPosition)\"\r\n  >\r\n    <ng-container *ngIf=\"!videoControlsComponent\">\r\n      <div class=\"overlayControls\">\r\n        <button class=\"controlButton\" (click)=\"toggleAudio()\">\r\n          <fa-icon\r\n            [icon]=\"participant.muted ? faMicrophoneSlash : faMicrophone\"\r\n            [style.color]=\"participant.muted ? 'red' : 'green'\"\r\n          ></fa-icon>\r\n        </button>\r\n        <button class=\"controlButton\" (click)=\"toggleVideo()\">\r\n          <fa-icon\r\n            [icon]=\"participant['videoOn'] ? faVideo : faVideoSlash\"\r\n            [style.color]=\"participant['videoOn'] ? 'green' : 'red'\"\r\n          ></fa-icon>\r\n        </button>\r\n      </div>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"videoControlsComponent\">\r\n      <ng-container *ngIf=\"isCustomComponent(videoControlsComponent)\">\r\n        <ng-container\r\n          *ngComponentOutlet=\"\r\n            videoControlsComponent.component;\r\n            injector: videoControlsComponent.injector\r\n          \"\r\n        ></ng-container>\r\n      </ng-container>\r\n      <ng-container *ngIf=\"!isCustomComponent(videoControlsComponent)\">\r\n        <div [innerHTML]=\"videoControlsComponent.outerHTML\"></div>\r\n      </ng-container>\r\n    </ng-container>\r\n  </div>\r\n</div>\r\n", styles: [".video-card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f;border:2px solid black;position:relative}.overlayWeb{position:absolute;min-width:40%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.overlayWebAlt{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr;grid-gap:0px;top:0;right:0}.overlayControls{display:flex;flex-direction:row;padding:0;position:absolute;top:0;left:0}.controlButton{justify-content:center;align-items:center;background-color:#0003;padding:2px 4px;margin-right:2px;font-size:medium;border:none;cursor:pointer}.nameColumn{justify-content:center;align-items:center;background-color:#00000080;padding:5px;margin-right:2px;font-size:small;text-align:center}.nameText{font-size:small;font-weight:bolder}.waveformWeb{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin:0 1px;transition:height .5s ease}\n"] }]
        }], ctorParameters: () => [{ type: ControlMedia }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['name']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['barColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['textColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageSource']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['roundedImage']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['remoteProducerId']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['eventType']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['forceFullDisplay']
                }] }, { type: MediaStream, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['videoStream']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showControls']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showInfo']
                }] }, { type: HTMLElement, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['videoInfoComponent']
                }] }, { type: HTMLElement, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['videoControlsComponent']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['controlsPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['infoPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['participant']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['backgroundColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['audioDecibels']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['doMirror']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }], propDecorators: { customStyle: [{
                type: Input
            }], name: [{
                type: Input
            }], barColor: [{
                type: Input
            }], textColor: [{
                type: Input
            }], imageSource: [{
                type: Input
            }], roundedImage: [{
                type: Input
            }], imageStyle: [{
                type: Input
            }], remoteProducerId: [{
                type: Input
            }], eventType: [{
                type: Input
            }], forceFullDisplay: [{
                type: Input
            }], videoStream: [{
                type: Input
            }], showControls: [{
                type: Input
            }], showInfo: [{
                type: Input
            }], videoInfoComponent: [{
                type: Input
            }], videoControlsComponent: [{
                type: Input
            }], controlsPosition: [{
                type: Input
            }], infoPosition: [{
                type: Input
            }], participant: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], audioDecibels: [{
                type: Input
            }], doMirror: [{
                type: Input
            }], parameters: [{
                type: Input
            }] } });

/**
 * AudioCard component renders an audio card for participants with customizable options and media controls.
 * It shows audio waveform animations, video/audio toggle buttons, and additional info based on injected or passed properties.
 *
 * @selector app-audio-card
 * @standalone true
 * @imports CommonModule, FontAwesomeModule, MiniCard
 *
 * @inputs
 * - `controlUserMedia` (function): Optional function to control media actions for a participant.
 * - `customStyle` (Partial<CSSStyleDeclaration>): Custom CSS styles for the audio card.
 * - `name` (string): Name of the participant.
 * - `barColor` (string): Color for the audio bar. Default is 'red'.
 * - `textColor` (string): Text color. Default is 'white'.
 * - `imageSource` (string): Image source URL for participant.
 * - `roundedImage` (boolean): Toggle for rounded image style.
 * - `imageStyle` (Partial<CSSStyleDeclaration>): Custom styles for the image.
 * - `showControls` (boolean): Toggle for displaying media controls. Default is true.
 * - `showInfo` (boolean): Toggle for displaying info section. Default is true.
 * - `videoInfoComponent` (HTMLElement | CustomComponent): Custom component for participant info.
 * - `videoControlsComponent` (HTMLElement | CustomComponent): Custom component for video controls.
 * - `controlsPosition` (ControlsPosition): Position for controls on the card. Default is 'topLeft'.
 * - `infoPosition` (InfoPosition): Position for the info section. Default is 'topRight'.
 * - `participant` (Participant | null): Participant object reference.
 * - `backgroundColor` (string): Background color for the card.
 * - `audioDecibels` (AudioDecibels): Optional audio decibel levels for the participant.
 * - `parameters` (AudioCardParameters): Required object with configuration parameters.
 *
 * @methods
 * - `ngOnInit()`: Initializes the component, sets default media control behavior, and activates audio waveform animations.
 * - `ngOnDestroy()`: Clears the animation interval.
 * - `animateBar(index: number)`: Animates the audio bar at a specified index.
 * - `animateWaveform()`: Triggers animations across the waveform bars.
 * - `resetWaveform()`: Resets waveform animations to default.
 * - `getAnimationDuration(index: number)`: Retrieves the animation duration for a bar by index.
 * - `toggleAudio()`: Toggles audio for the participant if media control function is defined.
 * - `toggleVideo()`: Toggles video for the participant if media control function is defined.
 * - `renderControls()`: Returns `showControls` to render or hide media controls.
 * - `combineStyles(baseStyle: any, additionalStyles: any)`: Combines base and additional styles for inline styling.
 * - `getOverlayPosition(position: string)`: Retrieves calculated overlay position for elements.
 * - `isCustomComponent(comp: HTMLElement | CustomComponent)`: Type guard for identifying custom components.
 * - `isFunctionComponent(comp: HTMLElement | CustomComponent)`: Type guard for identifying function components.
 *
 * @example
 * ```html
 * <app-audio-card
 *  [controlUserMedia]="controlMediaFunction"
 * [name]="participantName"
 * [barColor]="'blue'"
 * [textColor]="'black'"
 * [imageSource]="participantImageURL"
 * [roundedImage]="true"
 * [showControls]="true"
 * [participant]="participant"
 * [parameters]="audioCardParameters">
 * </app-audio-card>
 * ```
 *
 **/
class AudioCard {
    ngZone;
    controlMediaService;
    controlUserMedia;
    customStyle = {};
    name = '';
    barColor = 'red';
    textColor = 'white';
    imageSource = '';
    roundedImage = false;
    imageStyle = {};
    showControls = true;
    showInfo = true;
    videoInfoComponent; // Custom component for participant information
    videoControlsComponent; // Custom component for video controls
    controlsPosition = 'topLeft';
    infoPosition = 'topRight';
    participant = null;
    backgroundColor = '';
    audioDecibels;
    parameters;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    waveformAnimations = Array.from({ length: 9 }, () => 0);
    showWaveform = true;
    interval;
    constructor(ngZone, controlMediaService, injectedControlUserMedia, injectedCustomStyle, injectedName, injectedBarColor, injectedTextColor, injectedImageSource, injectedRoundedImage, injectedImageStyle, injectedShowControls, injectedShowInfo, injectedVideoInfoComponent, injectedVideoControlsComponent, injectedControlsPosition, injectedInfoPosition, injectedParticipant, injectedBackgroundColor, injectedAudioDecibels, injectedParameters) {
        this.ngZone = ngZone;
        this.controlMediaService = controlMediaService;
        this.controlUserMedia = injectedControlUserMedia || this.controlUserMedia;
        this.customStyle = injectedCustomStyle || this.customStyle;
        this.name = injectedName || this.name;
        this.barColor = injectedBarColor || this.barColor;
        this.textColor = injectedTextColor || this.textColor;
        this.imageSource = injectedImageSource || this.imageSource;
        this.roundedImage = injectedRoundedImage || this.roundedImage;
        this.imageStyle = injectedImageStyle || this.imageStyle;
        this.showControls = injectedShowControls != null ? injectedShowControls : this.showControls;
        this.showInfo = injectedShowInfo != null ? injectedShowInfo : this.showInfo;
        this.videoInfoComponent = injectedVideoInfoComponent || this.videoInfoComponent;
        this.videoControlsComponent = injectedVideoControlsComponent || this.videoControlsComponent;
        this.controlsPosition = injectedControlsPosition || this.controlsPosition;
        this.infoPosition = injectedInfoPosition || this.infoPosition;
        this.participant = injectedParticipant || this.participant;
        this.backgroundColor = injectedBackgroundColor || this.backgroundColor;
        this.audioDecibels = injectedAudioDecibels || this.audioDecibels;
        this.parameters = injectedParameters || this.parameters;
    }
    ngOnInit() {
        if (!this.controlUserMedia) {
            this.controlUserMedia = async (options) => {
                await this.controlMediaService.controlMedia(options);
            };
        }
        if (this.parameters) {
            this.ngZone.runOutsideAngular(() => {
                this.interval = setInterval(() => {
                    const { audioDecibels, participants } = this.parameters.getUpdatedAllParams();
                    const existingEntry = audioDecibels.find((entry) => entry.name == this.name);
                    this.participant = participants.find((p) => p.name == this.name) || null;
                    if (existingEntry &&
                        existingEntry.averageLoudness > 127.5 &&
                        this.participant &&
                        !this.participant.muted) {
                        this.animateWaveform();
                    }
                    else {
                        this.resetWaveform();
                    }
                }, 1000);
            });
        }
        if (this.participant?.muted) {
            this.showWaveform = false;
        }
        else {
            this.showWaveform = true;
        }
    }
    ngOnDestroy() {
        clearInterval(this.interval);
    }
    animateBar(index) {
        this.waveformAnimations[index] = 1;
        setTimeout(() => {
            this.waveformAnimations[index] = 0;
        }, this.getAnimationDuration(index));
    }
    animateWaveform() {
        this.waveformAnimations.forEach((_, index) => {
            setInterval(() => this.animateBar(index), this.getAnimationDuration(index) * 2);
        });
    }
    resetWaveform() {
        this.waveformAnimations.fill(0);
    }
    getAnimationDuration(index) {
        const durations = [474, 433, 407, 458, 400, 427, 441, 419, 487];
        return durations[index] || 0;
    }
    async toggleAudio() {
        if (this.participant && !this.participant.muted) {
            await this.controlUserMedia?.({
                participantId: this.participant.id || '',
                participantName: this.participant.name,
                type: 'audio',
                socket: this.parameters.socket,
                coHostResponsibility: this.parameters.coHostResponsibility,
                roomName: this.parameters.roomName,
                showAlert: this.parameters.showAlert,
                coHost: this.parameters.coHost,
                islevel: this.parameters.islevel,
                member: this.parameters.member,
                participants: this.parameters.participants,
            });
        }
    }
    async toggleVideo() {
        if (this.participant) {
            await this.controlUserMedia?.({
                participantId: this.participant.id || '',
                participantName: this.participant.name,
                type: 'video',
                socket: this.parameters.socket,
                coHostResponsibility: this.parameters.coHostResponsibility,
                roomName: this.parameters.roomName,
                showAlert: this.parameters.showAlert,
                coHost: this.parameters.coHost,
                islevel: this.parameters.islevel,
                member: this.parameters.member,
                participants: this.parameters.participants,
            });
        }
    }
    renderControls() {
        return this.showControls;
    }
    // Helper method to combine styles
    combineStyles(baseStyle, additionalStyles) {
        return { ...baseStyle, ...additionalStyles };
    }
    getOverlayPosition(position) {
        return getOverlayPosition({ position });
    }
    isCustomComponent(comp) {
        return (typeof comp.component !== 'function' &&
            comp.component !== undefined);
    }
    isFunctionComponent(comp) {
        return typeof comp === 'function';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AudioCard, deps: [{ token: i0.NgZone }, { token: ControlMedia }, { token: 'controlUserMedia', optional: true }, { token: 'customStyle', optional: true }, { token: 'name', optional: true }, { token: 'barColor', optional: true }, { token: 'textColor', optional: true }, { token: 'imageSource', optional: true }, { token: 'roundedImage', optional: true }, { token: 'imageStyle', optional: true }, { token: 'showControls', optional: true }, { token: 'showInfo', optional: true }, { token: 'videoInfoComponent', optional: true }, { token: 'videoControlsComponent', optional: true }, { token: 'controlsPosition', optional: true }, { token: 'infoPosition', optional: true }, { token: 'participant', optional: true }, { token: 'backgroundColor', optional: true }, { token: 'audioDecibels', optional: true }, { token: 'parameters', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: AudioCard, isStandalone: true, selector: "app-audio-card", inputs: { controlUserMedia: "controlUserMedia", customStyle: "customStyle", name: "name", barColor: "barColor", textColor: "textColor", imageSource: "imageSource", roundedImage: "roundedImage", imageStyle: "imageStyle", showControls: "showControls", showInfo: "showInfo", videoInfoComponent: "videoInfoComponent", videoControlsComponent: "videoControlsComponent", controlsPosition: "controlsPosition", infoPosition: "infoPosition", participant: "participant", backgroundColor: "backgroundColor", audioDecibels: "audioDecibels", parameters: "parameters" }, ngImport: i0, template: "<div\r\n  class=\"card\"\r\n  [ngStyle]=\"customStyle\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n>\r\n  <ng-container *ngIf=\"imageSource; else noImage\">\r\n    <div class=\"imageContainer\">\r\n      <img\r\n        [src]=\"imageSource\"\r\n        [ngStyle]=\"\r\n          combineStyles(imageStyle, {\r\n            'border-radius': roundedImage ? '20%' : '0'\r\n          })\r\n        \"\r\n        class=\"backgroundImage\"\r\n      />\r\n    </div>\r\n  </ng-container>\r\n  <ng-template #noImage>\r\n    <div style=\"width: 100%; height: 100%\">\r\n      <app-mini-card [initials]=\"name\" [fontSize]=\"20\" [ngStyle]=\"{ 'border': parameters.eventType === 'broadcast' ? '2px solid black' : '0px solid black' }\"></app-mini-card>\r\n    </div>\r\n  </ng-template>\r\n\r\n  <ng-container *ngIf=\"showInfo\">\r\n    <div\r\n      class=\"overlay\"\r\n      [ngStyle]=\"getOverlayPosition(infoPosition)\"\r\n      [ngClass]=\"showControls ? 'overlayWeb' : 'overlayWebAlt'\"\r\n    >\r\n      <div class=\"nameColumn\">\r\n        <p [ngStyle]=\"{ color: textColor }\" class=\"nameText\">{{ name }}</p>\r\n      </div>\r\n      <div *ngIf=\"showWaveform\" class=\"waveformWeb\">\r\n        <div\r\n          *ngFor=\"let animation of waveformAnimations\"\r\n          [ngStyle]=\"{\r\n            height: animation === 0 ? '1px' : '12px',\r\n            backgroundColor: barColor\r\n          }\"\r\n          class=\"bar\"\r\n        ></div>\r\n      </div>\r\n    </div>\r\n  </ng-container>\r\n\r\n  <ng-container *ngIf=\"renderControls()\">\r\n    <div\r\n      class=\"overlayControls\"\r\n      [ngStyle]=\"getOverlayPosition(controlsPosition)\"\r\n    >\r\n      <ng-container *ngIf=\"!videoControlsComponent\">\r\n        <button class=\"controlButton\" (click)=\"toggleAudio()\">\r\n          <fa-icon\r\n            [icon]=\"participant?.muted ? faMicrophoneSlash : faMicrophone\"\r\n            [style.color]=\"participant?.muted ? 'red' : 'green'\"\r\n          ></fa-icon>\r\n        </button>\r\n        <button class=\"controlButton\" (click)=\"toggleVideo()\">\r\n          <fa-icon\r\n            [icon]=\"participant?.['videoOn'] ? faVideo : faVideoSlash\"\r\n            [style.color]=\"participant?.['videoOn'] ? 'green' : 'red'\"\r\n          ></fa-icon>\r\n        </button>\r\n      </ng-container>\r\n      <ng-container *ngIf=\"videoControlsComponent\">\r\n        <ng-container *ngIf=\"isCustomComponent(videoControlsComponent)\">\r\n          <ng-container\r\n            *ngComponentOutlet=\"\r\n              videoControlsComponent.component;\r\n              injector: videoControlsComponent.injector\r\n            \"\r\n          ></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!isCustomComponent(videoControlsComponent)\">\r\n          <div [innerHTML]=\"videoControlsComponent.outerHTML\"></div>\r\n        </ng-container>\r\n      </ng-container>\r\n    </div>\r\n  </ng-container>\r\n</div>\r\n", styles: [".card{width:100%;height:100%;margin:0;padding:0;background-color:transparent;position:relative}.imageContainer{display:flex;justify-content:center;align-items:center;width:100%;height:100%}.backgroundImage{width:80px;height:80px;border-radius:50%}.overlayWeb{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.overlayWebAlt{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr;grid-gap:0px;top:0;right:0}.overlayControls{display:flex;flex-direction:row;padding:0;position:absolute;top:0;left:0}.controlButton{justify-content:center;align-items:center;background-color:#0003;padding:0 5px;margin-right:2px;font-size:medium;border:none;cursor:pointer}.nameColumn{justify-content:center;align-items:center;background-color:#00000080;padding:5px 0 0;margin-right:2px;font-size:small;text-align:center;min-height:4%;max-height:70%}.nameText{font-size:small;font-weight:bolder}.waveformWeb{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row;min-height:4%;max-height:70%}.waveformMobile{flex-direction:row;align-items:center;background-color:#0000000d;padding:0;max-width:25%;margin:0}.bar{flex:1;opacity:.75;margin:0 1px;transition:height .5s ease}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: MiniCard, selector: "app-mini-card", inputs: ["initials", "fontSize", "customStyle", "imageSource", "roundedImage", "imageStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AudioCard, decorators: [{
            type: Component,
            args: [{ selector: 'app-audio-card', imports: [CommonModule, FontAwesomeModule, MiniCard], template: "<div\r\n  class=\"card\"\r\n  [ngStyle]=\"customStyle\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n>\r\n  <ng-container *ngIf=\"imageSource; else noImage\">\r\n    <div class=\"imageContainer\">\r\n      <img\r\n        [src]=\"imageSource\"\r\n        [ngStyle]=\"\r\n          combineStyles(imageStyle, {\r\n            'border-radius': roundedImage ? '20%' : '0'\r\n          })\r\n        \"\r\n        class=\"backgroundImage\"\r\n      />\r\n    </div>\r\n  </ng-container>\r\n  <ng-template #noImage>\r\n    <div style=\"width: 100%; height: 100%\">\r\n      <app-mini-card [initials]=\"name\" [fontSize]=\"20\" [ngStyle]=\"{ 'border': parameters.eventType === 'broadcast' ? '2px solid black' : '0px solid black' }\"></app-mini-card>\r\n    </div>\r\n  </ng-template>\r\n\r\n  <ng-container *ngIf=\"showInfo\">\r\n    <div\r\n      class=\"overlay\"\r\n      [ngStyle]=\"getOverlayPosition(infoPosition)\"\r\n      [ngClass]=\"showControls ? 'overlayWeb' : 'overlayWebAlt'\"\r\n    >\r\n      <div class=\"nameColumn\">\r\n        <p [ngStyle]=\"{ color: textColor }\" class=\"nameText\">{{ name }}</p>\r\n      </div>\r\n      <div *ngIf=\"showWaveform\" class=\"waveformWeb\">\r\n        <div\r\n          *ngFor=\"let animation of waveformAnimations\"\r\n          [ngStyle]=\"{\r\n            height: animation === 0 ? '1px' : '12px',\r\n            backgroundColor: barColor\r\n          }\"\r\n          class=\"bar\"\r\n        ></div>\r\n      </div>\r\n    </div>\r\n  </ng-container>\r\n\r\n  <ng-container *ngIf=\"renderControls()\">\r\n    <div\r\n      class=\"overlayControls\"\r\n      [ngStyle]=\"getOverlayPosition(controlsPosition)\"\r\n    >\r\n      <ng-container *ngIf=\"!videoControlsComponent\">\r\n        <button class=\"controlButton\" (click)=\"toggleAudio()\">\r\n          <fa-icon\r\n            [icon]=\"participant?.muted ? faMicrophoneSlash : faMicrophone\"\r\n            [style.color]=\"participant?.muted ? 'red' : 'green'\"\r\n          ></fa-icon>\r\n        </button>\r\n        <button class=\"controlButton\" (click)=\"toggleVideo()\">\r\n          <fa-icon\r\n            [icon]=\"participant?.['videoOn'] ? faVideo : faVideoSlash\"\r\n            [style.color]=\"participant?.['videoOn'] ? 'green' : 'red'\"\r\n          ></fa-icon>\r\n        </button>\r\n      </ng-container>\r\n      <ng-container *ngIf=\"videoControlsComponent\">\r\n        <ng-container *ngIf=\"isCustomComponent(videoControlsComponent)\">\r\n          <ng-container\r\n            *ngComponentOutlet=\"\r\n              videoControlsComponent.component;\r\n              injector: videoControlsComponent.injector\r\n            \"\r\n          ></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!isCustomComponent(videoControlsComponent)\">\r\n          <div [innerHTML]=\"videoControlsComponent.outerHTML\"></div>\r\n        </ng-container>\r\n      </ng-container>\r\n    </div>\r\n  </ng-container>\r\n</div>\r\n", styles: [".card{width:100%;height:100%;margin:0;padding:0;background-color:transparent;position:relative}.imageContainer{display:flex;justify-content:center;align-items:center;width:100%;height:100%}.backgroundImage{width:80px;height:80px;border-radius:50%}.overlayWeb{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.overlayWebAlt{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr;grid-gap:0px;top:0;right:0}.overlayControls{display:flex;flex-direction:row;padding:0;position:absolute;top:0;left:0}.controlButton{justify-content:center;align-items:center;background-color:#0003;padding:0 5px;margin-right:2px;font-size:medium;border:none;cursor:pointer}.nameColumn{justify-content:center;align-items:center;background-color:#00000080;padding:5px 0 0;margin-right:2px;font-size:small;text-align:center;min-height:4%;max-height:70%}.nameText{font-size:small;font-weight:bolder}.waveformWeb{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row;min-height:4%;max-height:70%}.waveformMobile{flex-direction:row;align-items:center;background-color:#0000000d;padding:0;max-width:25%;margin:0}.bar{flex:1;opacity:.75;margin:0 1px;transition:height .5s ease}\n"] }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: ControlMedia }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['controlUserMedia']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['name']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['barColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['textColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageSource']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['roundedImage']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showControls']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showInfo']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['videoInfoComponent']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['videoControlsComponent']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['controlsPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['infoPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['participant']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['backgroundColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['audioDecibels']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }], propDecorators: { controlUserMedia: [{
                type: Input
            }], customStyle: [{
                type: Input
            }], name: [{
                type: Input
            }], barColor: [{
                type: Input
            }], textColor: [{
                type: Input
            }], imageSource: [{
                type: Input
            }], roundedImage: [{
                type: Input
            }], imageStyle: [{
                type: Input
            }], showControls: [{
                type: Input
            }], showInfo: [{
                type: Input
            }], videoInfoComponent: [{
                type: Input
            }], videoControlsComponent: [{
                type: Input
            }], controlsPosition: [{
                type: Input
            }], infoPosition: [{
                type: Input
            }], participant: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], audioDecibels: [{
                type: Input
            }], parameters: [{
                type: Input
            }] } });

/**
 * @service AddVideosGrid
 * @description Service to manage and update video and audio components on a grid in the user interface. This service helps organize and configure participants and streams into different grid layouts.
 *
 * @method addVideosGrid
 * Adds video and audio cards to the main and alternate grids based on the parameters and configuration options provided.
 *
 * @param {AddVideosGridOptions} options - Configuration options for setting up the grid.
 * @param {(Stream | Participant)[]} options.mainGridStreams - Streams or participants to display on the main grid.
 * @param {(Stream | Participant)[]} options.altGridStreams - Streams or participants to display on the alternate grid.
 * @param {number} options.numtoadd - The number of items to add to the grid.
 * @param {number} options.numRows - The number of rows for the main grid.
 * @param {number} options.numCols - The number of columns for the main grid.
 * @param {number} options.actualRows - The actual rows currently displayed.
 * @param {number} options.lastrowcols - The number of columns in the last row of the grid.
 * @param {boolean} options.removeAltGrid - Whether to remove the alternate grid layout.
 * @param {AddVideosGridParameters} options.parameters - Additional parameters for updating the grid, controlling appearance, and handling events.
 *
 * @returns {Promise<void>} A promise that resolves once the grid layout is updated.
 *
 * @example
 * ```typescript
 * await addVideosGridService.addVideosGrid({
 *   mainGridStreams: [...],
 *   altGridStreams: [...],
 *   numtoadd: 4,
 *   numRows: 2,
 *   numCols: 2,
 *   actualRows: 2,
 *   lastrowcols: 2,
 *   removeAltGrid: false,
 *   parameters: {
 *     eventType: 'webinar',
 *     updateAddAltGrid: (value) => {},
 *     ref_participants: participantsList,
 *     islevel: '1',
 *     videoAlreadyOn: true,
 *     localStreamVideo: localStream,
 *     keepBackground: true,
 *     virtualStream: virtualStream,
 *     forceFullDisplay: false,
 *     otherGridStreams: otherStreamsArray,
 *     updateOtherGridStreams: (newStreams) => {},
 *     updateMiniCardsGrid: (params) => {},
 *     getUpdatedAllParams: () => ({ /* updated parameters * / }),
 *   },
 * });
 * ```
 */
class AddVideosGrid {
    addVideosGrid = async ({ mainGridStreams, altGridStreams, numtoadd, numRows, numCols, actualRows, lastrowcols, removeAltGrid, parameters, }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = { ...parameters, ...getUpdatedAllParams() };
        let { eventType, updateAddAltGrid, ref_participants, islevel, videoAlreadyOn, localStreamVideo, keepBackground, virtualStream, forceFullDisplay, otherGridStreams, updateOtherGridStreams, updateMiniCardsGrid, } = parameters;
        let newComponents = [[], []];
        let participant;
        let remoteProducerId = '';
        let participant_ = null;
        numtoadd = mainGridStreams.length;
        if (removeAltGrid) {
            updateAddAltGrid(false);
        }
        // Add participants to the main grid
        for (let i = 0; i < numtoadd; i++) {
            participant = mainGridStreams[i];
            remoteProducerId = participant.producerId;
            let pseudoName = !remoteProducerId || remoteProducerId === '';
            if (pseudoName) {
                participant_ = participant;
                remoteProducerId = await participant.name;
                if (Object.prototype.hasOwnProperty.call(participant, 'audioID') &&
                    participant.audioID != null &&
                    participant.audioID !== '') {
                    newComponents[0].push({
                        component: AudioCard,
                        inputs: {
                            name: participant.name,
                            barColor: 'red',
                            textColor: 'white',
                            customStyle: {
                                backgroundColor: 'transparent',
                                border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                            },
                            controlsPosition: 'topLeft',
                            infoPosition: 'topRight',
                            showWaveform: true,
                            roundedImage: true,
                            parameters,
                            backgroundColor: 'transparent',
                            showControls: eventType !== 'chat',
                            participant,
                        },
                    });
                }
                else {
                    newComponents[0].push({
                        component: MiniCard,
                        inputs: {
                            initials: participant.name,
                            fontSize: 20,
                            customStyle: {
                                backgroundColor: 'transparent',
                                border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                            },
                        },
                    });
                }
            }
            else {
                if (remoteProducerId === 'youyou' || remoteProducerId === 'youyouyou') {
                    let name = 'You';
                    if (islevel === '2' && eventType !== 'chat') {
                        name = 'You (Host)';
                    }
                    if (!videoAlreadyOn) {
                        name = 'You';
                        if (islevel == '2' && eventType != 'chat') {
                            name = 'You (Host)';
                        }
                        newComponents[0].push({
                            component: MiniCard,
                            inputs: {
                                initials: name,
                                fontSize: 20,
                                customStyle: {
                                    backgroundColor: 'transparent',
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                            },
                        });
                    }
                    else {
                        participant = {
                            id: 'youyouyou',
                            stream: keepBackground && virtualStream ? virtualStream : localStreamVideo,
                            name: 'youyouyou',
                            muted: true,
                        };
                        participant_ = {
                            id: 'youyou',
                            videoID: 'youyou',
                            name: 'youyouyou',
                            stream: keepBackground && virtualStream ? virtualStream : localStreamVideo,
                        };
                        remoteProducerId = 'youyouyou';
                        newComponents[0].push({
                            component: VideoCard,
                            inputs: {
                                videoStream: participant.stream ? participant.stream : null,
                                remoteProducerId: participant.stream ? participant.stream.id : null,
                                eventType,
                                forceFullDisplay: eventType == 'webinar' ? false : forceFullDisplay,
                                customStyle: {
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                                participant: participant,
                                backgroundColor: 'transparent',
                                showControls: false,
                                showInfo: false,
                                name: participant.name,
                                doMirror: true,
                                parameters,
                            },
                        });
                    }
                }
                else {
                    participant_ = ref_participants.find((obj) => obj.videoID === remoteProducerId);
                    if (participant_) {
                        newComponents[0].push({
                            component: VideoCard,
                            inputs: {
                                videoStream: participant.stream ? participant.stream : null,
                                remoteProducerId,
                                eventType,
                                forceFullDisplay,
                                customStyle: {
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                                participant: participant_,
                                backgroundColor: 'transparent',
                                showControls: eventType !== 'chat',
                                showInfo: true,
                                name: participant_.name,
                                doMirror: false,
                                parameters,
                            },
                        });
                    }
                }
            }
            if (i === numtoadd - 1) {
                otherGridStreams[0] = newComponents[0];
                await updateMiniCardsGrid({
                    rows: numRows,
                    cols: numCols,
                    defal: true,
                    actualRows: actualRows,
                    parameters,
                });
                updateOtherGridStreams(otherGridStreams);
                await updateMiniCardsGrid({
                    rows: numRows,
                    cols: numCols,
                    defal: true,
                    actualRows,
                    parameters,
                });
            }
        }
        // Handle the alternate grid streams
        if (!removeAltGrid) {
            for (let i = 0; i < altGridStreams.length; i++) {
                participant = altGridStreams[i];
                remoteProducerId = participant.producerId;
                let participant_;
                let pseudoName = false;
                //check if there is .name in the participant object and if it is null
                if (Object.prototype.hasOwnProperty.call(participant, 'producerId') &&
                    participant.producerId != null &&
                    participant.producerId !== '') {
                    //actual video
                    pseudoName = false;
                }
                else {
                    pseudoName = true;
                }
                if (pseudoName) {
                    participant_ = participant;
                    remoteProducerId = await participant.name;
                    if (Object.prototype.hasOwnProperty.call(participant, 'audioID') &&
                        participant.audioID != null &&
                        participant.audioID !== '') {
                        newComponents[1].push({
                            component: AudioCard,
                            inputs: {
                                name: participant.name,
                                barColor: 'red',
                                textColor: 'white',
                                customStyle: {
                                    backgroundColor: 'transparent',
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                                controlsPosition: 'topLeft',
                                infoPosition: 'topRight',
                                showWaveform: true,
                                roundedImage: true,
                                parameters,
                                backgroundColor: 'transparent',
                                showControls: eventType !== 'chat',
                                participant,
                            },
                        });
                    }
                    else {
                        newComponents[1].push({
                            component: MiniCard,
                            inputs: {
                                initials: participant.name,
                                fontSize: 20,
                                customStyle: {
                                    backgroundColor: 'transparent',
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                            },
                        });
                    }
                }
                else {
                    participant_ = ref_participants.find((obj) => obj.videoID === remoteProducerId);
                    newComponents[1].push({
                        component: VideoCard,
                        inputs: {
                            videoStream: participant_ && participant_['stream'] ? participant_['stream'] : null,
                            remoteProducerId,
                            eventType,
                            forceFullDisplay,
                            customStyle: {
                                border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                            },
                            participant: participant_,
                            backgroundColor: 'transparent',
                            showControls: eventType !== 'chat',
                            showInfo: true,
                            name: participant.name,
                            doMirror: false,
                            parameters,
                        },
                    });
                }
                if (i === numtoadd - 1) {
                    otherGridStreams[1] = newComponents[1];
                    await updateMiniCardsGrid({
                        rows: 1,
                        cols: lastrowcols,
                        defal: false,
                        actualRows,
                        parameters,
                    });
                    updateOtherGridStreams(otherGridStreams);
                    await updateMiniCardsGrid({
                        rows: 1,
                        cols: lastrowcols,
                        defal: false,
                        actualRows,
                        parameters,
                    });
                }
            }
        }
        else {
            updateAddAltGrid(false);
            otherGridStreams[1] = [];
            await updateMiniCardsGrid({
                rows: 0,
                cols: 0,
                defal: false,
                actualRows: actualRows,
                parameters,
            });
            updateOtherGridStreams(otherGridStreams);
            await updateMiniCardsGrid({
                rows: 0,
                cols: 0,
                defal: false,
                actualRows,
                parameters,
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AddVideosGrid, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AddVideosGrid, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AddVideosGrid, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * @service AutoAdjust
 * @description Service to auto-adjust layout values based on the event type, number of participants, and sharing conditions. Useful for dynamically adjusting UI elements in different event settings.
 *
 * @method autoAdjust
 * Dynamically calculates and adjusts layout values (e.g., grid columns) based on conditions such as event type, participant count, and sharing status.
 *
 * @param {AutoAdjustOptions} options - Configuration options for the auto-adjustment.
 * @param {number} options.n - Number of participants in the event.
 * @param {EventType} options.eventType - Type of event (e.g., 'broadcast', 'chat', 'conference').
 * @param {boolean} options.shareScreenStarted - Indicates whether screen sharing is active.
 * @param {boolean} options.shared - Indicates if another resource is currently shared.
 *
 * @returns {Promise<number[]>} A promise resolving to an array of two adjusted layout values.
 *
 * @example
 * ```typescript
 * const [primaryLayout, secondaryLayout] = await autoAdjustService.autoAdjust({
 *   n: 5,
 *   eventType: 'conference',
 *   shareScreenStarted: false,
 *   shared: false,
 * });
 * console.log(primaryLayout, secondaryLayout); // Adjusted layout values based on inputs
 * ```
 */
class AutoAdjust {
    /**
     * Adjusts values based on the provided options.
     *
     * @param {AutoAdjustOptions} options - The options for auto adjustment.
     * @param {number} options.n - The number of participants.
     * @param {string} options.eventType - The type of event (e.g., 'broadcast', 'chat', 'conference').
     * @param {boolean} options.shareScreenStarted - Indicates if screen sharing has started.
     * @param {boolean} options.shared - Indicates if something is shared.
     *
     * @returns {Promise<number[]>} A promise that resolves to an array containing the adjusted values.
     */
    async autoAdjust({ n, eventType, shareScreenStarted, shared, }) {
        // Default values
        let val1 = 6;
        let val2 = 12 - val1;
        // Calculate percentage values
        // Adjust values based on eventType and other conditions
        if (eventType === 'broadcast') {
            val1 = 0;
            val2 = 12 - val1;
        }
        else if (eventType === 'chat' ||
            (eventType === 'conference' && !(shareScreenStarted || shared))) {
            val1 = 12;
            val2 = 12 - val1;
        }
        else {
            if (shareScreenStarted || shared) {
                val2 = 10;
                val1 = 12 - val2;
            }
            else {
                // Adjust values based on the number of participants (n)
                if (n === 0) {
                    val1 = 1;
                    val2 = 12 - val1;
                }
                else if (n >= 1 && n < 4) {
                    val1 = 4;
                    val2 = 12 - val1;
                }
                else if (n >= 4 && n < 6) {
                    val1 = 6;
                    val2 = 12 - val1;
                }
                else if (n >= 6 && n < 9) {
                    val1 = 6;
                    val2 = 12 - val1;
                }
                else if (n >= 9 && n < 12) {
                    val1 = 6;
                    val2 = 12 - val1;
                }
                else if (n >= 12 && n < 20) {
                    val1 = 8;
                    val2 = 12 - val1;
                }
                else if (n >= 20 && n < 50) {
                    val1 = 8;
                    val2 = 12 - val1;
                }
                else {
                    val1 = 10;
                    val2 = 12 - val1;
                }
            }
        }
        // Return an array with adjusted values
        return [val1, val2];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AutoAdjust, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AutoAdjust, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AutoAdjust, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * @service CalculateRowsAndColumns
 * @description Service to calculate the optimal number of rows and columns needed to display a given number of items in a grid. Useful for dynamically determining grid layout in responsive designs.
 *
 * @method calculateRowsAndColumns
 * Calculates the optimal number of rows and columns to display a specified number of items in a compact grid format.
 *
 * @param {CalculateRowsAndColumnsOptions} options - Configuration options for row and column calculation.
 * @param {number} options.n - The number of items to display in the grid.
 *
 * @returns {[number, number]} A tuple where the first value is the number of rows and the second is the number of columns.
 *
 * @example
 * ```typescript
 * const [rows, cols] = calculateRowsAndColumnsService.calculateRowsAndColumns({ n: 10 });
 * console.log(rows, cols); // Outputs optimized rows and columns for displaying 10 items
 * ```
 */
class CalculateRowsAndColumns {
    /**
     * Calculates the number of rows and columns needed to display a given number of items in a grid.
     *
     * @param {CalculateRowsAndColumnsOptions} options - The options for calculating rows and columns.
     * @param {number} options.n - The number of items to display.
     * @returns {[number, number]} A tuple containing the number of rows and columns.
     */
    calculateRowsAndColumns({ n }) {
        // Calculate the square root of n
        const sqrt = Math.sqrt(n);
        // Initialize columns based on the floor of the square root
        let cols = Math.floor(sqrt);
        // Calculate the number of rows needed to display n videos
        let rows = Math.ceil(n / cols);
        // Calculate the product of rows and columns
        let prod = rows * cols;
        // Adjust rows and columns until the product is greater than or equal to n
        while (prod < n) {
            if (cols < rows) {
                cols++;
            }
            else {
                rows++;
            }
            prod = rows * cols;
        }
        // Return an array with the calculated number of rows and columns
        return [rows, cols];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CalculateRowsAndColumns, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CalculateRowsAndColumns, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CalculateRowsAndColumns, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Asynchronously changes the video streams based on the provided options.
 *
 * @param {Object} options - The options for changing video streams.
 * @param {boolean} [options.screenChanged=false] - Indicates if the screen has changed.
 * @param {ChangeVidsOptions} options.parameters - The parameters for changing video streams.
 * @returns {Promise<void>} A promise that resolves when the video streams have been changed.
 *
 * @typedef {Object} ChangeVidsOptions
 * @property {Function} getUpdatedAllParams - Function to get updated parameters.
 * @property {Array} allVideoStreams - Array of all video streams.
 * @property {Array} p_activeNames - Array of active participant names.
 * @property {Array} activeNames - Array of active names.
 * @property {Array} dispActiveNames - Array of displayed active names.
 * @property {boolean} shareScreenStarted - Indicates if screen sharing has started.
 * @property {boolean} shared - Indicates if the screen is shared.
 * @property {Array} newLimitedStreams - Array of new limited streams.
 * @property {Array} non_alVideoStreams - Array of non-al video streams.
 * @property {Array} ref_participants - Array of reference participants.
 * @property {Array} participants - Array of participants.
 * @property {string} eventType - Type of the event.
 * @property {string} islevel - Level of the participant.
 * @property {string} member - Name of the member.
 * @property {boolean} sortAudioLoudness - Indicates if audio loudness should be sorted.
 * @property {Array} audioDecibels - Array of audio decibels.
 * @property {Array} mixed_alVideoStreams - Array of mixed al video streams.
 * @property {Array} non_alVideoStreams_muted - Array of muted non-al video streams.
 * @property {string} remoteProducerId - ID of the remote producer.
 * @property {Object} localStreamVideo - Local stream video object.
 * @property {Array} oldAllStreams - Array of old all streams.
 * @property {number} screenPageLimit - Limit of streams per screen page.
 * @property {string} meetingDisplayType - Type of meeting display.
 * @property {boolean} meetingVideoOptimized - Indicates if meeting video is optimized.
 * @property {boolean} recordingVideoOptimized - Indicates if recording video is optimized.
 * @property {string} recordingDisplayType - Type of recording display.
 * @property {Array} paginatedStreams - Array of paginated streams.
 * @property {number} itemPageLimit - Limit of items per page.
 * @property {boolean} doPaginate - Indicates if pagination should be done.
 * @property {boolean} prevDoPaginate - Indicates if pagination was previously done.
 * @property {number} currentUserPage - Current user page number.
 * @property {Array} breakoutRooms - Array of breakout rooms.
 * @property {number} hostNewRoom - Index of the new room for the host.
 * @property {boolean} breakOutRoomStarted - Indicates if breakout room has started.
 * @property {boolean} breakOutRoomEnded - Indicates if breakout room has ended.
 * @property {Object} virtualStream - Virtual stream object.
 * @property {number} mainRoomsLength - Length of main rooms.
 * @property {string} memberRoom - Room of the member.
 * @property {Function} updateP_activeNames - Function to update active participant names.
 * @property {Function} updateActiveNames - Function to update active names.
 * @property {Function} updateDispActiveNames - Function to update displayed active names.
 * @property {Function} updateNewLimitedStreams - Function to update new limited streams.
 * @property {Function} updateNon_alVideoStreams - Function to update non-al video streams.
 * @property {Function} updateRef_participants - Function to update reference participants.
 * @property {Function} updateSortAudioLoudness - Function to update audio loudness sorting.
 * @property {Function} updateMixed_alVideoStreams - Function to update mixed al video streams.
 * @property {Function} updateNon_alVideoStreams_muted - Function to update muted non-al video streams.
 * @property {Function} updatePaginatedStreams - Function to update paginated streams.
 * @property {Function} updateDoPaginate - Function to update pagination status.
 * @property {Function} updatePrevDoPaginate - Function to update previous pagination status.
 * @property {Function} updateCurrentUserPage - Function to update current user page.
 * @property {Function} updateNumberPages - Function to update number of pages.
 * @property {Function} updateMainRoomsLength - Function to update main rooms length.
 * @property {Function} updateMemberRoom - Function to update member room.
 * @property {Function} mixStreams - Function to mix streams.
 * @property {Function} dispStreams - Function to display streams.
 *
 *
 * @example
 * ```typescript
 * await changeVidsService.changeVids({
 *   screenChanged: true,
 *   parameters: {
 *     allVideoStreams: [], // Your array of video streams
 *     p_activeNames: [], // Active participant names
 *     activeNames: [], // Names of active streams
 *     dispActiveNames: [], // Names of displayed active streams
 *     shareScreenStarted: false,
 *     shared: false,
 *     newLimitedStreams: [], // New limited streams
 *     non_alVideoStreams: [], // Non-audio video streams
 *     ref_participants: [], // Reference participants
 *     participants: [], // All participants
 *     eventType: 'conference', // Type of event
 *     islevel: '1', // Level of the participant
 *     member: 'John Doe', // Member's name
 *     sortAudioLoudness: true,
 *     audioDecibels: [], // Audio decibel levels
 *     mixed_alVideoStreams: [], // Mixed audio/video streams
 *     non_alVideoStreams_muted: [], // Muted non-audio video streams
 *     remoteProducerId: 'abc123',
 *     localStreamVideo: null, // Local video stream
 *     oldAllStreams: [], // Previous streams
 *     screenPageLimit: 4, // Limit of streams per screen
 *     meetingDisplayType: 'grid', // Type of display
 *     meetingVideoOptimized: true, // Video optimization status
 *     recordingVideoOptimized: false, // Recording optimization status
 *     recordingDisplayType: 'video', // Recording display type
 *     paginatedStreams: [], // Paginated streams
 *     itemPageLimit: 2, // Items per page limit
 *     doPaginate: true, // Pagination flag
 *     prevDoPaginate: false, // Previous pagination state
 *     currentUserPage: 1, // Current page number
 *     breakoutRooms: [], // Breakout room information
 *     hostNewRoom: 0, // Host room number
 *     breakOutRoomStarted: false, // Breakout room status
 *     breakOutRoomEnded: false, // Breakout room end status
 *     virtualStream: null, // Virtual stream
 *     mainRoomsLength: 3, // Number of main rooms
 *     memberRoom: 1, // Member's room number
 *     updateP_activeNames: (names) => {}, // Update function for active names
 *     updateActiveNames: (names) => {}, // Update function for all names
 *     updateDispActiveNames: (names) => {}, // Update function for displayed names
 *     updateNewLimitedStreams: (streams) => {}, // Update function for limited streams
 *     updateNon_alVideoStreams: (participants) => {}, // Update function for non-audio streams
 *     updateRef_participants: (participants) => {}, // Update function for reference participants
 *     updateSortAudioLoudness: (sort) => {}, // Update function for sorting audio
 *     updateMixed_alVideoStreams: (streams) => {}, // Update function for mixed streams
 *     updateNon_alVideoStreams_muted: (participants) => {}, // Update function for muted streams
 *     updatePaginatedStreams: (streams) => {}, // Update function for paginated streams
 *     updateDoPaginate: (paginate) => {}, // Update function for pagination
 *     updatePrevDoPaginate: (paginate) => {}, // Update function for previous pagination
 *     updateCurrentUserPage: (page) => {}, // Update function for current page
 *     updateNumberPages: (pages) => {}, // Update function for number of pages
 *     updateMainRoomsLength: (length) => {}, // Update function for main room length
 *     updateMemberRoom: (room) => {}, // Update function for member's room
 *     mixStreams: async ({ streams, displayType }) => {}, // Function to mix streams
 *     dispStreams: async ({ streams, displayType }) => {}, // Function to display streams
 *   },
 * });
 * ```
 */
class ChangeVids {
    changeVids = async ({ screenChanged = false, parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { allVideoStreams, p_activeNames, activeNames, dispActiveNames, shareScreenStarted, shared, newLimitedStreams, non_alVideoStreams, ref_participants, participants, eventType, islevel, member, sortAudioLoudness, audioDecibels, mixed_alVideoStreams, non_alVideoStreams_muted, remoteProducerId, localStreamVideo, oldAllStreams, screenPageLimit, meetingDisplayType, meetingVideoOptimized, recordingVideoOptimized, recordingDisplayType, paginatedStreams, itemPageLimit, doPaginate, prevDoPaginate, currentUserPage, breakoutRooms, hostNewRoom, breakOutRoomStarted, breakOutRoomEnded, virtualStream, mainRoomsLength, memberRoom, updateP_activeNames, updateActiveNames, updateDispActiveNames, updateNewLimitedStreams, updateNon_alVideoStreams, updateRef_participants, updateSortAudioLoudness, updateMixed_alVideoStreams, updateNon_alVideoStreams_muted, updatePaginatedStreams, updateDoPaginate, updatePrevDoPaginate, updateCurrentUserPage, updateNumberPages, updateMainRoomsLength, updateMemberRoom, 
        // mediasfu functions
        mixStreams, dispStreams, } = parameters;
        try {
            let alVideoStreams = [...allVideoStreams];
            p_activeNames = [...activeNames];
            let streame;
            if (shareScreenStarted || shared) {
                alVideoStreams = [...newLimitedStreams];
                activeNames = [];
            }
            activeNames = [];
            dispActiveNames = [];
            ref_participants = participants;
            let temp = alVideoStreams;
            await Promise.all(temp.map(async (stream) => {
                let participant = ref_participants.find((obj) => obj.videoID === stream.producerId);
                if (!participant && stream.producerId !== 'youyou' && stream.producerId !== 'youyouyou') {
                    alVideoStreams = alVideoStreams.filter((obj) => obj.producerId !== stream.producerId);
                }
            }));
            if (eventType === 'broadcast' || eventType === 'chat') {
                sortAudioLoudness = false;
            }
            if (shareScreenStarted || shared) {
                non_alVideoStreams = [];
                non_alVideoStreams_muted = [];
                mixed_alVideoStreams = [];
            }
            else {
                if (alVideoStreams.length > screenPageLimit) {
                    alVideoStreams = alVideoStreams.filter((obj) => obj.producerId !== 'youyou' && obj.producerId !== 'youyouyou');
                    ref_participants = ref_participants.sort((a, b) => (a.muted ?? false) > (b.muted ?? false) ? 1 : -1);
                    let temp = [];
                    await Promise.all(ref_participants.map((participant) => {
                        let stream = alVideoStreams.find((obj) => obj.producerId === participant.videoID);
                        if (stream) {
                            temp.push(stream);
                        }
                    }));
                    alVideoStreams = temp;
                    let youyou = allVideoStreams.find((obj) => obj.producerId === 'youyou');
                    if (!youyou) {
                        let youyouyou = allVideoStreams.find((obj) => obj.producerId === 'youyouyou');
                        if (youyouyou) {
                            alVideoStreams.unshift(youyouyou);
                        }
                    }
                    else {
                        if (youyou) {
                            alVideoStreams.unshift(youyou);
                        }
                    }
                }
                const admin = participants.filter((participant) => participant.islevel === '2');
                let adminName = '';
                if (admin.length > 0) {
                    adminName = admin[0].name || '';
                }
                non_alVideoStreams = [];
                await Promise.all(ref_participants.map(async (participant) => {
                    let stream = alVideoStreams.find((obj) => obj.producerId === participant.videoID);
                    if (eventType !== 'chat' && eventType !== 'conference') {
                        if (!stream &&
                            participant.name !== member &&
                            !participant['muted'] &&
                            participant.name !== adminName) {
                            non_alVideoStreams.push(participant);
                        }
                    }
                    else {
                        if (!stream && participant.name !== member && !participant['muted']) {
                            non_alVideoStreams.push(participant);
                        }
                    }
                }));
                if (sortAudioLoudness) {
                    non_alVideoStreams.sort((a, b) => {
                        const avgLoudnessA = audioDecibels.find((obj) => obj.name === a.name)?.averageLoudness || 127;
                        const avgLoudnessB = audioDecibels.find((obj) => obj.name === b.name)?.averageLoudness || 127;
                        return avgLoudnessB - avgLoudnessA;
                    });
                    if (!(meetingDisplayType === 'video' && meetingVideoOptimized) ||
                        !(recordingVideoOptimized && recordingDisplayType === 'video')) {
                        mixed_alVideoStreams = await mixStreams({
                            alVideoStreams,
                            non_alVideoStreams,
                            ref_participants,
                        });
                    }
                }
                non_alVideoStreams_muted = [];
                await Promise.all(ref_participants.map(async (participant) => {
                    let stream = alVideoStreams.find((obj) => obj.producerId === participant.videoID);
                    if (eventType !== 'chat' && eventType !== 'conference') {
                        if (!stream &&
                            participant.name !== member &&
                            participant['muted'] &&
                            participant.name !== adminName) {
                            non_alVideoStreams_muted.push(participant);
                        }
                    }
                    else {
                        if (!stream && participant.name !== member && participant['muted']) {
                            non_alVideoStreams_muted.push(participant);
                        }
                    }
                }));
            }
            if (eventType === 'conference' && islevel !== '2') {
                let host = participants.find((obj) => obj.islevel === '2');
                if (host) {
                    if (host.videoID) {
                        remoteProducerId = host.videoID;
                    }
                    if (islevel === '2') {
                        host['stream'] = virtualStream || localStreamVideo;
                    }
                    else {
                        let hostVideo = alVideoStreams.find((obj) => obj.producerId === remoteProducerId);
                        if (!hostVideo) {
                            streame = oldAllStreams.find((streame) => streame.producerId === remoteProducerId);
                            if (streame) {
                                alVideoStreams = alVideoStreams.filter((obj) => obj.producerId !== host.videoID);
                                non_alVideoStreams = non_alVideoStreams.filter((obj) => obj.name !== host.name);
                                non_alVideoStreams_muted = non_alVideoStreams_muted.filter((obj) => obj.name !== host.name);
                                if (sortAudioLoudness) {
                                    mixed_alVideoStreams = mixed_alVideoStreams.filter((obj) => obj.name !== host.name);
                                    non_alVideoStreams_muted = non_alVideoStreams_muted.filter((obj) => obj.name !== host.name);
                                    if (meetingDisplayType == 'video' && meetingVideoOptimized) {
                                        alVideoStreams.unshift(streame);
                                    }
                                    else {
                                        mixed_alVideoStreams.unshift(streame);
                                    }
                                }
                                else {
                                    alVideoStreams.unshift(streame);
                                }
                            }
                            else {
                                await Promise.all(ref_participants.map(async (participant) => {
                                    let stream = alVideoStreams.find((obj) => obj.producerId == participant.videoID && participant.name == host.name);
                                    if (stream) {
                                        if (sortAudioLoudness) {
                                            mixed_alVideoStreams = mixed_alVideoStreams.filter((obj) => obj.name !== host.name);
                                            non_alVideoStreams_muted = non_alVideoStreams_muted.filter((obj) => obj.name !== host.name);
                                            mixed_alVideoStreams.unshift(participant);
                                        }
                                        else {
                                            non_alVideoStreams = non_alVideoStreams.filter((obj) => obj.name !== host.name);
                                            non_alVideoStreams.unshift(participant);
                                            return;
                                        }
                                    }
                                }));
                            }
                        }
                    }
                }
            }
            let allStreamsPaged = [];
            if (sortAudioLoudness) {
                if (meetingDisplayType === 'video') {
                    if (meetingVideoOptimized) {
                        allStreamsPaged = [...alVideoStreams];
                    }
                    else {
                        allStreamsPaged = [...mixed_alVideoStreams];
                    }
                }
                else if (meetingDisplayType === 'media') {
                    allStreamsPaged = [...mixed_alVideoStreams];
                }
                else if (meetingDisplayType === 'all') {
                    allStreamsPaged = [...mixed_alVideoStreams, ...non_alVideoStreams_muted];
                }
            }
            else {
                if (meetingDisplayType === 'video') {
                    allStreamsPaged = [...alVideoStreams];
                }
                else if (meetingDisplayType === 'media') {
                    allStreamsPaged = [...alVideoStreams, ...non_alVideoStreams];
                }
                else if (meetingDisplayType === 'all') {
                    allStreamsPaged = [...alVideoStreams, ...non_alVideoStreams, ...non_alVideoStreams_muted];
                }
            }
            paginatedStreams = [];
            let limit = itemPageLimit;
            if (shareScreenStarted || shared) {
                limit = screenPageLimit;
            }
            let firstPage = [];
            let page = [];
            let limit_ = limit + 1;
            if (eventType === 'conference' && !shared && !shareScreenStarted) {
                limit_ = limit_ - 1;
            }
            // Create pagination
            let memberInRoom = false;
            let filterHost = false;
            if (breakOutRoomStarted && !breakOutRoomEnded) {
                let tempBreakoutRooms = JSON.parse(JSON.stringify(breakoutRooms));
                let host = participants.find((obj) => obj.islevel == '2');
                for (let room of tempBreakoutRooms) {
                    try {
                        let currentStreams = [];
                        const roomIndex = tempBreakoutRooms.indexOf(room);
                        if (hostNewRoom != -1 && roomIndex == hostNewRoom) {
                            if (host) {
                                if (!room.map((obj) => obj.name).includes(host.name)) {
                                    room = [...room, { name: host.name, breakRoom: roomIndex }];
                                    filterHost = true;
                                }
                            }
                        }
                        for (let participant of room) {
                            if (participant.name == member && !memberInRoom) {
                                memberInRoom = true;
                                memberRoom = participant.breakRoom;
                                updateMemberRoom(memberRoom);
                            }
                            let streams = allStreamsPaged.filter((stream) => {
                                if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                                    stream.producerId != null &&
                                    stream.producerId !== '') ||
                                    (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                        stream['audioID'] != null &&
                                        stream['audioID'] !== '')) {
                                    let producerId = stream.producerId || stream['audioID'];
                                    let matchingParticipant = ref_participants.find((obj) => obj['audioID'] === producerId ||
                                        obj.videoID === producerId ||
                                        ((producerId == 'youyou' || producerId == 'youyouyou') &&
                                            member == participant.name));
                                    return ((matchingParticipant && matchingParticipant.name === participant.name) ||
                                        (participant.name == member &&
                                            (producerId == 'youyou' || producerId == 'youyouyou')));
                                }
                                else {
                                    return (Object.prototype.hasOwnProperty.call(stream, 'name') &&
                                        stream.name == participant.name);
                                }
                            });
                            for (let stream of streams) {
                                if (currentStreams.length < limit_) {
                                    currentStreams.push(stream);
                                }
                            }
                        }
                        paginatedStreams.push(currentStreams);
                    }
                    catch {
                        /* handle error */
                    }
                }
                let remainingStreams = allStreamsPaged.filter((stream) => {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                        stream.producerId != null &&
                        stream.producerId !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                            stream['audioID'] != null &&
                            stream['audioID'] !== '')) {
                        let producerId = stream.producerId || stream['audioID'];
                        let matchingParticipant = ref_participants.find((obj) => obj['audioID'] === producerId ||
                            obj.videoID === producerId ||
                            ((producerId == 'youyou' || producerId == 'youyouyou') && member == obj.name));
                        return (matchingParticipant &&
                            !breakoutRooms
                                .flat()
                                .map((obj) => obj.name)
                                .includes(matchingParticipant.name) &&
                            (!filterHost || matchingParticipant.name != host?.name));
                    }
                    else {
                        return (!breakoutRooms
                            .flat()
                            .map((obj) => obj.name)
                            .includes(stream.name ?? '') &&
                            (!filterHost || stream.name != host?.name));
                    }
                });
                if (memberInRoom) {
                    let memberStream = allStreamsPaged.find((stream) => {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            return stream.producerId == 'youyou' || stream.producerId == 'youyouyou';
                        }
                        return false; // Add a return statement here
                    });
                    if (memberStream && !remainingStreams.includes(memberStream)) {
                        remainingStreams.unshift(memberStream);
                    }
                }
                let remainingPaginatedStreams = [];
                if (remainingStreams.length > 0) {
                    firstPage = remainingStreams.slice(0, limit_);
                    remainingPaginatedStreams.push(firstPage);
                    for (let i = limit_; i < remainingStreams.length; i += limit) {
                        page = remainingStreams.slice(i, i + limit);
                        remainingPaginatedStreams.push(page);
                    }
                }
                mainRoomsLength = remainingPaginatedStreams.length;
                updateMainRoomsLength(mainRoomsLength);
                // Add the remaining streams to the beginning of the paginatedStreams
                for (let i = remainingPaginatedStreams.length - 1; i >= 0; i--) {
                    paginatedStreams.unshift(remainingPaginatedStreams[i]);
                }
            }
            else {
                firstPage = allStreamsPaged.slice(0, limit_);
                paginatedStreams.push(firstPage);
                for (let i = limit_; i < allStreamsPaged.length; i += limit) {
                    page = allStreamsPaged.slice(i, i + limit);
                    paginatedStreams.push(page);
                }
            }
            // State updates
            updateP_activeNames(p_activeNames);
            updateActiveNames(activeNames);
            updateDispActiveNames(dispActiveNames);
            updateNewLimitedStreams(newLimitedStreams);
            updateNon_alVideoStreams(non_alVideoStreams);
            updateRef_participants(ref_participants);
            updateSortAudioLoudness(sortAudioLoudness);
            updateMixed_alVideoStreams(mixed_alVideoStreams);
            updateNon_alVideoStreams_muted(non_alVideoStreams_muted);
            updatePaginatedStreams(paginatedStreams);
            prevDoPaginate = doPaginate;
            doPaginate = false;
            updatePrevDoPaginate(prevDoPaginate);
            updateDoPaginate(doPaginate);
            let isActive = false;
            if (paginatedStreams.length > 1) {
                if (!shareScreenStarted && !shared) {
                    doPaginate = true;
                }
                updateDoPaginate(doPaginate);
                if (currentUserPage > paginatedStreams.length - 1) {
                    if (breakOutRoomStarted && !breakOutRoomEnded) {
                        currentUserPage = 0;
                    }
                    else {
                        currentUserPage = paginatedStreams.length - 1;
                    }
                }
                else if (currentUserPage == 0) {
                    isActive = true;
                }
                updateCurrentUserPage(currentUserPage);
                updateNumberPages(paginatedStreams.length - 1);
                if (screenChanged) {
                    await dispStreams({
                        lStreams: paginatedStreams[0],
                        ind: 0,
                        parameters,
                    });
                }
                else {
                    await dispStreams({
                        lStreams: paginatedStreams[0],
                        ind: 0,
                        auto: true,
                        parameters,
                    });
                }
                if (!isActive) {
                    const currentPageBreak = currentUserPage - mainRoomsLength;
                    await dispStreams({
                        lStreams: paginatedStreams[currentUserPage],
                        ind: currentUserPage,
                        parameters,
                        breakRoom: currentPageBreak,
                        inBreakRoom: currentPageBreak >= 0,
                    });
                }
            }
            else {
                currentUserPage = 0;
                updateCurrentUserPage(currentUserPage);
                if (screenChanged) {
                    await dispStreams({
                        lStreams: paginatedStreams[0],
                        ind: 0,
                        parameters,
                    });
                }
                else {
                    await dispStreams({
                        lStreams: paginatedStreams[0],
                        ind: 0,
                        auto: true,
                        parameters,
                    });
                }
            }
        }
        catch (error) {
            console.log('changeVids error', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ChangeVids, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ChangeVids, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ChangeVids, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Checks the grid configuration and calculates various parameters based on the number of rows, columns, and active elements.
 *
 * @param {CheckGridOptions} options - The options for checking the grid.
 * @param {number} options.rows - The number of rows in the grid.
 * @param {number} options.cols - The number of columns in the grid.
 * @param {number} options.actives - The number of active elements in the grid.
 * @returns {Promise<[boolean, number, number, number, number, number, number] | void>} A promise that resolves to a tuple containing:
 * - `removeAltGrid` (boolean): Indicates whether to remove the alternate grid.
 * - `numtoadd` (number): The number of elements to add.
 * - `numRows` (number): The number of rows.
 * - `numCols` (number): The number of columns.
 * - `remainingVideos` (number): The number of remaining videos.
 * - `actualRows` (number): The actual number of rows.
 * - `lastrowcols` (number): The number of columns in the last row.
 *
 * If an error occurs, it logs the error to the console.
 *
 *   *
 * @example
 * ```typescript
 * const options = {
 *   rows: 3,
 *   cols: 4,
 *   actives: 10,
 * };
 *
 * const result = await checkGridService.checkGrid(options);
 * console.log(result);
 * // Output could be: [false, 2, 3, 4, 2, 3, 2]
 * ```
 */
class CheckGrid {
    async checkGrid({ rows, cols, actives, }) {
        try {
            let numRows = 0;
            let numCols = 0;
            let lastrow = 0;
            let lastrowcols = 0;
            let remainingVideos = 0;
            let numtoadd = 0;
            let actualRows = 0;
            let removeAltGrid = false;
            if (rows * cols !== actives) {
                if (rows * cols > actives) {
                    const res = actives - (rows - 1) * cols;
                    if (cols * 0.5 < res) {
                        lastrow = rows;
                        lastrowcols = res;
                        remainingVideos = lastrowcols;
                    }
                    else {
                        lastrowcols = res + cols;
                        lastrow = rows - 1;
                        remainingVideos = lastrowcols;
                    }
                    numRows = lastrow - 1;
                    numCols = cols;
                    numtoadd = (lastrow - 1) * numCols;
                    actualRows = lastrow;
                    removeAltGrid = false;
                }
            }
            else {
                // Perfect fit
                numCols = cols;
                numRows = rows;
                lastrow = rows;
                lastrowcols = cols;
                remainingVideos = 0;
                numtoadd = lastrow * numCols;
                actualRows = lastrow;
                removeAltGrid = true;
            }
            return [removeAltGrid, numtoadd, numRows, numCols, remainingVideos, actualRows, lastrowcols];
        }
        catch (error) {
            console.log('checkGrid error', error);
            throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckGrid, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckGrid, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckGrid, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Checks the permission based on the provided settings.
 *
 * @param {CheckPermissionOptions} options - The options for checking permissions.
 * @param {string} options.permissionType - The type of permission to check. Can be "audioSetting", "videoSetting", "screenshareSetting", or "chatSetting".
 * @param {string} options.audioSetting - The setting for audio permission. Can be "allow", "approval", or other.
 * @param {string} options.videoSetting - The setting for video permission. Can be "allow", "approval", or other.
 * @param {string} options.screenshareSetting - The setting for screenshare permission. Can be "allow", "approval", or other.
 * @param {string} options.chatSetting - The setting for chat permission. Can be "allow", "approval", or other.
 * @returns {Promise<number>} - Returns 0 if the setting is "allow", 1 if the setting is "approval", and 2 for other settings or invalid permission types.
 * @throws Will throw an error if an unexpected error occurs during the permission check.
 *
 * @example
 * const options = {
 *   permissionType: 'videoSetting',
 *   audioSetting: 'allow',
 *   videoSetting: 'approval',
 *   screenshareSetting: 'deny',
 *   chatSetting: 'allow',
 * };
 *
 * const result = await checkPermissionService.checkPermission(options);
 * console.log(result);
 * // Output: 1 (since videoSetting is 'approval')
 */
class CheckPermission {
    /**
     * Checks the permission based on the provided settings.
     *
     * @param {CheckPermissionOptions} options - The options for checking permissions.
     * @param {string} options.permissionType - The type of permission to check. Can be "audioSetting", "videoSetting", "screenshareSetting", or "chatSetting".
     * @param {string} options.audioSetting - The setting for audio permission. Can be "allow", "approval", or other.
     * @param {string} options.videoSetting - The setting for video permission. Can be "allow", "approval", or other.
     * @param {string} options.screenshareSetting - The setting for screenshare permission. Can be "allow", "approval", or other.
     * @param {string} options.chatSetting - The setting for chat permission. Can be "allow", "approval", or other.
     * @returns {Promise<number>} - Returns 0 if the setting is "allow", 1 if the setting is "approval", and 2 for other settings or invalid permission types.
     * @throws Will throw an error if an unexpected error occurs during the permission check.
     */
    async checkPermission({ permissionType, audioSetting, videoSetting, screenshareSetting, chatSetting, }) {
        try {
            // Perform a switch case to check for the permissionType and return the response
            switch (permissionType) {
                case 'audioSetting':
                    if (audioSetting === 'allow') {
                        return 0;
                    }
                    else if (audioSetting === 'approval') {
                        return 1;
                    }
                    else {
                        return 2;
                    }
                case 'videoSetting':
                    if (videoSetting === 'allow') {
                        return 0;
                    }
                    else if (videoSetting === 'approval') {
                        return 1;
                    }
                    else {
                        return 2;
                    }
                case 'screenshareSetting':
                    if (screenshareSetting === 'allow') {
                        return 0;
                    }
                    else if (screenshareSetting === 'approval') {
                        return 1;
                    }
                    else {
                        return 2;
                    }
                case 'chatSetting':
                    if (chatSetting === 'allow') {
                        return 0;
                    }
                    else if (chatSetting === 'approval') {
                        return 1;
                    }
                    else {
                        return 2;
                    }
                default:
                    // throw new Error(`Invalid permissionType: ${permissionType}`);
                    return 2;
            }
        }
        catch (error) {
            // console.log('checkPermission error', error);
            // throw error;
            return 2;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckPermission, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckPermission, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckPermission, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Checks the current screen sharing status and either stops or requests screen sharing based on the provided parameters.
 *
 * @param {CheckScreenShareOptions} options - The options for checking screen share.
 * @param {Object} options.parameters - The parameters for screen sharing.
 * @param {boolean} options.parameters.shared - Indicates if the screen is currently being shared.
 * @param {Function} [options.parameters.showAlert] - Function to show alerts.
 * @param {boolean} options.parameters.whiteboardStarted - Indicates if the whiteboard session has started.
 * @param {boolean} options.parameters.whiteboardEnded - Indicates if the whiteboard session has ended.
 * @param {boolean} options.parameters.breakOutRoomStarted - Indicates if the breakout room session has started.
 * @param {boolean} options.parameters.breakOutRoomEnded - Indicates if the breakout room session has ended.
 * @param {Function} options.parameters.stopShareScreen - Function to stop screen sharing.
 * @param {Function} options.parameters.requestScreenShare - Function to request screen sharing.
 *
 * @returns {Promise<void>} A promise that resolves when the screen sharing status has been checked and the appropriate action has been taken.
 *
 * @throws Will log an error message if an error occurs during the process.
 *
 * @example
 * const options = {
 *   parameters: {
 *     shared: false,
 *     whiteboardStarted: false,
 *     whiteboardEnded: false,
 *     breakOutRoomStarted: false,
 *     breakOutRoomEnded: false,
 *     stopShareScreen: async () => { /* Logic to stop screen sharing *\/ },
 *     requestScreenShare: async () => { /* Logic to request screen sharing *\/ },
 *     showAlert: (alert) => { console.log(alert.message); },
 *   },
 * };
 *
 * await checkScreenShareService.checkScreenShare(options);
 * // Output: Logic to request screen sharing will be executed.
 */
class CheckScreenShare {
    /**
     * Checks the current screen sharing status and either stops or requests screen sharing based on the provided parameters.
     *
     * @param {CheckScreenShareOptions} options - The options for checking screen share.
     * @param {Object} options.parameters - The parameters for screen sharing.
     * @param {boolean} options.parameters.shared - Indicates if the screen is currently being shared.
     * @param {Function} [options.parameters.showAlert] - Function to show alerts.
     * @param {boolean} options.parameters.whiteboardStarted - Indicates if the whiteboard session has started.
     * @param {boolean} options.parameters.whiteboardEnded - Indicates if the whiteboard session has ended.
     * @param {boolean} options.parameters.breakOutRoomStarted - Indicates if the breakout room session has started.
     * @param {boolean} options.parameters.breakOutRoomEnded - Indicates if the breakout room session has ended.
     * @param {Function} options.parameters.stopShareScreen - Function to stop screen sharing.
     * @param {Function} options.parameters.requestScreenShare - Function to request screen sharing.
     *
     * @returns {Promise<void>} A promise that resolves when the screen sharing status has been checked and the appropriate action has been taken.
     *
     * @throws Will log an error message if an error occurs during the process.
     */
    checkScreenShare = async ({ parameters }) => {
        try {
            const { shared, showAlert, whiteboardStarted, whiteboardEnded, breakOutRoomStarted, breakOutRoomEnded, 
            // mediasfu functions
            stopShareScreen, requestScreenShare, } = parameters;
            // Stop screen share if already shared or request screen share if not shared
            if (shared) {
                if (whiteboardStarted && !whiteboardEnded) {
                    showAlert?.({
                        message: 'Screen share is not allowed when whiteboard is active',
                        type: 'danger',
                    });
                    return;
                }
                await stopShareScreen({ parameters });
            }
            else {
                // Can't share if breakout room is active
                if (breakOutRoomStarted && !breakOutRoomEnded) {
                    showAlert?.({
                        message: 'Screen share is not allowed when breakout room is active',
                        type: 'danger',
                    });
                    return;
                }
                if (whiteboardStarted && !whiteboardEnded) {
                    showAlert?.({
                        message: 'Screen share is not allowed when whiteboard is active',
                        type: 'danger',
                    });
                    return;
                }
                await requestScreenShare({ parameters });
            }
        }
        catch (error) {
            console.log('checkScreenShare error', error);
            // throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckScreenShare, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckScreenShare, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckScreenShare, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Closes and resizes the video and audio elements based on the provided options.
 *
 * @param {CloseAndResizeOptions} options - The options for closing and resizing.
 * @param {string} options.producerId - The ID of the producer.
 * @param {string} options.kind - The kind of media (audio, video, screenshare, or screen).
 * @param {object} options.parameters - The parameters for the operation.
 * @param {function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 * @param {Array} options.parameters.allAudioStreams - Array of all audio streams.
 * @param {Array} options.parameters.allVideoStreams - Array of all video streams.
 * @param {Array} options.parameters.activeNames - Array of active participant names.
 * @param {Array} options.parameters.participants - Array of participants.
 * @param {Array} options.parameters.streamNames - Array of stream names.
 * @param {string} options.parameters.recordingDisplayType - Type of recording display.
 * @param {boolean} options.parameters.recordingVideoOptimized - Whether recording is video optimized.
 * @param {string} options.parameters.adminIDStream - ID of the admin stream.
 * @param {Array} options.parameters.newLimitedStreams - Array of new limited streams.
 * @param {Array} options.parameters.newLimitedStreamsIDs - Array of new limited stream IDs.
 * @param {Array} options.parameters.oldAllStreams - Array of old all streams.
 * @param {boolean} options.parameters.shareScreenStarted - Whether screen sharing has started.
 * @param {boolean} options.parameters.shared - Whether sharing is active.
 * @param {string} options.parameters.meetingDisplayType - Type of meeting display.
 * @param {boolean} options.parameters.defer_receive - Whether to defer receiving.
 * @param {boolean} options.parameters.lock_screen - Whether the screen is locked.
 * @param {boolean} options.parameters.firstAll - Whether it is the first all.
 * @param {boolean} options.parameters.first_round - Whether it is the first round.
 * @param {boolean} options.parameters.gotAllVids - Whether all videos are received.
 * @param {string} options.parameters.eventType - Type of event.
 * @param {string} options.parameters.hostLabel - Label of the host.
 * @param {boolean} options.parameters.shareEnded - Whether sharing has ended.
 * @param {boolean} options.parameters.updateMainWindow - Whether to update the main window.
 * @param {function} options.parameters.updateActiveNames - Function to update active names.
 * @param {function} options.parameters.updateAllAudioStreams - Function to update all audio streams.
 * @param {function} options.parameters.updateAllVideoStreams - Function to update all video streams.
 * @param {function} options.parameters.updateShareScreenStarted - Function to update share screen started status.
 * @param {function} options.parameters.updateUpdateMainWindow - Function to update main window status.
 * @param {function} options.parameters.updateNewLimitedStreams - Function to update new limited streams.
 * @param {function} options.parameters.updateOldAllStreams - Function to update old all streams.
 * @param {function} options.parameters.updateDefer_receive - Function to update defer receive status.
 * @param {function} options.parameters.updateMainHeightWidth - Function to update main height and width.
 * @param {function} options.parameters.updateShareEnded - Function to update share ended status.
 * @param {function} options.parameters.updateLock_screen - Function to update lock screen status.
 * @param {function} options.parameters.updateFirstAll - Function to update first all status.
 * @param {function} options.parameters.updateFirst_round - Function to update first round status.
 * @param {function} options.parameters.reorderStreams - Function to reorder streams.
 * @param {function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
 * @param {function} options.parameters.getVideos - Function to get videos.
 * @param {function} options.parameters.rePort - Function to report.
 *
 * @returns {Promise<void>} A promise that resolves when the operation is complete.
 *
 * @example
 * const options = {
 *   producerId: '12345',
 *   kind: 'video',
 *   parameters: {
 *     getUpdatedAllParams: () => { /* Logic to get updated parameters *\/ },
 *     allAudioStreams: [],
 *     allVideoStreams: [],
 *     activeNames: ['Participant1', 'Participant2'],
 *     participants: [],
 *     streamNames: [],
 *     recordingDisplayType: 'video',
 *     recordingVideoOptimized: true,
 *     adminIDStream: 'admin123',
 *     newLimitedStreams: [],
 *     newLimitedStreamsIDs: [],
 *     oldAllStreams: [],
 *     shareScreenStarted: false,
 *     shared: false,
 *     meetingDisplayType: 'media',
 *     defer_receive: false,
 *     lock_screen: false,
 *     firstAll: false,
 *     first_round: false,
 *     gotAllVids: false,
 *     eventType: 'conference',
 *     hostLabel: 'Host',
 *     shareEnded: false,
 *     updateMainWindow: false,
 *     updateActiveNames: (names) => { /* Logic to update active names *\/ },
 *     updateAllAudioStreams: (streams) => { /* Logic to update audio streams *\/ },
 *     updateShareScreenStarted: (status) => { /* Logic to update share screen status *\/ },
 *     updateUpdateMainWindow: (status) => { /* Logic to update main window status *\/ },
 *     updateNewLimitedStreams: (streams) => { /* Logic to update new limited streams *\/ },
 *     updateOldAllStreams: (streams) => { /* Logic to update old streams *\/ },
 *     updateDefer_receive: (status) => { /* Logic to update defer receive status *\/ },
 *     updateMainHeightWidth: (size) => { /* Logic to update main height and width *\/ },
 *     updateShareEnded: (status) => { /* Logic to update share ended status *\/ },
 *     updateLock_screen: (status) => { /* Logic to update lock screen status *\/ },
 *     updateFirstAll: (status) => { /* Logic to update first all status *\/ },
 *     updateFirst_round: (status) => { /* Logic to update first round status *\/ },
 *     reorderStreams: async () => { /* Logic to reorder streams *\/ },
 *     prepopulateUserMedia: async () => { /* Logic to prepopulate user media *\/ },
 *     getVideos: async () => { /* Logic to get videos *\/ },
 *     rePort: async () => { /* Logic to report *\/ },
 *   },
 * };
 *
 * await closeAndResizeService.closeAndResize(options);
 * // The operation will adjust the video and audio elements as per the given parameters.
 */
class CloseAndResize {
    /**
     * Closes and resizes the video and audio elements based on the provided options.
     *
     * @param {CloseAndResizeOptions} options - The options for closing and resizing.
     * @param {string} options.producerId - The ID of the producer.
     * @param {string} options.kind - The kind of media (audio, video, screenshare, or screen).
     * @param {object} options.parameters - The parameters for the operation.
     * @param {function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {Array} options.parameters.allAudioStreams - Array of all audio streams.
     * @param {Array} options.parameters.allVideoStreams - Array of all video streams.
     * @param {Array} options.parameters.activeNames - Array of active participant names.
     * @param {Array} options.parameters.participants - Array of participants.
     * @param {Array} options.parameters.streamNames - Array of stream names.
     * @param {string} options.parameters.recordingDisplayType - Type of recording display.
     * @param {boolean} options.parameters.recordingVideoOptimized - Whether recording is video optimized.
     * @param {string} options.parameters.adminIDStream - ID of the admin stream.
     * @param {Array} options.parameters.newLimitedStreams - Array of new limited streams.
     * @param {Array} options.parameters.newLimitedStreamsIDs - Array of new limited stream IDs.
     * @param {Array} options.parameters.oldAllStreams - Array of old all streams.
     * @param {boolean} options.parameters.shareScreenStarted - Whether screen sharing has started.
     * @param {boolean} options.parameters.shared - Whether sharing is active.
     * @param {string} options.parameters.meetingDisplayType - Type of meeting display.
     * @param {boolean} options.parameters.defer_receive - Whether to defer receiving.
     * @param {boolean} options.parameters.lock_screen - Whether the screen is locked.
     * @param {boolean} options.parameters.firstAll - Whether it is the first all.
     * @param {boolean} options.parameters.first_round - Whether it is the first round.
     * @param {boolean} options.parameters.gotAllVids - Whether all videos are received.
     * @param {string} options.parameters.eventType - Type of event.
     * @param {string} options.parameters.hostLabel - Label of the host.
     * @param {boolean} options.parameters.shareEnded - Whether sharing has ended.
     * @param {boolean} options.parameters.updateMainWindow - Whether to update the main window.
     * @param {function} options.parameters.updateActiveNames - Function to update active names.
     * @param {function} options.parameters.updateAllAudioStreams - Function to update all audio streams.
     * @param {function} options.parameters.updateAllVideoStreams - Function to update all video streams.
     * @param {function} options.parameters.updateShareScreenStarted - Function to update share screen started status.
     * @param {function} options.parameters.updateUpdateMainWindow - Function to update main window status.
     * @param {function} options.parameters.updateNewLimitedStreams - Function to update new limited streams.
     * @param {function} options.parameters.updateOldAllStreams - Function to update old all streams.
     * @param {function} options.parameters.updateDefer_receive - Function to update defer receive status.
     * @param {function} options.parameters.updateMainHeightWidth - Function to update main height and width.
     * @param {function} options.parameters.updateShareEnded - Function to update share ended status.
     * @param {function} options.parameters.updateLock_screen - Function to update lock screen status.
     * @param {function} options.parameters.updateFirstAll - Function to update first all status.
     * @param {function} options.parameters.updateFirst_round - Function to update first round status.
     * @param {function} options.parameters.reorderStreams - Function to reorder streams.
     * @param {function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @param {function} options.parameters.getVideos - Function to get videos.
     * @param {function} options.parameters.rePort - Function to report.
     *
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     */
    closeAndResize = async ({ producerId, kind, parameters, }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { allAudioStreams, allVideoStreams, activeNames, participants, streamNames, recordingDisplayType, recordingVideoOptimized, adminIDStream, newLimitedStreams, newLimitedStreamsIDs, oldAllStreams, shareScreenStarted, shared, meetingDisplayType, defer_receive, lock_screen, firstAll, first_round, gotAllVids, eventType, hostLabel, shareEnded, updateMainWindow, updateActiveNames, updateAllAudioStreams, updateAllVideoStreams, updateShareScreenStarted, updateUpdateMainWindow, updateNewLimitedStreams, updateOldAllStreams, updateDefer_receive, updateMainHeightWidth, updateShareEnded, updateLock_screen, updateFirstAll, updateFirst_round, 
        //mediasfu functions
        reorderStreams, prepopulateUserMedia, getVideos, rePort, } = parameters;
        //function to close and resize the video and audio elements
        let participant;
        if (kind === 'audio') {
            //stop the audio by removing the miniAudio with id = producerId
            //remove the audio from the allAudioStreams array
            allAudioStreams = allAudioStreams.filter(function (audioStream) {
                return audioStream.producerId !== producerId;
            });
            updateAllAudioStreams(allAudioStreams);
            if (recordingDisplayType == 'video' && recordingVideoOptimized == true) {
                // do nothing
            }
            else {
                //get the name of the participant with the producerId
                participant = participants.find((obj) => obj.audioID === producerId);
                if (participant) {
                    //check if the participants videoID is not null or ""
                    if (participant.videoID !== null && participant.videoID !== '') {
                        // do nothing
                    }
                    else {
                        //remove the participant from the activeNames array
                        activeNames = activeNames.filter(function (name) {
                            return name !== participant?.name;
                        });
                        updateActiveNames(activeNames);
                    }
                }
            }
            let checker = false;
            let alt_checker = false;
            if (meetingDisplayType == 'video' && participant) {
                checker =
                    participant[0].videoID != null &&
                        participant[0].videoID != '' &&
                        participant[0].videoID != undefined;
            }
            else {
                checker = true;
                alt_checker = true;
            }
            if (checker) {
                if (shareScreenStarted || shared) {
                    if (!alt_checker) {
                        await reorderStreams({ parameters });
                    }
                }
                else {
                    if (alt_checker && meetingDisplayType != 'video') {
                        await reorderStreams({ add: false, screenChanged: true, parameters });
                    }
                }
            }
        }
        else if (kind === 'video') {
            //update the video elements by removing the miniVideo with id = producerId
            //remove the video from the allVideoStreams array
            //check if producerId == adminidstream
            if (producerId == adminIDStream) {
                updateMainWindow = true;
                updateUpdateMainWindow(updateMainWindow);
            }
            try {
                allVideoStreams = allVideoStreams.filter(function (videoStream) {
                    return videoStream.producerId !== producerId;
                });
                updateAllVideoStreams(allVideoStreams);
                try {
                    //try remove it from oldVideoStreams
                    oldAllStreams = oldAllStreams.filter(function (videoStream) {
                        return videoStream.producerId !== producerId;
                    });
                    updateOldAllStreams(oldAllStreams);
                }
                catch {
                    /* handle error */
                }
                try {
                    //try remove it from newLimitedStreams
                    newLimitedStreams = newLimitedStreams.filter(function (videoStream) {
                        return videoStream.producerId !== producerId;
                    });
                    updateNewLimitedStreams(newLimitedStreams);
                }
                catch {
                    /* handle error */
                }
            }
            catch (error) {
                try {
                    //try remove it from oldVideoStreams
                    oldAllStreams = oldAllStreams.filter(function (videoStream) {
                        return videoStream.producerId !== producerId;
                    });
                    updateOldAllStreams(oldAllStreams);
                }
                catch {
                    /* handle error */
                }
            }
            try {
                //remove the participant from activeNames
                activeNames = activeNames.filter(function (name) {
                    //get the participant with the producerId
                    let participant = streamNames.find((obj) => obj.producerId === producerId);
                    return name !== (participant?.name ?? '');
                });
                updateActiveNames(activeNames);
            }
            catch {
                /* handle error */
            }
            if (lock_screen) {
                defer_receive = true;
                // check if the video is the one being displayed (i.e. (newLimitedStreamsIDs))
                if (newLimitedStreamsIDs.includes(producerId)) {
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                    await reorderStreams({ add: false, screenChanged: true, parameters });
                }
            }
            else {
                await prepopulateUserMedia({ name: hostLabel, parameters });
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
        else if (kind === 'screenshare' || kind === 'screen') {
            //update the video elements by removing the mainVideo with id = producerId
            updateMainWindow = true;
            //screenshare stuff
            shareScreenStarted = false;
            shareEnded = true;
            lock_screen = false;
            firstAll = false;
            first_round = false;
            updateUpdateMainWindow(updateMainWindow);
            updateShareScreenStarted(shareScreenStarted);
            updateShareEnded(shareEnded);
            updateLock_screen(lock_screen);
            updateFirstAll(firstAll);
            updateFirst_round(first_round);
            if (!gotAllVids || defer_receive) {
                defer_receive = false;
                updateDefer_receive(defer_receive);
                await getVideos({
                    participants,
                    allVideoStreams,
                    oldAllStreams,
                    updateAllVideoStreams,
                    updateOldAllStreams,
                });
                await rePort({ parameters });
            }
            if (eventType == 'conference') {
                updateMainHeightWidth(0);
            }
            await prepopulateUserMedia({ name: hostLabel, parameters });
            await reorderStreams({ add: false, screenChanged: true, parameters });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CloseAndResize, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CloseAndResize, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CloseAndResize, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Compares the current active names with the previous active names and triggers an action if there are changes.
 *
 * @param {CompareActiveNamesOptions} options - The options for comparing active names.
 * @param {boolean} [options.restart=false] - Whether to restart the comparison.
 * @param {CompareActiveNamesParameters} options.parameters - The parameters for the comparison.
 * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 * @param {string[]} options.parameters.activeNames - The current active names.
 * @param {string[]} options.parameters.prevActiveNames - The previous active names.
 * @param {Function} options.parameters.updatePrevActiveNames - Function to update the previous active names.
 * @param {Function} options.parameters.trigger - Function to trigger an action when names change.
 *
 * @returns {Promise<void>} A promise that resolves when the comparison is complete.
 *
 * @throws Will log an error message if an error occurs during the comparison.
 *
 * @example
 * const options = {
 *   restart: false,
 *   parameters: {
 *     getUpdatedAllParams: () => { /* Logic to get updated parameters *\/ },
 *     activeNames: ['Alice', 'Bob'],
 *     prevActiveNames: ['Alice', 'Charlie'],
 *     updatePrevActiveNames: (names) => { /* Logic to update previous active names *\/ },
 *     trigger: async (data) => { /* Logic to handle the trigger *\/ },
 *   },
 * };
 *
 * await compareActiveNamesService.compareActiveNames(options);
 * // If 'Bob' is not in the previous active names, it will trigger the action.
 */
class CompareActiveNames {
    /**
     * Compares the current active names with the previous active names and triggers an action if there are changes.
     *
     * @param {Object} options - The options for comparing active names.
     * @param {boolean} [options.restart=false] - Whether to restart the comparison.
     * @param {CompareActiveNamesOptions} options.parameters - The parameters for the comparison.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {string[]} options.parameters.activeNames - The current active names.
     * @param {string[]} options.parameters.prevActiveNames - The previous active names.
     * @param {Function} options.parameters.updatePrevActiveNames - Function to update the previous active names.
     * @param {Function} options.parameters.trigger - Function to trigger an action when names change.
     *
     * @returns {Promise<void>} A promise that resolves when the comparison is complete.
     *
     * @throws Will log an error message if an error occurs during the comparison.
     */
    async compareActiveNames({ restart = false, parameters, }) {
        try {
            let { getUpdatedAllParams } = parameters;
            parameters = getUpdatedAllParams();
            let { activeNames, prevActiveNames, updatePrevActiveNames, trigger } = parameters;
            // Restart the comparison if needed
            if (restart) {
                await trigger({ ref_ActiveNames: activeNames, parameters });
                return;
            }
            // Array to track changes in activeNames
            let nameChanged = [];
            // Compare each name in activeNames
            for (let i = 0; i < activeNames.length; i++) {
                const currentName = activeNames[i];
                // Check if the name is present in prevActiveNames
                const hasNameChanged = !prevActiveNames.includes(currentName);
                if (hasNameChanged) {
                    nameChanged.push(true);
                    trigger({ ref_ActiveNames: activeNames, parameters });
                    break;
                }
            }
            // Count the number of true in nameChanged
            let count = nameChanged.filter((value) => value === true).length;
            if (count < 1) {
                // Check for new names in prevActiveNames
                for (let i = 0; i < prevActiveNames.length; i++) {
                    const currentName = prevActiveNames[i];
                    // Check if the name is present in activeNames
                    const hasNameChanged = !activeNames.includes(currentName);
                    // Signal change if the name is new
                    if (hasNameChanged) {
                        trigger({ ref_ActiveNames: activeNames, parameters });
                        break;
                    }
                }
            }
            // Update prevActiveNames with current activeNames
            prevActiveNames = [...activeNames];
            updatePrevActiveNames(prevActiveNames);
        }
        catch (error) {
            console.log('compareActiveNames error', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CompareActiveNames, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CompareActiveNames, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CompareActiveNames, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
   * Compares the current screen states with the previous screen states and triggers actions based on changes.
   *
   * @param {CompareScreenStatesOptions} options - The options for comparing screen states.
   * @param {boolean} [options.restart=false] - Whether to restart the comparison process.
   * @param {CompareScreenStatesParameters} options.parameters - The parameters for the comparison.
   * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
   * @param {string} options.parameters.recordingDisplayType - The type of display being recorded.
   * @param {boolean} options.parameters.recordingVideoOptimized - Whether the recording is optimized for video.
   * @param {ScreenState[]} options.parameters.screenStates - The current screen states.
   * @param {ScreenState[]} options.parameters.prevScreenStates - The previous screen states.
   * @param {string[]} options.parameters.activeNames - The active names in the current context.
   * @param {Function} options.parameters.trigger - Function to trigger actions based on changes.
   *
   * @returns {Promise<void>} A promise that resolves when the comparison and any triggered actions are complete.
   *
   * @throws Will log an error message if an error occurs during the comparison process.
   *
   * @example
   * const options = {
   *   restart: false,
   *   parameters: {
   *     getUpdatedAllParams: () => { /* Logic to get updated parameters *\/ },
   *     recordingDisplayType: 'video',
   *     recordingVideoOptimized: true,
   *     screenStates: [{ state: 'active' }, { state: 'inactive' }],
   *     prevScreenStates: [{ state: 'inactive' }, { state: 'active' }],
   *     activeNames: ['Alice', 'Bob'],
   *     trigger: async (data) => { /* Logic to handle the trigger *\/ },
   *   },
   * };
   *
   * await compareScreenStatesService.compareScreenStates(options);
   * // If any screen state has changed, the trigger function will be called accordingly.
   */
class CompareScreenStates {
    /**
     * Compares the current screen states with the previous screen states and triggers actions based on changes.
     *
     * @param {Object} options - The options for comparing screen states.
     * @param {boolean} [options.restart=false] - Whether to restart the comparison process.
     * @param {CompareScreenStatesOptions} options.parameters - The parameters for the comparison.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {string} options.parameters.recordingDisplayType - The type of display being recorded.
     * @param {boolean} options.parameters.recordingVideoOptimized - Whether the recording is optimized for video.
     * @param {Array<ScreenState>} options.parameters.screenStates - The current screen states.
     * @param {Array<ScreenState>} options.parameters.prevScreenStates - The previous screen states.
     * @param {Array<string>} options.parameters.activeNames - The active names in the current context.
     * @param {Function} options.parameters.trigger - Function to trigger actions based on changes.
     *
     * @returns {Promise<void>} A promise that resolves when the comparison and any triggered actions are complete.
     *
     * @throws Will log an error message if an error occurs during the comparison process.
     */
    async compareScreenStates({ restart = false, parameters, }) {
        try {
            let { getUpdatedAllParams } = parameters;
            parameters = getUpdatedAllParams();
            let { recordingDisplayType, recordingVideoOptimized, screenStates, prevScreenStates, activeNames, trigger, } = parameters;
            // Restart the comparison if needed
            if (restart) {
                // Perform necessary actions on restart
                return;
            }
            // Compare each key-value pair in the screenStates objects
            for (let i = 0; i < screenStates.length; i++) {
                const currentScreenState = screenStates[i];
                const prevScreenState = prevScreenStates[i];
                // Check if any value has changed
                const hasChanged = Object.keys(currentScreenState).some((key) => currentScreenState[key] !== prevScreenState[key]);
                // Signal change if any value has changed
                if (hasChanged) {
                    // Perform actions or trigger events based on the change
                    if (recordingDisplayType === 'video' && recordingVideoOptimized) {
                        await trigger({ ref_ActiveNames: activeNames, parameters });
                        break;
                    }
                    await trigger({ ref_ActiveNames: activeNames, parameters });
                    break;
                }
            }
        }
        catch (error) {
            console.log('compareScreenStates error', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CompareScreenStates, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CompareScreenStates, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CompareScreenStates, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Manages connections to a media socket, allowing users to connect or disconnect based on API credentials.
 *
 * @class
 * @name SocketManager
 * @description Provides methods to connect and disconnect from a media socket using a provided API key or token.
 *
 * @method
 * validateApiKeyToken - Validates the API key or token for correct format.
 * connectSocket - Establishes a connection to the media socket using either the API key or token.
 * disconnectSocket - Disconnects an active socket connection.
 *
 * @example
 * ```typescript
 * const socketManager = new SocketManager();
 *
 * // Example of connecting to the socket
 * const socketConnection = await socketManager.connectSocket({
 *   apiUserName: 'user123',
 *   apiKey: 'validApiKeyOf64Characters',
 *   link: 'https://socketserver.example.com'
 * });
 *
 * // Example of disconnecting the socket
 * const isDisconnected = await socketManager.disconnectSocket({
 *   socket: socketConnection
 * });
 * ```
 *
 * @typedef {Object} ConnectSocketOptions
 * @property {string} apiUserName - Username for the API.
 * @property {string} [apiKey] - The API key for authentication.
 * @property {string} [apiToken] - The API token for authentication.
 * @property {string} link - The socket server link.
 *
 * @typedef {Object} DisconnectSocketOptions
 * @property {Socket} socket - The socket instance to disconnect.
 *
 * @returns {Promise<Socket | boolean>} The active socket instance on connection, or a boolean indicating disconnection success.
 */
class SocketManager {
    socket;
    async validateApiKeyToken(value) {
        if (!/^[a-z0-9]{64}$/i.test(value)) {
            throw new Error('Invalid API key or token.');
        }
        return true;
    }
    /**
     * Connects to a media socket using the provided connection options.
     *
     * @param {ConnectSocketOptions} options - The connection options.
     * @param {string} options.apiUserName - The API username.
     * @param {string} [options.apiKey] - The API key for authentication.
     * @param {string} [options.apiToken] - The API token for authentication.
     * @param {string} options.link - The socket link.
     *
     * @returns {Promise<Socket>} A promise that resolves to the connected socket.
     *
     * @example
     * ```typescript
     * const options = {
     *   apiUserName: 'user123',
     *   apiKey: 'validApiKeyOf64Characters',
     *   link: 'https://socketserver.example.com'
     * };
     *
     * try {
     *   const socket = await connectSocket(options);
     *   console.log('Connected to socket:', socket);
     * } catch (error) {
     *   console.error('Failed to connect to socket:', error);
     * }
     * ```
     */
    connectSocket = async ({ apiUserName, apiKey, apiToken, link, }) => {
        if (!apiUserName) {
            throw new Error('API username required.');
        }
        if (!(apiKey || apiToken)) {
            throw new Error('API key or token required.');
        }
        if (!link) {
            throw new Error('Socket link required.');
        }
        let useKey = false;
        try {
            if (apiKey && apiKey.length === 64) {
                await this.validateApiKeyToken(apiKey);
                useKey = true;
            }
            else {
                if (apiToken) {
                    await this.validateApiKeyToken(apiToken);
                }
                else {
                    throw new Error('API token is required.');
                }
                useKey = false;
            }
        }
        catch (error) {
            throw new Error('Invalid API key or token.');
        }
        return new Promise((resolve, reject) => {
            const query = useKey ? { apiUserName, apiKey } : { apiUserName, apiToken };
            this.socket = io(`${link}/media`, {
                transports: ['websocket'],
                query,
            });
            this.socket.on('connect', () => {
                console.log('Connected to media socket.', this.socket.id);
                resolve(this.socket);
            });
            this.socket.on('connect_error', () => {
                reject(new Error('Error connecting to media socket.'));
            });
        });
    };
    /**
     * Connects to a local media socket using the provided connection options.
     *
     * @param {ConnectLocalSocketOptions} options - The connection options.
     * @param {string} options.link - The socket link.
     *
     * @returns {Promise<ResponseLocalConnection>} A promise that resolves to the connected socket and data.
     *
     * @example
     * ```typescript
     * const options = {
     *   link: "http://localhost:3000",
     * };
     *
     * try {
     *   const { socket, data } = await connectLocalSocket(options);
     *   console.log("Connected to socket:", socket, data);
     * } catch (error) {
     *   console.error("Failed to connect to socket:", error);
     * }
     * ```
     */
    connectLocalSocket = async ({ link }) => {
        if (!link) {
            throw new Error("Socket link required.");
        }
        let socket;
        return new Promise((resolve, reject) => {
            // Connect to socket using the link provided
            socket = io(`${link}/media`, {
                transports: ["websocket"],
            });
            // Handle socket connection events
            socket.on("connection-success", (data) => {
                //check if link contains mediasfu.com and contains more than one c
                let conn = 'media';
                try {
                    if (link.includes('mediasfu.com') && (link.match(/c/g)?.length ?? 0) > 1) {
                        conn = 'consume';
                    }
                }
                catch {
                    // do nothing
                }
                console.log(`Connected to ${conn} socket with ID: ${socket.id}`);
                resolve({ socket, data });
            });
            socket.on("connect_error", (error) => {
                reject(new Error("Error connecting to media socket: " + error.message));
            });
        });
    };
    /**
     * Disconnects an active socket connection.
     *
     * @param {DisconnectSocketOptions} options - The options for disconnecting the socket.
     * @param {Socket} options.socket - The socket instance to disconnect.
     *
     * @returns {Promise<boolean>} A promise that resolves to true if the socket was disconnected successfully, or false otherwise.
     *
     * @example
     * ```typescript
     * const options = {
     *   socket: mySocketInstance,
     * };
     *
     * try {
     *   const isDisconnected = await disconnectSocket(options);
     *   console.log("Socket disconnected:", isDisconnected);
     * } catch (error) {
     *   console.error("Failed to disconnect socket:", error);
     * }
     * ```
     */
    disconnectSocket = async ({ socket }) => {
        if (socket) {
            socket.disconnect();
            return true;
        }
        return false;
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SocketManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SocketManager, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SocketManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Connects to remote IPs and manages socket connections.
 *
 * This method establishes connections to remote IPs for media streaming, handles new pipe producer events,
 * and manages producer closure events. It updates the necessary state in the application to reflect
 * the current connections and stream configurations.
 *
 * @param {ConnectIpsOptions} options - The options for connecting IPs.
 * @param {Record<string, any>[]} options.consume_sockets - The array of current socket connections.
 * @param {string[]} options.remIP - The list of remote IPs to connect to.
 * @param {string} options.apiUserName - The API username for authentication.
 * @param {string} [options.apiKey] - The API key for authentication.
 * @param {string} [options.apiToken] - The API token for authentication.
 * @param {Function} [options.newProducerMethod] - The method to handle new pipe producer events (default: newPipeProducer).
 * @param {Function} [options.closedProducerMethod] - The method to handle producer closed events (default: producerClosed).
 * @param {Function} [options.joinConsumeRoomMethod] - The method to handle joining a consuming room (default: joinConsumeRoom).
 * @param {ConnectIpsParameters} options.parameters - Additional parameters for the operation.
 * @param {string[]} options.parameters.roomRecvIPs - The list of IPs that have been received in the room.
 * @param {Function} options.parameters.updateRoomRecvIPs - Function to update the room received IPs.
 * @param {Function} options.parameters.updateConsume_sockets - Function to update the consume sockets.
 *
 * @returns {Promise<[Record<string, any>[], string[]]>} A promise that resolves to an array containing the updated consume sockets and room received IPs.
 *
 * @throws Will throw an error if required parameters are missing or if there is an issue connecting to a remote IP.
 *
 * @example
 * ```typescript
 * const result = await connectIps({
 *   consume_sockets: currentSockets,
 *   remIP: ['192.168.1.1', '192.168.1.2'],
 *   apiUserName: 'username',
 *   apiKey: 'your-api-key',
 *   apiToken: 'your-api-token',
 *   parameters: {
 *     roomRecvIPs: [],
 *     updateRoomRecvIPs: (ips) => { },
 *     updateConsume_sockets: (sockets) => { },
 *     // ...other parameters
 *   },
 * });
 * ```
 */
class ConnectIps {
    socketManagerService;
    newPipeProducerService;
    producerClosedService;
    joinConsumeRoomService;
    constructor(socketManagerService, newPipeProducerService, producerClosedService, joinConsumeRoomService) {
        this.socketManagerService = socketManagerService;
        this.newPipeProducerService = newPipeProducerService;
        this.producerClosedService = producerClosedService;
        this.joinConsumeRoomService = joinConsumeRoomService;
    }
    /**
     * Connects to remote IPs and manages socket connections.
     *
     * @param {Object} options - The options for connecting IPs.
     * @param {Record<string, any>[]} options.consume_sockets - The array of current socket connections.
     * @param {string[]} options.remIP - The list of remote IPs to connect to.
     * @param {string} options.apiUserName - The API username for authentication.
     * @param {string} [options.apiKey] - The API key for authentication.
     * @param {string} [options.apiToken] - The API token for authentication.
     * @param {Function} [options.newProducerMethod=newPipeProducer] - The method to handle new pipe producer events.
     * @param {Function} [options.closedProducerMethod=producerClosed] - The method to handle producer closed events.
     * @param {Function} [options.joinConsumeRoomMethod=joinConsumeRoom] - The method to handle joining a consuming room.
     * @param {Object} options.parameters - Additional parameters.
     * @param {string[]} options.parameters.roomRecvIPs - The list of IPs that have been received in the room.
     * @param {Function} options.parameters.updateRoomRecvIPs - The function to update the room received IPs.
     * @param {Function} options.parameters.updateConsume_sockets - The function to update the consume sockets.
     *
     * @returns {Promise<[Record<string, any>[], string[]]>} A promise that resolves to an array containing the updated consume sockets and room received IPs.
     *
     * @throws Will throw an error if required parameters are missing or if there is an issue connecting to a remote IP.
     */
    connectIps = async ({ consume_sockets, remIP, apiUserName, apiKey = '', apiToken = '', newProducerMethod = this.newPipeProducerService.newPipeProducer, closedProducerMethod = this.producerClosedService.producerClosed, joinConsumeRoomMethod = this.joinConsumeRoomService.joinConsumeRoom, parameters, }) => {
        try {
            const { roomRecvIPs, updateRoomRecvIPs, updateConsume_sockets } = parameters;
            if (!consume_sockets || !remIP || !apiUserName || (!apiKey && !apiToken)) {
                console.log('Missing required parameters - consume_sockets, remIP, apiUserName, apiKey, apiToken');
                return [consume_sockets, roomRecvIPs];
            }
            await Promise.all(remIP.map(async (ip) => {
                try {
                    // Check if the IP is already connected
                    const matching = consume_sockets.find((socketObj) => Object.keys(socketObj)[0] == ip);
                    if (matching || !ip || ip === '' || ip === null || ip === undefined) {
                        // Skip if the IP is already connected
                        return;
                    }
                    // Connect to the remote socket using socket.io-client
                    const remote_sock = await this.socketManagerService.connectSocket({
                        apiUserName,
                        apiKey,
                        apiToken,
                        link: `https://${ip}.mediasfu.com`,
                    });
                    // Handle successful connection to the remote socket
                    if (remote_sock.id) {
                        // Check if the IP is in the roomRecvIPs, if not, add it
                        if (!roomRecvIPs.includes(ip)) {
                            roomRecvIPs.push(ip);
                            updateRoomRecvIPs(roomRecvIPs);
                        }
                        // Handle new pipe producer event
                        remote_sock.on('new-pipe-producer', async ({ producerId, islevel }) => {
                            await newProducerMethod({ producerId, islevel, nsock: remote_sock, parameters });
                        });
                        // Handle producer closed event
                        remote_sock.on('producer-closed', async ({ remoteProducerId }) => {
                            await closedProducerMethod({ remoteProducerId, parameters });
                        });
                        // Handle new consuming room by joining the room
                        const data = await joinConsumeRoomMethod({
                            remote_sock,
                            apiToken,
                            apiUserName,
                            parameters,
                        });
                        if (!data.rtpCapabilities) {
                            return;
                        }
                        // Add the remote socket to the consume_sockets array
                        consume_sockets.push({ [ip]: remote_sock });
                        updateConsume_sockets(consume_sockets);
                    }
                }
                catch (error) {
                    // Handle the error
                    console.log('connectIps error', error);
                }
            }));
            return [consume_sockets, roomRecvIPs];
        }
        catch (error) {
            // Handle the error
            console.log('connectIps error', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectIps, deps: [{ token: SocketManager }, { token: NewPipeProducer }, { token: ProducerClosed }, { token: JoinConsumeRoom }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectIps, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectIps, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: SocketManager }, { type: NewPipeProducer }, { type: ProducerClosed }, { type: JoinConsumeRoom }] });

/**
 * Connects to remote IPs and manages socket connections.
 *
 * This method establishes connections to remote IPs for media streaming, handles new pipe producer events,
 * and manages producer closure events. It updates the necessary state in the application to reflect
 * the current connections and stream configurations.
 *
 * @param {ConnectLocalIpsOptions} options - The options for connecting IPs.
 * @param {Socket} options.socket - The socket connection to use for communication.
 * @param {Function} [options.newProducerMethod] - The method to handle new pipe producer events (default: newPipeProducer).
 * @param {Function} [options.closedProducerMethod] - The method to handle producer closed events (default: producerClosed).
 * @param {ConnectLocalIpsParameters} options.parameters - Additional parameters for the operation.
 *
 * @returns {Promise<void>} A promise that resolves when the connection is established.
 *
 * @throws Will throw an error if required parameters are missing or if there is an issue connecting to a remote IP.
 *
 * @example
 * ```typescript
 * const result = await connectLocalIps({
*     socket,
*     newProducerMethod: newPipeProducer,
*     closedProducerMethod: producerClosed,
*     parameters,
*   });
* ```
*/
class ConnectLocalIps {
    newPipeProducerService;
    producerClosedService;
    constructor(newPipeProducerService, producerClosedService) {
        this.newPipeProducerService = newPipeProducerService;
        this.producerClosedService = producerClosedService;
    }
    /**
     * Connects to remote IPs and manages socket connections.
     *
     * This method establishes connections to remote IPs for media streaming, handles new pipe producer events,
     * and manages producer closure events. It updates the necessary state in the application to reflect
     * the current connections and stream configurations.
     *
     * @param {ConnectLocalIpsOptions} options - The options for connecting IPs.
     * @param {Socket} options.socket - The socket connection to use for communication.
     * @param {Function} [options.newProducerMethod] - The method to handle new pipe producer events (default: newPipeProducer).
     * @param {Function} [options.closedProducerMethod] - The method to handle producer closed events (default: producerClosed).
     * @param {ConnectLocalIpsParameters} options.parameters - Additional parameters for the operation.
     *
     * @returns {Promise<void>} A promise that resolves when the connection is established.
     *
     * @throws Will throw an error if required parameters are missing or if there is an issue connecting to a remote IP.
     *
     * @example
     * ```typescript
     * const result = await connectLocalIps({
    *     socket,
    *     newProducerMethod: newPipeProducer,
    *     closedProducerMethod: producerClosed,
    *     parameters,
    *   });
    * ```
    */
    connectLocalIps = async ({ socket, newProducerMethod = this.newPipeProducerService.newPipeProducer, closedProducerMethod = this.producerClosedService.producerClosed, parameters, }) => {
        try {
            // Handle new pipe producer event
            socket.on('new-producer', async ({ producerId, islevel }) => {
                await newProducerMethod({ producerId, islevel, nsock: socket, parameters });
            });
            // Handle producer closed event
            socket.on('producer-closed', async ({ remoteProducerId }) => {
                await closedProducerMethod({ remoteProducerId, parameters });
            });
            await parameters.receiveAllPipedTransports({ nsock: socket, community: true, parameters });
        }
        catch (error) {
            // Handle the error
            console.log('connectLocalIps error', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectLocalIps, deps: [{ token: NewPipeProducer }, { token: ProducerClosed }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectLocalIps, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectLocalIps, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: NewPipeProducer }, { type: ProducerClosed }] });

/**
 * Connects the receiving transport to consume media from a remote producer.
 *
 * @param {ConnectRecvTransportOptions} options - The options for connecting the receiving transport.
 * @param {Transport} options.consumerTransport - The transport used for consuming media.
 * @param {string} options.remoteProducerId - The ID of the remote producer.
 * @param {string} options.serverConsumerTransportId - The ID of the server consumer transport.
 * @param {Socket} options.nsock - The socket used for communication.
 * @param {ConnectRecvTransportParameters} options.parameters - The parameters for the connection.
 *
 * @returns {Promise<void>} A promise that resolves when the connection is established.
 *
 * @throws Will throw an error if the connection or consumption fails.
 *
 * @example
 * ```typescript
 * const options = {
 *   consumerTransport,
 *   remoteProducerId: 'producer-id',
 *   serverConsumerTransportId: 'transport-id',
 *   nsock: socket,
 *   parameters: connectRecvTransportOptions,
 * };
 *
 * connectRecvTransport(options)
 *   .then(() => {
 *     console.log('Transport connected and consuming media');
 *   })
 *   .catch((error) => {
 *     console.error('Error connecting transport:', error);
 *   });
 * ```
 */
class ConnectRecvTransport {
    /**
     * Connects the receiving transport to consume media from a remote producer.
     *
     * @param {Object} options - The options for connecting the receiving transport.
     * @param {Transport} options.consumerTransport - The transport used for consuming media.
     * @param {string} options.remoteProducerId - The ID of the remote producer.
     * @param {string} options.serverConsumerTransportId - The ID of the server consumer transport.
     * @param {Socket} options.nsock - The socket used for communication.
     * @param {ConnectRecvTransportOptions} options.parameters - The parameters for the connection.
     *
     * @returns {Promise<void>} A promise that resolves when the connection is established.
     *
     * @throws Will throw an error if the connection or consumption fails.
     *
     * @example
     * ```typescript
     * const options = {
     *   consumerTransport,
     *   remoteProducerId: 'producer-id',
     *   serverConsumerTransportId: 'transport-id',
     *   nsock: socket,
     *   parameters: connectRecvTransportOptions,
     * };
     *
     * connectRecvTransport(options)
     *   .then(() => {
     *     console.log('Transport connected and consuming media');
     *   })
     *   .catch((error) => {
     *     console.error('Error connecting transport:', error);
     *   });
     * ```
     */
    connectRecvTransport = async ({ consumerTransport, remoteProducerId, serverConsumerTransportId, nsock, parameters, }) => {
        try {
            parameters = parameters.getUpdatedAllParams();
            const { device, consumerTransports, updateConsumerTransports, consumerResume } = parameters;
            // Emit 'consume' event to signal consumption initiation
            nsock.emit('consume', {
                rtpCapabilities: device ? device.rtpCapabilities : null,
                remoteProducerId,
                serverConsumerTransportId,
            }, async ({ params }) => {
                if (params.error) {
                    // Handle error
                    console.log('consume error', params.error);
                    return;
                }
                try {
                    // Consume media using received parameters
                    const consumer = await consumerTransport.consume({
                        id: params.id,
                        producerId: params.producerId,
                        kind: params.kind,
                        rtpParameters: params.rtpParameters,
                    });
                    // Update consumerTransports array with the new consumer
                    consumerTransports.push({
                        consumerTransport,
                        serverConsumerTransportId: params.id,
                        producerId: remoteProducerId,
                        consumer,
                        socket_: nsock,
                    });
                    updateConsumerTransports(consumerTransports);
                    // Extract track from the consumer
                    const { track } = consumer;
                    // Emit 'consumer-resume' event to signal consumer resumption
                    nsock.emit('consumer-resume', { serverConsumerId: params.serverConsumerId }, async ({ resumed }) => {
                        if (resumed) {
                            // Consumer resumed and ready to be used
                            try {
                                await consumerResume({
                                    track,
                                    kind: params.kind,
                                    remoteProducerId,
                                    params,
                                    parameters,
                                    nsock,
                                    consumer,
                                });
                            }
                            catch (error) {
                                // Handle error
                                console.log('consumerResume error', error);
                            }
                        }
                    });
                }
                catch (error) {
                    // Handle error
                    console.log('consume error', error);
                    return;
                }
            });
        }
        catch (error) {
            // Handle error
            console.log('connectRecvTransport error', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectRecvTransport, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectRecvTransport, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectRecvTransport, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Connects the send transport based on the specified option.
 *
 * @param {ConnectSendTransportOptions} options - The options for connecting the send transport.
 * @param {string} options.option - The type of transport to connect ("audio", "video", "screen", or "all").
 * @param {string} options.targetOption - The target of the transport to connect ("local", "remote", or "all").
 * @param {ConnectSendTransportParameters} options.parameters - The parameters required for connecting the transport.
 * @param {ProducerOptions} options.parameters.audioParams - The audio parameters.
 * @param {ProducerOptions} options.parameters.videoParams - The video parameters.
 * @param {MediaStream} options.parameters.localStreamScreen - The local screen stream.
 * @param {MediaStream} options.parameters.canvasStream - The canvas stream.
 * @param {boolean} options.parameters.whiteboardStarted - Indicates if the whiteboard has started.
 * @param {boolean} options.parameters.whiteboardEnded - Indicates if the whiteboard has ended.
 * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
 * @param {string} options.parameters.islevel - The level of the screen sharing.
 * @param {Function} options.parameters.connectSendTransportAudio - Function to connect the audio send transport.
 * @param {Function} options.parameters.connectSendTransportVideo - Function to connect the video send transport.
 * @param {Function} options.parameters.connectSendTransportScreen - Function to connect the screen send transport.
 *
 * @returns {Promise<void>} A promise that resolves when the transport is connected.
 *
 * @throws Will throw an error if the connection fails.
 *
 * @example
 * ```typescript
 * const options = {
 *   option: 'audio', // Can be 'audio', 'video', 'screen', or 'all'
 *   targetOption: 'local', // Can be 'local', 'remote', or 'all'
 *   parameters: {
 *     audioParams: { codec: 'opus' },
 *     videoParams: { codec: 'vp8' },
 *     localStreamScreen: null, // Set to your local screen stream
 *     canvasStream: null, // Set to your canvas stream if using
 *     whiteboardStarted: false,
 *     whiteboardEnded: true,
 *     shared: false,
 *     islevel: '1',
 *     connectSendTransportAudio: connectSendTransportAudioFunction,
 *     connectSendTransportVideo: connectSendTransportVideoFunction,
 *     connectSendTransportScreen: connectSendTransportScreenFunction,
 *     updateVideoProducer: () => {},
 *     updateProducerTransport: () => {},
 *     updateScreenProducer: () => {},
 *     updateMainWindow: false,
 *   },
 * };
 *
 * connectSendTransport(options)
 *   .then(() => {
 *     console.log('Transport connected successfully');
 *   })
 *   .catch((error) => {
 *     console.error('Error connecting transport:', error);
 *   });
 * ```
 */
class ConnectSendTransport {
    /**
     * Connects the send transport based on the specified option.
     *
     * @param {ConnectSendTransportOptions} options - The options for connecting the send transport.
     * @param {string} options.option - The type of transport to connect ("audio", "video", "screen", or both).
     * @param {string} options.targetOption - The target of the transport to connect ("local", "remote", or "all").
     * @param {Object} options.parameters - The parameters required for connecting the transport.
     * @param {Object} options.parameters.audioParams - The audio parameters.
     * @param {Object} options.parameters.videoParams - The video parameters.
     * @param {MediaStream} options.parameters.localStreamScreen - The local screen stream.
     * @param {MediaStream} options.parameters.canvasStream - The canvas stream.
     * @param {boolean} options.parameters.whiteboardStarted - Indicates if the whiteboard has started.
     * @param {boolean} options.parameters.whiteboardEnded - Indicates if the whiteboard has ended.
     * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
     * @param {string} options.parameters.islevel - The level of the screen sharing.
     * @param {Function} options.parameters.connectSendTransportAudio - Function to connect the audio send transport.
     * @param {Function} options.parameters.connectSendTransportVideo - Function to connect the video send transport.
     * @param {Function} options.parameters.connectSendTransportScreen - Function to connect the screen send transport.
     *
     * @returns {Promise<void>} A promise that resolves when the transport is connected.
     *
     * @throws Will throw an error if the connection fails.
     */
    async connectSendTransport({ option, targetOption = "all", parameters }) {
        try {
            const { audioParams, videoParams, localStreamScreen, canvasStream, whiteboardStarted, whiteboardEnded, shared, islevel, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, } = parameters;
            // Connect send transport based on the specified option
            if (option === 'audio') {
                await connectSendTransportAudio({
                    targetOption,
                    audioParams,
                    parameters,
                });
            }
            else if (option === 'video') {
                await connectSendTransportVideo({
                    targetOption,
                    videoParams,
                    parameters,
                });
            }
            else if (option === 'screen') {
                if (whiteboardStarted && !whiteboardEnded && canvasStream && islevel === '2' && !shared) {
                    await connectSendTransportScreen({
                        targetOption,
                        stream: canvasStream,
                        parameters,
                    });
                }
                else {
                    if (localStreamScreen) {
                        await connectSendTransportScreen({
                            targetOption,
                            stream: localStreamScreen,
                            parameters,
                        });
                    }
                    else {
                        throw new Error('localStreamScreen is null or undefined');
                    }
                }
            }
            else {
                // Connect both audio and video send transports
                await connectSendTransportAudio({
                    targetOption,
                    audioParams,
                    parameters,
                });
                await connectSendTransportVideo({
                    targetOption,
                    videoParams,
                    parameters,
                });
            }
        }
        catch (error) {
            console.log('connectSendTransport error', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransport, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransport, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransport, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

const updateMicLevel = async (audioProducer, updateAudioLevel) => {
    try {
        setInterval(() => {
            const sender = audioProducer.rtpSender;
            sender?.getStats().then((stats) => {
                stats.forEach((report) => {
                    if (report.type === 'media-source' && report.kind === 'audio' && report.audioLevel !== undefined) {
                        const newLevel = 127.5 + (report.audioLevel * 127.5);
                        updateAudioLevel(newLevel);
                    }
                });
            });
        }, 1000);
    }
    catch {
        // Handle error
    }
};
const connectLocalSendTransportAudio = async ({ parameters, audioParams }) => {
    try {
        let { localAudioProducer, localProducerTransport, updateLocalAudioProducer, updateLocalProducerTransport, } = parameters;
        if (localProducerTransport) {
            localAudioProducer = await localProducerTransport.produce(audioParams);
            updateLocalAudioProducer?.(localAudioProducer);
            updateLocalProducerTransport?.(localProducerTransport);
        }
    }
    catch (error) {
        console.error("Error connecting local audio transport:", error);
        throw error; // Re-throw to let the parent handle it
    }
};
/**
 * Connects the send transport for audio by producing audio data and updating the audio producer and producer transport objects.
 *
 * @param {ConnectSendTransportAudioOptions} options - The parameters for connecting the send transport.
 * @param {ProducerOptions} options.audioParams - The options for the audio producer.
 * @param {ConnectSendTransportAudioParameters} options.parameters - The parameters containing the audio producer, producer transport, and update functions.
 * @param {Producer} options.parameters.audioProducer - The current audio producer.
 * @param {Transport} options.parameters.producerTransport - The transport used to produce audio data.
 * @param {Function} options.parameters.updateAudioProducer - Function to update the audio producer.
 * @param {Function} options.parameters.updateProducerTransport - Function to update the producer transport.
 * @param {Function} [options.parameters.updateLocalAudioProducer] - Function to update the local audio producer.
 * @param {Function} [options.parameters.updateLocalProducerTransport] - Function to update the local producer transport.
 * @param {Function} options.parameters.updateAudioLevel - Function to update the audio level.
 *
 * @returns {Promise<void>} A promise that resolves when the audio transport is successfully connected.
 *
 * @throws Will throw an error if the connection fails.
 *
 * @example
 * ```typescript
 * const audioParams: ProducerOptions = {
 *   codec: 'opus',
 *   // other options
 * };
 *
 * const parameters = {
 *   audioProducer: null,
 *   producerTransport: transport,
 *   updateAudioProducer: (producer) => { console.log(updated) },
  *   updateProducerTransport: (transport) => { console.log(updated) },
  *  updateLocalAudioProducer: (localProducer) => { console.log(updated) },
  *  updateLocalProducerTransport: (localTransport) => { console.log(updated) },
  *  updateAudioLevel: (level) => { console.log(level) },
  * };
  *
  * connectSendTransportAudio({ audioParams, parameters })
  *   .then(() => {
  *     console.log('Audio transport connected successfully');
  *   })
  *   .catch((error) => {
  *     console.error('Error connecting audio transport:', error);
  *   });
  * ```
  */
class ConnectSendTransportAudio {
    /**
     * Connects the send transport for audio by producing audio data and updating the audio producer and producer transport objects.
     *
     * @param {ConnectSendTransportAudioOptions} options - The options for connecting the send transport.
     * @param {ProducerOptions} options.audioParams - The audio parameters.
     * @param {ConnectSendTransportAudioParameters} options.parameters - The parameters required for connecting the transport.
     * @param {Producer | null} options.parameters.audioProducer - The audio producer object.
     * @param {Transport | null} options.parameters.producerTransport - The producer transport object.
     * @param {Producer | null} [options.parameters.localAudioProducer] - The local audio producer object.
     * @param {Transport | null} [options.parameters.localProducerTransport] - The local producer transport object.
     * @param {(producer: Producer | null) => void} options.parameters.updateAudioProducer - The function to update the audio producer object.
     * @param {(transport: Transport | null) => void} options.parameters.updateProducerTransport - The function to update the producer transport object.
     * @param {(localProducer: Producer | null) => void} [options.parameters.updateLocalAudioProducer] - The function to update the local audio producer object.
     * @param {(localTransport: Transport | null) => void} [options.parameters.updateLocalProducerTransport] - The function to update the local producer transport object.
     * @param {(level: number) => void} options.parameters.updateAudioLevel - The function to update the audio level.
     * @returns {Promise<void>} A promise that resolves when the connection is established.
     *
     * @throws Will throw an error if the connection fails.
     *
     * @example
     * ```typescript
     * const options = {
     *  audioParams: { codec: 'opus' },
     * parameters: {
     * audioProducer: null,
     * producerTransport: transport,
     * updateAudioProducer: (producer) => { console.log(updated) },
     * updateProducerTransport: (transport) => { console.log(updated) },
     * updateLocalAudioProducer: (localProducer) => { console.log(updated) },
     * updateLocalProducerTransport: (localTransport) => { console.log(updated) },
     * },
     * };
     *
     * connectSendTransportAudio(options)
     * .then(() => {
     * console.log('Audio transport connected successfully');
     * })
     * .catch((error) => {
     * console.error('Error connecting audio transport:', error);
     * });
     * ```
     *
    */
    async connectSendTransportAudio({ targetOption = "all", audioParams, parameters, }) {
        try {
            let { audioProducer, producerTransport, updateAudioProducer, updateProducerTransport } = parameters;
            // Attempt to connect the primary send transport
            if (targetOption === "all" || targetOption === "remote") {
                audioProducer = await producerTransport.produce(audioParams);
                // Update the audio level
                updateMicLevel(audioProducer, parameters.updateAudioLevel);
                // Update state with the new producer and transport
                updateAudioProducer(audioProducer);
                updateProducerTransport(producerTransport);
            }
            // Attempt to connect the local send transport
            if (targetOption === "all" || targetOption === "local") {
                try {
                    await connectLocalSendTransportAudio({ parameters, audioParams });
                    // Update the audio level
                    if (targetOption === 'local' && parameters.updateAudioLevel) {
                        if (!parameters.localAudioProducer) {
                            parameters = parameters.getUpdatedAllParams();
                        }
                        updateMicLevel(parameters.localAudioProducer, parameters.updateAudioLevel);
                    }
                }
                catch (localError) {
                    console.error("Local audio transport connection failed:", localError);
                }
            }
        }
        catch (primaryError) {
            console.error("audio transport connection failed:", primaryError);
            throw new Error("Failed to connect to audio transport.");
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransportAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransportAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransportAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

const connectLocalSendTransportScreen = async ({ stream, parameters, }) => {
    try {
        let { localScreenProducer, localProducerTransport, updateLocalScreenProducer, updateLocalProducerTransport, device, } = parameters;
        // Find VP9 codec for local screen share
        const codec = device?.rtpCapabilities?.codecs?.find((codec) => codec.mimeType.toLowerCase() === "video/vp9");
        // Produce local screen share data
        if (localProducerTransport) {
            localScreenProducer = await localProducerTransport.produce({
                track: stream?.getVideoTracks()[0],
                codec,
                appData: { mediaTag: "screen-video" },
            });
            // Update the local producer and transport objects
            updateLocalScreenProducer?.(localScreenProducer);
            updateLocalProducerTransport?.(localProducerTransport);
        }
    }
    catch (error) {
        console.error("Error connecting local screen transport:", error);
        throw error; // Re-throw to propagate the error
    }
};
/**
 * Sets up and connects a screen sharing transport for sending video streams.
 *
 * This function supports both a primary and a local screen producer, delegating local handling to a separate function.
 *
 * @param {ConnectSendTransportScreenOptions} options - The configuration options for setting up the screen transport.
 * @param {"all" | "local" | "remote"} [options.targetOption] - The target option for connecting the transport.
 * @param {MediaStream} options.stream - The screen stream to be shared.
 * @param {ConnectSendTransportScreenParameters} options.parameters - The parameters required for setting up the screen transport.
 * @param {Producer | null} options.parameters.screenProducer - The screen producer object to be updated.
 * @param {Device | null} options.parameters.device - The device object for media capabilities.
 * @param {ProducerOptions} options.parameters.screenParams - The parameters for the screen producer.
 * @param {Transport | null} options.parameters.producerTransport - The producer transport object.
 * @param {ProducerOptions} options.parameters.params - The parameters for the producer.
 * @param {Function} options.parameters.updateScreenProducer - The function to update the screen producer object.
 * @param {Function} options.parameters.updateProducerTransport - The function to update the producer transport object.
 * @param {Function} [options.parameters.updateLocalScreenProducer] - The function to update the local screen producer object.
 * @param {Function} [options.parameters.updateLocalProducerTransport] - The function to update the local producer transport object.
 * @param {Function} options.parameters.getUpdatedAllParams - The function to get updated parameters.
 * @param {Object} [options.parameters.*] - Additional parameters for future use.
 *
 * @returns {Promise<void>} - A promise that resolves once the screen transport is successfully connected and set up.
 *
 * @throws Will throw an error if there is an issue with the connection or setup process.
 *
 * @example
 * ```typescript
 * await connectSendTransportScreen({
 *   stream: screenStream,
 *   targetOption: "all",
 *   parameters: {
 *     screenProducer: null,
 *     localScreenProducer: null,
 *     device: mediaDevice,
 *     screenParams: { encodings: [{ maxBitrate: 1500000 }] },
 *     producerTransport: sendTransport,
 *     localProducerTransport: localSendTransport,
 *     params: { track: screenStream.getVideoTracks()[0] },
 *     updateScreenProducer: setScreenProducer,
 *     updateLocalScreenProducer: setLocalScreenProducer,
 *     updateProducerTransport: setProducerTransport,
 *     updateLocalProducerTransport: setLocalProducerTransport,
 *     getUpdatedAllParams: getParams,
 *   },
 * });
 * ```
 */
class ConnectSendTransportScreen {
    /**
     * Sets up and connects a screen sharing transport for sending video streams.
     *
     * This function supports both a primary and a local screen producer, delegating local handling to a separate function.
     *
     * @param {ConnectSendTransportScreenOptions} options - The configuration options for setting up the screen transport.
     * @param {"all" | "local" | "remote"} [options.targetOption] - The target option for connecting the transport.
     * @param {MediaStream} options.stream - The screen stream to be shared.
     * @param {ConnectSendTransportScreenParameters} options.parameters - The parameters required for setting up the screen transport.
     * @param {Producer | null} options.parameters.screenProducer - The screen producer object to be updated.
     * @param {Device | null} options.parameters.device - The device object for media capabilities.
     * @param {ProducerOptions} options.parameters.screenParams - The parameters for the screen producer.
     * @param {Transport | null} options.parameters.producerTransport - The producer transport object.
     * @param {ProducerOptions} options.parameters.params - The parameters for the producer.
     * @param {Function} options.parameters.updateScreenProducer - The function to update the screen producer object.
     * @param {Function} options.parameters.updateProducerTransport - The function to update the producer transport object.
     * @param {Function} [options.parameters.updateLocalScreenProducer] - The function to update the local screen producer object.
     * @param {Function} [options.parameters.updateLocalProducerTransport] - The function to update the local producer transport object.
     * @param {Function} options.parameters.getUpdatedAllParams - The function to get updated parameters.
     * @param {Object} [options.parameters.*] - Additional parameters for future use.
     *
     * @returns {Promise<void>} - A promise that resolves once the screen transport is successfully connected and set up.
     *
     * @throws Will throw an error if there is an issue with the connection or setup process.
     *
     * @example
     * ```typescript
     * await connectSendTransportScreen({
     *   stream: screenStream,
     *   targetOption: "all",
     *   parameters: {
     *     screenProducer: null,
     *     localScreenProducer: null,
     *     device: mediaDevice,
     *     screenParams: { encodings: [{ maxBitrate: 1500000 }] },
     *     producerTransport: sendTransport,
     *     localProducerTransport: localSendTransport,
     *     params: { track: screenStream.getVideoTracks()[0] },
     *     updateScreenProducer: setScreenProducer,
     *     updateLocalScreenProducer: setLocalScreenProducer,
     *     updateProducerTransport: setProducerTransport,
     *     updateLocalProducerTransport: setLocalProducerTransport,
     *     getUpdatedAllParams: getParams,
     *   },
     * });
     * ```
     */
    async connectSendTransportScreen({ stream, parameters, targetOption = "all", }) {
        try {
            let { screenProducer, device, screenParams, producerTransport, params, updateScreenProducer, updateProducerTransport, } = parameters;
            device = parameters.getUpdatedAllParams().device;
            // Retrieve screen share parameters
            params = screenParams;
            // Find VP9 codec for screen share
            const codec = device?.rtpCapabilities?.codecs?.find((codec) => codec.mimeType.toLowerCase() === "video/vp9");
            // Produce screen share data using the producer transport
            if (targetOption === "remote" || targetOption === "all") {
                screenProducer = await producerTransport.produce({
                    track: stream?.getVideoTracks()[0],
                    ...params,
                    codec,
                    appData: { mediaTag: "screen-video" },
                });
                // Update the screen producer and producer transport objects
                updateScreenProducer(screenProducer);
                updateProducerTransport(producerTransport);
            }
            // Produce screen share data using the local producer transport
            if (targetOption === "local" || targetOption === "all") {
                try {
                    await connectLocalSendTransportScreen({ stream, parameters });
                }
                catch (localError) {
                    console.log("Error connecting local screen transport:", localError);
                }
            }
        }
        catch (error) {
            console.log("connectSendTransportScreen error", error);
            throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransportScreen, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransportScreen, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransportScreen, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

const connectLocalSendTransportVideo = async ({ videoParams, parameters, }) => {
    try {
        let { localVideoProducer, localProducerTransport, updateLocalVideoProducer, updateLocalProducerTransport, } = parameters;
        // Produce local video data if transport exists
        if (localProducerTransport) {
            localVideoProducer = await localProducerTransport.produce(videoParams);
            // Update local producer and transport
            updateLocalVideoProducer?.(localVideoProducer);
            updateLocalProducerTransport?.(localProducerTransport);
        }
    }
    catch (error) {
        console.error("Error connecting local video transport:", error);
        throw error; // Re-throw to propagate the error
    }
};
/**
 * Connects the send transport for video by producing video data and updates the relevant states.
 *
 * This function supports both a primary and a local video producer, delegating local handling to a separate function.
 *
 * @param {ConnectSendTransportVideoOptions} options - The options for connecting the send transport for video.
 * @param {ProducerOptions} options.videoParams - The parameters for the video producer.
 * @param {"all" | "local" | "remote"} [options.targetOption] - The target option for the video transport connection.
 * @param {ConnectSendTransportVideoParameters} options.parameters - The parameters for the video transport connection.
 * @param {Producer | null} options.parameters.videoProducer - The primary video producer.
 * @param {Producer | null} [options.parameters.localVideoProducer] - The local video producer.
 * @param {Device | null} options.parameters.device - The device information.
 * @param {Transport | null} options.parameters.producerTransport - The primary producer transport.
 * @param {Transport | null} [options.parameters.localProducerTransport] - The local producer transport.
 * @param {string} options.parameters.islevel - The connection level for the video transport.
 * @param {boolean} options.parameters.updateMainWindow - The flag to update the main window state.
 * @param {(producer: Producer | null) => void} options.parameters.updateVideoProducer - The function to update the video producer state.
 * @param {(localProducer: Producer | null) => void} [options.parameters.updateLocalVideoProducer] - The function to update the local video producer state.
 * @param {(transport: Transport | null) => void} options.parameters.updateProducerTransport - The function to update the producer transport state.
 * @param {(localTransport: Transport | null) => void} [options.parameters.updateLocalProducerTransport] - The function to update the local producer transport state.
 * @param {(state: boolean) => void} options.parameters.updateUpdateMainWindow - The function to update the main window state.
 * @param {any} [options.parameters] - Additional parameters for future use.
 * @returns {Promise<void>} A promise that resolves when the send transport for video is connected.
 *
 * @throws Will throw an error if the connection fails.
 *
 * @example
 * const options = {
 *   videoParams: {
 *     // video producer options (e.g., codec, bitrate)
 *   },
 *   targetOption: "all",
 *   parameters: {
 *     videoProducer: null,
 *     localVideoProducer: null,
 *     producerTransport: transport,
 *     localProducerTransport: localTransport,
 *     islevel: '2',
 *     updateMainWindow: false,
 *     updateVideoProducer: (producer) => console.log("Updated producer"),
 *     updateLocalVideoProducer: (localProducer) => console.log("Updated local producer"),
 *     updateProducerTransport: (transport) => console.log("Updated transport"),
 *     updateLocalProducerTransport: (localTransport) => console.log("Updated local transport"),
 *     updateUpdateMainWindow: (state) => console.log("Updated main window:", state),
 *   },
 * };
 *
 * connectSendTransportVideo(options)
 *   .then(() => console.log("Video transport connected successfully"))
 *   .catch((error) => console.error("Error connecting video transport:", error));
 */
class ConnectSendTransportVideo {
    /**
     * Connects the send transport for video by producing video data and updates the relevant states.
     *
     * This function supports both a primary and a local video producer, delegating local handling to a separate function.
     *
     * @param {ConnectSendTransportVideoOptions} options - The options for connecting the send transport for video.
     * @param {ProducerOptions} options.videoParams - The parameters for the video producer.
     * @param {"all" | "local" | "remote"} [options.targetOption] - The target option for the video transport connection.
     * @param {ConnectSendTransportVideoParameters} options.parameters - The parameters for the video transport connection.
     * @param {Producer | null} options.parameters.videoProducer - The primary video producer.
     * @param {Producer | null} [options.parameters.localVideoProducer] - The local video producer.
     * @param {Device | null} options.parameters.device - The device information.
     * @param {Transport | null} options.parameters.producerTransport - The primary producer transport.
     * @param {Transport | null} [options.parameters.localProducerTransport] - The local producer transport.
     * @param {string} options.parameters.islevel - The connection level for the video transport.
     * @param {boolean} options.parameters.updateMainWindow - The flag to update the main window state.
     * @param {(producer: Producer | null) => void} options.parameters.updateVideoProducer - The function to update the video producer state.
     * @param {(localProducer: Producer | null) => void} [options.parameters.updateLocalVideoProducer] - The function to update the local video producer state.
     * @param {(transport: Transport | null) => void} options.parameters.updateProducerTransport - The function to update the producer transport state.
     * @param {(localTransport: Transport | null) => void} [options.parameters.updateLocalProducerTransport] - The function to update the local producer transport state.
     * @param {(state: boolean) => void} options.parameters.updateUpdateMainWindow - The function to update the main window state.
     * @param {any} [options.parameters] - Additional parameters for future use.
     * @returns {Promise<void>} A promise that resolves when the send transport for video is connected.
     *
     * @throws Will throw an error if the connection fails.
     *
     * @example
     * const options = {
     *   videoParams: {
     *     // video producer options (e.g., codec, bitrate)
     *   },
     *   targetOption: "all",
     *   parameters: {
     *     videoProducer: null,
     *     localVideoProducer: null,
     *     producerTransport: transport,
     *     localProducerTransport: localTransport,
     *     islevel: '2',
     *     updateMainWindow: false,
     *     updateVideoProducer: (producer) => console.log("Updated producer"),
     *     updateLocalVideoProducer: (localProducer) => console.log("Updated local producer"),
     *     updateProducerTransport: (transport) => console.log("Updated transport"),
     *     updateLocalProducerTransport: (localTransport) => console.log("Updated local transport"),
     *     updateUpdateMainWindow: (state) => console.log("Updated main window:", state),
     *   },
     * };
     *
     * connectSendTransportVideo(options)
     *   .then(() => console.log("Video transport connected successfully"))
     *   .catch((error) => console.error("Error connecting video transport:", error));
     */
    connectSendTransportVideo = async ({ videoParams, parameters, targetOption = 'all', }) => {
        try {
            let { videoProducer, producerTransport, islevel, updateMainWindow, updateVideoProducer, updateProducerTransport, updateUpdateMainWindow, } = parameters;
            // Produce video data using the primary transport
            if (targetOption === "all" || targetOption === "remote") {
                videoProducer = await producerTransport.produce(videoParams);
                // Update main window state based on the video connection level
                if (islevel === "2") {
                    updateMainWindow = true;
                }
                // Update video producer, transport, and UI state
                updateVideoProducer(videoProducer);
                updateProducerTransport(producerTransport);
                updateUpdateMainWindow(updateMainWindow);
            }
            // Handle local video transport regardless of primary success or
            if (targetOption === "all" || targetOption === "local") {
                try {
                    await connectLocalSendTransportVideo({ videoParams, parameters });
                }
                catch (localError) {
                    console.log("Error connecting local video transport:", localError);
                }
            }
        }
        catch (error) {
            console.log("connectSendTransportVideo error", error);
            throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransportVideo, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransportVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConnectSendTransportVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * MiniAudio component is a draggable, customizable mini audio player with optional waveform animations.
 *
 * @selector app-mini-audio
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * ```html
 * <div *ngIf="visible" class="modal-container" [ngStyle]="{ transform: 'translate(' + position.x + 'px, ' + position.y + 'px)' }" (mousedown)="handleMouseDown($event)">
 *   <div class="card" [ngStyle]="customStyle">
 *     <ng-container *ngIf="imageSource">
 *       <img [src]="imageSource" [ngStyle]="getImageStyle()" alt="Background" class="background-image" />
 *     </ng-container>
 *     <div class="name-text" [ngStyle]="combineStyles({ color: textColor }, nameTextStyling)">
 *       {{ name }}
 *     </div>
 *     <div [ngStyle]="getOverlayPosition(overlayPosition)" class="overlay-web">
 *       <div class="waveform-web">
 *         <div *ngFor="let animation of waveformAnimations; let i = index"
 *              [ngStyle]="{ height: animation == 0 ? '1px' : '30px', width: '10px', backgroundColor: barColor }"
 *              class="bar">
 *         </div>
 *       </div>
 *     </div>
 *   </div>
 * </div>
 * ```
 *
 * @styles
 * - `.modal-container`: Positioning and drag area.
 * - `.card`: The main container styling.
 * - `.background-image`: Styling for an optional background image.
 * - `.name-text`: Styling for name text with customizable color.
 * - `.overlay-web` and `.waveform-web`: Contains and styles the waveform animation bars.
 *
 * @inputs
 * - `visible` (boolean): Show/hide the component.
 * - `customStyle` (object): Custom styles for the component.
 * - `name` (string): Text to display as the name.
 * - `showWaveform` (boolean): Show/hide waveform animations.
 * - `overlayPosition` (string): Position of the overlay.
 * - `barColor` (string): Color of waveform bars.
 * - `textColor` (string): Color of name text.
 * - `nameTextStyling` (object): Additional styles for the name text.
 * - `imageSource` (string): URL of the background image.
 * - `roundedImage` (boolean): If true, applies rounded corners to the image.
 * - `imageStyle` (object): Custom styles for the image.
 *
 * @property `waveformAnimations` (array): Tracks animation states for each waveform bar.
 * @property `position` (object): Tracks x and y positioning for dragging.
 *
 * @methods
 * - `ngOnInit()`: Starts waveform animations if `showWaveform` is true.
 * - `ngOnDestroy()`: Clears waveform animation intervals.
 * - `animateWaveform()`: Sets intervals for each bar's animation.
 * - `handleMouseDown(event: MouseEvent)`: Starts dragging on mousedown.
 * - `handleMouseMove(event: MouseEvent)`: Updates position during drag.
 * - `handleMouseUp()`: Ends dragging on mouseup.
 *
 * @example
 * ```html
 * <app-mini-audio [visible]="true" [name]="'Audio Player'" [barColor]="'blue'" [imageSource]="'/path/to/image.png'"></app-mini-audio>
 * ```
 */
class MiniAudio {
    visible = true;
    customStyle;
    name = '';
    showWaveform = false;
    overlayPosition = '';
    barColor = 'red';
    textColor = 'white';
    nameTextStyling = {};
    imageSource = '';
    roundedImage = false;
    imageStyle = {};
    waveformAnimations = Array.from({ length: 9 }, () => 0);
    intervals = [];
    position = { x: 0, y: 0 };
    isDragging = false;
    dragOffset = { x: 0, y: 0 };
    constructor(injectedVisible, injectedCustomStyle, injectedName, injectedShowWaveform, injectedOverlayPosition, injectedBarColor, injectedTextColor, injectedNameTextStyling, injectedImageSource, injectedRoundedImage, injectedImageStyle) {
        this.visible = injectedVisible != null ? injectedVisible : this.visible;
        this.customStyle = injectedCustomStyle || this.customStyle;
        this.name = injectedName || this.name;
        this.showWaveform = injectedShowWaveform != null ? injectedShowWaveform : this.showWaveform;
        this.overlayPosition = injectedOverlayPosition || this.overlayPosition;
        this.barColor = injectedBarColor || this.barColor;
        this.textColor = injectedTextColor || this.textColor;
        this.nameTextStyling = injectedNameTextStyling || this.nameTextStyling;
        this.imageSource = injectedImageSource || this.imageSource;
        this.roundedImage = injectedRoundedImage != null ? injectedRoundedImage : this.roundedImage;
        this.imageStyle = injectedImageStyle || this.imageStyle;
    }
    ngOnInit() {
        if (this.showWaveform) {
            this.animateWaveform();
        }
        else {
            this.resetWaveform();
        }
    }
    ngOnDestroy() {
        this.clearIntervals();
    }
    animateWaveform() {
        this.intervals = this.waveformAnimations.map((_, index) => setInterval(() => this.animateBar(index), this.getAnimationDuration(index) * 2));
    }
    animateBar(index) {
        this.waveformAnimations[index] = 1;
        setTimeout(() => {
            this.waveformAnimations[index] = 0;
        }, this.getAnimationDuration(index));
    }
    resetWaveform() {
        this.waveformAnimations.fill(0);
    }
    clearIntervals() {
        this.intervals.forEach((interval) => clearInterval(interval));
    }
    getAnimationDuration(index) {
        const durations = [474, 433, 407, 458, 400, 427, 441, 419, 487];
        return durations[index] || 0;
    }
    getImageStyle() {
        return {
            ...this.imageStyle,
            ...(this.roundedImage ? { borderRadius: '20%' } : {}),
        };
    }
    combineStyles(baseStyle, additionalStyles) {
        return { ...baseStyle, ...additionalStyles };
    }
    handleMouseDown(event) {
        this.isDragging = true;
        this.dragOffset = {
            x: event.clientX - this.position.x,
            y: event.clientY - this.position.y,
        };
    }
    handleMouseMove(event) {
        if (this.isDragging) {
            this.position = {
                x: event.clientX - this.dragOffset.x,
                y: event.clientY - this.dragOffset.y,
            };
        }
    }
    handleMouseUp() {
        this.isDragging = false;
    }
    getOverlayPosition(position) {
        return getOverlayPosition({ position });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MiniAudio, deps: [{ token: 'visible', optional: true }, { token: 'customStyle', optional: true }, { token: 'name', optional: true }, { token: 'showWaveform', optional: true }, { token: 'overlayPosition', optional: true }, { token: 'barColor', optional: true }, { token: 'textColor', optional: true }, { token: 'nameTextStyling', optional: true }, { token: 'imageSource', optional: true }, { token: 'roundedImage', optional: true }, { token: 'imageStyle', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MiniAudio, isStandalone: true, selector: "app-mini-audio", inputs: { visible: "visible", customStyle: "customStyle", name: "name", showWaveform: "showWaveform", overlayPosition: "overlayPosition", barColor: "barColor", textColor: "textColor", nameTextStyling: "nameTextStyling", imageSource: "imageSource", roundedImage: "roundedImage", imageStyle: "imageStyle" }, host: { listeners: { "document:mousemove": "handleMouseMove($event)", "document:mouseup": "handleMouseUp()" } }, ngImport: i0, template: `
    <div
      *ngIf="visible"
      class="modal-container"
      [ngStyle]="{ transform: 'translate(' + position.x + 'px, ' + position.y + 'px)' }"
      (mousedown)="handleMouseDown($event)"
    >
      <div class="card" [ngStyle]="customStyle">
        <ng-container *ngIf="imageSource">
          <img
            [src]="imageSource"
            [ngStyle]="getImageStyle()"
            alt="Background"
            class="background-image"
          />
        </ng-container>
        <div class="name-text" [ngStyle]="combineStyles({ color: textColor }, nameTextStyling)">
          {{ name }}
        </div>
        <div [ngStyle]="getOverlayPosition(overlayPosition)" class="overlay-web">
          <div class="waveform-web">
            <div
              *ngFor="let animation of waveformAnimations; let i = index"
              [ngStyle]="{
                height: animation == 0 ? '1px' : '30px',
                width: '10px',
                backgroundColor: barColor
              }"
              class="bar"
            ></div>
          </div>
        </div>
      </div>
    </div>
  `, isInline: true, styles: [".modal-container{position:absolute;top:0;right:0;padding:0;margin:0;width:100px;height:100px;display:flex;justify-content:center;align-items:center;background-color:#002d2180;z-index:8;elevation:8}.card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f}.background-image{position:absolute;width:70px;height:70px;justify-content:center;align-items:center;align-self:center;top:40%;left:50%;transform:translate(-35px,-10px)}.name-text{font-size:20px;font-weight:700;display:flex;justify-content:center;align-items:center;background-color:#00000080;width:100%;padding-top:5px;padding-bottom:5px;text-align:center;z-index:2}.overlay-web{position:absolute;width:100%;height:100%;display:grid;grid-template-columns:1fr 12fr 1fr;grid-gap:3px;z-index:3}.waveform-web{display:flex;justify-content:center;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin-right:.5px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MiniAudio, decorators: [{
            type: Component,
            args: [{ selector: 'app-mini-audio', imports: [CommonModule], template: `
    <div
      *ngIf="visible"
      class="modal-container"
      [ngStyle]="{ transform: 'translate(' + position.x + 'px, ' + position.y + 'px)' }"
      (mousedown)="handleMouseDown($event)"
    >
      <div class="card" [ngStyle]="customStyle">
        <ng-container *ngIf="imageSource">
          <img
            [src]="imageSource"
            [ngStyle]="getImageStyle()"
            alt="Background"
            class="background-image"
          />
        </ng-container>
        <div class="name-text" [ngStyle]="combineStyles({ color: textColor }, nameTextStyling)">
          {{ name }}
        </div>
        <div [ngStyle]="getOverlayPosition(overlayPosition)" class="overlay-web">
          <div class="waveform-web">
            <div
              *ngFor="let animation of waveformAnimations; let i = index"
              [ngStyle]="{
                height: animation == 0 ? '1px' : '30px',
                width: '10px',
                backgroundColor: barColor
              }"
              class="bar"
            ></div>
          </div>
        </div>
      </div>
    </div>
  `, styles: [".modal-container{position:absolute;top:0;right:0;padding:0;margin:0;width:100px;height:100px;display:flex;justify-content:center;align-items:center;background-color:#002d2180;z-index:8;elevation:8}.card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f}.background-image{position:absolute;width:70px;height:70px;justify-content:center;align-items:center;align-self:center;top:40%;left:50%;transform:translate(-35px,-10px)}.name-text{font-size:20px;font-weight:700;display:flex;justify-content:center;align-items:center;background-color:#00000080;width:100%;padding-top:5px;padding-bottom:5px;text-align:center;z-index:2}.overlay-web{position:absolute;width:100%;height:100%;display:grid;grid-template-columns:1fr 12fr 1fr;grid-gap:3px;z-index:3}.waveform-web{display:flex;justify-content:center;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin-right:.5px}\n"] }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['visible']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['name']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showWaveform']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['overlayPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['barColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['textColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['nameTextStyling']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageSource']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['roundedImage']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageStyle']
                }] }], propDecorators: { visible: [{
                type: Input
            }], customStyle: [{
                type: Input
            }], name: [{
                type: Input
            }], showWaveform: [{
                type: Input
            }], overlayPosition: [{
                type: Input
            }], barColor: [{
                type: Input
            }], textColor: [{
                type: Input
            }], nameTextStyling: [{
                type: Input
            }], imageSource: [{
                type: Input
            }], roundedImage: [{
                type: Input
            }], imageStyle: [{
                type: Input
            }], handleMouseMove: [{
                type: HostListener,
                args: ['document:mousemove', ['$event']]
            }], handleMouseUp: [{
                type: HostListener,
                args: ['document:mouseup']
            }] } });

/**
 * The `MiniAudioPlayer` component manages audio playback for participants in a meeting, including volume control, audio visualization, and connection to the main application state.
 * It uses audio analysis to display waveforms for active speakers and supports breakout room conditions, participant-specific audio decibel updates, and other media state dependencies.
 *
 * @component
 * @example
 * ```html
 * <app-mini-audio-player
 *    [stream]="audioStream"
 *    [consumer]="audioConsumer"
 *    [remoteProducerId]="producerId"
 *    [parameters]="audioPlayerParameters">
 * </app-mini-audio-player>
 * ```
 *
 * @param {MediaStream} [stream] - The audio stream from the participant.
 * @param {Consumer} [consumer] - The audio consumer for the participant.
 * @param {string} [remoteProducerId] - Unique ID for the remote producer of the audio stream.
 * @param {MiniAudioPlayerParameters} [parameters] - Configuration object with various parameters and utility functions for audio management.
 * @param {Component} [MiniAudioComponent] - Optional audio visualization component injected into the `MiniAudioPlayer`.
 * @param {Record<string, any>} [miniAudioProps] - Additional properties for configuring the audio visualization component.
 *
 * @returns {HTMLElement} The created audio player element.
 *
 * @remarks
 * The `MiniAudioPlayer` processes audio data and manage audio levels.
 * It supports a dynamic breakout room feature that restricts audio visibility to limited participants, updates decibel levels for individual participants, and adjusts the waveforms based on audio activity.
 *
 * Key functionalities include:
 * - Automatically toggling wave visualization for active speakers.
 * - Handling audio settings for different room states (e.g., shared screens, breakout rooms).
 * - Injecting configuration and parameter dependencies dynamically through `Injector`.
 *
 * @dependencies
 * - `setInterval` for periodic volume level checks (auto-clears on component destruction).
 * - `ReUpdateInterType` and `UpdateParticipantAudioDecibelsType` for dynamic participant audio decibel management.
 *
 * @example
 * ```typescript
 * const audioPlayerParameters: MiniAudioPlayerParameters = {
 *   breakOutRoomStarted: true,
 *   breakOutRoomEnded: false,
 *   limitedBreakRoom: participantList,
 *   reUpdateInter: reUpdateInterFunc,
 *   updateParticipantAudioDecibels: updateAudioDecibelsFunc,
 *   getUpdatedAllParams: () => getParams(),
 * };
 *
 * // Initialize component with required inputs
 * <app-mini-audio-player
 *   [stream]="audioStream"
 *   [consumer]="audioConsumer"
 *   [remoteProducerId]="participantId"
 *   [parameters]="audioPlayerParameters"
 * ></app-mini-audio-player>
 * ```
 */
class MiniAudioPlayer {
    injector;
    stream = null;
    consumer = null;
    remoteProducerId = '';
    parameters = {};
    MiniAudioComponent;
    miniAudioProps = {};
    audioElement;
    showWaveModal = false;
    isMuted = false;
    intervalId;
    autoWaveCheck = false;
    previousShowWaveModal = null;
    previousIsMuted = null;
    injectorCache = new WeakMap();
    cachedMiniAudioProps;
    constructor(injector, injectedStream, consumer, injectedRemoteProducerId, injectedParameters, injectedMiniAudioComponent, injectedMiniAudioProps) {
        this.injector = injector;
        this.stream = injectedStream || this.stream;
        this.consumer = consumer || this.consumer;
        this.remoteProducerId = injectedRemoteProducerId || this.remoteProducerId;
        this.parameters = injectedParameters || this.parameters;
        this.MiniAudioComponent = injectedMiniAudioComponent || this.MiniAudioComponent;
        this.miniAudioProps = injectedMiniAudioProps || this.miniAudioProps;
    }
    ngOnInit() {
        if (this.stream) {
            this.setupAudioProcessing();
        }
    }
    ngOnDestroy() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    setupAudioProcessing() {
        let averageLoudness = 128;
        let consLow = false;
        this.intervalId = setInterval(() => {
            try {
                const receiver = this.consumer?.rtpReceiver;
                receiver?.getStats().then((stats) => {
                    stats.forEach((report) => {
                        if (report.type === 'inbound-rtp' &&
                            report.kind === 'audio' &&
                            report.audioLevel) {
                            averageLoudness = 127.5 + report.audioLevel * 127.5;
                        }
                    });
                });
            }
            catch {
                // Do nothing
            }
            const updatedParams = this.parameters.getUpdatedAllParams();
            let { eventType, participants, paginatedStreams, currentUserPage, adminNameStream, dispActiveNames, activeSounds, reUpdateInter, updateParticipantAudioDecibels, updateActiveSounds, shared, shareScreenStarted, breakOutRoomStarted, breakOutRoomEnded, limitedBreakRoom, } = updatedParams;
            const participant = participants.find((obj) => obj.audioID == this.remoteProducerId);
            let audioActiveInRoom = true;
            if (participant) {
                if (breakOutRoomStarted && !breakOutRoomEnded) {
                    if (!limitedBreakRoom.map((obj) => obj.name).includes(participant.name)) {
                        audioActiveInRoom = false;
                        averageLoudness = 127;
                    }
                }
            }
            if (this.parameters.meetingDisplayType != 'video') {
                this.autoWaveCheck = true;
            }
            if (shared || shareScreenStarted) {
                this.autoWaveCheck = false;
            }
            if (participant) {
                this.isMuted = participant.muted || false;
                if (eventType != 'chat' && eventType != 'broadcast') {
                    updateParticipantAudioDecibels({
                        name: participant.name ?? '',
                        averageLoudness: averageLoudness,
                        audioDecibels: updatedParams.audioDecibels,
                        updateAudioDecibels: updatedParams['updateAudioDecibels'],
                    });
                }
                const inPage = paginatedStreams[currentUserPage].findIndex((obj) => obj.name == participant.name);
                if (participant.name && !dispActiveNames.includes(participant.name) && inPage == -1) {
                    this.autoWaveCheck = false;
                    if (!adminNameStream) {
                        const adminParticipant = participants.find((obj) => obj.islevel == '2');
                        adminNameStream = adminParticipant ? adminParticipant.name : '';
                    }
                    if (participant.name == adminNameStream) {
                        this.autoWaveCheck = true;
                    }
                }
                else {
                    this.autoWaveCheck = true;
                }
                if (participant.videoID ||
                    this.autoWaveCheck ||
                    (breakOutRoomStarted && !breakOutRoomEnded && audioActiveInRoom)) {
                    this.showWaveModal = false;
                    if (averageLoudness > 127.5) {
                        if (!activeSounds.includes(participant.name)) {
                            activeSounds.push(participant.name);
                            consLow = false;
                            if ((shareScreenStarted || shared) && !participant.videoID) {
                                // do nothing
                            }
                            else {
                                if (eventType != 'chat' && eventType != 'broadcast' && participant.name) {
                                    reUpdateInter({
                                        name: participant.name,
                                        add: true,
                                        average: averageLoudness,
                                        parameters: updatedParams,
                                    });
                                }
                            }
                        }
                    }
                    else {
                        if (activeSounds.includes(participant.name) && consLow) {
                            activeSounds.splice(activeSounds.indexOf(participant.name), 1);
                            if ((shareScreenStarted || shared) && !participant.videoID) {
                                // do nothing
                            }
                            else {
                                if (eventType != 'chat' && eventType != 'broadcast' && participant.name) {
                                    reUpdateInter({
                                        name: participant.name,
                                        average: averageLoudness,
                                        parameters: updatedParams,
                                    });
                                }
                            }
                        }
                        else {
                            consLow = true;
                        }
                    }
                }
                else {
                    if (averageLoudness > 127.5) {
                        if (!this.parameters['autoWave']) {
                            this.showWaveModal = false;
                        }
                        else {
                            this.showWaveModal = true;
                        }
                        if (!activeSounds.includes(participant.name)) {
                            activeSounds.push(participant.name);
                        }
                        if ((shareScreenStarted || shared) && !participant.videoID) {
                            // do nothing
                        }
                        else {
                            if (eventType != 'chat' && eventType != 'broadcast' && participant.name) {
                                reUpdateInter({
                                    name: participant.name,
                                    add: true,
                                    average: averageLoudness,
                                    parameters: updatedParams,
                                });
                            }
                        }
                    }
                    else {
                        this.showWaveModal = false;
                        if (activeSounds.includes(participant.name)) {
                            activeSounds.splice(activeSounds.indexOf(participant.name), 1);
                        }
                        if ((shareScreenStarted || shared) && !participant.videoID) {
                            // do nothing
                        }
                        else {
                            if (eventType != 'chat' && eventType != 'broadcast' && participant.name) {
                                reUpdateInter({
                                    name: participant.name,
                                    average: averageLoudness,
                                    parameters: updatedParams,
                                });
                            }
                        }
                    }
                }
                updateActiveSounds(activeSounds);
            }
            else {
                this.showWaveModal = false;
                this.isMuted = true;
            }
        }, 2000);
    }
    createInjector(inputs) {
        if (!this.injectorCache.has(inputs)) {
            const injector = Injector.create({
                providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
                parent: this.injector,
            });
            this.injectorCache.set(inputs, injector);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.injectorCache.get(inputs);
    }
    getMiniAudioProps() {
        if (!this.cachedMiniAudioProps ||
            this.showWaveModal !== this.previousShowWaveModal ||
            this.isMuted !== this.previousIsMuted) {
            this.cachedMiniAudioProps = {
                ...this.miniAudioProps,
                visible: this.showWaveModal && !this.isMuted,
                showWaveform: this.showWaveModal,
            };
            this.previousShowWaveModal = this.showWaveModal;
            this.previousIsMuted = this.isMuted;
        }
        return this.cachedMiniAudioProps;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MiniAudioPlayer, deps: [{ token: i0.Injector }, { token: 'stream', optional: true }, { token: 'consumer', optional: true }, { token: 'remoteProducerId', optional: true }, { token: 'parameters', optional: true }, { token: 'MiniAudioComponent', optional: true }, { token: 'miniAudioProps', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MiniAudioPlayer, isStandalone: true, selector: "app-mini-audio-player", inputs: { stream: "stream", consumer: "consumer", remoteProducerId: "remoteProducerId", parameters: "parameters", MiniAudioComponent: "MiniAudioComponent", miniAudioProps: "miniAudioProps" }, viewQueries: [{ propertyName: "audioElement", first: true, predicate: ["audioElement"], descendants: true, static: true }], ngImport: i0, template: "<div class=\"container\">\r\n  <audio *ngIf=\"stream\" autoplay playsinline #audioElement [srcObject]=\"stream\"></audio>\r\n\r\n  <ng-container *ngIf=\"MiniAudioComponent\">\r\n    <ng-container *ngComponentOutlet=\"MiniAudioComponent; injector: createInjector(getMiniAudioProps())\"></ng-container>\r\n  </ng-container>\r\n</div>\r\n", styles: [".container{display:flex;justify-content:center;align-items:center;z-index:9}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MiniAudioPlayer, decorators: [{
            type: Component,
            args: [{ selector: 'app-mini-audio-player', imports: [CommonModule], template: "<div class=\"container\">\r\n  <audio *ngIf=\"stream\" autoplay playsinline #audioElement [srcObject]=\"stream\"></audio>\r\n\r\n  <ng-container *ngIf=\"MiniAudioComponent\">\r\n    <ng-container *ngComponentOutlet=\"MiniAudioComponent; injector: createInjector(getMiniAudioProps())\"></ng-container>\r\n  </ng-container>\r\n</div>\r\n", styles: [".container{display:flex;justify-content:center;align-items:center;z-index:9}\n"] }]
        }], ctorParameters: () => [{ type: i0.Injector }, { type: MediaStream, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['stream']
                }] }, { type: i2$1.Consumer, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['consumer']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['remoteProducerId']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['MiniAudioComponent']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['miniAudioProps']
                }] }], propDecorators: { stream: [{
                type: Input
            }], consumer: [{
                type: Input
            }], remoteProducerId: [{
                type: Input
            }], parameters: [{
                type: Input
            }], MiniAudioComponent: [{
                type: Input
            }], miniAudioProps: [{
                type: Input
            }], audioElement: [{
                type: ViewChild,
                args: ['audioElement', { static: true }]
            }] } });

/**
 * Resumes a consumer, making it ready for use.
 *
 * @param {ConsumerResumeOptions} options - The options for resuming the consumer.
 * @param {MediaStreamTrack} options.track - The media stream track associated with the resumed consumer.
 * @param {string} options.kind - The type of media ('audio' or 'video') being resumed.
 * @param {string} options.remoteProducerId - The ID of the remote producer associated with the resumed consumer.
 * @param {ResumeParams} options.params - Additional parameters related to the resumed consumer.
 * @param {ConsumerResumeParameters} options.parameters - The parameters object containing various utility functions and state.
 * @param {Socket} options.nsock - The socket associated with the consumer.
 * @param {Consumer} options.consumer - The consumer to resume.
 * @throws Will throw an error if an issue occurs during the consumer resumption.
 *
 * @example
 * ```typescript
 * const options = {
 *   track: mediaStreamTrack, // MediaStreamTrack to be resumed
 *   remoteProducerId: 'producer-id', // Remote producer ID
 *   params: {
 *     id: 'consumer-id',
 *     producerId: 'producer-id',
 *     kind: 'audio',
 *     rtpParameters: {},
 *   },
 *   parameters: consumerResumeParameters, // Parameters for the consumer
 *   nsock: socket, // Socket for communication
 *   consumer: consumer, // Consumer to resume
 * };
 *
 * consumerResume(options)
 *   .then(() => {
 *     console.log('Consumer resumed successfully');
 *   })
 *   .catch((error) => {
 *     console.error('Error resuming consumer:', error);
 *   });
 * ```
 */
class ConsumerResume {
    /**
     * Resumes a consumer, making it ready for use.
     *
     * @param {Object} options - The options object.
     * @param {MediaStreamTrack} options.track - The media stream track associated with the resumed consumer.
     * @param {string} options.kind - The type of media ('audio' or 'video') being resumed.
     * @param {string} options.remoteProducerId - The ID of the remote producer associated with the resumed consumer.
     * @param {Object} options.params - Additional parameters related to the resumed consumer.
     * @param {Object} options.parameters - The parameters object containing various utility functions and state.
     * @param {Object} options.nsock - The socket associated with the consumer.
     * @param {Object} options.consumer - The consumer to resume.
     * @throws Throws an error if an issue occurs during the consumer resumption.
     */
    consumerResume = async ({ track, remoteProducerId, params, parameters, nsock, consumer, }) => {
        try {
            // Get updated parameters
            parameters = parameters.getUpdatedAllParams();
            // Destructure parameters
            let { nStream, allAudioStreams, allVideoStreams, streamNames, audStreamNames, updateMainWindow, shared, shareScreenStarted, screenId, participants, eventType, meetingDisplayType, mainScreenFilled, first_round, lock_screen, oldAllStreams, adminVidID, mainHeightWidth, member, audioOnlyStreams, gotAllVids, defer_receive, firstAll, remoteScreenStream, hostLabel, whiteboardStarted, whiteboardEnded, updateUpdateMainWindow, updateAllAudioStreams, updateAllVideoStreams, updateStreamNames, updateAudStreamNames, updateNStream, updateMainHeightWidth, updateLock_screen, updateFirstAll, updateRemoteScreenStream, updateOldAllStreams, updateAudioOnlyStreams, updateShareScreenStarted, updateGotAllVids, updateScreenId, updateDefer_receive, 
            //mediasfu functions
            reorderStreams, prepopulateUserMedia, } = parameters;
            if (params.kind === 'audio') {
                // Audio resumed
                // Check if the participant with audioID == remoteProducerId has a valid videoID
                let participant = participants.filter((p) => p.audioID === remoteProducerId);
                let name__ = participant.length > 0 ? participant[0].name || '' : '';
                if (name__ === member)
                    return;
                //find any participants with ScreenID not null and ScreenOn == true
                let screenParticipant_alt = participants.filter((participant) => participant.ScreenID != null &&
                    participant.ScreenOn == true &&
                    participant.ScreenID != '');
                if (screenParticipant_alt.length > 0) {
                    screenId = screenParticipant_alt[0].ScreenID;
                    if (screenId) {
                        updateScreenId(screenId);
                    }
                    if (!shared) {
                        shareScreenStarted = true;
                        updateShareScreenStarted(shareScreenStarted);
                    }
                }
                else {
                    if (whiteboardStarted && !whiteboardEnded) {
                        // whiteboard is active
                    }
                    else {
                        screenId = '';
                        updateScreenId(screenId);
                        updateShareScreenStarted(false);
                    }
                }
                // Media display and UI update to prioritize audio/video
                nStream = new MediaStream([track]);
                updateNStream(nStream);
                // Create MiniAudioPlayer track
                let nTrack = {
                    component: MiniAudioPlayer,
                    inputs: {
                        stream: nStream ? nStream : null,
                        consumer: consumer,
                        remoteProducerId: remoteProducerId,
                        parameters: parameters,
                        MiniAudioComponent: MiniAudio,
                        miniAudioProps: {
                            customStyle: { backgroundColor: 'gray' },
                            name: name__,
                            showWaveform: true,
                            overlayPosition: 'topRight',
                            barColor: 'white',
                            textColor: 'white',
                            imageSource: 'https://mediasfu.com/images/logo192.png',
                            roundedImage: true,
                            imageStyle: {},
                        },
                    },
                };
                // Add to audioOnlyStreams array
                audioOnlyStreams.push(nTrack);
                updateAudioOnlyStreams(audioOnlyStreams);
                // Add to allAudioStreams array; add producerId, stream
                allAudioStreams = [...allAudioStreams, { producerId: remoteProducerId, stream: nStream }];
                updateAllAudioStreams(allAudioStreams);
                let name;
                try {
                    name = participant[0].name;
                }
                catch {
                    /* handle error */
                }
                if (name) {
                    // Add to audStreamNames array; add producerId, name
                    audStreamNames = [...audStreamNames, { producerId: remoteProducerId, name: name__ }];
                    updateAudStreamNames(audStreamNames);
                    if (!mainScreenFilled && participant[0].islevel === '2') {
                        updateMainWindow = true;
                        updateUpdateMainWindow(updateMainWindow);
                        await prepopulateUserMedia({
                            name: hostLabel,
                            parameters: { ...parameters, audStreamNames, allAudioStreams },
                        });
                        updateMainWindow = false;
                        updateUpdateMainWindow(updateMainWindow);
                    }
                }
                else {
                    return;
                }
                // Checks for display type and updates the UI
                let checker;
                let alt_checker = false;
                if (meetingDisplayType == 'video') {
                    checker =
                        participant[0].videoID != null &&
                            participant[0].videoID != '' &&
                            participant[0].videoID != undefined;
                }
                else {
                    checker = true;
                    alt_checker = true;
                }
                if (checker) {
                    if (shareScreenStarted || shared) {
                        if (!alt_checker) {
                            await reorderStreams({
                                parameters: { ...parameters, audStreamNames, allAudioStreams },
                            });
                        }
                    }
                    else {
                        if (alt_checker && meetingDisplayType != 'video') {
                            await reorderStreams({
                                add: false,
                                screenChanged: true,
                                parameters: { ...parameters, audStreamNames, allAudioStreams },
                            });
                        }
                    }
                }
            }
            else {
                // Video resumed
                nStream = new MediaStream([track]);
                updateNStream(nStream);
                //find any participants with ScreenID not null and ScreenOn == true
                let screenParticipant_alt = participants.filter((participant) => participant.ScreenID != null &&
                    participant.ScreenOn == true &&
                    participant.ScreenID != '');
                if (screenParticipant_alt.length > 0) {
                    screenId = screenParticipant_alt[0].ScreenID;
                    if (screenId) {
                        updateScreenId(screenId);
                    }
                    if (!shared) {
                        shareScreenStarted = true;
                        updateShareScreenStarted(shareScreenStarted);
                    }
                }
                else {
                    if (whiteboardStarted && !whiteboardEnded) {
                        // whiteboard is active
                    }
                    else {
                        screenId = '';
                        updateScreenId(screenId);
                        updateShareScreenStarted(false);
                    }
                }
                // Check for display type and update the UI
                if (remoteProducerId == screenId) {
                    // Put on main screen for screen share
                    updateMainWindow = true;
                    updateUpdateMainWindow(updateMainWindow);
                    remoteScreenStream = [{ producerId: remoteProducerId, stream: nStream }];
                    updateRemoteScreenStream(remoteScreenStream);
                    if (eventType == 'conference') {
                        if (shared || shareScreenStarted) {
                            if (mainHeightWidth == 0) {
                                updateMainHeightWidth(84);
                            }
                        }
                        else {
                            if (mainHeightWidth > 0) {
                                updateMainHeightWidth(0);
                            }
                        }
                    }
                    if (!lock_screen) {
                        await prepopulateUserMedia({ name: hostLabel, parameters });
                        await reorderStreams({
                            add: false,
                            screenChanged: true,
                            parameters: { ...parameters, remoteScreenStream, allVideoStreams },
                        });
                    }
                    else {
                        if (!first_round) {
                            await prepopulateUserMedia({
                                name: hostLabel,
                                parameters: {
                                    ...parameters,
                                    remoteScreenStream,
                                    allVideoStreams,
                                },
                            });
                            await reorderStreams({
                                add: false,
                                screenChanged: true,
                                parameters: {
                                    ...parameters,
                                    remoteScreenStream,
                                    allVideoStreams,
                                },
                            });
                        }
                    }
                    lock_screen = true;
                    updateLock_screen(lock_screen);
                    firstAll = true;
                    updateFirstAll(firstAll);
                }
                else {
                    // Non-screen share video resumed
                    // Operations to add video to the UI (either main screen or mini screen)
                    parameters = parameters.getUpdatedAllParams();
                    // Get the name of the participant with videoID == remoteProducerId
                    let participant = participants.filter((participant) => participant.videoID == remoteProducerId);
                    if (participant.length > 0 &&
                        participant[0].name != null &&
                        participant[0].name != '' &&
                        participant[0].name != undefined &&
                        participant[0].name !== member) {
                        allVideoStreams = [
                            ...allVideoStreams,
                            { producerId: remoteProducerId, stream: nStream, socket_: nsock },
                        ];
                        updateAllVideoStreams(allVideoStreams);
                    }
                    if (participant.length > 0) {
                        let name = participant[0].name;
                        streamNames = [...streamNames, { producerId: remoteProducerId, name: name || '' }];
                        updateStreamNames(streamNames);
                    }
                    // If not screenshare, filter out the stream that belongs to the participant with isAdmin = true and islevel == '2' (host)
                    // Find the ID of the participant with isAdmin = true and islevel == '2'
                    if (!shareScreenStarted) {
                        let admin = participants.filter((participant) => (participant.isAdmin == true || participant.isHost == true) && participant.islevel == '2');
                        // Remove video stream with producerId == admin.id
                        // Get the videoID of the admin
                        if (admin.length > 0) {
                            adminVidID = admin[0].videoID;
                            if (adminVidID != null && adminVidID != '') {
                                let oldAllStreams_ = [];
                                // Check if the length of allVideoStreams is > 0
                                if (oldAllStreams.length > 0) {
                                    oldAllStreams_ = oldAllStreams;
                                }
                                oldAllStreams = allVideoStreams.filter((streame) => streame.producerId == adminVidID);
                                updateOldAllStreams(oldAllStreams);
                                if (oldAllStreams.length < 1) {
                                    oldAllStreams = oldAllStreams_;
                                    updateOldAllStreams(oldAllStreams);
                                }
                                allVideoStreams = allVideoStreams.filter((streame) => streame.producerId != adminVidID);
                                updateAllVideoStreams(allVideoStreams);
                                if (remoteProducerId == adminVidID) {
                                    updateMainWindow = true;
                                }
                            }
                            gotAllVids = true;
                            updateGotAllVids(gotAllVids);
                        }
                    }
                    else {
                        // Check if the videoID is either that of the admin or that of the screen participant
                        let screenParticipant = participants.filter((participant) => participant.ScreenID == screenId);
                        // See if producerId is that of admin videoID or screenParticipant videoID
                        let adminVidID;
                        let screenParticipantVidID;
                        if (screenParticipant.length > 0) {
                            screenParticipantVidID = screenParticipant[0].videoID;
                        }
                        if ((adminVidID != null && adminVidID != '') ||
                            (screenParticipantVidID != null && screenParticipantVidID != '')) {
                            if (adminVidID == remoteProducerId || screenParticipantVidID == remoteProducerId) {
                                await reorderStreams({
                                    parameters: { ...parameters, allVideoStreams },
                                });
                                return;
                            }
                        }
                    }
                    // Update the UI
                    if (lock_screen || shared) {
                        defer_receive = true;
                        updateDefer_receive(defer_receive);
                        if (!first_round) {
                            await reorderStreams({
                                add: false,
                                screenChanged: true,
                                parameters: { ...parameters, allVideoStreams },
                            });
                        }
                    }
                    else {
                        await reorderStreams({
                            add: false,
                            screenChanged: true,
                            parameters: { ...parameters, allVideoStreams },
                        });
                    }
                }
            }
        }
        catch (error) {
            console.log('consumerResume error', error);
            // throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConsumerResume, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConsumerResume, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConsumerResume, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Creates a WebRTC send transport and sets up event handlers for the transport.
 * Supports both primary and local transports with modular handling.
 * @param {CreateSendTransportOptions} options - The options for creating the send transport.
 * @param {string} options.option - The type of transport to create.
 * @param {CreateSendTransportParameters} options.parameters - The parameters required for creating the transport.
 * @param {string} options.parameters.islevel - The level of the transport.
 * @param {string} options.parameters.member - The member name for the transport.
 * @param {Socket} options.parameters.socket - The primary socket instance.
 * @param {Device} options.parameters.device - The device instance.
 * @param {Transport | null} options.parameters.producerTransport - The primary producer transport object.
 * @param {boolean} options.parameters.transportCreated - The state of the primary transport creation.
 * @param {(transport: Transport | null) => void} options.parameters.updateProducerTransport - The function to update the primary transport object.
 * @param {(state: boolean) => void} options.parameters.updateTransportCreated - The function to update the primary transport creation state.
 * @param {Function} options.parameters.connectSendTransport - The function to connect the send transport.
 * @param {Function} options.parameters.getUpdatedAllParams - The function to get updated parameters.
 * @param {Socket} [options.parameters.localSocket] - The local socket instance.
 * @param {Transport | null} [options.parameters.localProducerTransport] - The local producer transport object.
 * @param {boolean} [options.parameters.localTransportCreated] - The state of the local transport creation.
 * @param {(localTransport: Transport | null) => void} [options.parameters.updateLocalProducerTransport] - The function to update the local transport object.
 * @param {(state: boolean) => void} [options.parameters.updateLocalTransportCreated] - The function to update the local transport creation state.
 * @returns {Promise<void>} A promise that resolves when the send transport is created and configured.
 * @throws Will throw an error if there is an issue creating the send transport.
 * @example
 * const options = {
 *  option: 'video',
 * parameters: {
 * islevel: '1',
 * member: 'John Doe',
 * socket: socketInstance,
 * localSocket: localSocketInstance,
 * device: deviceInstance,
 * producerTransport: null,
 * localProducerTransport: null,
 * transportCreated: false,
 * localTransportCreated: false,
 * updateProducerTransport: (transport) => console.log('Primary transport updated:', transport),
 * updateLocalProducerTransport: (transport) => console.log('Local transport updated:', transport),
 * updateTransportCreated: (state) => console.log('Primary transport created:', state),
 * updateLocalTransportCreated: (state) => console.log('Local transport created:', state),
 * },
 * };
 * createSendTransport(options)
 * .then(() => console.log('Send transport created successfully'))
 * .catch((error) => console.error('Error creating send transport:', error));
 *
 */
const createLocalSendTransport = async ({ option, parameters, }) => {
    try {
        let { islevel, member, socket, localSocket, device, localProducerTransport, localTransportCreated, updateLocalProducerTransport, updateLocalTransportCreated, connectSendTransport, } = parameters;
        if (!localSocket || !localSocket.id || socket?.id == localSocket?.id) {
            return;
        }
        localSocket.emit("createWebRtcTransport", { consumer: false, islevel }, async ({ params }) => {
            if (params && params.error) {
                console.error("Error in local createWebRtcTransport:", params.error);
                return;
            }
            // Create local send transport
            localProducerTransport = await device.createSendTransport(params);
            if (updateLocalProducerTransport) {
                updateLocalProducerTransport(localProducerTransport);
            }
            // Handle local transport events
            localProducerTransport.on("connect", async ({ dtlsParameters }, callback, errback) => {
                try {
                    localSocket.emit("transport-connect", { dtlsParameters });
                    callback();
                }
                catch (error) {
                    errback(error);
                }
            });
            localProducerTransport.on("produce", async (parameters, callback, errback) => {
                try {
                    localSocket.emit("transport-produce", {
                        kind: parameters.kind,
                        rtpParameters: parameters.rtpParameters,
                        appData: parameters.appData,
                        islevel,
                        name: member,
                    }, ({ id }) => callback({ id }));
                }
                catch (error) {
                    errback(error);
                }
            });
            localProducerTransport.on("connectionstatechange", (state) => {
                if (state === "failed") {
                    console.error("Local transport connection failed.");
                    if (localProducerTransport) {
                        localProducerTransport.close();
                    }
                }
            });
            // Mark local transport as created
            localTransportCreated = true;
            updateLocalTransportCreated?.(localTransportCreated);
            // connect local transport
            await connectSendTransport({
                targetOption: "local",
                option,
                parameters: { ...parameters, localProducerTransport: localProducerTransport },
            });
        });
    }
    catch (error) {
        console.error("Error creating local send transport:", error);
    }
};
/**
 * Creates a WebRTC send transport and sets up event handlers for the transport.
 *
 * Supports both primary and local transports with modular handling.
 *
 * @param {CreateSendTransportOptions} options - The options for creating the send transport.
 * @param {string} options.option - The type of transport to create.
 * @param {CreateSendTransportParameters} options.parameters - The parameters required for creating the transport.
 * @param {string} options.parameters.islevel - The level of the transport.
 * @param {string} options.parameters.member - The member name for the transport.
 * @param {Socket} options.parameters.socket - The primary socket instance.
 * @param {Device} options.parameters.device - The device instance.
 * @param {Transport | null} options.parameters.producerTransport - The primary producer transport object.
 * @param {boolean} options.parameters.transportCreated - The state of the primary transport creation.
 * @param {(transport: Transport | null) => void} options.parameters.updateProducerTransport - The function to update the primary transport object.
 * @param {(state: boolean) => void} options.parameters.updateTransportCreated - The function to update the primary transport creation state.
 * @param {Function} options.parameters.connectSendTransport - The function to connect the send transport.
 * @param {Function} options.parameters.getUpdatedAllParams - The function to get updated parameters.
 * @param {Socket} [options.parameters.localSocket] - The local socket instance.
 * @param {Transport | null} [options.parameters.localProducerTransport] - The local producer transport object.
 * @param {boolean} [options.parameters.localTransportCreated] - The state of the local transport creation.
 * @param {(localTransport: Transport | null) => void} [options.parameters.updateLocalProducerTransport] - The function to update the local transport object.
 * @param {(state: boolean) => void} [options.parameters.updateLocalTransportCreated] - The function to update the local transport creation state.
 * @returns {Promise<void>} A promise that resolves when the send transport is created and configured.
 *
 * @throws Will throw an error if there is an issue creating the send transport.
 *
 * @example
 * const options = {
 *   option: 'video',
 *   parameters: {
 *     islevel: '1',
 *     member: 'John Doe',
 *     socket: socketInstance,
 *     localSocket: localSocketInstance,
 *     device: deviceInstance,
 *     producerTransport: null,
 *     localProducerTransport: null,
 *     transportCreated: false,
 *     localTransportCreated: false,
 *     updateProducerTransport: (transport) => console.log('Primary transport updated:', transport),
 *     updateLocalProducerTransport: (transport) => console.log('Local transport updated:', transport),
 *     updateTransportCreated: (state) => console.log('Primary transport created:', state),
 *     updateLocalTransportCreated: (state) => console.log('Local transport created:', state),
 *   },
 * };
 *
 * createSendTransport(options)
 *   .then(() => console.log('Send transport created successfully'))
 *   .catch((error) => console.error('Error creating send transport:', error));
 */
class CreateSendTransport {
    /**
     * Creates a WebRTC send transport and sets up event handlers for the transport.
     *
     * Supports both primary and local transports with modular handling.
     *
     * @param {CreateSendTransportOptions} options - The options for creating the send transport.
     * @param {string} options.option - The type of transport to create.
     * @param {CreateSendTransportParameters} options.parameters - The parameters required for creating the transport.
     * @param {string} options.parameters.islevel - The level of the transport.
     * @param {string} options.parameters.member - The member name for the transport.
     * @param {Socket} options.parameters.socket - The primary socket instance.
     * @param {Device} options.parameters.device - The device instance.
     * @param {Transport | null} options.parameters.producerTransport - The primary producer transport object.
     * @param {boolean} options.parameters.transportCreated - The state of the primary transport creation.
     * @param {(transport: Transport | null) => void} options.parameters.updateProducerTransport - The function to update the primary transport object.
     * @param {(state: boolean) => void} options.parameters.updateTransportCreated - The function to update the primary transport creation state.
     * @param {Function} options.parameters.connectSendTransport - The function to connect the send transport.
     * @param {Function} options.parameters.getUpdatedAllParams - The function to get updated parameters.
     * @param {Socket} [options.parameters.localSocket] - The local socket instance.
     * @param {Transport | null} [options.parameters.localProducerTransport] - The local producer transport object.
     * @param {boolean} [options.parameters.localTransportCreated] - The state of the local transport creation.
     * @param {(localTransport: Transport | null) => void} [options.parameters.updateLocalProducerTransport] - The function to update the local transport object.
     * @param {(state: boolean) => void} [options.parameters.updateLocalTransportCreated] - The function to update the local transport creation state.
     * @returns {Promise<void>} A promise that resolves when the send transport is created and configured.
     *
     * @throws Will throw an error if there is an issue creating the send transport.
     *
     * @example
     * const options = {
     *   option: 'video',
     *   parameters: {
     *     islevel: '1',
     *     member: 'John Doe',
     *     socket: socketInstance,
     *     localSocket: localSocketInstance,
     *     device: deviceInstance,
     *     producerTransport: null,
     *     localProducerTransport: null,
     *     transportCreated: false,
     *     localTransportCreated: false,
     *     updateProducerTransport: (transport) => console.log('Primary transport updated:', transport),
     *     updateLocalProducerTransport: (transport) => console.log('Local transport updated:', transport),
     *     updateTransportCreated: (state) => console.log('Primary transport created:', state),
     *     updateLocalTransportCreated: (state) => console.log('Local transport created:', state),
     *   },
     * };
     *
     * createSendTransport(options)
     *   .then(() => console.log('Send transport created successfully'))
     *   .catch((error) => console.error('Error creating send transport:', error));
     */
    async createSendTransport({ option, parameters }) {
        try {
            // Destructure parameters
            let { islevel, member, device, socket, transportCreated, producerTransport, updateProducerTransport, updateTransportCreated, connectSendTransport, getUpdatedAllParams, } = parameters;
            const updatedParams = getUpdatedAllParams();
            device = updatedParams.device;
            socket = updatedParams.socket;
            try {
                // Handle local transport creation first
                if (!createLocalSendTransport) {
                    throw new Error("Local transport creation method not found.");
                }
                await createLocalSendTransport({ option, parameters });
            }
            catch (error) {
                console.log("Error creating local send transport:", error);
            }
            // Emit createWebRtcTransport event to the server
            socket.emit('createWebRtcTransport', { consumer: false, islevel: islevel }, async ({ params }) => {
                // Check if there is an error in the response
                if (params && params.error) {
                    return;
                }
                // Create a WebRTC send transport
                if (device) {
                    producerTransport = device.createSendTransport(params);
                }
                else {
                    throw new Error('Device is null');
                }
                updateProducerTransport(producerTransport);
                // Handle 'connect' event
                producerTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
                    try {
                        socket.emit('transport-connect', {
                            dtlsParameters,
                        });
                        callback();
                    }
                    catch (error) {
                        errback(error);
                    }
                });
                // Handle 'produce' event
                producerTransport.on('produce', async (parameters, callback, errback) => {
                    try {
                        socket.emit('transport-produce', {
                            kind: parameters.kind,
                            rtpParameters: parameters.rtpParameters,
                            appData: parameters.appData,
                            islevel: islevel,
                            name: member,
                        }, ({ id }) => {
                            callback({ id });
                        });
                    }
                    catch (error) {
                        errback(error);
                    }
                });
                // Handle 'connectionstatechange' event
                producerTransport.on('connectionstatechange', (state) => {
                    switch (state) {
                        case 'connecting':
                            break;
                        case 'connected':
                            break;
                        case 'failed':
                            producerTransport?.close();
                            break;
                        default:
                            break;
                    }
                });
                // Update transport creation state
                transportCreated = true;
                await connectSendTransport({
                    targetOption: 'remote',
                    option: option,
                    parameters: {
                        ...parameters,
                        producerTransport: producerTransport,
                    },
                });
                updateTransportCreated(transportCreated);
            });
        }
        catch (error) {
            // Handle errors during transport creation
            console.log('Error creating send transport:', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CreateSendTransport, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CreateSendTransport, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CreateSendTransport, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

const disconnectLocalSendTransportAudio = async ({ parameters, }) => {
    try {
        const { localAudioProducer, localSocket, roomName, updateLocalAudioProducer, } = parameters;
        if (localSocket && localSocket.id) {
            // Close the local audio producer and notify the server
            if (localAudioProducer) {
                localAudioProducer.close(); // Actual logic: pause instead of close for MediaSFU preference
                updateLocalAudioProducer?.(null);
            }
            localSocket.emit("pauseProducerMedia", { mediaTag: "audio", roomName: roomName });
        }
        else {
            return;
        }
    }
    catch (error) {
        console.log("Error disconnecting local audio send transport:", error);
        throw error; // Re-throw to propagate the error
    }
};
/**
 * Disconnects the send transport for audio by pausing the audio producer and updating the UI accordingly.
 *
 * This function supports both a primary and a local audio producer, delegating local handling to a separate function.
 *
 * @param {DisconnectSendTransportAudioOptions} options - The options for disconnecting the send transport for audio.
 * @param {DisconnectSendTransportAudioParameters} options.parameters - The parameters for disconnecting the send transport for audio.
 * @param {Producer} options.parameters.audioProducer - The primary audio producer to disconnect.
 * @param {Producer} [options.parameters.localAudioProducer] - The local audio producer to disconnect.
 * @param {Socket} options.parameters.socket - The socket instance to use for communication.
 * @param {Socket} [options.parameters.localSocket] - The local socket instance to use for communication.
 * @param {boolean} options.parameters.videoAlreadyOn - Flag indicating if video is already on.
 * @param {string} options.parameters.islevel - The level of the user.
 * @param {boolean} options.parameters.lock_screen - Flag indicating if the screen is locked.
 * @param {boolean} options.parameters.shared - Flag indicating if the screen is shared.
 * @param {boolean} options.parameters.updateMainWindow - Flag to update the main window.
 * @param {string} options.parameters.hostLabel - The label for the host user.
 * @param {string} options.parameters.roomName - The name of the room.
 * @param {function} options.parameters.updateAudioProducer - Function to update the audio producer.
 * @param {function} [options.parameters.updateLocalAudioProducer] - Function to update the local audio producer (optional).
 * @param {function} options.parameters.updateUpdateMainWindow - Function to update the main window state.
 * @param {function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
 * @param {object} options.parameters - The parameters required for disconnecting the send transport for audio.
 * @returns {Promise<void>} A promise that resolves when the send transport for audio is disconnected.
 *
 * @throws Will throw an error if the operation fails.
 *
 * @example
 * const options = {
 *   parameters: {
 *     audioProducer: audioProducerInstance,
 *     localAudioProducer: localAudioProducerInstance,
 *     socket: socketInstance,
 *     localSocket: localSocketInstance,
 *     videoAlreadyOn: false,
 *     islevel: '1',
 *     lock_screen: false,
 *     shared: false,
 *     updateMainWindow: true,
 *     hostLabel: 'Host',
 *     roomName: 'Room 1',
 *     updateAudioProducer: (producer) => console.log('Updated audio producer:', producer),
 *     updateLocalAudioProducer: (producer) => console.log('Updated local audio producer:', producer),
 *     updateUpdateMainWindow: (state) => console.log('Main window state updated:', state),
 *     prepopulateUserMedia: async ({ name, parameters }) => console.log('Prepopulating user media for', name),
 *   },
 * };
 *
 * disconnectSendTransportAudio(options)
 *   .then(() => console.log("Audio send transport disconnected successfully"))
 *   .catch((error) => console.log("Error disconnecting audio send transport:", error));
 */
class DisconnectSendTransportAudio {
    /**
     * Disconnects the send transport for audio by pausing the audio producer and updating the UI accordingly.
     *
     * This function supports both a primary and a local audio producer, delegating local handling to a separate function.
     *
     * @param {DisconnectSendTransportAudioOptions} options - The options for disconnecting the send transport for audio.
     * @param {DisconnectSendTransportAudioParameters} options.parameters - The parameters for disconnecting the send transport for audio.
     * @param {Producer} options.parameters.audioProducer - The primary audio producer to disconnect.
     * @param {Producer} [options.parameters.localAudioProducer] - The local audio producer to disconnect.
     * @param {Socket} options.parameters.socket - The socket instance to use for communication.
     * @param {Socket} [options.parameters.localSocket] - The local socket instance to use for communication.
     * @param {boolean} options.parameters.videoAlreadyOn - Flag indicating if video is already on.
     * @param {string} options.parameters.islevel - The level of the user.
     * @param {boolean} options.parameters.lock_screen - Flag indicating if the screen is locked.
     * @param {boolean} options.parameters.shared - Flag indicating if the screen is shared.
     * @param {boolean} options.parameters.updateMainWindow - Flag to update the main window.
     * @param {string} options.parameters.hostLabel - The label for the host user.
     * @param {string} options.parameters.roomName - The name of the room.
     * @param {function} options.parameters.updateAudioProducer - Function to update the audio producer.
     * @param {function} [options.parameters.updateLocalAudioProducer] - Function to update the local audio producer (optional).
     * @param {function} options.parameters.updateUpdateMainWindow - Function to update the main window state.
     * @param {function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @param {object} options.parameters - The parameters required for disconnecting the send transport for audio.
     * @returns {Promise<void>} A promise that resolves when the send transport for audio is disconnected.
     *
     * @throws Will throw an error if the operation fails.
     *
     * @example
     * const options = {
     *   parameters: {
     *     audioProducer: audioProducerInstance,
     *     localAudioProducer: localAudioProducerInstance,
     *     socket: socketInstance,
     *     localSocket: localSocketInstance,
     *     videoAlreadyOn: false,
     *     islevel: '1',
     *     lock_screen: false,
     *     shared: false,
     *     updateMainWindow: true,
     *     hostLabel: 'Host',
     *     roomName: 'Room 1',
     *     updateAudioProducer: (producer) => console.log('Updated audio producer:', producer),
     *     updateLocalAudioProducer: (producer) => console.log('Updated local audio producer:', producer),
     *     updateUpdateMainWindow: (state) => console.log('Main window state updated:', state),
     *     prepopulateUserMedia: async ({ name, parameters }) => console.log('Prepopulating user media for', name),
     *   },
     * };
     *
     * disconnectSendTransportAudio(options)
     *   .then(() => console.log("Audio send transport disconnected successfully"))
     *   .catch((error) => console.log("Error disconnecting audio send transport:", error));
     */
    async disconnectSendTransportAudio({ parameters, }) {
        try {
            // Destructure parameters
            let { audioProducer, socket, videoAlreadyOn, islevel, lock_screen, shared, updateMainWindow, hostLabel, roomName, updateAudioProducer, updateUpdateMainWindow, prepopulateUserMedia, } = parameters;
            // Pause the audio producer
            audioProducer?.pause(); // actual logic is to close (await audioProducer.close()) but mediaSFU prefers pause if recording
            updateAudioProducer(audioProducer);
            // Update the UI
            if (!videoAlreadyOn && islevel === '2') {
                if (!lock_screen && !shared) {
                    updateMainWindow = true;
                    updateUpdateMainWindow(updateMainWindow);
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                    updateMainWindow = false;
                    updateUpdateMainWindow(updateMainWindow);
                }
            }
            // Notify the server about pausing audio producer
            socket.emit('pauseProducerMedia', { mediaTag: 'audio', roomName: roomName });
            // Handle local audio transport
            try {
                await disconnectLocalSendTransportAudio({ parameters });
            }
            catch (localError) {
                console.log("Error disconnecting local audio send transport:", localError);
            }
        }
        catch (error) {
            console.error('disconnectSendTransportAudio error', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectSendTransportAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectSendTransportAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectSendTransportAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

const disconnectLocalSendTransportVideo = async ({ parameters, }) => {
    try {
        const { localVideoProducer, localSocket, roomName, updateLocalVideoProducer, } = parameters;
        if (localSocket && localSocket.id) {
            // continue
        }
        else {
            return;
        }
        // Close the local video producer and notify the server
        if (localVideoProducer) {
            localVideoProducer.close();
            updateLocalVideoProducer?.(null);
        }
        localSocket.emit('pauseProducerMedia', { mediaTag: 'video', roomName: roomName });
    }
    catch (error) {
        console.error('Error disconnecting local video send transport:', error);
        throw error; // Re-throw to propagate the error
    }
};
/**
 * Disconnects the send transport for video, closes the video producer, and updates the state.
 *
 * This function supports both a primary and a local video producer, delegating local handling to a separate function.
 *
 * @param {DisconnectSendTransportVideoOptions} options - The options for disconnecting the send transport.
 * @param {DisconnectSendTransportVideoParameters} options.parameters - The parameters required for disconnecting the send transport.
 * @param {Producer | null} options.parameters.videoProducer - The primary video producer object.
 * @param {Producer | null} [options.parameters.localVideoProducer] - The local video producer object (optional).
 * @param {Socket} options.parameters.socket - The primary socket object.
 * @param {Socket} [options.parameters.localSocket] - The local socket object (optional).
 * @param {string} options.parameters.islevel - The participant's level.
 * @param {string} options.parameters.roomName - The name of the room.
 * @param {boolean} options.parameters.updateMainWindow - The flag to update the main window.
 * @param {boolean} options.parameters.lock_screen - The flag to lock the screen.
 * @param {Function} options.parameters.updateUpdateMainWindow - The function to update the main window state.
 * @param {Function} options.parameters.updateVideoProducer - The function to update the video producer state.
 * @param {Function} [options.parameters.updateLocalVideoProducer] - The function to update the local video producer state (optional).
 * @param {ReorderStreamsType} options.parameters.reorderStreams - The function to reorder streams.
 * @param {Function} [options.parameters.updateLocalProducerTransport] - The function to update the local producer transport state (optional).
 * @param {Function} [options.parameters.updateProducerTransport] - The function to update the producer transport state (optional).
 *
 * @returns {Promise<void>} A promise that resolves when the disconnection process is complete.
 *
 * @throws {Error} Throws an error if the disconnection process fails.
 *
 * @example
 * const options = {
 *   parameters: {
 *     videoProducer: videoProducerInstance,
 *     localVideoProducer: localVideoProducerInstance,
 *     socket: socketInstance,
 *     localSocket: localSocketInstance,
 *     islevel: '2',
 *     roomName: 'Room A',
 *     updateMainWindow: false,
 *     lock_screen: false,
 *     updateUpdateMainWindow: (state) => console.log('Main window updated:', state),
 *     updateVideoProducer: (producer) => console.log('Video producer updated:', producer),
 *     updateLocalVideoProducer: (producer) => console.log('Local video producer updated:', producer),
 *     reorderStreams: reorderStreamsFunction,
 *   },
 * };
 *
 * disconnectSendTransportVideo(options)
 *   .then(() => console.log('Video send transport disconnected successfully'))
 *   .catch((error) => console.error('Error disconnecting video send transport:', error));
 */
class DisconnectSendTransportVideo {
    /**
      * Disconnects the send transport for video, closes the video producer, and updates the state.
      *
      * This function supports both a primary and a local video producer, delegating local handling to a separate function.
      *
      * @param {DisconnectSendTransportVideoOptions} options - The options for disconnecting the send transport.
      * @param {DisconnectSendTransportVideoParameters} options.parameters - The parameters required for disconnecting the send transport.
      * @param {Producer | null} options.parameters.videoProducer - The primary video producer object.
      * @param {Producer | null} [options.parameters.localVideoProducer] - The local video producer object (optional).
      * @param {Socket} options.parameters.socket - The primary socket object.
      * @param {Socket} [options.parameters.localSocket] - The local socket object (optional).
      * @param {string} options.parameters.islevel - The participant's level.
      * @param {string} options.parameters.roomName - The name of the room.
      * @param {boolean} options.parameters.updateMainWindow - The flag to update the main window.
      * @param {boolean} options.parameters.lock_screen - The flag to lock the screen.
      * @param {Function} options.parameters.updateUpdateMainWindow - The function to update the main window state.
      * @param {Function} options.parameters.updateVideoProducer - The function to update the video producer state.
      * @param {Function} [options.parameters.updateLocalVideoProducer] - The function to update the local video producer state (optional).
      * @param {ReorderStreamsType} options.parameters.reorderStreams - The function to reorder streams.
      * @param {Function} [options.parameters.updateLocalProducerTransport] - The function to update the local producer transport state (optional).
      * @param {Function} [options.parameters.updateProducerTransport] - The function to update the producer transport state (optional).
      *
      * @returns {Promise<void>} A promise that resolves when the disconnection process is complete.
      *
      * @throws {Error} Throws an error if the disconnection process fails.
      *
      * @example
      * const options = {
      *   parameters: {
      *     videoProducer: videoProducerInstance,
      *     localVideoProducer: localVideoProducerInstance,
      *     socket: socketInstance,
      *     localSocket: localSocketInstance,
      *     islevel: '2',
      *     roomName: 'Room A',
      *     updateMainWindow: false,
      *     lock_screen: false,
      *     updateUpdateMainWindow: (state) => console.log('Main window updated:', state),
      *     updateVideoProducer: (producer) => console.log('Video producer updated:', producer),
      *     updateLocalVideoProducer: (producer) => console.log('Local video producer updated:', producer),
      *     reorderStreams: reorderStreamsFunction,
      *   },
      * };
      *
      * disconnectSendTransportVideo(options)
      *   .then(() => console.log('Video send transport disconnected successfully'))
      *   .catch((error) => console.error('Error disconnecting video send transport:', error));
      */
    async disconnectSendTransportVideo({ parameters, }) {
        try {
            let { videoProducer, socket, islevel, roomName, lock_screen, updateMainWindow, updateUpdateMainWindow, updateVideoProducer, reorderStreams, } = parameters.getUpdatedAllParams();
            // Close the video producer and update the state
            await videoProducer.close();
            updateVideoProducer(null);
            // Notify the server about pausing video sharing
            socket.emit('pauseProducerMedia', { mediaTag: 'video', roomName });
            // Update the UI based on the participant's level and screen lock status
            if (islevel === '2') {
                updateMainWindow = true;
                updateUpdateMainWindow(updateMainWindow);
            }
            if (lock_screen) {
                await reorderStreams({ add: true, screenChanged: true, parameters });
            }
            else {
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
            // Handle local video transport regardless of primary success or failure
            try {
                await disconnectLocalSendTransportVideo({ parameters });
            }
            catch (localError) {
                console.error('Error disconnecting local video send transport:', localError);
            }
        }
        catch (error) {
            // Handle errors during the disconnection process
            console.log('Error disconnecting send transport for video:', error.message);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectSendTransportVideo, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectSendTransportVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectSendTransportVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

const disconnectLocalSendTransportScreen = async ({ parameters }) => {
    try {
        // Destructure parameters
        let { localScreenProducer, localSocket, roomName, updateLocalScreenProducer, } = parameters;
        if (localSocket && localSocket.id) {
            localScreenProducer.close();
            updateLocalScreenProducer(localScreenProducer);
            // Notify the server about closing the screen producer and pausing screen sharing
            localSocket.emit('closeScreenProducer');
            localSocket.emit('pauseProducerMedia', { mediaTag: 'screen', roomName: roomName });
        }
    }
    catch {
        console.log('Error disconnecting local send transport for screen');
    }
};
/**
 * Disconnects the send transport for screen sharing.
 *
 * This function closes the screen producer, updates the state, and notifies the server
 * about the closure and pausing of screen sharing.
 *
 * @param {DisconnectSendTransportScreenOptions} options - The options for disconnecting the send transport.
 * @param {Object} options.parameters - The parameters required for disconnection.
 * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 * @param {Producer | null} options.parameters.screenProducer - The screen producer to be closed.
 * @param {Socket} options.parameters.socket - The socket connection to notify the server.
 * @param {Socket} [options.parameters.localSocket] - The local socket connection for communication.
 * @param {string} options.parameters.roomName - The name of the room.
 * @param {Function} options.parameters.updateScreenProducer - Function to update the screen producer state.
 * @param {Function} [options.parameters.updateLocalScreenProducer] - Function to update the local screen producer state.
 * @returns {Promise<void>} A promise that resolves when the disconnection process is complete.
 * @throws {Error} If an error occurs during the disconnection process.
 *
 * @example
 * const options = {
 *   parameters: {
 *     screenProducer: screenProducerInstance,
 *     socket: socketInstance,
 *     localSocket: localSocketInstance,
 *     roomName: 'Room 1',
 *     updateScreenProducer: (producer) => console.log('Updated screen producer:', producer),
 *     updateLocalScreenProducer: (localProducer) => console.log('Updated local screen producer:', localProducer),
 *     getUpdatedAllParams: () => ({
 *       screenProducer: screenProducerInstance,
 *       socket: socketInstance,
 *       roomName: 'Room 1',
 *     }),
 *   },
 * };
 *
 * disconnectSendTransportScreen(options)
 *   .then(() => {
 *     console.log('Screen send transport disconnected successfully');
 *   })
 *   .catch((error) => {
 *     console.error('Error disconnecting screen send transport:', error);
 *   });
 */
class DisconnectSendTransportScreen {
    /**
     * Disconnects the send transport for screen sharing.
     *
     * This function closes the screen producer, updates the state, and notifies the server
     * about the closure and pausing of screen sharing.
     *
     * @param {DisconnectSendTransportScreenOptions} options - The options for disconnecting the send transport.
     * @param {Object} options.parameters - The parameters required for disconnection.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {Producer | null} options.parameters.screenProducer - The screen producer to be closed.
     * @param {Socket} options.parameters.socket - The socket connection to notify the server.
     * @param {Socket} [options.parameters.localSocket] - The local socket connection for communication.
     * @param {string} options.parameters.roomName - The name of the room.
     * @param {Function} options.parameters.updateScreenProducer - Function to update the screen producer state.
     * @param {Function} [options.parameters.updateLocalScreenProducer] - Function to update the local screen producer state.
     * @returns {Promise<void>} A promise that resolves when the disconnection process is complete.
     * @throws {Error} If an error occurs during the disconnection process.
     *
     * @example
     * const options = {
     *   parameters: {
     *     screenProducer: screenProducerInstance,
     *     socket: socketInstance,
     *     localSocket: localSocketInstance,
     *     roomName: 'Room 1',
     *     updateScreenProducer: (producer) => console.log('Updated screen producer:', producer),
     *     updateLocalScreenProducer: (localProducer) => console.log('Updated local screen producer:', localProducer),
     *     getUpdatedAllParams: () => ({
     *       screenProducer: screenProducerInstance,
     *       socket: socketInstance,
     *       roomName: 'Room 1',
     *     }),
     *   },
     * };
     *
     * disconnectSendTransportScreen(options)
     *   .then(() => {
     *     console.log('Screen send transport disconnected successfully');
     *   })
     *   .catch((error) => {
     *     console.error('Error disconnecting screen send transport:', error);
     *   });
     */
    async disconnectSendTransportScreen({ parameters, }) {
        try {
            // Destructure parameters
            let { screenProducer, socket, roomName, updateScreenProducer } = parameters.getUpdatedAllParams();
            // Close the screen producer and update the state
            screenProducer?.close();
            updateScreenProducer(screenProducer);
            // Notify the server about closing the screen producer and pausing screen sharing
            socket.emit('closeScreenProducer');
            socket.emit('pauseProducerMedia', { mediaTag: 'screen', roomName });
        }
        catch (error) {
            // Handle errors during the disconnection process
            console.log('Error disconnecting send transport for screen:', error.message);
        }
        try {
            // Disconnect the local screen producer
            await disconnectLocalSendTransportScreen({ parameters });
        }
        catch {
            // Handle errors during the disconnection process
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectSendTransportScreen, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectSendTransportScreen, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectSendTransportScreen, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Function to display streams based on various parameters and conditions.
 *
 * @param {DispStreamsOptions} options - The options object.
 * @param {Array<(Stream | Participant)>} options.lStreams - List of streams to display.
 * @param {number} options.ind - Index of the current stream.
 * @param {boolean} [options.auto=false] - Flag to indicate if the function should run automatically.
 * @param {boolean} [options.ChatSkip=false] - Flag to indicate if chat should be skipped.
 * @param {string|null} [options.forChatID=null] - ID for chat reference.
 * @param {DispStreamsParameters} options.parameters - Parameters object containing various settings and functions.
 * @param {number} [options.breakRoom=-1] - Break room number.
 * @param {boolean} [options.inBreakRoom=false] - Flag to indicate if in break room.
 *
 * @returns {Promise<void>} A promise that resolves when the function completes.
 *
 * @async
 *
 * @example
 * ```typescript
 * const options = {
 *   lStreams: [...], // Your streams data here
 *   ind: 0,
 *   auto: true,
 *   ChatSkip: false,
 *   parameters: {
 *     consumerTransports: [],
 *     streamNames: [],
 *     audStreamNames: [],
 *     participants: [],
 *     ref_participants: [],
 *     recordingDisplayType: 'video',
 *     recordingVideoOptimized: false,
 *     meetingDisplayType: 'video',
 *     meetingVideoOptimized: false,
 *     currentUserPage: 1,
 *     hostLabel: 'Host',
 *     mainHeightWidth: 100,
 *     prevMainHeightWidth: 100,
 *     prevDoPaginate: false,
 *     doPaginate: false,
 *     firstAll: false,
 *     shared: false,
 *     shareScreenStarted: false,
 *     shareEnded: false,
 *     oldAllStreams: [],
 *     updateMainWindow: false,
 *     remoteProducerId: null,
 *     activeNames: [],
 *     dispActiveNames: [],
 *     p_dispActiveNames: [],
 *     nForReadjustRecord: 0,
 *     first_round: false,
 *     lock_screen: false,
 *     chatRefStreams: [],
 *     eventType: 'normal',
 *     islevel: '1',
 *     localStreamVideo: null,
 *     breakOutRoomStarted: false,
 *     breakOutRoomEnded: false,
 *     keepBackground: false,
 *     virtualStream: null,
 *     updateActiveNames: (names) => {},
 *     updateDispActiveNames: (names) => {},
 *     updateLStreams: (streams) => {},
 *     updateChatRefStreams: (streams) => {},
 *     updateNForReadjustRecord: (n) => {},
 *     updateUpdateMainWindow: (value) => {},
 *     updateShowMiniView: (value) => {},
 *     prepopulateUserMedia: async () => {},
 *     rePort: async () => {},
 *     processConsumerTransports: async () => {},
 *     resumePauseStreams: async () => {},
 *     readjust: async () => {},
 *     addVideosGrid: async () => {},
 *     getEstimate: async () => {},
 *     checkGrid: async () => {},
 *     resumePauseAudioStreams: async () => {},
 *     getUpdatedAllParams: () => options.parameters,
 *   },
 *   breakRoom: -1,
 *   inBreakRoom: false,
 * };
 *
 * dispStreamsService.dispStreams(options)
 *   .then(() => {
 *     console.log('Streams displayed successfully');
 *   })
 *   .catch((error) => {
 *     console.error('Error displaying streams:', error);
 *   });
 * ```
 */
class DispStreams {
    /**
     * Function to display streams based on various parameters and conditions.
     *
     * @param {Object} options - The options object.
     * @param {Array} options.lStreams - List of streams.
     * @param {number} options.ind - Index of the current stream.
     * @param {boolean} [options.auto=false] - Flag to indicate if the function should run automatically.
     * @param {boolean} [options.ChatSkip=false] - Flag to indicate if chat should be skipped.
     * @param {string|null} [options.forChatID=null] - ID for chat reference.
     * @param {Object} options.parameters - Parameters object containing various settings and functions.
     * @param {number} [options.breakRoom=-1] - Break room number.
     * @param {boolean} [options.inBreakRoom=false] - Flag to indicate if in break room.
     *
     * @returns {Promise<void>} - A promise that resolves when the function completes.
     *
     * @async
     */
    dispStreams = async ({ lStreams, ind, auto = false, ChatSkip = false, forChatID = null, parameters, breakRoom = -1, inBreakRoom = false, }) => {
        // function to display streams
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { consumerTransports, streamNames, audStreamNames, participants, ref_participants, recordingDisplayType, recordingVideoOptimized, meetingDisplayType, meetingVideoOptimized, currentUserPage, hostLabel, mainHeightWidth, prevMainHeightWidth, prevDoPaginate, doPaginate, firstAll, shared, shareScreenStarted, shareEnded, oldAllStreams, updateMainWindow, remoteProducerId, activeNames, dispActiveNames, p_dispActiveNames, nForReadjustRecord, first_round, lock_screen, chatRefStreams, eventType, islevel, localStreamVideo, breakOutRoomStarted, breakOutRoomEnded, keepBackground, virtualStream, updateActiveNames, updateDispActiveNames, updateLStreams, updateChatRefStreams, updateNForReadjustRecord, updateUpdateMainWindow, updateShowMiniView, prepopulateUserMedia, rePort, processConsumerTransports, resumePauseStreams, readjust, addVideosGrid, checkGrid, getEstimate, resumePauseAudioStreams, } = parameters;
        let proceed = true;
        let lStreams_ = lStreams.filter((stream) => stream.producerId !== 'youyou' && stream.producerId !== 'youyouyou');
        lStreams_ = lStreams_.filter((stream) => stream.id !== 'youyou' &&
            stream.id !== 'youyouyou' &&
            stream.name !== 'youyou' &&
            stream.name !== 'youyouyou');
        if (eventType === 'chat') {
            proceed = true;
        }
        else if (ind === 0 || (islevel !== '2' && currentUserPage === ind)) {
            proceed = false;
            lStreams_.forEach((stream) => {
                let checker = false;
                let check_level = 0;
                if (recordingDisplayType === 'video') {
                    if (recordingVideoOptimized) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            checker = true;
                            check_level = 0;
                        }
                    }
                    else {
                        if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') ||
                            (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '')) {
                            checker = true;
                            check_level = 1;
                        }
                    }
                }
                else if (recordingDisplayType === 'media') {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                        stream.producerId != null &&
                        stream.producerId !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                            stream.audioID != null &&
                            stream.audioID !== '')) {
                        checker = true;
                        check_level = 1;
                    }
                }
                else {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                        stream.producerId != null &&
                        stream.producerId !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                            stream.audioID != null &&
                            stream.audioID !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'name') &&
                            stream.name !== null &&
                            stream.name != '')) {
                        checker = true;
                        check_level = 2;
                    }
                }
                let participant;
                if (checker) {
                    if (check_level === 0) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                    }
                    else if (check_level === 1) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                        if (!participant) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '') {
                                participant = audStreamNames.find((obj) => obj.producerId === stream.audioID);
                                if (!participant) {
                                    participant = ref_participants.find((obj) => obj.audioID === stream.audioID);
                                }
                            }
                        }
                    }
                    else if (check_level === 2) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                        if (!participant) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '') {
                                participant = audStreamNames.find((obj) => obj.producerId === stream.audioID);
                                if (!participant) {
                                    participant = ref_participants.find((obj) => obj.audioID === stream.audioID);
                                }
                            }
                        }
                        if (!participant) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'name') &&
                                stream.name !== null &&
                                stream.name != '') {
                                participant = ref_participants.find((obj) => obj.name === stream.name);
                            }
                        }
                    }
                    if (participant) {
                        if (participant.name && !activeNames.includes(participant.name)) {
                            activeNames.push(participant.name);
                        }
                    }
                }
            });
            updateActiveNames(activeNames);
            lStreams_.forEach((stream) => {
                let disp_checker = false;
                let disp_check_level = 0;
                if (meetingDisplayType === 'video') {
                    if (meetingVideoOptimized) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            disp_checker = true;
                            disp_check_level = 0;
                        }
                    }
                    else {
                        if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') ||
                            (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '')) {
                            disp_checker = true;
                            disp_check_level = 1;
                        }
                    }
                }
                else if (meetingDisplayType === 'media') {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                        stream.producerId != null &&
                        stream.producerId !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                            stream.audioID != null &&
                            stream.audioID !== '')) {
                        disp_checker = true;
                        disp_check_level = 1;
                    }
                }
                else {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                        stream.producerId != null &&
                        stream.producerId !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                            stream.audioID != null &&
                            stream.audioID !== '') ||
                        (Object.prototype.hasOwnProperty.call(stream, 'name') &&
                            stream.name !== null &&
                            stream.name != '')) {
                        disp_checker = true;
                        disp_check_level = 2;
                    }
                }
                let participant_;
                if (disp_checker) {
                    if (disp_check_level === 0) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant_ = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                    }
                    else if (disp_check_level === 1) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant_ = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                        if (!participant_) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '') {
                                participant_ = audStreamNames.find((obj) => obj.producerId === stream.audioID);
                                if (!participant_) {
                                    participant_ = ref_participants.find((obj) => obj.audioID === stream.audioID);
                                }
                            }
                        }
                    }
                    else if (disp_check_level === 2) {
                        if (Object.prototype.hasOwnProperty.call(stream, 'producerId') &&
                            stream.producerId != null &&
                            stream.producerId !== '') {
                            participant_ = streamNames.find((obj) => obj.producerId === stream.producerId);
                        }
                        if (!participant_) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'audioID') &&
                                stream.audioID != null &&
                                stream.audioID !== '') {
                                participant_ = audStreamNames.find((obj) => obj.producerId === stream.audioID);
                                if (!participant_) {
                                    participant_ = ref_participants.find((obj) => obj.audioID === stream.audioID);
                                }
                            }
                        }
                        if (!participant_) {
                            if (Object.prototype.hasOwnProperty.call(stream, 'name') &&
                                stream.name !== null &&
                                stream.name != '') {
                                participant_ = ref_participants.find((obj) => obj.name === stream.name);
                            }
                        }
                    }
                    if (participant_) {
                        if (participant_.name && !dispActiveNames.includes(participant_.name)) {
                            dispActiveNames.push(participant_.name);
                            if (!p_dispActiveNames.includes(participant_.name)) {
                                proceed = true;
                            }
                        }
                    }
                }
            });
            updateDispActiveNames(dispActiveNames);
            if (lStreams_.length < 1) {
                if (shareScreenStarted || shared) {
                    proceed = true;
                }
                else if (!firstAll) {
                    proceed = true;
                }
            }
            if (shareScreenStarted || shared) {
                // screen share started
            }
            else {
                if (prevMainHeightWidth !== mainHeightWidth) {
                    updateMainWindow = true;
                    updateUpdateMainWindow(updateMainWindow);
                }
            }
            nForReadjustRecord = activeNames.length;
            updateNForReadjustRecord(nForReadjustRecord);
        }
        if (!proceed && auto) {
            if (updateMainWindow) {
                if (!lock_screen && !shared) {
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                }
                else {
                    if (!first_round) {
                        await prepopulateUserMedia({ name: hostLabel, parameters });
                    }
                }
            }
            if (ind === 0 && eventType !== 'chat') {
                await rePort({ parameters });
            }
            return;
        }
        if (eventType === 'broadcast') {
            lStreams = lStreams_;
            updateLStreams(lStreams);
        }
        else if (eventType === 'chat') {
            if (forChatID != null) {
                lStreams = chatRefStreams;
                updateLStreams(lStreams);
            }
            else {
                updateShowMiniView(false);
                if (islevel !== '2') {
                    let host = participants.find((obj) => obj.islevel === '2');
                    if (host) {
                        let streame;
                        remoteProducerId = host.videoID;
                        if (islevel === '2') {
                            host['stream'] = keepBackground && virtualStream ? virtualStream : localStreamVideo;
                        }
                        else {
                            streame = oldAllStreams.find((streame) => streame.producerId === remoteProducerId);
                            if (streame) {
                                lStreams = lStreams.filter((stream) => stream.name !== host.name);
                                lStreams.push(streame);
                            }
                        }
                    }
                }
                let youyou = lStreams.find((obj) => obj.producerId === 'youyou' || obj.producerId === 'youyouyou');
                lStreams = lStreams.filter((stream) => stream.producerId !== 'youyou' && stream.producerId !== 'youyouyou');
                if (youyou) {
                    lStreams.push(youyou);
                }
                chatRefStreams = lStreams;
                updateLStreams(lStreams);
                updateChatRefStreams(chatRefStreams);
            }
        }
        let refLength = lStreams.length;
        const [, rows, cols] = getEstimate({ n: refLength, parameters });
        let result = (await checkGrid({ rows, cols, actives: refLength })) || [false, 0, 0, 0, 0, 0, 0];
        let [removeAltGrid, numtoaddd, numRows, numCols, , actualRows, lastrowcols] = result;
        if (ChatSkip && eventType == 'chat') {
            numRows = 1;
            numCols = 1;
            actualRows = 1;
        }
        //if removeAltGrid is true then remove everyting from altGrid and add to mainGrid,check for streams on alvideoStreams and add to mainGrid that are not on mainGrid and add switching to true
        await readjust({ n: lStreams.length, state: ind, parameters });
        // split the streams into two arrays, one for mainGrid and one for altGrid
        // take up to numtoadd from the lStreams and add to mainGridStreams
        let mainGridStreams = lStreams.slice(0, numtoaddd);
        // take the rest of the streams and add to altGridStreams
        let altGridStreams = lStreams.slice(numtoaddd, lStreams.length);
        //add to grids
        if (doPaginate == true ||
            prevDoPaginate != doPaginate ||
            shared ||
            shareScreenStarted ||
            shareEnded) {
            let lStreams_alt = lStreams_;
            await processConsumerTransports({ consumerTransports, lStreams_: lStreams_alt, parameters });
            try {
                if (breakOutRoomStarted && !breakOutRoomEnded) {
                    await resumePauseAudioStreams({ inBreakRoom, breakRoom, parameters });
                }
            }
            catch (error) {
                // console.log('Error in resumePauseAudioStreams:', error);
            }
            try {
                if (!breakOutRoomStarted || (breakOutRoomStarted && breakOutRoomEnded)) {
                    await resumePauseStreams({ parameters });
                }
            }
            catch {
                /* handle error */
            }
            if (shareEnded) {
                shareEnded = false;
            }
        }
        if (ChatSkip && eventType == 'chat') {
            await addVideosGrid({
                mainGridStreams,
                altGridStreams,
                numtoadd: numtoaddd - 1,
                numRows,
                numCols,
                actualRows,
                lastrowcols,
                removeAltGrid,
                parameters,
            });
        }
        else {
            await addVideosGrid({
                mainGridStreams,
                altGridStreams,
                numtoadd: numtoaddd,
                numRows,
                numCols,
                actualRows,
                lastrowcols,
                removeAltGrid,
                parameters,
            });
        }
        if (updateMainWindow) {
            if (!lock_screen && !shared) {
                await prepopulateUserMedia({ name: hostLabel, parameters });
            }
            else {
                if (!first_round) {
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                }
            }
        }
        if (ind == 0 && eventType !== 'chat') {
            await rePort({ parameters });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DispStreams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DispStreams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DispStreams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Generates the content for a specific page.
 *
 * @param {GeneratePageContentOptions} options - The options for generating page content.
 * @param {number | string} options.page - The page number to generate content for.
 * @param {GeneratePageContentParameters} options.parameters - The parameters required for generating content.
 * @param {Array<(Participant | Stream)[]>} options.parameters.paginatedStreams - The streams to be paginated.
 * @param {number} options.parameters.currentUserPage - The current page of the user.
 * @param {Function} options.parameters.updateMainWindow - Function to update the main window flag.
 * @param {Function} options.parameters.updateCurrentUserPage - Function to update the current user page.
 * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window update flag.
 * @param {Function} options.parameters.dispStreams - Function to display streams for the specified page.
 * @param {number} [options.breakRoom=-1] - The break room identifier.
 * @param {boolean} [options.inBreakRoom=false] - Flag indicating if the user is in a break room.
 *
 * @returns {Promise<void>} A promise that resolves when the content generation is complete.
 *
 * @throws {Error} Throws an error if content generation fails.
 *
 * @example
 * ```typescript
 * const options = {
 *   page: 1,
 *   parameters: {
 *     paginatedStreams: [
 *       // Page 0 streams
 *       [stream1, stream2],
 *       // Page 1 streams
 *       [stream3, stream4],
 *     ],
 *     currentUserPage: 0,
 *     updateMainWindow: false,
 *     updateCurrentUserPage: (page) => { console.log(`Current page updated to: ${page}`); },
 *     updateUpdateMainWindow: (flag) => { console.log(`Main window update flag: ${flag}`); },
 *     dispStreams: async ({ lStreams, ind }) => {
 *       console.log(`Displaying streams for page ${ind}:`, lStreams);
 *     },
 *     getUpdatedAllParams: () => options.parameters,
 *   },
 *   breakRoom: -1,
 *   inBreakRoom: false,
 * };
 *
 * const generatePageContentService = new GeneratePageContent();
 * await generatePageContentService.generatePageContent(options);
 * ```
 */
class GeneratePageContent {
    /**
     * Generates the content for a specific page.
     *
     * @param {Object} options - The options for generating page content.
     * @param {number | string} options.page - The page number to generate content for.
     * @param {Object} options.parameters - The parameters required for generating content.
     * @param {Array} options.parameters.paginatedStreams - The streams to be paginated.
     * @param {number} options.parameters.currentUserPage - The current page of the user.
     * @param {Function} options.parameters.updateMainWindow - Function to update the main window flag.
     * @param {Function} options.parameters.updateCurrentUserPage - Function to update the current user page.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window update flag.
     * @param {Function} options.parameters.dispStreams - Function to display streams for the specified page.
     * @param {number} [options.breakRoom=-1] - The break room identifier.
     * @param {boolean} [options.inBreakRoom=false] - Flag indicating if the user is in a break room.
     * @returns {Promise<void>} A promise that resolves when the content generation is complete.
     * @throws {Error} Throws an error if content generation fails.
     */
    async generatePageContent({ page, parameters, breakRoom = -1, inBreakRoom = false, }) {
        try {
            // Destructure parameters
            parameters = parameters.getUpdatedAllParams();
            let { paginatedStreams, currentUserPage, updateMainWindow, updateCurrentUserPage, updateUpdateMainWindow, 
            // mediasfu functions
            dispStreams, } = parameters;
            // Convert page to an integer
            page = parseInt(page.toString(), 10);
            // Update current user page
            currentUserPage = page;
            updateCurrentUserPage(currentUserPage);
            // Update main window flag
            updateMainWindow = true;
            updateUpdateMainWindow(updateMainWindow);
            // Display streams for the specified page
            await dispStreams({
                lStreams: paginatedStreams[page],
                ind: page,
                parameters,
                breakRoom,
                inBreakRoom,
            });
        }
        catch (error) {
            // Handle errors during content generation
            console.log('Error generating page content:', error.message);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GeneratePageContent, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GeneratePageContent, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GeneratePageContent, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// estimate.service.ts
/**
 * Estimates the number of rows and columns for a given set of parameters.
 *
 * @param {GetEstimateOptions} options - The options for the estimation.
 * @param {number} options.n - The number of items to estimate for.
 * @param {GetEstimateParameters} options.parameters - The parameters for the estimation.
 * @param {number} options.parameters.fixedPageLimit - The fixed page limit.
 * @param {number} options.parameters.screenPageLimit - The screen page limit.
 * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
 * @param {boolean} [options.parameters.shared=false] - Indicates if sharing is active.
 * @param {EventType} options.parameters.eventType - The type of event (e.g., "chat", "conference").
 * @param {boolean} options.parameters.removeAltGrid - Indicates if the alternate grid should be removed.
 * @param {boolean} options.parameters.isWideScreen - Indicates if the screen is wide.
 * @param {boolean} options.parameters.isMediumScreen - Indicates if the screen is medium-sized.
 * @param {Function} options.parameters.updateRemoveAltGrid - Function to update the removeAltGrid parameter.
 * @param {CalculateRowsAndColumnsType} options.parameters.calculateRowsAndColumns - Function to calculate rows and columns.
 *
 * @returns {[number, number, number]} An array containing:
 * - Estimated number of items,
 * - Estimated number of rows,
 * - Estimated number of columns.
 *
 * @throws Will log an error message if an error occurs during estimation.
 *
 * @example
 * ```typescript
 * const estimateOptions = {
 *   n: 20,
 *   parameters: {
 *     fixedPageLimit: 10,
 *     screenPageLimit: 15,
 *     shareScreenStarted: false,
 *     shared: false,
 *     eventType: 'conference',
 *     removeAltGrid: false,
 *     isWideScreen: true,
 *     isMediumScreen: false,
 *     updateRemoveAltGrid: (value) => console.log(`Remove Alt Grid: ${value}`),
 *     calculateRowsAndColumns: ({ n }) => {
 *       const sqrt = Math.sqrt(n);
 *       return [Math.ceil(sqrt), Math.floor(sqrt)];
 *     },
 *   },
 * };
 *
 * const estimateService = new GetEstimate();
 * const [estimatedItems, estimatedRows, estimatedCols] = estimateService.getEstimate(estimateOptions);
 * console.log(`Estimated Items: ${estimatedItems}, Rows: ${estimatedRows}, Columns: ${estimatedCols}`);
 * ```
 */
class GetEstimate {
    /**
     * Estimates the number of rows and columns for a given set of parameters.
     *
     * @param {GetEstimateOptions} options - The options for the estimation.
     * @param {number} options.n - The number of items to estimate for.
     * @param {Object} options.parameters - The parameters for the estimation.
     * @param {number} options.parameters.fixedPageLimit - The fixed page limit.
     * @param {number} options.parameters.screenPageLimit - The screen page limit.
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
     * @param {boolean} options.parameters.shared - Indicates if sharing is active.
     * @param {string} options.parameters.eventType - The type of event (e.g., "chat", "conference").
     * @param {boolean} options.parameters.removeAltGrid - Indicates if the alternate grid should be removed.
     * @param {boolean} options.parameters.isWideScreen - Indicates if the screen is wide.
     * @param {boolean} options.parameters.isMediumScreen - Indicates if the screen is medium-sized.
     * @param {Function} options.parameters.updateRemoveAltGrid - Function to update the removeAltGrid parameter.
     * @param {Function} options.parameters.calculateRowsAndColumns - Function to calculate rows and columns.
     *
     * @returns {number[]} An array containing the estimated number of items, rows, and columns.
     *
     * @throws Will log an error message if an error occurs during estimation.
     */
    getEstimate({ n, parameters }) {
        try {
            // Destructure parameters
            let { fixedPageLimit, screenPageLimit, shareScreenStarted, shared, eventType, removeAltGrid, isWideScreen, isMediumScreen, updateRemoveAltGrid, 
            // mediaSfu functions
            calculateRowsAndColumns, } = parameters;
            // Calculate rows and columns
            const [rows, cols] = calculateRowsAndColumns({ n });
            // Check conditions for removing alt grid
            if (n < fixedPageLimit || ((shareScreenStarted || shared) && n < screenPageLimit + 1)) {
                removeAltGrid = true;
                updateRemoveAltGrid(removeAltGrid);
                // Return estimated values based on screen width
                if (!(isMediumScreen || isWideScreen)) {
                    return eventType === 'chat' ||
                        (eventType === 'conference' && !(shareScreenStarted || shared))
                        ? [n, n, 1]
                        : [n, 1, n];
                }
                else {
                    return eventType === 'chat' ||
                        (eventType === 'conference' && !(shareScreenStarted || shared))
                        ? [n, 1, n]
                        : [n, n, 1];
                }
            }
            return [rows * cols, rows, cols];
        }
        catch (error) {
            // Handle errors during estimation
            console.log('Error estimating rows and columns:', error.message);
            // throw error;
            return [0, 0, 0];
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetEstimate, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetEstimate, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetEstimate, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// piped-producers.service.ts
/**
 * Retrieves piped producers and signals new consumer transport for each retrieved producer.
 *
 * @param {GetPipedProducersAltOptions} options - The options for retrieving piped producers.
 * @param {boolean} options.community - Whether the room is a community edition room.
 * @param {Socket} options.nsock - The WebSocket instance used for communication.
 * @param {string} options.islevel - A flag indicating the level of the request.
 * @param {GetPipedProducersAltParameters} options.parameters - Additional parameters for the request.
 * @param {string} options.parameters.member - The member identifier.
 * @param {SignalNewConsumerTransportType} options.parameters.signalNewConsumerTransport - A function to signal new consumer transport.
 *
 * @returns {Promise<void>} A promise that resolves when the operation is complete.
 *
 * @throws {Error} If an error occurs during the process of retrieving producers.
 *
 * @example
 * ```typescript
 * const options = {
 *   community: true,
 *   nsock: socketInstance,
 *   islevel: '2',
 *   parameters: {
 *     member: 'user123',
 *     signalNewConsumerTransport: async ({ nsock, remoteProducerId, islevel, parameters }) => {
 *       // Implementation to signal new consumer transport
 *       console.log(`Signaling new consumer transport for producer: ${remoteProducerId}`);
 *     },
 *   },
 * };
 *
 * const getPipedProducersService = new GetPipedProducersAlt();
 * await getPipedProducersService.getPipedProducersAlt(options);
 * console.log('Piped producers retrieved successfully.');
 * ```
 */
class GetPipedProducersAlt {
    /**
     * Retrieves piped producers and signals new consumer transport for each retrieved producer.
     *
     * @param {Object} options - The options for retrieving piped producers.
     * @param {boolean} options.community - Whether the room is a community edition room.
     * @param {WebSocket} options.nsock - The WebSocket instance used for communication.
     * @param {boolean} options.islevel - A flag indicating the level of the request.
     * @param {Object} options.parameters - Additional parameters for the request.
     * @param {string} options.parameters.member - The member identifier.
     * @param {Function} options.parameters.signalNewConsumerTransport - A function to signal new consumer transport.
     *
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     *
     * @throws {Error} If an error occurs during the process of retrieving producers.
     */
    async getPipedProducersAlt({ community = false, nsock, islevel, parameters, }) {
        try {
            // Destructure parameters
            const { member, signalNewConsumerTransport } = parameters;
            const emitName = community ? "getProducersAlt" : "getProducersPipedAlt";
            // Emit request to get piped producers using WebSocket
            nsock.emit(emitName, { islevel, member }, async (producerIds) => {
                // Check if producers are retrieved
                if (producerIds.length > 0) {
                    // Signal new consumer transport for each retrieved producer
                    for (const id of producerIds) {
                        await signalNewConsumerTransport({ nsock, remoteProducerId: id, islevel, parameters });
                    }
                }
            });
        }
        catch (error) {
            // Handle errors during the process of retrieving producers
            console.log('Error getting piped producers:', error.message);
            // throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetPipedProducersAlt, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetPipedProducersAlt, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetPipedProducersAlt, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Retrieves piped producers and signals new consumer transport for each retrieved producer.
 *
 * @param {GetProducersPipedOptions} options - The options for getting piped producers.
 * @param {Socket} options.nsock - The WebSocket instance used for communication.
 * @param {string} options.islevel - A flag indicating the level of the operation.
 * @param {GetProducersPipedParameters} options.parameters - Additional parameters for the operation.
 * @param {string} options.parameters.member - The member identifier.
 * @param {SignalNewConsumerTransportType} options.parameters.signalNewConsumerTransport - The function to signal new consumer transport.
 *
 * @returns {Promise<void>} A promise that resolves when the operation is complete.
 *
 * @throws {Error} If an error occurs during the process of retrieving producers.
 *
 * @example
 * ```typescript
 * const options = {
 *   nsock: socketInstance,
 *   islevel: '2',
 *   parameters: {
 *     member: 'user123',
 *     signalNewConsumerTransport: async ({ remoteProducerId, islevel, nsock, parameters }) => {
 *       // Implementation to signal new consumer transport
 *       console.log(`Signaling new consumer transport for producer: ${remoteProducerId}`);
 *     },
 *   },
 * };
 *
 * const getProducersPipedService = new GetProducersPiped();
 * await getProducersPipedService.getProducersPiped(options);
 * console.log('Piped producers retrieved successfully.');
 * ```
 */
class GetProducersPiped {
    /**
     * Retrieves piped producers and signals new consumer transport for each retrieved producer.
     *
     * @param {Object} options - The options for getting piped producers.
     * @param {WebSocket} options.nsock - The WebSocket instance used for communication.
     * @param {boolean} options.islevel - A flag indicating the level of the operation.
     * @param {Object} options.parameters - Additional parameters for the operation.
     * @param {string} options.parameters.member - The member identifier.
     * @param {Function} options.parameters.signalNewConsumerTransport - The function to signal new consumer transport.
     *
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     *
     * @throws {Error} If an error occurs during the process of retrieving producers.
     */
    async getProducersPiped({ nsock, islevel, parameters }) {
        try {
            // Destructure parameters
            const { member, signalNewConsumerTransport } = parameters;
            // Emit request to get piped producers using WebSocket
            nsock.emit('getProducersPipedAlt', { islevel, member }, async (producerIds) => {
                // Check if producers are retrieved
                if (producerIds.length > 0) {
                    // Signal new consumer transport for each retrieved producer
                    await Promise.all(producerIds.map((id) => signalNewConsumerTransport({ remoteProducerId: id, islevel, nsock, parameters })));
                }
            });
        }
        catch (error) {
            // Handle errors during the process of retrieving producers
            console.log('Error getting piped producers:', error.message);
            // throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetProducersPiped, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetProducersPiped, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetProducersPiped, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Asynchronously processes and updates video streams by filtering out the admin's video stream.
 *
 * @param {GetVideosOptions} options - The options for getting videos.
 * @param {Participant[]} options.participants - The list of participants.
 * @param {Stream[]} options.allVideoStreams - The list of all video streams.
 * @param {(Stream | Participant)[]} options.oldAllStreams - The list of old video streams.
 * @param {string} [options.adminVidID] - The ID of the admin's video stream.
 * @param {Function} options.updateAllVideoStreams - Function to update the state variable for all video streams.
 * @param {Function} options.updateOldAllStreams - Function to update the state variable for old video streams.
 * @returns {Promise<void>} A promise that resolves when the video streams have been processed and updated.
 *
 * @throws {Error} If an error occurs during the process of updating video streams.
 *
 * @example
 * ```typescript
 * const options = {
 *   participants: participantList,
 *   allVideoStreams: currentVideoStreams,
 *   oldAllStreams: previousVideoStreams,
 *   updateAllVideoStreams: (streams) => {
 *     console.log('Updated all video streams:', streams);
 *   },
 *   updateOldAllStreams: (streams) => {
 *     console.log('Updated old video streams:', streams);
 *   },
 * };
 *
 * const getVideosService = new GetVideos();
 * await getVideosService.getVideos(options);
 * console.log('Video streams processed successfully.');
 * ```
 */
class GetVideos {
    /**
     * Asynchronously processes and updates video streams by filtering out the admin's video stream.
     *
     * @param {GetVideosOptions} options - The options for getting videos.
     * @param {Participant[]} options.participants - The list of participants.
     * @param {Stream[]} options.allVideoStreams - The list of all video streams.
     * @param {(Stream | Participant)[]} options.oldAllStreams - The list of old video streams.
     * @param {string} options.adminVidID - The ID of the admin's video stream.
     * @param {Function} options.updateAllVideoStreams - Function to update the state variable for all video streams.
     * @param {Function} options.updateOldAllStreams - Function to update the state variable for old video streams.
     * @returns {Promise<void>} A promise that resolves when the video streams have been processed and updated.
     */
    async getVideos({ participants, allVideoStreams, oldAllStreams, adminVidID, updateAllVideoStreams, updateOldAllStreams, }) {
        try {
            // Filter out the admin's video stream and update state variables
            let admin = participants.filter((participant) => participant.islevel === '2');
            if (admin.length > 0) {
                adminVidID = admin[0].videoID;
                if (adminVidID != null && adminVidID !== '') {
                    let oldAllStreams_ = [];
                    // Check if the length of oldAllStreams is greater than 0
                    if (oldAllStreams.length > 0) {
                        oldAllStreams_ = oldAllStreams;
                    }
                    // Filter out admin's video stream from oldAllStreams
                    oldAllStreams = allVideoStreams.filter((streame) => streame.producerId === adminVidID);
                    // If no admin's video stream found, revert to the previous state
                    if (oldAllStreams.length < 1) {
                        oldAllStreams = oldAllStreams_;
                    }
                    // Update the state variable for old video streams
                    updateOldAllStreams(oldAllStreams);
                    // Filter out admin's video stream from allVideoStreams
                    allVideoStreams = allVideoStreams.filter((streame) => streame.producerId !== adminVidID);
                    // Update the state variable for all video streams
                    updateAllVideoStreams(allVideoStreams);
                }
            }
        }
        catch (error) {
            // Handle errors during the process of updating video streams
            console.log('Error updating video streams:', error.message);
            // throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetVideos, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetVideos, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetVideos, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Mixes video and audio streams and participants based on specified parameters.
 *
 * @param {MixStreamsOptions} options - The options for mixing streams.
 * @param {Array<Stream | Participant>} options.alVideoStreams - The list of audio and video streams to mix.
 * @param {Array<Participant>} options.non_alVideoStreams - The list of non-audio and video streams to mix.
 * @param {Array<Stream | Participant>} options.ref_participants - The list of reference participants to mix.
 * @returns {Promise<Array<Stream | Participant>>} A promise that resolves with the mixed streams.
 *
 * @throws Will throw an error if there is an issue mixing the streams.
 *
 * @example
 * ```typescript
 * const mixedStreams = await mixStreams({
 *   alVideoStreams: [stream1, stream2],
 *   non_alVideoStreams: [participant1, participant2],
 *   ref_participants: [participant1, participant2],
 * });
 *
 * console.log('Mixed streams:', mixedStreams);
 * ```
 */
class MixStreams {
    /**
     * Mixes video and audio streams and participants based on specified parameters.
     *
     * @param {Object} options - The options for mixing streams.
     * @param {Array} options.alVideoStreams - The list of audio and video streams to mix.
     * @param {Array} options.non_alVideoStreams - The list of non-audio and video streams to mix.
     * @param {Array} options.ref_participants - The list of reference participants to mix.
     * @returns {Promise<Array>} A promise that resolves with the mixed streams.
     * @throws Will throw an error if there is an issue mixing the streams.
     * @example
     * ```typescript
     * mixStreams({
     *   alVideoStreams: [stream1, stream2],
     *  non_alVideoStreams: [participant1, participant2],
     * ref_participants: [participant1, participant2]
     * });
     *
     * ```
     */
    async mixStreams({ alVideoStreams, non_alVideoStreams, ref_participants, }) {
        try {
            const mixedStreams = [];
            const youyouStream = alVideoStreams.find((obj) => obj.producerId === 'youyou' || obj.producerId === 'youyouyou');
            alVideoStreams = alVideoStreams.filter((obj) => obj.producerId !== 'youyou' && obj.producerId !== 'youyouyou');
            const unmutedAlVideoStreams = alVideoStreams.filter((obj) => {
                const participant = ref_participants.find((p) => p.videoID === obj.producerId);
                return !obj.muted && participant && participant.muted === false;
            });
            const mutedAlVideoStreams = alVideoStreams.filter((obj) => {
                const participant = ref_participants.find((p) => p.videoID === obj.producerId);
                return obj.muted || (participant && participant.muted === true);
            });
            const nonAlVideoStreams = non_alVideoStreams.slice(); // Create a copy of non_alVideoStreams
            // Add unmutedAlVideoStreams to mixedStreams
            mixedStreams.push(...unmutedAlVideoStreams);
            // Interleave the mutedAlVideoStreams and nonAlVideoStreams
            let nonAlIndex = 0;
            for (let i = 0; i < mutedAlVideoStreams.length; i++) {
                if (nonAlIndex < nonAlVideoStreams.length) {
                    mixedStreams.push(nonAlVideoStreams[nonAlIndex]);
                    nonAlIndex++;
                }
                mixedStreams.push(mutedAlVideoStreams[i]);
            }
            // Handle remaining nonAlVideoStreams (if any)
            for (let i = nonAlIndex; i < nonAlVideoStreams.length; i++) {
                mixedStreams.push(nonAlVideoStreams[i]);
            }
            // Unshift 'youyou' or 'youyouyou' stream to mixedStreams
            if (youyouStream) {
                mixedStreams.unshift(youyouStream);
            }
            return mixedStreams;
        }
        catch (error) {
            // Handle errors during the process of mixing streams
            console.log('Error mixing streams:', error.message);
            throw error;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MixStreams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MixStreams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MixStreams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Handles changes in screen events such as broadcast, chat, and conference.
 *
 * @param {OnScreenChangesOptions} options - The options for handling screen changes.
 * @param {boolean} [options.changed=false] - Indicates if the screen has changed.
 * @param {OnScreenChangesParameters} options.parameters - The parameters for handling screen changes.
 * @param {string} options.parameters.eventType - The type of event (e.g., "broadcast", "chat", "conference").
 * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
 * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
 * @param {boolean} options.parameters.addForBasic - Flag to add basic controls.
 * @param {Function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
 * @param {Function} options.parameters.updateAddForBasic - Function to update the addForBasic flag.
 * @param {number} options.parameters.itemPageLimit - The limit for item pages.
 * @param {Function} options.parameters.updateItemPageLimit - Function to update the item page limit.
 * @param {Function} options.parameters.reorderStreams - Function to reorder streams.
 *
 * @returns {Promise<void>} A promise that resolves when the screen changes have been handled.
 *
 * @throws {Error} Throws an error if there is an issue handling screen changes.
 *
 * @example
 * ```typescript
 * const options = {
 *   changed: true,
 *   parameters: {
 *     eventType: 'broadcast',
 *     shareScreenStarted: false,
 *     shared: false,
 *     addForBasic: false,
 *     updateMainHeightWidth: (value) => { console.log(updated) },
 *     updateAddForBasic: (value) => { console.log(updated) },
 *     itemPageLimit: 1,
 *     updateItemPageLimit: (value) => { console.log(updated) },
 *     reorderStreams: async (params) => { },
 *   },
 * };
 *
 * await onScreenChanges(options);
 * ```
 */
class OnScreenChanges {
    /**
     * Handles changes in screen events such as broadcast, chat, and conference.
     *
     * @param {OnScreenChangesOptions} options - The options for handling screen changes.
     * @param {boolean} options.changed - Indicates if the screen has changed.
     * @param {object} options.parameters - The parameters for handling screen changes.
     * @param {string} options.parameters.eventType - The type of event (e.g., "broadcast", "chat", "conference").
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
     * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
     * @param {boolean} options.parameters.addForBasic - Flag to add basic controls.
     * @param {function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
     * @param {function} options.parameters.updateAddForBasic - Function to update the addForBasic flag.
     * @param {number} options.parameters.itemPageLimit - The limit for item pages.
     * @param {function} options.parameters.updateItemPageLimit - Function to update the item page limit.
     * @param {function} options.parameters.reorderStreams - Function to reorder streams.
     *
     * @returns {Promise<void>} A promise that resolves when the screen changes have been handled.
     *
     * @throws {Error} Throws an error if there is an issue handling screen changes.
     */
    onScreenChanges = async ({ changed = false, parameters, }) => {
        try {
            // Destructure parameters
            let { eventType, shareScreenStarted, shared, addForBasic, updateMainHeightWidth, updateAddForBasic, itemPageLimit, updateItemPageLimit, 
            // mediasfu functions
            reorderStreams, } = parameters;
            // Remove element with id 'controlButtons'
            addForBasic = false;
            updateAddForBasic(addForBasic);
            if (eventType == 'broadcast' || eventType == 'chat') {
                addForBasic = true;
                updateAddForBasic(addForBasic);
                itemPageLimit = eventType == 'broadcast' ? 1 : 2;
                updateItemPageLimit(itemPageLimit);
                updateMainHeightWidth(eventType == 'broadcast' ? 100 : 0);
            }
            else {
                if (eventType == 'conference' && !(shareScreenStarted || shared)) {
                    updateMainHeightWidth(0);
                }
            }
            // Update the mini cards grid
            await reorderStreams({ add: false, screenChanged: changed, parameters });
        }
        catch (error) {
            // Handle errors during the process of handling screen changes
            console.log('Error handling screen changes:', error.message);
            // throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: OnScreenChanges, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: OnScreenChanges, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: OnScreenChanges, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Prepopulates the user media based on the provided options.
 *
 * This method prepares the UI components for the user's media based on the event type and participant information.
 * It manages the display of video and audio cards, mini cards, and handles screen sharing scenarios.
 *
 * @param {PrepopulateUserMediaOptions} options - The options for prepopulating user media.
 * @param {string} options.name - The name of the user.
 * @param {PrepopulateUserMediaParameters} options.parameters - The parameters for prepopulating user media.
 * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 * @param {Array<Participant>} options.parameters.participants - List of participants.
 * @param {Array<Stream>} options.parameters.allVideoStreams - List of all video streams.
 * @param {string} options.parameters.islevel - The level of the user.
 * @param {string} options.parameters.member - The member name.
 * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
 * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
 * @param {string} options.parameters.eventType - The type of event (e.g., "broadcast", "chat", "conference").
 * @param {string} options.parameters.screenId - The ID of the screen.
 * @param {boolean} options.parameters.forceFullDisplay - Indicates if full display is forced.
 * @param {Function} options.parameters.updateMainWindow - Function to update the main window.
 * @param {boolean} options.parameters.mainScreenFilled - Indicates if the main screen is filled.
 * @param {boolean} options.parameters.adminOnMainScreen - Indicates if admin is on the main screen.
 * @param {string} options.parameters.mainScreenPerson - The person on the main screen.
 * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already on.
 * @param {boolean} options.parameters.audioAlreadyOn - Indicates if the audio is already on.
 * @param {Array<Stream>} options.parameters.oldAllStreams - List of old all streams.
 * @param {Function} options.parameters.checkOrientation - Function to check orientation.
 * @param {boolean} options.parameters.screenForceFullDisplay - Indicates if screen force full display is enabled.
 * @param {Stream} options.parameters.localStreamScreen - The local screen stream.
 * @param {Array<Stream>} options.parameters.remoteScreenStream - List of remote screen streams.
 * @param {Stream} options.parameters.localStreamVideo - The local video stream.
 * @param {number} options.parameters.mainHeightWidth - The main height and width.
 * @param {boolean} options.parameters.isWideScreen - Indicates if the screen is wide.
 * @param {boolean} options.parameters.localUIMode - Indicates if local UI mode is enabled.
 * @param {boolean} options.parameters.whiteboardStarted - Indicates if whiteboard has started.
 * @param {boolean} options.parameters.whiteboardEnded - Indicates if whiteboard has ended.
 * @param {Stream} options.parameters.virtualStream - The virtual stream.
 * @param {boolean} options.parameters.keepBackground - Indicates if background should be kept.
 * @param {Stream} options.parameters.annotateScreenStream - The annotate screen stream.
 * @param {Function} options.parameters.updateMainScreenPerson - Function to update the main screen person.
 * @param {Function} options.parameters.updateMainScreenFilled - Function to update if the main screen is filled.
 * @param {Function} options.parameters.updateAdminOnMainScreen - Function to update if admin is on the main screen.
 * @param {Function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
 * @param {Function} options.parameters.updateScreenForceFullDisplay - Function to update screen force full display.
 * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window update status.
 * @param {Function} options.parameters.updateMainGridStream - Function to update the main grid stream.
 *
 * @returns {Promise<{ component: any; inputs: any }[] | void>} A promise that resolves with the components and inputs or void.
 *
 * @throws {Error} Throws an error if there is an issue preparing and populating the main screen.
 *
 * @example
 * ```typescript
 * const options = {
 *   name: 'John Doe',
 *   parameters: {
 *     getUpdatedAllParams: () => { },
 *     participants: [],
 *     allVideoStreams: [],
 *     islevel: '1',
 *     member: 'John',
 *     shared: false,
 *     shareScreenStarted: false,
 *     eventType: 'conference',
 *     screenId: 'screen123',
 *     forceFullDisplay: false,
 *     updateMainWindow: false,
 *     mainScreenFilled: false,
 *     adminOnMainScreen: false,
 *     mainScreenPerson: '',
 *     videoAlreadyOn: false,
 *     audioAlreadyOn: false,
 *     oldAllStreams: [],
 *     checkOrientation: () => 'landscape',
 *     screenForceFullDisplay: false,
 *     localStreamScreen: null,
 *     remoteScreenStream: [],
 *     localStreamVideo: null,
 *     mainHeightWidth: 100,
 *     isWideScreen: true,
 *     localUIMode: false,
 *     whiteboardStarted: false,
 *     whiteboardEnded: false,
 *     virtualStream: null,
 *     keepBackground: false,
 *     annotateScreenStream: false,
 *     updateMainScreenPerson: (person) => { console.log(updated) },
 *     updateMainScreenFilled: (filled) => { console.log(updated) },
 *     updateAdminOnMainScreen: (admin) => { console.log(updated) },
 *     updateMainHeightWidth: (heightWidth) => { console.log(updated) },
 *     updateScreenForceFullDisplay: (force) => { console.log(updated) },
 *     updateUpdateMainWindow: (update) => { console.log(updated) },
 *     updateMainGridStream: (components) => { console.log(updated) },
 *   },
 * };
 *
 * await prepopulateUserMedia(options);
 * ```
 */
class PrepopulateUserMedia {
    /**
     * Prepopulates the user media based on the provided options.
     *
     * @param {PrepopulateUserMediaOptions} options - The options for prepopulating user media.
     * @param {string} options.name - The name of the user.
     * @param {Parameters} options.parameters - The parameters for prepopulating user media.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {Array<Participant>} options.parameters.participants - List of participants.
     * @param {Array<Stream>} options.parameters.allVideoStreams - List of all video streams.
     * @param {string} options.parameters.islevel - The level of the user.
     * @param {string} options.parameters.member - The member name.
     * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
     * @param {string} options.parameters.eventType - The type of event.
     * @param {string} options.parameters.screenId - The screen ID.
     * @param {boolean} options.parameters.forceFullDisplay - Indicates if full display is forced.
     * @param {Function} options.parameters.updateMainWindow - Function to update the main window.
     * @param {boolean} options.parameters.mainScreenFilled - Indicates if the main screen is filled.
     * @param {boolean} options.parameters.adminOnMainScreen - Indicates if admin is on the main screen.
     * @param {string} options.parameters.mainScreenPerson - The person on the main screen.
     * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already on.
     * @param {boolean} options.parameters.audioAlreadyOn - Indicates if the audio is already on.
     * @param {Array<Stream>} options.parameters.oldAllStreams - List of old all streams.
     * @param {Function} options.parameters.checkOrientation - Function to check orientation.
     * @param {boolean} options.parameters.screenForceFullDisplay - Indicates if screen force full display is enabled.
     * @param {Stream} options.parameters.localStreamScreen - The local screen stream.
     * @param {Array<Stream>} options.parameters.remoteScreenStream - List of remote screen streams.
     * @param {Stream} options.parameters.localStreamVideo - The local video stream.
     * @param {number} options.parameters.mainHeightWidth - The main height and width.
     * @param {boolean} options.parameters.isWideScreen - Indicates if the screen is wide.
     * @param {boolean} options.parameters.localUIMode - Indicates if local UI mode is enabled.
     * @param {boolean} options.parameters.whiteboardStarted - Indicates if whiteboard has started.
     * @param {boolean} options.parameters.whiteboardEnded - Indicates if whiteboard has ended.
     * @param {Stream} options.parameters.virtualStream - The virtual stream.
     * @param {boolean} options.parameters.keepBackground - Indicates if background should be kept.
     * @param {Stream} options.parameters.annotateScreenStream - The annotate screen stream.
     * @param {Function} options.parameters.updateMainScreenPerson - Function to update the main screen person.
     * @param {Function} options.parameters.updateMainScreenFilled - Function to update if the main screen is filled.
     * @param {Function} options.parameters.updateAdminOnMainScreen - Function to update if admin is on the main screen.
     * @param {Function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
     * @param {Function} options.parameters.updateScreenForceFullDisplay - Function to update screen force full display.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window update status.
     * @param {Function} options.parameters.updateMainGridStream - Function to update the main grid stream.
     *
     * @returns {Promise<{ component: any, inputs: any }[] | void>} A promise that resolves with the components and inputs or void.
     */
    prepopulateUserMedia = async ({ name, parameters, }) => {
        try {
            // Destructure parameters
            let { getUpdatedAllParams } = parameters;
            parameters = getUpdatedAllParams();
            let { participants, allVideoStreams, islevel, member, shared, shareScreenStarted, eventType, screenId, forceFullDisplay, updateMainWindow, mainScreenFilled, adminOnMainScreen, mainScreenPerson, videoAlreadyOn, audioAlreadyOn, oldAllStreams, checkOrientation, screenForceFullDisplay, localStreamScreen, remoteScreenStream, localStreamVideo, mainHeightWidth, isWideScreen, localUIMode, whiteboardStarted, whiteboardEnded, virtualStream, keepBackground, annotateScreenStream, updateMainScreenPerson, updateMainScreenFilled, updateAdminOnMainScreen, updateMainHeightWidth, updateScreenForceFullDisplay, updateUpdateMainWindow, updateMainGridStream, } = parameters;
            // If the event type is 'chat', return early
            if (eventType == 'chat') {
                return;
            }
            // Initialize variables
            let host;
            let hostStream;
            let newComponents = [];
            // Check if screen sharing is started or shared
            if (shareScreenStarted || shared) {
                // Handle main grid visibility based on the event type
                if (eventType == 'conference') {
                    if (shared || shareScreenStarted) {
                        if (mainHeightWidth == 0) {
                            // Add the main grid if not present
                            updateMainHeightWidth(84);
                        }
                    }
                    else {
                        // Remove the main grid if not shared or started
                        updateMainHeightWidth(0);
                    }
                }
                // Switch display to optimize for screen share
                screenForceFullDisplay = forceFullDisplay;
                updateScreenForceFullDisplay(screenForceFullDisplay);
                // Get the orientation and adjust forceFullDisplay
                let orientation = checkOrientation();
                if (orientation == 'portrait' || !isWideScreen) {
                    if (shareScreenStarted || shared) {
                        screenForceFullDisplay = false;
                        updateScreenForceFullDisplay(screenForceFullDisplay);
                    }
                }
                // Check if the user is sharing the screen
                if (shared) {
                    // User is sharing
                    host = { name: member, audioID: '', videoID: '' };
                    hostStream = localStreamScreen;
                    // Update admin on the main screen
                    adminOnMainScreen = islevel == '2';
                    updateAdminOnMainScreen(adminOnMainScreen);
                    // Update main screen person
                    mainScreenPerson = host.name || '';
                    updateMainScreenPerson(mainScreenPerson);
                }
                else {
                    //someone else is sharing
                    host =
                        participants.find((participant) => participant.ScreenID == screenId && participant.ScreenOn == true) ?? null;
                    if (whiteboardStarted && !whiteboardEnded) {
                        host = { name: 'WhiteboardActive', islevel: '2', audioID: '', videoID: '' };
                        hostStream = { producerId: 'WhiteboardActive' };
                    }
                    if (host == null) {
                        // remoteScreenStream
                        host =
                            participants.find((participant) => participant.ScreenOn == true) ?? null;
                    }
                    // check remoteScreenStream
                    if (host != null && !host?.name?.includes('WhiteboardActive')) {
                        if (remoteScreenStream.length == 0) {
                            hostStream =
                                allVideoStreams.find((stream) => stream.producerId == host?.ScreenID) ?? null;
                        }
                        else {
                            hostStream = remoteScreenStream[0];
                        }
                    }
                    // Update admin on the main screen
                    adminOnMainScreen = (host && host.islevel == '2') ?? false;
                    updateAdminOnMainScreen(adminOnMainScreen);
                    // Update main screen person
                    mainScreenPerson = host?.name ?? '';
                    updateMainScreenPerson(mainScreenPerson);
                }
            }
            else {
                // Screen share not started
                if (eventType == 'conference') {
                    // No main grid for conferences
                    return;
                }
                // Find the host with level '2'
                host = participants.find((participant) => participant.islevel == '2') ?? null;
                // Update main screen person
                mainScreenPerson = host?.name ?? '';
                updateMainScreenPerson(mainScreenPerson);
            }
            // If host is not null, check if host videoIsOn
            if (host) {
                // Populate the main screen with the host video
                if (shareScreenStarted || shared) {
                    forceFullDisplay = screenForceFullDisplay;
                    if (whiteboardStarted && !whiteboardEnded) {
                        // Whiteboard is active
                    }
                    else {
                        newComponents.push({
                            component: VideoCard,
                            inputs: {
                                videoStream: shared ? hostStream : hostStream.stream,
                                remoteProducerId: host.ScreenID,
                                eventType,
                                forceFullDisplay: annotateScreenStream && shared ? false : forceFullDisplay,
                                customStyle: {
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                                participant: host,
                                backgroundColor: 'rgba(217, 227, 234, 0.99)',
                                showControls: false,
                                showInfo: true,
                                name: host.name,
                                doMirror: false,
                                parameters,
                            },
                        });
                    }
                    updateMainGridStream(newComponents);
                    mainScreenFilled = true;
                    updateMainScreenFilled(mainScreenFilled);
                    adminOnMainScreen = host.islevel == '2';
                    updateAdminOnMainScreen(adminOnMainScreen);
                    mainScreenPerson = host.name ?? '';
                    updateMainScreenPerson(mainScreenPerson);
                    return newComponents;
                }
                // Check if video is already on or not
                if ((islevel != '2' && !host['videoOn']) ||
                    (islevel == '2' && (!host['videoOn'] || !videoAlreadyOn)) ||
                    localUIMode == true) {
                    // Video is off
                    if (islevel == '2' && videoAlreadyOn) {
                        // Admin's video is on
                        newComponents.push({
                            component: VideoCard,
                            inputs: {
                                videoStream: keepBackground && virtualStream ? virtualStream : localStreamVideo,
                                remoteProducerId: host.videoID,
                                eventType,
                                forceFullDisplay,
                                customStyle: {
                                    border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                },
                                participant: host,
                                backgroundColor: 'rgba(217, 227, 234, 0.99)',
                                showControls: false,
                                showInfo: true,
                                name: host.name,
                                doMirror: true,
                                parameters,
                            },
                        });
                        updateMainGridStream(newComponents);
                        mainScreenFilled = true;
                        updateMainScreenFilled(mainScreenFilled);
                        adminOnMainScreen = true;
                        updateAdminOnMainScreen(adminOnMainScreen);
                        mainScreenPerson = host.name ?? '';
                        updateMainScreenPerson(mainScreenPerson);
                    }
                    else {
                        // Video is off and not admin
                        let audOn;
                        if (islevel == '2' && audioAlreadyOn) {
                            audOn = true;
                        }
                        else {
                            if (host != null && islevel != '2') {
                                audOn = host['muted'] == false;
                            }
                        }
                        if (audOn) {
                            // Audio is on
                            try {
                                newComponents.push({
                                    component: AudioCard,
                                    inputs: {
                                        name: host.name,
                                        barColor: 'red',
                                        textColor: 'white',
                                        customStyle: {
                                            backgroundColor: 'transparent',
                                            border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                        },
                                        controlsPosition: 'topLeft',
                                        infoPosition: 'topRight',
                                        showWaveform: true,
                                        roundedImage: true,
                                        parameters: parameters,
                                        showControls: false,
                                        backgroundColor: 'transparent',
                                    },
                                });
                                updateMainGridStream(newComponents);
                            }
                            catch (error) {
                                // Handle audio card creation error
                            }
                            mainScreenFilled = true;
                            updateMainScreenFilled(mainScreenFilled);
                            adminOnMainScreen = islevel == '2';
                            updateAdminOnMainScreen(adminOnMainScreen);
                            mainScreenPerson = host.name ?? '';
                            updateMainScreenPerson(mainScreenPerson);
                        }
                        else {
                            // Audio is off
                            try {
                                newComponents.push({
                                    component: MiniCard,
                                    inputs: {
                                        initials: name,
                                        fontSize: 20,
                                        customStyle: {
                                            backgroundColor: 'transparent',
                                            border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                        },
                                    },
                                });
                                updateMainGridStream(newComponents);
                            }
                            catch (error) {
                                // Handle mini card creation error
                            }
                            mainScreenFilled = false;
                            updateMainScreenFilled(mainScreenFilled);
                            adminOnMainScreen = islevel == '2';
                            updateAdminOnMainScreen(adminOnMainScreen);
                            mainScreenPerson = host.name ?? '';
                            updateMainScreenPerson(mainScreenPerson);
                        }
                    }
                }
                else {
                    // Video is on
                    if (shareScreenStarted || shared) {
                        // Screen share is on
                        if (whiteboardStarted && !whiteboardEnded) {
                            // Whiteboard is active
                        }
                        else {
                            try {
                                newComponents.push({
                                    component: VideoCard,
                                    inputs: {
                                        videoStream: shared ? hostStream : hostStream.stream,
                                        remoteProducerId: host.ScreenID,
                                        eventType,
                                        forceFullDisplay,
                                        customStyle: {
                                            border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                        },
                                        participant: host,
                                        backgroundColor: 'rgba(217, 227, 234, 0.99)',
                                        showControls: false,
                                        showInfo: true,
                                        name: host.name,
                                        doMirror: false,
                                        parameters,
                                    },
                                });
                                updateMainGridStream(newComponents);
                                mainScreenFilled = true;
                                updateMainScreenFilled(mainScreenFilled);
                                adminOnMainScreen = host.islevel == '2';
                                updateAdminOnMainScreen(adminOnMainScreen);
                                mainScreenPerson = host.name ?? '';
                                updateMainScreenPerson(mainScreenPerson);
                            }
                            catch (error) {
                                // Handle video card creation error
                            }
                        }
                    }
                    else {
                        // Screen share is off
                        let streame;
                        if (islevel == '2') {
                            host['stream'] = keepBackground && virtualStream ? virtualStream : localStreamVideo;
                        }
                        else {
                            streame = oldAllStreams.find((streame) => streame.producerId == host.videoID);
                            host['stream'] = streame && streame.stream;
                        }
                        try {
                            if (host['stream']) {
                                newComponents.push({
                                    component: VideoCard,
                                    inputs: {
                                        videoStream: host['stream'],
                                        remoteProducerId: host.videoID,
                                        eventType,
                                        forceFullDisplay,
                                        customStyle: {
                                            border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                        },
                                        participant: host,
                                        backgroundColor: 'rgba(217, 227, 234, 0.99)',
                                        showControls: false,
                                        showInfo: true,
                                        name: host.name,
                                        doMirror: member == host.name,
                                        parameters,
                                    },
                                });
                                updateMainGridStream(newComponents);
                                mainScreenFilled = true;
                                adminOnMainScreen = host.islevel == '2';
                                mainScreenPerson = host.name ?? '';
                            }
                            else {
                                newComponents.push({
                                    component: MiniCard,
                                    inputs: {
                                        initials: name,
                                        fontSize: 20,
                                        customStyle: {
                                            backgroundColor: 'transparent',
                                            border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                                        },
                                    },
                                });
                                updateMainGridStream(newComponents);
                                mainScreenFilled = false;
                                adminOnMainScreen = islevel == '2';
                                mainScreenPerson = host.name ?? '';
                            }
                            updateMainScreenFilled(mainScreenFilled);
                            updateAdminOnMainScreen(adminOnMainScreen);
                            updateMainScreenPerson(mainScreenPerson);
                        }
                        catch (error) {
                            // Handle video card creation error
                        }
                    }
                }
            }
            else {
                // Host is null, add a mini card
                try {
                    newComponents.push({
                        component: MiniCard,
                        inputs: {
                            initials: name,
                            fontSize: 20,
                            customStyle: {
                                backgroundColor: 'transparent',
                                border: eventType !== 'broadcast' ? '2px solid black' : '0px solid black',
                            },
                        },
                    });
                    updateMainGridStream(newComponents);
                    mainScreenFilled = false;
                    adminOnMainScreen = false;
                    mainScreenPerson = '';
                    updateMainScreenFilled(mainScreenFilled);
                    updateAdminOnMainScreen(adminOnMainScreen);
                    updateMainScreenPerson(mainScreenPerson);
                }
                catch (error) {
                    // Handle mini card creation error
                }
            }
            updateMainWindow = false;
            updateUpdateMainWindow(updateMainWindow);
            return newComponents;
        }
        catch (error) {
            // Handle errors during the process of preparing and populating the main screen
            console.log('Error preparing and populating the main screen:', error.message);
            return [];
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PrepopulateUserMedia, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PrepopulateUserMedia, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PrepopulateUserMedia, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Processes consumer transports by pausing and resuming them based on certain conditions.
 *
 * This method checks the state of each consumer transport and determines whether to pause or resume
 * based on the validity of the producer ID in relation to the provided streams.
 * It utilizes a sleep function to introduce a delay before pausing the transports.
 *
 * @param {ProcessConsumerTransportsOptions} options - The options for processing consumer transports.
 * @param {Array<Transport>} options.consumerTransports - The list of consumer transports to process.
 * @param {Array<Stream | Participant>} options.lStreams_ - The list of local streams.
 * @param {ProcessConsumerTransportsParameters} options.parameters - The parameters for processing, including:
 *   - {Array<Stream>} options.parameters.remoteScreenStream - The list of remote screen streams.
 *   - {Array<Stream | Participant>} options.parameters.oldAllStreams - The list of old streams.
 *   - {Array<Stream | Participant>} options.parameters.newLimitedStreams - The list of new limited streams.
 *   - {Function} options.parameters.sleep - A function to pause execution for a specified duration.
 *   - {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 *
 * @returns {Promise<void>} A promise that resolves when the processing is complete.
 *
 * @throws {Error} Will throw an error if there is an issue processing consumer transports.
 *
 * @example
 * ```typescript
 * const options = {
 *   consumerTransports: [],
 *   lStreams_: [],
 *   parameters: {
 *     remoteScreenStream: [],
 *     oldAllStreams: [],
 *     newLimitedStreams: [],
 *     sleep: async ({ ms }) => new Promise(resolve => setTimeout(resolve, ms)),
 *   },
 * };
 *
 * await processConsumerTransports(options);
 * ```
 */
class ProcessConsumerTransports {
    /**
     * Processes consumer transports by pausing and resuming them based on certain conditions.
     *
     * @param {Object} options - The options for processing consumer transports.
     * @param {Array} options.consumerTransports - The list of consumer transports to process.
     * @param {Array} options.lStreams_ - The list of local streams.
     * @param {Object} options.parameters - The parameters object containing various stream arrays and utility functions.
     *
     * @returns {Promise<void>} - A promise that resolves when the processing is complete.
     *
     * @throws {Error} - Throws an error if there is an issue processing consumer transports.
     *
     * The function performs the following steps:
     * 1. Destructures and updates the parameters.
     * 2. Defines a helper function to check if a producerId is valid in given stream arrays.
     * 3. Filters consumer transports to resume based on certain conditions.
     * 4. Filters consumer transports to pause based on certain conditions.
     * 5. Pauses consumer transports after a short delay.
     * 6. Emits `consumer-pause` event for each filtered transport (not audio).
     * 7. Emits `consumer-resume` event for each filtered transport (not audio).
     */
    processConsumerTransports = async ({ consumerTransports, lStreams_, parameters, }) => {
        try {
            // Destructure parameters
            let { getUpdatedAllParams } = parameters;
            parameters = getUpdatedAllParams();
            const { remoteScreenStream, oldAllStreams, newLimitedStreams, 
            // mediasfu functions
            sleep, } = parameters;
            // Function to check if the producerId is valid in the given stream arrays
            const isValidProducerId = (producerId, ...streamArrays) => {
                return (producerId !== null &&
                    producerId !== '' &&
                    streamArrays.some((streamArray) => {
                        return (streamArray.length > 0 &&
                            streamArray.some((stream) => stream?.producerId === producerId));
                    }));
            };
            // Get paused consumer transports that are not audio
            const consumerTransportsToResume = consumerTransports.filter((transport) => isValidProducerId(transport.producerId, lStreams_, remoteScreenStream, oldAllStreams, newLimitedStreams) &&
                transport.consumer?.paused === true &&
                transport.consumer.kind !== 'audio');
            // Get unpaused consumer transports that are not audio
            const consumerTransportsToPause = consumerTransports.filter((transport) => transport.producerId &&
                transport.producerId !== null &&
                transport.producerId !== '' &&
                !lStreams_.some((stream) => stream.producerId === transport.producerId) &&
                transport.consumer &&
                transport.consumer.kind &&
                transport.consumer.paused !== true &&
                transport.consumer.kind !== 'audio' &&
                !remoteScreenStream.some((stream) => stream.producerId === transport.producerId) &&
                !oldAllStreams.some((stream) => stream.producerId === transport.producerId) &&
                !newLimitedStreams.some((stream) => stream.producerId === transport.producerId));
            // Pause consumer transports after a short delay
            await sleep({ ms: 100 });
            // Emit consumer.pause() for each filtered transport (not audio)
            for (const transport of consumerTransportsToPause) {
                transport.consumer.pause();
                transport.socket_.emit('consumer-pause', { serverConsumerId: transport.serverConsumerTransportId }, async () => {
                    // Handle the response if needed
                });
            }
            // Emit consumer.resume() for each filtered transport (not audio)
            for (const transport of consumerTransportsToResume) {
                transport.socket_.emit('consumer-resume', { serverConsumerId: transport.serverConsumerTransportId }, async ({ resumed }) => {
                    if (resumed) {
                        transport.consumer.resume();
                    }
                });
            }
        }
        catch (error) {
            // Handle errors during the process of pausing or resuming consumer transports
            console.log(`Error processing consumer transports: ${error.message}`);
            // throw new Error(`Error processing consumer transports: ${error.message}`);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProcessConsumerTransports, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProcessConsumerTransports, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProcessConsumerTransports, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Processes consumer transports for audio streams by pausing and resuming them based on their current state and the provided streams.
 *
 * This method checks the state of each audio consumer transport and either pauses or resumes it depending on the presence of its producer ID in the provided list of streams.
 * It uses a sleep function to introduce a delay between the pause and resume operations to ensure smooth transitions.
 *
 * @param {ProcessConsumerTransportsAudioOptions} options - The options for processing consumer transports.
 * @param {Array<Transport>} options.consumerTransports - The list of consumer transports to process.
 * @param {Array<(Stream | Participant)>} options.lStreams - The list of local streams to check against.
 * @param {ProcessConsumerTransportsAudioParameters} options.parameters - Additional parameters for processing.
 * @param {Function} options.parameters.sleep - A function to pause execution for a specified duration.
 *
 * @returns {Promise<void>} A promise that resolves when the processing is complete.
 *
 * @throws {Error} Will throw an error if there is an issue processing the consumer transports.
 *
 * @example
 * ```typescript
 * const options = {
 *   consumerTransports: [,
 *   lStreams: [],
 *   parameters: {
 *     sleep: async ({ ms }) => new Promise(resolve => setTimeout(resolve, ms)),
 *   },
 * };
 *
 * await processConsumerTransportsAudio(options);
 * ```
 */
class ProcessConsumerTransportsAudio {
    /**
     * Processes consumer transports for audio streams by pausing and resuming them based on their current state and the provided streams.
     *
     * @param {Object} options - The options for processing consumer transports.
     * @param {Array} options.consumerTransports - The list of consumer transports to process.
     * @param {Array} options.lStreams - The list of local streams to check against.
     * @param {Object} options.parameters - Additional parameters for processing.
     * @param {Function} options.parameters.sleep - A function to pause execution for a specified duration.
     *
     * @returns {Promise<void>} A promise that resolves when the processing is complete.
     *
     * @throws Will throw an error if there is an issue processing the consumer transports.
     */
    processConsumerTransportsAudio = async ({ consumerTransports, lStreams, parameters, }) => {
        try {
            const { sleep } = parameters;
            // Function to check if the producerId is valid
            const isValidProducerId = (producerId, ...streamArrays) => {
                return (producerId !== null &&
                    producerId !== '' &&
                    streamArrays.some((streamArray) => {
                        return (streamArray.length > 0 &&
                            streamArray.some((stream) => stream?.producerId === producerId));
                    }));
            };
            // Get paused consumer transports that are audio
            const consumerTransportsToResume = consumerTransports.filter((transport) => isValidProducerId(transport.producerId, lStreams) &&
                transport.consumer?.paused === true &&
                transport.consumer.kind === 'audio');
            // Get unpaused consumer transports that are audio
            const consumerTransportsToPause = consumerTransports.filter((transport) => transport.producerId &&
                transport.producerId !== null &&
                transport.producerId !== '' &&
                !lStreams.some((stream) => stream.producerId === transport.producerId) &&
                transport.consumer &&
                transport.consumer.kind &&
                transport.consumer.paused !== true &&
                transport.consumer.kind === 'audio');
            await sleep({ ms: 100 });
            // Emit consumer.pause() for each transport to pause
            for (const transport of consumerTransportsToPause) {
                transport.consumer.pause();
                transport.socket_.emit('consumer-pause', { serverConsumerId: transport.serverConsumerTransportId }, async () => {
                    // Do something after the consumer is paused
                });
            }
            // Emit consumer.resume() for each transport to resume
            for (const transport of consumerTransportsToResume) {
                transport.socket_.emit('consumer-resume', { serverConsumerId: transport.serverConsumerTransportId }, async ({ resumed }) => {
                    if (resumed) {
                        transport.consumer.resume();
                    }
                });
            }
        }
        catch (error) {
            console.log(`Error in processConsumerTransportsAudio: ${error.message}`);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProcessConsumerTransportsAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProcessConsumerTransportsAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProcessConsumerTransportsAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Adjusts the layout parameters based on the provided options.
 *
 * This method calculates the layout dimensions and updates the main window size based on the current event type,
 * the number of participants, and whether screen sharing is active. It also manages the state transitions
 * to ensure that the UI reflects the correct configuration based on user interactions.
 *
 * @param {ReadjustOptions} options - The options for readjusting the layout.
 * @param {number} options.n - The number of participants or elements.
 * @param {number} options.state - The current state of the layout.
 * @param {Object} options.parameters - The parameters for the layout adjustment.
 * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 * @param {string} options.parameters.eventType - The type of event (e.g., "broadcast", "chat", "conference").
 * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
 * @param {boolean} options.parameters.shared - Indicates if content is being shared.
 * @param {number} options.parameters.mainHeightWidth - The main height and width value.
 * @param {number} options.parameters.prevMainHeightWidth - The previous main height and width value.
 * @param {string} options.parameters.hostLabel - The label for the host.
 * @param {boolean} options.parameters.first_round - Indicates if it is the first round.
 * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
 * @param {Function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
 * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
 *
 * @returns {Promise<void>} A promise that resolves when the layout adjustment is complete.
 *
 * @throws {Error} Throws an error if there is an issue updating the grid sizes.
 *
 * @example
 * ```typescript
 * const options = {
 *   n: 5,
 *   state: 0,
 *   parameters: {
 *     getUpdatedAllParams: () => updatedParams,
 *     eventType: 'conference',
 *     shareScreenStarted: false,
 *     shared: false,
 *     mainHeightWidth: 100,
 *     prevMainHeightWidth: 100,
 *     hostLabel: 'Host Name',
 *     first_round: false,
 *     lock_screen: false,
 *     updateMainHeightWidth: (value) => { console.log(updated) },
 *     prepopulateUserMedia: async ({ name, parameters }) => {  },
 *   },
 * };
 *
 * await readjust(options);
 * ```
 */
class Readjust {
    /**
     * Adjusts the layout parameters based on the provided options.
     *
     * @param {ReadjustOptions} options - The options for readjusting the layout.
     * @param {number} options.n - The number of participants or elements.
     * @param {number} options.state - The current state of the layout.
     * @param {object} options.parameters - The parameters for the layout adjustment.
     * @param {function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {string} options.parameters.eventType - The type of event (e.g., "broadcast", "chat", "conference").
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
     * @param {boolean} options.parameters.shared - Indicates if content is being shared.
     * @param {number} options.parameters.mainHeightWidth - The main height and width value.
     * @param {number} options.parameters.prevMainHeightWidth - The previous main height and width value.
     * @param {string} options.parameters.hostLabel - The label for the host.
     * @param {boolean} options.parameters.first_round - Indicates if it is the first round.
     * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
     * @param {function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
     * @param {function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @returns {Promise<void>} A promise that resolves when the layout adjustment is complete.
     * @throws {Error} Throws an error if there is an issue updating the grid sizes.
     */
    readjust = async ({ n, state, parameters }) => {
        let { getUpdatedAllParams, prepopulateUserMedia } = parameters;
        parameters = getUpdatedAllParams();
        try {
            // Destructure parameters
            let { eventType, shareScreenStarted, shared, mainHeightWidth, prevMainHeightWidth, hostLabel, first_round, lock_screen, updateMainHeightWidth, } = parameters;
            if (state == 0) {
                prevMainHeightWidth = mainHeightWidth;
            }
            let val1 = 6;
            let val2 = 12 - val1;
            let cal1 = Math.floor((val1 / 12) * 100);
            let cal2 = 100 - cal1;
            if (eventType == 'broadcast') {
                val1 = 0;
                val2 = 12 - val1;
                if (n == 0) {
                    val1 = 0;
                    val2 = 12 - val1;
                }
            }
            else if (eventType == 'chat' ||
                (eventType == 'conference' && !(shareScreenStarted || shared))) {
                val1 = 12;
                val2 = 12 - val1;
            }
            else {
                if (shareScreenStarted || shared) {
                    val2 = 10;
                    val1 = 12 - val2;
                }
                else {
                    if (n == 0) {
                        val1 = 1;
                        val2 = 12 - val1;
                    }
                    else if (n >= 1 && n < 4) {
                        val1 = 4;
                        val2 = 12 - val1;
                    }
                    else if (n >= 4 && n < 6) {
                        val1 = 6;
                        val2 = 12 - val1;
                    }
                    else if (n >= 6 && n < 9) {
                        val1 = 6;
                        val2 = 12 - val1;
                    }
                    else if (n >= 9 && n < 12) {
                        val1 = 6;
                        val2 = 12 - val1;
                    }
                    else if (n >= 12 && n < 20) {
                        val1 = 8;
                        val2 = 12 - val1;
                    }
                    else if (n >= 20 && n < 50) {
                        val1 = 8;
                        val2 = 12 - val1;
                    }
                    else {
                        val1 = 10;
                        val2 = 12 - val1;
                    }
                }
            }
            if (state == 0) {
                mainHeightWidth = val2;
            }
            cal1 = Math.floor((val1 / 12) * 100);
            cal2 = 100 - cal1;
            updateMainHeightWidth(cal2);
            if (prevMainHeightWidth != mainHeightWidth) {
                if (!lock_screen && !shared) {
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                }
                else {
                    if (!first_round) {
                        await prepopulateUserMedia({ name: hostLabel, parameters });
                    }
                }
            }
        }
        catch (error) {
            // Handle errors during the process of updating grid sizes
            console.log('Error updating grid sizes:', error.message);
            // throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Readjust, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Readjust, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Readjust, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Receives all piped transports by emitting an event to the server and processing the response.
 *
 * This method communicates with the server to request piped transports for a specific room and member.
 * It checks if any producers exist and, if so, iterates through different levels to retrieve piped producers.
 *
 * @param {ReceiveAllPipedTransportsOptions} options - The options for receiving all piped transports.
 * @param {Socket} options.nsock - The socket instance used for communication.
 * @param {boolean} options.community - Whether the room is a community edition room.
 * @param {ReceiveAllPipedTransportsParameters} options.parameters - The parameters for the operation.
 * @param {string} options.parameters.roomName - The name of the room.
 * @param {string} options.parameters.member - The member identifier.
 * @param {GetPipedProducersAltType} options.parameters.getPipedProducersAlt - The function to get piped producers for a given level.
 *
 * @returns {Promise<void>} A promise that resolves when the operation is complete.
 *
 * @throws Will log an error message if the operation fails.
 *
 * @example
 * ```typescript
 * const options = {
 *   nsock: socketInstance,
 *   community: true,
 *   parameters: {
 *     roomName: 'Room1',
 *     member: 'Member1',
 *     getPipedProducersAlt: getPipedProducersAltFunction,
 *   },
 * };
 *
 * await receiveAllPipedTransports(options);
 * ```
 */
class ReceiveAllPipedTransports {
    /**
     * Receives all piped transports by emitting an event to the server and processing the response.
     *
     * @param {ReceiveAllPipedTransportsOptions} options - The options for receiving all piped transports.
     * @param {any} options.nsock - The socket instance used for communication.
     * @param {boolean} options.community - Whether the room is a community edition room.
     * @param {Object} options.parameters - The parameters for the operation.
     * @param {string} options.parameters.roomName - The name of the room.
     * @param {string} options.parameters.member - The member identifier.
     * @param {Function} options.parameters.getPipedProducersAlt - The function to get piped producers for a given level.
     *
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     *
     * @throws Will log an error message if the operation fails.
     */
    receiveAllPipedTransports = async ({ nsock, community = false, parameters, }) => {
        try {
            // Destructure parameters
            const { roomName, member, getPipedProducersAlt } = parameters;
            const emitName = community ? "createReceiveAllTransports" : "createReceiveAllTransportsPiped";
            const emitData = community ? { islevel: '0' } : { roomName, member };
            // Emit createReceiveAllTransportsPiped event to the server
            await new Promise((resolve, reject) => {
                nsock.emit(emitName, emitData, async ({ producersExist }) => {
                    try {
                        // Array of options representing different levels
                        const options = ['0', '1', '2'];
                        // If producers exist, loop through each level and get producers
                        if (producersExist) {
                            for (const islevel of options) {
                                await getPipedProducersAlt({ nsock, community, islevel, parameters });
                            }
                        }
                        resolve();
                    }
                    catch (err) {
                        reject(err);
                    }
                });
            });
        }
        catch (error) {
            console.log('receiveAllPipedTransports error', error);
            // throw error;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReceiveAllPipedTransports, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReceiveAllPipedTransports, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReceiveAllPipedTransports, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Reorders the video streams based on the provided options and updates the UI accordingly.
 *
 * This method handles the logic for reordering streams in a video conferencing application,
 * managing the addition and arrangement of streams based on various conditions such as
 * participant roles, screen sharing status, and current streams.
 *
 * @param {ReorderStreamsOptions} options - The options for reordering streams.
 * @param {boolean} [options.add=false] - Whether to add new streams or not.
 * @param {boolean} [options.screenChanged=false] - Whether the screen has changed or not.
 * @param {ReorderStreamsParameters} options.parameters - The parameters required for reordering streams.
 * @param {Array<Stream | Participant>} options.parameters.allVideoStreams - Array of all video streams.
 * @param {Array<Participant>} options.parameters.participants - Array of participants.
 * @param {Array<Stream | Participant>} options.parameters.oldAllStreams - Array of old streams.
 * @param {string} [options.parameters.screenId] - ID of the screen.
 * @param {string} [options.parameters.adminVidID] - ID of the admin video.
 * @param {Array<Stream | Participant>} options.parameters.newLimitedStreams - Array of new limited streams.
 * @param {Array<string>} options.parameters.newLimitedStreamsIDs - Array of new limited stream IDs.
 * @param {Array<string>} options.parameters.activeSounds - Array of active sounds.
 * @param {string} [options.parameters.screenShareIDStream] - ID of the screen share stream.
 * @param {string} [options.parameters.screenShareNameStream] - Name of the screen share stream.
 * @param {string} [options.parameters.adminIDStream] - ID of the admin stream.
 * @param {string} [options.parameters.adminNameStream] - Name of the admin stream.
 * @param {Function} options.parameters.updateNewLimitedStreams - Function to update new limited streams.
 * @param {Function} options.parameters.updateNewLimitedStreamsIDs - Function to update new limited stream IDs.
 * @param {Function} options.parameters.updateActiveSounds - Function to update active sounds.
 * @param {Function} options.parameters.updateScreenShareIDStream - Function to update screen share ID stream.
 * @param {Function} options.parameters.updateScreenShareNameStream - Function to update screen share name stream.
 * @param {Function} options.parameters.updateAdminIDStream - Function to update admin ID stream.
 * @param {Function} options.parameters.updateAdminNameStream - Function to update admin name stream.
 * @param {Function} options.parameters.updateYouYouStream - Function to update YouYou stream.
 * @param {Function} options.parameters.changeVids - Function to reflect changes on the UI.
 *
 * @returns {Promise<void>} A promise that resolves when the reordering is complete.
 *
 * @throws Will throw an error if there is an issue during the reordering process.
 *
 * @example
 * ```typescript
 * await reorderStreams({
 *   add: true,
 *   screenChanged: false,
 *   parameters: {
 *     allVideoStreams: [...],
 *     participants: [...],
 *     oldAllStreams: [...],
 *     newLimitedStreams: [],
 *     newLimitedStreamsIDs: [],
 *     activeSounds: [],
 *     updateNewLimitedStreams: (streams) => { console.log(updated) },
 *     updateNewLimitedStreamsIDs: (ids) => { console.log(updated) },
 *     updateActiveSounds: (sounds) => { console.log(updated) },
 *     changeVids: async (options) => { },
 *     // ...other parameters
 *   },
 * });
 * ```
 */
class ReorderStreams {
    /**
     * Reorders the video streams based on the provided options and updates the UI accordingly.
     *
     * @param {Object} options - The options for reordering streams.
     * @param {boolean} [options.add=false] - Whether to add new streams or not.
     * @param {boolean} [options.screenChanged=false] - Whether the screen has changed or not.
     * @param {ReorderStreamsOptions} options.parameters - The parameters required for reordering streams.
     *
     * @returns {Promise<void>} A promise that resolves when the reordering is complete.
     *
     * @typedef {Object} ReorderStreamsOptions
     * @property {Function} getUpdatedAllParams - Function to get updated parameters.
     * @property {Array} allVideoStreams - Array of all video streams.
     * @property {Array} participants - Array of participants.
     * @property {Array} oldAllStreams - Array of old streams.
     * @property {string} screenId - ID of the screen.
     * @property {string} adminVidID - ID of the admin video.
     * @property {Array} newLimitedStreams - Array of new limited streams.
     * @property {Array} newLimitedStreamsIDs - Array of new limited stream IDs.
     * @property {Array} activeSounds - Array of active sounds.
     * @property {string} screenShareIDStream - ID of the screen share stream.
     * @property {string} screenShareNameStream - Name of the screen share stream.
     * @property {string} adminIDStream - ID of the admin stream.
     * @property {string} adminNameStream - Name of the admin stream.
     * @property {Function} updateNewLimitedStreams - Function to update new limited streams.
     * @property {Function} updateNewLimitedStreamsIDs - Function to update new limited stream IDs.
     * @property {Function} updateActiveSounds - Function to update active sounds.
     * @property {Function} updateScreenShareIDStream - Function to update screen share ID stream.
     * @property {Function} updateScreenShareNameStream - Function to update screen share name stream.
     * @property {Function} updateAdminIDStream - Function to update admin ID stream.
     * @property {Function} updateAdminNameStream - Function to update admin name stream.
     * @property {Function} updateYouYouStream - Function to update YouYou stream.
     * @property {Function} changeVids - Function to reflect changes on the UI.
     */
    reorderStreams = async ({ add = false, screenChanged = false, parameters, }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { allVideoStreams, participants, oldAllStreams, screenId, adminVidID, newLimitedStreams, newLimitedStreamsIDs, activeSounds, screenShareIDStream, screenShareNameStream, adminIDStream, adminNameStream, updateNewLimitedStreams, updateNewLimitedStreamsIDs, updateActiveSounds, updateScreenShareIDStream, updateScreenShareNameStream, updateAdminIDStream, updateAdminNameStream, updateYouYouStream, 
        //mediasfu functions
        changeVids, } = parameters;
        // function to reorder streams on the ui
        if (!add) {
            newLimitedStreams = [];
            newLimitedStreamsIDs = [];
            activeSounds = [];
        }
        const youyou = allVideoStreams.filter((stream) => stream.producerId === 'youyou');
        const admin = participants.filter((participant) => participant.islevel === '2');
        if (admin.length > 0) {
            adminVidID = admin[0].videoID;
        }
        else {
            adminVidID = '';
        }
        if (adminVidID) {
            const adminStream = allVideoStreams.find((stream) => stream.producerId === adminVidID);
            if (!add) {
                newLimitedStreams = [...newLimitedStreams, ...youyou];
                newLimitedStreamsIDs = [
                    ...newLimitedStreamsIDs,
                    ...youyou.map((stream) => stream.producerId),
                ];
            }
            else {
                const youyouStream = newLimitedStreams.find((stream) => stream.producerId === 'youyou');
                if (!youyouStream) {
                    newLimitedStreams = [...newLimitedStreams, ...youyou];
                    newLimitedStreamsIDs = [
                        ...newLimitedStreamsIDs,
                        ...youyou.map((stream) => stream.producerId),
                    ];
                }
            }
            if (adminStream) {
                adminIDStream = adminVidID;
                if (!add) {
                    newLimitedStreams = [...newLimitedStreams, adminStream];
                    newLimitedStreamsIDs = [...newLimitedStreamsIDs, adminStream.producerId];
                }
                else {
                    const adminStreamer = newLimitedStreams.find((stream) => stream.producerId === adminVidID);
                    if (!adminStreamer) {
                        newLimitedStreams = [...newLimitedStreams, adminStream];
                        newLimitedStreamsIDs = [...newLimitedStreamsIDs, adminStream.producerId];
                    }
                }
            }
            else {
                const oldAdminStream = oldAllStreams.find((stream) => stream.producerId === adminVidID);
                if (oldAdminStream) {
                    //add it to the allVideoStream
                    adminIDStream = adminVidID;
                    adminNameStream = admin[0].name;
                    if (!add) {
                        newLimitedStreams = [...newLimitedStreams, oldAdminStream];
                        newLimitedStreamsIDs = [...newLimitedStreamsIDs, oldAdminStream.producerId];
                    }
                    else {
                        const adminStreamer = newLimitedStreams.find((stream) => stream.producerId === adminVidID);
                        if (!adminStreamer) {
                            newLimitedStreams = [...newLimitedStreams, oldAdminStream];
                            newLimitedStreamsIDs = [...newLimitedStreamsIDs, oldAdminStream.producerId];
                        }
                    }
                }
            }
            const screenParticipant = participants.filter((participant) => participant.ScreenID === screenId);
            if (screenParticipant.length > 0) {
                const screenParticipantVidID = screenParticipant[0].videoID;
                const screenParticipantVidID_ = newLimitedStreams.filter((stream) => stream.producerId === screenParticipantVidID);
                if (screenParticipantVidID_?.length < 1 && screenParticipantVidID) {
                    screenShareIDStream = screenParticipantVidID;
                    screenShareNameStream = screenParticipant[0].name;
                    const screenParticipantVidID__ = allVideoStreams.filter((stream) => stream.producerId === screenParticipantVidID);
                    newLimitedStreams = [...newLimitedStreams, ...screenParticipantVidID__];
                    newLimitedStreamsIDs = [
                        ...newLimitedStreamsIDs,
                        ...screenParticipantVidID__.map((stream) => stream.producerId),
                    ];
                }
            }
        }
        else {
            if (!add) {
                newLimitedStreams = [...newLimitedStreams, ...youyou];
                newLimitedStreamsIDs = [
                    ...newLimitedStreamsIDs,
                    ...youyou.map((stream) => stream.producerId),
                ];
            }
            else {
                const youyouStream = newLimitedStreams.find((stream) => stream.producerId === 'youyou');
                if (!youyouStream) {
                    newLimitedStreams = [...newLimitedStreams, ...youyou];
                    newLimitedStreamsIDs = [
                        ...newLimitedStreamsIDs,
                        ...youyou.map((stream) => stream.producerId),
                    ];
                }
            }
            const screenParticipant = participants.filter((participant) => participant.ScreenID === screenId);
            if (screenParticipant.length > 0) {
                const screenParticipantVidID = screenParticipant[0].videoID;
                const screenParticipantVidID_ = newLimitedStreams.filter((stream) => stream.producerId === screenParticipantVidID);
                if (screenParticipantVidID_?.length < 1 && screenParticipantVidID) {
                    screenShareIDStream = screenParticipantVidID;
                    screenShareNameStream = screenParticipant[0].name;
                    const screenParticipantVidID__ = allVideoStreams.filter((stream) => stream.producerId === screenParticipantVidID);
                    newLimitedStreams = [...newLimitedStreams, ...screenParticipantVidID__];
                    newLimitedStreamsIDs = [
                        ...newLimitedStreamsIDs,
                        ...screenParticipantVidID__.map((stream) => stream.producerId),
                    ];
                }
            }
        }
        updateNewLimitedStreams(newLimitedStreams);
        updateNewLimitedStreamsIDs(newLimitedStreamsIDs);
        updateActiveSounds(activeSounds);
        updateScreenShareIDStream(screenShareIDStream);
        updateScreenShareNameStream(screenShareNameStream);
        updateAdminIDStream(adminIDStream);
        updateAdminNameStream(adminNameStream);
        updateYouYouStream(youyou);
        //reflect the changes on the ui
        await changeVids({ screenChanged, parameters });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReorderStreams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReorderStreams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReorderStreams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * RePort function that handles the reporting logic based on the provided parameters.
 *
 * This method checks the current state of the recording process and updates the screen states
 * accordingly. It also compares active names and screen states based on the provided parameters.
 *
 * @param {RePortOptions} options - The options for the rePort function.
 * @param {boolean} [options.restart=false] - Flag indicating whether to restart the process.
 * @param {RePortParameters} options.parameters - The parameters object containing various states and functions.
 * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 * @param {string} options.parameters.islevel - The current level of the process.
 * @param {string} options.parameters.mainScreenPerson - The person on the main screen.
 * @param {boolean} options.parameters.adminOnMainScreen - Flag indicating if admin is on the main screen.
 * @param {boolean} options.parameters.mainScreenFilled - Flag indicating if the main screen is filled.
 * @param {boolean} options.parameters.recordStarted - Flag indicating if recording has started.
 * @param {boolean} options.parameters.recordStopped - Flag indicating if recording has stopped.
 * @param {boolean} options.parameters.recordPaused - Flag indicating if recording is paused.
 * @param {boolean} options.parameters.recordResumed - Flag indicating if recording has resumed.
 * @param {Array<ScreenState>} options.parameters.screenStates - Array of current screen states.
 * @param {Function} options.parameters.updateScreenStates - Function to update the current screen states.
 * @param {Function} options.parameters.updatePrevScreenStates - Function to update the previous screen states.
 * @param {Function} options.parameters.compareActiveNames - Function to compare active names.
 * @param {Function} options.parameters.compareScreenStates - Function to compare screen states.
 *
 * @returns {Promise<void>} A promise that resolves when the reporting process is complete.
 *
 * @throws {Error} Throws an error if there is an issue during the reporting process.
 *
 * @example
 * ```typescript
 * const options = {
 *   restart: false,
 *   parameters: {
 *     islevel: '1',
 *     mainScreenPerson: 'John Doe',
 *     adminOnMainScreen: false,
 *     mainScreenFilled: true,
 *     recordStarted: true,
 *     screenStates: [],
 *     updateScreenStates: (states) => { console.log(updated) },
 *     compareActiveNames: async (opts) => {  },
 *     compareScreenStates: async (opts) => {  },
 *   },
 * };
 *
 * await rePort(options);
 * ```
 */
class RePort {
    /**
     * RePort function that handles the reporting logic based on the provided parameters.
     *
     * @param {RePortOptions} options - The options for the rePort function.
     * @param {boolean} [options.restart=false] - Flag indicating whether to restart the process.
     * @param {Object} options.parameters - The parameters object containing various states and functions.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {string} options.parameters.islevel - The current level of the process.
     * @param {string} options.parameters.mainScreenPerson - The person on the main screen.
     * @param {boolean} options.parameters.adminOnMainScreen - Flag indicating if admin is on the main screen.
     * @param {boolean} options.parameters.mainScreenFilled - Flag indicating if the main screen is filled.
     * @param {boolean} options.parameters.recordStarted - Flag indicating if recording has started.
     * @param {boolean} options.parameters.recordStopped - Flag indicating if recording has stopped.
     * @param {boolean} options.parameters.recordPaused - Flag indicating if recording is paused.
     * @param {boolean} options.parameters.recordResumed - Flag indicating if recording has resumed.
     * @param {Array} options.parameters.screenStates - Array of current screen states.
     * @param {Function} options.parameters.updateScreenStates - Function to update the current screen states.
     * @param {Function} options.parameters.updatePrevScreenStates - Function to update the previous screen states.
     * @param {Function} options.parameters.compareActiveNames - Function to compare active names.
     * @param {Function} options.parameters.compareScreenStates - Function to compare screen states.
     *
     * @returns {Promise<void>} A promise that resolves when the reporting process is complete.
     *
     * @throws {Error} Throws an error if there is an issue during the reporting process.
     */
    async rePort({ restart = false, parameters }) {
        const { getUpdatedAllParams } = parameters;
        const updatedParams = getUpdatedAllParams();
        const { islevel, mainScreenPerson, adminOnMainScreen, mainScreenFilled, recordStarted, recordStopped, recordPaused, recordResumed, screenStates, updateScreenStates, updatePrevScreenStates, compareActiveNames, compareScreenStates, } = updatedParams;
        try {
            if (recordStarted || recordResumed) {
                if (recordStopped || recordPaused) {
                    // Recording stopped or paused, do nothing
                }
                else {
                    if (islevel === '2') {
                        const prevScreenStatesCopy = [...screenStates];
                        updatePrevScreenStates(prevScreenStatesCopy);
                        const newScreenStates = [{ mainScreenPerson, adminOnMainScreen, mainScreenFilled }];
                        updateScreenStates(newScreenStates);
                        await compareActiveNames({ restart, parameters: updatedParams });
                        if (!restart) {
                            await compareScreenStates({ restart, parameters: updatedParams });
                        }
                    }
                }
            }
        }
        catch (error) {
            // Handle errors during the process of rePorting
            console.error('Error during rePorting: ', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RePort, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RePort, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RePort, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Requests to start screen sharing.
 *
 * This method initiates a screen sharing request and handles the response
 * from the server to determine if screen sharing is allowed. It also configures
 * the target resolution for the screen share based on the user's input and
 * parameters.
 *
 * @param {RequestScreenShareOptions} options - The options for requesting screen share.
 * @param {Object} options.parameters - The parameters for the screen share request.
 * @param {Socket} options.parameters.socket - The socket instance to communicate with the server.
 * @param {Function} [options.parameters.showAlert] - Optional function to show alerts to the user.
 * @param {boolean} options.parameters.localUIMode - Indicates if the user is in local UI mode.
 * @param {string} [options.parameters.targetResolution] - The target resolution for screen sharing.
 * @param {string} [options.parameters.targetResolutionHost] - The target resolution for the host screen.
 * @param {Function} options.parameters.startShareScreen - Function to start screen sharing.
 *
 * @returns {Promise<void>} A promise that resolves when the screen share request is processed.
 *
 * @throws {Error} Throws an error if there is an issue during the screen share request process.
 *
 * @example
 * ```typescript
 * await requestScreenShare({
 *   parameters: {
 *     socket: mySocket,
 *     localUIMode: false,
 *     targetResolution: 'fhd',
 *     startShareScreen: myStartShareScreenFunction,
 *     showAlert: myShowAlertFunction,
 *   },
 * });
 * ```
 */
class RequestScreenShare {
    /**
     * Requests to start screen sharing.
     *
     * @param {RequestScreenShareOptions} options - The options for requesting screen share.
     * @param {Object} options.parameters - The parameters for the screen share request.
     * @param {Socket} options.parameters.socket - The socket instance to communicate with the server.
     * @param {Function} [options.parameters.showAlert] - Optional function to show alerts to the user.
     * @param {boolean} options.parameters.localUIMode - Indicates if the user is in local UI mode.
     * @param {string} [options.parameters.targetResolution] - The target resolution for screen sharing.
     * @param {string} [options.parameters.targetResolutionHost] - The target resolution for the host screen.
     * @param {Function} options.parameters.startShareScreen - Function to start screen sharing.
     *
     * @returns {Promise<void>} A promise that resolves when the screen share request is processed.
     *
     * @throws {Error} Throws an error if there is an issue during the screen share request process.
     */
    requestScreenShare = async ({ parameters }) => {
        try {
            // Destructure parameters
            const { showAlert, localUIMode, startShareScreen, socket, targetResolution = 'hd', targetResolutionHost = 'hd', } = parameters;
            // Check if the user is in local UI mode
            if (localUIMode === true) {
                await startShareScreen({ parameters });
                return;
            }
            let targetWidth = 1280;
            let targetHeight = 720;
            if (targetResolution == 'qhd' || targetResolutionHost == 'qhd') {
                targetWidth = 2560;
                targetHeight = 1440;
            }
            else if (targetResolution == 'fhd' || targetResolutionHost == 'fhd') {
                targetWidth = 1920;
                targetHeight = 1080;
            }
            socket.emit('requestScreenShare', async ({ allowScreenShare }) => {
                if (!allowScreenShare) {
                    // Send an alert to the user
                    showAlert?.({
                        message: 'You are not allowed to share screen',
                        type: 'danger',
                        duration: 3000,
                    });
                }
                else {
                    await startShareScreen({ parameters: { ...parameters, targetWidth, targetHeight } });
                }
            });
        }
        catch (error) {
            // Handle errors during the process of requesting screen share
            console.error('Error during requesting screen share: ', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RequestScreenShare, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RequestScreenShare, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RequestScreenShare, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Resumes or pauses audio streams based on the provided options.
 *
 * This method checks the current state of participants in breakout rooms and
 * updates the audio streams accordingly. It can add or remove audio streams
 * based on the participant's current status (in a breakout room or not)
 * and the event type (e.g., conference, webinar).
 *
 * @param {ResumePauseAudioStreamsOptions} options - The options for resuming or pausing audio streams.
 * @param {number} [options.breakRoom=-1] - The ID of the break room. Defaults to -1 if not specified.
 * @param {boolean} [options.inBreakRoom=false] - Indicates if the participant is in a break room. Defaults to false.
 * @param {ResumePauseAudioStreamsParameters} options.parameters - The parameters required for processing audio streams.
 * @param {Array<BreakoutParticipant[]>} options.parameters.breakoutRooms - Array of breakout rooms.
 * @param {Array<Participant>} options.parameters.ref_participants - Array of reference participants.
 * @param {Array<Stream | Participant>} options.parameters.allAudioStreams - Array of all audio streams.
 * @param {Array<Participant>} options.parameters.participants - Array of participants.
 * @param {string} options.parameters.islevel - The level of the participant.
 * @param {EventType} options.parameters.eventType - The type of event (e.g., conference, webinar).
 * @param {Array<Transport>} options.parameters.consumerTransports - Array of consumer transports.
 * @param {Array<BreakoutParticipant>} options.parameters.limitedBreakRoom - Array of participants in the limited break room.
 * @param {number} options.parameters.hostNewRoom - The ID of the host's new room.
 * @param {string} options.parameters.member - The name of the member.
 * @param {Function} options.parameters.updateLimitedBreakRoom - Function to update the limited break room.
 * @param {Function} options.parameters.processConsumerTransportsAudio - Function to process audio transports.
 *
 * @returns {Promise<void>} A promise that resolves when the audio streams have been processed.
 *
 * @throws Will log an error message if there is an issue processing the audio streams.
 *
 * @example
 * ```typescript
 * await resumePauseAudioStreams({
 *   breakRoom: 1,
 *   inBreakRoom: true,
 *   parameters: {
 *     breakoutRooms: [],
 *     ref_participants: [],
 *     allAudioStreams: [],
 *     participants: [],
 *     islevel: '1',
 *     eventType: 'conference',
 *     consumerTransports: [],
 *     limitedBreakRoom: [],
 *     hostNewRoom: 2,
 *     member: 'JohnDoe',
 *     updateLimitedBreakRoom: myUpdateFunction,
 *     processConsumerTransportsAudio: myProcessFunction,
 *   },
 * });
 * ```
 */
class ResumePauseAudioStreams {
    /**
     * Resumes or pauses audio streams based on the provided options.
     *
     * @param {ResumePauseAudioStreamsOptions} options - The options for resuming or pausing audio streams.
     * @param {number} [options.breakRoom=-1] - The ID of the break room.
     * @param {boolean} [options.inBreakRoom=false] - Indicates if the participant is in a break room.
     * @param {Parameters} options.parameters - The parameters required for processing audio streams.
     *
     * @returns {Promise<void>} A promise that resolves when the audio streams have been processed.
     *
     * @throws Will log an error message if there is an issue processing the audio streams.
     */
    resumePauseAudioStreams = async ({ breakRoom = -1, inBreakRoom = false, parameters, }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { breakoutRooms, ref_participants, allAudioStreams, participants, islevel, eventType, consumerTransports, hostNewRoom, member, updateLimitedBreakRoom, processConsumerTransportsAudio, } = parameters;
        let room = [];
        let currentStreams = [];
        // Determine the room based on breakout status
        if (inBreakRoom && breakRoom !== -1) {
            room = breakoutRooms[breakRoom];
        }
        else {
            room = ref_participants.filter((participant) => !breakoutRooms
                .flat()
                .map((obj) => obj.name)
                .includes(participant.name));
        }
        updateLimitedBreakRoom(room);
        try {
            let addHostAudio = false;
            if (islevel !== '2' && eventType === 'conference') {
                const roomMember = breakoutRooms.find((r) => r.find((p) => p.name === member));
                let memberBreakRoom = -1;
                if (roomMember) {
                    memberBreakRoom = breakoutRooms.indexOf(roomMember);
                }
                if ((inBreakRoom && breakRoom !== hostNewRoom) ||
                    (!inBreakRoom && hostNewRoom !== -1 && hostNewRoom !== memberBreakRoom)) {
                    const host = participants.find((obj) => obj.islevel === '2');
                    // Remove the host from the room
                    room = room.filter((participant) => participant.name !== host?.name);
                }
                else {
                    if ((inBreakRoom && breakRoom === hostNewRoom) ||
                        (!inBreakRoom && hostNewRoom === -1) ||
                        (!inBreakRoom && hostNewRoom === memberBreakRoom && memberBreakRoom !== -1)) {
                        addHostAudio = true;
                    }
                }
            }
            for (let participant of room) {
                let streams = allAudioStreams.filter((stream) => {
                    if ((Object.prototype.hasOwnProperty.call(stream, 'producerId') && stream.producerId) ||
                        (Object.prototype.hasOwnProperty.call(stream, 'audioID') && stream.audioID)) {
                        let producerId = stream.producerId || stream.audioID;
                        let matchingParticipant = ref_participants.find((obj) => obj.audioID == producerId);
                        return matchingParticipant && matchingParticipant.name == participant.name;
                    }
                    // Return false if the stream doesn't meet the criteria
                    return false;
                });
                currentStreams.push(...streams);
            }
            // If webinar, add the host audio stream if it is not in the currentStreams
            if (islevel !== '2' && (eventType === 'webinar' || addHostAudio)) {
                const host = participants.find((obj) => obj.islevel === '2');
                const hostStream = allAudioStreams.find((obj) => obj.producerId === host?.audioID);
                if (hostStream && !currentStreams.includes(hostStream)) {
                    currentStreams.push(hostStream);
                    if (host?.name && !room.map((obj) => obj.name).includes(host.name)) {
                        room.push({ name: host?.name || '', breakRoom: -1 });
                    }
                    updateLimitedBreakRoom(room);
                }
            }
            await processConsumerTransportsAudio({
                consumerTransports,
                lStreams: currentStreams,
                parameters,
            });
        }
        catch (error) {
            console.log('Error in resumePauseAudioStreams:', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ResumePauseAudioStreams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ResumePauseAudioStreams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ResumePauseAudioStreams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Resumes or pauses streams based on the provided parameters.
 *
 * This method processes the current participant states and the active display names to determine
 * which audio and video streams should be resumed or paused. It communicates with the server
 * to resume streams as necessary.
 *
 * @param {ResumePauseStreamsOptions} options - The options for resuming or pausing streams.
 * @param {Object} options.parameters - The parameters for the function.
 * @param {Array<Participant>} options.parameters.participants - The list of participants in the session.
 * @param {Array<string>} options.parameters.dispActiveNames - The list of active display names.
 * @param {Array<Transport>} options.parameters.consumerTransports - The list of consumer transports.
 * @param {string} [options.parameters.screenId] - The screen producer ID if applicable.
 * @param {string} options.parameters.islevel - The level of the user (e.g., participant or host).
 *
 * @returns {Promise<void>} A promise that resolves when the streams have been resumed or paused.
 *
 * @throws Will throw an error if there is an issue during the process of resuming or pausing streams.
 *
 * @example
 * ```typescript
 * await resumePauseStreams({
 *   parameters: {
 *     participants: [...], // Array of participants
 *     dispActiveNames: ['Alice', 'Bob'], // Active display names
 *     consumerTransports: [...], // Array of consumer transports
 *     screenId: 'screen123', // Screen producer ID
 *     islevel: '1', // User level
 *     getUpdatedAllParams: myGetUpdatedFunction, // Function to get updated params
 *   },
 * });
 * ```
 */
class ResumePauseStreams {
    /**
     * Resumes or pauses streams based on the provided parameters.
     *
     * @param {ResumePauseStreamsOptions} options - The options for resuming or pausing streams.
     * @param {Object} options.parameters - The parameters for the function.
     * @param {Array} options.parameters.participants - The list of participants.
     * @param {Array} options.parameters.dispActiveNames - The list of active display names.
     * @param {Array} options.parameters.consumerTransports - The list of consumer transports.
     * @param {string} options.parameters.screenId - The screen producer ID.
     * @param {string} options.parameters.islevel - The level of the user.
     *
     * @returns {Promise<void>} A promise that resolves when the streams have been resumed or paused.
     *
     * @throws Will throw an error if there is an issue during the process of resuming or pausing streams.
     */
    resumePauseStreams = async ({ parameters }) => {
        try {
            // Destructure parameters
            parameters = parameters.getUpdatedAllParams();
            let { participants, dispActiveNames, consumerTransports, screenId, islevel } = parameters;
            // Get the videoID of the host (islevel=2)
            let host = participants.find((obj) => obj.islevel === '2');
            let hostVideoID = host ? host.videoID : null;
            // Get videoIDs of participants in dispActiveNames and screenproducerId
            let videosIDs = dispActiveNames.map((name) => {
                let participant = participants.find((obj) => obj.name === name);
                return participant ? participant.videoID : null;
            });
            // Add screenproducerId to allVideoIDs if it's not null or empty
            if (screenId) {
                videosIDs.push(screenId);
            }
            // Add hostVideoID to allVideoIDs if it's not null or empty (only if the user is not the host)
            if (islevel !== '2' && hostVideoID) {
                videosIDs.push(hostVideoID);
            }
            // Remove null or empty videoIDs
            let allVideoIDs = videosIDs.filter((videoID) => videoID !== null && videoID !== '');
            if (allVideoIDs.length > 0) {
                // Get consumer transports with producerId in allVideoIDs
                const consumerTransportsToResume = consumerTransports.filter((transport) => allVideoIDs.includes(transport.producerId) && transport.consumer.kind !== 'audio');
                // Resume all consumerTransportsToResume
                for (const transport of consumerTransportsToResume) {
                    transport.socket_.emit('consumer-resume', { serverConsumerId: transport.serverConsumerTransportId }, async ({ resumed }) => {
                        if (resumed) {
                            transport.consumer.resume();
                        }
                    });
                }
            }
        }
        catch (error) {
            console.log('Error during resuming or pausing streams: ', error);
            // Handle errors during the process of resuming or pausing streams
            // throw new Error(`Error during resuming or pausing streams: ${error.message}`);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ResumePauseStreams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ResumePauseStreams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ResumePauseStreams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Resumes the send transport for audio and updates the UI and audio producer state accordingly.
 *
 * This function supports both a primary and a local audio producer, delegating the local logic to a separate function.
 *
 * @param {ResumeSendTransportAudioOptions} options - The options for resuming the send transport.
 * @param {ResumeSendTransportAudioParameters} options.parameters - The parameters for resuming the send transport.
 * @param {Producer} options.parameters.audioProducer - The primary audio producer to resume.
 * @param {Producer} [options.parameters.localAudioProducer] - The local audio producer to resume.
 * @param {string} options.parameters.islevel - The level of the audio producer.
 * @param {string} options.parameters.hostLabel - The label for the host.
 * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
 * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
 * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already on.
 * @param {Function} options.parameters.updateAudioProducer - Function to update the audio producer state.
 * @param {Function} [options.parameters.updateLocalAudioProducer] - Function to update the local audio producer state.
 * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
 * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
 * @returns {Promise<void>} A promise that resolves when the send transport is resumed and the UI is updated.
 *
 * @throws {Error} Throws an error if there is an issue during the process of resuming the audio send transport.
 *
 * @example
 * ```typescript
 * await resumeSendTransportAudio({
 *   parameters: {
 *     audioProducer: producer,
 *     localAudioProducer: localProducer,
 *     islevel: '1',
 *     hostLabel: 'Host',
 *     lock_screen: false,
 *     shared: false,
 *     updateAudioProducer: updateProducerFunction,
 *     updateLocalAudioProducer: updateLocalProducerFunction,
 *     videoAlreadyOn: false,
 *     updateUpdateMainWindow: updateWindowFunction,
 *     prepopulateUserMedia: prepopulateFunction,
 *     prepopulateLocalUserMedia: prepopulateLocalFunction,
 *   },
 * });
 * ```
 */
class ResumeSendTransportAudio {
    async resumeLocalSendTransportAudio({ parameters, }) {
        try {
            const { localAudioProducer, updateLocalAudioProducer, } = parameters;
            // Resume local audio producer
            if (localAudioProducer) {
                localAudioProducer.resume();
                updateLocalAudioProducer?.(localAudioProducer);
            }
        }
        catch (error) {
            console.error("Error resuming local audio send transport:", error);
            throw error; // Re-throw to propagate the error
        }
    }
    ;
    /**
     * Resumes the send transport for audio and updates the UI and audio producer state accordingly.
     *
     * This function supports both a primary and a local audio producer, delegating the local logic to a separate function.
     *
     * @param {ResumeSendTransportAudioOptions} options - The options for resuming the send transport.
     * @param {ResumeSendTransportAudioParameters} options.parameters - The parameters for resuming the send transport.
     * @param {Producer} options.parameters.audioProducer - The primary audio producer to resume.
     * @param {Producer} [options.parameters.localAudioProducer] - The local audio producer to resume.
     * @param {string} options.parameters.islevel - The level of the audio producer.
     * @param {string} options.parameters.hostLabel - The label for the host.
     * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
     * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
     * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already on.
     * @param {Function} options.parameters.updateAudioProducer - Function to update the audio producer state.
     * @param {Function} [options.parameters.updateLocalAudioProducer] - Function to update the local audio producer state.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @returns {Promise<void>} A promise that resolves when the send transport is resumed and the UI is updated.
     *
     * @throws {Error} Throws an error if there is an issue during the process of resuming the audio send transport.
     *
     * @example
     * ```typescript
     * await resumeSendTransportAudio({
     *   parameters: {
     *     audioProducer: producer,
     *     localAudioProducer: localProducer,
     *     islevel: '1',
     *     hostLabel: 'Host',
     *     lock_screen: false,
     *     shared: false,
     *     updateAudioProducer: updateProducerFunction,
     *     updateLocalAudioProducer: updateLocalProducerFunction,
     *     videoAlreadyOn: false,
     *     updateUpdateMainWindow: updateWindowFunction,
     *     prepopulateUserMedia: prepopulateFunction,
     *     prepopulateLocalUserMedia: prepopulateLocalFunction,
     *   },
     * });
     * ```
     */
    async resumeSendTransportAudio({ parameters }) {
        try {
            let { audioProducer, islevel, updateMainWindow, hostLabel, lock_screen, shared, updateAudioProducer, videoAlreadyOn, updateUpdateMainWindow, prepopulateUserMedia, } = parameters;
            // Resume send transport for audio
            audioProducer?.resume();
            // Update the UI
            if (!videoAlreadyOn && islevel === '2') {
                if (!lock_screen && !shared) {
                    updateMainWindow = true;
                    updateUpdateMainWindow(updateMainWindow);
                    await prepopulateUserMedia({ name: hostLabel, parameters });
                    updateMainWindow = false;
                    updateUpdateMainWindow(updateMainWindow);
                }
            }
            // Update audio producer state
            updateAudioProducer(audioProducer);
            // Attempt to handle local audio producer if primary fails
            try {
                await this.resumeLocalSendTransportAudio({ parameters });
            }
            catch (localError) {
                console.error("local audio send transport resuming failed:", localError);
            }
        }
        catch (error) {
            // Handle errors during the process of resuming the audio send transport
            throw new Error(`Error during resuming audio send transport: ${error.message}`);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ResumeSendTransportAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ResumeSendTransportAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ResumeSendTransportAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Updates the interaction state based on the provided options and parameters.
 *
 * This method handles the updating of participant interactions based on the event type, screen sharing status,
 * and various other parameters. It manages the addition and removal of streams in the context of screen sharing
 * and video/audio management.
 *
 * @param {ReUpdateInterOptions} options - The options for updating the interaction.
 * @param {string} options.name - The name of the participant.
 * @param {boolean} [options.add=false] - Whether to add the participant to the interaction.
 * @param {boolean} [options.force=false] - Whether to force the update.
 * @param {number} [options.average=127] - The average value used for determining reorder intervals.
 * @param {ReUpdateInterParameters} options.parameters - The parameters for updating the interaction.
 * @param {number} options.parameters.screenPageLimit - The screen page limit.
 * @param {number} options.parameters.itemPageLimit - The item page limit.
 * @param {number} options.parameters.reorderInterval - The reorder interval.
 * @param {number} options.parameters.fastReorderInterval - The fast reorder interval.
 * @param {string} options.parameters.eventType - The type of event (e.g., "broadcast", "chat", "conference").
 * @param {Array<Participant>} options.parameters.participants - The list of participants.
 * @param {Array<Stream | Participant>} options.parameters.allVideoStreams - The list of all video streams.
 * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
 * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
 * @param {string} options.parameters.adminNameStream - The admin name stream.
 * @param {string} options.parameters.screenShareNameStream - The screen share name stream.
 * @param {boolean} options.parameters.updateMainWindow - Whether to update the main window.
 * @param {boolean} options.parameters.sortAudioLoudness - Whether to sort audio by loudness.
 * @param {number} options.parameters.lastReorderTime - The last reorder time.
 * @param {Array<Stream | Participant>} options.parameters.newLimitedStreams - The list of new limited streams.
 * @param {Array<string>} options.parameters.newLimitedStreamsIDs - The list of new limited stream IDs.
 * @param {Array<string>} options.parameters.oldSoundIds - The list of old sound IDs.
 * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
 * @param {Function} options.parameters.updateSortAudioLoudness - Function to update the audio loudness sorting.
 * @param {Function} options.parameters.updateLastReorderTime - Function to update the last reorder time.
 * @param {Function} options.parameters.updateNewLimitedStreams - Function to update the new limited streams.
 * @param {Function} options.parameters.updateNewLimitedStreamsIDs - Function to update the new limited stream IDs.
 * @param {Function} options.parameters.updateOldSoundIds - Function to update the old sound IDs.
 * @param {Function} options.parameters.onScreenChanges - Function to handle screen changes.
 * @param {Function} options.parameters.reorderStreams - Function to reorder streams.
 * @param {Function} options.parameters.changeVids - Function to change videos.
 *
 * @returns {Promise<void>} A promise that resolves when the interaction update is complete.
 *
 * @throws {Error} Throws an error if there is an issue during the interaction update.
 *
 * @example
 * ```typescript
 * const options = {
 *   name: 'John Doe',
 *   add: true,
 *   parameters: {
 *     screenPageLimit: 5,
 *     itemPageLimit: 10,
 *     reorderInterval: 1000,
 *     fastReorderInterval: 500,
 *     eventType: 'conference',
 *     participants: [...],
 *     allVideoStreams: [...],
 *     shared: false,
 *     shareScreenStarted: false,
 *     adminNameStream: 'Admin',
 *     screenShareNameStream: 'ScreenShare',
 *     updateMainWindow: true,
 *     sortAudioLoudness: false,
 *     lastReorderTime: Date.now(),
 *     newLimitedStreams: [],
 *     newLimitedStreamsIDs: [],
 *     oldSoundIds: [],
 *     updateUpdateMainWindow: (value) => { console.log(updated) },
 *     updateSortAudioLoudness: (value) => { console.log(updated) },
 *     updateLastReorderTime: (value) => { console.log(updated) },
 *     updateNewLimitedStreams: (streams) => { console.log(updated) },
 *     updateNewLimitedStreamsIDs: (ids) => { console.log(updated) },
 *     updateOldSoundIds: (ids) => { console.log(updated) },
 *     onScreenChanges: async (opts) => {  },
 *     reorderStreams: async (opts) => {  },
 *     changeVids: async (opts) => {  },
 *   },
 * };
 *
 * await reUpdateInter(options);
 * ```
 */
class ReUpdateInter {
    /**
     * Updates the interaction state based on the provided options and parameters.
     *
     * @param {ReUpdateInterOptions} options - The options for updating the interaction.
     * @param {string} options.name - The name of the participant.
     * @param {boolean} [options.add=false] - Whether to add the participant to the interaction.
     * @param {boolean} [options.force=false] - Whether to force the update.
     * @param {number} [options.average=127] - The average value used for determining reorder intervals.
     * @param {Object} options.parameters - The parameters for updating the interaction.
     * @param {number} options.parameters.screenPageLimit - The screen page limit.
     * @param {number} options.parameters.itemPageLimit - The item page limit.
     * @param {number} options.parameters.reorderInterval - The reorder interval.
     * @param {number} options.parameters.fastReorderInterval - The fast reorder interval.
     * @param {string} options.parameters.eventType - The type of event.
     * @param {Array} options.parameters.participants - The list of participants.
     * @param {Array} options.parameters.allVideoStreams - The list of all video streams.
     * @param {boolean} options.parameters.shared - Whether the screen is shared.
     * @param {boolean} options.parameters.shareScreenStarted - Whether screen sharing has started.
     * @param {string} options.parameters.adminNameStream - The admin name stream.
     * @param {string} options.parameters.screenShareNameStream - The screen share name stream.
     * @param {boolean} options.parameters.updateMainWindow - Whether to update the main window.
     * @param {boolean} options.parameters.sortAudioLoudness - Whether to sort audio by loudness.
     * @param {number} options.parameters.lastReorderTime - The last reorder time.
     * @param {Array} options.parameters.newLimitedStreams - The list of new limited streams.
     * @param {Array} options.parameters.newLimitedStreamsIDs - The list of new limited stream IDs.
     * @param {Array} options.parameters.oldSoundIds - The list of old sound IDs.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
     * @param {Function} options.parameters.updateSortAudioLoudness - Function to update the audio loudness sorting.
     * @param {Function} options.parameters.updateLastReorderTime - Function to update the last reorder time.
     * @param {Function} options.parameters.updateNewLimitedStreams - Function to update the new limited streams.
     * @param {Function} options.parameters.updateNewLimitedStreamsIDs - Function to update the new limited stream IDs.
     * @param {Function} options.parameters.updateOldSoundIds - Function to update the old sound IDs.
     * @param {Function} options.parameters.onScreenChanges - Function to handle screen changes.
     * @param {Function} options.parameters.reorderStreams - Function to reorder streams.
     * @param {Function} options.parameters.changeVids - Function to change videos.
     *
     * @returns {Promise<void>} A promise that resolves when the interaction update is complete.
     */
    reUpdateInter = async ({ name, add = false, force = false, average = 127, parameters, }) => {
        let { screenPageLimit, itemPageLimit, reorderInterval, fastReorderInterval, eventType, participants, allVideoStreams, shared, shareScreenStarted, adminNameStream, screenShareNameStream, updateMainWindow, sortAudioLoudness, lastReorderTime, newLimitedStreams, newLimitedStreamsIDs, oldSoundIds, updateUpdateMainWindow, updateSortAudioLoudness, updateLastReorderTime, updateNewLimitedStreams, updateNewLimitedStreamsIDs, updateOldSoundIds, onScreenChanges, reorderStreams, changeVids, } = parameters;
        if (eventType == 'broadcast' || eventType == 'chat') {
            return;
        }
        let refLimit = screenPageLimit - 1;
        if (shareScreenStarted || shared) {
            // Do something when screen is shared or screen share is started
        }
        else {
            refLimit = itemPageLimit - 1;
            if (add) {
                const currentTime = Date.now();
                if ((currentTime - lastReorderTime >= reorderInterval && average > 128.5) ||
                    (average > 130 && currentTime - lastReorderTime >= fastReorderInterval)) {
                    lastReorderTime = currentTime;
                    sortAudioLoudness = true;
                    if (eventType == 'conference') {
                        await onScreenChanges({ changed: true, parameters });
                    }
                    else {
                        await reorderStreams({ add: false, screenChanged: true, parameters });
                    }
                    sortAudioLoudness = false;
                    updateSortAudioLoudness(sortAudioLoudness);
                    updateUpdateMainWindow(updateMainWindow);
                    updateLastReorderTime(lastReorderTime);
                    return;
                }
            }
        }
        let videoID = null;
        if (shareScreenStarted || shared) {
            if (add) {
                const participant = participants.find((p) => p.name === name);
                videoID = participant?.videoID ?? null;
                if (!videoID) {
                    return;
                }
                if (!newLimitedStreamsIDs.includes(videoID)) {
                    //first check length of newLimitedStreams to not exceed refLimit, if so remove oldSoundID from newLimitedStreams
                    if (newLimitedStreams.length > refLimit) {
                        let oldoldSounds = [...oldSoundIds];
                        for (let i = 0; i < oldSoundIds.length; i++) {
                            if (newLimitedStreams.length > refLimit) {
                                // remove stream from newLimitedStreams
                                if (newLimitedStreams.length < screenPageLimit) {
                                    return;
                                }
                                const currentId = oldSoundIds[i];
                                if (currentId !== screenShareNameStream && currentId !== adminNameStream) {
                                    newLimitedStreams = newLimitedStreams.filter((stream) => stream.producerId !== currentId);
                                    newLimitedStreamsIDs = newLimitedStreamsIDs.filter((id) => id !== currentId);
                                    oldoldSounds = oldoldSounds.filter((id) => id !== currentId);
                                }
                            }
                        }
                        oldSoundIds = [...oldoldSounds];
                    }
                    const stream = allVideoStreams.find((s) => s.producerId === videoID);
                    if (stream && newLimitedStreams.length < screenPageLimit) {
                        newLimitedStreams.push(stream);
                        newLimitedStreamsIDs.push(videoID);
                        if (!oldSoundIds.includes(name)) {
                            oldSoundIds.push(name);
                        }
                        await changeVids({ screenChanged: true, parameters });
                    }
                }
            }
            else {
                if (!force) {
                    try {
                        // remove stream from newLimitedStreams
                        if (newLimitedStreams.length < screenPageLimit) {
                            return;
                        }
                        newLimitedStreams = newLimitedStreams.filter((stream) => stream.producerId != videoID);
                        newLimitedStreamsIDs = newLimitedStreamsIDs.filter((id) => id !== videoID);
                        oldSoundIds = oldSoundIds.filter((id) => id !== name);
                        await changeVids({ parameters });
                    }
                    catch {
                        /* handle error */
                    }
                }
                else {
                    const participant = participants.find((p) => p.name === name);
                    if (participant?.muted) {
                        try {
                            newLimitedStreams = newLimitedStreams.filter((stream) => stream.producerId !== videoID);
                            newLimitedStreamsIDs = newLimitedStreamsIDs.filter((id) => id !== videoID);
                            oldSoundIds = oldSoundIds.filter((id) => id !== name);
                            await changeVids({ parameters });
                        }
                        catch {
                            /* handle error */
                        }
                    }
                }
            }
            updateNewLimitedStreams(newLimitedStreams);
            updateNewLimitedStreamsIDs(newLimitedStreamsIDs);
            updateOldSoundIds(oldSoundIds);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReUpdateInter, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReUpdateInter, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReUpdateInter, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * StartShareScreen - Service to initiate screen sharing with configurable options for different environments.
 *
 * This service initiates the screen sharing process, handling both successful and failed attempts
 * and updating the shared state accordingly.
 *
 * @class
 * @name StartShareScreen
 * @example
 * ```typescript
 * const startShareScreenService = new StartShareScreen();
 * await startShareScreenService.startShareScreen({
 *   parameters: {
 *     shared: false,
 *     showAlert: (alert) => console.log(alert.message),
 *     updateShared: (shared) => console.log('Shared state:', shared),
 *     onWeb: true,
 *     targetWidth: 1920,
 *     targetHeight: 1080,
 *     streamSuccessScreen: async ({ stream }) => {
 *       // Handle the successful stream here
 *       console.log('Stream started:', stream);
 *     },
 *   },
 * });
 * ```
 *
 * @param {StartShareScreenOptions} options - The options for starting screen sharing.
 * @param {Object} options.parameters - The parameters controlling screen sharing behavior.
 * @param {boolean} options.parameters.shared - Indicates if the screen is currently shared.
 * @param {Function} options.parameters.showAlert - Function to display alerts.
 * @param {Function} options.parameters.updateShared - Function to update the shared state.
 * @param {boolean} options.parameters.onWeb - Indicates if the app is running in a web environment.
 * @param {number} [options.parameters.targetWidth=1280] - Optional width setting for shared screen resolution.
 * @param {number} [options.parameters.targetHeight=720] - Optional height setting for shared screen resolution.
 * @param {Function} options.parameters.streamSuccessScreen - Function to handle successful screen sharing.
 *
 * @method startShareScreen - Initiates the screen sharing process based on the provided parameters.
 * @returns {Promise<void>} Resolves when the screen sharing process is complete or fails.
 */
class StartShareScreen {
    /**
     * Starts the screen sharing process.
     *
     * @param {StartShareScreenOptions} options - The options for starting screen sharing.
     * @param {Object} options.parameters - The parameters for screen sharing.
     * @param {boolean} options.parameters.shared - Indicates if the screen is currently being shared.
     * @param {Function} options.parameters.showAlert - Function to show alert messages.
     * @param {Function} options.parameters.updateShared - Function to update the shared state.
     * @param {boolean} options.parameters.onWeb - Indicates if the application is running on a web platform.
     * @param {number} [options.parameters.targetWidth] - The target width for screen sharing.
     * @param {number} [options.parameters.targetHeight] - The target height for screen sharing.
     * @param {Function} options.parameters.streamSuccessScreen - Function to handle successful screen sharing.
     *
     * @returns {Promise<void>} A promise that resolves when the screen sharing process is complete.
     *
     * @throws Will log an error message if there is an issue starting the screen share.
     */
    startShareScreen = async ({ parameters }) => {
        // start screen share function
        // attempt to start screen share and return true if successful
        let { shared, showAlert, updateShared, onWeb, targetWidth = 1280, targetHeight = 720, streamSuccessScreen, } = parameters;
        try {
            if (!onWeb) {
                showAlert?.({
                    message: 'You cannot share screen while on mobile',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                shared = true;
                await navigator.mediaDevices
                    .getDisplayMedia({
                    video: {
                        width: targetWidth,
                        height: targetHeight,
                        frameRate: 30,
                    },
                    audio: false,
                })
                    .then(async (stream) => {
                    await streamSuccessScreen({ stream, parameters });
                })
                    .catch(async () => {
                    shared = false;
                    showAlert?.({
                        message: 'Could not share screen, check and retry',
                        type: 'danger',
                        duration: 3000,
                    });
                });
            }
            else {
                showAlert?.({
                    message: 'Could not share screen, check and retry',
                    type: 'danger',
                    duration: 3000,
                });
            }
            // update the shared variable
            updateShared(shared);
        }
        catch (error) {
            console.log('Error starting screen share', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartShareScreen, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartShareScreen, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartShareScreen, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Stops the screen sharing process and updates the relevant parameters and states.
 *
 * This method updates the internal state to reflect that screen sharing has ended,
 * cleans up local media tracks, and reorders the streams in the application.
 *
 * @param {StopShareScreenOptions} options - The options for stopping the screen share.
 * @param {Object} options.parameters - The parameters required for stopping the screen share.
 * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 * @param {boolean} options.parameters.shared - Indicates if the screen is currently shared.
 * @param {boolean} options.parameters.shareScreenStarted - Indicates if the screen sharing has started.
 * @param {boolean} options.parameters.shareEnded - Indicates if the screen sharing has ended.
 * @param {boolean} options.parameters.updateMainWindow - Indicates if the main window needs to be updated.
 * @param {boolean} options.parameters.defer_receive - Indicates if receiving is deferred.
 * @param {string} options.parameters.hostLabel - The label of the host.
 * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
 * @param {boolean} options.parameters.forceFullDisplay - Indicates if full display is forced.
 * @param {boolean} options.parameters.firstAll - Indicates if it is the first all.
 * @param {boolean} options.parameters.first_round - Indicates if it is the first round.
 * @param {MediaStream} options.parameters.localStreamScreen - The local screen stream.
 * @param {string} options.parameters.eventType - The type of event (e.g., "conference").
 * @param {boolean} options.parameters.prevForceFullDisplay - Indicates if full display was previously forced.
 * @param {boolean} options.parameters.annotateScreenStream - Indicates if the screen stream is annotated.
 * @param {Function} options.parameters.updateShared - Function to update the shared state.
 * @param {Function} options.parameters.updateShareScreenStarted - Function to update the share screen started state.
 * @param {Function} options.parameters.updateShareEnded - Function to update the share ended state.
 * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window state.
 * @param {Function} options.parameters.updateDefer_receive - Function to update the defer receive state.
 * @param {Function} options.parameters.updateLock_screen - Function to update the lock screen state.
 * @param {Function} options.parameters.updateForceFullDisplay - Function to update the force full display state.
 * @param {Function} options.parameters.updateFirstAll - Function to update the first all state.
 * @param {Function} options.parameters.updateFirst_round - Function to update the first round state.
 * @param {Function} options.parameters.updateLocalStreamScreen - Function to update the local screen stream.
 * @param {Function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
 * @param {Function} options.parameters.updateAnnotateScreenStream - Function to update the annotate screen stream state.
 * @param {Function} options.parameters.updateIsScreenboardModalVisible - Function to update the screenboard modal visibility.
 * @param {Function} options.parameters.disconnectSendTransportScreen - Function to disconnect the send transport screen.
 * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
 * @param {Function} options.parameters.reorderStreams - Function to reorder streams.
 * @param {Function} options.parameters.getVideos - Function to get videos.
 *
 * @returns {Promise<void>} A promise that resolves when the screen sharing process is stopped.
 *
 * @throws {Error} Throws an error if there is an issue during the screen share stopping process.
 *
 * @example
 * await stopShareScreen({
 *   parameters: {
 *     socket: mySocket,
 *     shared: true,
 *     shareScreenStarted: true,
 *     // other parameters...
 *   },
 * });
 */
class StopShareScreen {
    /**
     * Stops the screen sharing process and updates the relevant parameters and states.
     *
     * @param {StopShareScreenOptions} options - The options for stopping the screen share.
     * @param {Object} options.parameters - The parameters required for stopping the screen share.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {boolean} options.parameters.shared - Indicates if the screen is currently shared.
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if the screen sharing has started.
     * @param {boolean} options.parameters.shareEnded - Indicates if the screen sharing has ended.
     * @param {boolean} options.parameters.updateMainWindow - Indicates if the main window needs to be updated.
     * @param {boolean} options.parameters.defer_receive - Indicates if receiving is deferred.
     * @param {string} options.parameters.hostLabel - The label of the host.
     * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
     * @param {boolean} options.parameters.forceFullDisplay - Indicates if full display is forced.
     * @param {boolean} options.parameters.firstAll - Indicates if it is the first all.
     * @param {boolean} options.parameters.first_round - Indicates if it is the first round.
     * @param {MediaStream} options.parameters.localStreamScreen - The local screen stream.
     * @param {string} options.parameters.eventType - The type of event.
     * @param {boolean} options.parameters.prevForceFullDisplay - Indicates if full display was previously forced.
     * @param {boolean} options.parameters.annotateScreenStream - Indicates if the screen stream is annotated.
     * @param {Function} options.parameters.updateShared - Function to update the shared state.
     * @param {Function} options.parameters.updateShareScreenStarted - Function to update the share screen started state.
     * @param {Function} options.parameters.updateShareEnded - Function to update the share ended state.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window state.
     * @param {Function} options.parameters.updateDefer_receive - Function to update the defer receive state.
     * @param {Function} options.parameters.updateLock_screen - Function to update the lock screen state.
     * @param {Function} options.parameters.updateForceFullDisplay - Function to update the force full display state.
     * @param {Function} options.parameters.updateFirstAll - Function to update the first all state.
     * @param {Function} options.parameters.updateFirst_round - Function to update the first round state.
     * @param {Function} options.parameters.updateLocalStreamScreen - Function to update the local screen stream.
     * @param {Function} options.parameters.updateMainHeightWidth - Function to update the main height and width.
     * @param {Function} options.parameters.updateAnnotateScreenStream - Function to update the annotate screen stream state.
     * @param {Function} options.parameters.updateIsScreenboardModalVisible - Function to update the screenboard modal visibility.
     * @param {Function} options.parameters.disconnectSendTransportScreen - Function to disconnect the send transport screen.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @param {Function} options.parameters.reorderStreams - Function to reorder streams.
     * @param {Function} options.parameters.getVideos - Function to get videos.
     *
     * @returns {Promise<void>} A promise that resolves when the screen sharing process is stopped.
     */
    stopShareScreen = async ({ parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { shared, shareScreenStarted, shareEnded, updateMainWindow, defer_receive, hostLabel, lock_screen, forceFullDisplay, firstAll, first_round, localStreamScreen, eventType, prevForceFullDisplay, annotateScreenStream, 
        // updates for the above
        updateShared, updateShareScreenStarted, updateShareEnded, updateUpdateMainWindow, updateDefer_receive, updateLock_screen, updateForceFullDisplay, updateFirstAll, updateFirst_round, updateLocalStreamScreen, updateMainHeightWidth, updateAnnotateScreenStream, updateIsScreenboardModalVisible, 
        // mediasfu functions
        disconnectSendTransportScreen, prepopulateUserMedia, reorderStreams, getVideos, } = parameters;
        shared = false;
        updateShared(shared);
        shareScreenStarted = false;
        updateShareScreenStarted(shareScreenStarted);
        shareEnded = true;
        updateShareEnded(shareEnded);
        updateMainWindow = true;
        updateUpdateMainWindow(updateMainWindow);
        if (defer_receive) {
            defer_receive = false;
            updateDefer_receive(defer_receive);
            await getVideos({
                participants: parameters.participants,
                allVideoStreams: parameters.allVideoStreams,
                oldAllStreams: parameters.oldAllStreams,
                adminVidID: parameters.adminVidID,
                updateAllVideoStreams: parameters['updateAllVideoStreams'],
                updateOldAllStreams: parameters['updateOldAllStreams'],
            });
        }
        try {
            localStreamScreen?.getTracks().forEach((track) => track.stop());
        }
        catch {
            // do nothing
        }
        updateLocalStreamScreen(localStreamScreen);
        await disconnectSendTransportScreen({ parameters });
        try {
            if (annotateScreenStream) {
                annotateScreenStream = false;
                updateAnnotateScreenStream(annotateScreenStream);
                updateIsScreenboardModalVisible(true);
                await new Promise((resolve) => setTimeout(resolve, 500));
                updateIsScreenboardModalVisible(false);
            }
        }
        catch (error) {
            console.log('Error handling screen annotation:', error);
        }
        if (eventType == 'conference') {
            updateMainHeightWidth(0);
        }
        try {
            await prepopulateUserMedia({ name: hostLabel, parameters });
        }
        catch (error) {
            console.log('Error in prepopulateUserMedia:', error);
        }
        try {
            await reorderStreams({ add: false, screenChanged: true, parameters });
        }
        catch (error) {
            console.log('Error in reorderStreams:', error);
        }
        lock_screen = false;
        updateLock_screen(lock_screen);
        forceFullDisplay = prevForceFullDisplay;
        updateForceFullDisplay(forceFullDisplay);
        firstAll = false;
        updateFirstAll(firstAll);
        first_round = false;
        updateFirst_round(first_round);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StopShareScreen, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StopShareScreen, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StopShareScreen, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Handles the successful streaming of audio by setting up the necessary transports and updating the relevant states.
 *
 * This method updates the local media stream with the new audio track, manages the transport connection,
 * and updates the participants' states to reflect changes in audio settings.
 *
 * @param {StreamSuccessAudioOptions} options - The options for streaming success audio.
 * @param {MediaStream} options.stream - The media stream containing the audio track.
 * @param {StreamSuccessAudioParameters} options.parameters - The parameters required for setting up the audio stream.
 * @param {Socket} options.parameters.socket - The socket connection for real-time communication.
 * @param {Participant[]} options.parameters.participants - The list of participants in the session.
 * @param {MediaStream | null} options.parameters.localStream - The local media stream that includes video and audio tracks.
 * @param {boolean} options.parameters.transportCreated - Indicates if the audio transport has been created.
 * @param {boolean} options.parameters.transportCreatedAudio - Indicates if the audio transport has been created.
 * @param {boolean} options.parameters.audioAlreadyOn - Indicates if the audio is already active.
 * @param {boolean} options.parameters.micAction - Indicates the microphone action state.
 * @param {ProducerOptions} options.parameters.audioParams - The current audio parameters for the producer.
 * @param {MediaStream | null} options.parameters.localStreamAudio - The local audio stream.
 * @param {string} options.parameters.defAudioID - The default audio device ID for the stream.
 * @param {string} options.parameters.userDefaultAudioInputDevice - The user default audio input device.
 * @param {ProducerOptions} options.parameters.params - Additional parameters for the producer.
 * @param {ProducerOptions} [options.parameters.audioParamse] - Additional audio parameters.
 * @param {ProducerOptions} options.parameters.aParams - Producer parameters for the audio.
 * @param {string} options.parameters.hostLabel - The label of the host for this session.
 * @param {string} options.parameters.islevel - The participant's level (e.g., admin, regular user).
 * @param {string} options.parameters.member - The member name for identification.
 * @param {boolean} options.parameters.updateMainWindow - Indicates if the main window needs to be updated.
 * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked for participants.
 * @param {boolean} options.parameters.shared - Indicates if the screen is currently shared.
 * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video stream is currently active.
 * @param {ShowAlert} [options.parameters.showAlert] - Optional function to show alert messages.
 * @param {Function} options.parameters.updateParticipants - Function to update the list of participants.
 * @param {Function} options.parameters.updateTransportCreated - Function to update the audio transport created status.
 * @param {Function} options.parameters.updateTransportCreatedAudio - Function to update the audio transport created status.
 * @param {Function} options.parameters.updateAudioAlreadyOn - Function to update the audio active status.
 * @param {Function} options.parameters.updateMicAction - Function to update the microphone action state.
 * @param {Function} options.parameters.updateAudioParams - Function to update the audio parameters.
 * @param {Function} options.parameters.updateLocalStream - Function to update the local stream.
 * @param {Function} options.parameters.updateLocalStreamAudio - Function to update the local audio stream.
 * @param {Function} options.parameters.updateDefAudioID - Function to update the default audio device ID.
 * @param {Function} options.parameters.updateUserDefaultAudioInputDevice - Function to update the default audio input device.
 * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window status.
 * @param {Function} options.parameters.createSendTransport - Function to create a send transport for audio.
 * @param {Function} options.parameters.connectSendTransportAudio - Function to connect the send transport for audio.
 * @param {Function} options.parameters.resumeSendTransportAudio - Function to resume the send transport for audio.
 * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media based on current settings.
 *
 * @returns {Promise<void>} A promise that resolves when the audio streaming setup is complete.
 *
 * @throws {Error} Throws an error if there is an issue during the audio stream setup.
 *
 * @example
 * await streamSuccessAudio({
 *   stream: newAudioStream,
 *   parameters: {
 *     socket: socketInstance,
 *     participants: participantList,
 *     // other parameters...
 *   },
 * });
 */
class StreamSuccessAudio {
    /**
     * Handles the successful streaming of audio by setting up the necessary transports and updating the relevant states.
     *
     * @param {Object} options - The options for streaming success audio.
     * @param {MediaStream} options.stream - The media stream containing the audio track.
     * @param {Object} options.parameters - The parameters required for setting up the audio stream.
     * @param {Object} options.parameters.socket - The socket connection.
     * @param {Array} options.parameters.participants - The list of participants.
     * @param {MediaStream} options.parameters.localStream - The local media stream.
     * @param {boolean} options.parameters.transportCreated - Flag indicating if the transport is created.
     * @param {boolean} options.parameters.transportCreatedAudio - Flag indicating if the audio transport is created.
     * @param {boolean} options.parameters.audioAlreadyOn - Flag indicating if the audio is already on.
     * @param {boolean} options.parameters.micAction - Flag indicating the microphone action.
     * @param {Object} options.parameters.audioParams - The audio parameters.
     * @param {MediaStream} options.parameters.localStreamAudio - The local audio stream.
     * @param {string} options.parameters.defAudioID - The default audio device ID.
     * @param {string} options.parameters.userDefaultAudioInputDevice - The user default audio input device.
     * @param {Object} options.parameters.params - Additional parameters.
     * @param {Object} options.parameters.audioParamse - Additional audio parameters.
     * @param {Object} options.parameters.aParams - Additional parameters for audio.
     * @param {string} options.parameters.hostLabel - The label of the host.
     * @param {string} options.parameters.islevel - The level of the user.
     * @param {string} options.parameters.member - The member name.
     * @param {boolean} options.parameters.updateMainWindow - Flag indicating if the main window should be updated.
     * @param {boolean} options.parameters.lock_screen - Flag indicating if the screen is locked.
     * @param {boolean} options.parameters.shared - Flag indicating if the screen is shared.
     * @param {boolean} options.parameters.videoAlreadyOn - Flag indicating if the video is already on.
     * @param {Function} options.parameters.showAlert - Function to show alert messages.
     * @param {Function} options.parameters.updateParticipants - Function to update participants.
     * @param {Function} options.parameters.updateTransportCreated - Function to update transport created flag.
     * @param {Function} options.parameters.updateTransportCreatedAudio - Function to update audio transport created flag.
     * @param {Function} options.parameters.updateAudioAlreadyOn - Function to update audio already on flag.
     * @param {Function} options.parameters.updateMicAction - Function to update microphone action flag.
     * @param {Function} options.parameters.updateAudioParams - Function to update audio parameters.
     * @param {Function} options.parameters.updateLocalStream - Function to update local stream.
     * @param {Function} options.parameters.updateLocalStreamAudio - Function to update local audio stream.
     * @param {Function} options.parameters.updateDefAudioID - Function to update default audio device ID.
     * @param {Function} options.parameters.updateUserDefaultAudioInputDevice - Function to update user default audio input device.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update main window flag.
     * @param {Function} options.parameters.createSendTransport - Function to create send transport.
     * @param {Function} options.parameters.connectSendTransportAudio - Function to connect send transport audio.
     * @param {Function} options.parameters.resumeSendTransportAudio - Function to resume send transport audio.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @returns {Promise<void>} A promise that resolves when the audio streaming setup is complete.
     */
    async streamSuccessAudio({ stream, parameters }) {
        let { socket, participants, localStream, transportCreated, transportCreatedAudio, audioAlreadyOn, micAction, audioParams, localStreamAudio, defAudioID, userDefaultAudioInputDevice, params, audioParamse, aParams, hostLabel, islevel, member, updateMainWindow, lock_screen, shared, videoAlreadyOn, showAlert, 
        // update functions
        updateParticipants, updateTransportCreated, updateTransportCreatedAudio, updateAudioAlreadyOn, updateMicAction, updateAudioParams, updateLocalStream, updateLocalStreamAudio, updateDefAudioID, updateUserDefaultAudioInputDevice, updateUpdateMainWindow, 
        // mediasfu functions
        createSendTransport, connectSendTransportAudio, resumeSendTransportAudio, prepopulateUserMedia, } = parameters;
        localStreamAudio = stream;
        updateLocalStreamAudio(localStreamAudio);
        // Add the audio stream track to the localStream
        if (localStream == null) {
            localStream = new MediaStream([localStreamAudio.getAudioTracks()[0]]);
            updateLocalStream(localStream);
        }
        else {
            localStream.addTrack(localStreamAudio.getAudioTracks()[0]);
            updateLocalStream(localStream);
        }
        const audioTracked = localStream.getAudioTracks()[0];
        defAudioID = audioTracked.getSettings().deviceId || '';
        userDefaultAudioInputDevice = defAudioID;
        // Update the state variables
        updateDefAudioID(defAudioID);
        updateUserDefaultAudioInputDevice(userDefaultAudioInputDevice);
        try {
            params = aParams;
            audioParamse = { ...params };
            audioParams = { track: localStream.getAudioTracks()[0], ...audioParamse };
            updateAudioParams(audioParams);
            // Create transport if not created else connect transport
            if (!transportCreated) {
                try {
                    await createSendTransport({
                        parameters: {
                            ...parameters,
                            audioParams: audioParams,
                        },
                        option: 'audio',
                    });
                }
                catch (error) {
                    console.error('Error creating send transport:', error);
                }
            }
            else {
                if (!transportCreatedAudio) {
                    await connectSendTransportAudio({
                        audioParams,
                        parameters,
                    });
                }
                else {
                    await resumeSendTransportAudio({ parameters });
                }
            }
        }
        catch (error) {
            showAlert?.({
                message: error.message,
                type: 'danger',
                duration: 3000,
            });
        }
        // Update the participants array to reflect the change
        audioAlreadyOn = true;
        updateAudioAlreadyOn(audioAlreadyOn);
        if (micAction) {
            micAction = false;
            updateMicAction(micAction);
        }
        participants.forEach((participant) => {
            if (participant.socketId == socket.id && participant.name == member) {
                participant.muted = false;
            }
        });
        updateParticipants(participants);
        // Update the transport created state
        transportCreated = true;
        transportCreatedAudio = true;
        updateTransportCreated(transportCreated);
        updateTransportCreatedAudio(transportCreatedAudio);
        // Reupdate screen display if host
        if (videoAlreadyOn == false && islevel == '2') {
            if (!lock_screen && !shared) {
                updateMainWindow = true;
                updateUpdateMainWindow(updateMainWindow);
                await prepopulateUserMedia({ name: hostLabel, parameters });
                updateMainWindow = false;
                updateUpdateMainWindow(updateMainWindow);
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Handles the switching of the audio stream upon successful stream connection.
 *
 * @param {StreamSuccessAudioSwitchOptions} options - The options for the audio stream success switch.
 * @param {MediaStream} options.stream - The new media stream containing the audio track.
 * @param {Object} options.parameters - The parameters required for setting up the audio stream.
 * @param {Producer} options.parameters.audioProducer - The current audio producer.
 * @param {Producer} options.parameters.localAudioProducer - The local audio producer.
 * @param {Socket} options.parameters.socket - The socket connection for communication.
 * @param {Socket} options.parameters.localSocket - The local socket connection for communication.
 * @param {string} options.parameters.roomName - The name of the room.
 * @param {MediaStream | null} options.parameters.localStream - The local media stream.
 * @param {MediaStream | null} options.parameters.localStreamAudio - The local audio stream.
 * @param {ProducerOptions} options.parameters.audioParams - The audio parameters.
 * @param {boolean} options.parameters.audioPaused - Indicates if the audio is paused.
 * @param {boolean} options.parameters.audioAlreadyOn - Indicates if the audio is already on.
 * @param {boolean} options.parameters.transportCreated - Indicates if the transport is created.
 * @param {ProducerCodecOptions} options.parameters.audioParamse - Additional audio parameters.
 * @param {string} options.parameters.defAudioID - The default audio device ID.
 * @param {string} options.parameters.userDefaultAudioInputDevice - The user default audio input device.
 * @param {string} options.parameters.hostLabel - The label of the host.
 * @param {boolean} options.parameters.updateMainWindow - Indicates if the main window should be updated.
 * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already on.
 * @param {string} options.parameters.islevel - The level of the participant.
 * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
 * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
 * @param {Function} options.parameters.updateAudioProducer - Function to update the audio producer.
 * @param {Function} options.parameters.updateLocalAudioProducer - Function to update the local audio producer.
 * @param {Function} options.parameters.updateLocalStream - Function to update the local stream.
 * @param {Function} options.parameters.updateAudioParams - Function to update the audio parameters.
 * @param {Function} options.parameters.updateDefAudioID - Function to update the default audio device ID.
 * @param {Function} options.parameters.updateUserDefaultAudioInputDevice - Function to update the user default audio input device.
 * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
 * @param {Function} options.parameters.sleep - Function to pause execution for a specified time.
 * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
 * @param {Function} options.parameters.createSendTransport - Function to create a send transport.
 * @param {Function} options.parameters.connectSendTransportAudio - Function to connect the send transport for audio.
 *
 * @returns {Promise<void>} A promise that resolves when the audio stream switch is complete.
 *
 * @example
 * const options = {
 *   stream: newAudioStream, // MediaStream object containing the new audio track
 *   parameters: {
 *     audioProducer: currentAudioProducer,
 *     localAudioProducer: localAudioProducerInstance,
 *     localSocket: localSocketInstance,
 *     socket: socketInstance,
 *     roomName: "Room1",
 *     localStream: null,
 *     localStreamAudio: null,
 *     audioParams: audioProducerOptions,
 *     audioPaused: false,
 *     audioAlreadyOn: true,
 *     transportCreated: false,
 *     audioParamse: additionalAudioParams,
 *     defAudioID: "default-audio-device-id",
 *     userDefaultAudioInputDevice: "user-input-device-id",
 *     hostLabel: "Host",
 *     islevel: "1",
 *     videoAlreadyOn: false,
 *     lock_screen: false,
 *     shared: false,
 *     updateAudioProducer: updateAudioProducerFunction,
 *     updateLocalAudioProducer: updateLocalAudioProducerFunction,
 *     updateLocalStream: updateLocalStreamFunction,
 *     updateAudioParams: updateAudioParamsFunction,
 *     updateDefAudioID: updateDefAudioIDFunction,
 *     updateUserDefaultAudioInputDevice: updateUserDefaultAudioInputDeviceFunction,
 *     updateUpdateMainWindow: updateMainWindowFunction,
 *     sleep: sleepFunction,
 *     prepopulateUserMedia: prepopulateUserMediaFunction,
 *     createSendTransport: createSendTransportFunction,
 *     connectSendTransportAudio: connectSendTransportAudioFunction,
 *   },
 * };
 *
 * streamSuccessAudioSwitch(options)
 *   .then(() => {
 *     console.log('Audio stream switched successfully');
 *   })
 *   .catch(error => {
 *     console.error('Error switching audio stream:', error);
 *   });
 */
class StreamSuccessAudioSwitch {
    /**
     * Handles the switching of the audio stream upon successful stream connection.
     *
     * @param {StreamSuccessAudioSwitchOptions} options - The options for the audio stream success switch.
     * @param {MediaStream} options.stream - The new media stream containing the audio track.
     * @param {Object} options.parameters - The parameters required for setting up the audio stream.
     * @param {Producer} options.parameters.audioProducer - The current audio producer.
     * @param {Producer} options.parameters.localAudioProducer - The local audio producer.
     * @param {Socket} options.parameters.socket - The socket connection for communication.
     * @param {Socket} options.parameters.localSocket - The local socket connection for communication.
     * @param {string} options.parameters.roomName - The name of the room.
     * @param {MediaStream | null} options.parameters.localStream - The local media stream.
     * @param {MediaStream | null} options.parameters.localStreamAudio - The local audio stream.
     * @param {ProducerOptions} options.parameters.audioParams - The audio parameters.
     * @param {boolean} options.parameters.audioPaused - Indicates if the audio is paused.
     * @param {boolean} options.parameters.audioAlreadyOn - Indicates if the audio is already on.
     * @param {boolean} options.parameters.transportCreated - Indicates if the transport is created.
     * @param {ProducerCodecOptions} options.parameters.audioParamse - Additional audio parameters.
     * @param {string} options.parameters.defAudioID - The default audio device ID.
     * @param {string} options.parameters.userDefaultAudioInputDevice - The user default audio input device.
     * @param {string} options.parameters.hostLabel - The label of the host.
     * @param {boolean} options.parameters.updateMainWindow - Indicates if the main window should be updated.
     * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already on.
     * @param {string} options.parameters.islevel - The level of the participant.
     * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
     * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
     * @param {Function} options.parameters.updateAudioProducer - Function to update the audio producer.
     * @param {Function} options.parameters.updateLocalAudioProducer - Function to update the local audio producer.
     * @param {Function} options.parameters.updateLocalStream - Function to update the local stream.
     * @param {Function} options.parameters.updateAudioParams - Function to update the audio parameters.
     * @param {Function} options.parameters.updateDefAudioID - Function to update the default audio device ID.
     * @param {Function} options.parameters.updateUserDefaultAudioInputDevice - Function to update the user default audio input device.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
     * @param {Function} options.parameters.sleep - Function to pause execution for a specified time.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @param {Function} options.parameters.createSendTransport - Function to create a send transport.
     * @param {Function} options.parameters.connectSendTransportAudio - Function to connect the send transport for audio.
     *
     * @returns {Promise<void>} A promise that resolves when the audio stream switch is complete.
     *
     * @example
     * const options = {
     *   stream: newAudioStream, // MediaStream object containing the new audio track
     *   parameters: {
     *     audioProducer: currentAudioProducer,
     *     localAudioProducer: localAudioProducerInstance,
     *     localSocket: localSocketInstance,
     *     socket: socketInstance,
     *     roomName: "Room1",
     *     localStream: null,
     *     localStreamAudio: null,
     *     audioParams: audioProducerOptions,
     *     audioPaused: false,
     *     audioAlreadyOn: true,
     *     transportCreated: false,
     *     audioParamse: additionalAudioParams,
     *     defAudioID: "default-audio-device-id",
     *     userDefaultAudioInputDevice: "user-input-device-id",
     *     hostLabel: "Host",
     *     islevel: "1",
     *     videoAlreadyOn: false,
     *     lock_screen: false,
     *     shared: false,
     *     updateAudioProducer: updateAudioProducerFunction,
     *     updateLocalAudioProducer: updateLocalAudioProducerFunction,
     *     updateLocalStream: updateLocalStreamFunction,
     *     updateAudioParams: updateAudioParamsFunction,
     *     updateDefAudioID: updateDefAudioIDFunction,
     *     updateUserDefaultAudioInputDevice: updateUserDefaultAudioInputDeviceFunction,
     *     updateUpdateMainWindow: updateMainWindowFunction,
     *     sleep: sleepFunction,
     *     prepopulateUserMedia: prepopulateUserMediaFunction,
     *     createSendTransport: createSendTransportFunction,
     *     connectSendTransportAudio: connectSendTransportAudioFunction,
     *   },
     * };
     *
     * streamSuccessAudioSwitch(options)
     *   .then(() => {
     *     console.log('Audio stream switched successfully');
     *   })
     *   .catch(error => {
     *     console.error('Error switching audio stream:', error);
     *   });
     */
    async streamSuccessAudioSwitch({ stream, parameters, }) {
        let { audioProducer, localAudioProducer, socket, localSocket, roomName, localStream, localStreamAudio, audioParams, audioPaused, audioAlreadyOn, transportCreated, audioParamse, defAudioID, userDefaultAudioInputDevice, hostLabel, updateMainWindow, videoAlreadyOn, islevel, lock_screen, shared, updateAudioProducer, updateLocalAudioProducer, updateLocalStream, updateAudioParams, updateDefAudioID, updateUserDefaultAudioInputDevice, updateUpdateMainWindow, 
        // mediasfu functions
        sleep, prepopulateUserMedia, createSendTransport, connectSendTransportAudio, } = parameters;
        // Get the new default audio device ID
        let newDefAudioID = stream.getAudioTracks()[0].getSettings().deviceId;
        // Check if the audio device has changed
        if (newDefAudioID != defAudioID) {
            // Close the current audioProducer
            if (audioProducer) {
                audioProducer.close();
                updateAudioProducer(audioProducer);
            }
            // Emit a pauseProducerMedia event to pause the audio media
            socket.emit('pauseProducerMedia', { mediaTag: 'audio', roomName: roomName, force: true });
            try {
                if (localSocket && localSocket.id) {
                    if (localAudioProducer) {
                        localAudioProducer.close();
                        if (updateLocalAudioProducer) {
                            updateLocalAudioProducer(localAudioProducer);
                        }
                    }
                    localSocket.emit("pauseProducerMedia", {
                        mediaTag: "audio",
                        roomName: roomName,
                        force: true,
                    });
                }
            }
            catch {
                // Do nothing
            }
            // Update the localStreamAudio with the new audio tracks
            localStreamAudio = stream;
            // If localStream is null, create a new MediaStream with the new audio track
            if (localStream == null) {
                localStream = new MediaStream([localStreamAudio.getAudioTracks()[0]]);
            }
            else {
                // Remove all existing audio tracks from localStream and add the new audio track
                localStream.getAudioTracks().forEach((track) => {
                    localStream?.removeTrack(track);
                });
                localStream.addTrack(localStreamAudio.getAudioTracks()[0]);
            }
            // Update localStream
            updateLocalStream(localStream);
            // Get the new default audio device ID from the new audio track
            const audioTracked = localStream.getAudioTracks()[0];
            defAudioID = audioTracked.getSettings().deviceId ?? '';
            updateDefAudioID(defAudioID);
            // Update userDefaultAudioInputDevice
            userDefaultAudioInputDevice = defAudioID;
            updateUserDefaultAudioInputDevice(userDefaultAudioInputDevice);
            // Update audioParams with the new audio track
            audioParams = { track: localStream.getAudioTracks()[0], ...audioParamse };
            updateAudioParams(audioParams);
            // Sleep for 500 milliseconds
            await sleep({ ms: 500 });
            // Create a new send transport if not created, otherwise, connect the existing transport
            if (!transportCreated) {
                try {
                    await createSendTransport({
                        parameters: {
                            ...parameters,
                            audioParams: audioParams,
                        },
                        option: 'audio',
                    });
                }
                catch (error) {
                    console.error('Error creating send transport:', error);
                }
            }
            else {
                await connectSendTransportAudio({
                    audioParams,
                    parameters,
                });
            }
            // If audio is paused and not already on, pause the audioProducer and emit a pauseProducerMedia event
            if (audioPaused && !audioAlreadyOn) {
                audioProducer?.pause();
                updateAudioProducer(audioProducer);
                socket.emit('pauseProducerMedia', { mediaTag: 'audio', roomName: roomName });
                try {
                    if (localSocket && localSocket.id) {
                        localSocket.emit("pauseProducerMedia", {
                            mediaTag: "audio",
                            roomName: roomName,
                        });
                    }
                }
                catch {
                    // Do nothing
                }
            }
        }
        // Update the UI based on the participant's level and screen lock status
        if (!videoAlreadyOn && islevel === '2') {
            if (!lock_screen && !shared) {
                // Set updateMainWindow to true, prepopulate user media, and set updateMainWindow back to false
                updateMainWindow = true;
                updateUpdateMainWindow(updateMainWindow);
                await prepopulateUserMedia({ name: hostLabel, parameters });
                updateMainWindow = false;
                updateUpdateMainWindow(updateMainWindow);
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessAudioSwitch, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessAudioSwitch, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessAudioSwitch, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Handles the successful initiation of screen sharing.
 *
 * This method sets up the necessary transport connections for screen sharing,
 * updates relevant application states, and notifies participants of the screen
 * sharing status.
 *
 * @param {StreamSuccessScreenOptions} options - The options for the screen sharing success handler.
 * @param {MediaStream} options.stream - The media stream to be shared.
 * @param {StreamSuccessScreenParameters} options.parameters - The parameters required for screen sharing.
 * @param {Socket} options.parameters.socket - The socket instance for real-time communication.
 * @param {boolean} options.parameters.transportCreated - Flag indicating if the transport is already created.
 * @param {MediaStream | null} options.parameters.localStreamScreen - The local screen media stream.
 * @param {boolean} options.parameters.screenAlreadyOn - Flag indicating if the screen is already being shared.
 * @param {boolean} options.parameters.screenAction - Flag indicating if the screen share action is requested.
 * @param {boolean} options.parameters.transportCreatedScreen - Flag indicating if the screen transport is created.
 * @param {string} options.parameters.hostLabel - The label of the host for this session.
 * @param {string} options.parameters.eventType - The type of event (e.g., conference).
 * @param {ShowAlert} [options.parameters.showAlert] - Optional function to show alert messages.
 * @param {boolean} options.parameters.annotateScreenStream - Flag indicating if screen annotation is enabled.
 * @param {Function} options.parameters.updateTransportCreatedScreen - Function to update the screen transport creation state.
 * @param {Function} options.parameters.updateScreenAlreadyOn - Function to update the screen sharing state.
 * @param {Function} options.parameters.updateScreenAction - Function to update the screen action state.
 * @param {Function} options.parameters.updateTransportCreated - Function to update the transport creation state.
 * @param {Function} options.parameters.updateLocalStreamScreen - Function to update the local screen stream.
 * @param {Function} options.parameters.updateShared - Function to update the shared state.
 * @param {Function} options.parameters.updateIsScreenboardModalVisible - Function to update the screenboard modal visibility.
 * @param {Function} options.parameters.sleep - Function to pause execution for a specified time.
 * @param {Function} options.parameters.createSendTransport - Function to create a send transport for screen sharing.
 * @param {Function} options.parameters.connectSendTransportScreen - Function to connect the send transport for screen sharing.
 * @param {Function} options.parameters.disconnectSendTransportScreen - Function to disconnect the send transport for screen sharing.
 * @param {Function} options.parameters.stopShareScreen - Function to stop the screen sharing process.
 * @param {Function} options.parameters.reorderStreams - Function to reorder streams based on current state.
 * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media based on current settings.
 * @param {Function} options.parameters.rePort - Function to reinitialize ports if needed.
 *
 * @returns {Promise<void>} A promise that resolves when the screen sharing setup is complete.
 *
 * @throws {Error} Throws an error if there is an issue during the screen sharing setup.
 *
 * @example
 * await streamSuccessScreen({
 *   stream: newScreenStream,
 *   parameters: {
 *     socket: socketInstance,
 *     localStreamScreen: null,
 *     // other parameters...
 *   },
 * });
 */
class StreamSuccessScreen {
    /**
     * Handles the successful initiation of screen sharing.
     *
     * @param {StreamSuccessScreenOptions} options - The options for the screen sharing success handler.
     * @param {MediaStream} options.stream - The media stream to be shared.
     * @param {Object} options.parameters - The parameters required for screen sharing.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {Socket} options.parameters.socket - The socket instance for communication.
     * @param {boolean} options.parameters.transportCreated - Flag indicating if the transport is already created.
     * @param {MediaStream} options.parameters.localStreamScreen - The local screen media stream.
     * @param {boolean} options.parameters.screenAlreadyOn - Flag indicating if the screen is already being shared.
     * @param {boolean} options.parameters.screenAction - Flag indicating if the screen share action is requested.
     * @param {boolean} options.parameters.transportCreatedScreen - Flag indicating if the screen transport is created.
     * @param {string} options.parameters.hostLabel - The label of the host.
     * @param {string} options.parameters.eventType - The type of the event (e.g., conference).
     * @param {Function} options.parameters.showAlert - Function to show alerts.
     * @param {boolean} options.parameters.annotateScreenStream - Flag indicating if screen annotation is enabled.
     * @param {Function} options.parameters.updateTransportCreatedScreen - Function to update the screen transport creation state.
     * @param {Function} options.parameters.updateScreenAlreadyOn - Function to update the screen sharing state.
     * @param {Function} options.parameters.updateScreenAction - Function to update the screen action state.
     * @param {Function} options.parameters.updateTransportCreated - Function to update the transport creation state.
     * @param {Function} options.parameters.updateLocalStreamScreen - Function to update the local screen stream.
     * @param {Function} options.parameters.updateShared - Function to update the shared state.
     * @param {Function} options.parameters.updateIsScreenboardModalVisible - Function to update the screenboard modal visibility.
     * @param {Function} options.parameters.sleep - Function to pause execution for a specified duration.
     * @param {Function} options.parameters.createSendTransport - Function to create a send transport.
     * @param {Function} options.parameters.connectSendTransportScreen - Function to connect the send transport for screen sharing.
     * @param {Function} options.parameters.disconnectSendTransportScreen - Function to disconnect the send transport for screen sharing.
     * @param {Function} options.parameters.stopShareScreen - Function to stop screen sharing.
     * @param {Function} options.parameters.reorderStreams - Function to reorder streams.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     * @param {Function} options.parameters.rePort - Function to reinitialize ports.
     *
     * @returns {Promise<void>} A promise that resolves when the screen sharing setup is complete.
     */
    async streamSuccessScreen({ stream, parameters }) {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { socket, transportCreated, localStreamScreen, screenAlreadyOn, screenAction, transportCreatedScreen, hostLabel, eventType, showAlert, annotateScreenStream, 
        // updates for the above
        updateTransportCreatedScreen, updateScreenAlreadyOn, updateScreenAction, updateTransportCreated, updateLocalStreamScreen, updateShared, updateIsScreenboardModalVisible, sleep, 
        // mediasfu functions
        createSendTransport, connectSendTransportScreen, disconnectSendTransportScreen, stopShareScreen, reorderStreams, prepopulateUserMedia, rePort, } = parameters;
        // Share screen on success
        localStreamScreen = stream;
        updateLocalStreamScreen(localStreamScreen);
        try {
            // Create transport if not created else connect transport
            if (!transportCreated) {
                await createSendTransport({
                    option: 'screen',
                    parameters: { ...parameters, localStreamScreen },
                });
            }
            else {
                await connectSendTransportScreen({
                    stream: localStreamScreen,
                    parameters: { ...parameters, localStreamScreen },
                });
            }
            // Alert the socket that you are sharing screen
            socket.emit('startScreenShare');
        }
        catch (error) {
            showAlert?.({
                message: error.message,
                type: 'danger',
                duration: 3000,
            });
        }
        // Reupdate the screen display
        try {
            updateShared(true);
            await prepopulateUserMedia({
                name: hostLabel,
                parameters: { ...parameters, localStreamScreen, shared: true },
            });
        }
        catch {
            /* handle error */
        }
        // Update the participants array to reflect the change
        screenAlreadyOn = true;
        updateScreenAlreadyOn(screenAlreadyOn);
        // Reorder streams if required
        try {
            if (eventType == 'conference') {
                await reorderStreams({ add: false, screenChanged: true, parameters });
                await prepopulateUserMedia({ name: hostLabel, parameters });
            }
            else {
                await reorderStreams({ parameters });
            }
        }
        catch (error) {
            try {
                await rePort({ parameters });
            }
            catch {
                /* handle error */
            }
        }
        // Handle screen share end
        localStreamScreen.getVideoTracks()[0].onended = async function () {
            // Supports both manual and automatic screen share end
            await disconnectSendTransportScreen({ parameters });
            await stopShareScreen({ parameters });
        };
        // If user requested to share screen, update the screenAction state
        if (screenAction == true) {
            screenAction = false;
        }
        updateScreenAction(screenAction);
        // Update the transport created state
        transportCreatedScreen = true;
        transportCreated = true;
        updateTransportCreatedScreen(transportCreatedScreen);
        updateTransportCreated(transportCreated);
        // Handle screen annotation modal
        try {
            if (annotateScreenStream) {
                annotateScreenStream = false;
                updateIsScreenboardModalVisible(true);
                await sleep({ ms: 500 });
                updateIsScreenboardModalVisible(false);
            }
        }
        catch (error) {
            //console.log('Error handling screen annotation:', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessScreen, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessScreen, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessScreen, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Streams a video successfully by managing the local stream, updating parameters, and handling video transport.
 *
 * This method initiates the video streaming process by updating the local video stream with the new stream,
 * creating or connecting to the video transport, and notifying participants of the streaming status.
 *
 * @param {StreamSuccessVideoOptions} options - The options for streaming the video.
 * @param {MediaStream} options.stream - The media stream to be used for the video.
 * @param {StreamSuccessVideoParameters} options.parameters - The parameters required for streaming.
 * @param {Socket} options.parameters.socket - The socket instance for real-time communication.
 * @param {Participant[]} options.parameters.participants - The list of participants in the session.
 * @param {MediaStream | null} options.parameters.localStream - The local media stream.
 * @param {boolean} options.parameters.transportCreated - Indicates if the transport has already been created.
 * @param {boolean} options.parameters.transportCreatedVideo - Indicates if the video transport has been created.
 * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already on.
 * @param {boolean} options.parameters.videoAction - Indicates if a video action is being performed.
 * @param {ProducerOptions} options.parameters.videoParams - The parameters for the video producer.
 * @param {MediaStream | null} options.parameters.localStreamVideo - The local video stream.
 * @param {string} options.parameters.defVideoID - The default video device ID.
 * @param {string} options.parameters.userDefaultVideoInputDevice - The user's default video input device.
 * @param {ProducerOptions} options.parameters.params - Additional parameters for the producer.
 * @param {ProducerOptions} options.parameters.videoParamse - Additional parameters for the video.
 * @param {string} options.parameters.islevel - The level of the user (e.g., host, participant).
 * @param {string} options.parameters.member - The member's name in the session.
 * @param {boolean} options.parameters.updateMainWindow - Indicates if the main window should be updated.
 * @param {boolean} options.parameters.lock_screen - Indicates if the screen is locked.
 * @param {boolean} options.parameters.shared - Indicates if the screen is shared.
 * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already on.
 * @param {Function} options.parameters.showAlert - Function to show alert messages.
 * @param {Function} options.parameters.updateParticipants - Function to update the participants list.
 * @param {Function} options.parameters.updateTransportCreated - Function to update the transport creation state.
 * @param {Function} options.parameters.updateTransportCreatedVideo - Function to update the transport creation state.
 * @param {Function} options.parameters.updateVideoAlreadyOn - Function to update the video status.
 * @param {Function} options.parameters.updateVideoAction - Function to update the video action state.
 * @param {Function} options.parameters.updateLocalStream - Function to update the local stream.
 * @param {Function} options.parameters.updateLocalStreamVideo - Function to update the local video stream.
 * @param {Function} options.parameters.updateUserDefaultVideoInputDevice - Function to update the default video input device.
 * @param {Function} options.parameters.updateCurrentFacingMode - Function to update the current facing mode.
 * @param {Function} options.parameters.updateDefVideoID - Function to update the default video device ID.
 * @param {Function} options.parameters.updateAllowed - Function to update the allowed state.
 * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window state.
 * @param {Function} options.parameters.createSendTransport - Function to create a send transport for video.
 * @param {Function} options.parameters.connectSendTransportVideo - Function to connect the send transport for video.
 * @param {Function} options.parameters.resumeSendTransportAudio - Function to resume audio transport.
 *
 * @returns {Promise<void>} A promise that resolves when the video has been successfully streamed.
 *
 * @throws {Error} Throws an error if there is an issue with streaming the video.
 *
 * @example
 * await streamSuccessVideo({
 *   stream: newVideoStream,
 *   parameters: {
 *     socket: socketInstance,
 *     localStream: null,
 *     // other parameters...
 *   },
 * });
 */
class StreamSuccessVideo {
    /**
     * Streams a video successfully by managing the local stream, updating parameters, and handling video transport.
     *
     * @param {StreamSuccessVideoOptions} options - The options for streaming the video.
     * @param {MediaStream} options.stream - The media stream to be used for the video.
     * @param {Object} options.parameters - The parameters required for streaming.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     *
     * @returns {Promise<void>} A promise that resolves when the video has been successfully streamed.
     *
     * @throws Will throw an error if there is an issue with streaming the video.
     */
    streamSuccessVideo = async ({ stream, parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        try {
            let { socket, participants, localStream, transportCreated, transportCreatedVideo, videoAlreadyOn, videoAction, videoParams, localStreamVideo, defVideoID, userDefaultVideoInputDevice, params, videoParamse, islevel, member, updateMainWindow, lock_screen, shared, shareScreenStarted, vParams, hParams, allowed, currentFacingMode, device, keepBackground, appliedBackground, videoProducer, 
            // update functions
            updateTransportCreated, updateTransportCreatedVideo, updateVideoAlreadyOn, updateVideoAction, updateLocalStream, updateLocalStreamVideo, updateUserDefaultVideoInputDevice, updateCurrentFacingMode, updateDefVideoID, updateAllowed, updateUpdateMainWindow, updateParticipants, updateVideoParams, updateIsBackgroundModalVisible, updateAutoClickBackground, 
            // mediasfu functions
            createSendTransport, connectSendTransportVideo, showAlert, reorderStreams, sleep, } = parameters;
            localStreamVideo = stream;
            updateLocalStreamVideo(localStreamVideo);
            // Add the video stream track to localStream
            if (localStream == null) {
                localStream = new MediaStream([localStreamVideo.getVideoTracks()[0]]);
                updateLocalStream(localStream);
            }
            else {
                // Remove all video tracks that are currently in the localStream
                localStream.getVideoTracks().forEach((track) => {
                    localStream?.removeTrack(track);
                });
                // Add the new video track to the localStream
                localStream.addTrack(localStreamVideo.getVideoTracks()[0]);
                updateLocalStream(localStream);
            }
            // Get the video track settings
            const videoTracked = localStream.getVideoTracks()[0];
            defVideoID = videoTracked.getSettings().deviceId ?? '';
            userDefaultVideoInputDevice = defVideoID;
            currentFacingMode = videoTracked.getSettings().facingMode ?? 'user';
            // Update the state variables
            if (defVideoID) {
                updateDefVideoID(defVideoID);
            }
            if (userDefaultVideoInputDevice) {
                updateUserDefaultVideoInputDevice(userDefaultVideoInputDevice);
            }
            if (currentFacingMode) {
                updateCurrentFacingMode(currentFacingMode);
            }
            allowed = true;
            updateAllowed(allowed);
            try {
                // Apply the video constraints
                if (islevel == '2') {
                    if (!shared || !shareScreenStarted) {
                        params = hParams;
                        videoParamse = { ...params };
                    }
                    else {
                        params = vParams;
                        videoParamse = { ...params };
                    }
                }
                else {
                    params = vParams;
                    videoParamse = { ...params };
                }
                // Remove VP9 codec from the video codecs; support only VP8 and H264
                let codec = device?.rtpCapabilities?.codecs?.filter((codec) => codec.mimeType.toLowerCase() !== 'video/vp9' && codec.kind === 'video');
                // Create transport if not created else connect transport
                if (codec && codec.length > 0) {
                    videoParams = {
                        track: localStream.getVideoTracks()[0],
                        ...videoParamse,
                        codec: codec[0],
                    };
                }
                else {
                    throw new Error('No suitable video codec found');
                }
                updateVideoParams(videoParams);
                if (keepBackground && appliedBackground) {
                    videoAlreadyOn = true;
                    updateVideoAlreadyOn(videoAlreadyOn);
                    updateAutoClickBackground(true);
                    updateIsBackgroundModalVisible(true);
                    await sleep({ ms: 500 });
                    updateIsBackgroundModalVisible(false);
                    updateAutoClickBackground(false);
                }
                else {
                    if (!transportCreated) {
                        try {
                            await createSendTransport({
                                parameters: {
                                    ...parameters,
                                    videoParams: videoParams,
                                },
                                option: 'video',
                            });
                        }
                        catch (error) {
                            console.log('Error creating send transport:', error);
                        }
                    }
                    else {
                        try {
                            videoProducer?.close();
                            await sleep({ ms: 500 });
                        }
                        catch {
                            /* handle error */
                        }
                        await connectSendTransportVideo({
                            parameters: parameters,
                            videoParams: videoParams,
                        });
                    }
                }
            }
            catch (error) {
                showAlert?.({
                    message: error.message,
                    type: 'danger',
                    duration: 3000,
                });
            }
            // Update the videoAlreadyOn state
            videoAlreadyOn = true;
            updateVideoAlreadyOn(videoAlreadyOn);
            // If user requested to share video, update the videoAction state
            if (videoAction) {
                videoAction = false;
                updateVideoAction(videoAction);
            }
            // Update the display screen if host
            if (islevel == '2') {
                updateMainWindow = true;
                updateUpdateMainWindow(updateMainWindow);
            }
            // Update the participants array to reflect the change
            participants.forEach((participant) => {
                if (participant.socketId == socket.id && participant.name == member) {
                    participant.videoOn = true;
                }
            });
            updateParticipants(participants);
            // Update the transport created state
            transportCreatedVideo = true;
            transportCreated = true;
            updateTransportCreated(transportCreated);
            updateTransportCreatedVideo(transportCreatedVideo);
            // Reupdate the screen display
            if (lock_screen) {
                try {
                    await reorderStreams({
                        add: true,
                        screenChanged: true,
                        parameters: { ...parameters, videoAlreadyOn },
                    });
                }
                catch (error) {
                    console.log('Error reordering streams with lock screen:', error);
                }
            }
            else {
                try {
                    await reorderStreams({
                        add: false,
                        screenChanged: true,
                        parameters: { ...parameters, videoAlreadyOn },
                    });
                }
                catch (error) {
                    console.log('Error reordering streams without lock screen:', error);
                }
            }
        }
        catch (error) {
            const { showAlert } = parameters;
            console.log('Error in streamSuccessVideo:', error);
            showAlert?.({
                message: error.message,
                type: 'danger',
                duration: 3000,
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessVideo, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StreamSuccessVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Switches the user's audio input device based on the provided audio preference.
 *
 * This method checks for audio permissions, attempts to access the specified audio input device,
 * and updates the application's state accordingly. If the audio input device cannot be accessed,
 * it will revert to the previous audio input device.
 *
 * @param {SwitchUserAudioOptions} options - The options for switching the user's audio input device.
 * @param {string} options.audioPreference - The preferred audio input device ID.
 * @param {SwitchUserAudioParameters} options.parameters - Additional parameters required for switching the audio input device.
 * @param {string} options.parameters.prevAudioInputDevice - The previous audio input device ID.
 * @param {Function} options.parameters.showAlert - Function to show alert messages.
 * @param {boolean} options.parameters.hasAudioPermission - Flag indicating if the user has granted audio permission.
 * @param {Function} options.parameters.updateUserDefaultAudioInputDevice - Function to update the user's default audio input device.
 * @param {Function} options.parameters.streamSuccessAudioSwitch - Function to handle successful audio stream switch.
 * @param {Function} options.parameters.requestPermissionAudio - Function to request audio permission from the user.
 * @param {Function} options.parameters.checkMediaPermission - Function to check if media permission is granted.
 *
 * @returns {Promise<void>} A promise that resolves when the audio input device has been successfully switched.
 *
 * @throws Will throw an error if the audio input device cannot be accessed or if there is an unexpected error.
 *
 * @example
 * await switchUserAudio({
 *   audioPreference: 'new-audio-device-id',
 *   parameters: {
 *     prevAudioInputDevice: 'previous-device-id',
 *     hasAudioPermission: true,
 *     updateUserDefaultAudioInputDevice: updateDeviceFunction,
 *     // other parameters...
 *   },
 * });
 */
class SwitchUserAudio {
    /**
     * Switches the user's audio input device based on the provided audio preference.
     *
     * @param {SwitchUserAudioOptions} options - The options for switching the user's audio input device.
     * @param {string} options.audioPreference - The preferred audio input device ID.
     * @param {Object} options.parameters - Additional parameters required for switching the audio input device.
     * @param {string} options.parameters.prevAudioInputDevice - The previous audio input device ID.
     * @param {Function} options.parameters.showAlert - Function to show alert messages.
     * @param {boolean} options.parameters.hasAudioPermission - Flag indicating if the user has granted audio permission.
     * @param {Function} options.parameters.updateUserDefaultAudioInputDevice - Function to update the user's default audio input device.
     * @param {Function} options.parameters.streamSuccessAudioSwitch - Function to handle successful audio stream switch.
     * @param {Function} options.parameters.requestPermissionAudio - Function to request audio permission from the user.
     * @param {Function} options.parameters.checkMediaPermission - Function to check if media permission is granted.
     *
     * @returns {Promise<void>} A promise that resolves when the audio input device has been successfully switched.
     *
     * @throws Will throw an error if the audio input device cannot be accessed or if there is an unexpected error.
     */
    async switchUserAudio({ audioPreference, parameters }) {
        let { userDefaultAudioInputDevice, prevAudioInputDevice, showAlert, hasAudioPermission, updateUserDefaultAudioInputDevice, 
        // media functions
        streamSuccessAudioSwitch, requestPermissionAudio, checkMediaPermission, } = parameters;
        try {
            // Check if audio permission is granted
            if (!hasAudioPermission) {
                if (checkMediaPermission) {
                    let statusMic = await requestPermissionAudio();
                    if (statusMic !== 'granted') {
                        showAlert?.({
                            message: 'Allow access to your microphone or check if your microphone is not being used by another application.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                }
            }
            let mediaConstraints = {
                audio: {
                    deviceId: { exact: audioPreference },
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false,
                },
                video: false,
            };
            // Get user media with the defined audio constraints
            await navigator.mediaDevices
                .getUserMedia(mediaConstraints)
                .then(async (stream) => {
                await streamSuccessAudioSwitch({ stream, parameters });
            })
                .catch(() => {
                // Handle errors and revert to the previous audio input device
                userDefaultAudioInputDevice = prevAudioInputDevice;
                updateUserDefaultAudioInputDevice(userDefaultAudioInputDevice);
                showAlert?.({
                    message: 'Error switching; the specified microphone could not be accessed.',
                    type: 'danger',
                    duration: 3000,
                });
            });
        }
        catch (error) {
            // Handle unexpected errors and revert to the previous audio input device
            userDefaultAudioInputDevice = prevAudioInputDevice;
            updateUserDefaultAudioInputDevice(userDefaultAudioInputDevice);
            showAlert?.({
                message: 'Error switching; the specified microphone could not be accessed.',
                type: 'danger',
                duration: 3000,
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchUserAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchUserAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchUserAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// click-video.service.ts
/**
 * Handles the click event to toggle the participant's video on/off and manages video permission requests.
 *
 * @param {ClickVideoOptions} options - The options for handling the video click event.
 * @param {ClickVideoParameters} options.parameters - The parameters required for the video action.
 * @param {boolean} options.parameters.checkMediaPermission - Indicates if media permission needs to be checked.
 * @param {boolean} options.parameters.hasCameraPermission - Indicates if camera permission has been granted.
 * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is currently active.
 * @param {boolean} options.parameters.audioOnlyRoom - Indicates if the current room is audio-only.
 * @param {boolean} options.parameters.recordStarted - Indicates if recording has started.
 * @param {boolean} options.parameters.recordResumed - Indicates if recording has resumed.
 * @param {boolean} options.parameters.recordPaused - Indicates if recording is paused.
 * @param {boolean} options.parameters.recordStopped - Indicates if recording is stopped.
 * @param {string} options.parameters.recordingMediaOptions - The media options for recording (e.g., "video", "audio").
 * @param {string} options.parameters.islevel - The participant's level.
 * @param {boolean} options.parameters.youAreCoHost - Indicates if the user is a co-host.
 * @param {boolean} options.parameters.adminRestrictSetting - Indicates if there are admin restrictions on video.
 * @param {string | null} options.parameters.videoRequestState - State of the video request.
 * @param {number} options.parameters.videoRequestTime - Timestamp of the video request.
 * @param {string} options.parameters.member - The participant's name.
 * @param {Socket} options.parameters.socket - The socket connection used for communication.
 * @param {string} options.parameters.roomName - The name of the room where the video is being toggled.
 * @param {string} options.parameters.userDefaultVideoInputDevice - The default video input device.
 * @param {string} options.parameters.currentFacingMode - The current facing mode of the camera.
 * @param {VidCons} options.parameters.vidCons - Video constraints for the stream.
 * @param {number} options.parameters.frameRate - Desired frame rate for the video.
 * @param {boolean} options.parameters.videoAction - Indicates if a video action is currently taking place.
 * @param {MediaStream | null} options.parameters.localStream - The local media stream.
 * @param {string} options.parameters.audioSetting - The current audio setting.
 * @param {string} options.parameters.videoSetting - The current video setting.
 * @param {string} options.parameters.screenshareSetting - The current screenshare setting.
 * @param {string} options.parameters.chatSetting - The current chat setting.
 * @param {number} options.parameters.updateRequestIntervalSeconds - Interval time for updating request state.
 *
 * @returns {Promise<void>} A promise that resolves when the video action has been handled.
 *
 * @remarks
 * This function checks the current status of the video and handles the logic for starting or stopping the video stream.
 * It validates permissions and room settings before allowing the video to be activated or deactivated.
 *
 * @example
 * ```typescript
 * const options: ClickVideoOptions = {
 *   parameters: {
 *     checkMediaPermission: true,
 *     hasCameraPermission: false,
 *     videoAlreadyOn: false,
 *     audioOnlyRoom: false,
 *     recordStarted: false,
 *     recordResumed: false,
 *     recordPaused: false,
 *     recordStopped: false,
 *     recordingMediaOptions: 'video',
 *     islevel: '1',
 *     youAreCoHost: false,
 *     adminRestrictSetting: false,
 *     videoRequestState: null,
 *     videoRequestTime: 0,
 *     member: 'John Doe',
 *     socket: socketInstance,
 *     roomName: 'myRoom',
 *     userDefaultVideoInputDevice: '',
 *     currentFacingMode: 'user',
 *     vidCons: { width: 1280, height: 720 },
 *     frameRate: 30,
 *     videoAction: false,
 *     localStream: null,
 *     audioSetting: 'on',
 *     videoSetting: 'on',
 *     screenshareSetting: 'off',
 *     chatSetting: 'allow',
 *     updateRequestIntervalSeconds: 30,
 *     showAlert: (alert) => console.log(alert.message),
 *     updateVideoAlreadyOn: (status) => console.log(`Video already on: ${status}`),
 *     updateVideoRequestState: (state) => console.log(`Video request state: ${state}`),
 *     updateLocalStream: (stream) => console.log('Local stream updated'),
 *     streamSuccessVideo: streamSuccessFunction,
 *     disconnectSendTransportVideo: disconnectFunction,
 *     requestPermissionCamera: requestPermissionFunction,
 *     checkPermission: checkPermissionFunction,
 *     getUpdatedAllParams: () => parameters,
 *   },
 * };
 *
 * const clickVideoService = new ClickVideo();
 * await clickVideoService.clickVideo(options);
 * ```
 */
class ClickVideo {
    /**
     * Handles the click event to toggle the participant's video on/off and manages video permission requests.
     *
     * @param {ClickVideoParams} options - The function parameters.
     * @returns {Promise<void>}
     */
    clickVideo = async ({ parameters }) => {
        let { checkMediaPermission, hasCameraPermission, videoAlreadyOn, audioOnlyRoom, recordStarted, recordResumed, recordPaused, recordStopped, recordingMediaOptions, islevel, youAreCoHost, adminRestrictSetting, videoRequestState, videoRequestTime, member, socket, roomName, userDefaultVideoInputDevice, currentFacingMode, vidCons, frameRate, videoAction, localStream, audioSetting, videoSetting, screenshareSetting, chatSetting, updateRequestIntervalSeconds, streamSuccessVideo, showAlert, updateVideoAlreadyOn, updateVideoRequestState, updateLocalStream, disconnectSendTransportVideo, requestPermissionCamera, checkPermission, } = parameters;
        if (audioOnlyRoom) {
            showAlert?.({
                message: 'You cannot turn on your camera in an audio only event.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (videoAlreadyOn) {
            if (islevel === '2' && (recordStarted || recordResumed)) {
                if (!(recordPaused || recordStopped) && recordingMediaOptions === 'video') {
                    showAlert?.({
                        message: 'You cannot turn off your camera while recording video, please pause or stop recording first.',
                        type: 'danger',
                        duration: 3000,
                    });
                    return;
                }
            }
            videoAlreadyOn = false;
            updateVideoAlreadyOn(videoAlreadyOn);
            if (localStream) {
                localStream.getVideoTracks()[0].enabled = false;
            }
            updateLocalStream(localStream);
            await disconnectSendTransportVideo({ parameters });
        }
        else {
            if (adminRestrictSetting) {
                showAlert?.({
                    message: 'You cannot turn on your camera. Access denied by host.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            let response = 2;
            if (!videoAction && islevel !== '2' && !youAreCoHost) {
                response = await checkPermission({
                    permissionType: 'videoSetting',
                    audioSetting,
                    videoSetting,
                    screenshareSetting,
                    chatSetting,
                });
            }
            else {
                response = 0;
            }
            if (response === 1) {
                if (videoRequestState === 'pending') {
                    showAlert?.({
                        message: 'A request is pending. Please wait for the host to respond.',
                        type: 'danger',
                        duration: 3000,
                    });
                    return;
                }
                if (videoRequestState === 'rejected' &&
                    Date.now() - videoRequestTime < updateRequestIntervalSeconds) {
                    showAlert?.({
                        message: `A request was rejected. Please wait for ${updateRequestIntervalSeconds} seconds before sending another request.`,
                        type: 'danger',
                        duration: 3000,
                    });
                    return;
                }
                showAlert?.({
                    message: 'Request sent to host.',
                    type: 'success',
                    duration: 3000,
                });
                videoRequestState = 'pending';
                updateVideoRequestState(videoRequestState);
                let userRequest = { id: socket.id, name: member, icon: 'fa-video' };
                socket.emit('participantRequest', { userRequest, roomName });
            }
            else if (response === 2) {
                showAlert?.({
                    message: 'You cannot turn on your camera. Access denied by host.',
                    type: 'danger',
                    duration: 3000,
                });
            }
            else {
                if (!hasCameraPermission) {
                    if (checkMediaPermission) {
                        let statusCamera = await requestPermissionCamera();
                        if (statusCamera !== 'granted') {
                            showAlert?.({
                                message: 'Allow access to your camera or check if your camera is not being used by another application.',
                                type: 'danger',
                                duration: 3000,
                            });
                            return;
                        }
                    }
                }
                let mediaConstraints = {};
                let altMediaConstraints = {};
                if (userDefaultVideoInputDevice) {
                    if (vidCons && vidCons.width && vidCons.height) {
                        mediaConstraints = {
                            video: {
                                deviceId: userDefaultVideoInputDevice,
                                facingMode: currentFacingMode,
                                ...vidCons,
                                frameRate: { ideal: frameRate },
                            },
                            audio: false,
                        };
                        altMediaConstraints = {
                            video: { ...vidCons, frameRate: { ideal: frameRate } },
                            audio: false,
                        };
                    }
                    else {
                        mediaConstraints = {
                            video: { ...vidCons, frameRate: { ideal: frameRate } },
                            audio: false,
                        };
                        altMediaConstraints = { video: { frameRate: { ideal: frameRate } }, audio: false };
                    }
                }
                else {
                    if (vidCons && vidCons.width && vidCons.height) {
                        mediaConstraints = {
                            video: { ...vidCons, frameRate: { ideal: frameRate } },
                            audio: false,
                        };
                        altMediaConstraints = {
                            video: { ...vidCons, frameRate: { ideal: frameRate } },
                            audio: false,
                        };
                    }
                    else {
                        mediaConstraints = { video: { frameRate: { ideal: frameRate } }, audio: false };
                    }
                }
                await navigator.mediaDevices
                    .getUserMedia(mediaConstraints)
                    .then(async (stream) => {
                    await streamSuccessVideo({ stream, parameters });
                })
                    .catch(async () => {
                    await navigator.mediaDevices
                        .getUserMedia(altMediaConstraints)
                        .then(async (stream) => {
                        await streamSuccessVideo({ stream, parameters });
                    })
                        .catch(async () => {
                        //remove frameRate from constraints
                        altMediaConstraints = {
                            video: { ...vidCons },
                            audio: false,
                        };
                        await navigator.mediaDevices
                            .getUserMedia(altMediaConstraints)
                            .then(async (stream) => {
                            await streamSuccessVideo({ stream, parameters });
                        }).catch(() => {
                            showAlert?.({
                                message: 'Allow access to your camera or check if your camera is not being used by another application.',
                                type: 'danger',
                                duration: 3000,
                            });
                        });
                    });
                });
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickVideo, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Switches the user's video input device based on the provided options.
 *
 * This method checks permissions, enumerates available devices, and updates the
 * video stream based on user preferences. It also manages UI updates and alerts.
 *
 * @param {SwitchUserVideoOptions} options - The options for switching the user's video.
 * @param {string} options.videoPreference - The preferred video input device ID.
 * @param {boolean} options.checkoff - Flag indicating whether to turn off the video.
 * @param {SwitchUserVideoParameters} options.parameters - Additional parameters required for switching the video.
 * @param {boolean} options.parameters.audioOnlyRoom - Indicates if the room is audio-only.
 * @param {number} options.parameters.frameRate - The desired frame rate for the video.
 * @param {Object} options.parameters.vidCons - Video constraints such as width and height.
 * @param {string} options.parameters.prevVideoInputDevice - The previous video input device ID.
 * @param {Function} options.parameters.showAlert - Function to show alerts to the user.
 * @param {boolean} options.parameters.hasCameraPermission - Indicates if the user has camera permission.
 * @param {Function} options.parameters.updateVideoSwitching - Function to update video switching state.
 * @param {Function} options.parameters.updateUserDefaultVideoInputDevice - Function to update the default video input device.
 * @param {Function} options.parameters.requestPermissionCamera - Function to request camera permission.
 * @param {Function} options.parameters.streamSuccessVideo - Function to handle successful video stream.
 * @param {Function} options.parameters.sleep - Function to pause execution for a specified duration.
 * @param {Function} options.parameters.checkMediaPermission - Function to check media permissions.
 *
 * @returns {Promise<void>} A promise that resolves when the video input device has been successfully switched.
 *
 * @throws {Error} Throws an error if switching the video input device fails.
 *
 * @example
 * await switchUserVideo({
 *   videoPreference: 'user',
 *   checkoff: false,
 *   parameters: {
 *     audioOnlyRoom: false,
 *     frameRate: 30,
 *     vidCons: { width: 1280, height: 720 },
 *     prevVideoInputDevice: 'device-id',
 *     showAlert: myShowAlertFunction,
 *     hasCameraPermission: true,
 *     updateVideoSwitching: myUpdateFunction,
 *     updateUserDefaultVideoInputDevice: myUpdateFunction,
 *     requestPermissionCamera: myRequestPermissionFunction,
 *     streamSuccessVideo: myStreamSuccessFunction,
 *     sleep: mySleepFunction,
 *     checkMediaPermission: true,
 *   },
 * });
 */
class SwitchUserVideo {
    ClickVideoService;
    constructor(ClickVideoService) {
        this.ClickVideoService = ClickVideoService;
    }
    /**
     * Switches the user's video input device based on the provided options.
     *
     * @param {SwitchUserVideoOptions} options - The options for switching the user's video.
     * @param {string} options.videoPreference - The preferred video input device ID.
     * @param {boolean} options.checkoff - Flag indicating whether to turn off the video.
     * @param {Object} options.parameters - Additional parameters required for switching the video.
     * @param {boolean} options.parameters.audioOnlyRoom - Indicates if the room is audio-only.
     * @param {number} options.parameters.frameRate - The desired frame rate for the video.
     * @param {Object} options.parameters.vidCons - Video constraints such as width and height.
     * @param {string} options.parameters.prevVideoInputDevice - The previous video input device ID.
     * @param {Function} options.parameters.showAlert - Function to show alerts to the user.
     * @param {boolean} options.parameters.hasCameraPermission - Indicates if the user has camera permission.
     * @param {Function} options.parameters.updateVideoSwitching - Function to update video switching state.
     * @param {Function} options.parameters.updateUserDefaultVideoInputDevice - Function to update the default video input device.
     * @param {Function} options.parameters.requestPermissionCamera - Function to request camera permission.
     * @param {Function} options.parameters.streamSuccessVideo - Function to handle successful video stream.
     * @param {Function} options.parameters.sleep - Function to pause execution for a specified duration.
     * @param {Function} options.parameters.checkMediaPermission - Function to check media permissions.
     *
     * @returns {Promise<void>} A promise that resolves when the video input device has been switched.
     *
     * @throws Will throw an error if switching the video input device fails.
     */
    switchUserVideo = async ({ videoPreference, checkoff, parameters, }) => {
        let { audioOnlyRoom, frameRate, vidCons, prevVideoInputDevice, userDefaultVideoInputDevice, showAlert, hasCameraPermission, updateVideoSwitching, updateUserDefaultVideoInputDevice, 
        // mediasfu functions
        requestPermissionCamera, streamSuccessVideo, sleep, checkMediaPermission, } = parameters;
        try {
            // Check if it's an audio-only room
            if (audioOnlyRoom) {
                showAlert?.({
                    message: 'You cannot turn on your camera in an audio-only event.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            // If checkoff is not true, trigger a click on the video button to turn off the video
            if (!checkoff) {
                await this.ClickVideoService.clickVideo({ parameters });
                await updateVideoSwitching(true);
                await sleep(500);
                await updateVideoSwitching(false);
            }
            // Check camera permission
            if (!hasCameraPermission) {
                if (checkMediaPermission) {
                    let statusCamera = await requestPermissionCamera();
                    if (statusCamera !== 'granted') {
                        showAlert?.({
                            message: 'Allow access to your camera or check if your camera is not being used by another application.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                }
            }
            let mediaConstraints = {};
            if (vidCons && vidCons.width && vidCons.height) {
                mediaConstraints = {
                    video: {
                        deviceId: { exact: videoPreference },
                        ...vidCons,
                        frameRate: { ideal: frameRate },
                    },
                    audio: false,
                };
            }
            else {
                mediaConstraints = {
                    video: {
                        deviceId: { exact: videoPreference },
                        frameRate: { ideal: frameRate },
                    },
                    audio: false,
                };
            }
            // Get user media with the defined constraints
            await navigator.mediaDevices
                .getUserMedia(mediaConstraints)
                .then(async (stream) => {
                await streamSuccessVideo({ stream, parameters });
            })
                .catch(async () => {
                // Handle errors and revert to the previous video input device
                userDefaultVideoInputDevice = prevVideoInputDevice;
                updateUserDefaultVideoInputDevice(userDefaultVideoInputDevice);
                showAlert?.({
                    message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                    type: 'danger',
                    duration: 3000,
                });
            });
        }
        catch (error) {
            // Handle unexpected errors and revert to the previous video input device
            userDefaultVideoInputDevice = prevVideoInputDevice;
            updateUserDefaultVideoInputDevice(userDefaultVideoInputDevice);
            showAlert?.({
                message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                type: 'danger',
                duration: 3000,
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchUserVideo, deps: [{ token: ClickVideo }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchUserVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchUserVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: ClickVideo }] });

/**
 * Switches the user's video stream based on the provided video preference and other parameters.
 *
 * This method manages the process of switching the user's video input device,
 * checking permissions, and updating the relevant application state.
 * If the specified device is not accessible, it attempts to find an alternative.
 *
 * @param {SwitchUserVideoAltOptions} options - The options for switching the user's video.
 * @param {string} options.videoPreference - The preferred video input device ID.
 * @param {boolean} options.checkoff - A flag indicating whether to turn off the video before switching.
 * @param {SwitchUserVideoAltParameters} options.parameters - The parameters required for switching the video.
 * @param {Function} options.parameters.showAlert - Function to show alert messages to the user.
 * @param {boolean} options.parameters.hasCameraPermission - Flag indicating if the user has granted camera permission.
 * @param {Function} options.parameters.updateVideoSwitching - Function to update the video switching state.
 * @param {Function} options.parameters.requestPermissionCamera - Function to request camera permission from the user.
 * @param {Function} options.parameters.checkMediaPermission - Function to check if media permissions are granted.
 *
 * @returns {Promise<void>} A promise that resolves when the video switching is complete.
 *
 * @throws Will throw an error if the audio input device cannot be accessed or if there is an unexpected error.
 *
 * @example
 * await switchUserVideoAlt({
 *   videoPreference: 'user',
 *   checkoff: false,
 *   parameters: {
 *     hasCameraPermission: true,
 *     updateVideoSwitching: (state) => { /* update state *\/ },
 *     // other parameters...
 *   },
 * });
 */
class SwitchUserVideoAlt {
    ClickVideoService;
    constructor(ClickVideoService) {
        this.ClickVideoService = ClickVideoService;
    }
    /**
     * Switches the user's video stream based on the provided video preference and other parameters.
     *
     * @param {Object} options - The options for switching the user's video.
     * @param {string} options.videoPreference - The preferred video facing mode (e.g., "user" or "environment").
     * @param {boolean} options.checkoff - A flag indicating whether to turn off the video before switching.
     * @param {SwitchUserVideoAltOptions} options.parameters - The parameters required for switching the video.
     *
     * @returns {Promise<void>} A promise that resolves when the video switching is complete.
     *
     * @throws Will throw an error if there is an issue with switching the video.
     */
    async switchUserVideoAlt({ videoPreference, checkoff, parameters, }) {
        let { getUpdatedAllParams } = parameters;
        let parameters_ = getUpdatedAllParams();
        let { audioOnlyRoom, frameRate, vidCons, showAlert, hasCameraPermission, updateVideoSwitching, updateCurrentFacingMode, 
        // mediasfu functions
        requestPermissionCamera, streamSuccessVideo, sleep, checkMediaPermission, } = parameters;
        let { currentFacingMode, prevFacingMode } = parameters_;
        try {
            // Check if it's an audio-only room
            if (audioOnlyRoom) {
                showAlert?.({
                    message: 'You cannot turn on your camera in an audio-only event.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            // If checkoff is not true, trigger a click on the video button to turn off the video
            if (!checkoff) {
                await this.ClickVideoService.clickVideo({ parameters });
                updateVideoSwitching(true);
                await sleep({ ms: 500 });
                updateVideoSwitching(false);
            }
            // Check camera permission
            if (!hasCameraPermission) {
                if (checkMediaPermission) {
                    let statusCamera = await requestPermissionCamera();
                    if (statusCamera !== 'granted') {
                        showAlert?.({
                            message: 'Allow access to your camera or check if your camera is not being used by another application.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                }
            }
            // Enumerate video devices
            const videoDevices = await navigator.mediaDevices.enumerateDevices();
            // Define media constraints based on preferences and options
            let mediaConstraints = {};
            if (vidCons && vidCons.width && vidCons.height) {
                mediaConstraints = {
                    video: {
                        facingMode: { exact: videoPreference },
                        ...vidCons,
                        frameRate: { ideal: frameRate },
                    },
                    audio: false,
                };
            }
            else {
                mediaConstraints = {
                    video: {
                        facingMode: { exact: videoPreference },
                        frameRate: { ideal: frameRate },
                    },
                    audio: false,
                };
            }
            // Get user media with the defined constraints
            await navigator.mediaDevices
                .getUserMedia(mediaConstraints)
                .then(async (stream) => {
                await streamSuccessVideo({ stream, parameters });
            })
                .catch(async () => {
                let videoDevicesFront = [];
                // Filter video devices based on the preferred facing mode
                if (videoPreference === 'user') {
                    videoDevicesFront = videoDevices.filter((device) => device.label.includes('front') && device.kind === 'videoinput');
                }
                else {
                    videoDevicesFront = videoDevices.filter((device) => device.label.includes('back') && device.kind === 'videoinput');
                }
                if (videoDevicesFront.length > 0) {
                    videoDevicesFront.forEach((device) => {
                        if (device.kind === 'videoinput') {
                            let videoDeviceId = device.deviceId;
                            // Update media constraints with the specific video device
                            if (vidCons && vidCons.width && vidCons.height) {
                                mediaConstraints = {
                                    video: {
                                        deviceId: { exact: videoDeviceId },
                                        ...vidCons,
                                        frameRate: { ideal: frameRate },
                                    },
                                    audio: false,
                                };
                            }
                            else {
                                mediaConstraints = {
                                    video: {
                                        deviceId: { exact: videoDeviceId },
                                        frameRate: { ideal: frameRate },
                                    },
                                    audio: false,
                                };
                            }
                            // Try to get user media with the new constraints
                            navigator.mediaDevices
                                .getUserMedia(mediaConstraints)
                                .then(async (stream) => {
                                await streamSuccessVideo({ stream, parameters });
                            })
                                .catch(() => {
                                // If the current video device is the last one in the list, show the error; otherwise, try the next device
                                if (videoDeviceId === videoDevicesFront[videoDevicesFront.length - 1].deviceId) {
                                    currentFacingMode = prevFacingMode;
                                    updateCurrentFacingMode(currentFacingMode);
                                    showAlert?.({
                                        message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                                        type: 'danger',
                                        duration: 3000,
                                    });
                                }
                            });
                        }
                    });
                }
                else {
                    // Show error if no compatible video devices are found
                    currentFacingMode = prevFacingMode;
                    updateCurrentFacingMode(currentFacingMode);
                    showAlert?.({
                        message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
            });
        }
        catch (error) {
            // Handle any unexpected errors
            const videoDevices = await navigator.mediaDevices.enumerateDevices();
            let videoDevicesFront = [];
            if (videoPreference === 'user') {
                videoDevicesFront = videoDevices.filter((device) => device.label.includes('front') && device.kind === 'videoinput');
            }
            else {
                videoDevicesFront = videoDevices.filter((device) => device.label.includes('back') && device.kind === 'videoinput');
            }
            let mediaConstraints = {};
            if (videoDevicesFront.length > 0) {
                videoDevicesFront.forEach((device) => {
                    if (device.kind === 'videoinput') {
                        let videoDeviceId = device.deviceId;
                        if (vidCons && vidCons.width && vidCons.height) {
                            mediaConstraints = {
                                video: {
                                    deviceId: { exact: videoDeviceId },
                                    ...vidCons,
                                    frameRate: { ideal: frameRate },
                                },
                                audio: false,
                            };
                        }
                        else {
                            mediaConstraints = {
                                video: {
                                    deviceId: { exact: videoDeviceId },
                                    frameRate: { ideal: frameRate },
                                },
                                audio: false,
                            };
                        }
                        navigator.mediaDevices
                            .getUserMedia(mediaConstraints)
                            .then(async (stream) => {
                            await streamSuccessVideo({ stream, parameters });
                        })
                            .catch(() => {
                            // If current video device is the last one in the list, show the error; otherwise, try next device
                            if (videoDeviceId === videoDevicesFront[videoDevicesFront.length - 1].deviceId) {
                                currentFacingMode = prevFacingMode;
                                updateCurrentFacingMode(currentFacingMode);
                                showAlert?.({
                                    message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                                    type: 'danger',
                                    duration: 3000,
                                });
                            }
                        });
                    }
                });
            }
            else {
                currentFacingMode = prevFacingMode;
                updateCurrentFacingMode(currentFacingMode);
                showAlert?.({
                    message: 'Error switching; not accessible, might need to turn off your video and turn it back on after switching.',
                    type: 'danger',
                    duration: 3000,
                });
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchUserVideoAlt, deps: [{ token: ClickVideo }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchUserVideoAlt, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchUserVideoAlt, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: ClickVideo }] });

/**
 * Triggers an update to the screen client based on the provided parameters.
 *
 * This function handles various conditions to determine the main screen person,
 * adjusts the screen states, and emits an update to the screen client via socket.
 *
 * @param {TriggerOptions} options - The options for triggering the update.
 * @param {string[]} options.ref_ActiveNames - Reference to the active names.
 * @param {TriggerParameters} options.parameters - The parameters for the trigger.
 * @returns {Promise<void>} A promise that resolves when the trigger is complete.
 *
 * @throws Will throw an error if the updateScreenClient operation fails.
 *
 * @example
 * ```typescript
 * await trigger({
 *   ref_ActiveNames: ["user1", "user2"],
 *   parameters: {
 *     socket: socketInstance,
 *     localSocket: socketInstance,
 *     roomName: "room1",
 *     screenStates: [{ mainScreenPerson: "user1", mainScreenFilled: true, adminOnMainScreen: false }],
 *     participants: [{ name: "admin", islevel: "2" }],
 *     updateDateState: 0,
 *     lastUpdate: null,
 *     nForReadjust: 0,
 *     eventType: "conference",
 *     shared: false,
 *     shareScreenStarted: false,
 *     whiteboardStarted: false,
 *     whiteboardEnded: false,
 *     updateUpdateDateState: (date) => {},
 *     updateLastUpdate: (date) => {},
 *     updateNForReadjust: (n) => {},
 *     autoAdjust: async ({ n, parameters }) => [n, 0],
 *   },
 * });
 * ```
 */
class Trigger {
    /**
     * Triggers an update to the screen client based on the provided parameters.
     *
     * @param {TriggerOptions} options - The options for triggering the update.
     * @param {string[]} options.ref_ActiveNames - Reference to the active names.
     * @param {Parameters} options.parameters - The parameters for the trigger.
     * @returns {Promise<void>} A promise that resolves when the trigger is complete.
     *
     * @throws Will throw an error if the updateScreenClient operation fails.
     *
     * @remarks
     * This function handles various conditions to determine the main screen person,
     * adjusts the screen states, and emits an update to the screen client via socket.
     *
     * @example
     * ```typescript
     * await trigger({
     *   ref_ActiveNames: ["user1", "user2"],
     *   parameters: {
     *     socket: socketInstance,
     *     localSocket: socketInstance,
     *     roomName: "room1",
     *     screenStates: [{ mainScreenPerson: "user1", mainScreenFilled: true, adminOnMainScreen: false }],
     *     participants: [{ name: "admin", islevel: "2" }],
     *     updateDateState: 0,
     *     lastUpdate: null,
     *     nForReadjust: 0,
     *     eventType: "conference",
     *     shared: false,
     *     shareScreenStarted: false,
     *     whiteboardStarted: false,
     *     whiteboardEnded: false,
     *     updateUpdateDateState: (date) => {},
     *     updateLastUpdate: (date) => {},
     *     updateNForReadjust: (n) => {},
     *     autoAdjust: async ({ n, parameters }) => [n, 0],
     *   },
     * });
     * ```
     */
    async trigger({ ref_ActiveNames, parameters }) {
        // Function to trigger the updateScreen event
        try {
            let { socket, localSocket, roomName, screenStates, participants, updateDateState, lastUpdate, nForReadjust, eventType, shared, shareScreenStarted, whiteboardStarted, whiteboardEnded, updateUpdateDateState, updateLastUpdate, updateNForReadjust, autoAdjust, } = parameters;
            let socketRef = socket;
            if (localSocket && localSocket.id) {
                socketRef = localSocket;
            }
            let personOnMainScreen = screenStates[0].mainScreenPerson;
            let adminName = '';
            const admin = participants.filter((participant) => participant.islevel == '2');
            if (admin.length > 0) {
                adminName = admin[0].name || '';
            }
            if (personOnMainScreen === 'WhiteboardActive') {
                personOnMainScreen = adminName;
            }
            let mainfilled = screenStates[0].mainScreenFilled;
            let adminOnMain = screenStates[0].adminOnMainScreen;
            let nForReadjust_;
            let val1;
            let noww = new Date().getTime();
            // get now in seconds
            let timestamp = Math.floor(noww / 1000);
            let eventPass = false;
            if (eventType === 'conference' && !(shared || shareScreenStarted)) {
                eventPass = true;
                personOnMainScreen = adminName;
                if (!ref_ActiveNames.includes(adminName)) {
                    ref_ActiveNames.unshift(adminName);
                }
            }
            if ((mainfilled && personOnMainScreen != null && adminOnMain) || eventPass) {
                if (eventType === 'conference') {
                    nForReadjust = nForReadjust + 1;
                    updateNForReadjust(nForReadjust);
                }
                if (!ref_ActiveNames.includes(adminName) && whiteboardStarted && !whiteboardEnded) {
                    ref_ActiveNames.unshift(adminName);
                }
                nForReadjust_ = ref_ActiveNames.length;
                if (nForReadjust_ === 0 && eventType === 'webinar') {
                    val1 = 0;
                }
                else {
                    const [val11] = await autoAdjust({
                        n: nForReadjust_,
                        eventType,
                        shared,
                        shareScreenStarted,
                    });
                    val1 = val11;
                }
                let calc1 = Math.floor((val1 / 12) * 100);
                let calc2 = 100 - calc1;
                // check if lastUpdate is not null and at least same seconds
                if (lastUpdate == null || updateDateState != timestamp) {
                    let now = new Date();
                    socketRef.emit('updateScreenClient', {
                        roomName,
                        names: ref_ActiveNames,
                        mainPercent: calc2,
                        mainScreenPerson: personOnMainScreen,
                        viewType: eventType,
                    }, ({ success, reason }) => {
                        updateDateState = timestamp;
                        updateUpdateDateState(updateDateState);
                        lastUpdate = Math.floor(now.getTime() / 1000);
                        updateLastUpdate(lastUpdate);
                        if (success) {
                            // handle success
                        }
                        else {
                            console.log(reason, 'updateScreenClient failed');
                        }
                    });
                }
            }
            else if (mainfilled && personOnMainScreen != null && !adminOnMain) {
                nForReadjust_ = ref_ActiveNames.length;
                if (!ref_ActiveNames.includes(adminName)) {
                    ref_ActiveNames.unshift(adminName);
                    nForReadjust_ = ref_ActiveNames.length;
                }
                const [val11] = await autoAdjust({
                    n: nForReadjust_,
                    eventType,
                    shared,
                    shareScreenStarted,
                });
                val1 = val11;
                const calc1 = Math.floor((val1 / 12) * 100);
                const calc2 = 100 - calc1;
                if (lastUpdate == null || updateDateState != timestamp) {
                    let now = new Date();
                    socketRef.emit('updateScreenClient', {
                        roomName,
                        names: ref_ActiveNames,
                        mainPercent: calc2,
                        mainScreenPerson: personOnMainScreen,
                        viewType: eventType,
                    }, ({ success, reason }) => {
                        updateDateState = timestamp;
                        updateUpdateDateState(updateDateState);
                        lastUpdate = Math.floor(now.getTime() / 1000);
                        updateLastUpdate(lastUpdate);
                        if (success) {
                            // handle success
                        }
                        else {
                            console.log(reason, 'updateScreenClient failed');
                        }
                    });
                }
            }
            else {
                // stop recording
                console.log('trigger stopRecording');
            }
        }
        catch (error) {
            console.log('Error triggering updateScreen:', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Trigger, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Trigger, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Trigger, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Updates the mini cards grid based on the specified rows and columns.
 *
 * This method calculates the dimensions for the mini cards based on the provided
 * rows and columns, as well as the container sizes. It also considers pagination
 * settings and updates the grid sizes accordingly. The method can update either
 * the default grid or an alternative grid based on the `defal` parameter.
 *
 * @param {UpdateMiniCardsGridOptions} options - The options for updating the mini cards grid.
 * @param {number} options.rows - The number of rows in the grid.
 * @param {number} options.cols - The number of columns in the grid.
 * @param {boolean} [options.defal=true] - Flag indicating whether to update the default grid or an alternative grid.
 * @param {number} [options.actualRows=2] - The actual number of rows in the grid.
 * @param {UpdateMiniCardsGridParameters} options.parameters - Additional parameters needed for the function.
 * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 * @param {Function} options.parameters.updateGridRows - Function to update the grid rows.
 * @param {Function} options.parameters.updateGridCols - Function to update the grid columns.
 * @param {Function} options.parameters.updateAltGridRows - Function to update the alternative grid rows.
 * @param {Function} options.parameters.updateAltGridCols - Function to update the alternative grid columns.
 * @param {Function} options.parameters.updateGridSizes - Function to update the grid sizes.
 * @param {GridSizes} options.parameters.gridSizes - Object containing grid width and height.
 * @param {string} options.parameters.paginationDirection - The direction of pagination ('horizontal' or 'vertical').
 * @param {number} options.parameters.paginationHeightWidth - The height or width of pagination.
 * @param {boolean} options.parameters.doPaginate - Flag indicating whether pagination is enabled.
 * @param {ComponentSizes} options.parameters.componentSizes - Object containing container width and height.
 * @param {EventType} options.parameters.eventType - The type of event ('chat', etc.).
 *
 * @returns {Promise<void>} - A Promise that resolves after updating the mini cards grid.
 *
 * @example
 * ```typescript
 * const gridOptions = {
 *   rows: 3,
 *   cols: 4,
 *   parameters: {
 *     getUpdatedAllParams: () => updatedParams,
 *     updateGridRows: (rows) => console.log(`Grid Rows Updated: ${rows}`),
 *     updateGridCols: (cols) => console.log(`Grid Cols Updated: ${cols}`),
 *     updateAltGridRows: (rows) => console.log(`Alt Grid Rows Updated: ${rows}`),
 *     updateAltGridCols: (cols) => console.log(`Alt Grid Cols Updated: ${cols}`),
 *     updateGridSizes: (sizes) => console.log(`Grid Sizes Updated: ${JSON.stringify(sizes)}`),
 *     gridSizes: { gridWidth: 100, gridHeight: 100 },
 *     paginationDirection: 'horizontal',
 *     paginationHeightWidth: 50,
 *     doPaginate: true,
 *     componentSizes: { otherWidth: 800, otherHeight: 600 },
 *     eventType: 'chat',
 *   },
 * };
 *
 * const miniCardGridService = new UpdateMiniCardsGrid();
 * miniCardGridService.updateMiniCardsGrid(gridOptions);
 * ```
 */
class UpdateMiniCardsGrid {
    /**
     * Updates the mini cards grid based on the specified rows and columns.
     *
     * @param {object} options - The function parameters.
     * @param {number} options.rows - The number of rows in the grid.
     * @param {number} options.cols - The number of columns in the grid.
     * @param {boolean} options.defal - Flag indicating whether to update the default grid or an alternative grid.
     * @param {number} options.actualRows - The actual number of rows in the grid.
     * @param {number} options.ind - The index parameter.
     * @param {object} options.parameters - Additional parameters needed for the function.
     * @param {function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {function} options.parameters.updateGridRows - Function to update the grid rows.
     * @param {function} options.parameters.updateGridCols - Function to update the grid columns.
     * @param {function} options.parameters.updateAltGridRows - Function to update the alternative grid rows.
     * @param {function} options.parameters.updateAltGridCols - Function to update the alternative grid columns.
     * @param {function} options.parameters.updateGridSizes - Function to update the grid sizes.
     * @param {object} options.parameters.gridSizes - Object containing grid width and height.
     * @param {string} options.parameters.paginationDirection - The direction of pagination ('horizontal' or 'vertical').
     * @param {number} options.parameters.paginationHeightWidth - The height or width of pagination.
     * @param {boolean} options.parameters.doPaginate - Flag indicating whether pagination is enabled.
     * @param {object} options.parameters.componentSizes - Object containing container width and height.
     * @param {string} options.parameters.eventType - The type of event ('chat', etc.).
     * @returns {Promise<void>} - A Promise that resolves after updating the mini cards grid.
     */
    async updateMiniCardsGrid({ rows, cols, defal = true, actualRows = 2, parameters, }) {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { updateGridRows, updateGridCols, updateAltGridRows, updateAltGridCols, updateGridSizes, gridSizes, paginationDirection, paginationHeightWidth, doPaginate, componentSizes, eventType, } = parameters;
        let containerWidth = componentSizes.otherWidth;
        let containerHeight = componentSizes.otherHeight;
        if (doPaginate) {
            // if pagination is enabled and direction is horizontal
            if (paginationDirection == 'horizontal') {
                containerHeight = containerHeight - paginationHeightWidth;
            }
            else {
                containerWidth = containerWidth - paginationHeightWidth;
            }
        }
        let cardSpacing = 3; // 3px margin between cards
        if (eventType == 'chat') {
            cardSpacing = 0;
        }
        let totalSpacingHorizontal = (cols - 1) * cardSpacing;
        let totalSpacingVertical = (actualRows - 1) * cardSpacing;
        let cardWidth;
        let cardHeight;
        if (cols == 0 || actualRows == 0) {
            cardWidth = 0;
            cardHeight = 0;
        }
        else {
            cardWidth = Math.floor((containerWidth - totalSpacingHorizontal) / cols);
            cardHeight = Math.floor((containerHeight - totalSpacingVertical) / actualRows);
        }
        if (defal) {
            updateGridRows(rows);
            updateGridCols(cols);
            gridSizes = { ...gridSizes, gridWidth: cardWidth, gridHeight: cardHeight };
            updateGridSizes(gridSizes);
        }
        else {
            updateAltGridRows(rows);
            updateAltGridCols(cols);
            gridSizes = { ...gridSizes, altGridWidth: cardWidth, altGridHeight: cardHeight };
            updateGridSizes(gridSizes);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateMiniCardsGrid, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateMiniCardsGrid, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateMiniCardsGrid, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Updates or adds a participant's audio decibel data in the array.
 *
 * This method checks if a participant's name exists in the audio decibels array.
 * If it does, it updates the participant's `averageLoudness`; otherwise, it adds a new entry.
 * After modification, it calls `updateAudioDecibels` to apply the changes to the array.
 *
 * @param {UpdateParticipantAudioDecibelsOptions} options - The options for updating participant audio decibels.
 * @param {string} options.name - The name of the participant.
 * @param {number} options.averageLoudness - The current average loudness of the participant.
 * @param {AudioDecibels[]} options.audioDecibels - The array of current audio decibel entries.
 * @param {Function} options.updateAudioDecibels - The function to update the audio decibels array.
 *
 * @returns {void} - This function does not return a value.
 *
 * @example
 * ```typescript
 * const audioDecibels = [
 *   { name: 'Alice', averageLoudness: -10 },
 *   { name: 'Bob', averageLoudness: -12 },
 * ];
 *
 * const updateAudioDecibels = (newDecibels) => {
 *   console.log('Updated audio decibels:', newDecibels);
 * };
 *
 * const updateService = new UpdateParticipantAudioDecibels();
 *
 * // Update existing participant
 * updateService.updateParticipantAudioDecibels({
 *   name: 'Alice',
 *   averageLoudness: -8,
 *   audioDecibels,
 *   updateAudioDecibels,
 * });
 *
 * // Add a new participant
 * updateService.updateParticipantAudioDecibels({
 *   name: 'Charlie',
 *   averageLoudness: -15,
 *   audioDecibels,
 *   updateAudioDecibels,
 * });
 * ```
 */
class UpdateParticipantAudioDecibels {
    /**
     * Updates the audio decibels for a participant.
     *
     * @param {Object} options - The options for updating participant audio decibels.
     * @param {string} options.name - The name of the participant.
     * @param {number} options.averageLoudness - The average loudness of the participant.
     * @param {Array<{ name: string, averageLoudness: number }>} options.audioDecibels - The array of audio decibels entries.
     * @param {Function} options.updateAudioDecibels - The function to update the audio decibels array.
     *
     * @returns {void}
     */
    updateParticipantAudioDecibels({ name, averageLoudness, audioDecibels, updateAudioDecibels, }) {
        // Function to update the audioDecibels array
        // Check if the entry already exists in audioDecibels
        const existingEntry = audioDecibels.find((entry) => entry.name === name);
        if (existingEntry) {
            // Entry exists, update the averageLoudness
            existingEntry.averageLoudness = averageLoudness;
        }
        else {
            // Entry doesn't exist, add a new entry to audioDecibels
            audioDecibels.push({ name, averageLoudness });
        }
        // Update the audioDecibels array
        updateAudioDecibels(audioDecibels);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateParticipantAudioDecibels, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateParticipantAudioDecibels, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateParticipantAudioDecibels, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * The `AParams` service provides the encoding parameters for audio production in a media session using the Mediasoup library.
 * It includes a default configuration for RTP encoding parameters, which can be used when creating audio producers.
 *
 * @service
 * @example
 * ```typescript
 * import { AParams } from './path/to/a-params.service';
 *
 * constructor(private aParamsService: AParams) {
 *   console.log(this.aParamsService.aParams);
 * }
 * ```
 *
 * @typedef AParamsType
 * @property {RtpEncodingParameters[]} encodings - Array of RTP encoding parameters for audio.
 * @property {ProducerCodecOptions} [codecOptions] - Optional codec options for the audio producer.
 *
 * @example
 * const aParams: AParamsType = {
 *   encodings: [
 *     {
 *       rid: 'r0',
 *       maxBitrate: 64000, // Max bitrate for the audio stream (in bps)
 *     },
 *   ],
 *   codecOptions: {
 *     // Additional codec options can be defined here
 *   },
 * };
 *
 * @remarks
 * The default `aParams` contains a single encoding with a `rid` of "r0" and a maximum bitrate of 64 kbps.
 * This configuration can be adjusted based on application requirements.
 *
 * @returns {AParamsType} The audio parameters for use in audio producer configuration.
 */
class AParams {
    aParams = {
        encodings: [
            {
                rid: 'r0',
                maxBitrate: 64000,
            },
        ],
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AParams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AParams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AParams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * The `HParams` service provides encoding parameters for video production in a media session using the Mediasoup library.
 * It includes a default configuration for RTP encoding parameters designed for handling high-quality video streams.
 *
 * @service
 * @example
 * ```typescript
 * import { HParams } from './path/to/h-params.service';
 *
 * constructor(private hParamsService: HParams) {
 *   console.log(this.hParamsService.hParams);
 * }
 * ```
 *
 * @typedef HParamsType
 * @property {RtpEncodingParameters[]} encodings - Array of RTP encoding parameters for video.
 * @property {ProducerCodecOptions} [codecOptions] - Optional codec options for the video producer.
 *
 * @example
 * const hParams: HParamsType = {
 *   encodings: [
 *     {
 *       rid: 'r8',
 *       maxBitrate: 240000, // Max bitrate for this encoding (in bps)
 *       scalabilityMode: 'L1T3', // Scalable video coding mode
 *       scaleResolutionDownBy: 4.0, // Scale down the resolution by a factor of 4
 *     },
 *     {
 *       rid: 'r9',
 *       maxBitrate: 480000,
 *       scalabilityMode: 'L1T3',
 *       scaleResolutionDownBy: 2.0, // Scale down the resolution by a factor of 2
 *     },
 *     {
 *       rid: 'r10',
 *       maxBitrate: 960000,
 *       scalabilityMode: 'L1T3',
 *     },
 *   ],
 *   codecOptions: {
 *     videoGoogleStartBitrate: 320, // Initial bitrate for the Google codec
 *   },
 * };
 *
 * @remarks
 * The default `hParams` includes three encoding configurations with different resolutions and bitrates.
 * The configurations are optimized for scalable video encoding, allowing for adaptive bitrate streaming based on network conditions.
 *
 * @returns {HParamsType} The video parameters for use in video producer configuration.
 */
class HParams {
    hParams = {
        encodings: [
            {
                rid: 'r8',
                maxBitrate: 240000,
                scalabilityMode: 'L1T3',
                scaleResolutionDownBy: 4.0,
            },
            {
                rid: 'r9',
                maxBitrate: 480000,
                scalabilityMode: 'L1T3',
                scaleResolutionDownBy: 2.0,
            },
            {
                rid: 'r10',
                maxBitrate: 960000,
                scalabilityMode: 'L1T3',
            },
        ],
        codecOptions: {
            videoGoogleStartBitrate: 320,
        },
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HParams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HParams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HParams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * The `ScreenParams` service provides encoding parameters specifically for screen sharing in a media session using the Mediasoup library.
 * It includes a default configuration for RTP encoding parameters optimized for high-quality screen sharing.
 *
 * @service
 * @example
 * ```typescript
 * import { ScreenParams } from './path/to/screen-params.service';
 *
 * constructor(private screenParamsService: ScreenParams) {
 *   console.log(this.screenParamsService.screenParams);
 * }
 * ```
 *
 * @typedef ScreenParamsType
 * @property {RtpEncodingParameters[]} encodings - Array of RTP encoding parameters for screen sharing.
 * @property {ProducerCodecOptions} [codecOptions] - Optional codec options for the screen sharing producer.
 *
 * @example
 * const screenParams: ScreenParamsType = {
 *   encodings: [
 *     {
 *       rid: 'r7',
 *       maxBitrate: 3000000, // Max bitrate for this encoding (in bps)
 *     },
 *   ],
 *   codecOptions: {
 *     videoGoogleStartBitrate: 1000, // Initial bitrate for the Google codec
 *   },
 * };
 *
 * @remarks
 * The default `screenParams` includes one encoding configuration with a high maximum bitrate suitable for sharing detailed screen content.
 * The parameters are optimized to ensure a smooth experience during screen sharing sessions.
 *
 * @returns {ScreenParamsType} The screen sharing parameters for use in screen sharing producer configuration.
 */
class ScreenParams {
    screenParams = {
        encodings: [
            {
                rid: 'r7',
                maxBitrate: 3000000,
            },
        ],
        codecOptions: {
            videoGoogleStartBitrate: 1000,
        },
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ScreenParams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ScreenParams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ScreenParams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * The `VParams` service provides encoding parameters for video in a media session using the Mediasoup library.
 * It includes a default configuration for RTP encoding parameters optimized for video streaming.
 *
 * @service
 * @example
 * ```typescript
 * import { VParams } from './path/to/v-params.service';
 *
 * constructor(private vParamsService: VParams) {
 *   console.log(this.vParamsService.vParams);
 * }
 * ```
 *
 * @typedef VParamsType
 * @property {RtpEncodingParameters[]} encodings - Array of RTP encoding parameters for video.
 * @property {ProducerCodecOptions} [codecOptions] - Optional codec options for the video producer.
 *
 * @example
 * const vParams: VParamsType = {
 *   encodings: [
 *     {
 *       rid: 'r3',
 *       maxBitrate: 200000, // Max bitrate for this encoding (in bps)
 *       scalabilityMode: 'L1T3', // Scalability mode for encoding
 *       scaleResolutionDownBy: 4.0, // Scale down resolution by this factor
 *     },
 *     {
 *       rid: 'r4',
 *       maxBitrate: 400000,
 *       scalabilityMode: 'L1T3',
 *       scaleResolutionDownBy: 2.0,
 *     },
 *     {
 *       rid: 'r5',
 *       maxBitrate: 800000,
 *       scalabilityMode: 'L1T3',
 *     },
 *   ],
 *   codecOptions: {
 *     videoGoogleStartBitrate: 320, // Initial bitrate for the Google codec
 *   },
 * };
 *
 * @remarks
 * The default `vParams` includes multiple encoding configurations with different maximum bitrates,
 * allowing for adaptive streaming based on network conditions and participant capabilities.
 *
 * @returns {VParamsType} The video parameters for use in video producer configuration.
 */
class VParams {
    vParams = {
        encodings: [
            {
                rid: 'r3',
                maxBitrate: 200000,
                scalabilityMode: 'L1T3',
                scaleResolutionDownBy: 4.0,
            },
            {
                rid: 'r4',
                maxBitrate: 400000,
                scalabilityMode: 'L1T3',
                scaleResolutionDownBy: 2.0,
            },
            {
                rid: 'r5',
                maxBitrate: 800000,
                scalabilityMode: 'L1T3',
            },
        ],
        codecOptions: {
            videoGoogleStartBitrate: 320,
        },
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: VParams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: VParams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: VParams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Toggles the visibility of the background modal.
 *
 * This method updates the visibility state of the background modal by calling
 * the provided update function with the negation of the current visibility state.
 *
 * @param {LaunchBackgroundOptions} options - The options object containing necessary variables and functions.
 * @param {Function} options.updateIsBackgroundModalVisible - Function to update the visibility state of the background modal.
 * @param {boolean} options.isBackgroundModalVisible - Current visibility state of the background modal.
 *
 * @returns {void}
 *
 * @example
 * ```typescript
 * const options = {
 *   updateIsBackgroundModalVisible: (isVisible) => {
 *     console.log(`Background modal is now ${isVisible ? 'visible' : 'hidden'}.`);
 *   },
 *   isBackgroundModalVisible: false,
 * };
 *
 * const launchBackgroundService = new LaunchBackground();
 * launchBackgroundService.launchBackground(options);
 * ```
 */
class LaunchBackground {
    /**
     * Toggles the visibility of the background modal.
     * @function
     * @param {Object} options - The options object containing necessary variables and functions.
     * @param {Function} options.updateIsBackgroundModalVisible - Function to update the visibility state of the background modal.
     * @param {boolean} options.isBackgroundModalVisible - Current visibility state of the background modal.
     */
    launchBackground({ updateIsBackgroundModalVisible, isBackgroundModalVisible, }) {
        updateIsBackgroundModalVisible(!isBackgroundModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchBackground, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchBackground, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchBackground, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Launches the breakout rooms by toggling the visibility of the breakout rooms modal.
 *
 * This method is used to show or hide the breakout rooms modal based on the current visibility state.
 *
 * @param {LaunchBreakoutRoomsOptions} options - The options object containing necessary variables and functions.
 * @param {Function} options.updateIsBreakoutRoomsModalVisible - Function to update the visibility state of the breakout rooms modal.
 * @param {boolean} options.isBreakoutRoomsModalVisible - Current visibility state of the breakout rooms modal.
 *
 * @returns {void}
 *
 * @example
 * ```typescript
 * const options: LaunchBreakoutRoomsOptions = {
 *   updateIsBreakoutRoomsModalVisible: (isVisible) => {
 *     console.log('Breakout Rooms Modal is now:', isVisible ? 'Visible' : 'Hidden');
 *   },
 *   isBreakoutRoomsModalVisible: false,
 * };
 *
 * const launchBreakoutRoomsService = new LaunchBreakoutRooms();
 * launchBreakoutRoomsService.launchBreakoutRooms(options);
 * ```
 */
class LaunchBreakoutRooms {
    /**
     * Launches the breakout rooms by toggling the visibility of the breakout rooms modal.
     *
     * @param updateIsBreakoutRoomsModalVisible - Function to update the visibility state of the breakout rooms modal.
     * @param isBreakoutRoomsModalVisible - Current visibility state of the breakout rooms modal.
     */
    launchBreakoutRooms({ updateIsBreakoutRoomsModalVisible, isBreakoutRoomsModalVisible, }) {
        updateIsBreakoutRoomsModalVisible(!isBreakoutRoomsModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchBreakoutRooms, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchBreakoutRooms, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchBreakoutRooms, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Updates the state of breakout rooms based on the provided data and parameters.
 *
 * This method handles changes in breakout rooms, updates the relevant state variables,
 * and triggers necessary UI updates based on the current status of the breakout rooms.
 *
 * @param {BreakoutRoomUpdatedOptions} options - The options object containing the data and parameters.
 * @param {BreakoutRoomUpdatedData} options.data - The data object containing information about the breakout rooms.
 * @param {BreakoutRoomUpdatedParameters} options.parameters - The parameters object containing various state update functions and other parameters.
 * @param {boolean} options.parameters.breakOutRoomStarted - Indicates if the breakout room has started.
 * @param {boolean} options.parameters.breakOutRoomEnded - Indicates if the breakout room has ended.
 * @param {Array<BreakoutParticipant[]>} options.parameters.breakoutRooms - The list of current breakout rooms.
 * @param {number} options.parameters.hostNewRoom - The ID of the new room for the host.
 * @param {string} options.parameters.islevel - The level of the breakout room (e.g., '2' for host).
 * @param {Array<Participant>} options.parameters.participantsAll - The list of all participants.
 * @param {Array<Participant>} options.parameters.participants - The list of participants who are not banned.
 * @param {string} options.parameters.meetingDisplayType - The current display type of the meeting.
 * @param {string} options.parameters.prevMeetingDisplayType - The previous display type of the meeting.
 * @param {Function} options.parameters.updateBreakoutRooms - Function to update the breakout rooms.
 * @param {Function} options.parameters.updateBreakOutRoomStarted - Function to update the breakout room started state.
 * @param {Function} options.parameters.updateBreakOutRoomEnded - Function to update the breakout room ended state.
 * @param {Function} options.parameters.updateHostNewRoom - Function to update the host's new room.
 * @param {Function} options.parameters.updateMeetingDisplayType - Function to update the meeting display type.
 * @param {Function} options.parameters.updateParticipantsAll - Function to update the list of all participants.
 * @param {Function} options.parameters.updateParticipants - Function to update the list of participants who are not banned.
 * @param {Function} options.parameters.onScreenChanges - Function to handle screen changes.
 * @param {Function} options.parameters.rePort - Function to handle reporting.
 *
 * @returns {Promise<void>} A promise that resolves when the breakout room state has been updated.
 *
 * @throws Will throw an error if the update process fails.
 *
 * @example
 * ```typescript
 * const options = {
 *   data: {
 *     forHost: true,
 *     newRoom: 3,
 *     status: 'started',
 *     members: [
 *       { name: 'user1', isBanned: false, audioID: 'audio1', videoID: 'video1' },
 *       { name: 'user2', isBanned: true, audioID: 'audio2', videoID: 'video2' },
 *     ],
 *     breakoutRooms: [[{ name: 'user1' }, { name: 'user2' }]],
 *   },
 *   parameters: {
 *     socket: socketInstance,
 *     roomName: 'mainRoom',
 *     screenStates: [{ mainScreenPerson: 'user1', mainScreenFilled: true, adminOnMainScreen: false }],
 *     participants: [{ name: 'admin', islevel: '2' }],
 *     breakOutRoomStarted: false,
 *     breakOutRoomEnded: false,
 *     hostNewRoom: 0,
 *     islevel: '2',
 *     participantsAll: [],
 *     updateBreakoutRooms: (rooms) => {},
 *     updateBreakOutRoomStarted: (started) => {},
 *     updateBreakOutRoomEnded: (ended) => {},
 *     updateHostNewRoom: (room) => {},
 *     updateMeetingDisplayType: (type) => {},
 *     updateParticipantsAll: (participants) => {},
 *     updateParticipants: (participants) => {},
 *     onScreenChanges: async () => {},
 *     rePort: async () => {},
 *   },
 * };
 *
 * const breakoutRoomService = new BreakoutRoomUpdated();
 * await breakoutRoomService.breakoutRoomUpdated(options);
 * ```
 */
class BreakoutRoomUpdated {
    /**
     * Updates the state of breakout rooms based on the provided data and parameters.
     *
     * @param {Object} options - The options object.
     * @param {Object} options.data - The data object containing information about the breakout rooms.
     * @param {Object} options.parameters - The parameters object containing various state update functions and other parameters.
     * @param {boolean} options.parameters.breakOutRoomStarted - Indicates if the breakout room has started.
     * @param {boolean} options.parameters.breakOutRoomEnded - Indicates if the breakout room has ended.
     * @param {Array} options.parameters.breakoutRooms - The list of current breakout rooms.
     * @param {number} options.parameters.hostNewRoom - The ID of the new room for the host.
     * @param {string} options.parameters.islevel - The level of the breakout room.
     * @param {Array} options.parameters.participantsAll - The list of all participants.
     * @param {Array} options.parameters.participants - The list of participants who are not banned.
     * @param {string} options.parameters.meetingDisplayType - The current display type of the meeting.
     * @param {string} options.parameters.prevMeetingDisplayType - The previous display type of the meeting.
     * @param {Function} options.parameters.updateBreakoutRooms - Function to update the breakout rooms.
     * @param {Function} options.parameters.updateBreakOutRoomStarted - Function to update the breakout room started state.
     * @param {Function} options.parameters.updateBreakOutRoomEnded - Function to update the breakout room ended state.
     * @param {Function} options.parameters.updateHostNewRoom - Function to update the host's new room.
     * @param {Function} options.parameters.updateMeetingDisplayType - Function to update the meeting display type.
     * @param {Function} options.parameters.updateParticipantsAll - Function to update the list of all participants.
     * @param {Function} options.parameters.updateParticipants - Function to update the list of participants who are not banned.
     * @param {Function} options.parameters.onScreenChanges - Function to handle screen changes.
     * @param {Function} options.parameters.rePort - Function to handle reporting.
     *
     * @returns {Promise<void>} A promise that resolves when the breakout room state has been updated.
     *
     * @throws Will throw an error if the update process fails.
     */
    breakoutRoomUpdated = async ({ data, parameters }) => {
        try {
            parameters = parameters.getUpdatedAllParams();
            let { breakOutRoomStarted, breakOutRoomEnded, breakoutRooms, islevel, participantsAll, participants, updateBreakoutRooms, updateBreakOutRoomStarted, updateBreakOutRoomEnded, updateHostNewRoom, updateMeetingDisplayType, meetingDisplayType, prevMeetingDisplayType, updateParticipantsAll, updateParticipants, 
            //mediaSfu functions
            onScreenChanges, rePort, } = parameters;
            if (data.forHost) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                updateHostNewRoom(data.newRoom);
                await onScreenChanges({ changed: true, parameters });
                return;
            }
            if (islevel == '2' && data.members) {
                //filter out the participant that isBanned == true
                participantsAll = data.members;
                //remove every field other than isBanned and name from participantsAll
                participantsAll = data.members.map((participant) => ({
                    isBanned: participant.isBanned,
                    name: participant.name,
                    audioID: participant.audioID,
                    videoID: participant.videoID,
                }));
                updateParticipantsAll(participantsAll);
                participants = data.members.filter((participant) => participant.isBanned == false);
                updateParticipants(participants);
            }
            breakoutRooms = data.breakoutRooms || [];
            updateBreakoutRooms(breakoutRooms);
            if (data.status == 'started' && (breakOutRoomStarted || !breakOutRoomEnded)) {
                breakOutRoomStarted = true;
                breakOutRoomEnded = false;
                updateBreakOutRoomStarted(true);
                updateBreakOutRoomEnded(false);
                prevMeetingDisplayType = meetingDisplayType;
                if (meetingDisplayType != 'all') {
                    meetingDisplayType = 'all';
                    updateMeetingDisplayType('all');
                }
                await onScreenChanges({ changed: true, parameters });
                if (islevel == '2') {
                    await rePort({ restart: true, parameters });
                }
            }
            else if (data.status == 'ended') {
                breakOutRoomEnded = true;
                updateBreakOutRoomEnded(true);
                if (meetingDisplayType != prevMeetingDisplayType) {
                    meetingDisplayType = prevMeetingDisplayType;
                    updateMeetingDisplayType(prevMeetingDisplayType);
                }
                await onScreenChanges({ changed: true, parameters });
                if (islevel == '2') {
                    await rePort({ restart: true, parameters });
                }
            }
            else if (data.status == 'started' && breakOutRoomStarted) {
                breakOutRoomStarted = true;
                breakOutRoomEnded = false;
                updateBreakOutRoomStarted(true);
                updateBreakOutRoomEnded(false);
                await onScreenChanges({ changed: true, parameters });
                if (islevel == '2') {
                    await rePort({ restart: true, parameters });
                }
            }
        }
        catch (error) {
            // console.log('Error updating breakout room:', error.message);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: BreakoutRoomUpdated, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: BreakoutRoomUpdated, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: BreakoutRoomUpdated, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Toggles the visibility of the co-host modal.
 *
 * This method is used to show or hide the co-host modal based on the current visibility state.
 *
 * @param {LaunchCoHostOptions} options - The options object containing necessary variables and functions.
 * @param {Function} options.updateIsCoHostModalVisible - Function to update the visibility state of the co-host modal.
 * @param {boolean} options.isCoHostModalVisible - Current visibility state of the co-host modal.
 *
 * @returns {void}
 *
 * @example
 * ```typescript
 * const options: LaunchCoHostOptions = {
 *   updateIsCoHostModalVisible: (isVisible) => {
 *     console.log('Co-Host Modal is now:', isVisible ? 'Visible' : 'Hidden');
 *   },
 *   isCoHostModalVisible: false,
 * };
 *
 * const launchCoHostService = new launchCoHost();
 * launchCoHostService.launchCoHost(options);
 * ```
 */
class launchCoHost {
    /**
     * Toggles the visibility of the co-host modal.
     *
     * @param updateIsCoHostModalVisible - Function to update the visibility state of the co-host modal.
     * @param isCoHostModalVisible - Current visibility state of the co-host modal.
     */
    launchCoHost({ updateIsCoHostModalVisible, isCoHostModalVisible }) {
        updateIsCoHostModalVisible(!isCoHostModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: launchCoHost, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: launchCoHost, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: launchCoHost, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// This method is used to modify the co-host settings in the chat room.
/**
 * Modifies the co-host settings for a given room.
 *
 * This method allows you to update the co-host for a chat room, set their responsibilities,
 * and emit the relevant changes to the server. It also handles demo mode restrictions.
 *
 * @param {ModifyCoHostSettingsOptions} options - The options for modifying co-host settings.
 * @param {string} options.roomName - The name of the room.
 * @param {Function} options.showAlert - Function to show an alert message.
 * @param {string} options.selectedParticipant - The participant selected to be co-host.
 * @param {string} options.coHost - The current co-host.
 * @param {Array<CoHostResponsibility>} options.coHostResponsibility - The responsibilities assigned to the co-host.
 * @param {Function} options.updateIsCoHostModalVisible - Function to update the visibility of the co-host modal.
 * @param {Function} options.updateCoHostResponsibility - Function to update the co-host responsibility.
 * @param {Function} options.updateCoHost - Function to update the co-host.
 * @param {Socket} options.socket - The socket instance for emitting events.
 *
 * @returns {Promise<void>} A promise that resolves when the co-host settings have been modified.
 *
 * @remarks
 * - If the room is in demo mode (room name starts with "d"), co-host cannot be added and an alert is shown.
 * - If a valid participant is selected, they are set as the new co-host.
 * - The co-host responsibility is updated.
 * - A socket event is emitted to update the co-host information.
 * - The co-host modal is closed after updating the settings.
 *
 * @example
 * ```typescript
 * const options: ModifyCoHostSettingsOptions = {
 *   roomName: 'mainRoom',
 *   showAlert: (alert) => console.log(alert.message),
 *   selectedParticipant: 'JohnDoe',
 *   coHost: 'No coHost',
 *   coHostResponsibility: ['manage participants', 'start/stop recording'],
 *   updateIsCoHostModalVisible: (isVisible) => console.log('Co-host modal visible:', isVisible),
 *   updateCoHostResponsibility: (responsibility) => console.log('Updated co-host responsibility:', responsibility),
 *   updateCoHost: (coHost) => console.log('New co-host:', coHost),
 *   socket: socketInstance,
 * };
 *
 * const modifyCoHostService = new ModifyCoHostSettings();
 * await modifyCoHostService.modifyCoHostSettings(options);
 * ```
 */
class ModifyCoHostSettings {
    /**
     * Modifies the co-host settings for a given room.
     *
     * @param {Object} options - The options for modifying co-host settings.
     * @param {string} options.roomName - The name of the room.
     * @param {Function} options.showAlert - Function to show an alert message.
     * @param {string} options.selectedParticipant - The participant selected to be co-host.
     * @param {string} options.coHost - The current co-host.
     * @param {string} options.coHostResponsibility - The responsibility assigned to the co-host.
     * @param {Function} options.updateIsCoHostModalVisible - Function to update the visibility of the co-host modal.
     * @param {Function} options.updateCoHostResponsibility - Function to update the co-host responsibility.
     * @param {Function} options.updateCoHost - Function to update the co-host.
     * @param {Object} options.socket - The socket instance for emitting events.
     * @returns {Promise<void>} A promise that resolves when the co-host settings have been modified.
     *
     * @remarks
     * - If the room is in demo mode (room name starts with "d"), co-host cannot be added and an alert is shown.
     * - If a valid participant is selected, they are set as the new co-host.
     * - The co-host responsibility is updated.
     * - A socket event is emitted to update the co-host information.
     * - The co-host modal is closed after updating the settings.
     */
    async modifyCoHostSettings({ roomName, showAlert, selectedParticipant, coHost, coHostResponsibility, updateIsCoHostModalVisible, updateCoHostResponsibility, updateCoHost, socket, }) {
        // Check if the chat room is in demo mode
        if (roomName.toLowerCase().startsWith('d')) {
            showAlert?.({
                message: 'You cannot add co-host in demo mode.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        let newCoHost = coHost;
        if (coHost != 'No coHost' ||
            (selectedParticipant && selectedParticipant != 'Select a participant')) {
            if (selectedParticipant && selectedParticipant != 'Select a participant') {
                newCoHost = selectedParticipant;
                updateCoHost(newCoHost);
            }
            updateCoHostResponsibility(coHostResponsibility);
            // Emit a socket event to update co-host information
            socket.emit('updateCoHost', { roomName, coHost: newCoHost, coHostResponsibility });
        }
        // Close the co-host modal
        updateIsCoHostModalVisible(false);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ModifyCoHostSettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ModifyCoHostSettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ModifyCoHostSettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// display-settings.service.ts
/**
 * Toggles the visibility of the display settings modal.
 *
 * This method allows you to show or hide the display settings modal by updating its visibility state.
 *
 * @param {LaunchDisplaySettingsOptions} options - The options for launching the display settings.
 * @param {Function} options.updateIsDisplaySettingsModalVisible - Function to update the visibility state of the display settings modal.
 * @param {boolean} options.isDisplaySettingsModalVisible - Current visibility state of the display settings modal.
 *
 * @returns {void}
 *
 * @example
 * ```typescript
 * const options: LaunchDisplaySettingsOptions = {
 *   updateIsDisplaySettingsModalVisible: (isVisible) => console.log('Display settings modal is now:', isVisible),
 *   isDisplaySettingsModalVisible: false,
 * };
 *
 * const launchDisplaySettingsService = new LaunchDisplaySettings();
 * launchDisplaySettingsService.launchDisplaySettings(options);
 * ```
 */
class LaunchDisplaySettings {
    /**
     * Toggles the visibility of the display settings modal.
     *
     * @param updateIsDisplaySettingsModalVisible - Function to update the visibility state of the display settings modal.
     * @param isDisplaySettingsModalVisible - Current visibility state of the display settings modal.
     */
    launchDisplaySettings({ updateIsDisplaySettingsModalVisible, isDisplaySettingsModalVisible, }) {
        // Toggle the visibility of the display settings modal.
        updateIsDisplaySettingsModalVisible(!isDisplaySettingsModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchDisplaySettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchDisplaySettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchDisplaySettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Modifies the display settings based on the provided parameters.
 *
 * This method updates the display settings for the meeting based on the participant's level,
 * recording status, and other conditions. It validates display types and shows alerts
 * when necessary. It also handles the display settings for breakout rooms.
 *
 * @param {ModifyDisplaySettingsOptions} options - The options containing the parameters to modify the display settings.
 * @param {Object} options.parameters - The parameters for modifying the display settings.
 * @param {Function} options.parameters.showAlert - Function to show alert messages.
 * @param {string} options.parameters.meetingDisplayType - The current meeting display type.
 * @param {boolean} options.parameters.autoWave - Flag indicating if auto wave is enabled.
 * @param {boolean} options.parameters.forceFullDisplay - Flag indicating if full display is forced.
 * @param {boolean} options.parameters.meetingVideoOptimized - Flag indicating if the meeting video is optimized.
 * @param {string} options.parameters.islevel - The current level of the meeting.
 * @param {boolean} options.parameters.recordStarted - Flag indicating if recording has started.
 * @param {boolean} options.parameters.recordResumed - Flag indicating if recording has resumed.
 * @param {boolean} options.parameters.recordStopped - Flag indicating if recording has stopped.
 * @param {boolean} options.parameters.recordPaused - Flag indicating if recording is paused.
 * @param {string} options.parameters.recordingDisplayType - The current recording display type.
 * @param {boolean} options.parameters.recordingVideoOptimized - Flag indicating if the recording video is optimized.
 * @param {string} options.parameters.prevForceFullDisplay - The previous force full display value.
 * @param {string} options.parameters.prevMeetingDisplayType - The previous meeting display type.
 * @param {Function} options.parameters.updateMeetingDisplayType - Function to update the meeting display type.
 * @param {Function} options.parameters.updateAutoWave - Function to update the auto wave setting.
 * @param {Function} options.parameters.updateForceFullDisplay - Function to update the force full display setting.
 * @param {Function} options.parameters.updateMeetingVideoOptimized - Function to update the meeting video optimization setting.
 * @param {Function} options.parameters.updatePrevForceFullDisplay - Function to update the previous force full display setting.
 * @param {Function} options.parameters.updatePrevMeetingDisplayType - Function to update the previous meeting display type.
 * @param {Function} options.parameters.updateIsDisplaySettingsModalVisible - Function to update the visibility of the display settings modal.
 * @param {Function} options.parameters.updateFirstAll - Function to update the first all setting.
 * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
 * @param {boolean} options.parameters.breakOutRoomStarted - Flag indicating if a breakout room has started.
 * @param {boolean} options.parameters.breakOutRoomEnded - Flag indicating if a breakout room has ended.
 * @param {Function} options.parameters.onScreenChanges - Function to handle screen changes.
 *
 * @returns {Promise<void>} A promise that resolves when the display settings have been modified.
 *
 * @example
 * ```typescript
 * const options: ModifyDisplaySettingsOptions = {
 *   parameters: {
 *     showAlert: (alert) => console.log(alert.message),
 *     meetingDisplayType: 'video',
 *     autoWave: true,
 *     forceFullDisplay: false,
 *     meetingVideoOptimized: true,
 *     islevel: '1',
 *     recordStarted: false,
 *     recordResumed: false,
 *     recordStopped: false,
 *     recordPaused: false,
 *     recordingDisplayType: 'media',
 *     recordingVideoOptimized: false,
 *     prevForceFullDisplay: false,
 *     prevMeetingDisplayType: 'media',
 *     updateMeetingDisplayType: (type) => console.log('Updated display type:', type),
 *     updateAutoWave: (wave) => console.log('Updated auto wave:', wave),
 *     updateForceFullDisplay: (fullDisplay) => console.log('Updated force full display:', fullDisplay),
 *     updateMeetingVideoOptimized: (optimized) => console.log('Updated video optimization:', optimized),
 *     updatePrevForceFullDisplay: (fullDisplay) => console.log('Updated previous full display:', fullDisplay),
 *     updatePrevMeetingDisplayType: (type) => console.log('Updated previous display type:', type),
 *     updateIsDisplaySettingsModalVisible: (isVisible) => console.log('Display settings modal is now:', isVisible),
 *     updateFirstAll: (firstAll) => console.log('Updated first all:', firstAll),
 *     updateUpdateMainWindow: (update) => console.log('Updated main window:', update),
 *     breakOutRoomStarted: false,
 *     breakOutRoomEnded: false,
 *     onScreenChanges: async ({ changed, parameters }) => console.log('Screen changes:', changed),
 *   },
 * };
 *
 * const modifyDisplaySettingsService = new ModifyDisplaySettings();
 * await modifyDisplaySettingsService.modifyDisplaySettings(options);
 * ```
 */
class ModifyDisplaySettings {
    /**
     * Modifies the display settings based on the provided parameters.
     *
     * @param {ModifyDisplaySettingsOptions} options - The options containing the parameters to modify the display settings.
     * @param {Object} options.parameters - The parameters for modifying the display settings.
     * @param {Function} options.parameters.showAlert - Function to show alert messages.
     * @param {string} options.parameters.meetingDisplayType - The current meeting display type.
     * @param {boolean} options.parameters.autoWave - Flag indicating if auto wave is enabled.
     * @param {boolean} options.parameters.forceFullDisplay - Flag indicating if full display is forced.
     * @param {boolean} options.parameters.meetingVideoOptimized - Flag indicating if the meeting video is optimized.
     * @param {string} options.parameters.islevel - The current level of the meeting.
     * @param {boolean} options.parameters.recordStarted - Flag indicating if recording has started.
     * @param {boolean} options.parameters.recordResumed - Flag indicating if recording has resumed.
     * @param {boolean} options.parameters.recordStopped - Flag indicating if recording has stopped.
     * @param {boolean} options.parameters.recordPaused - Flag indicating if recording is paused.
     * @param {string} options.parameters.recordingDisplayType - The current recording display type.
     * @param {boolean} options.parameters.recordingVideoOptimized - Flag indicating if the recording video is optimized.
     * @param {string} options.parameters.prevForceFullDisplay - The previous force full display value.
     * @param {string} options.parameters.prevMeetingDisplayType - The previous meeting display type.
     * @param {Function} options.parameters.updateMeetingDisplayType - Function to update the meeting display type.
     * @param {Function} options.parameters.updateAutoWave - Function to update the auto wave setting.
     * @param {Function} options.parameters.updateForceFullDisplay - Function to update the force full display setting.
     * @param {Function} options.parameters.updateMeetingVideoOptimized - Function to update the meeting video optimization setting.
     * @param {Function} options.parameters.updatePrevForceFullDisplay - Function to update the previous force full display setting.
     * @param {Function} options.parameters.updatePrevMeetingDisplayType - Function to update the previous meeting display type.
     * @param {Function} options.parameters.updateIsDisplaySettingsModalVisible - Function to update the visibility of the display settings modal.
     * @param {Function} options.parameters.updateFirstAll - Function to update the first all setting.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
     * @param {boolean} options.parameters.breakOutRoomStarted - Flag indicating if a breakout room has started.
     * @param {boolean} options.parameters.breakOutRoomEnded - Flag indicating if a breakout room has ended.
     * @param {Function} options.parameters.onScreenChanges - Function to handle screen changes.
     *
     * @returns {Promise<void>} A promise that resolves when the display settings have been modified.
     */
    modifyDisplaySettings = async ({ parameters }) => {
        // Destructure the parameters
        let { showAlert, meetingDisplayType, autoWave, forceFullDisplay, meetingVideoOptimized, islevel, recordStarted, recordResumed, recordStopped, recordPaused, recordingDisplayType, recordingVideoOptimized, prevForceFullDisplay, prevMeetingDisplayType, updateMeetingDisplayType, updateAutoWave, updateForceFullDisplay, updateMeetingVideoOptimized, updatePrevForceFullDisplay, updatePrevMeetingDisplayType, updateIsDisplaySettingsModalVisible, updateFirstAll, updateUpdateMainWindow, breakOutRoomStarted, breakOutRoomEnded, onScreenChanges, } = parameters;
        // Update previous states
        updateAutoWave(autoWave);
        updateForceFullDisplay(forceFullDisplay);
        if (islevel === '2' && (recordStarted || recordResumed) && !recordStopped && !recordPaused) {
            if (recordingDisplayType === 'video' &&
                meetingDisplayType === 'video' &&
                meetingVideoOptimized &&
                !recordingVideoOptimized) {
                showAlert?.({
                    message: 'Meeting display type can be either video, media, or all when recording display type is non-optimized video.',
                    type: 'danger',
                    duration: 3000,
                });
                // Reset to previous values or handle as needed
                meetingDisplayType = recordingDisplayType;
                updateMeetingDisplayType(meetingDisplayType);
                meetingVideoOptimized = recordingVideoOptimized;
                updateMeetingVideoOptimized(meetingVideoOptimized);
                return;
            }
            else if (recordingDisplayType === 'media' && meetingDisplayType === 'video') {
                showAlert?.({
                    message: 'Meeting display type can be either media or all when recording display type is media.',
                    type: 'danger',
                    duration: 3000,
                });
                // Reset to previous values or handle as needed
                meetingDisplayType = recordingDisplayType;
                updateMeetingDisplayType(meetingDisplayType);
                return;
            }
            else if (recordingDisplayType === 'all' &&
                (meetingDisplayType === 'video' || meetingDisplayType === 'media')) {
                showAlert?.({
                    message: 'Meeting display type can be only all when recording display type is all.',
                    type: 'danger',
                    duration: 3000,
                });
                // Reset to previous values or handle as needed
                meetingDisplayType = recordingDisplayType;
                updateMeetingDisplayType(meetingDisplayType);
                return;
            }
        }
        updateMeetingDisplayType(meetingDisplayType);
        updateMeetingVideoOptimized(meetingVideoOptimized);
        // Close the modal or perform additional actions
        updateIsDisplaySettingsModalVisible(false);
        if (prevMeetingDisplayType !== meetingDisplayType ||
            prevForceFullDisplay !== forceFullDisplay) {
            if (breakOutRoomStarted && !breakOutRoomEnded && meetingDisplayType !== 'all') {
                showAlert?.({
                    message: 'Breakout room is active. Display type can only be all.',
                    type: 'danger',
                });
                meetingDisplayType = prevMeetingDisplayType;
                updateMeetingDisplayType(prevMeetingDisplayType);
                return;
            }
            updateFirstAll(meetingDisplayType !== 'all' ? true : false);
            updateUpdateMainWindow(true);
            await onScreenChanges({
                changed: true,
                parameters: { ...parameters, meetingDisplayType, forceFullDisplay },
            });
            updatePrevForceFullDisplay(forceFullDisplay);
            updatePrevMeetingDisplayType(meetingDisplayType);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ModifyDisplaySettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ModifyDisplaySettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ModifyDisplaySettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Toggles the visibility of the confirmation exit modal.
 *
 * This method updates the state of the confirmation exit modal by inverting its current visibility status.
 *
 * @param {LaunchConfirmExitOptions} options - The options for toggling the confirmation exit modal visibility.
 * @param {Function} options.updateIsConfirmExitModalVisible - Function to update the visibility state of the confirmation exit modal.
 * @param {boolean} options.isConfirmExitModalVisible - Current visibility state of the confirmation exit modal.
 *
 * @example
 * ```typescript
 * const launchConfirmExitService = new LaunchConfirmExit();
 * launchConfirmExitService.launchConfirmExit({
 *   updateIsConfirmExitModalVisible: (isVisible) => {
 *     console.log('Confirm exit modal is now:', isVisible ? 'Visible' : 'Hidden');
 *   },
 *   isConfirmExitModalVisible: false, // Initially not visible
 * });
 * ```
 */
class LaunchConfirmExit {
    /**
     * Toggles the visibility of the confirmation exit modal.
     *
     * @param updateIsConfirmExitModalVisible - Function to update the visibility state of the confirmation exit modal.
     * @param isConfirmExitModalVisible - Current visibility state of the confirmation exit modal.
     */
    launchConfirmExit({ updateIsConfirmExitModalVisible, isConfirmExitModalVisible, }) {
        updateIsConfirmExitModalVisible(!isConfirmExitModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchConfirmExit, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchConfirmExit, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchConfirmExit, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// confirm-exit.service.ts
/**
 * Confirms the exit of a member from a room and optionally bans them.
 *
 * This method emits a socket event to disconnect the specified member from the given room.
 * If the `ban` option is set to true, the member will be banned from rejoining the room.
 *
 * @param {ConfirmExitOptions} options - The options for confirming the exit.
 * @param {Socket} options.socket - The socket instance to emit the event.
 * @param {Socket} [options.localSocket] - The local socket instance to emit the event.
 * @param {string} options.member - The member who is exiting.
 * @param {string} options.roomName - The name of the room the member is exiting from.
 * @param {boolean} [options.ban=false] - Whether to ban the member from the room.
 * @returns {Promise<void>} A promise that resolves when the exit is confirmed.
 *
 * @example
 * ```typescript
 * const confirmExitService = new ConfirmExit();
 * await confirmExitService.confirmExit({
 *   socket: socketInstance,
 *   localSocket: localSocketInstance,
 *   member: 'JohnDoe',
 *   roomName: 'Room1',
 *   ban: true, // Optional: set to true if you want to ban the member
 * });
 * ```
 */
class ConfirmExit {
    /**
     * Confirms the exit of a member from a room and optionally bans them.
     *
     * @param {Object} options - The options for confirming the exit.
     * @param {Socket} options.socket - The socket instance to emit the event.
     * @param {Socket} [options.localSocket] - The local socket instance to emit the event.
     * @param {string} options.member - The member who is exiting.
     * @param {string} options.roomName - The name of the room the member is exiting from.
     * @param {boolean} [options.ban=false] - Whether to ban the member from the room.
     * @returns {Promise<void>} A promise that resolves when the exit is confirmed.
     */
    async confirmExit({ socket, localSocket, member, roomName, ban = false }) {
        // Emit a socket event to disconnect the user from the room
        socket.emit('disconnectUser', { member: member, roomName: roomName, ban: ban });
        if (localSocket && localSocket.id) {
            // Emit a local socket event to disconnect the user from the room
            localSocket.emit("disconnectUser", {
                member: member,
                roomName: roomName,
                ban: ban,
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfirmExit, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfirmExit, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfirmExit, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Launches the media settings modal and updates the available audio and video input devices.
 *
 * This method checks the current visibility of the media settings modal and, if it is not visible,
 * retrieves the list of available audio and video input devices. It then updates the state with
 * these devices and opens the modal. If the modal is already visible, it closes the modal.
 *
 * @param {LaunchMediaSettingsOptions} options - The options for launching media settings.
 * @param {Function} options.updateIsMediaSettingsModalVisible - Function to update the visibility state of the media settings modal.
 * @param {boolean} options.isMediaSettingsModalVisible - Current visibility state of the media settings modal.
 * @param {MediaDeviceInfo[]} options.audioInputs - Array to store available audio input devices.
 * @param {MediaDeviceInfo[]} options.videoInputs - Array to store available video input devices.
 * @param {Function} options.updateAudioInputs - Function to update the available audio input devices.
 * @param {Function} options.updateVideoInputs - Function to update the available video input devices.
 * @returns {Promise<void>} A promise that resolves when the media settings have been updated.
 *
 * @example
 * ```typescript
 * const launchMediaSettingsService = new LaunchMediaSettings();
 * launchMediaSettingsService.launchMediaSettings({
 *   updateIsMediaSettingsModalVisible: (isVisible) => {
 *     console.log('Media settings modal is now:', isVisible ? 'Visible' : 'Hidden');
 *   },
 *   isMediaSettingsModalVisible: false, // Initially not visible
 *   audioInputs: [],
 *   videoInputs: [],
 *   updateAudioInputs: (inputs) => {
 *     console.log('Available audio inputs:', inputs);
 *   },
 *   updateVideoInputs: (inputs) => {
 *     console.log('Available video inputs:', inputs);
 *   },
 * });
 * ```
 */
class LaunchMediaSettings {
    /**
     * Launches the media settings modal and updates the available audio and video input devices.
     *
     * @param {Object} options - The options for launching media settings.
     * @param {Function} options.updateIsMediaSettingsModalVisible - Function to update the visibility state of the media settings modal.
     * @param {boolean} options.isMediaSettingsModalVisible - Current visibility state of the media settings modal.
     * @param {MediaDeviceInfo[]} options.audioInputs - Array to store available audio input devices.
     * @param {MediaDeviceInfo[]} options.videoInputs - Array to store available video input devices.
     * @param {Function} options.updateAudioInputs - Function to update the available audio input devices.
     * @param {Function} options.updateVideoInputs - Function to update the available video input devices.
     * @returns {Promise<void>} A promise that resolves when the media settings have been updated.
     */
    async launchMediaSettings({ updateIsMediaSettingsModalVisible, isMediaSettingsModalVisible, audioInputs, videoInputs, updateAudioInputs, updateVideoInputs, }) {
        // Check if media settings modal is not visible and update available audio and video input devices
        if (!isMediaSettingsModalVisible) {
            try {
                // Get the list of all available media devices
                const devices = await navigator.mediaDevices.enumerateDevices();
                // Filter the devices to get only audio and video input devices
                videoInputs = devices.filter((device) => device.kind === 'videoinput');
                audioInputs = devices.filter((device) => device.kind === 'audioinput');
                // Update the available audio and video input devices
                updateVideoInputs(videoInputs);
                updateAudioInputs(audioInputs);
                // Open the media settings modal
                updateIsMediaSettingsModalVisible(true);
            }
            catch (error) {
                // Open the media settings modal
                updateIsMediaSettingsModalVisible(true);
            }
        }
        else {
            // Close the media settings modal
            updateIsMediaSettingsModalVisible(false);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchMediaSettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchMediaSettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchMediaSettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Toggles the visibility of the menu modal.
 *
 * This method updates the visibility state of the menu modal by calling the provided
 * function with the negated current visibility state. If the modal is currently visible,
 * it will be hidden, and vice versa.
 *
 * @param {LaunchMenuModalOptions} options - The options for launching the menu modal.
 * @param {Function} options.updateIsMenuModalVisible - Function to update the visibility state of the menu modal.
 * @param {boolean} options.isMenuModalVisible - Current visibility state of the menu modal.
 *
 * @example
 * ```typescript
 * const launchMenuModalService = new LaunchMenuModal();
 * launchMenuModalService.launchMenuModal({
 *   updateIsMenuModalVisible: (isVisible) => {
 *     console.log('Menu modal is now:', isVisible ? 'Visible' : 'Hidden');
 *   },
 *   isMenuModalVisible: false, // Initially not visible
 * });
 * ```
 */
class LaunchMenuModal {
    /**
     * Toggles the visibility of the menu modal.
     *
     * @param updateIsMenuModalVisible - Function to update the visibility state of the menu modal.
     * @param isMenuModalVisible - Current visibility state of the menu modal.
     */
    launchMenuModal({ updateIsMenuModalVisible, isMenuModalVisible }) {
        updateIsMenuModalVisible(!isMenuModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchMenuModal, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchMenuModal, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchMenuModal, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Toggles the visibility state of the messages modal.
 *
 * This method updates the visibility state of the messages modal by calling the provided
 * function with the negated current visibility state. If the modal is currently visible,
 * it will be closed; if it's hidden, it will be opened.
 *
 * @param {LaunchMessagesOptions} options - The options for launching the messages modal.
 * @param {Function} options.updateIsMessagesModalVisible - Function to update the visibility state of the messages modal.
 * @param {boolean} options.isMessagesModalVisible - Current visibility state of the messages modal.
 *
 * @example
 * ```typescript
 * const launchMessagesService = new LaunchMessages();
 * launchMessagesService.launchMessages({
 *   updateIsMessagesModalVisible: (visible) => {
 *     console.log('Messages modal is now:', visible ? 'Visible' : 'Hidden');
 *   },
 *   isMessagesModalVisible: false, // Initially not visible
 * });
 * ```
 */
class LaunchMessages {
    /**
     * Toggles the visibility state of the messages modal.
     * If the modal is currently visible, it will be closed. If it's hidden, it will be opened.
     *
     * @param updateIsMessagesModalVisible - Function to update the visibility state of the messages modal.
     * @param isMessagesModalVisible - Current visibility state of the messages modal.
     */
    launchMessages({ updateIsMessagesModalVisible, isMessagesModalVisible, }) {
        updateIsMessagesModalVisible(!isMessagesModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchMessages, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchMessages, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchMessages, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Sends a message to the specified room.
 *
 * This method validates the message and its recipients, checks user permissions,
 * and then emits the message to the server via a socket connection. It also
 * handles alerting the user for any errors encountered during the process,
 * such as exceeding message limits or invalid input.
 *
 * @param {SendMessageOptions} options - The options for sending the message.
 * @param {string} options.member - The member sending the message.
 * @param {string} options.islevel - The level of the member.
 * @param {Function} options.showAlert - Function to show alert messages.
 * @param {Array} options.coHostResponsibility - List of co-host responsibilities.
 * @param {string} options.coHost - The co-host of the room.
 * @param {string} options.chatSetting - Chat setting for the room.
 * @param {string} options.message - The message to be sent.
 * @param {string} options.roomName - The name of the room.
 * @param {number} options.messagesLength - The current number of messages in the room.
 * @param {Array} options.receivers - List of receivers for the message.
 * @param {boolean} options.group - Indicates if the message is for a group.
 * @param {string} options.sender - The sender of the message.
 * @param {Object} options.socket - The socket instance for emitting events.
 *
 * @returns {Promise<void>} A promise that resolves when the message is sent.
 *
 * @throws Will throw an error if the message count limit is exceeded.
 * @throws Will throw an error if the message, sender, or receivers are not valid.
 * @throws Will throw an error if the user is not allowed to send a message in the event room.
 *
 * @example
 * ```typescript
 * const sendMessageService = new SendMessage();
 * await sendMessageService.sendMessage({
 *   member: 'JohnDoe',
 *   islevel: '1',
 *   showAlert: (alert) => console.log(alert.message),
 *   coHostResponsibility: [],
 *   coHost: 'JaneDoe',
 *   chatSetting: 'allowed',
 *   message: 'Hello everyone!',
 *   roomName: 'Room1',
 *   messagesLength: 50,
 *   receivers: ['user1', 'user2'],
 *   group: true,
 *   sender: 'JohnDoe',
 *   socket: socketInstance,
 * });
 * ```
 */
class SendMessage {
    /**
     * Sends a message to the specified room.
     *
     * @param {Object} options - The options for sending the message.
     * @param {string} options.member - The member sending the message.
     * @param {string} options.islevel - The level of the member.
     * @param {Function} options.showAlert - Function to show alert messages.
     * @param {Array} options.coHostResponsibility - List of co-host responsibilities.
     * @param {string} options.coHost - The co-host of the room.
     * @param {boolean} options.chatSetting - Chat setting for the room.
     * @param {string} options.message - The message to be sent.
     * @param {string} options.roomName - The name of the room.
     * @param {number} options.messagesLength - The current number of messages in the room.
     * @param {Array} options.receivers - List of receivers for the message.
     * @param {boolean} options.group - Indicates if the message is for a group.
     * @param {string} options.sender - The sender of the message.
     * @param {Object} options.socket - The socket instance for communication.
     *
     * @returns {Promise<void>} A promise that resolves when the message is sent.
     *
     * @throws Will throw an error if the message count limit is exceeded.
     * @throws Will throw an error if the message, sender, or receivers are not valid.
     * @throws Will throw an error if the user is not allowed to send a message in the event room.
     */
    async sendMessage({ member, islevel, showAlert, coHostResponsibility, coHost, chatSetting, message, roomName, messagesLength, receivers, group, sender, socket, }) {
        let chatValue = false;
        // Check message count limit based on the room type
        if ((messagesLength > 100 && roomName.startsWith('d')) ||
            (messagesLength > 500 && roomName.startsWith('s')) ||
            (messagesLength > 100000 && roomName.startsWith('p'))) {
            showAlert?.({
                message: 'You have reached the maximum number of messages allowed.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Validate message, sender, and receivers
        if (!message || !receivers || (!member && !sender)) {
            showAlert?.({
                message: 'Message is not valid.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Create the message object
        const messageObject = {
            sender: sender ? sender : member,
            receivers: receivers,
            message: message,
            timestamp: new Date().toLocaleTimeString(),
            group: group !== undefined && group !== null ? group : false,
        };
        try {
            // Check co-host responsibility for chat
            chatValue = coHostResponsibility.find((item) => item.name === 'chat')?.value ?? false;
        }
        catch (error) {
            console.error(error);
        }
        if (islevel === '2' || (coHost === member && chatValue === true)) {
            // Allow sending message
        }
        else {
            // Check if user is allowed to send a message in the event room
            if (!chatSetting) {
                showAlert?.({
                    message: 'You are not allowed to send a message in this event room',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        // Send the message to the server
        socket.emit('sendMessage', {
            messageObject: messageObject,
            roomName: roomName,
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SendMessage, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SendMessage, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SendMessage, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Toggles the visibility of the participants modal.
 *
 * This method checks the current visibility state of the participants modal
 * and updates it accordingly. If the modal is currently visible, it will be hidden.
 * If it is hidden, it will be displayed.
 *
 * @param {LaunchParticipantsOptions} options - The options for toggling the participants modal.
 * @param {Function} options.updateIsParticipantsModalVisible - Function to update the visibility state of the participants modal.
 * @param {boolean} options.isParticipantsModalVisible - Current visibility state of the participants modal.
 *
 * @returns {void}
 *
 * @example
 * ```typescript
 * const launchParticipantsService = new LaunchParticipants();
 * launchParticipantsService.launchParticipants({
 *   updateIsParticipantsModalVisible: (isVisible) => {
 *     console.log(`Participants modal is now ${isVisible ? 'visible' : 'hidden'}`);
 *   },
 *   isParticipantsModalVisible: false,
 * });
 * ```
 */
class LaunchParticipants {
    /**
     * Toggles the visibility of the participants modal.
     * @function
     * @param {Object} options - The options object containing necessary variables and functions.
     * @param {Function} options.updateIsParticipantsModalVisible - Function to update the visibility state of the participants modal.
     * @param {boolean} options.isParticipantsModalVisible - Current visibility state of the participants modal.
     */
    launchParticipants({ updateIsParticipantsModalVisible, isParticipantsModalVisible, }) {
        updateIsParticipantsModalVisible(!isParticipantsModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchParticipants, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchParticipants, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchParticipants, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Sends a direct message to a participant if certain conditions are met.
 *
 * This method checks the current user's level and their co-host responsibilities
 * to determine if they are allowed to send a direct message to a specified participant.
 * If the user has the appropriate permissions, the method updates the direct message
 * details and opens the messages modal. If the user is not allowed to send the message,
 * an alert is displayed.
 *
 * @param {MessageParticipantsOptions} options - The options for sending a message to a participant.
 * @param {CoHostResponsibility[]} options.coHostResponsibility - Array of responsibilities assigned to the co-host.
 * @param {Participant} options.participant - The participant to whom the message is to be sent.
 * @param {string} options.member - The current member attempting to send the message.
 * @param {string} options.islevel - The level of the current member.
 * @param {Function} [options.showAlert] - Function to show an alert message if the message cannot be sent.
 * @param {string} options.coHost - The co-host member.
 * @param {Function} options.updateIsMessagesModalVisible - Function to update the visibility of the messages modal.
 * @param {Function} options.updateDirectMessageDetails - Function to update the details of the direct message.
 * @param {Function} options.updateStartDirectMessage - Function to start the direct message.
 *
 * @returns {void}
 *
 * @example
 * ```typescript
 * const messageService = new MessageParticipants();
 * messageService.messageParticipants({
 *   coHostResponsibility: [{ name: 'chat', value: true }],
 *   participant: { name: 'John', islevel: '1' },
 *   member: 'Alice',
 *   islevel: '1',
 *   showAlert: ({ message, type, duration }) => {
 *     console.log(`Alert: ${message} - Type: ${type} - Duration: ${duration}`);
 *   },
 *   coHost: 'Bob',
 *   updateIsMessagesModalVisible: (isVisible) => {
 *     console.log(`Messages modal is now ${isVisible ? 'visible' : 'hidden'}`);
 *   },
 *   updateDirectMessageDetails: (participant) => {
 *     console.log(`Direct messaging: ${participant.name}`);
 *   },
 *   updateStartDirectMessage: (start) => {
 *     console.log(`Direct messaging started: ${start}`);
 *   },
 * });
 * ```
 */
class MessageParticipants {
    /**
     * Sends a direct message to a participant if certain conditions are met.
     *s
     * @param coHostResponsibility - Array of responsibilities assigned to the co-host.
     * @param participant - The participant to whom the message is to be sent.
     * @param member - The current member attempting to send the message.
     * @param islevel - The level of the current member.
     * @param showAlert - Function to show an alert message.
     * @param coHost - The co-host member.
     * @param updateIsMessagesModalVisible - Function to update the visibility of the messages modal.
     * @param updateDirectMessageDetails - Function to update the details of the direct message.
     * @param updateStartDirectMessage - Function to start the direct message.
     *
     * @returns void
     */
    messageParticipants({ coHostResponsibility, participant, member, islevel, showAlert, coHost, updateIsMessagesModalVisible, updateDirectMessageDetails, updateStartDirectMessage, }) {
        let chatValue = false;
        try {
            chatValue = coHostResponsibility.find((item) => item.name === 'chat')?.value ?? false;
        }
        catch (error) {
            console.error(error);
        }
        if (islevel === '2' || (coHost === member && chatValue === true)) {
            if (participant.islevel !== '2') {
                updateDirectMessageDetails(participant);
                updateStartDirectMessage(true);
                updateIsMessagesModalVisible(true);
            }
        }
        else {
            showAlert?.({
                message: 'You are not allowed to send this message',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MessageParticipants, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MessageParticipants, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MessageParticipants, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Mutes a participant in a media session if certain conditions are met.
 *
 * This method checks the current user's level and their co-host responsibilities
 * to determine if they are allowed to mute a specified participant. If allowed,
 * the method emits a socket event to mute the participant. If not allowed, an alert
 * is displayed.
 *
 * @param {MuteParticipantsOptions} options - The options for muting participants.
 * @param {Socket} options.socket - The socket instance for communication.
 * @param {CoHostResponsibility[]} options.coHostResponsibility - List of co-host responsibilities.
 * @param {Participant} options.participant - The participant to be muted.
 * @param {string} options.member - The current member attempting to mute.
 * @param {string} options.islevel - The level of the current member.
 * @param {Function} [options.showAlert] - Optional function to show alerts.
 * @param {string} options.coHost - The co-host information.
 * @param {string} options.roomName - The name of the room.
 *
 * @returns {Promise<void>} A promise that resolves when the participant is muted.
 *
 * @throws Will log an error if there is an issue accessing co-host responsibilities.
 *
 * @example
 * ```typescript
 * const muteService = new MuteParticipants();
 * muteService.muteParticipants({
 *   socket: socketInstance,
 *   coHostResponsibility: [{ name: 'media', value: true }],
 *   participant: { id: '123', name: 'John', islevel: '1', muted: false },
 *   member: 'Alice',
 *   islevel: '1',
 *   showAlert: ({ message, type }) => {
 *     console.log(`Alert: ${message} - Type: ${type}`);
 *   },
 *   coHost: 'Bob',
 *   roomName: 'room1',
 * });
 * ```
 */
class MuteParticipants {
    /**
     * Mutes a participant in a media session if certain conditions are met.
     *
     * @param {Object} options - The options for muting participants.
     * @param {Socket} options.socket - The socket instance for communication.
     * @param {Array} options.coHostResponsibility - List of co-host responsibilities.
     * @param {Object} options.participant - The participant to be muted.
     * @param {Object} options.member - The current member attempting to mute.
     * @param {string} options.islevel - The level of the current member.
     * @param {Function} [options.showAlert] - Optional function to show alerts.
     * @param {Object} options.coHost - The co-host information.
     * @param {string} options.roomName - The name of the room.
     *
     * @returns {Promise<void>} A promise that resolves when the participant is muted.
     *
     * @throws Will log an error if there is an issue accessing co-host responsibilities.
     */
    async muteParticipants({ socket, coHostResponsibility, participant, member, islevel, showAlert, coHost, roomName, }) {
        let mediaValue = false;
        try {
            mediaValue = coHostResponsibility.find((item) => item.name === 'media')?.value ?? false;
        }
        catch (error) {
            console.error(error);
        }
        if (islevel === '2' || (coHost === member && mediaValue === true)) {
            if (!participant.muted && participant.islevel !== '2') {
                const participantId = participant.id;
                socket.emit('controlMedia', {
                    participantId,
                    participantName: participant.name,
                    type: 'all',
                    roomName,
                });
            }
        }
        else {
            showAlert?.({
                message: 'You are not allowed to mute other participants',
                type: 'danger',
                duration: 3000,
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MuteParticipants, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MuteParticipants, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MuteParticipants, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Removes a participant from the room if the user has the appropriate permissions.
 *
 * This method checks the current user's level and their co-host responsibilities
 * to determine if they are allowed to remove a specified participant. If allowed,
 * the method emits a socket event to disconnect the participant and updates
 * the local list of participants. If not allowed, an alert is displayed.
 *
 * @param {RemoveParticipantsOptions} options - The options for removing a participant.
 * @param {CoHostResponsibility[]} options.coHostResponsibility - The responsibilities of the co-host.
 * @param {Participant} options.participant - The participant to be removed.
 * @param {string} options.member - The current member attempting to remove the participant.
 * @param {string} options.islevel - The level of the current member.
 * @param {Function} [options.showAlert] - Optional function to show alert messages.
 * @param {string} options.coHost - The co-host information.
 * @param {Participant[]} options.participants - The list of current participants.
 * @param {Socket} options.socket - The socket instance for emitting events.
 * @param {string} options.roomName - The name of the room.
 * @param {Function} options.updateParticipants - Function to update the participants list.
 *
 * @returns {Promise<void>} A promise that resolves when the participant is removed.
 *
 * @throws Will log an error if there is an issue accessing co-host responsibilities.
 *
 * @example
 * ```typescript
 * const removeParticipantsService = new RemoveParticipants();
 * await removeParticipantsService.removeParticipants({
 *   coHostResponsibility: [{ name: 'participants', value: true }],
 *   participant: { id: '123', name: 'John', islevel: '1' },
 *   member: 'Alice',
 *   islevel: '1',
 *   showAlert: ({ message, type }) => {
 *     console.log(`Alert: ${message} - Type: ${type}`);
 *   },
 *   coHost: 'Bob',
 *   participants: [{ id: '123', name: 'John', islevel: '1' }],
 *   socket: socketInstance,
 *   roomName: 'room1',
 *   updateParticipants: (updatedList) => {
 *     console.log('Updated participants:', updatedList);
 *   },
 * });
 * ```
 */
class RemoveParticipants {
    /**
     * Removes a participant from the room if the user has the appropriate permissions.
     *
     * @param {RemoveParticipantsOptions} options - The options for removing a participant.
     * @param {Array} options.coHostResponsibility - The responsibilities of the co-host.
     * @param {Object} options.participant - The participant to be removed.
     * @param {Object} options.member - The current member attempting to remove the participant.
     * @param {string} options.islevel - The level of the current member.
     * @param {Function} [options.showAlert] - Function to show an alert message.
     * @param {Object} options.coHost - The co-host information.
     * @param {Array} options.participants - The list of current participants.
     * @param {Object} options.socket - The socket instance for emitting events.
     * @param {string} options.roomName - The name of the room.
     * @param {Function} options.updateParticipants - Function to update the participants list.
     *
     * @returns {Promise<void>} - A promise that resolves when the participant is removed.
     */
    async removeParticipants({ coHostResponsibility, participant, member, islevel, showAlert, coHost, participants, socket, roomName, updateParticipants, }) {
        let participantsValue = false;
        try {
            participantsValue =
                coHostResponsibility.find((item) => item.name === 'participants')?.value ?? false;
        }
        catch (error) {
            participantsValue = false;
        }
        if (islevel === '2' || (coHost === member && participantsValue === true)) {
            if (participant.islevel !== '2') {
                const participantId = participant.id;
                // Emit a socket event to disconnect the user
                socket.emit('disconnectUserInitiate', {
                    member: participant.name,
                    roomName,
                    id: participantId,
                });
                // Remove the participant from the local array
                participants.splice(participants.findIndex((obj) => obj.name === participant.name), 1);
                // Update the participants array
                updateParticipants(participants);
            }
        }
        else {
            showAlert?.({
                message: 'You are not allowed to remove other participants',
                type: 'danger',
                duration: 3000,
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RemoveParticipants, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RemoveParticipants, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RemoveParticipants, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Handles the creation of a poll.
 *
 * This method sends a request to create a poll in the specified room via a socket event.
 * It also handles the response from the server to notify the user whether the poll was
 * created successfully or if there was an error.
 *
 * @param {HandleCreatePollOptions} options - The options for creating the poll.
 * @param {Poll} options.poll - The poll object containing the poll details.
 * @param {Socket} options.socket - The socket instance for emitting events.
 * @param {string} options.roomName - The name of the room where the poll will be created.
 * @param {Function} [options.showAlert] - Optional function to show alert messages.
 * @param {Function} options.updateIsPollModalVisible - Function to update the visibility of the poll modal.
 *
 * @returns {Promise<void>} A promise that resolves when the poll is created successfully.
 *
 * @throws Will handle any errors during the poll creation process silently.
 *
 * @example
 * ```typescript
 * const handleCreatePollService = new HandleCreatePoll();
 * const pollData = {
 *   question: 'What is your favorite color?',
 *   options: ['Red', 'Blue', 'Green'],
 * };
 * await handleCreatePollService.handleCreatePoll({
 *   poll: pollData,
 *   socket: socketInstance,
 *   roomName: 'room1',
 *   showAlert: ({ message, type }) => {
 *     console.log(`Alert: ${message} - Type: ${type}`);
 *   },
 *   updateIsPollModalVisible: (isVisible) => {
 *     console.log('Poll modal visibility:', isVisible);
 *   },
 * });
 * ```
 */
class HandleCreatePoll {
    /**
     * Handles the creation of a poll.
     *
     * @param {Object} options - The options for creating the poll.
     * @param {Poll} options.poll - The poll object containing the poll details.
     * @param {Object} options.parameters - Additional parameters for creating the poll.
     * @returns {Promise<void>} - A promise that resolves when the poll is created successfully.
     */
    async handleCreatePoll({ poll, socket, roomName, showAlert, updateIsPollModalVisible, }) {
        try {
            socket.emit('createPoll', { roomName, poll }, (response) => {
                if (response.success) {
                    showAlert?.({ message: 'Poll created successfully', type: 'success' });
                    updateIsPollModalVisible(false);
                }
                else {
                    showAlert?.({ message: response.reason || 'Failed to create poll', type: 'danger' });
                }
            });
        }
        catch {
            /* handle error */
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HandleCreatePoll, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HandleCreatePoll, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HandleCreatePoll, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Handles the end of a poll by emitting an "endPoll" event through the provided socket.
 * Displays an alert based on the success or failure of the operation.
 *
 * @param {HandleEndPollOptions} options - The options for ending the poll.
 * @param {string} options.pollId - The ID of the poll to end.
 * @param {Socket} options.socket - The socket instance to emit the event.
 * @param {Function} [options.showAlert] - Optional function to display alerts.
 * @param {string} options.roomName - The name of the room where the poll is being conducted.
 * @param {Function} options.updateIsPollModalVisible - Function to update the visibility of the poll modal.
 *
 * @returns {Promise<void>} A promise that resolves when the poll end operation is complete.
 *
 * @throws Will log an error if the operation fails to emit the end poll event.
 *
 * @example
 * ```typescript
 * const handleEndPollService = new HandleEndPoll();
 * const pollId = '12345';
 * await handleEndPollService.handleEndPoll({
 *   pollId: pollId,
 *   socket: socketInstance,
 *   roomName: 'room1',
 *   showAlert: ({ message, type }) => {
 *     console.log(`Alert: ${message} - Type: ${type}`);
 *   },
 *   updateIsPollModalVisible: (isVisible) => {
 *     console.log('Poll modal visibility:', isVisible);
 *   },
 * });
 * ```
 */
class HandleEndPoll {
    /**
     * Handles the end of a poll by emitting an "endPoll" event through the provided socket.
     * Displays an alert based on the success or failure of the operation.
     *
     * @param {Object} options - The options for ending the poll.
     * @param {string} options.pollId - The ID of the poll to end.
     * @param {Socket} options.socket - The socket instance to emit the event.
     * @param {Function} [options.showAlert] - Optional function to display alerts.
     * @param {string} options.roomName - The name of the room where the poll is being conducted.
     * @returns {Promise<void>} A promise that resolves when the poll end operation is complete.
     */
    async handleEndPoll({ pollId, socket, showAlert, roomName, updateIsPollModalVisible, }) {
        try {
            socket.emit('endPoll', { roomName, poll_id: pollId }, (response) => {
                if (response.success) {
                    showAlert?.({ message: 'Poll ended successfully', type: 'success' });
                    updateIsPollModalVisible(false);
                }
                else {
                    showAlert?.({ message: response.reason || 'Failed to end poll', type: 'danger' });
                }
            });
        }
        catch (error) {
            console.log(error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HandleEndPoll, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HandleEndPoll, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HandleEndPoll, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Handles the voting process for a poll.
 *
 * @param {HandleVotePollOptions} options - The options for handling the vote.
 * @param {string} options.pollId - The ID of the poll.
 * @param {number} options.optionIndex - The index of the selected option.
 * @param {Socket} options.socket - The socket instance for communication.
 * @param {Function} [options.showAlert] - Optional function to show alerts.
 * @param {string} options.member - The member who is voting.
 * @param {string} options.roomName - The name of the room where the poll is conducted.
 * @param {Function} options.updateIsPollModalVisible - Function to update the visibility of the poll modal.
 *
 * @returns {Promise<void>} A promise that resolves when the vote is handled.
 *
 * @throws Will log an error message if there is an issue submitting the vote.
 *
 * @example
 * ```typescript
 * const handleVotePollService = new HandleVotePoll();
 * await handleVotePollService.handleVotePoll({
 *   pollId: '12345',
 *   optionIndex: 1,
 *   socket: socketInstance,
 *   member: 'user1',
 *   roomName: 'room1',
 *   showAlert: ({ message, type }) => {
 *     console.log(`Alert: ${message} - Type: ${type}`);
 *   },
 *   updateIsPollModalVisible: (isVisible) => {
 *     console.log('Poll modal visibility:', isVisible);
 *   },
 * });
 * ```
 */
class HandleVotePoll {
    /**
     * Handles the voting process for a poll.
     *
     * @param {Object} options - The options for handling the vote.
     * @param {string} options.pollId - The ID of the poll.
     * @param {number} options.optionIndex - The index of the selected option.
     * @param {Socket} options.socket - The socket instance for communication.
     * @param {Function} [options.showAlert] - Optional function to show alerts.
     * @param {Object} options.member - The member who is voting.
     * @param {string} options.roomName - The name of the room where the poll is conducted.
     * @param {Function} options.updateIsPollModalVisible - Function to update the visibility of the poll modal.
     * @returns {Promise<void>} A promise that resolves when the vote is handled.
     *
     * @throws Will log an error message if there is an issue submitting the vote.
     */
    async handleVotePoll({ pollId, optionIndex, socket, showAlert, member, roomName, updateIsPollModalVisible, }) {
        try {
            socket.emit('votePoll', {
                roomName,
                poll_id: pollId,
                member,
                choice: optionIndex,
            }, (response) => {
                if (response.success) {
                    showAlert?.({ message: 'Vote submitted successfully', type: 'success' });
                    updateIsPollModalVisible(false);
                }
                else {
                    showAlert?.({ message: response.reason, type: 'danger' });
                }
            });
        }
        catch (error) {
            // console.log(error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HandleVotePoll, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HandleVotePoll, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HandleVotePoll, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Toggles the visibility of the poll modal.
 *
 * @param {LaunchPollOptions} options - The options object containing necessary variables and functions.
 * @param {Function} options.updateIsPollModalVisible - Function to update the visibility state of the poll modal.
 * @param {boolean} options.isPollModalVisible - Current visibility state of the poll modal.
 *
 * @returns {void}
 *
 * @example
 * ```typescript
 * const launchPollService = new LaunchPoll();
 * launchPollService.launchPoll({
 *   updateIsPollModalVisible: (isVisible) => {
 *     console.log('Poll modal visibility:', isVisible);
 *   },
 *   isPollModalVisible: false,
 * });
 * ```
 */
class LaunchPoll {
    /**
     * Toggles the visibility of the poll modal.
     * @function
     * @param {Object} options - The options object containing necessary variables and functions.
     * @param {Function} options.updateIsPollModalVisible - Function to update the visibility state of the poll modal.
     * @param {boolean} options.isPollModalVisible - Current visibility state of the poll modal.
     */
    launchPoll({ updateIsPollModalVisible, isPollModalVisible }) {
        updateIsPollModalVisible(!isPollModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchPoll, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchPoll, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchPoll, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Updates the poll state based on the provided data.
 *
 * @param {PollUpdatedOptions} options - The options for updating the poll.
 * @param {PollUpdatedData} options.data - The data containing poll information.
 * @param {Poll[]} options.polls - The current list of polls.
 * @param {Poll} options.poll - The current poll.
 * @param {string} options.member - The member identifier.
 * @param {string} options.islevel - The level of the member.
 * @param {Function} [options.showAlert] - Function to show alerts.
 * @param {Function} options.updatePolls - Function to update the list of polls.
 * @param {Function} options.updatePoll - Function to update the current poll.
 * @param {Function} options.updateIsPollModalVisible - Function to update the visibility of the poll modal.
 * @returns {Promise<void>} A promise that resolves when the poll update is complete.
 *
 * @example
 * ```typescript
 * const pollUpdatedService = new PollUpdated();
 * pollUpdatedService.pollUpdated({
 *   data: { polls: [], poll: { id: '123', question: 'Sample Poll?', status: 'started' } },
 *   polls: [],
 *   poll: { id: '123', question: 'Sample Poll?', status: 'started' },
 *   member: 'user1',
 *   islevel: '1',
 *   showAlert: (alert) => console.log(alert.message),
 *   updatePolls: (polls) => console.log('Updated polls:', polls),
 *   updatePoll: (poll) => console.log('Updated poll:', poll),
 *   updateIsPollModalVisible: (visible) => console.log('Poll modal visibility:', visible),
 * });
 * ```
 */
class PollUpdated {
    /**
     * Updates the poll state based on the provided data.
     *
     * @param {Object} options - The options for updating the poll.
     * @param {any} options.data - The data containing poll information.
     * @param {any[]} options.polls - The current list of polls.
     * @param {any} options.poll - The current poll.
     * @param {string} options.member - The member identifier.
     * @param {string} options.islevel - The level of the member.
     * @param {Function} options.showAlert - Function to show alerts.
     * @param {Function} options.updatePolls - Function to update the list of polls.
     * @param {Function} options.updatePoll - Function to update the current poll.
     * @param {Function} options.updateIsPollModalVisible - Function to update the visibility of the poll modal.
     * @returns {Promise<void>} A promise that resolves when the poll update is complete.
     */
    async pollUpdated({ data, polls, poll, member, islevel, showAlert, updatePolls, updatePoll, updateIsPollModalVisible, }) {
        try {
            if (data.polls) {
                polls = data.polls;
                updatePolls(data.polls);
            }
            else {
                polls = [data.poll];
                updatePolls(polls);
            }
            let temp_poll = { id: '' };
            if (poll) {
                temp_poll = { ...poll };
            }
            if (data.status != 'ended') {
                poll = data.poll;
                updatePoll(data.poll);
            }
            if (data.status === 'started' && islevel !== '2') {
                if (!poll.voters || (poll.voters && !poll.voters[member])) {
                    showAlert?.({ message: 'New poll started', type: 'success', duration: 3000 });
                    updateIsPollModalVisible(true);
                }
            }
            else if (data.status === 'ended') {
                if (temp_poll.id === data.poll.id) {
                    showAlert?.({ message: 'Poll ended', type: 'danger', duration: 3000 });
                    // update the poll
                    updatePoll(data.poll);
                }
            }
        }
        catch (error) {
            // console.log(error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PollUpdated, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PollUpdated, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PollUpdated, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Checks if the recording can be paused based on the current pause count and the allowed pause limits.
 *
 * @param {CheckPauseStateOptions} options - The options for checking the pause state.
 * @param {string} options.recordingMediaOptions - The type of media being recorded ("video" or "audio").
 * @param {number} options.recordingVideoPausesLimit - The maximum number of pauses allowed for video recordings.
 * @param {number} options.recordingAudioPausesLimit - The maximum number of pauses allowed for audio recordings.
 * @param {number} options.pauseRecordCount - The current count of pauses that have been made.
 * @param {Function} [options.showAlert] - A function to show an alert message if the pause limit is reached.
 * @returns {Promise<boolean>} A promise that resolves to `true` if the recording can be paused, otherwise `false`.
 *
 * @example
 * ```typescript
 * const checkPauseStateService = new CheckPauseState();
 * const canPause = await checkPauseStateService.checkPauseState({
 *   recordingMediaOptions: 'video',
 *   recordingVideoPausesLimit: 3,
 *   recordingAudioPausesLimit: 5,
 *   pauseRecordCount: 2,
 *   showAlert: (alert) => console.log(alert.message),
 * });
 * console.log('Can pause recording:', canPause);
 * ```
 */
class CheckPauseState {
    /**
     * Checks if the recording can be paused based on the current pause count and the allowed pause limits.
     *
     * @param {Object} options - The options for checking the pause state.
     * @param {string} options.recordingMediaOptions - The type of media being recorded ("video" or "audio").
     * @param {number} options.recordingVideoPausesLimit - The maximum number of pauses allowed for video recordings.
     * @param {number} options.recordingAudioPausesLimit - The maximum number of pauses allowed for audio recordings.
     * @param {number} options.pauseRecordCount - The current count of pauses that have been made.
     * @param {Function} options.showAlert - A function to show an alert message if the pause limit is reached.
     * @returns {Promise<boolean>} - A promise that resolves to `true` if the recording can be paused, otherwise `false`.
     */
    checkPauseState = async ({ recordingMediaOptions, recordingVideoPausesLimit, recordingAudioPausesLimit, pauseRecordCount, showAlert, }) => {
        // function to check if the user can pause recording
        let ref_limit = 0;
        if (recordingMediaOptions == 'video') {
            ref_limit = recordingVideoPausesLimit;
        }
        else {
            ref_limit = recordingAudioPausesLimit;
        }
        if (pauseRecordCount < ref_limit) {
            return true;
        }
        else {
            showAlert?.({
                message: 'You have reached the limit of pauses - you can choose to stop recording.',
                type: 'danger',
                duration: 3000,
            });
            return false;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckPauseState, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckPauseState, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckPauseState, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Checks if the recording can be resumed based on the media type and pause limits.
 *
 * @param {CheckResumeStateOptions} options - The options for checking resume state.
 * @param {string} options.recordingMediaOptions - The type of media being recorded ("video" or "audio").
 * @param {number} options.recordingVideoPausesLimit - The maximum number of pauses allowed for video recording.
 * @param {number} options.recordingAudioPausesLimit - The maximum number of pauses allowed for audio recording.
 * @param {number} options.pauseRecordCount - The current number of pauses that have occurred.
 * @returns {Promise<boolean>} A promise that resolves to a boolean indicating whether the recording can be resumed.
 *
 * @example
 * ```typescript
 * const checkResumeStateService = new CheckResumeState();
 * const canResume = await checkResumeStateService.checkResumeState({
 *   recordingMediaOptions: 'audio',
 *   recordingVideoPausesLimit: 3,
 *   recordingAudioPausesLimit: 5,
 *   pauseRecordCount: 2,
 * });
 * console.log('Can resume recording:', canResume);
 * ```
 */
class CheckResumeState {
    /**
     * Checks if the recording can be resumed based on the media type and pause limits.
     *
     * @param {Object} options - The options for checking resume state.
     * @param {string} options.recordingMediaOptions - The type of media being recorded ("video" or "audio").
     * @param {number} options.recordingVideoPausesLimit - The maximum number of pauses allowed for video recording.
     * @param {number} options.recordingAudioPausesLimit - The maximum number of pauses allowed for audio recording.
     * @param {number} options.pauseRecordCount - The current number of pauses that have occurred.
     * @returns {Promise<boolean>} - A promise that resolves to a boolean indicating whether the recording can be resumed.
     */
    checkResumeState = async ({ recordingMediaOptions, recordingVideoPausesLimit, recordingAudioPausesLimit, pauseRecordCount, }) => {
        // function to check if the user can resume recording
        let ref_limit = 0;
        if (recordingMediaOptions == 'video') {
            ref_limit = recordingVideoPausesLimit;
        }
        else {
            ref_limit = recordingAudioPausesLimit;
        }
        return pauseRecordCount <= ref_limit;
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckResumeState, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckResumeState, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckResumeState, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Confirms the recording settings based on the provided parameters and updates the recording state.
 *
 * @param {ConfirmRecordingOptions} options - The options for confirming the recording.
 * @param {ConfirmRecordingParameters} options.parameters - The parameters for the recording, including:
 *   - {ShowAlert} [options.parameters.showAlert] - Optional function to show alert messages.
 *   - {string} options.parameters.recordingMediaOptions - Type of media being recorded ("video" or "audio").
 *   - {string} options.parameters.recordingAudioOptions - Audio recording options.
 *   - {string} options.parameters.recordingVideoOptions - Video recording options.
 *   - {string} options.parameters.recordingVideoType - Type of video recording.
 *   - {'video' | 'media' | 'all'} options.parameters.recordingDisplayType - The display type for the recording.
 *   - {boolean} options.parameters.recordingNameTags - Flag for including name tags in the recording.
 *   - {string} options.parameters.recordingBackgroundColor - Background color for the recording.
 *   - {string} options.parameters.recordingNameTagsColor - Color for the name tags.
 *   - {string} options.parameters.recordingOrientationVideo - Orientation for video recording.
 *   - {boolean} options.parameters.recordingAddHLS - Flag for adding HLS support.
 *   - {boolean} options.parameters.recordingAddText - Flag for adding custom text.
 *   - {string} options.parameters.recordingCustomText - Custom text for the recording.
 *   - {string} options.parameters.recordingCustomTextPosition - Position of the custom text.
 *   - {string} options.parameters.recordingCustomTextColor - Color of the custom text.
 *   - {string} options.parameters.meetingDisplayType - Current display type of the meeting.
 *   - {boolean} options.parameters.recordingVideoParticipantsFullRoomSupport - Support for video participants in full room.
 *   - {boolean} options.parameters.recordingAllParticipantsSupport - Support for recording all participants.
 *   - {boolean} options.parameters.recordingVideoParticipantsSupport - Support for video participants.
 *   - {boolean} options.parameters.recordingSupportForOtherOrientation - Support for other orientations.
 *   - {string} options.parameters.recordingPreferredOrientation - Preferred orientation for recording.
 *   - {boolean} options.parameters.recordingMultiFormatsSupport - Support for multiple formats.
 *   - {boolean} options.parameters.recordingVideoOptimized - Flag for video optimization.
 *   - {boolean} options.parameters.recordingAllParticipantsFullRoomSupport - Support for recording all participants in full room.
 *   - {boolean} options.parameters.meetingVideoOptimized - Flag for meeting video optimization.
 *   - {EventType} options.parameters.eventType - Type of the event.
 *   - {boolean} options.parameters.breakOutRoomStarted - Indicates if a breakout room has started.
 *   - {boolean} options.parameters.breakOutRoomEnded - Indicates if a breakout room has ended.
 *   - {Function} options.parameters.updateRecordingDisplayType - Function to update the recording display type.
 *   - {Function} options.parameters.updateRecordingVideoOptimized - Function to update video optimization status.
 *   - {Function} options.parameters.updateUserRecordingParams - Function to update user recording parameters.
 *   - {Function} options.parameters.updateConfirmedToRecord - Function to confirm the recording.
 *
 * @returns {Promise<void>} A promise that resolves when the recording settings have been confirmed.
 *
 * @remarks
 * This function performs several checks to ensure that the recording settings are valid based on the provided parameters.
 * If any of the checks fail, an alert is shown and the function returns early without updating the recording state.
 *
 * The function checks for the following conditions:
 * - Whether recording videos of all participants is allowed.
 * - Whether recording all participants is allowed.
 * - Whether recording other video participants is allowed.
 * - Whether recording all orientations is allowed.
 * - Whether recording the preferred orientation is allowed.
 * - Whether recording all formats is allowed.
 * - Whether the recording display type is valid based on the meeting display type.
 * - Whether recording all participants with media is allowed.
 *
 * If all checks pass, the function constructs the `mainSpecs`, `dispSpecs`, and `textSpecs` objects based on the state variables,
 * updates the user recording parameters, and confirms the recording.
 *
 * @example
 * ```typescript
 * const options: ConfirmRecordingOptions = { parameters: someParameters };
 * await confirmRecording(options);
 * ```
 */
class ConfirmRecording {
    /**
     * Confirms the recording settings based on the provided parameters and updates the recording state.
     *
     * @param {ConfirmRecordingOptions} options - The options for confirming the recording.
     * @param {Parameters} options.parameters - The parameters for the recording.
     *
     * @returns {Promise<void>} A promise that resolves when the recording settings have been confirmed.
     *
     * @remarks
     * This function performs several checks to ensure that the recording settings are valid based on the provided parameters.
     * If any of the checks fail, an alert is shown and the function returns early without updating the recording state.
     *
     * The function checks for the following conditions:
     * - Whether recording videos of all participants is allowed.
     * - Whether recording all participants is allowed.
     * - Whether recording other video participants is allowed.
     * - Whether recording all orientations is allowed.
     * - Whether recording the preferred orientation is allowed.
     * - Whether recording all formats is allowed.
     * - Whether the recording display type is valid based on the meeting display type.
     * - Whether recording all participants with media is allowed.
     *
     * If all checks pass, the function constructs the `mainSpecs`, `dispSpecs`, and `textSpecs` objects based on the state variables,
     * updates the user recording parameters, and confirms the recording.
     *
     * @example
     * ```typescript
     * const options: ConfirmRecordingOptions = { parameters: someParameters };
     * await confirmRecording(options);
     * ```
     */
    confirmRecording = async ({ parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { showAlert, recordingMediaOptions, recordingAudioOptions, recordingVideoOptions, recordingVideoType, recordingDisplayType, recordingNameTags, recordingBackgroundColor, recordingNameTagsColor, recordingOrientationVideo, recordingAddHLS, recordingAddText, recordingCustomText, recordingCustomTextPosition, recordingCustomTextColor, meetingDisplayType, recordingVideoParticipantsFullRoomSupport, recordingAllParticipantsSupport, recordingVideoParticipantsSupport, recordingSupportForOtherOrientation, recordingPreferredOrientation, recordingMultiFormatsSupport, recordingVideoOptimized, recordingAllParticipantsFullRoomSupport, meetingVideoOptimized, eventType, breakOutRoomStarted, breakOutRoomEnded, updateRecordingDisplayType, updateRecordingVideoOptimized, updateRecordingVideoParticipantsFullRoomSupport, updateRecordingAllParticipantsSupport, updateRecordingVideoParticipantsSupport, updateRecordingSupportForOtherOrientation, updateRecordingPreferredOrientation, updateRecordingMultiFormatsSupport, updateUserRecordingParams, updateConfirmedToRecord, } = parameters;
        // Retrieve the values from the state
        const mediaOptions = recordingMediaOptions;
        // Other variables not provided in the guide
        const selectedRecordOption = recordingDisplayType;
        // Additional logic similar to the provided guide
        // recordingVideoParticipantsFullRoomSupport = minigrid and main video
        if (eventType !== 'broadcast') {
            if (!recordingVideoParticipantsFullRoomSupport &&
                recordingVideoOptions === 'all' &&
                mediaOptions === 'video') {
                if (meetingDisplayType == 'all') {
                    if (breakOutRoomStarted && !breakOutRoomEnded) {
                        // breakout rooms are started
                    }
                    else {
                        showAlert?.({
                            message: 'You are not allowed to record videos of all participants; change the meeting display type to video or video optimized.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                }
            }
            // recordingAllParticipantsSupport  = others other than host screen (video + audio)
            if (!recordingAllParticipantsSupport && recordingVideoOptions === 'all') {
                showAlert?.({
                    message: 'You are only allowed to record yourself.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            // recordingVideoParticipantsSupport (maingrid + non-host screenshare person)
            if (!recordingVideoParticipantsSupport && recordingDisplayType === 'video') {
                showAlert?.({
                    message: 'You are not allowed to record other video participants.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        if (!recordingSupportForOtherOrientation && recordingOrientationVideo === 'all') {
            showAlert?.({
                message: 'You are not allowed to record all orientations.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (recordingPreferredOrientation === 'landscape' &&
            recordingOrientationVideo === 'portrait' &&
            !recordingSupportForOtherOrientation) {
            showAlert?.({
                message: 'You are not allowed to record portrait orientation.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        else if (recordingPreferredOrientation === 'portrait' &&
            recordingOrientationVideo === 'landscape' &&
            !recordingSupportForOtherOrientation) {
            showAlert?.({
                message: 'You are not allowed to record landscape orientation.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (!recordingMultiFormatsSupport && recordingVideoType === 'all') {
            showAlert?.({
                message: 'You are not allowed to record all formats.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (eventType !== 'broadcast') {
            if (recordingMediaOptions === 'video') {
                if (meetingDisplayType === 'media') {
                    if (recordingDisplayType === 'all') {
                        showAlert?.({
                            message: 'Recording display type can be either video, video optimized, or media when meeting display type is media.',
                            type: 'danger',
                            duration: 3000,
                        });
                        recordingDisplayType = meetingDisplayType;
                        return;
                    }
                }
                else if (meetingDisplayType === 'video') {
                    if (recordingDisplayType === 'all' || recordingDisplayType === 'media') {
                        showAlert?.({
                            message: 'Recording display type can be either video or video optimized when meeting display type is video.',
                            type: 'danger',
                            duration: 3000,
                        });
                        recordingDisplayType = meetingDisplayType;
                        return;
                    }
                    if (meetingVideoOptimized && !recordingVideoOptimized) {
                        showAlert?.({
                            message: 'Recording display type can be only video optimized when meeting display type is video optimized.',
                            type: 'danger',
                            duration: 3000,
                        });
                        recordingVideoOptimized = meetingVideoOptimized;
                        return;
                    }
                }
            }
            else {
                if (recordingDisplayType === 'all' || recordingDisplayType === 'media') {
                    // do nothing
                }
                else {
                    recordingDisplayType = 'media';
                }
                recordingVideoOptimized = false;
            }
        }
        if (recordingDisplayType === 'all' && !recordingAllParticipantsFullRoomSupport) {
            showAlert?.({
                message: 'You can only record all participants with media.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Construct mainSpecs and dispSpecs objects based on the state variables
        const mainSpecs = {
            mediaOptions: recordingMediaOptions,
            audioOptions: recordingAudioOptions,
            videoOptions: recordingVideoOptions,
            videoType: recordingVideoType,
            videoOptimized: recordingVideoOptimized,
            recordingDisplayType: recordingDisplayType,
            addHLS: recordingAddHLS,
        };
        const dispSpecs = {
            nameTags: recordingNameTags,
            backgroundColor: recordingBackgroundColor,
            nameTagsColor: recordingNameTagsColor,
            orientationVideo: recordingOrientationVideo,
        };
        const textSpecs = {
            addText: recordingAddText,
            customText: recordingCustomText,
            customTextPosition: recordingCustomTextPosition,
            customTextColor: recordingCustomTextColor,
        };
        // Construct userRecordingParams object
        const userRecordingParams = { mainSpecs, dispSpecs, textSpecs };
        // Update state variables based on the logic
        updateUserRecordingParams(userRecordingParams);
        updateConfirmedToRecord(true);
        updateRecordingDisplayType(selectedRecordOption);
        updateRecordingVideoOptimized(recordingVideoOptimized);
        updateRecordingVideoParticipantsFullRoomSupport(recordingVideoParticipantsFullRoomSupport);
        updateRecordingAllParticipantsSupport(recordingAllParticipantsSupport);
        updateRecordingVideoParticipantsSupport(recordingVideoParticipantsSupport);
        updateRecordingSupportForOtherOrientation(recordingSupportForOtherOrientation);
        updateRecordingPreferredOrientation(recordingPreferredOrientation);
        updateRecordingMultiFormatsSupport(recordingMultiFormatsSupport);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfirmRecording, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfirmRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfirmRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Launches the recording process based on various conditions and updates the UI accordingly.
 *
 * @param {LaunchRecordingOptions} options - The options for launching the recording.
 * @param {Function} options.updateIsRecordingModalVisible - Function to update the visibility of the recording modal.
 * @param {boolean} options.isRecordingModalVisible - Indicates if the recording modal is currently visible.
 * @param {Function} [options.showAlert] - Optional function to show an alert message.
 * @param {boolean} options.stopLaunchRecord - Indicates if the recording launch should be stopped.
 * @param {boolean} options.canLaunchRecord - Indicates if the recording can be launched.
 * @param {boolean} options.recordingAudioSupport - Indicates if audio recording is supported.
 * @param {boolean} options.recordingVideoSupport - Indicates if video recording is supported.
 * @param {Function} options.updateCanRecord - Function to update the recording capability.
 * @param {Function} options.updateClearedToRecord - Function to update the cleared-to-record status.
 * @param {boolean} options.recordStarted - Indicates if the recording has started.
 * @param {boolean} options.recordPaused - Indicates if the recording is paused.
 * @param {boolean} options.localUIMode - Indicates if the local UI mode is active.
 *
 * @returns {void}
 *
 * @throws Will show an alert if:
 * - The recording has already ended or the user is not allowed to record.
 * - The recording initiation is not allowed due to insufficient permissions.
 * - The recording is currently running and cannot be reconfigured unless paused.
 *
 * @example
 * ```typescript
 * const options: LaunchRecordingOptions = {
 *   updateIsRecordingModalVisible: (visible) => { /* update visibility logic *\/ },
 *   isRecordingModalVisible: false,
 *   showAlert: (alert) => { /* show alert logic *\/ },
 *   stopLaunchRecord: false,
 *   canLaunchRecord: true,
 *   recordingAudioSupport: true,
 *   recordingVideoSupport: true,
 *   updateCanRecord: (canRecord) => { /* update record capability *\/ },
 *   updateClearedToRecord: (cleared) => { /* update cleared status *\/ },
 *   recordStarted: false,
 *   recordPaused: false,
 *   localUIMode: false,
 * };
 * launchRecording(options);
 * ```
 */
class LaunchRecording {
    /**
     * Launches the recording process based on various conditions and updates the UI accordingly.
     *
     * @param {Object} options - The options for launching the recording.
     * @param {Function} options.updateIsRecordingModalVisible - Function to update the visibility of the recording modal.
     * @param {boolean} options.isRecordingModalVisible - Indicates if the recording modal is currently visible.
     * @param {Function} options.showAlert - Function to show an alert message.
     * @param {boolean} options.stopLaunchRecord - Indicates if the recording launch should be stopped.
     * @param {boolean} options.canLaunchRecord - Indicates if the recording can be launched.
     * @param {boolean} options.recordingAudioSupport - Indicates if audio recording is supported.
     * @param {boolean} options.recordingVideoSupport - Indicates if video recording is supported.
     * @param {Function} options.updateCanRecord - Function to update the recording capability.
     * @param {Function} options.updateClearedToRecord - Function to update the cleared-to-record status.
     * @param {boolean} options.recordStarted - Indicates if the recording has started.
     * @param {boolean} options.recordPaused - Indicates if the recording is paused.
     * @param {boolean} options.localUIMode - Indicates if the local UI mode is active.
     *
     * @returns {void}
     */
    launchRecording({ updateIsRecordingModalVisible, isRecordingModalVisible, showAlert, stopLaunchRecord, canLaunchRecord, recordingAudioSupport, recordingVideoSupport, updateCanRecord, updateClearedToRecord, recordStarted, recordPaused, localUIMode, }) {
        // Check if recording is already launched
        if (!isRecordingModalVisible && stopLaunchRecord && !localUIMode) {
            showAlert?.({
                message: 'Recording has already ended or you are not allowed to record',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Check if recording initiation is allowed
        if (!isRecordingModalVisible && canLaunchRecord && !localUIMode) {
            // Check if both audio and video recording are not allowed
            if (!recordingAudioSupport && !recordingVideoSupport) {
                showAlert?.({
                    message: 'You are not allowed to record',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            // update clearedToRecord to false
            updateClearedToRecord(false);
            // update canRecord to false
            updateCanRecord(false);
        }
        if (!isRecordingModalVisible && recordStarted) {
            if (!recordPaused) {
                showAlert?.({
                    message: 'You can only re-configure recording after pausing it',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        if (!isRecordingModalVisible &&
            !recordingAudioSupport &&
            !recordingVideoSupport &&
            !localUIMode) {
            showAlert?.({
                message: 'You are not allowed to record',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Update the visibility of the recording modal
        updateIsRecordingModalVisible(!isRecordingModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchRecording, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Controls the pause and resume functionality of a recording timer.
 *
 * @param {RecordPauseTimerOptions} options - The options for controlling the timer.
 * @param {boolean} [options.stop=false] - Indicates whether to stop the timer.
 * @param {boolean} options.isTimerRunning - Indicates if the timer is currently running.
 * @param {boolean} options.canPauseResume - Indicates if the timer can be paused or resumed.
 * @param {Function} [options.showAlert] - Optional function to show an alert message.
 * @returns {boolean} - Returns true if the timer can be paused or resumed, otherwise false.
 *
 * @throws Will show an alert message if:
 * - The timer cannot be stopped, paused, or resumed due to not meeting the required time condition.
 *
 * @example
 * ```typescript
 * const options: RecordPauseTimerOptions = {
 *   stop: false,
 *   isTimerRunning: true,
 *   canPauseResume: true,
 *   showAlert: (alert) => {  },
 * };
 * const canPause = recordPauseTimer(options);
 * if (canPause) {
 *   // proceed with pausing or resuming the recording
 * }
 * ```
 */
class RecordPauseTimer {
    /**
     * Controls the pause and resume functionality of a recording timer.
     *
     * @param {Object} options - The options for controlling the timer.
     * @param {boolean} [options.stop=false] - Indicates whether to stop the timer.
     * @param {Object} options.parameters - The parameters for the timer control.
     * @param {boolean} options.parameters.isTimerRunning - Indicates if the timer is currently running.
     * @param {boolean} options.parameters.canPauseResume - Indicates if the timer can be paused or resumed.
     * @param {Function} [options.parameters.showAlert] - Optional function to show an alert message.
     * @returns {boolean} - Returns true if the timer can be paused or resumed, otherwise false.
     */
    recordPauseTimer = ({ stop = false, isTimerRunning, canPauseResume, showAlert, }) => {
        // Ensure the timer is running and pause/resume actions are allowed
        if (isTimerRunning && canPauseResume) {
            return true;
        }
        else {
            const message = stop
                ? 'Can only stop after 15 seconds of starting or pausing or resuming recording'
                : 'Can only pause or resume after 15 seconds of starting or pausing or resuming recording';
            showAlert?.({
                message,
                type: 'danger',
            });
            return false;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordPauseTimer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordPauseTimer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordPauseTimer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Updates the recording timer and progress time.
 * @function
 * @param {RecordUpdateTimerOptions} options - The options object containing necessary variables and functions.
 */
/**
 * Updates the recording timer by calculating the elapsed time since the recording started
 * and formatting it in HH:MM:SS format.
 *
 * @param {Object} options - The options object.
 * @param {number} options.recordElapsedTime - The elapsed recording time in seconds.
 * @param {number} options.recordStartTime - The timestamp when the recording started.
 * @param {Function} options.updateRecordElapsedTime - Callback to update the elapsed recording time.
 * @param {Function} options.updateRecordingProgressTime - Callback to update the formatted recording time.
 * @returns {void}
 *
 * @remarks
 * This function calculates the elapsed time since the recording started and formats it into
 * a string in HH:MM:SS format. It updates both the elapsed time in seconds and the formatted
 * time via the provided callback functions.
 *
 * @example
 * ```typescript
 * const options: RecordUpdateTimerOptions = {
 *   recordElapsedTime: 0,
 *   recordStartTime: Date.now(),
 *   updateRecordElapsedTime: (elapsedTime) => { console.log(`Elapsed Time: ${elapsedTime} seconds`); },
 *   updateRecordingProgressTime: (formattedTime) => { console.log(`Formatted Time: ${formattedTime}`); },
 * };
 * recordUpdateTimer(options);
 * ```
 */
class RecordUpdateTimer {
    /**
     * Updates the recording timer and progress time.
     * @function
     * @param {RecordUpdateTimerOptions} options - The options object containing necessary variables and functions.
     */
    /**
     * Updates the recording timer by calculating the elapsed time since the recording started
     * and formatting it in HH:MM:SS format.
     *
     * @param {Object} options - The options object.
     * @param {number} options.recordElapsedTime - The elapsed recording time in seconds.
     * @param {number} options.recordStartTime - The timestamp when the recording started.
     * @param {Function} options.updateRecordElapsedTime - Callback to update the elapsed recording time.
     * @param {Function} options.updateRecordingProgressTime - Callback to update the formatted recording time.
     * @returns {void}
     */
    recordUpdateTimer({ recordElapsedTime, recordStartTime, updateRecordElapsedTime, updateRecordingProgressTime, }) {
        /**
         * Utility function to pad single-digit numbers with leading zeros.
         * @param {number} number - The number to pad.
         * @returns {string} The padded number as a string.
         */
        function padNumber(number) {
            return number.toString().padStart(2, '0');
        }
        const currentTime = new Date().getTime(); // Get the current timestamp
        recordElapsedTime = Math.floor((currentTime - recordStartTime) / 1000); // Calculate the elapsed time in seconds
        updateRecordElapsedTime(recordElapsedTime);
        // Format the time in HH:MM:SS format
        const hours = Math.floor(recordElapsedTime / 3600);
        const minutes = Math.floor((recordElapsedTime % 3600) / 60);
        const seconds = recordElapsedTime % 60;
        const formattedTime = padNumber(hours) + ':' + padNumber(minutes) + ':' + padNumber(seconds);
        updateRecordingProgressTime(formattedTime);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordUpdateTimer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordUpdateTimer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordUpdateTimer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Resumes the recording timer if it is not already running and can be paused/resumed.
 *
 * @param {RecordResumeTimerOptions} options - The options for resuming the recording timer.
 * @param {Object} options.parameters - The parameters for the recording timer.
 * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 * @param {boolean} options.parameters.isTimerRunning - Indicates if the timer is currently running.
 * @param {boolean} options.parameters.canPauseResume - Indicates if the timer can be paused/resumed.
 * @param {number} options.parameters.recordElapsedTime - The elapsed recording time in seconds.
 * @param {number} options.parameters.recordStartTime - The start time of the recording.
 * @param {NodeJS.Timeout | null} options.parameters.recordTimerInterval - The interval ID for the recording timer.
 * @param {Function} options.parameters.showAlert - Function to show an alert message.
 * @param {Function} options.parameters.updateRecordStartTime - Function to update the recording start time.
 * @param {Function} options.parameters.updateRecordTimerInterval - Function to update the recording timer interval.
 * @param {Function} options.parameters.updateIsTimerRunning - Function to update the timer running status.
 * @param {Function} options.parameters.updateCanPauseResume - Function to update the pause/resume status.
 *
 * @returns {Promise<boolean>} - Returns a promise that resolves to true if the timer was successfully resumed, otherwise false.
 *
 * @throws Will show an alert if the timer cannot be resumed due to conditions not being met.
 *
 * @example
 * ```typescript
 * const options: RecordResumeTimerOptions = {
 *   parameters: {
 *     isTimerRunning: false,
 *     canPauseResume: true,
 *     recordElapsedTime: 10,
 *     recordStartTime: Date.now(),
 *     recordTimerInterval: null,
 *     showAlert: (alert) => { },
 *     updateRecordStartTime: (time) => { },
 *     updateRecordTimerInterval: (interval) => { },
 *     updateIsTimerRunning: (isRunning) => { },
 *     updateCanPauseResume: (canPause) => {  },
 *     getUpdatedAllParams: () => ({  }),
 *   },
 * };
 * const canResume = await recordResumeTimer(options);
 * if (canResume) {
 *   // proceed with the resumed recording
 * }
 * ```
 */
class RecordResumeTimer {
    RecordUpdateTimerService;
    constructor(RecordUpdateTimerService) {
        this.RecordUpdateTimerService = RecordUpdateTimerService;
    }
    /**
     * Resumes the recording timer if it is not already running and can be paused/resumed.
     *
     * @param {RecordResumeTimerOptions} options - The options for resuming the recording timer.
     * @param {Object} options.parameters - The parameters for the recording timer.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {boolean} options.parameters.isTimerRunning - Indicates if the timer is currently running.
     * @param {boolean} options.parameters.canPauseResume - Indicates if the timer can be paused/resumed.
     * @param {number} options.parameters.recordElapsedTime - The elapsed recording time in seconds.
     * @param {number} options.parameters.recordStartTime - The start time of the recording.
     * @param {number | null} options.parameters.recordTimerInterval - The interval ID for the recording timer.
     * @param {Function} options.parameters.showAlert - Function to show an alert message.
     * @param {Function} options.parameters.updateRecordStartTime - Function to update the recording start time.
     * @param {Function} options.parameters.updateRecordTimerInterval - Function to update the recording timer interval.
     * @param {Function} options.parameters.updateIsTimerRunning - Function to update the timer running status.
     * @param {Function} options.parameters.updateCanPauseResume - Function to update the pause/resume status.
     *
     * @returns {Promise<boolean>} - Returns a promise that resolves to true if the timer was successfully resumed, otherwise false.
     */
    recordResumeTimer = async ({ parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { isTimerRunning, canPauseResume, recordElapsedTime, recordStartTime, recordTimerInterval, showAlert, updateRecordStartTime, updateRecordTimerInterval, updateIsTimerRunning, updateCanPauseResume,
        //mediasfu Functions
        // recordUpdateTimer,
         } = parameters;
        if (!isTimerRunning && canPauseResume) {
            recordStartTime = new Date().getTime() - recordElapsedTime * 1000; // Calculate the starting time based on elapsed time
            updateRecordStartTime(recordStartTime);
            recordTimerInterval = setInterval(() => {
                // Update the timer every second (1000 milliseconds)
                this.RecordUpdateTimerService.recordUpdateTimer({
                    recordElapsedTime: recordElapsedTime,
                    recordStartTime: recordStartTime,
                    updateRecordElapsedTime: parameters['updateRecordElapsedTime'],
                    updateRecordingProgressTime: parameters['updateRecordingProgressTime'],
                });
                parameters = getUpdatedAllParams();
                // Check if recording is paused or stopped, and close the interval if needed
                if (parameters['recordPaused'] ||
                    parameters['recordStopped'] ||
                    parameters['roomName'] == '' ||
                    parameters['roomName'] == null) {
                    if (recordTimerInterval != null) {
                        clearInterval(recordTimerInterval);
                    }
                    updateRecordTimerInterval(null);
                    isTimerRunning = false;
                    updateIsTimerRunning(isTimerRunning);
                    canPauseResume = false;
                    updateCanPauseResume(canPauseResume);
                }
            }, 1000);
            updateRecordTimerInterval(recordTimerInterval);
            isTimerRunning = true;
            updateIsTimerRunning(isTimerRunning);
            canPauseResume = false; // Disable pause/resume actions until paused again
            updateCanPauseResume(canPauseResume);
            return true;
        }
        else {
            showAlert?.({
                type: 'danger',
                message: 'Can only pause or resume after 15 seconds of starting or pausing or resuming recording',
            });
            return false;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordResumeTimer, deps: [{ token: RecordUpdateTimer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordResumeTimer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordResumeTimer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: RecordUpdateTimer }] });

/**
 * Starts the recording timer and manages its state.
 *
 * @param {RecordStartTimerOptions} options - The options for starting the recording timer.
 * @param {Object} options.parameters - The parameters for the recording timer.
 * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 * @param {number} options.parameters.recordStartTime - The start time of the recording.
 * @param {NodeJS.Timeout | null} options.parameters.recordTimerInterval - The interval ID for the recording timer.
 * @param {boolean} options.parameters.isTimerRunning - Flag indicating if the timer is currently running.
 * @param {boolean} options.parameters.canPauseResume - Flag indicating if pause/resume actions are enabled.
 * @param {number} options.parameters.recordChangeSeconds - The time after which pause/resume actions are enabled.
 * @param {Function} options.parameters.updateRecordStartTime - Function to update the recording start time.
 * @param {Function} options.parameters.updateRecordTimerInterval - Function to update the recording timer interval.
 * @param {Function} options.parameters.updateIsTimerRunning - Function to update the timer running state.
 * @param {Function} options.parameters.updateCanPauseResume - Function to update the pause/resume state.
 *
 * @returns {Promise<void>} A promise that resolves when the timer is started.
 *
 * @remarks
 * This function initializes the recording start time and sets up an interval to update the timer every second.
 * It also manages the state of the timer, including enabling and disabling pause/resume actions.
 * The timer is stopped if the recording is paused, stopped, or if the room name is invalid.
 *
 * @example
 * ```typescript
 * const options: RecordStartTimerOptions = {
 *   parameters: {
 *     recordStartTime: Date.now(),
 *     recordTimerInterval: null,
 *     isTimerRunning: false,
 *     canPauseResume: false,
 *     recordChangeSeconds: 15,
 *     recordPaused: false,
 *     recordStopped: false,
 *     roomName: 'room1',
 *     updateRecordStartTime: (time) => {  },
 *     updateRecordTimerInterval: (interval) => {  },
 *     updateIsTimerRunning: (isRunning) => { },
 *     updateCanPauseResume: (canPause) => {},
 *     getUpdatedAllParams: () => { },
 *   },
 * };
 * await recordStartTimer(options);
 * ```
 */
class RecordStartTimer {
    RecordUpdateTimerService;
    constructor(RecordUpdateTimerService) {
        this.RecordUpdateTimerService = RecordUpdateTimerService;
    }
    /**
     * Starts the recording timer.
     * @function
     * @param {RecordStartTimerOptions} options - The options object containing necessary variables and functions.
     */
    /**
     * Starts a recording timer and manages its state.
     *
     * @param {RecordStartTimerOptions} options - The options for starting the recording timer.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     * @param {number} options.parameters.recordStartTime - The start time of the recording.
     * @param {number | null} options.parameters.recordTimerInterval - The interval ID for the recording timer.
     * @param {boolean} options.parameters.isTimerRunning - Flag indicating if the timer is running.
     * @param {boolean} options.parameters.canPauseResume - Flag indicating if pause/resume actions are enabled.
     * @param {number} options.parameters.recordChangeSeconds - The time after which pause/resume actions are enabled.
     * @param {Function} options.parameters.updateRecordStartTime - Function to update the recording start time.
     * @param {Function} options.parameters.updateRecordTimerInterval - Function to update the recording timer interval.
     * @param {Function} options.parameters.updateIsTimerRunning - Function to update the timer running state.
     * @param {Function} options.parameters.updateCanPauseResume - Function to update the pause/resume state.
     *
     * @returns {Promise<void>} A promise that resolves when the timer is started.
     *
     * @remarks
     * This function initializes the recording start time and sets up an interval to update the timer every second.
     * It also manages the state of the timer, including enabling and disabling pause/resume actions.
     * The timer is stopped if the recording is paused, stopped, or if the room name is invalid.
     */
    recordStartTimer = async ({ parameters }) => {
        let { getUpdatedAllParams } = parameters;
        parameters = getUpdatedAllParams();
        let { recordStartTime, recordTimerInterval, isTimerRunning, canPauseResume, recordChangeSeconds, updateRecordStartTime, updateRecordTimerInterval, updateIsTimerRunning, updateCanPauseResume, } = parameters;
        /**
         * Utility function to enable pause/resume actions after a specified time.
         */
        function enablePauseResume() {
            canPauseResume = true;
            updateCanPauseResume(canPauseResume);
        }
        if (!isTimerRunning) {
            recordStartTime = new Date().getTime(); // Get the current timestamp
            updateRecordStartTime(recordStartTime);
            recordTimerInterval = setInterval(() => {
                // Update the timer every second (1000 milliseconds)
                this.RecordUpdateTimerService.recordUpdateTimer({
                    recordElapsedTime: parameters.recordElapsedTime,
                    recordStartTime: recordStartTime,
                    updateRecordElapsedTime: parameters.updateRecordElapsedTime,
                    updateRecordingProgressTime: parameters.updateRecordingProgressTime,
                });
                parameters = getUpdatedAllParams();
                // Check if recording is paused or stopped, and close the interval if needed
                if (parameters.recordPaused ||
                    parameters.recordStopped ||
                    parameters.roomName == '' ||
                    parameters.roomName == null) {
                    clearInterval(recordTimerInterval);
                    updateRecordTimerInterval(null);
                    isTimerRunning = false;
                    updateIsTimerRunning(isTimerRunning);
                    canPauseResume = false;
                    updateCanPauseResume(canPauseResume);
                }
            }, 1000);
            updateRecordTimerInterval(recordTimerInterval);
            isTimerRunning = true;
            updateIsTimerRunning(isTimerRunning);
            canPauseResume = false; // Disable pause/resume actions initially
            updateCanPauseResume(canPauseResume);
            setTimeout(enablePauseResume, recordChangeSeconds); // Enable pause/resume actions after specified time
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordStartTimer, deps: [{ token: RecordUpdateTimer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordStartTimer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordStartTimer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: RecordUpdateTimer }] });

/**
 * Starts the recording process based on the provided parameters.
 *
 * @param {StartRecordingOptions} options - The options for starting the recording.
 * @param {object} options.parameters - The parameters required for starting the recording.
 * @param {string} options.parameters.roomName - The name of the room where recording is to be started.
 * @param {object} options.parameters.userRecordingParams - User-specific recording parameters.
 * @param {object} options.parameters.socket - The socket instance for communication.
 * @param {object} options.parameters.localSocket - The local socket instance for communication.
 * @param {function} options.parameters.updateIsRecordingModalVisible - Function to update the visibility of the recording modal.
 * @param {boolean} options.parameters.confirmedToRecord - Flag indicating if the user has confirmed to record.
 * @param {function} options.parameters.showAlert - Function to show alerts.
 * @param {string} options.parameters.recordingMediaOptions - The media options for recording (e.g., "video", "audio").
 * @param {boolean} options.parameters.videoAlreadyOn - Flag indicating if the video is already on.
 * @param {boolean} options.parameters.audioAlreadyOn - Flag indicating if the audio is already on.
 * @param {boolean} options.parameters.recordStarted - Flag indicating if the recording has started.
 * @param {boolean} options.parameters.recordPaused - Flag indicating if the recording is paused.
 * @param {boolean} options.parameters.recordResumed - Flag indicating if the recording is resumed.
 * @param {boolean} options.parameters.recordStopped - Flag indicating if the recording is stopped.
 * @param {boolean} options.parameters.startReport - Flag indicating if the start report is active.
 * @param {boolean} options.parameters.endReport - Flag indicating if the end report is active.
 * @param {boolean} options.parameters.canRecord - Flag indicating if recording is allowed.
 * @param {function} options.parameters.updateClearedToRecord - Function to update the cleared to record status.
 * @param {function} options.parameters.updateRecordStarted - Function to update the record started status.
 * @param {function} options.parameters.updateRecordPaused - Function to update the record paused status.
 * @param {function} options.parameters.updateRecordResumed - Function to update the record resumed status.
 * @param {function} options.parameters.updateStartReport - Function to update the start report status.
 * @param {function} options.parameters.updateEndReport - Function to update the end report status.
 * @param {function} options.parameters.updateCanRecord - Function to update the can record status.
 * @param {boolean} options.parameters.whiteboardStarted - Flag indicating if the whiteboard has started.
 * @param {boolean} options.parameters.whiteboardEnded - Flag indicating if the whiteboard has ended.
 * @param {function} options.parameters.rePort - Function to report the recording status.
 * @param {function} options.parameters.captureCanvasStream - Function to capture the canvas stream.
 *
 * @returns {Promise<boolean | undefined>} - A promise that resolves to a boolean indicating if the recording attempt was successful, or undefined if not applicable.
 *
 * @remarks
 * This method checks various conditions, such as whether the user has confirmed recording and whether audio or video is already on,
 * before starting the recording. It updates the recording state, manages socket communication, and handles whiteboard functionality if applicable.
 *
 * @example
 * ```typescript
 * const options: StartRecordingOptions = { parameters: someParameters };
 * const result = await startRecording(options);
 * if (result) {
 *   console.log('Recording started successfully.');
 * } else {
 *   console.log('Failed to start recording.');
 * }
 * ```
 */
class StartRecording {
    RecordStartTimerService;
    RecordResumeTimerService;
    constructor(RecordStartTimerService, RecordResumeTimerService) {
        this.RecordStartTimerService = RecordStartTimerService;
        this.RecordResumeTimerService = RecordResumeTimerService;
    }
    /**
     * Starts the recording process based on the provided parameters.
     *
     * @param {StartRecordingOptions} options - The options for starting the recording.
     * @param {object} options.parameters - The parameters required for starting the recording.
     * @param {string} options.parameters.roomName - The name of the room where recording is to be started.
     * @param {object} options.parameters.userRecordingParams - User-specific recording parameters.
     * @param {object} options.parameters.socket - The socket instance for communication.
     * @param {object} options.parameters.localSocket - The local socket instance for communication.
     * @param {function} options.parameters.updateIsRecordingModalVisible - Function to update the visibility of the recording modal.
     * @param {boolean} options.parameters.confirmedToRecord - Flag indicating if the user has confirmed to record.
     * @param {function} options.parameters.showAlert - Function to show alerts.
     * @param {string} options.parameters.recordingMediaOptions - The media options for recording (e.g., "video", "audio").
     * @param {boolean} options.parameters.videoAlreadyOn - Flag indicating if the video is already on.
     * @param {boolean} options.parameters.audioAlreadyOn - Flag indicating if the audio is already on.
     * @param {boolean} options.parameters.recordStarted - Flag indicating if the recording has started.
     * @param {boolean} options.parameters.recordPaused - Flag indicating if the recording is paused.
     * @param {boolean} options.parameters.recordResumed - Flag indicating if the recording is resumed.
     * @param {boolean} options.parameters.recordStopped - Flag indicating if the recording is stopped.
     * @param {boolean} options.parameters.startReport - Flag indicating if the start report is active.
     * @param {boolean} options.parameters.endReport - Flag indicating if the end report is active.
     * @param {boolean} options.parameters.canRecord - Flag indicating if recording is allowed.
     * @param {function} options.parameters.updateClearedToRecord - Function to update the cleared to record status.
     * @param {function} options.parameters.updateRecordStarted - Function to update the record started status.
     * @param {function} options.parameters.updateRecordPaused - Function to update the record paused status.
     * @param {function} options.parameters.updateRecordResumed - Function to update the record resumed status.
     * @param {function} options.parameters.updateStartReport - Function to update the start report status.
     * @param {function} options.parameters.updateEndReport - Function to update the end report status.
     * @param {function} options.parameters.updateCanRecord - Function to update the can record status.
     * @param {boolean} options.parameters.whiteboardStarted - Flag indicating if the whiteboard has started.
     * @param {boolean} options.parameters.whiteboardEnded - Flag indicating if the whiteboard has ended.
     * @param {function} options.parameters.rePort - Function to report the recording status.
     * @param {function} options.parameters.captureCanvasStream - Function to capture the canvas stream.
     *
     * @returns {Promise<boolean | undefined>} - A promise that resolves to a boolean indicating if the recording attempt was successful, or undefined if not applicable.
     */
    startRecording = async ({ parameters }) => {
        parameters = parameters.getUpdatedAllParams();
        let { roomName, userRecordingParams, socket, localSocket, updateIsRecordingModalVisible, confirmedToRecord, showAlert, recordingMediaOptions, videoAlreadyOn, audioAlreadyOn, recordStarted, recordPaused, recordResumed, recordStopped, startReport, endReport, canRecord, updateClearedToRecord, updateRecordStarted, updateRecordPaused, updateRecordResumed, updateStartReport, updateEndReport, updateCanRecord, whiteboardStarted, whiteboardEnded, 
        //mediasfu functions
        rePort, captureCanvasStream, } = parameters;
        // Check if recording is confirmed before starting
        if (!confirmedToRecord) {
            showAlert?.({
                message: 'You must click confirm before you can start recording',
                type: 'danger',
            });
            return false;
        }
        // Check for recordingMediaOptions for video
        if (recordingMediaOptions === 'video' && !videoAlreadyOn) {
            showAlert?.({
                message: 'You must turn on your video before you can start recording',
                type: 'danger',
            });
            return false;
        }
        // Check for recordingMediaOptions for audio
        if (recordingMediaOptions === 'audio' && !audioAlreadyOn) {
            showAlert?.({
                message: 'You must turn on your audio before you can start recording',
                type: 'danger',
            });
            return false;
        }
        // Set clearedToRecord to true
        updateClearedToRecord(true);
        let action = 'startRecord';
        if (recordStarted && recordPaused && !recordResumed && !recordStopped) {
            action = 'resumeRecord';
        }
        else {
            action = 'startRecord';
        }
        let recAttempt = false;
        let socketRef = localSocket && localSocket.connected ? localSocket : socket;
        await new Promise((resolve) => {
            socketRef.emit(action, { roomName, userRecordingParams }, async ({ success, reason }) => {
                if (success) {
                    recordStarted = true;
                    startReport = true;
                    endReport = false;
                    recordPaused = false;
                    recAttempt = true;
                    updateRecordStarted(recordStarted);
                    updateStartReport(startReport);
                    updateEndReport(endReport);
                    updateRecordPaused(recordPaused);
                    if (action === 'startRecord') {
                        await rePort({ parameters });
                        await this.RecordStartTimerService.recordStartTimer({ parameters });
                    }
                    else {
                        recordResumed = true;
                        updateRecordResumed(recordResumed);
                        await rePort({ restart: true, parameters });
                        await this.RecordResumeTimerService.recordResumeTimer({ parameters });
                    }
                }
                else {
                    showAlert?.({ message: `Recording could not start - ${reason}`, type: 'danger' });
                    canRecord = true;
                    startReport = false;
                    endReport = true;
                    recAttempt = false;
                    updateCanRecord(canRecord);
                    updateStartReport(startReport);
                    updateEndReport(endReport);
                }
                resolve();
            });
        });
        // Capture canvas stream if recording is successful and whiteboard is active
        try {
            if (recAttempt &&
                whiteboardStarted &&
                !whiteboardEnded &&
                recordingMediaOptions === 'video') {
                captureCanvasStream({ parameters });
            }
        }
        catch (error) {
            console.log('Error capturing canvas stream:', error);
        }
        // Set isRecordingModalVisible to false
        updateIsRecordingModalVisible(false);
        return recAttempt;
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartRecording, deps: [{ token: RecordStartTimer }, { token: RecordResumeTimer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: RecordStartTimer }, { type: RecordResumeTimer }] });

/**
 * Stops the recording process based on the provided parameters.
 *
 * @param {StopRecordingOptions} options - The options for stopping the recording.
 * @param {Object} options.parameters - The parameters required for stopping the recording.
 * @param {string} options.parameters.roomName - The name of the room where the recording is being stopped.
 * @param {Socket} options.parameters.socket - The socket instance for communication.
 * @param {Socket} [options.parameters.localSocket] - The local socket instance for communication.
 * @param {Function} options.parameters.showAlert - Function to show alerts.
 * @param {boolean} options.parameters.startReport - Flag indicating if the start report is active.
 * @param {boolean} options.parameters.endReport - Flag indicating if the end report is active.
 * @param {boolean} options.parameters.recordStarted - Flag indicating if the recording has started.
 * @param {boolean} options.parameters.recordPaused - Flag indicating if the recording is paused.
 * @param {boolean} options.parameters.recordStopped - Flag indicating if the recording is stopped.
 * @param {Function} options.parameters.updateRecordPaused - Function to update the record paused status.
 * @param {Function} options.parameters.updateRecordStopped - Function to update the record stopped status.
 * @param {Function} options.parameters.updateStartReport - Function to update the start report status.
 * @param {Function} options.parameters.updateEndReport - Function to update the end report status.
 * @param {Function} options.parameters.updateShowRecordButtons - Function to update the visibility of recording buttons.
 * @param {boolean} options.parameters.whiteboardStarted - Flag indicating if the whiteboard has started.
 * @param {boolean} options.parameters.whiteboardEnded - Flag indicating if the whiteboard has ended.
 * @param {string} options.parameters.recordingMediaOptions - The media options for recording (e.g., "video", "audio").
 * @param {Function} options.parameters.captureCanvasStream - Function to capture the canvas stream.
 *
 * @returns {Promise<void>} - A promise that resolves when the recording is stopped.
 *
 * @remarks
 * This method checks if the recording has started and is not already stopped.
 * It pauses the timer and emits a stop recording event via socket communication.
 * If successful, it updates the recording state and alerts the user.
 * Additionally, if the whiteboard feature is active, it captures the canvas stream.
 *
 * @example
 * ```typescript
 * const options: StopRecordingOptions = { parameters: someParameters };
 * await stopRecording(options);
 * console.log('Recording stopped successfully.');
 * ```
 */
class StopRecording {
    RecordPauseTimerService;
    constructor(RecordPauseTimerService) {
        this.RecordPauseTimerService = RecordPauseTimerService;
    }
    async stopRecording({ parameters }) {
        let { roomName, socket, localSocket, showAlert, startReport, endReport, recordStarted, recordPaused, recordStopped, updateRecordPaused, updateRecordStopped, updateStartReport, updateEndReport, updateShowRecordButtons, whiteboardStarted, whiteboardEnded, recordingMediaOptions, 
        //mediasfu functions
        captureCanvasStream, } = parameters;
        let recAttempt;
        if (recordStarted && !recordStopped) {
            let stop = this.RecordPauseTimerService.recordPauseTimer({
                stop: true,
                isTimerRunning: parameters['isTimerRunning'],
                canPauseResume: parameters['canPauseResume'],
                showAlert: parameters.showAlert,
            });
            if (stop) {
                let action = 'stopRecord';
                let socketRef = localSocket && localSocket.connected ? localSocket : socket;
                await new Promise((resolve) => {
                    socketRef.emit(action, { roomName }, ({ success, reason, recordState, }) => {
                        if (success) {
                            startReport = false;
                            endReport = true;
                            recordPaused = false;
                            recordStopped = true;
                            recAttempt = true;
                            updateStartReport(startReport);
                            updateEndReport(endReport);
                            updateRecordPaused(recordPaused);
                            updateRecordStopped(recordStopped);
                            showAlert?.({ message: 'Recording Stopped', type: 'success' });
                            updateShowRecordButtons(false);
                        }
                        else {
                            let reasonMessage = `Recording Stop Failed: ${reason}; the recording is currently ${recordState}`;
                            showAlert?.({ message: reasonMessage, type: 'danger' });
                            recAttempt = false;
                        }
                        resolve();
                    });
                });
                try {
                    if (recAttempt && whiteboardStarted && !whiteboardEnded) {
                        if (recordingMediaOptions === 'video') {
                            captureCanvasStream({ parameters, start: false });
                        }
                    }
                }
                catch (error) {
                    console.log('Error capturing canvas stream:', error);
                }
            }
            else {
                return;
            }
        }
        else {
            showAlert?.({ message: 'Recording is not started yet or already stopped', type: 'danger' });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StopRecording, deps: [{ token: RecordPauseTimer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StopRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StopRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: RecordPauseTimer }] });

/**
 * Updates the recording state based on the provided parameters.
 *
 * @param {UpdateRecordingOptions} options - The options for updating the recording state.
 * @param {Object} options.parameters - The parameters required for updating the recording state.
 * @param {string} options.parameters.roomName - The name of the room where the recording is taking place.
 * @param {UserRecordingParams} options.parameters.userRecordingParams - User-specific recording parameters.
 * @param {Socket} options.parameters.socket - The socket instance for communication.
 * @param {Socket} [options.parameters.localSocket] - The local socket instance for communication.
 * @param {Function} options.parameters.updateIsRecordingModalVisible - Function to update the visibility of the recording modal.
 * @param {boolean} options.parameters.confirmedToRecord - Indicates if the user has confirmed to start recording.
 * @param {Function} options.parameters.showAlert - Function to show alerts.
 * @param {string} options.parameters.recordingMediaOptions - The media options for recording (e.g., "video", "audio").
 * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is already turned on.
 * @param {boolean} options.parameters.audioAlreadyOn - Indicates if the audio is already turned on.
 * @param {boolean} options.parameters.recordStarted - Indicates if the recording has started.
 * @param {boolean} options.parameters.recordPaused - Indicates if the recording is paused.
 * @param {boolean} options.parameters.recordResumed - Indicates if the recording has resumed.
 * @param {boolean} options.parameters.recordStopped - Indicates if the recording has stopped.
 * @param {number} options.parameters.recordChangeSeconds - The interval in seconds for changing the recording state.
 * @param {number} options.parameters.pauseRecordCount - The count of pauses during the recording.
 * @param {boolean} options.parameters.startReport - Indicates if the start report is active.
 * @param {boolean} options.parameters.endReport - Indicates if the end report is active.
 * @param {boolean} options.parameters.canRecord - Indicates if recording is allowed.
 * @param {boolean} options.parameters.canPauseResume - Indicates if pausing and resuming the recording is allowed.
 * @param {Function} options.parameters.updateCanPauseResume - Function to update the pause/resume state.
 * @param {Function} options.parameters.updatePauseRecordCount - Function to update the pause record count.
 * @param {Function} options.parameters.updateClearedToRecord - Function to update the cleared-to-record state.
 * @param {Function} options.parameters.updateRecordPaused - Function to update the record paused state.
 * @param {Function} options.parameters.updateRecordResumed - Function to update the record resumed state.
 * @param {Function} options.parameters.updateStartReport - Function to update the start report state.
 * @param {Function} options.parameters.updateEndReport - Function to update the end report state.
 * @param {Function} options.parameters.updateCanRecord - Function to update the can record state.
 * @param {Function} options.parameters.rePort - Function to handle reporting.
 *
 * @returns {Promise<void>} A promise that resolves when the recording state has been updated.
 *
 * @remarks
 * This method handles the recording state updates, including starting, pausing, resuming, and stopping the recording.
 * It also performs necessary checks to ensure that the user can perform the requested actions based on their current state.
 * Alerts are displayed for any issues encountered during the process.
 *
 * @example
 * ```typescript
 * const options: UpdateRecordingOptions = { parameters: someParameters };
 * await updateRecording(options);
 * console.log('Recording state updated successfully.');
 * ```
 */
class UpdateRecording {
    CheckPauseStateService;
    CheckResumeStateService;
    RecordPauseTimerService;
    RecordResumeTimerService;
    constructor(CheckPauseStateService, CheckResumeStateService, RecordPauseTimerService, RecordResumeTimerService) {
        this.CheckPauseStateService = CheckPauseStateService;
        this.CheckResumeStateService = CheckResumeStateService;
        this.RecordPauseTimerService = RecordPauseTimerService;
        this.RecordResumeTimerService = RecordResumeTimerService;
    }
    /**
     * Updates the recording state based on the provided parameters.
     *
     * @param {UpdateRecordingOptions} parameters - The parameters for updating the recording state.
     * @returns {Promise<void>} A promise that resolves when the recording state has been updated.
     *
     * @property {string} roomName - The name of the room where the recording is taking place.
     * @property {any} userRecordingParams - Parameters related to the user's recording settings.
     * @property {any} socket - The socket connection used for communication.
     * @property {any} localSocket - The local socket connection used for communication.
     * @property {Function} updateIsRecordingModalVisible - Function to update the visibility of the recording modal.
     * @property {boolean} confirmedToRecord - Indicates if the user has confirmed to start recording.
     * @property {Function} showAlert - Function to show alert messages.
     * @property {string} recordingMediaOptions - The media options for recording (e.g., "video", "audio").
     * @property {boolean} videoAlreadyOn - Indicates if the video is already turned on.
     * @property {boolean} audioAlreadyOn - Indicates if the audio is already turned on.
     * @property {boolean} recordStarted - Indicates if the recording has started.
     * @property {boolean} recordPaused - Indicates if the recording is paused.
     * @property {boolean} recordResumed - Indicates if the recording has resumed.
     * @property {boolean} recordStopped - Indicates if the recording has stopped.
     * @property {number} recordChangeSeconds - The interval in seconds for changing the recording state.
     * @property {number} pauseRecordCount - The count of pauses during the recording.
     * @property {boolean} startReport - Indicates if the start report is active.
     * @property {boolean} endReport - Indicates if the end report is active.
     * @property {boolean} canRecord - Indicates if recording is allowed.
     * @property {boolean} canPauseResume - Indicates if pausing and resuming the recording is allowed.
     * @property {Function} updateCanPauseResume - Function to update the pause/resume state.
     * @property {Function} updatePauseRecordCount - Function to update the pause record count.
     * @property {Function} updateClearedToRecord - Function to update the cleared-to-record state.
     * @property {Function} updateRecordPaused - Function to update the record paused state.
     * @property {Function} updateRecordResumed - Function to update the record resumed state.
     * @property {Function} updateStartReport - Function to update the start report state.
     * @property {Function} updateEndReport - Function to update the end report state.
     * @property {Function} updateCanRecord - Function to update the can record state.
     * @property {Function} rePort - Function to handle reporting.
     */
    updateRecording = async ({ parameters }) => {
        parameters = parameters.getUpdatedAllParams();
        let { roomName, userRecordingParams, socket, localSocket, updateIsRecordingModalVisible, confirmedToRecord, showAlert, recordingMediaOptions, videoAlreadyOn, audioAlreadyOn, recordStarted, recordPaused, recordResumed, recordStopped, recordChangeSeconds, pauseRecordCount, startReport, endReport, canRecord, updateCanPauseResume, updatePauseRecordCount, updateClearedToRecord, updateRecordPaused, updateRecordResumed, updateStartReport, updateEndReport, updateCanRecord, 
        //mediasfu functions
        // checkPauseState,
        // checkResumeState,
        rePort,
        // recordPauseTimer,
        // recordResumeTimer,
         } = parameters;
        // Check if recording is confirmed before starting
        if (recordStopped) {
            showAlert?.({
                message: 'Recording has already stopped',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Check for recordingMediaOptions for video
        if (recordingMediaOptions === 'video' && !videoAlreadyOn) {
            showAlert?.({
                message: 'You must turn on your video before you can start recording',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Check for recordingMediaOptions for audio
        if (recordingMediaOptions === 'audio' && !audioAlreadyOn) {
            showAlert?.({
                message: 'You must turn on your audio before you can start recording',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        let socketRef = localSocket && localSocket.connected ? localSocket : socket;
        if (recordStarted && !recordPaused && !recordStopped) {
            let proceed = false;
            proceed = await this.CheckPauseStateService.checkPauseState({
                recordingMediaOptions,
                recordingVideoPausesLimit: parameters['recordingVideoPausesLimit'],
                recordingAudioPausesLimit: parameters['recordingAudioPausesLimit'],
                pauseRecordCount,
                showAlert,
            });
            if (!proceed) {
                return;
            }
            let record = this.RecordPauseTimerService.recordPauseTimer({
                stop: false,
                isTimerRunning: parameters.isTimerRunning,
                canPauseResume: parameters.canPauseResume,
                showAlert,
            });
            if (record) {
                let action = 'pauseRecord';
                await new Promise((resolve) => {
                    socketRef.emit(action, { roomName }, async ({ success, reason, recordState, pauseCount, }) => {
                        pauseRecordCount = pauseCount;
                        updatePauseRecordCount(pauseRecordCount);
                        if (success) {
                            startReport = false;
                            endReport = true;
                            recordPaused = true;
                            updateStartReport(startReport);
                            updateEndReport(endReport);
                            updateRecordPaused(recordPaused);
                            showAlert?.({
                                message: 'Recording paused',
                                type: 'success',
                                duration: 3000,
                            });
                            // Set isRecordingModalVisible to false
                            updateIsRecordingModalVisible(false);
                            setTimeout(() => {
                                updateCanPauseResume(true);
                            }, recordChangeSeconds);
                        }
                        else {
                            let reasonMessage = `Recording Pause Failed: ${reason}; the current state is: ${recordState}`;
                            showAlert?.({
                                message: reasonMessage,
                                type: 'danger',
                                duration: 3000,
                            });
                        }
                        resolve();
                    });
                });
            }
        }
        else if (recordStarted && recordPaused && !recordStopped) {
            if (!confirmedToRecord) {
                showAlert?.({
                    message: 'You must click confirm before you can start recording',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            let proceed = false;
            proceed = await this.CheckResumeStateService.checkResumeState({
                recordingMediaOptions,
                recordingVideoPausesLimit: parameters['recordingVideoPausesLimit'],
                recordingAudioPausesLimit: parameters['recordingAudioPausesLimit'],
                pauseRecordCount,
            });
            if (!proceed) {
                return;
            }
            let resume = await this.RecordResumeTimerService.recordResumeTimer({ parameters });
            if (resume) {
                // Set clearedToRecord to true
                updateClearedToRecord(true);
                let action = 'startRecord';
                if (recordStarted && recordPaused && !recordResumed && !recordStopped) {
                    action = 'resumeRecord';
                }
                else {
                    action = 'startRecord';
                }
                action = 'resumeRecord';
                await new Promise((resolve) => {
                    socketRef.emit(action, { roomName, userRecordingParams }, async ({ success, reason, }) => {
                        if (success) {
                            recordPaused = false;
                            recordResumed = true;
                            updateRecordPaused(recordPaused);
                            updateRecordResumed(recordResumed);
                            if (action === 'startRecord') {
                                await rePort({ parameters });
                            }
                            else {
                                recordResumed = true;
                                await rePort({ restart: true, parameters });
                            }
                        }
                        else {
                            showAlert?.({
                                message: `Recording could not start - ${reason}`,
                                type: 'danger',
                                duration: 3000,
                            });
                            canRecord = true;
                            startReport = false;
                            endReport = true;
                            updateCanRecord(canRecord);
                            updateStartReport(startReport);
                            updateEndReport(endReport);
                        }
                        resolve();
                    });
                });
                // Set isRecordingModalVisible to false
                updateIsRecordingModalVisible(false);
                setTimeout(() => {
                    updateCanPauseResume(true);
                }, recordChangeSeconds);
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateRecording, deps: [{ token: CheckPauseState }, { token: CheckResumeState }, { token: RecordPauseTimer }, { token: RecordResumeTimer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: CheckPauseState }, { type: CheckResumeState }, { type: RecordPauseTimer }, { type: RecordResumeTimer }] });

// requests.service.ts
/**
 * Toggles the visibility state of the requests modal.
 *
 * @param {LaunchRequestsOptions} options - The options for launching requests.
 * @param {Function} options.updateIsRequestsModalVisible - Function to update the visibility state of the requests modal.
 * @param {boolean} options.isRequestsModalVisible - Current visibility state of the requests modal.
 * @returns {void}
 *
 * @remarks
 * This method is used to open or close the requests modal by toggling its visibility state.
 * It takes the current visibility state as input and updates it accordingly.
 *
 * @example
 * ```typescript
 * const options: LaunchRequestsOptions = {
 *   updateIsRequestsModalVisible: (isVisible) => {
 *     console.log('Requests modal visibility:', isVisible);
 *   },
 *   isRequestsModalVisible: false,
 * };
 *
 * const launchRequestsService = new LaunchRequests();
 * launchRequestsService.launchRequests(options);
 * ```
 */
class LaunchRequests {
    /**
     * Toggles the visibility state of the requests modal.
     *
     * @param {LaunchRequestsOptions} options - The options for launching requests.
     * @param {Function} options.updateIsRequestsModalVisible - Function to update the visibility state of the requests modal.
     * @param {boolean} options.isRequestsModalVisible - Current visibility state of the requests modal.
     * @returns {void}
     */
    launchRequests({ updateIsRequestsModalVisible, isRequestsModalVisible, }) {
        // Toggle the visibility of the display settings modal.
        updateIsRequestsModalVisible(!isRequestsModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchRequests, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchRequests, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchRequests, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Responds to incoming requests by updating the request list and emitting a response to the server.
 *
 * @param {RespondToRequestsOptions} options - The options for responding to requests.
 * @param {Socket} options.socket - The socket instance used to emit the response.
 * @param {Request} options.request - The request object containing details of the request.
 * @param {Function} options.updateRequestList - The function to update the request list.
 * @param {Request[]} options.requestList - The current list of requests.
 * @param {string} options.action - The action to be taken on the request.
 * @param {string} options.roomName - The name of the room to which the response should be emitted.
 *
 * @returns {Promise<void>} A promise that resolves when the response has been emitted.
 *
 * @remarks
 * This method filters out the request that is being responded to from the current request list,
 * updates the list, and emits the response to the server using the provided socket.
 * It ensures that the state of the requests is accurately reflected in the application.
 *
 * @example
 * ```typescript
 * const options: RespondToRequestsOptions = {
 *   socket: socketInstance,
 *   request: {
 *     id: 'request_id',
 *     name: 'Request Name',
 *     icon: 'request_icon'
 *   },
 *   updateRequestList: (newRequestList) => {
 *     console.log('Updated request list:', newRequestList);
 *   },
 *   requestList: currentRequestList,
 *   action: 'accept',
 *   roomName: 'Room 1',
 * };
 *
 * const respondToRequestsService = new RespondToRequests();
 * await respondToRequestsService.respondToRequests(options);
 * ```
 */
class RespondToRequests {
    /**
     * Responds to incoming requests by updating the request list and emitting a response to the server.
     *
     * @param {Object} options - The options for responding to requests.
     * @param {Socket} options.socket - The socket instance used to emit the response.
     * @param {Request} options.request - The request object containing details of the request.
     * @param {Function} options.updateRequestList - The function to update the request list.
     * @param {Request[]} options.requestList - The current list of requests.
     * @param {string} options.action - The action to be taken on the request.
     * @param {string} options.roomName - The name of the room to which the response should be emitted.
     *
     * @returns {Promise<void>} A promise that resolves when the response has been emitted.
     */
    async respondToRequests({ socket, request, updateRequestList, requestList, action, roomName, }) {
        // Filter out the request that is being responded to
        let newRequestList = requestList.filter((request_) => {
            return !(request_.id === request.id &&
                request_.icon === request.icon &&
                request_.name === request.name);
        });
        // Update the request list
        updateRequestList(newRequestList);
        // Prepare the request response object
        let requestResponse = {
            id: request.id,
            name: request.name,
            type: request.icon,
            action: action,
        };
        // Emit the response via the socket
        socket.emit('updateUserofRequestStatus', { requestResponse, roomName });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RespondToRequests, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RespondToRequests, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RespondToRequests, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// settings.service.ts
/**
 * Toggles the visibility state of the settings modal.
 *
 * @param {LaunchSettingsOptions} options - The options for launching settings.
 * @param {Function} options.updateIsSettingsModalVisible - Function to update the visibility state of the settings modal.
 * @param {boolean} options.isSettingsModalVisible - Current visibility state of the settings modal.
 * @returns {void}
 *
 * @remarks
 * This method toggles the current visibility state of the settings modal.
 * If the modal is currently visible, it will be hidden, and vice versa.
 *
 * @example
 * ```typescript
 * const options: LaunchSettingsOptions = {
 *   updateIsSettingsModalVisible: (isVisible) => {
 *     console.log('Settings modal visibility:', isVisible);
 *   },
 *   isSettingsModalVisible: false,
 * };
 *
 * const launchSettingsService = new LaunchSettings();
 * launchSettingsService.launchSettings(options);
 * ```
 */
class LaunchSettings {
    /**
     * Toggles the visibility state of the settings modal.
     *
     * @param {LaunchSettingsOptions} options - The options for launching settings.
     * @param {Function} options.updateIsSettingsModalVisible - Function to update the visibility state of the settings modal.
     * @param {boolean} options.isSettingsModalVisible - Current visibility state of the settings modal.
     * @returns {void}
     */
    launchSettings({ updateIsSettingsModalVisible, isSettingsModalVisible, }) {
        // Toggle the visibility of the display settings modal.
        updateIsSettingsModalVisible(!isSettingsModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchSettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchSettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchSettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Modifies the settings for a given room and updates the state accordingly.
 *
 * @param {ModifySettingsOptions} options - The options for modifying settings.
 * @param {Function} options.showAlert - Function to show alert messages.
 * @param {string} options.roomName - The name of the room.
 * @param {string} options.audioSet - The audio setting to be applied.
 * @param {string} options.videoSet - The video setting to be applied.
 * @param {string} options.screenshareSet - The screenshare setting to be applied.
 * @param {string} options.chatSet - The chat setting to be applied.
 * @param {Socket} options.socket - The socket instance for emitting events.
 * @param {Function} options.updateAudioSetting - Function to update the audio setting state.
 * @param {Function} options.updateVideoSetting - Function to update the video setting state.
 * @param {Function} options.updateScreenshareSetting - Function to update the screenshare setting state.
 * @param {Function} options.updateChatSetting - Function to update the chat setting state.
 * @param {Function} options.updateIsSettingsModalVisible - Function to update the visibility of the settings modal.
 *
 * @returns {Promise<void>} A promise that resolves when the settings have been modified.
 *
 * @throws Will show an alert if any setting is set to "approval" in demo mode (room name starts with "d").
 *
 * @example
 * ```typescript
 * const options: ModifySettingsOptions = {
 *   showAlert: (alert) => console.log(alert),
 *   roomName: 'exampleRoom',
 *   audioSet: 'enabled',
 *   videoSet: 'disabled',
 *   screenshareSet: 'approval',
 *   chatSet: 'enabled',
 *   socket: socketInstance,
 *   updateAudioSetting: (audio) => console.log('Audio setting updated:', audio),
 *   updateVideoSetting: (video) => console.log('Video setting updated:', video),
 *   updateScreenshareSetting: (screenshare) => console.log('Screenshare setting updated:', screenshare),
 *   updateChatSetting: (chat) => console.log('Chat setting updated:', chat),
 *   updateIsSettingsModalVisible: (visible) => console.log('Settings modal visibility:', visible),
 * };
 *
 * const modifySettingsService = new ModifySettings();
 * await modifySettingsService.modifySettings(options);
 * ```
 */
class ModifySettings {
    /**
     * Modifies the settings for a given room and updates the state accordingly.
     *
     * @param {Object} options - The options for modifying settings.
     * @param {Function} options.showAlert - Function to show alert messages.
     * @param {string} options.roomName - The name of the room.
     * @param {string} options.audioSet - The audio setting to be applied.
     * @param {string} options.videoSet - The video setting to be applied.
     * @param {string} options.screenshareSet - The screenshare setting to be applied.
     * @param {string} options.chatSet - The chat setting to be applied.
     * @param {Object} options.socket - The socket instance for emitting events.
     * @param {Function} options.updateAudioSetting - Function to update the audio setting state.
     * @param {Function} options.updateVideoSetting - Function to update the video setting state.
     * @param {Function} options.updateScreenshareSetting - Function to update the screenshare setting state.
     * @param {Function} options.updateChatSetting - Function to update the chat setting state.
     * @param {Function} options.updateIsSettingsModalVisible - Function to update the visibility of the settings modal.
     *
     * @returns {Promise<void>} A promise that resolves when the settings have been modified.
     *
     * @throws Will show an alert if any setting is set to "approval" in demo mode (room name starts with "d").
     */
    modifySettings = async ({ showAlert, roomName, audioSet, videoSet, screenshareSet, chatSet, socket, updateAudioSetting, updateVideoSetting, updateScreenshareSetting, updateChatSetting, updateIsSettingsModalVisible, }) => {
        if (roomName.toLowerCase().startsWith('d')) {
            // none should be approval
            if (audioSet === 'approval' ||
                videoSet === 'approval' ||
                screenshareSet === 'approval' ||
                chatSet === 'approval') {
                showAlert?.({
                    message: 'You cannot set approval for demo mode.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        // Check and update state variables based on the provided logic
        if (audioSet) {
            updateAudioSetting(audioSet);
        }
        if (videoSet) {
            updateVideoSetting(videoSet);
        }
        if (screenshareSet) {
            updateScreenshareSetting(screenshareSet);
        }
        if (chatSet) {
            updateChatSetting(chatSet);
        }
        const settings = [audioSet, videoSet, screenshareSet, chatSet];
        socket.emit('updateSettingsForRequests', { settings, roomName });
        // Close modal
        updateIsSettingsModalVisible(false);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ModifySettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ModifySettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ModifySettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Handles the click event for toggling audio in a media session.
 *
 * @param {ClickAudioOptions} options - The parameters required for handling the audio click event.
 * @param {Object} options.parameters - The parameters for toggling audio.
 * @param {boolean} options.parameters.checkMediaPermission - Flag indicating whether to check media permission.
 * @param {boolean} options.parameters.hasAudioPermission - Flag indicating if the user has audio permission.
 * @param {boolean} options.parameters.audioPaused - Flag indicating if audio is paused.
 * @param {boolean} options.parameters.audioAlreadyOn - Flag indicating if audio is already turned on.
 * @param {boolean} options.parameters.audioOnlyRoom - Flag indicating if the room is audio-only.
 * @param {boolean} options.parameters.recordStarted - Flag indicating if recording has started.
 * @param {boolean} options.parameters.recordResumed - Flag indicating if recording has resumed.
 * @param {boolean} options.parameters.recordPaused - Flag indicating if recording is paused.
 * @param {boolean} options.parameters.recordStopped - Flag indicating if recording is stopped.
 * @param {string} options.parameters.recordingMediaOptions - Media options for recording (e.g., "video", "audio").
 * @param {string} options.parameters.islevel - User's level in the application.
 * @param {boolean} options.parameters.youAreCoHost - Flag indicating if the user is a co-host.
 * @param {boolean} options.parameters.adminRestrictSetting - Flag indicating if admin restrictions are set.
 * @param {string | null} options.parameters.audioRequestState - Current state of the audio request.
 * @param {number} options.parameters.audioRequestTime - Timestamp of the audio request.
 * @param {string} options.parameters.member - Current member's name.
 * @param {Socket} options.parameters.socket - The socket instance for communication.
 * @param {Socket} options.parameters.localSocket - The local socket instance for communication.
 * @param {string} options.parameters.roomName - The name of the room.
 * @param {string} options.parameters.userDefaultAudioInputDevice - The default audio input device for the user.
 * @param {boolean} options.parameters.micAction - Flag indicating if the microphone action is in progress.
 * @param {MediaStream | null} options.parameters.localStream - The user's local media stream.
 * @param {string} options.parameters.audioSetting - Current audio setting.
 * @param {string} options.parameters.videoSetting - Current video setting.
 * @param {string} options.parameters.screenshareSetting - Current screenshare setting.
 * @param {string} options.parameters.chatSetting - Current chat setting.
 * @param {number} options.parameters.updateRequestIntervalSeconds - Interval for updating request states.
 * @param {Participant[]} options.parameters.participants - List of participants in the room.
 * @param {boolean} options.parameters.transportCreated - Flag indicating if the transport has been created.
 * @param {boolean} options.parameters.transportCreatedAudio - Flag indicating if audio transport has been created.
 *
 * @returns {Promise<void>} A promise that resolves when the audio click event has been handled.
 *
 * @remarks
 * This function performs the following actions:
 * - If the event is audio-only, it shows an alert and exits.
 * - If the audio is already on, it handles the logic for turning it off, including checking recording states and permissions.
 * - If the audio is off, it checks for admin restrictions, user permissions, and handles the logic for turning the audio on.
 * - It updates various states and emits socket events as necessary.
 *
 * @example
 * ```typescript
 * const options: ClickAudioOptions = {
 *   parameters: {
 *     checkMediaPermission: true,
 *     hasAudioPermission: false,
 *     audioPaused: false,
 *     audioAlreadyOn: false,
 *     audioOnlyRoom: false,
 *     recordStarted: false,
 *     recordResumed: false,
 *     recordPaused: false,
 *     recordStopped: false,
 *     recordingMediaOptions: 'audio',
 *     islevel: '1',
 *     youAreCoHost: false,
 *     adminRestrictSetting: false,
 *     audioRequestState: null,
 *     audioRequestTime: 0,
 *     member: 'John Doe',
 *     socket: socketInstance,
 *     localSocket: socketInstance,
 *     roomName: 'exampleRoom',
 *     userDefaultAudioInputDevice: 'default',
 *     micAction: false,
 *     localStream: null,
 *     audioSetting: 'enabled',
 *     videoSetting: 'disabled',
 *     screenshareSetting: 'disabled',
 *     chatSetting: 'enabled',
 *     updateRequestIntervalSeconds: 30,
 *     participants: [],
 *     transportCreated: false,
 *     transportCreatedAudio: false,
 *     updateAudioAlreadyOn: (status) => console.log(status),
 *     updateAudioRequestState: (state) => console.log(state),
 *     updateAudioPaused: (status) => console.log(status),
 *     updateLocalStream: (stream) => console.log(stream),
 *     updateParticipants: (participants) => console.log(participants),
 *     updateTransportCreated: (status) => console.log(status),
 *     updateTransportCreatedAudio: (status) => console.log(status),
 *     updateMicAction: (action) => console.log(action),
 *     checkPermission: async () => 'granted',
 *     streamSuccessAudio: async () => console.log('Audio streaming success'),
 *     disconnectSendTransportAudio: async () => console.log('Audio transport disconnected'),
 *     requestPermissionAudio: async () => 'granted',
 *     resumeSendTransportAudio: async () => console.log('Audio transport resumed'),
 *   },
 * };
 *
 * const clickAudioService = new ClickAudio();
 * await clickAudioService.clickAudio(options);
 * ```
 */
class ClickAudio {
    /**
     * Handles the click event for toggling audio in a media session.
     *
     * @param {ClickAudioOptions} parameters - The parameters required for handling the audio click event.
     * @returns {Promise<void>} A promise that resolves when the audio click event has been handled.
     *
     * The function performs the following actions:
     * - If the event is audio-only, it shows an alert and exits.
     * - If the audio is already on, it handles the logic for turning it off, including checking recording states and permissions.
     * - If the audio is off, it checks for admin restrictions, user permissions, and handles the logic for turning the audio on.
     * - It updates various states and emits socket events as necessary.
     *
     * The function makes use of several helper functions and state update functions passed in through the parameters.
     */
    async clickAudio({ parameters }) {
        let { checkMediaPermission, hasAudioPermission, audioPaused, audioAlreadyOn, audioOnlyRoom, recordStarted, recordResumed, recordPaused, recordStopped, recordingMediaOptions, islevel, youAreCoHost, adminRestrictSetting, audioRequestState, audioRequestTime, member, socket, localSocket, roomName, userDefaultAudioInputDevice, micAction, localStream, audioSetting, videoSetting, screenshareSetting, chatSetting, updateRequestIntervalSeconds, participants, showAlert, transportCreated, transportCreatedAudio, updateAudioAlreadyOn, updateAudioRequestState, updateAudioPaused, updateLocalStream, updateParticipants, updateTransportCreated, updateTransportCreatedAudio, updateMicAction, checkPermission, streamSuccessAudio, requestPermissionAudio, resumeSendTransportAudio, disconnectSendTransportAudio, } = parameters;
        if (audioOnlyRoom) {
            showAlert?.({
                message: 'You cannot turn on your camera in an audio-only event.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (audioAlreadyOn) {
            if (islevel === '2' && (recordStarted || recordResumed)) {
                if (!(recordPaused || recordStopped)) {
                    if (recordingMediaOptions === 'audio') {
                        showAlert?.({
                            message: 'You cannot turn off your audio while recording, please pause or stop recording first.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                }
            }
            audioAlreadyOn = false;
            updateAudioAlreadyOn(audioAlreadyOn);
            if (localStream) {
                localStream.getAudioTracks()[0].enabled = false;
            }
            updateLocalStream(localStream);
            await disconnectSendTransportAudio({ parameters }); //disconnect function here actuall calls audioProducer.pause() instead of close() as in mediasfu
            audioPaused = true;
            updateAudioPaused(audioPaused);
        }
        else {
            if (adminRestrictSetting) {
                showAlert?.({
                    message: 'You cannot turn on your microphone. Access denied by host.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            let response = 2;
            if (!micAction && islevel !== '2' && !youAreCoHost) {
                response = await checkPermission({
                    permissionType: 'audioSetting',
                    audioSetting,
                    videoSetting,
                    screenshareSetting,
                    chatSetting,
                });
            }
            else {
                response = 0;
            }
            switch (response) {
                case 1: {
                    if (audioRequestState === 'pending') {
                        showAlert?.({
                            message: 'A request is pending. Please wait for the host to respond.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                    showAlert?.({
                        message: 'Request sent to host.',
                        type: 'success',
                        duration: 3000,
                    });
                    audioRequestState = 'pending';
                    updateAudioRequestState(audioRequestState);
                    //create a request and add to the request list and send to host
                    const userRequest = {
                        id: socket.id,
                        name: member,
                        icon: 'fa-microphone',
                    };
                    socket.emit('participantRequest', { userRequest, roomName });
                    break;
                }
                case 2:
                    if (audioRequestState === 'rejected' &&
                        Date.now() - audioRequestTime < updateRequestIntervalSeconds * 1000) {
                        showAlert?.({
                            message: `A request was rejected. Please wait for ${updateRequestIntervalSeconds} seconds before sending another request.`,
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                    break;
                case 0:
                    //allow
                    if (audioPaused) {
                        if (localStream) {
                            localStream.getAudioTracks()[0].enabled = true;
                        }
                        updateAudioAlreadyOn(true);
                        await resumeSendTransportAudio({ parameters });
                        socket.emit('resumeProducerAudio', { mediaTag: 'audio', roomName });
                        try {
                            if (localSocket && localSocket.id) {
                                localSocket.emit("resumeProducerAudio", { mediaTag: "audio", roomName });
                            }
                        }
                        catch (error) {
                            console.log("Error in resumeProducerAudio", error);
                        }
                        updateLocalStream(localStream);
                        if (micAction == true) {
                            micAction = false;
                            updateMicAction(micAction);
                        }
                        participants.forEach((participant) => {
                            if (participant['socketId'] === socket.id && participant.name === member) {
                                participant.muted = false;
                            }
                        });
                        updateParticipants(participants);
                        transportCreated = true;
                        updateTransportCreated(transportCreated);
                        transportCreatedAudio = true;
                        updateTransportCreatedAudio(transportCreatedAudio);
                    }
                    else {
                        if (!hasAudioPermission && checkMediaPermission) {
                            const statusMic = await requestPermissionAudio();
                            if (statusMic !== 'granted') {
                                showAlert?.({
                                    message: 'Allow access to your microphone or check if your microphone is not being used by another application.',
                                    type: 'danger',
                                    duration: 3000,
                                });
                                return;
                            }
                        }
                        const mediaConstraints = userDefaultAudioInputDevice
                            ? { audio: { deviceId: userDefaultAudioInputDevice }, video: false }
                            : { audio: true, video: false };
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
                            await streamSuccessAudio({ stream, parameters });
                        }
                        catch (error) {
                            console.error(error);
                            showAlert?.({
                                message: 'Allow access to your microphone or check if your microphone is not being used by another application.',
                                type: 'danger',
                                duration: 3000,
                            });
                        }
                    }
                    break;
                default:
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Toggles the visibility of the chat modal based on the current state and event settings.
 *
 * @param {ClickChatOptions} options - The options for the clickChat function.
 * @param {boolean} options.isMessagesModalVisible - Indicates if the messages modal is currently visible.
 * @param {Function} options.updateIsMessagesModalVisible - Function to update the visibility state of the messages modal.
 * @param {string} options.chatSetting - The chat setting for the event, which can be "allow" or other values.
 * @param {string} options.islevel - The participant's level, where "2" indicates a level that allows chat.
 * @param {Function} [options.showAlert] - Optional function to show an alert message.
 *
 * @returns {Promise<void>} A promise that resolves when the operation is complete.
 *
 * @remarks
 * This function checks the current visibility state of the messages modal. If it is already visible, it will hide the modal.
 * If it is not visible, it checks the chat settings and the participant's level to determine whether to show an alert
 * indicating that chat is disabled or to display the chat modal.
 *
 * @example
 * ```typescript
 * const options: ClickChatOptions = {
 *   isMessagesModalVisible: false,
 *   updateIsMessagesModalVisible: (visible) => console.log(`Modal is now ${visible ? 'visible' : 'hidden'}`),
 *   chatSetting: 'allow',
 *   islevel: '1',
 *   showAlert: (alert) => console.log(`Alert: ${alert.message}`),
 * };
 *
 * const clickChatService = new ClickChat();
 * await clickChatService.clickChat(options);
 * ```
 */
class ClickChat {
    /**
     * Toggles the visibility of the chat modal based on the current state and event settings.
     *
     * @param {Object} options - The options for the clickChat function.
     * @param {boolean} options.isMessagesModalVisible - Indicates if the messages modal is currently visible.
     * @param {Function} options.updateIsMessagesModalVisible - Function to update the visibility state of the messages modal.
     * @param {string} options.chatSetting - The chat setting for the event, which can be "allow" or other values.
     * @param {string} options.islevel - The participant's level, where "2" indicates a level that allows chat.
     * @param {Function} [options.showAlert] - Optional function to show an alert message.
     *
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     */
    async clickChat({ isMessagesModalVisible, updateIsMessagesModalVisible, chatSetting, islevel, showAlert, }) {
        if (isMessagesModalVisible) {
            updateIsMessagesModalVisible(false);
        }
        else {
            // Check if chat is allowed based on event settings and participant level
            if (chatSetting !== 'allow' && islevel !== '2') {
                updateIsMessagesModalVisible(false);
                showAlert?.({
                    message: 'Chat is disabled for this event.',
                    type: 'danger',
                    duration: 3000,
                });
            }
            else {
                updateIsMessagesModalVisible(true);
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickChat, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickChat, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickChat, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// screen-share.service.ts
/**
 * Handles the action for the screen button, including starting and stopping screen sharing.
 *
 * @param {ClickScreenShareOptions} options - Options for handling the screen button action.
 * @param {Object} options.parameters - The parameters required for the screen share action.
 * @param {Function} options.parameters.showAlert - Function to show alert messages.
 * @param {string} options.parameters.roomName - The name of the room where the screen share is taking place.
 * @param {string} options.parameters.member - The member initiating the screen share.
 * @param {Socket} options.parameters.socket - The socket connection used for communication.
 * @param {string} options.parameters.islevel - The participant's level.
 * @param {boolean} options.parameters.youAreCoHost - Indicates if the user is a co-host.
 * @param {boolean} options.parameters.adminRestrictSetting - Indicates if there are restrictions set by the admin.
 * @param {string} options.parameters.audioSetting - Current audio setting.
 * @param {string} options.parameters.videoSetting - Current video setting.
 * @param {string} options.parameters.screenshareSetting - Current screen share setting.
 * @param {string} options.parameters.chatSetting - Current chat setting.
 * @param {boolean} options.parameters.screenAction - Indicates if a screen action is currently taking place.
 * @param {boolean} options.parameters.screenAlreadyOn - Indicates if screen sharing is currently active.
 * @param {string | null} options.parameters.screenRequestState - State of the screen share request.
 * @param {number} options.parameters.screenRequestTime - Timestamp of when the screen share request was made.
 * @param {boolean} options.parameters.audioOnlyRoom - Indicates if the room is audio-only.
 * @param {number} options.parameters.updateRequestIntervalSeconds - Interval time for updating request state.
 * @param {Function} options.parameters.updateScreenRequestState - Function to update the screen request state.
 * @param {Function} options.parameters.updateScreenAlreadyOn - Function to update the screen sharing status.
 * @param {Function} options.parameters.checkPermission - Function to check permissions for screen sharing.
 * @param {Function} options.parameters.checkScreenShare - Function to check and initiate screen sharing.
 * @param {Function} options.parameters.stopShareScreen - Function to stop screen sharing.
 *
 * @returns {Promise<void>} A promise that resolves when the screen share action has been handled.
 *
 * @remarks
 * This function checks the current status of screen sharing and handles the logic for starting or stopping screen sharing.
 * It validates permissions and room settings before allowing screen sharing to be activated or deactivated.
 *
 * @example
 * ```typescript
 * const options: ClickScreenShareOptions = {
 *   parameters: {
 *     showAlert: (alert) => console.log(alert.message),
 *     roomName: 'myRoom',
 *     member: 'John Doe',
 *     socket: socketInstance,
 *     islevel: '1',
 *     youAreCoHost: false,
 *     adminRestrictSetting: false,
 *     audioSetting: 'on',
 *     videoSetting: 'on',
 *     screenshareSetting: 'off',
 *     chatSetting: 'allow',
 *     screenAction: false,
 *     screenAlreadyOn: false,
 *     screenRequestState: null,
 *     screenRequestTime: 0,
 *     audioOnlyRoom: false,
 *     updateRequestIntervalSeconds: 30,
 *     updateScreenRequestState: (state) => console.log(`Screen request state: ${state}`),
 *     updateScreenAlreadyOn: (status) => console.log(`Screen already on: ${status}`),
 *     checkPermission: checkPermissionFunction,
 *     checkScreenShare: checkScreenShareFunction,
 *     stopShareScreen: stopShareScreenFunction,
 *     getUpdatedAllParams: () => parameters,
 *   },
 * };
 *
 * const clickScreenShareService = new ClickScreenShare();
 * await clickScreenShareService.clickScreenShare(options);
 * ```
 */
class ClickScreenShare {
    /**
     * Handles the action for the screen button, including starting and stopping screen sharing.
     *
     * @param {ClickScreenShareParams} options - Options for handling the screen button action.
     * @returns {Promise<void>}
     */
    clickScreenShare = async ({ parameters }) => {
        parameters = { ...parameters, ...parameters.getUpdatedAllParams() };
        let { showAlert, roomName, member, socket, islevel, youAreCoHost, adminRestrictSetting, audioSetting, videoSetting, screenshareSetting, chatSetting, screenAction, screenAlreadyOn, screenRequestState, screenRequestTime, audioOnlyRoom, updateRequestIntervalSeconds, updateScreenRequestState, updateScreenAlreadyOn, checkPermission, checkScreenShare, stopShareScreen, } = parameters;
        if (audioOnlyRoom) {
            showAlert?.({
                message: 'You cannot turn on your camera in an audio-only event.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (roomName.startsWith('d')) {
            showAlert?.({
                message: 'You cannot start screen share in a demo room.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (screenAlreadyOn) {
            screenAlreadyOn = false;
            updateScreenAlreadyOn(screenAlreadyOn);
            await stopShareScreen({ parameters });
        }
        else {
            if (adminRestrictSetting) {
                showAlert?.({
                    message: 'You cannot start screen share. Access denied by host.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            let response = 2;
            if (!screenAction && islevel != '2' && !youAreCoHost) {
                response = await checkPermission({
                    permissionType: 'screenshareSetting',
                    audioSetting,
                    videoSetting,
                    screenshareSetting,
                    chatSetting,
                });
            }
            else {
                response = 0;
            }
            switch (response) {
                case 0:
                    checkScreenShare({ parameters });
                    break;
                case 1: {
                    if (screenRequestState === 'pending') {
                        showAlert?.({
                            message: 'A request is already pending. Please wait for the host to respond.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                    if (screenRequestState === 'rejected' &&
                        Date.now() - screenRequestTime < updateRequestIntervalSeconds) {
                        showAlert?.({
                            message: 'You cannot send another request at this time.',
                            type: 'danger',
                            duration: 3000,
                        });
                        return;
                    }
                    showAlert?.({
                        message: 'Your request has been sent to the host.',
                        type: 'success',
                        duration: 3000,
                    });
                    screenRequestState = 'pending';
                    updateScreenRequestState(screenRequestState);
                    let userRequest = { id: socket.id, name: member, icon: 'fa-desktop' };
                    socket.emit('participantRequest', { userRequest, roomName });
                    break;
                }
                case 2:
                    showAlert?.({
                        message: 'You are not allowed to start screen share.',
                        type: 'danger',
                        duration: 3000,
                    });
                    break;
                default:
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickScreenShare, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickScreenShare, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ClickScreenShare, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Switches the audio input device based on user preference.
 *
 * @param {SwitchAudioOptions} options - The options for switching the audio input.
 * @param {string} options.audioPreference - The ID of the preferred audio input device.
 * @param {SwitchAudioParameters} options.parameters - The parameters required for switching the audio.
 * @param {string} options.parameters.defAudioID - The default audio input device ID.
 * @param {string} options.parameters.userDefaultAudioInputDevice - The current default audio input device ID.
 * @param {string} options.parameters.prevAudioInputDevice - The previously used audio input device ID.
 * @param {Function} options.parameters.updateUserDefaultAudioInputDevice - Function to update the user's default audio input device.
 * @param {Function} options.parameters.updatePrevAudioInputDevice - Function to update the previous audio input device.
 * @param {Function} options.parameters.switchUserAudio - Function to switch the user's audio.
 *
 * @returns {Promise<void>} A promise that resolves when the audio input has been switched.
 *
 * @remarks
 * This function checks if the user's preferred audio device differs from the current default.
 * If so, it updates the previous audio device and the current default audio device.
 * It then calls the function to switch the user's audio.
 *
 * @example
 * ```typescript
 * const options: SwitchAudioOptions = {
 *   audioPreference: 'newAudioDeviceID',
 *   parameters: {
 *     defAudioID: 'defaultAudioDeviceID',
 *     userDefaultAudioInputDevice: 'currentAudioDeviceID',
 *     prevAudioInputDevice: '',
 *     updateUserDefaultAudioInputDevice: (deviceId) => console.log(`Updated to: ${deviceId}`),
 *     updatePrevAudioInputDevice: (deviceId) => console.log(`Previous device was: ${deviceId}`),
 *     switchUserAudio: async ({ audioPreference, parameters }) => {
 *       console.log(`Switching audio to: ${audioPreference}`);
 *     },
 *     getUpdatedAllParams: () => {
 *       return {
 *         defAudioID: 'defaultAudioDeviceID',
 *         userDefaultAudioInputDevice: 'currentAudioDeviceID',
 *         prevAudioInputDevice: '',
 *       };
 *     },
 *   },
 * };
 *
 * const switchAudioService = new SwitchAudio();
 * await switchAudioService.switchAudio(options);
 * ```
 */
class SwitchAudio {
    /**
     * Switches the audio input device based on user preference.
     *
     * @param {SwitchAudioParams} options - The function parameters.
     * @returns {Promise<void>}
     */
    async switchAudio({ audioPreference, parameters }) {
        let { defAudioID, userDefaultAudioInputDevice, prevAudioInputDevice, updateUserDefaultAudioInputDevice, updatePrevAudioInputDevice, 
        //mediasfu functions
        switchUserAudio, } = parameters;
        if (audioPreference !== defAudioID) {
            prevAudioInputDevice = userDefaultAudioInputDevice;
            updatePrevAudioInputDevice(prevAudioInputDevice);
            userDefaultAudioInputDevice = audioPreference;
            updateUserDefaultAudioInputDevice(userDefaultAudioInputDevice);
            if (defAudioID) {
                await switchUserAudio({ audioPreference, parameters });
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchAudio, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchAudio, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchAudio, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Switches the user's video device based on the provided video preference.
 *
 * @param {SwitchVideoOptions} options - The options for switching the video input.
 * @param {string} options.videoPreference - The preferred video device to switch to.
 * @param {SwitchVideoParameters} options.parameters - The parameters required for switching the video input.
 * @param {boolean} options.parameters.recordStarted - Indicates if recording has started.
 * @param {boolean} options.parameters.recordResumed - Indicates if recording has resumed.
 * @param {boolean} options.parameters.recordStopped - Indicates if recording has stopped.
 * @param {boolean} options.parameters.recordPaused - Indicates if recording is paused.
 * @param {string} options.parameters.recordingMediaOptions - The current media options (e.g., "video").
 * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is currently on.
 * @param {string} options.parameters.userDefaultVideoInputDevice - The default video input device for the user.
 * @param {string} options.parameters.defVideoID - The default video ID for the input device.
 * @param {boolean} options.parameters.allowed - Indicates if the user is allowed to switch video.
 * @param {Function} options.parameters.updateDefVideoID - Function to update the default video ID.
 * @param {Function} options.parameters.updatePrevVideoInputDevice - Function to update the previous video input device.
 * @param {Function} options.parameters.updateUserDefaultVideoInputDevice - Function to update the user’s default video input device.
 * @param {Function} options.parameters.updateIsMediaSettingsModalVisible - Function to update the visibility of the media settings modal.
 * @param {Function} [options.parameters.showAlert] - Optional function to show alert messages.
 * @param {Function} options.parameters.switchUserVideo - Function to switch the user's video input.
 *
 * @returns {Promise<void>} A promise that resolves when the video input has been switched.
 *
 * @remarks
 * This function checks if the user is allowed to switch the video input based on the current state,
 * and it shows alerts if there are any issues. If the video is already on, it cannot be switched until
 * it is turned off, and vice versa. The default video input device is updated if necessary.
 *
 * @example
 * ```typescript
 * const options: SwitchVideoOptions = {
 *   videoPreference: 'newDeviceId',
 *   parameters: {
 *     recordStarted: false,
 *     recordResumed: false,
 *     recordStopped: false,
 *     recordPaused: false,
 *     recordingMediaOptions: 'video',
 *     videoAlreadyOn: true,
 *     userDefaultVideoInputDevice: 'currentDeviceId',
 *     defVideoID: 'defaultDeviceId',
 *     allowed: true,
 *     updateDefVideoID: (deviceId) => console.log(`Default video ID updated to: ${deviceId}`),
 *     updatePrevVideoInputDevice: (deviceId) => console.log(`Previous video input device updated to: ${deviceId}`),
 *     updateUserDefaultVideoInputDevice: (deviceId) => console.log(`User default video input device updated to: ${deviceId}`),
 *     updateIsMediaSettingsModalVisible: (isVisible) => console.log(`Media settings modal is now ${isVisible ? 'visible' : 'hidden'}`),
 *     switchUserVideo: async ({ videoPreference }) => console.log(`Switched video to: ${videoPreference}`),
 *     getUpdatedAllParams: () => ({ }),
 *   },
 * };
 *
 * const switchVideoService = new SwitchVideo();
 * await switchVideoService.switchVideo(options);
 * ```
 */
class SwitchVideo {
    /**
     * Switches the user's video device based on the provided video preference.
     *
     * @param {SwitchVideoParams} options - The function parameters.
     */
    async switchVideo({ videoPreference, parameters }) {
        let { recordStarted, recordResumed, recordStopped, recordPaused, recordingMediaOptions, videoAlreadyOn, userDefaultVideoInputDevice, defVideoID, allowed, updateDefVideoID, updatePrevVideoInputDevice, updateUserDefaultVideoInputDevice, updateIsMediaSettingsModalVisible, 
        //mediasfu functions
        showAlert, switchUserVideo, } = parameters;
        // Check if recording is in progress and whether the selected video device is the default one
        let checkoff = false;
        if ((recordStarted || recordResumed) && !recordStopped && !recordPaused) {
            if (recordingMediaOptions === 'video') {
                checkoff = true;
            }
        }
        // Check camera access permission
        if (!allowed) {
            showAlert?.({
                message: 'Allow access to your camera by starting it for the first time.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        // Check video state and display appropriate alert messages
        if (checkoff) {
            if (videoAlreadyOn) {
                showAlert?.({
                    message: 'Please turn off your video before switching.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        else {
            if (!videoAlreadyOn) {
                showAlert?.({
                    message: 'Please turn on your video before switching.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        // Set default video ID if not already set
        if (!defVideoID) {
            defVideoID = userDefaultVideoInputDevice ?? 'default';
            updateDefVideoID(defVideoID);
        }
        // Switch video only if the selected video device is different from the default
        if (videoPreference !== defVideoID) {
            const prevVideoInputDevice = userDefaultVideoInputDevice;
            updatePrevVideoInputDevice(prevVideoInputDevice);
            userDefaultVideoInputDevice = videoPreference;
            updateUserDefaultVideoInputDevice(userDefaultVideoInputDevice);
            if (defVideoID) {
                updateIsMediaSettingsModalVisible(false);
                await switchUserVideo({ videoPreference, checkoff, parameters });
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchVideo, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchVideo, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchVideo, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Switches the video input based on user preference and current state.
 *
 * @param {SwitchVideoAltOptions} options - The options for switching the video input.
 * @param {SwitchVideoAltParameters} options.parameters - The parameters required for switching the video input.
 * @param {boolean} options.parameters.recordStarted - Indicates if recording has started.
 * @param {boolean} options.parameters.recordResumed - Indicates if recording has resumed.
 * @param {boolean} options.parameters.recordStopped - Indicates if recording has stopped.
 * @param {boolean} options.parameters.recordPaused - Indicates if recording is paused.
 * @param {string} options.parameters.recordingMediaOptions - The current media options (e.g., "video").
 * @param {boolean} options.parameters.videoAlreadyOn - Indicates if the video is currently on.
 * @param {string} options.parameters.currentFacingMode - The current facing mode of the camera (e.g., "environment").
 * @param {boolean} options.parameters.allowed - Indicates if the user is allowed to switch video.
 * @param {boolean} options.parameters.audioOnlyRoom - Indicates if the current room is audio-only.
 * @param {Function} options.parameters.updateCurrentFacingMode - Function to update the current facing mode.
 * @param {Function} options.parameters.updateIsMediaSettingsModalVisible - Function to update the visibility of the media settings modal.
 * @param {Function} [options.parameters.showAlert] - Optional function to show alert messages.
 * @param {Function} options.parameters.switchUserVideoAlt - Function to switch the user's video input.
 *
 * @returns {Promise<void>} A promise that resolves when the video input has been switched.
 *
 * @remarks
 * This function checks if the user is allowed to switch the video input based on the current state,
 * and it shows alerts if there are any issues. If the video is already on, it cannot be switched until
 * it is turned off, and vice versa. The facing mode of the camera is toggled between "user" and "environment".
 *
 * @example
 * ```typescript
 * const options: SwitchVideoAltOptions = {
 *   parameters: {
 *     recordStarted: false,
 *     recordResumed: false,
 *     recordStopped: false,
 *     recordPaused: false,
 *     recordingMediaOptions: 'video',
 *     videoAlreadyOn: true,
 *     currentFacingMode: 'user',
 *     allowed: true,
 *     audioOnlyRoom: false,
 *     updateCurrentFacingMode: (mode) => console.log(`Facing mode updated to: ${mode}`),
 *     updateIsMediaSettingsModalVisible: (isVisible) => console.log(`Media settings modal is now ${isVisible ? 'visible' : 'hidden'}`),
 *     switchUserVideoAlt: async ({ videoPreference }) => console.log(`Switched video to: ${videoPreference}`),
 *     getUpdatedAllParams: () => ({ }),
 *   },
 * };
 *
 * const switchVideoService = new SwitchVideoAlt();
 * await switchVideoService.switchVideoAlt(options);
 * ```
 */
class SwitchVideoAlt {
    async switchVideoAlt({ parameters }) {
        let { recordStarted, recordResumed, recordStopped, recordPaused, recordingMediaOptions, videoAlreadyOn, currentFacingMode, allowed, audioOnlyRoom, updateCurrentFacingMode, updateIsMediaSettingsModalVisible, showAlert, 
        //media functions
        switchUserVideoAlt, } = parameters;
        if (audioOnlyRoom) {
            showAlert?.({
                message: 'You cannot turn on your camera in an audio-only event.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        let checkoff = false;
        if ((recordStarted || recordResumed) &&
            !recordStopped &&
            !recordPaused &&
            recordingMediaOptions === 'video') {
            checkoff = true;
        }
        if (!allowed) {
            showAlert?.({
                message: 'Allow access to your camera by starting it for the first time.',
                type: 'danger',
                duration: 3000,
            });
            return;
        }
        if (checkoff) {
            if (videoAlreadyOn) {
                showAlert?.({
                    message: 'Please turn off your video before switching.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        else {
            if (!videoAlreadyOn) {
                showAlert?.({
                    message: 'Please turn on your video before switching.',
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
        }
        // Camera switching logic here
        let newFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
        updateCurrentFacingMode(newFacingMode);
        updateIsMediaSettingsModalVisible(false);
        await switchUserVideoAlt({ videoPreference: newFacingMode, checkoff, parameters });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchVideoAlt, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchVideoAlt, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SwitchVideoAlt, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Asynchronously joins a room on MediaSFU.
 *
 * This method sends a POST request to the MediaSFU API to join an existing room.
 * It validates the provided credentials and dynamically constructs the API endpoint,
 * including support for the Community Edition via a custom `localLink`.
 *
 * @param {object} options - Configuration options for joining the room.
 * @param {JoinMediaSFURoomOptions | CreateMediaSFURoomOptions} options.payload -
 *   The payload containing the room details and action (`join` or `create`).
 * @param {string} options.apiUserName - The API username, used for authentication.
 * @param {string} options.apiKey - The API key, used for authentication.
 * @param {string} [options.localLink=""] -
 *   The local link for Community Edition users. If provided, it overrides the default API URL.
 *
 * @returns {Promise<{
*   data: CreateJoinRoomResponse | CreateJoinRoomError | null;
*   success: boolean;
* }>} A promise resolving to an object containing the API response:
* - `data`: The response object, either `CreateJoinRoomResponse` or `CreateJoinRoomError`.
* - `success`: Boolean indicating whether the operation was successful.
*
* @throws {Error} Throws an error if the request fails or if the provided credentials are invalid.
*
* @example
* const response = await joinRoomOnMediaSFU.joinRoomOnMediaSFU({
*   payload: {
*     action: 'join',
*     meetingID: '123456',
*     userName: 'user123',
*   },
*   apiUserName: 'yourAPIUSERNAME',
*   apiKey: 'yourAPIKEY',
*   localLink: 'http://localhost:3000', // Optional for Community Edition
* });
*
* if (response.success) {
*   console.log('Joined room successfully:', response.data);
* } else {
*   console.error('Failed to join room:', response.data?.error);
* }
*/
class JoinRoomOnMediaSFU {
    constructor() { }
    /**
   * Asynchronously joins a room on MediaSFU.
   *
   * This method sends a POST request to the MediaSFU API to join an existing room.
   * It validates the provided credentials and dynamically constructs the API endpoint,
   * including support for the Community Edition via a custom `localLink`.
   *
   * @param {object} options - Configuration options for joining the room.
   * @param {JoinMediaSFURoomOptions | CreateMediaSFURoomOptions} options.payload -
   *   The payload containing the room details and action (`join` or `create`).
   * @param {string} options.apiUserName - The API username, used for authentication.
   * @param {string} options.apiKey - The API key, used for authentication.
   * @param {string} [options.localLink=""] -
   *   The local link for Community Edition users. If provided, it overrides the default API URL.
   *
   * @returns {Promise<{
   *   data: CreateJoinRoomResponse | CreateJoinRoomError | null;
    *   success: boolean;
    * }>} A promise resolving to an object containing the API response:
    * - `data`: The response object, either `CreateJoinRoomResponse` or `CreateJoinRoomError`.
    * - `success`: Boolean indicating whether the operation was successful.
    *
    * @throws {Error} Throws an error if the request fails or if the provided credentials are invalid.
    *
    * @example
    * const response = await joinRoomOnMediaSFU.joinRoomOnMediaSFU({
    *   payload: {
    *     action: 'join',
    *     meetingID: '123456',
    *     userName: 'user123',
    *   },
    *   apiUserName: 'yourAPIUSERNAME',
    *   apiKey: 'yourAPIKEY',
    *   localLink: 'http://localhost:3000', // Optional for Community Edition
    * });
    *
    * if (response.success) {
    *   console.log('Joined room successfully:', response.data);
    * } else {
    *   console.error('Failed to join room:', response.data?.error);
    * }
    */
    async joinRoomOnMediaSFU({ payload, apiUserName, apiKey, localLink, }) {
        try {
            if (!apiUserName ||
                !apiKey ||
                apiUserName === 'yourAPIUSERNAME' ||
                apiKey === 'yourAPIKEY' ||
                apiKey.length !== 64 ||
                apiUserName.length < 6) {
                return { data: { error: 'Invalid credentials' }, success: false };
            }
            let API_URL = 'https://mediasfu.com/v1/rooms/';
            if (localLink && localLink.trim() !== '' && !localLink.includes('mediasfu.com')) {
                localLink = localLink.replace(/\/$/, '');
                API_URL = localLink + '/joinRoom';
            }
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${apiUserName}:${apiKey}`,
                },
                body: JSON.stringify(payload),
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP error! Status: ${response.status}, Message: ${errorText}`);
            }
            const data = await response.json();
            return { data, success: true };
        }
        catch (error) {
            const errorMessage = error.reason ? error.reason : 'unknown error';
            return {
                data: { error: `Unable to join room, ${errorMessage}` },
                success: false,
            };
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinRoomOnMediaSFU, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinRoomOnMediaSFU, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinRoomOnMediaSFU, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

// start-meeting-progress-timer.service.ts
/**
 * Starts a timer to track the progress of a meeting.
 *
 * @param {StartMeetingProgressTimerOptions} options - The options for starting the meeting progress timer.
 * @param {number} options.startTime - The custom start time for the meeting progress timer in seconds since epoch.
 * @param {StartMeetingProgressTimerParameters} options.parameters - The parameters required for updating the meeting progress.
 * @param {Function} options.parameters.updateMeetingProgressTime - Function to update the formatted meeting progress time.
 * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
 *
 * @returns {void}
 *
 * @remarks
 * This function calculates the elapsed time since the meeting started and updates the meeting progress every second.
 * The timer will stop if the validated flag is set to false or if the room name is not valid.
 *
 * The time is formatted in HH:MM:SS format, and the update function is called with the formatted time.
 *
 * @example
 * ```typescript
 * const options: StartMeetingProgressTimerOptions = {
 *   startTime: Math.floor(Date.now() / 1000), // Current time in seconds
 *   parameters: {
 *     updateMeetingProgressTime: (formattedTime) => console.log(`Meeting Progress: ${formattedTime}`),
 *     validated: true,
 *     roomName: 'Room123',
 *     getUpdatedAllParams: () => ({
 *       validated: true,
 *       roomName: 'Room123',
 *       updateMeetingProgressTime: options.parameters.updateMeetingProgressTime,
 *     }),
 *   },
 * };
 *
 * const timerService = new StartMeetingProgressTimer();
 * timerService.startMeetingProgressTimer(options);
 * ```
 */
class StartMeetingProgressTimer {
    timeProgress;
    /**
     * Starts a timer to track the progress of a meeting.
     *
     * @param {Object} options - The options for starting the meeting progress timer.
     * @param {number} options.startTime - The custom start time for the meeting progress timer.
     * @param {Object} options.parameters - The parameters required for updating the meeting progress.
     * @param {Function} options.parameters.updateMeetingProgressTime - Function to update the meeting progress time.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     *
     * @returns {void}
     */
    startMeetingProgressTimer = ({ startTime, parameters, }) => {
        let { updateMeetingProgressTime, getUpdatedAllParams } = parameters;
        const calculateElapsedTime = (startTime) => {
            const currentTime = Math.floor(new Date().getTime() / 1000);
            return currentTime - startTime;
        };
        const padNumber = (number) => {
            return number.toString().padStart(2, '0');
        };
        const formatTime = (time) => {
            const hours = Math.floor(time / 3600);
            const minutes = Math.floor((time % 3600) / 60);
            const seconds = (time % 60).toFixed(0).padStart(2, '0');
            return `${padNumber(hours)}:${padNumber(minutes)}:${padNumber(Number(seconds))}`;
        };
        let elapsedTime = calculateElapsedTime(startTime);
        this.timeProgress = setInterval(async () => {
            elapsedTime++;
            const formattedTime = formatTime(elapsedTime);
            updateMeetingProgressTime(formattedTime);
            parameters = getUpdatedAllParams();
            if (!parameters.validated || !parameters.roomName) {
                clearInterval(this.timeProgress);
                this.timeProgress = null;
            }
        }, 1000);
    };
    stopMeetingProgressTimer = () => {
        if (this.timeProgress) {
            clearInterval(this.timeProgress);
            this.timeProgress = null;
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartMeetingProgressTimer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartMeetingProgressTimer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartMeetingProgressTimer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * The `FormatNumber` service provides functionality to format numeric values
 * into a more readable string representation, appending appropriate suffixes
 * like K (thousands), M (millions), and B (billions).
 *
 * @service
 * @example
 * ```typescript
 * import { FormatNumber } from 'mediasfu-angular';
 *
 * constructor(private formatNumber: FormatNumber) {}
 *
 * async displayFormattedNumber() {
 *   const formatted = await this.formatNumber.formatNumber({ number: 1500 });
 *   console.log(formatted); // Outputs: "1.5K"
 * }
 * ```
 *
 * @remarks
 * This service can be useful for displaying large numbers in a more compact form
 * in user interfaces, especially in dashboards or reports where space is limited.
 *
 * @property {FormatNumberOptions} options - Options containing the number to format.
 *
 * @returns {FormatNumber} The FormatNumber service for formatting numeric values.
 */
class FormatNumber {
    async formatNumber({ number }) {
        if (number) {
            if (number < 1e3) {
                return number.toString();
            }
            else if (number < 1e6) {
                return (number / 1e3).toFixed(1) + 'K';
            }
            else if (number < 1e9) {
                return (number / 1e6).toFixed(1) + 'M';
            }
            else if (number < 1e12) {
                return (number / 1e9).toFixed(1) + 'B';
            }
        }
        // Return undefined for falsy input values
        return undefined;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: FormatNumber, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: FormatNumber, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: FormatNumber, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * GenerateRandomMessages - Service to generate random chat messages from participants.
 *
 * This service generates random direct and group messages based on participants and a given host setup,
 * with options to tailor messages for chat broadcast.
 *
 * @class
 * @name GenerateRandomMessages
 * @example
 * ```typescript
 * const generateRandomMessagesService = new GenerateRandomMessages();
 * const messages = generateRandomMessagesService.generateRandomMessages({
 *   participants: [
 *     { name: 'Alice' },
 *     { name: 'Bob' },
 *     { name: 'Charlie' }
 *   ],
 *   member: 'Alice',
 *   coHost: 'Bob',
 *   host: 'Charlie',
 *   forChatBroadcast: true
 * });
 * console.log(messages);
 * ```
 *
 * @param {Object} options - Options for generating random messages.
 * @param {Participant[]} options.participants - List of participants for message generation.
 * @param {string} options.member - The primary member in the chat.
 * @param {string} [options.coHost] - Optional co-host participant.
 * @param {string} options.host - The chat host.
 * @param {boolean} [options.forChatBroadcast=false] - Flag to indicate if messages are for chat broadcast.
 * @returns {Message[]} Array of randomly generated messages with direct and group messaging.
 */
class GenerateRandomMessages {
    /**
     * Generates random messages for a given set of participants.
     *
     * @param {Object} options - The options for generating random messages.
     * @param {Array} options.participants - The list of participants.
     * @param {string} options.member - The member who is part of the chat.
     * @param {string} [options.coHost=""] - The co-host of the chat.
     * @param {string} options.host - The host of the chat.
     * @param {boolean} [options.forChatBroadcast=false] - Flag to indicate if the messages are for chat broadcast.
     * @returns {Message[]} An array of generated messages.
     */
    generateRandomMessages({ participants, member, coHost = '', host, forChatBroadcast = false, }) {
        const messages = [];
        // Function to get a random participant other than the sender
        const getRandomReceiver = (sender) => {
            const potentialReceivers = participants.filter((participant) => participant.name !== sender);
            const randomReceiver = potentialReceivers[Math.floor(Math.random() * potentialReceivers.length)];
            return randomReceiver.name || '';
        };
        // Force add messages for specific participants
        let refNames = [];
        if (forChatBroadcast) {
            refNames = [member, host];
        }
        else {
            if (coHost) {
                refNames = [
                    member,
                    coHost,
                    host,
                    ...participants
                        .map((participant) => participant.name)
                        .filter((name) => name !== undefined),
                ];
            }
            else {
                refNames = [
                    member,
                    host,
                    ...participants
                        .map((participant) => participant.name)
                        .filter((name) => name !== undefined),
                ];
            }
        }
        // Return unique names for the refNames
        refNames = [...new Set(refNames)];
        // Generate messages
        let timeIncrement = 0;
        refNames.forEach((sender) => {
            // Send direct messages
            const directMessage = {
                sender: sender,
                receivers: [getRandomReceiver(sender)],
                message: `Direct message from ${sender}`,
                timestamp: new Date(Date.now() + timeIncrement).toLocaleTimeString(),
                group: false,
            };
            messages.push(directMessage);
            // Send group messages
            const groupMessage = {
                sender: sender,
                receivers: participants
                    .map((participant) => participant.name)
                    .filter((name) => name !== undefined),
                message: `Group message from ${sender}`,
                timestamp: new Date(Date.now() + timeIncrement).toLocaleTimeString(),
                group: true,
            };
            messages.push(groupMessage);
            timeIncrement += 15000; // Increment time by 15 seconds for each message
        });
        return messages;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomMessages, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomMessages, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomMessages, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * GenerateRandomParticipants - Service to generate a list of random participants.
 *
 * This service creates a list of participants based on a set of specified options, with customization for chat broadcasts
 * and designation of specific roles like member, co-host, and host.
 *
 * @class
 * @name GenerateRandomParticipants
 * @example
 * ```typescript
 * const generateRandomParticipantsService = new GenerateRandomParticipants();
 * const participants = generateRandomParticipantsService.generateRandomParticipants({
 *   member: 'Alice',
 *   coHost: 'Bob',
 *   host: 'Charlie',
 *   forChatBroadcast: true
 * });
 * console.log(participants);
 * ```
 *
 * @param {Object} options - Options for generating participants.
 * @param {string} options.member - Primary member to include in the participants list.
 * @param {string} [options.coHost] - Optional co-host in the participants list.
 * @param {string} options.host - Host to include in the participants list.
 * @param {boolean} [options.forChatBroadcast=false] - Indicates if participants are for a chat broadcast.
 * @returns {Participant[]} Array of generated participants with randomized levels, muted states, and identifiers.
 */
class GenerateRandomParticipants {
    /**
     * Generates a list of random participants with specified options.
     *
     * @param {Object} options - The options for generating participants.
     * @param {string} options.member - The member to include in the participants list.
     * @param {string} [options.coHost=""] - The co-host to include in the participants list.
     * @param {string} options.host - The host to include in the participants list.
     * @param {boolean} [options.forChatBroadcast=false] - Whether the participants are for a chat broadcast.
     * @returns {Participant[]} An array of generated participants.
     */
    generateRandomParticipants({ member, coHost = '', host, forChatBroadcast = false, }) {
        const participants = [];
        let names = [
            'Alice',
            'Bob',
            'Charlie',
            'David',
            'Eve',
            'Frank',
            'Grace',
            'Hank',
            'Ivy',
            'Jack',
            'Kate',
            'Liam',
            'Mia',
            'Nina',
            'Olivia',
            'Pete',
            'Quinn',
            'Rachel',
            'Steve',
            'Tina',
            'Ursula',
            'Vince',
            'Wendy',
            'Xander',
            'Yvonne',
            'Zack',
        ];
        // Limit names to 2 for chat broadcast
        if (forChatBroadcast) {
            names.splice(2);
        }
        // Place member, coHost, and host at the beginning if not already included
        if (!names.includes(member)) {
            names.unshift(member);
        }
        if (!names.includes(coHost) && !forChatBroadcast) {
            names.unshift(coHost);
        }
        if (!names.includes(host)) {
            names.unshift(host);
        }
        // Limit names to 2 for chat broadcast
        if (forChatBroadcast) {
            names.splice(2);
        }
        // Remove names of length 1 or less
        names = names.filter((name) => name.length > 1);
        // Shuffle the names array to ensure unique names for each participant
        const shuffledNames = [...names];
        for (let i = shuffledNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledNames[i], shuffledNames[j]] = [shuffledNames[j], shuffledNames[i]];
        }
        let hasLevel2Participant = false;
        // Generate participant objects
        for (let i = 0; i < shuffledNames.length; i++) {
            const randomName = shuffledNames[i];
            const randomLevel = hasLevel2Participant ? '1' : randomName == host ? '2' : '1'; // Set islevel to '2' only once
            const randomMuted = forChatBroadcast ? true : Math.random() < 0.5; // Set muted to false for chat broadcast
            if (randomLevel === '2') {
                hasLevel2Participant = true;
            }
            participants.push({
                name: randomName,
                islevel: randomLevel,
                muted: randomMuted,
                id: i.toString(),
                audioID: `audio-${i}`,
                videoID: `video-${i}`,
            });
        }
        return participants;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomParticipants, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomParticipants, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomParticipants, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
   * Generates an array of random poll objects with varying types and options.
   *
   * Each poll includes a question, a type (e.g., "trueFalse", "yesNo", or "custom"), and multiple choice options.
   * Poll types determine the options generated:
   * - `"trueFalse"` polls have "True" and "False" options.
   * - `"yesNo"` polls have "Yes" and "No" options.
   * - `"custom"` polls generate 2–6 custom options labeled as "Option 1", "Option 2", etc.
   *
   * @param {GenerateRandomPollsOptions} options - An object containing the number of polls to generate.
   * @param {number} options.numberOfPolls - The number of random polls to generate.
   * @returns {Poll[]} An array of generated polls with unique IDs and randomly selected types and options.
   *
   * @example
   * const pollService = new GenerateRandomPolls();
   * const options = { numberOfPolls: 3 };
   * const randomPolls = pollService.generateRandomPolls(options);
   *
   * console.log(randomPolls);
   * // Output:
   * // [
   * //   { id: '1', question: 'Random Question 1', type: 'yesNo', options: ['Yes', 'No'], votes: [0, 0], status: 'inactive', voters: {} },
   * //   { id: '2', question: 'Random Question 2', type: 'trueFalse', options: ['True', 'False'], votes: [0, 0], status: 'inactive', voters: {} },
   * //   { id: '3', question: 'Random Question 3', type: 'custom', options: ['Option 1', 'Option 2', 'Option 3'], votes: [0, 0, 0], status: 'inactive', voters: {} }
   * // ]
   */
class GenerateRandomPolls {
    /**
     * Generates an array of random poll objects.
     *
     * @param {GenerateRandomPollsOptions} options - An object containing the number of polls to generate.
     * @param {number} options.numberOfPolls - The number of random polls to generate.
     * @returns {Poll[]} An array of random poll objects.
     */
    generateRandomPolls({ numberOfPolls }) {
        const pollTypes = ['trueFalse', 'yesNo', 'custom'];
        const polls = [];
        for (let i = 0; i < numberOfPolls; i++) {
            const type = pollTypes[Math.floor(Math.random() * pollTypes.length)];
            let options;
            switch (type) {
                case 'trueFalse':
                    options = ['True', 'False'];
                    break;
                case 'yesNo':
                    options = ['Yes', 'No'];
                    break;
                case 'custom':
                    options = Array.from({ length: Math.floor(Math.random() * 5) + 2 }, (_, idx) => `Option ${idx + 1}`);
                    break;
                default:
                    options = [];
            }
            const poll = {
                id: `${i + 1}`,
                question: `Random Question ${i + 1}`,
                type,
                options,
                votes: Array(options.length).fill(0),
                status: 'inactive', // or 'active'
                voters: {},
            };
            polls.push(poll);
        }
        return polls;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomPolls, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomPolls, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomPolls, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
  * Generates a random list of requests for participants, ensuring unique icons per participant
  * and excluding the host and co-host from the request list.
  *
  * @param {GenerateRandomRequestListOptions} options - Configuration options for generating requests.
  * @param {Participant[]} options.participants - Array of participant objects.
  * @param {string} options.hostName - Name of the host to be excluded.
  * @param {string} [options.coHostName] - Optional name of the co-host to be excluded.
  * @param {number} options.numberOfRequests - Number of requests to generate per participant.
  * @returns {Request[]} Array of requests, each uniquely associated with a participant.
  *
  * @example
  * ```typescript
  * const requestService = new GenerateRandomRequestList();
  * const participants = [
  *   { id: '1', name: 'Alice' },
  *   { id: '2', name: 'Bob' },
  *   { id: '3', name: 'Charlie' }
  * ];
  * const options = {
  *   participants,
  *   hostName: 'Alice',
  *   coHostName: 'Bob',
  *   numberOfRequests: 2
  * };
  *
  * const requests = requestService.generateRandomRequestList(options);
  *
  * console.log(requests);
  * // Output:
  * // [
  * //   { id: '3', name: 'charlie', icon: 'fa-microphone', username: 'charlie' },
  * //   { id: '3', name: 'charlie', icon: 'fa-desktop', username: 'charlie' }
  * // ]
  * ```
  */
class GenerateRandomRequestList {
    /**
     * Generates a list of random requests for participants, excluding the host and co-host.
     *
     * @param {GenerateRandomRequestListOptions} options - The options for generating the request list.
     * @param {Participant[]} options.participants - The list of participants.
     * @param {string} options.hostName - The name of the host.
     * @param {string} options.coHostName - The name of the co-host.
     * @param {number} options.numberOfRequests - The number of requests to generate for each participant.
     * @returns {Request[]} The generated list of requests.
     */
    generateRandomRequestList({ participants, hostName, coHostName, numberOfRequests, }) {
        // Filter out the host and co-host from the participants
        const filteredParticipants = participants.filter((participant) => participant.name !== hostName && participant.name !== coHostName);
        // Create an array with three possible request icons
        const requestIcons = ['fa-video', 'fa-desktop', 'fa-microphone'];
        // Shuffle the request icons array to ensure unique icons for each participant and randomly select a minimum of 1 and a maximum of 3 icons
        for (let i = requestIcons.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [requestIcons[i], requestIcons[j]] = [requestIcons[j], requestIcons[i]];
        }
        // Generate unique requests for each participant with unique icons
        const requestList = filteredParticipants.flatMap((participant) => {
            const uniqueIcons = new Set(); // To ensure unique icons for each participant
            const requests = [];
            for (let i = 0; i < numberOfRequests; i++) {
                let randomIcon;
                do {
                    randomIcon = requestIcons[Math.floor(Math.random() * requestIcons.length)];
                } while (uniqueIcons.has(randomIcon));
                uniqueIcons.add(randomIcon);
                requests.push({
                    id: participant.id || '',
                    name: participant.name.toLowerCase().replace(/\s/g, '_'),
                    icon: randomIcon,
                    username: participant.name.toLowerCase().replace(/\s/g, '_'),
                });
            }
            return requests;
        });
        return requestList;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomRequestList, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomRequestList, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomRequestList, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
  * Generates a random list of participants for a waiting room.
  *
  * @returns {WaitingRoomParticipant[]} An array of `WaitingRoomParticipant` objects, each with a unique ID and random name.
  *
  * @example
  * ```typescript
  * const generateListService = new GenerateRandomWaitingRoomList();
  * const waitingRoomList = generateListService.generateRandomWaitingRoomList();
  *
  * console.log(waitingRoomList);
  * // Output:
  * // [
  * //   { name: 'Dimen', id: '0' },
  * //   { name: 'Nore', id: '1' },
  * //   { name: 'Ker', id: '2' },
  * //   { name: 'Lor', id: '3' },
  * //   { name: 'Mik', id: '4' }
  * // ]
  * ```
  */
class GenerateRandomWaitingRoomList {
    /**
     * Generates a random list of participants for a waiting room.
     *
     * @param options - Configuration options for generating the waiting room list.
     * @returns An array of `WaitingRoomParticipant` objects, each with a random name, mute status, and unique ID.
     *
     * @example
     * const options = {};
     * const waitingRoomList = generateRandomWaitingRoomList(options);
     * console.log(waitingRoomList);
     */
    generateRandomWaitingRoomList() {
        // Array of random names to assign to participants in the waiting room
        const names = ['Dimen', 'Nore', 'Ker', 'Lor', 'Mik'];
        // Loop through the names array and add participants to the waiting room list
        const waitingRoomList = [];
        for (let i = 0; i < names.length; i++) {
            const randomName = names[i];
            waitingRoomList.push({
                name: randomName,
                id: i.toString(),
            });
        }
        return waitingRoomList;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomWaitingRoomList, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomWaitingRoomList, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GenerateRandomWaitingRoomList, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Gets the style for positioning a modal based on the specified position.
 *
 * @param {GetModalPositionOptions} options - Object containing the desired modal position.
 * @param {string} options.position - The modal position ('center', 'topLeft', 'topRight', 'bottomLeft', 'bottomRight').
 * @returns {ModalPositionStyle} - Style object for aligning the modal according to the specified position.
 *
 * @example
 * ```typescript
 * const positionStyle = getModalPosition({ position: 'center' });
 * // Output: { justifyContent: 'center', alignItems: 'center' }
 *
 * const topLeftStyle = getModalPosition({ position: 'topLeft' });
 * // Output: { justifyContent: 'flex-start', alignItems: 'flex-start' }
 * ```
 */
function getModalPosition({ position }) {
    switch (position) {
        case 'center':
            return { justifyContent: 'center', alignItems: 'center' };
        case 'topLeft':
            return { justifyContent: 'flex-start', alignItems: 'flex-start' };
        case 'topRight':
            return { justifyContent: 'flex-start', alignItems: 'flex-end' };
        case 'bottomLeft':
            return { justifyContent: 'flex-end', alignItems: 'flex-start' };
        case 'bottomRight':
        default:
            return { justifyContent: 'flex-end', alignItems: 'flex-end' };
    }
}

/**
 * Pauses the execution for a specified number of milliseconds.
 *
 * @param {SleepOptions} options - Contains the duration to pause.
 * @param {number} options.ms - Number of milliseconds to delay.
 * @returns {Promise<void>} Resolves after the specified duration.
 *
 * @example
 * ```typescript
 * await sleep({ ms: 2000 });
 * // Pauses execution for 2 seconds
 * ```
 */
function sleep({ ms }) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Service to toggle the visibility of a waiting modal.
 *
 * @param {LaunchWaitingOptions} options - The options to control the waiting modal visibility.
 * @param {Function} options.updateIsWaitingModalVisible - Function to update the visibility of the waiting modal.
 * @param {boolean} options.isWaitingModalVisible - Current visibility state of the waiting modal.
 *
 * @example
 * ```typescript
 * const launchWaitingService = new LaunchWaiting();
 * launchWaitingService.launchWaiting({
 *   updateIsWaitingModalVisible: (isVisible) => console.log(`Modal is now ${isVisible ? 'visible' : 'hidden'}`),
 *   isWaitingModalVisible: false,
 * });
 * ```
 *
 * This example toggles the modal's visibility state, making it visible if it was hidden and vice versa.
 */
class LaunchWaiting {
    /**
     * Toggles the visibility of the waiting modal.
     *
     * @param updateIsWaitingModalVisible - Function to update the visibility state of the waiting modal.
     * @param isWaitingModalVisible - Current visibility state of the waiting modal.
     */
    launchWaiting({ updateIsWaitingModalVisible, isWaitingModalVisible, }) {
        // Open or close the menu modal
        updateIsWaitingModalVisible(!isWaitingModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchWaiting, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchWaiting, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchWaiting, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Handles the response to a participant in the waiting room, either allowing or denying their entry.
 *
 * @param {RespondToWaitingOptions} options - Options for handling the participant's entry request.
 * @param {string} options.participantId - Unique identifier for the participant.
 * @param {string} options.participantName - Name of the participant.
 * @param {Function} options.updateWaitingList - Function to update the waiting list by removing the responded participant.
 * @param {WaitingRoomParticipant[]} options.waitingList - Current list of participants in the waiting room.
 * @param {boolean | string} options.type - Indicates whether to allow ("true") or deny ("false") the participant's entry.
 * @param {string} options.roomName - The name of the room the participant is requesting to join.
 * @param {Socket} options.socket - The socket instance used to emit the response event.
 * @returns {Promise<void>} Resolves when the response has been processed.
 *
 * @example
 * ```typescript
 * const respondService = new RespondToWaiting();
 * respondService.respondToWaiting({
 *   participantId: '12345',
 *   participantName: 'John Doe',
 *   updateWaitingList: (newList) => console.log('Updated Waiting List:', newList),
 *   waitingList: currentWaitingList,
 *   type: 'true',
 *   roomName: 'Room1',
 *   socket: io('http://localhost:3000'),
 * });
 * ```
 *
 * In this example, the participant 'John Doe' is allowed to join 'Room1', and the updated waiting list is logged.
 */
class RespondToWaiting {
    /**
     * Responds to a participant waiting to join a room by either allowing or denying their entry.
     *
     * @param {Object} options - The options for responding to the waiting participant.
     * @param {string} options.participantId - The ID of the participant.
     * @param {string} options.participantName - The name of the participant.
     * @param {Function} options.updateWaitingList - The function to update the waiting list.
     * @param {Array} options.waitingList - The current waiting list of participants.
     * @param {boolean | string} options.type - The type of response, either "true" or "false".
     * @param {string} options.roomName - The name of the room.
     * @param {Object} options.socket - The socket instance to emit events.
     * @returns {Promise<void>} - A promise that resolves when the response has been processed.
     */
    async respondToWaiting({ participantId, participantName, updateWaitingList, waitingList, type, roomName, socket, }) {
        // Filter out the participant from the waiting list
        const newWaitingList = waitingList.filter((item) => item.name !== participantName);
        // Update the waiting list
        updateWaitingList(newWaitingList);
        const responseType = type === 'true' || type === true ? 'true' : 'false';
        // Emit an event to allow or deny the participant based on the response type
        await socket.emit('allowUserIn', {
            participantId,
            participantName,
            type: responseType,
            roomName,
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RespondToWaiting, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RespondToWaiting, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RespondToWaiting, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

// whiteboard.service.ts
/**
 * Toggles the visibility of the configure whiteboard modal.
 *
 * @param {LaunchConfigureWhiteboardOptions} options - Options to control whiteboard configuration modal.
 * @param {Function} options.updateIsConfigureWhiteboardModalVisible - Function to update the modal's visibility state.
 * @param {boolean} options.isConfigureWhiteboardModalVisible - Current visibility state of the configure whiteboard modal.
 *
 * This function uses the current visibility state to toggle the whiteboard configuration modal on or off.
 *
 * @example
 * ```typescript
 * const launchService = new LaunchConfigureWhiteboard();
 * launchService.launchConfigureWhiteboard({
 *   updateIsConfigureWhiteboardModalVisible: (visible) => console.log('Modal Visible:', visible),
 *   isConfigureWhiteboardModalVisible: false
 * });
 * ```
 *
 * In this example, the modal visibility state is toggled, and the updated visibility state is logged.
 */
class LaunchConfigureWhiteboard {
    /**
     * Toggles the visibility of the configure whiteboard modal.
     *
     * @param updateIsConfigureWhiteboardModalVisible - Function to update the visibility state of the configure whiteboard modal.
     * @param isConfigureWhiteboardModalVisible - Current visibility state of the configure whiteboard modal.
     */
    launchConfigureWhiteboard({ updateIsConfigureWhiteboardModalVisible, isConfigureWhiteboardModalVisible, }) {
        // Open or close the menu modal
        updateIsConfigureWhiteboardModalVisible(!isConfigureWhiteboardModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchConfigureWhiteboard, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchConfigureWhiteboard, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LaunchConfigureWhiteboard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
// canvas.service.ts
/**
 * Captures the canvas stream and handles the transport connection for screen sharing.
 *
 * @param {CaptureCanvasStreamOptions} options - The options for capturing the canvas stream.
 * @param {Object} options.parameters - The parameters required for capturing and managing the canvas stream.
 * @param {HTMLCanvasElement} options.parameters.canvasWhiteboard - The canvas element to capture the stream from.
 * @param {MediaStream} [options.parameters.canvasStream] - The current canvas stream, if any.
 * @param {Function} options.parameters.updateCanvasStream - Function to update the canvas stream state.
 * @param {Producer | null} [options.parameters.screenProducer] - The current screen producer, if any.
 * @param {Producer | null} [options.parameters.localScreenProducer] - The current local screen producer, if any.
 * @param {boolean} [options.parameters.transportCreated] - Flag indicating if the transport has been created.
 * @param {boolean} [options.parameters.localTransportCreated] - Flag indicating if the local transport has been created.
 * @param {Socket} [options.parameters.localSocket] - The local socket instance used for communication.
 * @param {Function} options.parameters.updateScreenProducer - Function to update the screen producer state.
 * @param {Function} options.parameters.updateLocalScreenProducer - Function to update the local screen producer state.
 * @param {Function} options.parameters.sleep - Function to pause execution for a specified duration.
 * @param {Function} options.parameters.createSendTransport - Function to create a send transport for the screen.
 * @param {Function} options.parameters.connectSendTransportScreen - Function to connect the send transport for the screen.
 * @param {Function} options.parameters.disconnectSendTransportScreen - Function to disconnect the send transport for the screen.
 * @param {boolean} [start=true] - Flag indicating whether to start or stop the canvas stream.
 * @returns {Promise<void>} A promise that resolves when the operation is complete.
 *
 * @example
 * ```typescript
 * const canvasElement = document.querySelector('#canvas') as HTMLCanvasElement;
 * const options = {
 *   parameters: {
 *     canvasWhiteboard: canvasElement,
 *     updateCanvasStream: (stream) => console.log("Canvas Stream Updated:", stream),
 *     updateScreenProducer: (producer) => console.log("Screen Producer Updated:", producer),
 *     updateLocalScreenProducer: (localProducer) => console.log("Local Screen Producer Updated:", localProducer),
 *     createSendTransport: async (params) => console.log("Transport created with", params),
 *     connectSendTransportScreen: async (options) => console.log("Transport connected with", options),
 *     disconnectSendTransportScreen: async (params) => console.log("Transport disconnected with", params),
 *     sleep: ({ ms }) => new Promise(resolve => setTimeout(resolve, ms)),
 *   },
 *   start: true,
 * };
 * await captureCanvasStream(options);
 * ```
 */
class CaptureCanvasStream {
    /**
     * Capture the canvas stream.
     * @param {Object} parameters - The parameters object.
     * @param {boolean} [start=true] - Indicates whether to start capturing the stream.
     * @returns {Promise<void>} - A promise that resolves when the canvas stream is captured.
     */
    captureCanvasStream = async ({ parameters, start = true, }) => {
        try {
            parameters = parameters.getUpdatedAllParams();
            let { canvasWhiteboard, canvasStream, updateCanvasStream, screenProducer, localScreenProducer, transportCreated, localTransportCreated, updateScreenProducer, updateLocalScreenProducer, localSocket, 
            // mediasfu functions
            sleep, createSendTransport, connectSendTransportScreen, disconnectSendTransportScreen, } = parameters;
            if (start && !canvasStream) {
                // Wait for canvasWhiteboard to be available
                let attempts = 0;
                const maxAttempts = 20; // 2 seconds / 100ms intervals
                while (!canvasWhiteboard && attempts < maxAttempts) {
                    await new Promise((resolve) => setTimeout(resolve, 100));
                    parameters = parameters.getUpdatedAllParams();
                    canvasWhiteboard = parameters.canvasWhiteboard;
                    attempts++;
                }
                if (!canvasWhiteboard) {
                    throw new Error('Canvas whiteboard not available.');
                }
                const stream = canvasWhiteboard.captureStream(30);
                canvasStream = stream;
                updateCanvasStream(stream);
                if (localSocket && !localSocket.id) {
                    try {
                        if (!localTransportCreated) {
                            await createSendTransport({ option: "screen", parameters });
                        }
                        else {
                            try {
                                if (localScreenProducer) {
                                    localScreenProducer.close();
                                    if (updateLocalScreenProducer) {
                                        updateLocalScreenProducer(null);
                                    }
                                    await sleep({ ms: 500 });
                                }
                            }
                            catch (error) {
                                console.error(error);
                            }
                            await connectSendTransportScreen({ stream, parameters });
                        }
                    }
                    catch {
                        // do nothing
                    }
                    return;
                }
                if (!transportCreated) {
                    await createSendTransport({ option: 'screen', parameters });
                }
                else {
                    try {
                        screenProducer.close();
                        updateScreenProducer(null);
                        await sleep({ ms: 500 });
                    }
                    catch {
                        /* handle error */
                    }
                    await connectSendTransportScreen({ stream, parameters });
                }
            }
            else {
                if (!start && canvasStream) {
                    canvasStream.getTracks().forEach((track) => track.stop());
                    canvasStream = null;
                    updateCanvasStream(null);
                    disconnectSendTransportScreen({ parameters });
                }
            }
        }
        catch (error) {
            console.log('Error in captureCanvasStream:', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CaptureCanvasStream, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CaptureCanvasStream, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CaptureCanvasStream, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Creates a mediasoup client device using the provided RTP capabilities.
 *
 * @param {CreateDeviceClientOptions} options - Options containing the required RTP capabilities.
 * @param {RtpCapabilities | null} options.rtpCapabilities - The RTP capabilities necessary for initializing the device.
 * @returns {Promise<Device | null>} - A promise resolving to the created `Device` instance or `null` if creation fails.
 * @throws {Error} - Throws an error if RTP capabilities or the mediasoup client library are not provided, or if the device is unsupported by the browser.
 *
 * This function initializes a mediasoup client `Device` using the specified RTP capabilities, enabling communication capabilities according to provided media configurations. It filters out unsupported video orientation extensions and loads router capabilities, ensuring compatibility with client configurations.
 *
 * @example
 * ```typescript
 * const client = new CreateDeviceClient();
 * const device = await client.createDeviceClient({ rtpCapabilities });
 * if (device) {
 *   console.log('Device created successfully:', device);
 * } else {
 *   console.log('Failed to create device.');
 * }
 * ```
 *
 * In this example, the function creates a device based on RTP capabilities, handling errors and unsupported devices gracefully.
 */
class CreateDeviceClient {
    /**
     * Creates a mediasoup client device with the provided RTP capabilities.
     *
     * @param {CreateDeviceClientOptions} options - The options for creating the device client.
     * @param {RTPCapabilities} options.rtpCapabilities - The RTP capabilities required for the device.
     * @returns {Promise<Device | null>} A promise that resolves to the created Device or null if creation fails.
     * @throws {Error} Throws an error if the required parameters are not provided or if device creation is not supported.
     *
     */
    async createDeviceClient({ rtpCapabilities }) {
        try {
            // Validate input parameters
            if (!rtpCapabilities || !mediasoupClient) {
                throw new Error('Both rtpCapabilities and mediasoupClient must be provided.');
            }
            // Create a mediasoup client device
            const device = new mediasoupClient.Device();
            // Remove orientation capabilities
            if (rtpCapabilities.headerExtensions) {
                rtpCapabilities.headerExtensions = rtpCapabilities.headerExtensions.filter((ext) => ext.uri !== 'urn:3gpp:video-orientation');
            }
            // Load the provided RTP capabilities into the device
            await device.load({
                routerRtpCapabilities: rtpCapabilities,
            });
            // Perform additional initialization, e.g., loading spinner and retrieving messages
            return device;
        }
        catch (error) {
            // Handle specific errors, e.g., UnsupportedError
            if (error.name === 'UnsupportedError') {
                // Handle unsupported device creation
                console.error('UnsupportedError: Device creation is not supported by the browser.');
            }
            throw error; // Propagate other errors
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CreateDeviceClient, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CreateDeviceClient, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CreateDeviceClient, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Joins a user to a room using socket communication with validation checks.
 *
 * @param {JoinRoomOptions} options - Contains:
 *   - `socket`: Socket instance for communication.
 *   - `roomName`: Name of the room to join.
 *   - `islevel`: User's level indicator.
 *   - `member`: User identifier.
 *   - `sec`: Security token.
 *   - `apiUserName`: API username for authentication.
 *
 * - **Validation**:
 *   - Ensures `roomName`, `apiUserName`, and `member` are alphanumeric.
 *   - Verifies that `roomName` starts with 's' or 'p' and meets length requirements.
 *   - Validates `sec`, `islevel`, and `apiUserName` against specified length and format conditions.
 *
 * - **Response Handling**:
 *   - Resolves with the server's response upon a successful join.
 *   - Rejects with a descriptive error if the user is banned, suspended, or if the host has not yet joined the room.
 *
 * @returns {Promise<object>} Resolves with data from the 'joinRoom' event or rejects with validation errors.
 * @throws {Error} Throws errors encountered during validation or join process.
 *
 * @example
 * ```typescript
 * const joinOptions = {
 *   socket: mySocket,
 *   roomName: 'sMyRoom',
 *   islevel: '1',
 *   member: 'participant123',
 *   sec: '64-character-secure-key...',
 *   apiUserName: 'apiUser123',
 * };
 * joinRoom(joinOptions)
 *   .then(response => console.log('Room joined:', response))
 *   .catch(error => console.error('Join failed:', error));
 * ```
 */
class JoinRoom {
    validateAlphanumeric;
    constructor(validateAlphanumeric) {
        this.validateAlphanumeric = validateAlphanumeric;
    }
    /**
     * Joins a user to a specified room via a socket connection.
     *
     * @param {Object} options - The options for joining the room.
     * @param {Socket} options.socket - The socket instance to use for communication.
     * @param {string} options.roomName - The name of the room to join.
     * @param {string} options.islevel - The level of the user.
     * @param {string} options.member - The member identifier.
     * @param {string} options.sec - The security token.
     * @param {string} options.apiUserName - The API username of the user.
     *
     * @returns {Promise<object>} A promise that resolves with the data received from the 'joinRoom' event or rejects with a validation error.
     *
     * @throws {Error} Throws an error if the user is banned, suspended, or if the host has not joined the room yet.
     */
    async joinRoom({ socket, roomName, islevel, member, sec, apiUserName, }) {
        return new Promise((resolve, reject) => {
            // Validate inputs
            if (!(sec && roomName && islevel && apiUserName && member)) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Missing required parameters',
                };
                reject(validationError);
                return;
            }
            // Validate alphanumeric for roomName, apiUserName, and member
            try {
                this.validateAlphanumeric.validateAlphanumeric({ str: roomName });
                this.validateAlphanumeric.validateAlphanumeric({ str: apiUserName });
                this.validateAlphanumeric.validateAlphanumeric({ str: member });
            }
            catch (error) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName or apiUserName or member',
                };
                reject(validationError);
                return;
            }
            // Validate roomName starts with 's' or 'p'
            if (!(roomName.startsWith('s') || roomName.startsWith('p'))) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName, must start with s or p',
                };
                reject(validationError);
                return;
            }
            // Validate other conditions for sec, roomName, islevel, apiUserName
            if (!(sec.length === 64 &&
                roomName.length >= 8 &&
                islevel.length === 1 &&
                apiUserName.length >= 6 &&
                (islevel === '0' || islevel === '1' || islevel === '2'))) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName or islevel or apiUserName or secret',
                };
                reject(validationError);
                return;
            }
            socket.emit('joinRoom', { roomName, islevel, member, sec, apiUserName }, async (data) => {
                try {
                    // Check if rtpCapabilities is null
                    if (data.rtpCapabilities === null) {
                        // Check if banned, suspended, or noAdmin
                        if (data.banned) {
                            throw new Error('User is banned.');
                        }
                        if (data.suspended) {
                            throw new Error('User is suspended.');
                        }
                        if (data.noAdmin) {
                            throw new Error('Host has not joined the room yet.');
                        }
                        // Resolve with the data received from the 'joinRoom' event
                        resolve(data);
                    }
                    else {
                        // Resolve with the data received from the 'joinRoom' event
                        resolve(data);
                    }
                }
                catch (error) {
                    // Handle errors during the joinRoom process
                    console.log('Error joining room:', error);
                    reject(error);
                }
            });
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinRoom, deps: [{ token: ValidateAlphanumeric }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinRoom, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinRoom, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: ValidateAlphanumeric }] });

/**
 * Facilitates joining a room by emitting the `joinRoom` event to the server through a socket connection.
 *
 * @param {JoinRoomClientOptions} options - Configuration options for joining the room.
 * @param {Socket} options.socket - The socket instance for server communication.
 * @param {string} options.roomName - The name of the room to join.
 * @param {string} options.islevel - Level identifier for the user in the room.
 * @param {string} options.member - Member identifier for the joining user.
 * @param {string} options.sec - Security token or identifier for access.
 * @param {string} options.apiUserName - API username for server authentication.
 * @param {boolean} [options.consume=false] - If `true`, joins via `joinConRoom`; otherwise, joins via `joinRoom`.
 * @returns {Promise<any>} - A promise resolving with the server response data.
 * @throws {Error} - Throws an error if the room joining attempt fails.
 *
 * @example
 * ```typescript
 * const joinRoomClient = new JoinRoomClient(joinRoomService, joinConRoomService);
 * const response = await joinRoomClient.joinRoomClient({
 *   socket: mySocket,
 *   roomName: 'myRoom',
 *   islevel: '1',
 *   member: 'user123',
 *   sec: 'secureToken',
 *   apiUserName: 'apiUser',
 *   consume: true,
 * });
 * console.log('Joined room with response:', response);
 * ```
 *
 * This example demonstrates using `joinRoomClient` to join a room, either as a consumer or a producer, based on the `consume` flag.
 */
class JoinRoomClient {
    JoinRoomService;
    JoinConRoomService;
    constructor(JoinRoomService, JoinConRoomService) {
        this.JoinRoomService = JoinRoomService;
        this.JoinConRoomService = JoinConRoomService;
    }
    /**
     * Joins a room by emitting the `joinRoom` event to the server using the provided socket.
     *
     * @param {Object} options - The options for joining the room.
     * @param {Socket} options.socket - The socket instance to use for communication.
     * @param {string} options.roomName - The name of the room to join.
     * @param {boolean} options.islevel - The level indicator for the room.
     * @param {string} options.member - The member identifier.
     * @param {string} options.sec - The security token or identifier.
     * @param {string} options.apiUserName - The API username for authentication.
     * @param {boolean} [options.consume=false] - Flag to determine which join function to use.
     * @returns {Promise<any>} A promise that resolves with the data returned from the server.
     * @throws {Error} Throws an error if the room joining process fails.
     */
    async joinRoomClient({ socket, roomName, islevel, member, sec, apiUserName, consume = false, }) {
        try {
            let data;
            if (consume) {
                data = await this.JoinConRoomService.joinConRoom({
                    socket,
                    roomName,
                    islevel,
                    member,
                    sec,
                    apiUserName,
                });
            }
            else {
                data = await this.JoinRoomService.joinRoom({
                    socket,
                    roomName,
                    islevel,
                    member,
                    sec,
                    apiUserName,
                });
            }
            return data;
        }
        catch (error) {
            console.error(error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinRoomClient, deps: [{ token: JoinRoom }, { token: JoinConRoom }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinRoomClient, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinRoomClient, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: JoinRoom }, { type: JoinConRoom }] });

/**
 * The `VideoCaptureConstraints` service provides various video capture constraints
 * including resolution and frame rate settings for different display sizes (landscape, portrait, and neutral).
 *
 * @service
 * @example
 * ```typescript
 * import { VideoCaptureConstraints } from './path/to/video-capture-constraints.service';
 *
 * constructor(private videoConstraints: VideoCaptureConstraints) {
 *   console.log(this.videoConstraints.hdCons); // Access HD constraints
 * }
 * ```
 *
 * @remarks
 * This service contains predefined constraints that can be used for video capture
 * settings based on the desired quality and aspect ratio. These constraints can
 * be applied when requesting media streams from the user's camera.
 *
 * @property {Object} QnHDCons - Video capture constraints for QnHD resolution (320x180).
 * @property {Object} sdCons - Video capture constraints for SD resolution (640x360).
 * @property {Object} hdCons - Video capture constraints for HD resolution (1280x720).
 * @property {Object} fhdCons - Video capture constraints for FHD resolution (1920x1080).
 * @property {Object} qhdCons - Video capture constraints for QHD resolution (2560x1440).
 *
 * @property {Object} QnHDConsPort - Video capture constraints for QnHD resolution in portrait mode.
 * @property {Object} sdConsPort - Video capture constraints for SD resolution in portrait mode.
 * @property {Object} hdConsPort - Video capture constraints for HD resolution in portrait mode.
 * @property {Object} fhdConsPort - Video capture constraints for FHD resolution in portrait mode.
 * @property {Object} qhdConsPort - Video capture constraints for QHD resolution in portrait mode.
 *
 * @property {Object} QnHDConsNeu - Video capture constraints for QnHD resolution in neutral mode.
 * @property {Object} sdConsNeu - Video capture constraints for SD resolution in neutral mode.
 * @property {Object} hdConsNeu - Video capture constraints for HD resolution in neutral mode.
 * @property {Object} fhdConsNeu - Video capture constraints for FHD resolution in neutral mode.
 * @property {Object} qhdConsNeu - Video capture constraints for QnHD resolution in neutral mode.
 *
 * @property {number} QnHDFrameRate - Frame rate for QnHD video capture (5 FPS).
 * @property {number} sdFrameRate - Frame rate for SD video capture (10 FPS).
 * @property {number} hdFrameRate - Frame rate for HD video capture (15 FPS).
 * @property {number} fhdFrameRate - Frame rate for FHD video capture (20 FPS).
 * @property {number} qhdFrameRate - Frame rate for QHD video capture (30 FPS).
 * @property {number} screenFrameRate - Frame rate for screen capture (30 FPS).
 *
 * @returns {VideoCaptureConstraints} The video capture constraints for use in media requests.
 */
class VideoCaptureConstraints {
    // Landscape display sizes
    QnHDCons = { width: { ideal: 320 }, height: { ideal: 180 } };
    sdCons = { width: { ideal: 640 }, height: { ideal: 360 } };
    hdCons = { width: { ideal: 1280 }, height: { ideal: 720 } };
    fhdCons = { width: { ideal: 1920 }, height: { ideal: 1080 } };
    qhdCons = { width: { ideal: 2560 }, height: { ideal: 1440 } };
    // Portrait display sizes
    QnHDConsPort = { width: { ideal: 180 }, height: { ideal: 320 } };
    sdConsPort = { width: { ideal: 360 }, height: { ideal: 640 } };
    hdConsPort = { width: { ideal: 720 }, height: { ideal: 1280 } };
    fhdConsPort = { width: { ideal: 1080 }, height: { ideal: 1920 } };
    qhdConsPort = { width: { ideal: 1440 }, height: { ideal: 2560 } };
    // Neutral (Square) display sizes
    QnHDConsNeu = { width: { ideal: 240 }, height: { ideal: 240 } };
    sdConsNeu = { width: { ideal: 480 }, height: { ideal: 480 } };
    hdConsNeu = { width: { ideal: 960 }, height: { ideal: 960 } };
    fhdConsNeu = { width: { ideal: 1440 }, height: { ideal: 1440 } };
    qhdConsNeu = { width: { ideal: 1920 }, height: { ideal: 1920 } };
    // Frame rates for video capture
    QnHDFrameRate = 5;
    sdFrameRate = 10;
    hdFrameRate = 15;
    fhdFrameRate = 20;
    qhdFrameRate = 30;
    screenFrameRate = 30;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: VideoCaptureConstraints, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: VideoCaptureConstraints, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: VideoCaptureConstraints, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
// room.service.ts
/**
 * Updates room parameters for the client after joining a room and receiving server-provided parameters.
 *
 * @param {UpdateRoomParametersClientOptions} options - An object containing:
 *  - various room settings and parameters,
 *  - functions to update those parameters.
 *
 * - **Screen/Page Settings:** Adjusts screen and item page limits, meeting room parameters, and video constraints based on server data.
 * - **Recording and Media Settings:** Applies bitrate and frame rate adjustments, based on the target resolution and media options.
 * - **Role-Specific Settings:** Configures admin, host, and co-host settings for permissions, orientations, and resolutions.
 * - **Alerting**: Uses `showAlert` to notify the client on issues or permissions restrictions.
 *
 * @example
 * ```typescript
 * const options = {
 *   parameters: {
 *     rtpCapabilities: myRtpCapabilities,
 *     roomRecvIPs: ['192.168.1.1'],
 *     meetingRoomParams: myMeetingParams,
 *     itemPageLimit: 3,
 *     audioOnlyRoom: false,
 *     addForBasic: true,
 *     screenPageLimit: 2,
 *     shareScreenStarted: false,
 *     shared: true,
 *     targetOrientation: 'landscape',
 *     recordingVideoSupport: true,
 *     frameRate: 15,
 *     adminPasscode: 'admin123',
 *     eventType: 'conference',
 *     youAreCoHost: false,
 *     updateRtpCapabilities: (rtp) => console.log('Updating RTP:', rtp),
 *     updateRoomRecvIPs: (ips) => console.log('Updating IPs:', ips),
 *     updateMeetingRoomParams: (params) => console.log('Updating room params:', params),
 *     // Additional parameters...
 *   },
 * };
 *
 * const updateRoomParametersClient = new UpdateRoomParametersClient(videoCaptureConstraints, hParams, vParams, screenParams, aParams);
 * updateRoomParametersClient.updateRoomParametersClient(options);
 * ```
 *
 * This example demonstrates setting up room parameters for a conference-type room with recording support and custom update functions.
 */
class UpdateRoomParametersClient {
    videoCaptureConstraints;
    hParams;
    vParams;
    screenParams;
    aParams;
    constructor(videoCaptureConstraints, hParams, vParams, screenParams, aParams) {
        this.videoCaptureConstraints = videoCaptureConstraints;
        this.hParams = hParams;
        this.vParams = vParams;
        this.screenParams = screenParams;
        this.aParams = aParams;
    }
    /**
     * Update Room Parameters Client after the user has joined the room and the room parameters have been received from the server.
     * @param {Object} parameters - An object containing various parameters and update functions.
     */
    updateRoomParametersClient = ({ parameters }) => {
        try {
            const { screenPageLimit, shareScreenStarted, shared, hParams, vParams, frameRate, islevel, showAlert, data, 
            //updates
            updateRtpCapabilities, updateRoomRecvIPs, updateMeetingRoomParams, updateItemPageLimit, updateAudioOnlyRoom, updateScreenPageLimit, updateVidCons, updateFrameRate, updateAdminPasscode, updateEventType, updateYouAreCoHost, updateAutoWave, updateForceFullDisplay, updateChatSetting, updateMeetingDisplayType, updateAudioSetting, updateVideoSetting, updateScreenshareSetting, updateHParams, updateVParams, updateScreenParams, updateAParams, updateTargetResolution, updateTargetResolutionHost, 
            // Recording updates
            updateRecordingAudioPausesLimit, updateRecordingAudioPausesCount, updateRecordingAudioSupport, updateRecordingAudioPeopleLimit, updateRecordingAudioParticipantsTimeLimit, updateRecordingVideoPausesCount, updateRecordingVideoPausesLimit, updateRecordingVideoSupport, updateRecordingVideoPeopleLimit, updateRecordingVideoParticipantsTimeLimit, updateRecordingAllParticipantsSupport, updateRecordingVideoParticipantsSupport, updateRecordingAllParticipantsFullRoomSupport, updateRecordingVideoParticipantsFullRoomSupport, updateRecordingPreferredOrientation, updateRecordingSupportForOtherOrientation, updateRecordingMultiFormatsSupport, updateRecordingVideoOptions, updateRecordingAudioOptions, updateMainHeightWidth, } = parameters;
            if (data.rtpCapabilities == null) {
                let reason = data.reason || '';
                showAlert?.({
                    message: 'Sorry, you are not allowed to join this room. ' + reason,
                    type: 'danger',
                    duration: 3000,
                });
                return;
            }
            // Update all values
            updateRtpCapabilities(data.rtpCapabilities);
            updateAdminPasscode(data.secureCode);
            updateRoomRecvIPs(data.roomRecvIPs);
            updateMeetingRoomParams(data.meetingRoomParams);
            // Update recording values
            updateRecordingAudioPausesLimit(data.recordingParams.recordingAudioPausesLimit);
            updateRecordingAudioPausesCount(data.recordingParams.recordingAudioPausesCount);
            updateRecordingAudioSupport(data.recordingParams.recordingAudioSupport);
            updateRecordingAudioPeopleLimit(data.recordingParams.recordingAudioPeopleLimit);
            updateRecordingAudioParticipantsTimeLimit(data.recordingParams.recordingAudioParticipantsTimeLimit);
            updateRecordingVideoPausesCount(data.recordingParams.recordingVideoPausesCount);
            updateRecordingVideoPausesLimit(data.recordingParams.recordingVideoPausesLimit);
            updateRecordingVideoSupport(data.recordingParams.recordingVideoSupport);
            updateRecordingVideoPeopleLimit(data.recordingParams.recordingVideoPeopleLimit);
            updateRecordingVideoParticipantsTimeLimit(data.recordingParams.recordingVideoParticipantsTimeLimit);
            updateRecordingAllParticipantsSupport(data.recordingParams.recordingAllParticipantsSupport);
            updateRecordingVideoParticipantsSupport(data.recordingParams.recordingVideoParticipantsSupport);
            updateRecordingAllParticipantsFullRoomSupport(data.recordingParams.recordingAllParticipantsFullRoomSupport);
            updateRecordingVideoParticipantsFullRoomSupport(data.recordingParams.recordingVideoParticipantsFullRoomSupport);
            updateRecordingPreferredOrientation(data.recordingParams.recordingPreferredOrientation);
            updateRecordingSupportForOtherOrientation(data.recordingParams.recordingSupportForOtherOrientation);
            updateRecordingMultiFormatsSupport(data.recordingParams.recordingMultiFormatsSupport);
            // Update other meeting room settings
            updateItemPageLimit(data.meetingRoomParams.itemPageLimit);
            updateEventType(data.meetingRoomParams.type);
            if (data.meetingRoomParams.type == 'chat' && islevel != '2') {
                updateYouAreCoHost(true);
            }
            if (['chat', 'broadcast'].includes(data.meetingRoomParams.type)) {
                updateAutoWave(false);
                updateMeetingDisplayType('all');
                updateForceFullDisplay(true);
                updateChatSetting('allow');
            }
            updateAudioSetting(data.meetingRoomParams.audioSetting);
            updateVideoSetting(data.meetingRoomParams.videoSetting);
            updateScreenshareSetting(data.meetingRoomParams.screenshareSetting);
            updateChatSetting(data.meetingRoomParams.chatSetting);
            updateAudioOnlyRoom(data.meetingRoomParams.mediaType != 'video');
            if (data.meetingRoomParams.type == 'chat' || data.meetingRoomParams.type == 'broadcast') {
                if (data.meetingRoomParams.type == 'broadcast') {
                    updateItemPageLimit(1);
                    updateRecordingVideoOptions('mainScreen');
                    updateRecordingAudioOptions('host');
                }
                else {
                    updateItemPageLimit(2);
                }
            }
            if (data.meetingRoomParams.type == 'conference' && (shared || shareScreenStarted)) {
                updateMainHeightWidth(100);
            }
            else {
                updateMainHeightWidth(0);
            }
            updateScreenPageLimit(Math.min(data.meetingRoomParams.itemPageLimit, screenPageLimit));
            // Assign media capture constraints based on the user's role and room settings
            let targetOrientation = islevel == '2'
                ? data.meetingRoomParams.targetOrientationHost
                : data.meetingRoomParams.targetOrientation;
            let targetResolution = islevel == '2'
                ? data.meetingRoomParams.targetResolutionHost
                : data.meetingRoomParams.targetResolution;
            let vidCons;
            if (targetOrientation == 'landscape') {
                vidCons =
                    targetResolution == 'hd'
                        ? this.videoCaptureConstraints.hdCons
                        : targetResolution == 'QnHD'
                            ? this.videoCaptureConstraints.QnHDCons
                            : targetResolution == 'fhd'
                                ? this.videoCaptureConstraints.fhdCons
                                : targetResolution == 'qhd'
                                    ? this.videoCaptureConstraints.qhdCons
                                    : this.videoCaptureConstraints.sdCons;
            }
            else if (targetOrientation == 'neutral') {
                vidCons =
                    targetResolution == 'hd'
                        ? this.videoCaptureConstraints.hdConsNeu
                        : targetResolution == 'QnHD'
                            ? this.videoCaptureConstraints.QnHDConsNeu
                            : targetResolution == 'fhd'
                                ? this.videoCaptureConstraints.fhdConsNeu
                                : targetResolution == 'qhd'
                                    ? this.videoCaptureConstraints.qhdConsNeu
                                    : this.videoCaptureConstraints.sdConsNeu;
            }
            else {
                vidCons =
                    targetResolution == 'hd'
                        ? this.videoCaptureConstraints.hdConsPort
                        : targetResolution == 'QnHD'
                            ? this.videoCaptureConstraints.QnHDConsPort
                            : targetResolution == 'fhd'
                                ? this.videoCaptureConstraints.fhdConsPort
                                : targetResolution == 'qhd'
                                    ? this.videoCaptureConstraints.qhdConsPort
                                    : this.videoCaptureConstraints.sdConsPort;
            }
            let frameRateValue = frameRate ? frameRate : 10;
            let vParamsValue = { ...vParams };
            let hParamsValue = { ...hParams };
            if (Object.keys(vParamsValue).length === 0) {
                vParamsValue = this.vParams.vParams;
            }
            if (Object.keys(hParamsValue).length === 0) {
                hParamsValue = this.hParams.hParams;
            }
            if (targetResolution == 'hd') {
                frameRateValue = this.videoCaptureConstraints.hdFrameRate;
                vParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 4);
                });
                hParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 4);
                });
            }
            else if (targetResolution == 'QnHD') {
                frameRateValue = this.videoCaptureConstraints.QnHDFrameRate;
                vParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 0.25);
                });
                hParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 0.25);
                });
                hParamsValue.codecOptions.videoGoogleStartBitrate *= 0.25;
                vParamsValue.codecOptions.videoGoogleStartBitrate *= 0.25;
            }
            else if (targetResolution == 'fhd') {
                frameRateValue = this.videoCaptureConstraints.fhdFrameRate;
                vParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 8);
                });
                hParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 8);
                });
                hParamsValue.codecOptions.videoGoogleStartBitrate *= 8;
                vParamsValue.codecOptions.videoGoogleStartBitrate *= 8;
            }
            else if (targetResolution == 'qhd') {
                frameRateValue = this.videoCaptureConstraints.qhdFrameRate;
                vParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 16);
                });
                hParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 16);
                });
                hParamsValue.codecOptions.videoGoogleStartBitrate *= 16;
                vParamsValue.codecOptions.videoGoogleStartBitrate *= 16;
            }
            if (data.recordingParams.recordingVideoSupport) {
                vParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 1.2);
                });
                hParamsValue.encodings.forEach((encoding) => {
                    encoding.maxBitrate && (encoding.maxBitrate *= 1.2);
                });
                hParamsValue.codecOptions.videoGoogleStartBitrate *= 1.2;
                vParamsValue.codecOptions.videoGoogleStartBitrate *= 1.2;
            }
            updateVidCons(vidCons);
            updateFrameRate(frameRateValue);
            updateHParams(hParamsValue);
            updateVParams(vParamsValue);
            updateScreenParams(this.screenParams.screenParams);
            updateAParams(this.aParams.aParams);
            updateTargetResolution(data.meetingRoomParams.targetResolution);
            updateTargetResolutionHost(data.meetingRoomParams.targetResolutionHost);
        }
        catch (error) {
            console.log('updateRoomParametersClient error', error);
            parameters.showAlert?.({
                message: error.message,
                type: 'danger',
                duration: 3000,
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateRoomParametersClient, deps: [{ token: VideoCaptureConstraints }, { token: HParams }, { token: VParams }, { token: ScreenParams }, { token: AParams }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateRoomParametersClient, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateRoomParametersClient, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: VideoCaptureConstraints }, { type: HParams }, { type: VParams }, { type: ScreenParams }, { type: AParams }] });

const MAX_ATTEMPTS$1 = 10; // Maximum number of unsuccessful attempts before rate limiting
const RATE_LIMIT_DURATION$1 = 3 * 60 * 60 * 1000; // 3 hours in milliseconds
const TIMEOUT_DURATION = 10000; // 10 seconds
class CheckLimitsAndMakeRequest {
    cookieService;
    constructor(cookieService) {
        this.cookieService = cookieService;
    }
    /**
     * Checks rate limits and attempts to make a socket connection.
     *
     * @param params - The parameters required for making the request.
     */
    async checkLimitsAndMakeRequest({ apiUserName, apiToken, link, apiKey = '', userName, parameters, validate = true, }) {
        let unsuccessfulAttempts = parseInt(this.cookieService.get('unsuccessfulAttempts'), 10) || 0;
        let lastRequestTimestamp = parseInt(this.cookieService.get('lastRequestTimestamp'), 10) || 0;
        if (unsuccessfulAttempts >= MAX_ATTEMPTS$1 &&
            Date.now() - lastRequestTimestamp < RATE_LIMIT_DURATION$1) {
            parameters.showAlert?.({
                message: 'Too many unsuccessful attempts. Please try again later.',
                type: 'danger',
                duration: 3000,
            });
            this.cookieService.set('lastRequestTimestamp', Date.now().toString());
            return;
        }
        else {
            // Reset attempts if the rate limit duration has passed
            if (Date.now() - lastRequestTimestamp >= RATE_LIMIT_DURATION$1) {
                unsuccessfulAttempts = 0;
                this.cookieService.set('unsuccessfulAttempts', '0');
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
            }
        }
        try {
            parameters.updateIsLoadingModalVisible(true);
            // Initiate socket connection
            const socket = await Promise.race([
                parameters.connectSocket({
                    apiUserName,
                    apiKey,
                    apiToken,
                    link,
                }),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Request timed out')), TIMEOUT_DURATION)),
            ]);
            if (socket && socket instanceof Socket && socket.id) {
                // Successful connection
                unsuccessfulAttempts = 0;
                this.cookieService.set('unsuccessfulAttempts', '0');
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
                if (validate) {
                    parameters.updateSocket(socket);
                }
                else {
                    parameters.updateLocalSocket?.(socket);
                }
                parameters.updateApiUserName(apiUserName);
                parameters.updateApiToken(apiToken);
                parameters.updateLink(link);
                parameters.updateRoomName(apiUserName);
                parameters.updateMember(userName);
                if (validate) {
                    parameters.updateValidated(true);
                }
                parameters.updateIsLoadingModalVisible(false);
            }
            else {
                // Unsuccessful connection
                unsuccessfulAttempts += 1;
                this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
                parameters.updateIsLoadingModalVisible(false);
                if (unsuccessfulAttempts >= MAX_ATTEMPTS$1) {
                    parameters.showAlert?.({
                        message: 'Too many unsuccessful attempts. Please try again later.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
                else {
                    parameters.showAlert?.({
                        message: 'Invalid credentials.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
        }
        catch (error) {
            // Handle errors (e.g., timeout)
            parameters.showAlert?.({
                message: 'Unable to connect. Check your credentials and try again.',
                type: 'danger',
                duration: 3000,
            });
            unsuccessfulAttempts += 1;
            this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
            this.cookieService.set('lastRequestTimestamp', Date.now().toString());
            parameters.updateIsLoadingModalVisible(false);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckLimitsAndMakeRequest, deps: [{ token: i1$1.CookieService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckLimitsAndMakeRequest, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CheckLimitsAndMakeRequest, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: i1$1.CookieService }] });

/**
 * Checks the MediaSFU URL and processes the necessary actions based on the URL's validity.
 *
 * @param {CheckMediasfuURLOptions} options - The options for checking and handling the MediaSFU URL.
 * @param {ResponseJoinLocalRoom} options.data - The data received from the room join response.
 * @param {string} options.member - The member identifier.
 * @param {string} options.roomName - The name of the room to join.
 * @param {string} options.islevel - The level of the user.
 * @param {Socket} options.socket - The socket instance to use for communication.
 * @param {PreJoinPageParameters} options.parameters - Additional parameters for pre-join page actions.
 * @param {JoinRoomOnMediaSFUType} options.joinMediaSFURoom - The function to join a room on MediaSFU.
 * @param {string} options.localLink - The local link to use for Community Edition.
 *
 * @returns {Promise<void>} A promise that resolves when the actions are complete.
 *
 * @example
 * ```typescript
 * const options = {
 *   data: {
 *     mediasfuURL: "https://example.com/meet/room123/secret",
 *     allowRecord: true,
 *     apiKey: "1234567890123456789012345678901234567890123456789012345678901234",
 *     apiUserName: "user123",
 *   },
 *   member: "user123",
 *   roomName: "s12345678",
 *   islevel: "1",
 *   socket: socketInstance,
 *   parameters: {
 *     someParameter: "value",
 *   },
 *   joinMediaSFURoom: joinRoomOnMediaSFU,
 *   localLink: "https://socketserver.example.com",
 * };
 *
 * try {
 *   await checkMediasfuURL(options);
 *   console.log("MediaSFU URL processed successfully.");
 * } catch (error) {
 *   console.error("Failed to process MediaSFU URL:", error);
 * }
 * ```
 */
class JoinLocalRoom {
    validateAlphanumericService;
    checkLimitsService;
    joinRoomOnMediaSFU;
    constructor(validateAlphanumericService, checkLimitsService, joinRoomOnMediaSFU) {
        this.validateAlphanumericService = validateAlphanumericService;
        this.checkLimitsService = checkLimitsService;
        this.joinRoomOnMediaSFU = joinRoomOnMediaSFU;
    }
    /**
     * Checks the MediaSFU URL and processes the necessary actions based on the URL's validity.
     *
     * @param {CheckMediasfuURLOptions} options - The options for checking and handling the MediaSFU URL.
     * @param {ResponseJoinLocalRoom} options.data - The data received from the room join response.
     * @param {string} options.member - The member identifier.
     * @param {string} options.roomName - The name of the room to join.
     * @param {string} options.islevel - The level of the user.
     * @param {Socket} options.socket - The socket instance to use for communication.
     * @param {PreJoinPageParameters} options.parameters - Additional parameters for pre-join page actions.
     * @param {JoinRoomOnMediaSFUType} options.joinMediaSFURoom - The function to join a room on MediaSFU.
     * @param {string} options.localLink - The local link to use for Community Edition.
     *
     * @returns {Promise<void>} A promise that resolves when the actions are complete.
     *
     * @example
     * ```typescript
     * const options = {
     *   data: {
     *     mediasfuURL: "https://example.com/meet/room123/secret",
     *     allowRecord: true,
     *     apiKey: "1234567890123456789012345678901234567890123456789012345678901234",
     *     apiUserName: "user123",
     *   },
     *   member: "user123",
     *   roomName: "s12345678",
     *   islevel: "1",
     *   socket: socketInstance,
     *   parameters: {
     *     someParameter: "value",
     *   },
     *   joinMediaSFURoom: joinRoomOnMediaSFU,
     *   localLink: "https://socketserver.example.com",
     * };
     *
     * try {
     *   await checkMediasfuURL(options);
     *   console.log("MediaSFU URL processed successfully.");
     * } catch (error) {
     *   console.error("Failed to process MediaSFU URL:", error);
     * }
     * ```
     */
    async joinLocalRoom(options) {
        const { socket, roomName, islevel, member, sec, apiUserName, parameters, checkConnect = false, joinMediaSFURoom = this.joinRoomOnMediaSFU.joinRoomOnMediaSFU, localLink = '', } = options;
        return new Promise((resolve, reject) => {
            // Validate inputs
            if (!(sec && roomName && islevel && apiUserName && member)) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Missing required parameters',
                };
                reject(validationError);
                return;
            }
            // Validate alphanumeric for roomName, apiUserName, and member
            try {
                this.validateAlphanumericService.validateAlphanumeric({ str: roomName });
                this.validateAlphanumericService.validateAlphanumeric({ str: apiUserName });
                this.validateAlphanumericService.validateAlphanumeric({ str: member });
            }
            catch (error) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName or apiUserName or member',
                };
                reject(validationError);
                return;
            }
            // Validate roomName starts with 's', 'p', or 'm'
            if (!(roomName.startsWith('s') ||
                roomName.startsWith('p') ||
                roomName.startsWith('m'))) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName, must start with s, p, or m',
                };
                reject(validationError);
                return;
            }
            // Validate other conditions for sec, roomName, islevel, apiUserName
            if (!(sec.length === 32 &&
                roomName.length >= 8 &&
                islevel.length === 1 &&
                apiUserName.length >= 6 &&
                ['0', '1', '2'].includes(islevel))) {
                const validationError = {
                    success: false,
                    rtpCapabilities: null,
                    reason: 'Invalid roomName, islevel, apiUserName, or secret',
                };
                reject(validationError);
                return;
            }
            socket.emit('joinRoom', { roomName, islevel, member, sec, apiUserName }, async (data) => {
                try {
                    // Check if rtpCapabilities is null
                    if (data.rtpCapabilities === null) {
                        // Handle specific error cases
                        if (data.isBanned) {
                            throw new Error('User is banned.');
                        }
                        if (data.hostNotJoined) {
                            throw new Error('Host has not joined the room yet.');
                        }
                        // Resolve with the data received from the 'joinRoom' event
                        resolve(data);
                    }
                    else {
                        if (checkConnect) {
                            await this.checkMediasfuURL({
                                data,
                                member,
                                roomName,
                                islevel,
                                socket,
                                parameters,
                                joinMediaSFURoom,
                                localLink,
                            });
                        }
                        else {
                            // If mediasfuURL is present, extract and update the API token
                            if (data.mediasfuURL && data.mediasfuURL.length > 10) {
                                let secretCode;
                                const splitTexts = ['/meet/', '/chat/', '/broadcast/'];
                                const splitText = splitTexts.find((text) => data.mediasfuURL.includes(text)) ||
                                    '/meet/';
                                const urlParts = data.mediasfuURL.split(splitText);
                                secretCode = urlParts[1].split('/')[1];
                                parameters.updateApiToken(secretCode);
                            }
                        }
                        // Resolve with the data received from the 'joinRoom' event
                        resolve(data);
                    }
                }
                catch (error) {
                    // Handle errors during the joinRoom process
                    console.error('Error joining room:', error);
                    reject(error);
                }
            });
        });
    }
    /**
     * Checks the MediaSFU URL and processes necessary actions based on its validity.
     *
     * @param {Object} options - Contains:
     *   - `data`: Data received from the room join response.
     *   - `member`: User identifier.
     *   - `roomName`: Name of the room to join.
     *   - `islevel`: User's level indicator.
     *   - `socket`: Socket instance for communication.
     *   - `parameters`: Additional parameters for pre-join page actions.
     *   - `joinMediaSFURoom`: Function to join a room on MediaSFU.
     *   - `localLink`: Local link to use for Community Edition.
     */
    async checkMediasfuURL(options) {
        const { data, member, roomName, islevel, socket, parameters, localLink } = options;
        let joinMediaSFURoom = options.joinMediaSFURoom;
        if (data.mediasfuURL && data.mediasfuURL.length > 10) {
            let link;
            let secretCode;
            try {
                const splitTexts = ['/meet/', '/chat/', '/broadcast/'];
                const splitText = splitTexts.find((text) => data.mediasfuURL.includes(text)) || '/meet/';
                const urlParts = data.mediasfuURL.split(splitText);
                link = urlParts[0];
                secretCode = urlParts[1].split('/')[1];
            }
            catch {
                link = data.mediasfuURL;
                return;
            }
            await this.checkLimitsService.checkLimitsAndMakeRequest({
                apiUserName: roomName,
                apiToken: secretCode,
                link,
                apiKey: '',
                userName: member,
                parameters,
                validate: false,
            });
            return;
        }
        if ((!data.mediasfuURL || data.mediasfuURL.length < 10) &&
            islevel !== '2' &&
            data.allowRecord &&
            data.apiKey &&
            data.apiKey.length === 64 &&
            data.apiUserName &&
            data.apiUserName.length > 5 &&
            (roomName.startsWith('s') || roomName.startsWith('p'))) {
            const payload = {
                action: 'join',
                meetingID: roomName,
                userName: member,
            };
            if (!joinMediaSFURoom) {
                joinMediaSFURoom = this.joinRoomOnMediaSFU.joinRoomOnMediaSFU;
            }
            const response = await joinMediaSFURoom({
                payload,
                apiKey: data.apiKey,
                apiUserName: data.apiUserName,
                localLink,
            });
            if (response.success && response.data && 'roomName' in response.data) {
                try {
                    socket.emit('updateMediasfuURL', { eventID: roomName, mediasfuURL: response.data.publicURL }, () => { });
                }
                catch {
                    // Do nothing
                }
                await this.checkLimitsService.checkLimitsAndMakeRequest({
                    apiUserName: response.data.roomName,
                    apiToken: response.data.secret,
                    link: response.data.link,
                    userName: member,
                    parameters,
                    validate: false,
                });
                parameters.updateApiToken(response.data.secret);
            }
            return;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinLocalRoom, deps: [{ token: ValidateAlphanumeric }, { token: CheckLimitsAndMakeRequest }, { token: JoinRoomOnMediaSFU }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinLocalRoom, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: JoinLocalRoom, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: ValidateAlphanumeric }, { type: CheckLimitsAndMakeRequest }, { type: JoinRoomOnMediaSFU }] });

/**
 * Manages participant-related operations, including updates for participant lists, requests, co-host settings,
 * and other session details. This method filters out banned and suspended participants, reorders streams,
 * connects IPs, and updates the UI.
 *
 * @async
 * @param {AllMembersOptions} options - Parameters for managing all members.
 * @param {Participant[]} options.members - The array of participant objects.
 * @param {Request[]} options.requestss - The list of requests from participants.
 * @param {string} options.coHoste - The current co-host name.
 * @param {CoHostResponsibility[]} options.coHostRes - The responsibilities assigned to the co-host.
 * @param {AllMembersParameters} options.parameters - Additional parameters for member management and UI updates.
 * @param {ConsumeSocket[]} options.consume_sockets - Array of sockets for participant communication.
 * @param {string} options.apiUserName - API username for authentication.
 * @param {string} options.apiKey - API key for authentication.
 * @param {string} options.apiToken - API token for authentication.
 *
 * @returns {Promise<void>} A promise that resolves when all members have been processed and updates are complete.
 *
 * @example
 * ```typescript
 * const allMembersService = new AllMembers();
 * await allMembersService.allMembers({
 *   members: [{ name: 'John', isBanned: false, isSuspended: false, audioID: '123', videoID: '456' }],
 *   requestss: [{ id: '1', name: 'Jane', type: 'fa-microphone' }],
 *   coHoste: 'Jane',
 *   coHostRes: ['manage-chat'],
 *   parameters: {
 *     participantsAll: [],
 *     participants: [],
 *     dispActiveNames: ['John'],
 *     requestList: [],
 *     coHost: '',
 *     coHostResponsibility: [],
 *     lock_screen: false,
 *     firstAll: false,
 *     membersReceived: false,
 *     roomRecvIPs: [],
 *     deferScreenReceived: false,
 *     screenId: null,
 *     shareScreenStarted: false,
 *     meetingDisplayType: 'grid',
 *     hostFirstSwitch: false,
 *     waitingRoomList: [],
 *     islevel: '1',
 *     socket: socket,
 *     updateParticipantsAll: (participantsAll) => console.log(participantsAll),
 *     updateParticipants: (participants) => console.log(participants),
 *     updateRequestList: (requestList) => console.log(requestList),
 *     updateCoHost: (coHost) => console.log(coHost),
 *     updateCoHostResponsibility: (coHostRes) => console.log(coHostRes),
 *     updateFirstAll: (firstAll) => console.log(firstAll),
 *     updateMembersReceived: (membersReceived) => console.log(membersReceived),
 *     updateDeferScreenReceived: (deferScreenReceived) => console.log(deferScreenReceived),
 *     updateShareScreenStarted: (shareScreenStarted) => console.log(shareScreenStarted),
 *     updateHostFirstSwitch: (hostFirstSwitch) => console.log(hostFirstSwitch),
 *     updateConsume_sockets: (sockets) => console.log(sockets),
 *     updateRoomRecvIPs: (ips) => console.log(ips),
 *     updateIsLoadingModalVisible: (visible) => console.log(visible),
 *     updateTotalReqWait: (total) => console.log(total),
 *     onScreenChanges: (params) => console.log('onScreenChanges called with', params),
 *     connectIps: async (params) => [['socket1'], ['ip1']],
 *     connectLocalIps: async (params) => [['socket1'], ['ip1']],
 *     sleep: async ({ ms }) => new Promise((resolve) => setTimeout(resolve, ms)),
 *     reorderStreams: async (params) => console.log('reorderStreams called with', params),
 *   },
 *   consume_sockets: [{ socketId: 'abc123' }],
 *   apiUserName: 'testUser',
 *   apiKey: 'apiKeyExample',
 *   apiToken: 'apiTokenExample',
 * });
 * ```
 */
class AllMembers {
    /**
     * allMembers - A method for handling various tasks related to participant management and UI updates.
     * @param {Object} params - The parameters passed to the allMembers method.
     * @param {Array} params.members - The array of participant members.
     * @param {Array} params.requestss - The array of requests.
     * @param {boolean} params.coHoste - The co-host state.
     * @param {boolean} params.coHostRes - The co-host responsibility state.
     * @param {Object} params.parameters - The object containing parameters for the allMembers method.
     * @param {Array} params.consume_sockets - The array of consume sockets.
     * @param {string} params.apiUserName - The API username.
     * @param {string} params.apiKey - The API key.
     * @param {string} params.apiToken - The API token.
     * @returns {void} - No return value.
     */
    allMembers = async ({ members, requestss, coHoste, coHostRes, parameters, consume_sockets, apiUserName, apiKey, apiToken, }) => {
        let { participantsAll, participants, dispActiveNames, requestList, coHost, coHostResponsibility, lock_screen, firstAll, membersReceived, roomRecvIPs, deferScreenReceived, screenId, shareScreenStarted, meetingDisplayType, hostFirstSwitch, waitingRoomList, islevel, socket, updateParticipantsAll, updateParticipants, updateRequestList, updateCoHost, updateCoHostResponsibility, updateFirstAll, updateMembersReceived, updateDeferScreenReceived, updateShareScreenStarted, updateHostFirstSwitch, updateConsume_sockets, updateRoomRecvIPs, updateIsLoadingModalVisible, updateTotalReqWait, onScreenChanges, connectIps, connectLocalIps, reorderStreams, sleep, } = parameters;
        // Filter out the participant that isBanned == true or isSuspended == true
        participantsAll = members.map((participant) => ({
            isBanned: participant.isBanned,
            isSuspended: participant.isSuspended,
            name: participant.name,
            audioID: participant.audioID,
            videoID: participant.videoID,
        }));
        updateParticipantsAll(participantsAll);
        participants = members.filter((participant) => !participant.isBanned && !participant.isSuspended);
        updateParticipants(participants);
        // Check if dispActiveNames is not empty and contains the name of the participant that is not in the participants array
        if (dispActiveNames.length > 0) {
            let dispActiveNames_ = dispActiveNames.filter((name) => !participants.map((participant) => participant.name).includes(name));
            if (dispActiveNames_.length > 0) {
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
        // check to expect no roomRecvIPs for local instance
        let onLocal = false;
        if (roomRecvIPs.length === 1 && roomRecvIPs[0] === "none") {
            onLocal = true;
        }
        // Operations to update the UI; make sure we are connected to the server before updating the UI
        if (!membersReceived && !onLocal) {
            if (roomRecvIPs.length < 1) {
                // Keep checking every 0.01s
                let checkIPs = setInterval(async () => {
                    if (roomRecvIPs.length > 0) {
                        clearInterval(checkIPs);
                        if (deferScreenReceived && screenId != null) {
                            shareScreenStarted = true;
                            updateShareScreenStarted(shareScreenStarted);
                        }
                        const [sockets_, ips_] = await connectIps({
                            consume_sockets,
                            remIP: roomRecvIPs,
                            parameters,
                            apiUserName,
                            apiKey,
                            apiToken,
                        });
                        if (sockets_ && ips_) {
                            updateConsume_sockets(sockets_);
                            updateRoomRecvIPs(ips_);
                        }
                        membersReceived = true;
                        updateMembersReceived(membersReceived);
                        await sleep({ ms: 250 });
                        updateIsLoadingModalVisible(false);
                        deferScreenReceived = false;
                        updateDeferScreenReceived(deferScreenReceived);
                    }
                }, 10);
            }
            else {
                const [sockets_, ips_] = await connectIps({
                    consume_sockets,
                    remIP: roomRecvIPs,
                    parameters,
                    apiUserName,
                    apiKey,
                    apiToken,
                });
                if (sockets_ && ips_) {
                    updateConsume_sockets(sockets_);
                    updateRoomRecvIPs(ips_);
                }
                membersReceived = true;
                updateMembersReceived(membersReceived);
                if (deferScreenReceived && screenId != null) {
                    shareScreenStarted = true;
                    updateShareScreenStarted(shareScreenStarted);
                }
                await sleep({ ms: 250 });
                updateIsLoadingModalVisible(false);
                deferScreenReceived = false;
                updateDeferScreenReceived(deferScreenReceived);
            }
        }
        else {
            if (screenId != null) {
                let host = participants.find((participant) => participant.ScreenID == screenId && participant.ScreenOn == true);
                if (deferScreenReceived && screenId != null && host) {
                    shareScreenStarted = true;
                    updateShareScreenStarted(shareScreenStarted);
                }
            }
        }
        if (onLocal && !membersReceived) {
            if (connectLocalIps) {
                await connectLocalIps({ socket: socket, parameters });
            }
            await sleep({ ms: 100 });
            updateIsLoadingModalVisible(false);
        }
        // Return requests for only ids that are in the participants array and update the count badge
        requestList = requestss.filter((request) => participants.some((participant) => participant.id == request.id));
        updateRequestList(requestList);
        updateTotalReqWait(requestList.length + waitingRoomList.length);
        if (coHoste !== undefined && coHoste !== null) {
            coHost = coHoste;
        }
        updateCoHost(coHost);
        if (coHostRes) {
            coHostResponsibility = coHostRes;
        }
        updateCoHostResponsibility(coHostResponsibility);
        try {
            if (!lock_screen && !firstAll) {
                await onScreenChanges({ parameters });
                if (meetingDisplayType != 'all') {
                    firstAll = true;
                    updateFirstAll(firstAll);
                }
            }
            else {
                if (islevel == '2') {
                    if (!hostFirstSwitch) {
                        await onScreenChanges({ parameters });
                        hostFirstSwitch = true; // Get self display
                        updateHostFirstSwitch(hostFirstSwitch);
                    }
                }
            }
        }
        catch (error) {
            console.log('allMembers OnScreen', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AllMembers, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AllMembers, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AllMembers, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Manages participant settings and UI updates, including connecting IPs, reordering streams,
 * updating settings, and handling participant display based on various session parameters.
 *
 * @async
 * @param {AllMembersRestOptions} options - Parameters for managing members.
 * @param {Participant[]} options.members - The array of participant objects.
 * @param {Settings} options.settings - The session settings for audio, video, screenshare, and chat.
 * @param {string} [options.coHoste] - The current co-host name.
 * @param {CoHostResponsibility[]} [options.coHostRes] - The responsibilities assigned to the co-host.
 * @param {AllMembersRestParameters} options.parameters - Additional parameters for managing members and UI updates.
 * @param {ConsumeSocket[]} options.consume_sockets - Array of sockets for participant communication.
 * @param {string} options.apiUserName - API username for authentication.
 * @param {string} options.apiKey - API key for authentication.
 * @param {string} options.apiToken - API token for authentication.
 *
 * @returns {Promise<void>} A promise that resolves when updates and changes for members are completed.
 *
 * @example
 * ```typescript
 * const allMembersRestService = new AllMembersRest();
 * await allMembersRestService.allMembersRest({
 *   members: [{ name: 'John', isBanned: false, isSuspended: false, audioID: '123', videoID: '456' }],
 *   settings: ['enabled', 'HD', 'allowed', 'public'],
 *   coHoste: 'Jane',
 *   coHostRes: ['manage-chat'],
 *   parameters: {
 *     participantsAll: [],
 *     participants: [],
 *     dispActiveNames: ['John'],
 *     requestList: [],
 *     coHost: '',
 *     coHostResponsibility: [],
 *     lock_screen: false,
 *     firstAll: false,
 *     membersReceived: false,
 *     roomRecvIPs: [],
 *     deferScreenReceived: false,
 *     screenId: null,
 *     shareScreenStarted: false,
 *     meetingDisplayType: 'grid',
 *     audioSetting: '',
 *     videoSetting: '',
 *     screenshareSetting: '',
 *     chatSetting: '',
 *     socket: mySocket,
 *     updateParticipantsAll: (participantsAll) => console.log(participantsAll),
 *     updateParticipants: (participants) => console.log(participants),
 *     updateRequestList: (requestList) => console.log(requestList),
 *     updateCoHost: (coHost) => console.log(coHost),
 *     updateCoHostResponsibility: (coHostRes) => console.log(coHostRes),
 *     updateFirstAll: (firstAll) => console.log(firstAll),
 *     updateMembersReceived: (membersReceived) => console.log(membersReceived),
 *     updateDeferScreenReceived: (deferScreenReceived) => console.log(deferScreenReceived),
 *     updateShareScreenStarted: (shareScreenStarted) => console.log(shareScreenStarted),
 *     updateAudioSetting: (audioSetting) => console.log(audioSetting),
 *     updateVideoSetting: (videoSetting) => console.log(videoSetting),
 *     updateScreenshareSetting: (screenshareSetting) => console.log(screenshareSetting),
 *     updateChatSetting: (chatSetting) => console.log(chatSetting),
 *     updateConsume_sockets: (sockets) => console.log(sockets),
 *     updateRoomRecvIPs: (ips) => console.log(ips),
 *     updateIsLoadingModalVisible: (visible) => console.log(visible),
 *     onScreenChanges: (params) => console.log('onScreenChanges called with', params),
 *     connectIps: async (params) => [['socket1'], ['ip1']],
 *     connectLocalIps: async (params) => [['socket1'], ['ip1']],
 *     sleep: async ({ ms }) => new Promise((resolve) => setTimeout(resolve, ms)),
 *     reorderStreams: async (params) => console.log('reorderStreams called with', params),
 *   },
 *   consume_sockets: [{ socketId: 'abc123' }],
 *   apiUserName: 'testUser',
 *   apiKey: 'apiKeyExample',
 *   apiToken: 'apiTokenExample',
 * });
 * ```
 */
class AllMembersRest {
    /**
     * Handles various tasks related to participant management and UI updates.
     * @param {Object} params - The parameters passed to the allMembersRest method.
     * @param {Array} params.members - The array of participant members.
     * @param {Array} params.settings - The array of settings.
     * @param {boolean} params.coHoste - The co-host state.
     * @param {boolean} params.coHostRes - The co-host responsibility state.
     * @param {Object} params.parameters - The object containing parameters for the allMembersRest method.
     * @param {Array} params.consume_sockets - The array of consume sockets.
     * @param {string} params.apiUserName - The API username.
     * @param {string} params.apiKey - The API key.
     * @param {string} params.apiToken - The API token.
     * @returns {void} - No return value.
     */
    async allMembersRest({ members, settings, coHoste, coHostRes, parameters, consume_sockets, apiUserName, apiKey, apiToken, }) {
        let { participantsAll, participants, dispActiveNames, requestList, coHost, coHostResponsibility, lock_screen, firstAll, membersReceived, roomRecvIPs, deferScreenReceived, screenId, shareScreenStarted, meetingDisplayType, audioSetting, videoSetting, screenshareSetting, chatSetting, socket, updateParticipantsAll, updateParticipants, updateRequestList, updateCoHost, updateCoHostResponsibility, updateFirstAll, updateMembersReceived, updateDeferScreenReceived, updateShareScreenStarted, updateAudioSetting, updateVideoSetting, updateScreenshareSetting, updateChatSetting, updateConsume_sockets, updateRoomRecvIPs, updateIsLoadingModalVisible, onScreenChanges, connectIps, connectLocalIps, reorderStreams, sleep, } = parameters;
        // Filter out the participant that isBanned == true or isSuspended == true
        participantsAll = members.map((participant) => ({
            isBanned: participant.isBanned,
            isSuspended: participant.isSuspended,
            name: participant.name,
            audioID: participant.audioID,
            videoID: participant.videoID,
        }));
        updateParticipantsAll(participantsAll);
        participants = members.filter((participant) => !participant.isBanned && !participant.isSuspended);
        updateParticipants(participants);
        // Check if dispActiveNames is not empty and contains the name of the participant that is not in the participants array
        if (dispActiveNames.length > 0) {
            let dispActiveNames_ = dispActiveNames.filter((name) => !participants.map((participant) => participant.name).includes(name));
            if (dispActiveNames_.length > 0 && membersReceived) {
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
        // check to expect no roomRecvIPs for local instance
        let onLocal = false;
        if (roomRecvIPs.length === 1 && roomRecvIPs[0] === "none") {
            onLocal = true;
        }
        // Operations to update the UI; make sure we are connected to the server before updating the UI
        if (!membersReceived && !onLocal) {
            if (roomRecvIPs.length < 1) {
                // Keep checking every 0.01s
                let checkIPs = setInterval(async () => {
                    if (roomRecvIPs.length > 0) {
                        clearInterval(checkIPs);
                        if (deferScreenReceived && screenId != null) {
                            shareScreenStarted = true;
                            updateShareScreenStarted(shareScreenStarted);
                        }
                        const [sockets_, ips_] = await connectIps({
                            consume_sockets,
                            remIP: roomRecvIPs,
                            parameters,
                            apiUserName,
                            apiKey,
                            apiToken,
                        });
                        if (sockets_ && ips_) {
                            updateConsume_sockets(sockets_);
                            updateRoomRecvIPs(ips_);
                        }
                        membersReceived = true;
                        updateMembersReceived(membersReceived);
                        await sleep({ ms: 250 });
                        updateIsLoadingModalVisible(false);
                        deferScreenReceived = false;
                        updateDeferScreenReceived(deferScreenReceived);
                    }
                }, 10);
            }
            else {
                const [sockets_, ips_] = await connectIps({
                    consume_sockets,
                    remIP: roomRecvIPs,
                    parameters,
                    apiUserName,
                    apiKey,
                    apiToken,
                });
                if (sockets_ && ips_) {
                    updateConsume_sockets(sockets_);
                    updateRoomRecvIPs(ips_);
                }
                membersReceived = true;
                updateMembersReceived(membersReceived);
                if (deferScreenReceived && screenId != null) {
                    shareScreenStarted = true;
                    updateShareScreenStarted(shareScreenStarted);
                }
                await sleep({ ms: 250 });
                updateIsLoadingModalVisible(false);
                deferScreenReceived = false;
                updateDeferScreenReceived(deferScreenReceived);
            }
        }
        else {
            if (screenId != null) {
                let host = participants.find((participant) => participant.ScreenID == screenId && participant.ScreenOn == true);
                if (deferScreenReceived && screenId != null && host) {
                    shareScreenStarted = true;
                    updateShareScreenStarted(shareScreenStarted);
                }
            }
        }
        if (onLocal && !membersReceived) {
            if (connectLocalIps) {
                await connectLocalIps({ socket: socket, parameters });
            }
            await sleep({ ms: 100 });
            updateIsLoadingModalVisible(false);
        }
        // Return requests for only ids that are in the participants array and update the count badge
        let requests = requestList;
        requestList = requests.filter((request) => participants.some((participant) => participant.id == request.id));
        updateRequestList(requestList);
        if (coHoste !== undefined && coHoste !== null) {
            coHost = coHoste;
        }
        if (coHost !== undefined && coHost !== null) {
            updateCoHost(coHost);
        }
        if (coHostRes !== undefined && coHostRes !== null) {
            coHostResponsibility = coHostRes;
        }
        updateCoHostResponsibility(coHostResponsibility);
        try {
            if (!lock_screen && !firstAll) {
                await onScreenChanges({ parameters });
                if (meetingDisplayType != 'all') {
                    firstAll = true;
                    updateFirstAll(firstAll);
                }
            }
        }
        catch (error) {
            console.log('allMembersRest OnScreen', error);
        }
        try {
            if (membersReceived) {
                audioSetting = settings[0];
                videoSetting = settings[1];
                screenshareSetting = settings[2];
                chatSetting = settings[3];
                updateAudioSetting(audioSetting);
                updateVideoSetting(videoSetting);
                updateScreenshareSetting(screenshareSetting);
                updateChatSetting(chatSetting);
            }
        }
        catch (error) {
            console.log('allMembersRest Settings', error);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AllMembersRest, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AllMembersRest, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AllMembersRest, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle updating the list and count of waiting room participants.
 *
 * @class
 * @name AllWaitingRoomMembers
 * @description This service updates the waiting room participants list and the total count of participants waiting to join.
 *
 * @method
 * @async
 * @name allWaitingRoomMembers
 * @param {AllWaitingRoomMembersOptions} options - The options for updating the waiting room data.
 * @param {WaitingRoomParticipant[]} options.waitingParticipants - An array of participants currently in the waiting room.
 * @param {Function} options.updateWaitingRoomList - Function to update the waiting room participants list.
 * @param {Function} options.updateTotalReqWait - Function to update the total count of waiting room participants.
 *
 * @returns {Promise<void>} A promise that resolves when the updates to the waiting room data are complete.
 *
 * @example
 * ```typescript
 * const allWaitingRoomMembersService = new AllWaitingRoomMembers();
 * await allWaitingRoomMembersService.allWaitingRoomMembers({
 *   waitingParticipants: [{ name: 'John Doe', isApproved: false }],
 *   updateWaitingRoomList: (participants) => console.log(participants),
 *   updateTotalReqWait: (total) => console.log(`Total requests: ${total}`)
 * });
 * ```
 */
class AllWaitingRoomMembers {
    /**
     * Updates the waiting room participants list and the total count of waiting room participants.
     *
     * @param {Object} options - The options object.
     * @param {Array} options.waitingParticipants - An array of participants currently in the waiting room.
     * @param {Function} options.updateWaitingRoomList - A function to update the waiting room participants list.
     * @param {Function} options.updateTotalReqWait - A function to update the total count of waiting room participants.
     * @returns {Promise<void>} A promise that resolves when the updates are complete.
     */
    allWaitingRoomMembers = async ({ waitingParticipants, updateWaitingRoomList, updateTotalReqWait, }) => {
        // Calculate the total number of waiting room participants
        const totalReqs = waitingParticipants.length;
        // Update the waiting room participants list
        updateWaitingRoomList(waitingParticipants);
        // Update the total count of waiting room participants
        updateTotalReqWait(totalReqs);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AllWaitingRoomMembers, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AllWaitingRoomMembers, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AllWaitingRoomMembers, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle banning a participant from the session.
 *
 * @class
 * @name BanParticipant
 * @description This service provides a method to remove a participant from active lists and update the session's participant array, followed by reordering the streams.
 *
 * @method
 * banParticipant
 * @async
 * @param {BanParticipantOptions} options - The options for banning a participant.
 * @param {string} options.name - The name of the participant to be banned.
 * @param {BanParticipantParameters} options.parameters - Parameters required for the banning operation.
 * @param {string[]} options.parameters.activeNames - Array of active participant names.
 * @param {string[]} options.parameters.dispActiveNames - Array of display participant names.
 * @param {Participant[]} options.parameters.participants - Array of current session participants.
 * @param {Function} options.parameters.updateParticipants - Function to update the participants array.
 * @param {Function} options.parameters.reorderStreams - Function to reorder the streams after removing the participant.
 *
 * @returns {Promise<void>} A promise that resolves when the participant has been banned and streams reordered.
 *
 * @example
 * ```typescript
 * const banParticipantService = new BanParticipant();
 * await banParticipantService.banParticipant({
 *   name: 'John Doe',
 *   parameters: {
 *     activeNames: ['John Doe', 'Jane Smith'],
 *     dispActiveNames: ['John Doe', 'Jane Smith'],
 *     participants: [{ name: 'John Doe', isBanned: false }, { name: 'Jane Smith', isBanned: false }],
 *     updateParticipants: (updated) => console.log(updated),
 *     reorderStreams: async () => { }
 *   }
 * });
 * ```
 */
class BanParticipant {
    /**
     * Bans a participant from the session by removing them from the active and display names arrays,
     * updating the participants list, and reordering the streams.
     *
     * @param {BanParticipantOptions} options - The options for banning a participant.
     * @param {string} options.name - The name of the participant to be banned.
     * @param {Object} options.parameters - The parameters required for banning the participant.
     * @param {string[]} options.parameters.activeNames - The array of active participant names.
     * @param {string[]} options.parameters.dispActiveNames - The array of display participant names.
     * @param {Object[]} options.parameters.participants - The array of participant objects.
     * @param {Function} options.parameters.updateParticipants - The function to update the participants array.
     * @param {Function} options.parameters.reorderStreams - The function to reorder the streams.
     *
     * @returns {Promise<void>} A promise that resolves when the participant has been banned and streams reordered.
     */
    banParticipant = async ({ name, parameters }) => {
        const { activeNames, dispActiveNames, participants, updateParticipants, reorderStreams } = parameters;
        // Check if the participant is in the active or display names array
        if (activeNames.includes(name) || dispActiveNames.includes(name)) {
            // Filter out the banned participant from the participants array
            const updatedParticipants = participants.filter((participant) => participant.name !== name);
            // Update the participants array
            updateParticipants(updatedParticipants);
            // Reorder streams after participant removal
            await reorderStreams({ add: false, screenChanged: true, parameters });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: BanParticipant, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: BanParticipant, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: BanParticipant, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service for controlling participant media in a session, with options to manage audio, video, screenshare, and chat functionalities.
 *
 * @class
 * @name ControlMediaHost
 * @description This service provides the host with control over a participant's media (audio, video, screenshare, chat), with options to enable or disable these functionalities individually or all at once.
 *
 * @method
 * controlMediaHost
 * @async
 * @param {ControlMediaHostOptions} options - Options to specify which media type to control and provide necessary parameters.
 * @param {string} options.type - The media type to control ('audio', 'video', 'screenshare', 'chat', 'all').
 * @param {ControlMediaHostParameters} options.parameters - Additional parameters, functions, and media streams necessary to perform the media control operations.
 *
 * @returns {Promise<void>} - A promise that resolves when the media control operation is complete.
 *
 * @example
 * ```typescript
 * const controlMediaHostService = new ControlMediaHost();
 * await controlMediaHostService.controlMediaHost({
 *   type: 'audio',
 *   parameters: {
 *     updateAdminRestrictSetting: (value) => console.log(value),
 *     localStream: myLocalStream,
 *     updateLocalStream: (stream) => console.log(stream),
 *     updateAudioAlreadyOn: (value) => console.log(value),
 *     onScreenChanges: async () => { },
 *     disconnectSendTransportAudio: async () => { },
 *     getUpdatedAllParams: () => ({ }),
 *   }
 * });
 * ```
 *
 * @remarks
 * - This function handles the control of audio, video, screenshare, or chat for a participant based on the specified type.
 * - For `all` type, it sequentially controls each media type to ensure all are turned off.
 */
class ControlMediaHost {
    /**
     * Controls the media (audio, video, screenshare, chat) of a participant as a host.
     *
     * @param {object} options - The function parameters.
     * @param {string} options.type - The type of media to control ('audio', 'video', 'screenshare', 'chat', 'all').
     * @param {object} options.parameters - Additional parameters needed for the function.
     * @param {boolean} options.parameters.adminRestrictSetting - The setting to restrict host control.
     * @param {function} options.parameters.updateAdminRestrictSetting - Function to update the adminRestrictSetting.
     * @param {MediaStream} options.parameters.localStream - The local audio and video stream.
     * @param {function} options.parameters.updateLocalStream - Function to update the local audio and video stream.
     * @param {boolean} options.parameters.audioAlreadyOn - Indicates whether audio is currently on.
     * @param {function} options.parameters.updateAudioAlreadyOn - Function to update the audioAlreadyOn status.
     * @param {MediaStream} options.parameters.localStreamScreen - The local screenshare stream.
     * @param {function} options.parameters.updateLocalStreamScreen - Function to update the local screenshare stream.
     * @param {MediaStream} options.parameters.localStreamVideo - The local video stream.
     * @param {function} options.parameters.updateLocalStreamVideo - Function to update the local video stream.
     * @param {boolean} options.parameters.screenAlreadyOn - Indicates whether screenshare is currently on.
     * @param {function} options.parameters.updateScreenAlreadyOn - Function to update the screenAlreadyOn status.
     * @param {boolean} options.parameters.videoAlreadyOn - Indicates whether video is currently on.
     * @param {function} options.parameters.updateVideoAlreadyOn - Function to update the videoAlreadyOn status.
     * @param {boolean} options.parameters.chatAlreadyOn - Indicates whether chat is currently on.
     * @param {function} options.parameters.updateChatAlreadyOn - Function to update the chatAlreadyOn status.
     * @param {function} options.parameters.onScreenChanges - Function to handle changes in screen status.
     * @param {function} options.parameters.stopShareScreen - Function to stop sharing the screen.
     * @param {function} options.parameters.disconnectSendTransportVideo - Function to disconnect video send transport.
     * @param {function} options.parameters.disconnectSendTransportAudio - Function to disconnect audio send transport.
     * @param {function} options.parameters.disconnectSendTransportScreen - Function to disconnect screenshare send transport.
     */
    controlMediaHost = async ({ type, parameters }) => {
        let { updateAdminRestrictSetting, updateLocalStream, updateAudioAlreadyOn, updateLocalStreamScreen, updateLocalStreamVideo, updateScreenAlreadyOn, updateVideoAlreadyOn, updateChatAlreadyOn, onScreenChanges, stopShareScreen, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, } = parameters;
        let { localStream, localStreamScreen, localStreamVideo } = parameters.getUpdatedAllParams();
        try {
            updateAdminRestrictSetting(true);
            if (type === 'audio') {
                if (localStream) {
                    localStream.getAudioTracks()[0].enabled = false;
                }
                updateLocalStream(localStream);
                await disconnectSendTransportAudio({ parameters });
                updateAudioAlreadyOn(false);
            }
            else if (type === 'video') {
                try {
                    if (localStream) {
                        localStream.getVideoTracks()[0].enabled = false;
                    }
                    updateLocalStream(localStream);
                    await disconnectSendTransportVideo({ parameters });
                    await onScreenChanges({ changed: true, parameters });
                    updateVideoAlreadyOn(false);
                }
                catch {
                    /* handle error */
                }
                try {
                    if (localStreamVideo) {
                        localStreamVideo.getVideoTracks()[0].enabled = false;
                        updateLocalStreamVideo(localStreamVideo);
                        await disconnectSendTransportVideo({ parameters });
                        await onScreenChanges({ changed: true, parameters });
                        updateVideoAlreadyOn(false);
                    }
                }
                catch (error) {
                    onScreenChanges({ changed: true, parameters });
                }
            }
            else if (type === 'screenshare') {
                if (localStreamScreen) {
                    localStreamScreen.getVideoTracks()[0].enabled = false;
                }
                updateLocalStreamScreen(localStreamScreen);
                await disconnectSendTransportScreen({ parameters });
                await stopShareScreen({ parameters });
                updateScreenAlreadyOn(false);
            }
            else if (type === 'chat') {
                updateChatAlreadyOn(false);
            }
            else if (type === 'all') {
                try {
                    if (localStream) {
                        localStream.getAudioTracks()[0].enabled = false;
                    }
                    updateLocalStream(localStream);
                    await disconnectSendTransportAudio({ parameters });
                    updateAudioAlreadyOn(false);
                }
                catch {
                    /* handle error */
                }
                try {
                    if (localStreamScreen) {
                        localStreamScreen.getVideoTracks()[0].enabled = false;
                    }
                    updateLocalStreamScreen(localStreamScreen);
                    await disconnectSendTransportScreen({ parameters });
                    await stopShareScreen({ parameters });
                    updateScreenAlreadyOn(false);
                }
                catch {
                    /* handle error */
                }
                try {
                    if (localStream) {
                        localStream.getVideoTracks()[0].enabled = false;
                    }
                    updateLocalStream(localStream);
                    await disconnectSendTransportVideo({ parameters });
                    await onScreenChanges({ changed: true, parameters });
                    updateVideoAlreadyOn(false);
                }
                catch {
                    /* handle error */
                }
                try {
                    if (localStreamVideo) {
                        localStreamVideo.getVideoTracks()[0].enabled = false;
                    }
                    updateLocalStreamVideo(localStreamVideo);
                    await disconnectSendTransportVideo({ parameters });
                    await onScreenChanges({ changed: true, parameters });
                    updateVideoAlreadyOn(false);
                }
                catch (error) {
                    onScreenChanges({ changed: true, parameters });
                }
            }
        }
        catch (error) {
            console.error('Error in controlMediaHost:', error);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlMediaHost, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlMediaHost, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlMediaHost, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle disconnection logic, providing options to redirect or display an alert message.
 *
 * @class
 * @name Disconnect
 * @description This service manages user disconnection by either redirecting the user to a specified URL (for web platforms) or showing a custom alert message.
 *
 * @method
 * disconnect
 * @async
 * @param {DisconnectOptions} options - The options for handling disconnection.
 * @param {Function} options.showAlert - Function to display an alert message if a redirect is not needed.
 * @param {string} options.redirectURL - The URL to redirect to upon disconnection, if applicable.
 * @param {boolean} options.onWeb - Flag indicating if the application is running on the web.
 * @param {Function} [options.updateValidated] - Optional function to update validation state, primarily for native applications.
 * @returns {Promise<void>} A promise that resolves when the disconnection process completes.
 *
 * @example
 * const disconnectOptions = {
 *   showAlert: (alert) => console.log(alert.message),
 *   redirectURL: 'https://example.com/home',
 *   onWeb: true,
 *   updateValidated: (isValid) => console.log(`Validation updated: ${isValid}`)
 * };
 * disconnectService.disconnect(disconnectOptions);
 */
class Disconnect {
    /**
     * Handles the disconnection logic by either redirecting to a specified URL or showing an alert.
     *
     * @param {DisconnectOptions} options - The options for handling disconnection.
     * @param {Function} options.showAlert - Function to display an alert message.
     * @param {string} options.redirectURL - URL to redirect to if on the web.
     * @param {boolean} options.onWeb - Flag indicating if the operation is on the web.
     * @returns {Promise<void>} A promise that resolves when the disconnection handling is complete.
     */
    disconnect = async ({ showAlert, redirectURL, onWeb }) => {
        // Redirect to the specified URL on the web
        if (onWeb && redirectURL) {
            window.location.href = redirectURL;
        }
        else {
            // Display an alert and update the validated state
            if (showAlert) {
                showAlert({
                    message: 'You have been disconnected from the session.',
                    type: 'danger',
                    duration: 2000,
                });
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Disconnect, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Disconnect, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Disconnect, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle self-disconnection and banning of a user from a room.
 *
 * @class
 * @name DisconnectUserSelf
 * @description This service manages the disconnection of a user from a specified room and initiates a ban on the user.
 *
 * @method
 * disconnectUserSelf
 * @async
 * @param {DisconnectUserSelfOptions} options - The options required to disconnect the user.
 * @param {string} options.member - The identifier of the member to be disconnected.
 * @param {string} options.roomName - The name of the room from which the user will be disconnected.
 * @param {Socket} options.socket - The socket instance used to emit the disconnection and ban request.
 * @param {Socket} [options.localSocket] - The local socket instance used to emit the disconnection request.
 * @returns {Promise<void>} A promise that resolves when the disconnection request is sent to the server.
 *
 * @example
 * const disconnectUserSelfOptions = {
 *   member: 'user123',
 *   roomName: 'room456',
 *   socket: mySocketInstance
 *   localSocket: myLocalSocketInstance
 * };
 * await disconnectUserSelfService.disconnectUserSelf(disconnectUserSelfOptions);
 */
class DisconnectUserSelf {
    /**
     * Disconnects the user from the specified room and bans them.
     *
     * @param {DisconnectUserSelfOptions} options - The options for disconnecting the user.
     * @param {Object} options.member - The member object representing the user to disconnect.
     * @param {string} options.roomName - The name of the room from which the user will be disconnected.
     * @param {Socket} options.socket - The socket instance used to emit the disconnection request.
     * @param {Socket} [options.localSocket] - The local socket instance used to emit the disconnection request.
     * @returns {Promise<void>} A promise that resolves when the disconnection request has been emitted.
     */
    disconnectUserSelf = async ({ member, roomName, socket, localSocket, }) => {
        // Update that the user needs to be disconnected; this is initiated by the host when banning a user
        socket.emit('disconnectUser', { member, roomName, ban: true });
        try {
            if (localSocket && localSocket.id) {
                // Emit the disconnection request to the local socket, indicating that the user is being banned
                localSocket.emit("disconnectUser", {
                    member: member,
                    roomName: roomName,
                    ban: true,
                });
            }
        }
        catch {
            // Do nothing
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectUserSelf, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectUserSelf, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisconnectUserSelf, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle domain-related operations, such as retrieving and processing domains for connection.
 *
 * @class
 * @name GetDomains
 * @description This service provides a method to retrieve and process domains by connecting IPs that are not currently present in the room.
 *
 * @method
 * getDomains
 * @async
 * @param {GetDomainsOptions} options - The options for retrieving and connecting domains.
 * @param {string[]} options.domains - The list of domains to process.
 * @param {AltDomains} options.alt_domains - An object mapping primary domains to alternative domains.
 * @param {string} options.apiUserName - The API username for authentication.
 * @param {string} options.apiKey - The API key for authentication.
 * @param {string} options.apiToken - The API token for authentication.
 * @param {GetDomainsParameters} options.parameters - Additional parameters for the operation.
 * @param {string[]} options.parameters.roomRecvIPs - The list of IP addresses already connected in the room.
 * @param {Function} options.parameters.getUpdatedAllParams - A function to get updated parameters.
 * @param {Function} options.parameters.connectIps - A function to connect IPs that are not currently present.
 * @returns {Promise<void>} A promise that resolves when the operation is complete.
 * @throws {Error} Throws an error if the domain retrieval or connection fails.
 *
 * @example
 * const options = {
 *   domains: ['example.com', 'example.org'],
 *   alt_domains: { 'example.com': 'alt-example.com' },
 *   apiUserName: 'user123',
 *   apiKey: 'key123',
 *   apiToken: 'token123',
 *   parameters: {
 *     roomRecvIPs: ['192.168.1.1'],
 *     getUpdatedAllParams: () => updatedParameters,
 *     connectIps: connectIpsFunction,
 *   }
 * };
 * getDomainsService.getDomains(options);
 */
class GetDomains {
    getDomains = async ({ domains, alt_domains, apiUserName, apiKey, apiToken, parameters, }) => {
        const { roomRecvIPs, connectIps } = parameters;
        const ipsToConnect = [];
        let updatedConsumeSockets = parameters.getUpdatedAllParams().consume_sockets;
        try {
            for (const domain of domains) {
                const ipToCheck = alt_domains[domain] || domain;
                // Check if the IP is already in roomRecvIPs
                if (!roomRecvIPs.includes(ipToCheck)) {
                    ipsToConnect.push(ipToCheck);
                }
            }
            const [,] = await connectIps({
                consume_sockets: updatedConsumeSockets,
                remIP: ipsToConnect,
                parameters,
                apiUserName,
                apiKey,
                apiToken,
            });
            // Handle sockets_ and ips_ if needed
        }
        catch (error) {
            console.error('Error in getDomains: ', error);
            throw new Error('Failed to retrieve domains.');
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetDomains, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetDomains, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: GetDomains, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle host responses to participant requests, including updating states and showing relevant alerts.
 *
 * @class
 * @name HostRequestResponse
 * @description
 * Manages host responses to requests (e.g., microphone, video, screenshare, chat) by updating the state of actions and triggering alerts based on acceptance or rejection.
 *
 * @method
 * hostRequestResponse
 * @async
 *
 * @param {HostRequestResponseOptions} options - Options for handling the host request response:
 *   - `requestResponse` {RequestResponse}: The request response object.
 *   - `showAlert` {Function}: Optional alert function for notifications.
 *   - `requestList` {Request[]}: The current list of requests.
 *   - `updateRequestList` {Function}: Updates the request list.
 *   - `updateMicAction`, `updateVideoAction`, `updateScreenAction`, `updateChatAction` {Function}: Update functions for respective actions.
 *   - `updateAudioRequestState`, `updateVideoRequestState`, `updateScreenRequestState`, `updateChatRequestState` {Function}: Updates request states.
 *   - `updateAudioRequestTime`, `updateVideoRequestTime`, `updateScreenRequestTime`, `updateChatRequestTime` {Function}: Update functions for request timers.
 *   - `updateRequestIntervalSeconds` {number}: Interval in seconds to update request time.
 *
 * @returns {Promise<void>} Resolves once the request response has been handled.
 *
 * @example
 * const options = {
 *   requestResponse: { id: '1', type: 'fa-microphone', action: 'accepted' },
 *   showAlert: alert => console.log(alert.message),
 *   requestList: [{ id: '1', type: 'fa-microphone' }],
 *   updateRequestList: list => console.log(list),
 *   updateMicAction: state => console.log(state),
 *   updateAudioRequestState: state => console.log(state),
 *   updateAudioRequestTime: time => console.log(time),
 *   updateRequestIntervalSeconds: 30,
 * };
 * hostRequestResponseService.hostRequestResponse(options);
 */
class HostRequestResponse {
    hostRequestResponse = async ({ requestResponse, showAlert, requestList, updateRequestList, updateMicAction, updateVideoAction, updateScreenAction, updateChatAction, updateAudioRequestState, updateVideoRequestState, updateScreenRequestState, updateChatRequestState, updateAudioRequestTime, updateVideoRequestTime, updateScreenRequestTime, updateChatRequestTime, updateRequestIntervalSeconds, }) => {
        // Filter out the request from the list
        const filteredRequests = requestList.filter((request) => request.id !== requestResponse.id &&
            request.icon !== requestResponse.type &&
            request.name !== requestResponse.name &&
            request.username !== requestResponse.username);
        updateRequestList(filteredRequests);
        const requestType = requestResponse.type;
        // Handle accepted actions
        if (requestResponse.action === 'accepted') {
            switch (requestType) {
                case 'fa-microphone':
                    showAlert?.({
                        message: 'Unmute request was accepted; click the mic button again to begin.',
                        type: 'success',
                        duration: 10000,
                    });
                    updateMicAction(true);
                    updateAudioRequestState('accepted');
                    break;
                case 'fa-video':
                    showAlert?.({
                        message: 'Video request was accepted; click the video button again to begin.',
                        type: 'success',
                        duration: 10000,
                    });
                    updateVideoAction(true);
                    updateVideoRequestState('accepted');
                    break;
                case 'fa-desktop':
                    showAlert?.({
                        message: 'Screenshare request was accepted; click the screen button again to begin.',
                        type: 'success',
                        duration: 10000,
                    });
                    updateScreenAction(true);
                    updateScreenRequestState('accepted');
                    break;
                case 'fa-comments':
                    showAlert?.({
                        message: 'Chat request was accepted; click the chat button again to begin.',
                        type: 'success',
                        duration: 10000,
                    });
                    updateChatAction(true);
                    updateChatRequestState('accepted');
                    break;
            }
        }
        else {
            // Handle rejected actions
            let timerDate;
            switch (requestType) {
                case 'fa-microphone':
                    showAlert?.({
                        message: 'Unmute request was not accepted',
                        type: 'danger',
                        duration: 10000,
                    });
                    updateAudioRequestState('rejected');
                    timerDate = new Date();
                    timerDate.setSeconds(timerDate.getSeconds() + updateRequestIntervalSeconds);
                    updateAudioRequestTime(timerDate.getTime());
                    break;
                case 'fa-video':
                    showAlert?.({
                        message: 'Video request was not accepted',
                        type: 'danger',
                        duration: 10000,
                    });
                    updateVideoRequestState('rejected');
                    timerDate = new Date();
                    timerDate.setSeconds(timerDate.getSeconds() + updateRequestIntervalSeconds);
                    updateVideoRequestTime(timerDate.getTime());
                    break;
                case 'fa-desktop':
                    showAlert?.({
                        message: 'Screenshare request was not accepted',
                        type: 'danger',
                        duration: 10000,
                    });
                    updateScreenRequestState('rejected');
                    timerDate = new Date();
                    timerDate.setSeconds(timerDate.getSeconds() + updateRequestIntervalSeconds);
                    updateScreenRequestTime(timerDate.getTime());
                    break;
                case 'fa-comments':
                    showAlert?.({
                        message: 'Chat request was not accepted',
                        type: 'danger',
                        duration: 10000,
                    });
                    updateChatRequestState('rejected');
                    timerDate = new Date();
                    timerDate.setSeconds(timerDate.getSeconds() + updateRequestIntervalSeconds);
                    updateChatRequestTime(timerDate.getTime());
                    break;
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HostRequestResponse, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HostRequestResponse, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: HostRequestResponse, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle the end of a meeting, including showing an alert and redirecting the user.
 *
 * @class
 * @name MeetingEnded
 * @description
 * This service provides a method to display a notification when a meeting ends and redirects the user to a specified URL or handles other post-meeting actions.
 *
 * @method
 * meetingEnded
 *
 * @param {MeetingEndedOptions} options - Options for handling the meeting end:
 *   - `showAlert` {Function}: Optional function to display an alert message.
 *   - `redirectURL` {string}: URL to redirect to after the meeting ends.
 *   - `onWeb` {boolean}: Specifies if the application is running on the web.
 *   - `eventType` {string}: Specifies the type of event ending the meeting.
 *
 * @returns {Promise<void>} Completes meeting end handling by displaying an alert and performing a redirect.
 *
 * @example
 * const options = {
 *   showAlert: (options) => console.log(options.message),
 *   redirectURL: 'https://example.com/home',
 *   onWeb: true,
 *   eventType: 'webinar',
 * };
 * meetingEndedService.meetingEnded(options);
 * // Displays alert and redirects to specified URL
 */
class MeetingEnded {
    /**
     * Handles the end of a meeting by showing an alert and redirecting the user.
     *
     * @param {MeetingEndedOptions} options - The options for handling the meeting end.
     * @param {Function} options.showAlert - Function to show an alert message.
     * @param {string} options.redirectURL - URL to redirect to after the meeting ends.
     * @param {boolean} options.onWeb - Flag indicating if the application is running on the web.
     * @param {string} options.eventType - Type of the event that triggered the meeting end.
     *
     * @returns {Promise<void>} A promise that resolves when the meeting end handling is complete.
     */
    meetingEnded = async ({ showAlert, redirectURL, onWeb, eventType, }) => {
        // Show an alert that the meeting has ended and wait for 2 seconds before redirecting to the home page
        if (eventType !== 'chat') {
            showAlert?.({
                message: 'The event has ended. You will be redirected to the home page in 2 seconds.',
                type: 'danger',
                duration: 2000,
            });
        }
        if (onWeb && redirectURL) {
            setTimeout(() => {
                window.location.href = redirectURL;
            }, 2000);
        }
        else {
            // setTimeout(() => {
            //   updateValidated(false);
            // }, 2000);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingEnded, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingEnded, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingEnded, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle the "still there?" check in a meeting by showing a confirmation modal.
 *
 * @class
 * @name MeetingStillThere
 * @description
 * This service provides a method to display a "still there?" confirmation modal to check if participants are still active in the meeting.
 *
 * @method
 * meetingStillThere
 *
 * @param {MeetingStillThereOptions} options - Options for managing the modal visibility:
 *   - `updateIsConfirmHereModalVisible` {Function}: Function to set the visibility of the "still there?" confirmation modal.
 *
 * @returns {Promise<void>} Updates modal visibility when checking if the user is still present.
 *
 * @example
 * const options = {
 *   updateIsConfirmHereModalVisible: (isVisible) => console.log(`Modal visibility: ${isVisible}`),
 * };
 * meetingStillThereService.meetingStillThere(options);
 * // Output: Sets and logs modal visibility to true
 */
class MeetingStillThere {
    /**
     * Handles the "still there?" meeting check by updating the visibility of the confirmation modal.
     *
     * @param {Object} options - The options for the meeting still there check.
     * @param {Function} options.updateIsConfirmHereModalVisible - Function to update the visibility of the "still there?" modal.
     * @returns {Promise<void>} A promise that resolves when the modal visibility is updated.
     */
    meetingStillThere = ({ updateIsConfirmHereModalVisible }) => {
        // Update the visibility of the "still there?" modal
        updateIsConfirmHereModalVisible(true);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingStillThere, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingStillThere, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingStillThere, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle the remaining time for a meeting and display an alert if necessary.
 *
 * @class
 * @name MeetingTimeRemaining
 * @description
 * Manages the display of a time remaining alert for meetings, except when the event type is 'chat'.
 *
 * @method
 * meetingTimeRemaining
 *
 * @param {MeetingTimeRemainingOptions} options - Options for managing meeting time:
 *   - `timeRemaining` {number}: The remaining time in milliseconds.
 *   - `showAlert` {Function}: Optional function to display an alert message.
 *   - `eventType` {EventType}: The type of the event (e.g., "meeting", "broadcast", "chat").
 *
 * @returns {Promise<void>} Displays an alert with the remaining time for the meeting.
 *
 * @example
 * const options = {
 *   timeRemaining: 180000, // 3 minutes in milliseconds
 *   showAlert: (options) => console.log(options.message),
 *   eventType: 'meeting'
 * };
 * await meetingTimeRemainingService.meetingTimeRemaining(options);
 * // Output: Displays "The event will end in 3:00 minutes."
 */
class MeetingTimeRemaining {
    /**
     * Handles the remaining time for a meeting and shows an alert if the event type is not 'chat'.
     *
     * @param {Object} options - The options for the meeting time remaining.
     * @param {number} options.timeRemaining - The remaining time in milliseconds.
     * @param {Function} options.showAlert - The function to show an alert message.
     * @param {string} options.eventType - The type of the event.
     * @returns {Promise<void>} A promise that resolves when the operation is complete.
     */
    meetingTimeRemaining = async ({ timeRemaining, showAlert, eventType, }) => {
        // Convert time from milliseconds to readable format of minutes and seconds
        const minutes = Math.floor(timeRemaining / 60000);
        const seconds = Math.floor((timeRemaining % 60000) / 1000);
        const timeRemainingString = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        // Show alert with time remaining if eventType is not 'chat'
        if (eventType !== 'chat') {
            showAlert?.({
                message: `The event will end in ${timeRemainingString} minutes.`,
                type: 'success',
                duration: 3000,
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingTimeRemaining, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingTimeRemaining, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingTimeRemaining, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle participant requests in an event's waiting room.
 *
 * @class
 * @name ParticipantRequested
 * @description
 * Manages participant requests by adding new requests to the list and updating the total count of requests and waiting room participants.
 *
 * @method
 * participantRequested
 *
 * @param {ParticipantRequestedOptions} options - Contains request information and update functions:
 *   - `userRequest` {Request}: The new request from a participant.
 *   - `requestList` {Request[]}: The current list of requests.
 *   - `waitingRoomList` {WaitingRoomParticipant[]}: The list of participants in the waiting room.
 *   - `updateTotalReqWait` {Function}: Function to update the total count of requests and waiting room participants.
 *   - `updateRequestList` {Function}: Function to update the request list.
 *
 * @returns {Promise<void>} Updates the request list and total request count.
 *
 * @example
 * const options = {
 *   userRequest: { id: '123', name: 'John Doe', icon: 'fa-user', username: 'johndoe' },
 *   requestList: existingRequests,
 *   waitingRoomList: waitingParticipants,
 *   updateTotalReqWait: (count) => console.log(`Total requests: ${count}`),
 *   updateRequestList: (list) => console.log('Updated request list', list)
 * };
 * await participantRequestedService.participantRequested(options);
 * // Adds "John Doe" to request list and updates the total count.
 */
class ParticipantRequested {
    /**
     * Handles a participant's request by adding it to the request list and updating the total count of requests and waiting room participants.
     *
     * @param {ParticipantRequestedOptions} options - The options for handling the participant's request.
     * @param {UserRequest} options.userRequest - The user request to be added to the request list.
     * @param {UserRequest[]} options.requestList - The current list of user requests.
     * @param {UserRequest[]} options.waitingRoomList - The current list of participants in the waiting room.
     * @param {Function} options.updateTotalReqWait - Function to update the total count of requests and waiting room participants.
     * @param {Function} options.updateRequestList - Function to update the request list.
     * @returns {Promise<void>} A promise that resolves when the participant's request has been handled.
     */
    participantRequested = async ({ userRequest, requestList, waitingRoomList, updateTotalReqWait, updateRequestList, }) => {
        // Add the user request to the request list
        const updatedRequestList = [...requestList, userRequest];
        updateRequestList(updatedRequestList);
        // Update the total count of requests and waiting room participants
        const reqCount = updatedRequestList.length + waitingRoomList.length;
        updateTotalReqWait(reqCount);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantRequested, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantRequested, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantRequested, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle actions when a person joins an event.
 *
 * @class
 * @name PersonJoined
 * @description
 * Displays a notification when a person joins the event, using the `showAlert` function if provided.
 *
 * @method
 * personJoined
 *
 * @param {PersonJoinedOptions} options - Contains information about the person and alert display function:
 *   - `name` {string}: The name of the person who joined.
 *   - `showAlert` {Function} (optional): Function to display a notification when the person joins.
 *
 * @returns {void} Executes alert display through `showAlert` if defined.
 *
 * @example
 * const options = {
 *   name: 'Alice',
 *   showAlert: ({ message, type, duration }) => console.log(message)
 * };
 * personJoinedService.personJoined(options);
 * // Logs: "Alice joined the event."
 */
class PersonJoined {
    /**
     * Handles the event when a person joins.
     *
     * @param {PersonJoinedOptions} options - The options for the person joined event.
     * @param {string} options.name - The name of the person who joined.
     * @param {Function} options.showAlert - A function to display an alert/notification.
     * @returns {Promise<void>} A promise that resolves when the alert has been shown.
     */
    personJoined = ({ name, showAlert }) => {
        // Display an alert/notification about the person joining the event
        showAlert?.({
            message: `${name} joined the event.`,
            type: 'success',
            duration: 3000,
        });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PersonJoined, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PersonJoined, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PersonJoined, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle closing a media producer and associated UI and state updates.
 *
 * @class
 * @name ProducerMediaClosed
 * @description
 * Manages the closure of a media producer by identifying associated consumer transports, closing necessary resources,
 * and updating the user interface to reflect the change. For screen sharing, it resets the shared state and adjusts the main view.
 *
 * @method
 * producerMediaClosed
 *
 * @param {ProducerMediaClosedOptions} options - Contains details on the producer and parameters for state updates:
 *   - `producerId` {string}: ID of the producer to close.
 *   - `kind` {string}: The type of media to close (e.g., "screenshare" or "audio").
 *   - `parameters` {ProducerMediaClosedParameters}: Settings and update functions to manage the closure process.
 *      - `consumerTransports` {Transport[]}: List of active transports for consumers.
 *      - `updateConsumerTransports` {Function}: Updates the list of active consumer transports.
 *      - `hostLabel` {string}: Label of the host to revert to if screen sharing ends.
 *      - `shared` {boolean}: Indicates whether a screen is currently shared.
 *      - `updateShared` {Function}: Updates the shared screen state.
 *      - `updateShareScreenStarted` {Function}: Marks the start or end of screen sharing.
 *      - `updateScreenId` {Function}: Clears the screen ID when screen sharing ends.
 *      - `updateShareEnded` {Function}: Marks the end of screen sharing.
 *      - `closeAndResize` {Function}: Adjusts the screen display upon closing the media.
 *      - `prepopulateUserMedia` {Function}: Loads default media after screen sharing ends.
 *      - `reorderStreams` {Function}: Reorders streams to optimize layout when media is closed.
 *
 * @returns {Promise<void>} Resolves when all updates are complete and the producer closure is handled.
 *
 * @example
 * const options = {
 *   producerId: '12345',
 *   kind: 'screenshare',
 *   parameters: {
 *     consumerTransports: [...],
 *     updateConsumerTransports: (transports) => { ... },
 *     hostLabel: 'Host',
 *     shared: true,
 *     updateShared: (shared) => { ... },
 *     updateShareScreenStarted: (started) => { ... },
 *     updateScreenId: (id) => { ... },
 *     updateShareEnded: (ended) => { ... },
 *     closeAndResize: ({ producerId, kind, parameters }) => { ... },
 *     prepopulateUserMedia: ({ name, parameters }) => { ... },
 *     reorderStreams: ({ add, screenChanged, parameters }) => { ... },
 *   }
 * };
 *
 * producerMediaClosedService.producerMediaClosed(options)
 *   .then(() => console.log('Producer closed successfully'))
 *   .catch(error => console.error('Error:', error));
 *
 * @remarks
 * This service performs the following steps:
 * 1. Retrieves updated parameters.
 * 2. Finds and closes the transport associated with the producer.
 * 3. Updates the list of consumer transports.
 * 4. Adjusts the display layout with `closeAndResize`.
 * 5. If the producer is a screen share, resets shared state and reloads default media.
 */
class ProducerMediaClosed {
    /**
     * Handles the closure of a media producer.
     *
     * @param {ProducerMediaClosedOptions} options - The options for closing the media producer.
     * @param {string} options.producerId - The ID of the producer to close.
     * @param {string} options.kind - The kind of media (e.g., "screenshare" or "screen").
     * @param {Parameters} options.parameters - The parameters object containing various methods and properties.
     *
     * @returns {Promise<void>} - A promise that resolves when the producer has been closed and necessary updates are made.
     *
     * @remarks
     * This function performs the following steps:
     * 1. Retrieves updated parameters.
     * 2. Finds the transport associated with the producer to close.
     * 3. Closes the consumer transport and consumer if found.
     * 4. Updates the consumer transports list.
     * 5. Calls `closeAndResize` with the necessary parameters.
     * 6. If the producer kind is "screenshare" or "screen", updates shared state and calls various update methods.
     */
    producerMediaClosed = async ({ producerId, kind, parameters, }) => {
        parameters = parameters.getUpdatedAllParams();
        const { consumerTransports, updateConsumerTransports, hostLabel, shared, updateShared, updateShareScreenStarted, updateScreenId, updateShareEnded, closeAndResize, prepopulateUserMedia, reorderStreams, } = parameters;
        const producerToClose = consumerTransports.find((transportData) => transportData.producerId === producerId);
        if (producerToClose) {
            try {
                await producerToClose['consumerTransport'].close();
            }
            catch (error) {
                console.error('Error closing consumer transport:', error);
            }
            try {
                producerToClose.consumer.close();
            }
            catch (error) {
                console.error('Error closing consumer:', error);
            }
            const updatedConsumerTransports = consumerTransports.filter((transportData) => transportData.producerId !== producerId);
            updateConsumerTransports(updatedConsumerTransports);
            await closeAndResize({ producerId, kind, parameters });
        }
        else {
            if (kind === 'screenshare' || kind === 'screen') {
                if (shared) {
                    updateShared(false);
                }
                else {
                    updateShareScreenStarted(false);
                    updateScreenId('');
                }
                updateShareEnded(true);
                await prepopulateUserMedia({ name: hostLabel, parameters });
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerMediaClosed, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerMediaClosed, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerMediaClosed, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle the paused state of media for a producer.
 *
 * @class
 * @name ProducerMediaPaused
 * @description
 * Handles the actions required when media is paused for a specified producer, including UI updates, participant state handling, and managing meeting display optimizations.
 *
 * @method
 * producerMediaPaused
 *
 * @param {ProducerMediaPausedOptions} options - Options to specify the producer and event details:
 *   - `producerId` {string}: The ID of the paused producer.
 *   - `kind` {string}: The type of media paused (e.g., "audio", "video").
 *   - `name` {string}: Name of the producer whose media is paused.
 *   - `parameters` {ProducerMediaPausedParameters}: Configuration and state parameters for the meeting.
 *      - `activeSounds` {string[]}: Active audio streams currently displayed.
 *      - `meetingDisplayType` {string}: Current meeting layout type (e.g., "media", "video").
 *      - `meetingVideoOptimized` {boolean}: Indicates if video is optimized.
 *      - `participants` {Participant[]}: List of all meeting participants.
 *      - `oldSoundIds` {string[]}: List of previously active audio stream IDs.
 *      - `shared` {boolean}: Indicates if the screen is currently shared.
 *      - `shareScreenStarted` {boolean}: Indicates if screen sharing has started.
 *      - `updateMainWindow` {boolean}: Specifies if the main display window should update.
 *      - `hostLabel` {string}: The label representing the host participant.
 *      - `islevel` {string}: The access level of the participant.
 *      - `updateActiveSounds` {Function}: Updates the list of active audio streams.
 *      - `updateUpdateMainWindow` {Function}: Updates the status of the main display window.
 *      - `reorderStreams` {Function}: Reorders media streams for optimized display.
 *      - `prepopulateUserMedia` {Function}: Preloads user media based on display needs.
 *      - `reUpdateInter` {Function}: Refreshes participant interactions on the UI.
 *
 * @returns {Promise<void>} Resolves when media pause handling is complete.
 *
 * @example
 * const options = {
 *   producerId: '12345',
 *   kind: 'audio',
 *   name: 'Participant A',
 *   parameters: {
 *     activeSounds: ['Participant B'],
 *     meetingDisplayType: 'video',
 *     meetingVideoOptimized: false,
 *     participants: [...],
 *     oldSoundIds: ['Participant A'],
 *     shared: false,
 *     shareScreenStarted: false,
 *     updateMainWindow: true,
 *     hostLabel: 'Host',
 *     islevel: '1',
 *     updateActiveSounds: (sounds) => { ... },
 *     updateUpdateMainWindow: (status) => { ... },
 *     reorderStreams: ({ add, screenChanged, parameters }) => { ... },
 *     prepopulateUserMedia: ({ name, parameters }) => { ... },
 *     reUpdateInter: ({ name, add, force, parameters }) => { ... }
 *   }
 * };
 *
 * producerMediaPausedService.producerMediaPaused(options)
 *   .then(() => console.log('Media pause handled'))
 *   .catch(error => console.error('Error:', error));
 */
class ProducerMediaPaused {
    /**
     * Handles the event when media is paused for a producer.
     *
     * @param {ProducerMediaPausedOptions} options - The options for the producer media paused event.
     * @param {string} options.producerId - The ID of the producer.
     * @param {string} options.kind - The kind of media (e.g., "audio", "video").
     * @param {string} options.name - The name of the producer.
     * @param {Parameters} options.parameters - The parameters for the event.
     *
     * @returns {Promise<void>} A promise that resolves when the media paused handling is complete.
     *
     * @description
     * This function handles the event when media is paused for a producer. It performs the following tasks:
     * - Updates the parameters.
     * - Iterates through participants and updates the UI based on their muted status and other conditions.
     * - Handles meeting display type and optimizes the UI accordingly.
     * - Manages audio media by updating the relevant participant's state.
     */
    producerMediaPaused = async ({ producerId, kind, name, parameters, }) => {
        parameters = parameters.getUpdatedAllParams();
        let { activeSounds, meetingDisplayType, meetingVideoOptimized, participants, oldSoundIds, shared, shareScreenStarted, updateMainWindow, hostLabel, islevel, updateActiveSounds, updateUpdateMainWindow, reorderStreams, prepopulateUserMedia, reUpdateInter, } = parameters;
        await Promise.all(participants.map(async (participant) => {
            if (participant.muted) {
                try {
                    if (participant.islevel == '2' &&
                        !participant.videoID &&
                        !shared &&
                        !shareScreenStarted &&
                        islevel != '2') {
                        updateMainWindow = true;
                        updateUpdateMainWindow(updateMainWindow);
                        await prepopulateUserMedia({ name: hostLabel, parameters });
                        updateMainWindow = false;
                        updateUpdateMainWindow(updateMainWindow);
                    }
                }
                catch {
                    /* handle error */
                }
                if (shareScreenStarted || shared) {
                    if (activeSounds.includes(participant.name)) {
                        activeSounds = activeSounds.filter((audioStream) => audioStream != participant.name);
                        updateActiveSounds(activeSounds);
                    }
                    await reUpdateInter({ name: participant.name, add: false, force: true, parameters });
                }
            }
        }));
        let checker = false;
        if (meetingDisplayType == 'media' ||
            (meetingDisplayType == 'video' && !meetingVideoOptimized)) {
            const participant = participants.find((obj) => obj.name == name);
            checker = !!participant?.videoID;
            if (!checker && !shareScreenStarted && !shared) {
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
        if (kind == 'audio') {
            try {
                const participant = participants.find((obj) => obj.audioID == producerId) ||
                    participants.find((obj) => obj.name == name);
                if (participant &&
                    ((participant.name && oldSoundIds.includes(participant.name)) ||
                        (name && oldSoundIds.includes(name)))) {
                    reUpdateInter({
                        name: participant.name ?? '',
                        add: false,
                        force: true,
                        parameters,
                    });
                }
            }
            catch {
                /* handle error */
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerMediaPaused, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerMediaPaused, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerMediaPaused, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to handle resuming media for a specific participant in a meeting.
 *
 * @class
 * @name ProducerMediaResumed
 * @description Resumes media (audio only) for a participant and updates the meeting display based on the meeting layout and participant status.
 *
 * @method
 * producerMediaResumed
 *
 * @param {ProducerMediaResumedOptions} options - Options to control media resumption:
 *   - `name` {string}: Name of the participant whose media is to be resumed.
 *   - `parameters` {ProducerMediaResumedParameters}: Meeting and participant-specific configurations.
 *      - `meetingDisplayType` {string}: Type of meeting display (e.g., "media").
 *      - `participants` {Participant[]}: List of participants in the meeting.
 *      - `shared` {boolean}: Indicates if the screen is currently shared.
 *      - `shareScreenStarted` {boolean}: Indicates if screen sharing has started.
 *      - `mainScreenFilled` {boolean}: Indicates if the main screen is filled.
 *      - `hostLabel` {string}: Label or name of the host.
 *      - `updateUpdateMainWindow` {Function}: Function to update the main window display.
 *      - `reorderStreams` {Function}: Function to manage stream ordering when display changes.
 *      - `prepopulateUserMedia` {Function}: Function to preload user media for the main screen.
 *
 * @returns {Promise<void>} Resolves when media for the specified participant has resumed.
 *
 * @example
 * const options = {
 *   name: 'Participant A',
 *   parameters: {
 *     meetingDisplayType: 'media',
 *     participants: [...],
 *     shared: false,
 *     shareScreenStarted: false,
 *     mainScreenFilled: false,
 *     hostLabel: 'Host',
 *     updateUpdateMainWindow: (updateMainWindow) => { ... },
 *     reorderStreams: ({ add, screenChanged, parameters }) => { ... },
 *     prepopulateUserMedia: ({ name, parameters }) => { ... }
 *   }
 * };
 *
 * producerMediaResumedService.producerMediaResumed(options)
 *   .then(() => console.log('Media resumed'))
 *   .catch(error => console.error('Error:', error));
 */
class ProducerMediaResumed {
    /**
     * Resumes media for a specific participant in a meeting.
     *
     * @param {ProducerMediaResumedOptions} options - The options for resuming media.
     * @param {string} options.name - The name of the participant whose media is to be resumed.
     * @param {Object} options.parameters - The parameters related to the meeting and participants.
     * @param {string} options.parameters.meetingDisplayType - The type of meeting display.
     * @param {Array} options.parameters.participants - The list of participants in the meeting.
     * @param {boolean} options.parameters.shared - Indicates if the screen is being shared.
     * @param {boolean} options.parameters.shareScreenStarted - Indicates if screen sharing has started.
     * @param {boolean} options.parameters.mainScreenFilled - Indicates if the main screen is filled.
     * @param {string} options.parameters.hostLabel - The label of the host.
     * @param {Function} options.parameters.updateUpdateMainWindow - Function to update the main window.
     * @param {Function} options.parameters.reorderStreams - Function to reorder the streams.
     * @param {Function} options.parameters.prepopulateUserMedia - Function to prepopulate user media.
     *
     * @returns {Promise<void>} A promise that resolves when the media has been resumed.
     */
    producerMediaResumed = async ({ name, parameters, }) => {
        parameters = parameters.getUpdatedAllParams();
        let { meetingDisplayType, participants, shared, shareScreenStarted, updateMainWindow, mainScreenFilled, hostLabel, updateUpdateMainWindow, reorderStreams, prepopulateUserMedia, } = parameters;
        // Update to resume the audio only of a participant
        // name is the name of the participant
        // kind is the kind of media (always audio)
        // Operations to update UI to optimize interest levels
        const participant = participants.find((obj) => obj.name == name);
        if (!mainScreenFilled && participant?.islevel == '2') {
            updateMainWindow = true;
            updateUpdateMainWindow(updateMainWindow);
            await prepopulateUserMedia({ name: hostLabel, parameters });
            updateMainWindow = false;
            updateUpdateMainWindow(updateMainWindow);
        }
        let checker;
        if (meetingDisplayType == 'media') {
            checker = participant?.videoID != null && participant.videoID !== '';
            if (!checker && !(shareScreenStarted || shared)) {
                await reorderStreams({ add: false, screenChanged: true, parameters });
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerMediaResumed, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerMediaResumed, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ProducerMediaResumed, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to re-initiate recording in a specific room, considering administrative restrictions.
 *
 * @class
 * @name ReInitiateRecording
 * @description Attempts to re-initiate recording if administrative restrictions permit.
 *
 * @method
 * reInitiateRecording
 *
 * @param {ReInitiateRecordingOptions} options - Configuration options for re-initiating recording:
 *   - `roomName` {string}: The name of the room to start recording in.
 *   - `member` {string}: The name of the member initiating the recording.
 *   - `socket` {Socket}: The socket instance for server communication.
 *   - `adminRestrictSetting` {boolean}: Flag indicating if the admin restrict setting is active, preventing re-initiation.
 *
 * @returns {Promise<void>} Resolves if recording is successfully re-initiated; otherwise, it throws an error if re-initiation fails.
 *
 * @example
 * const options = {
 *   roomName: 'Room101',
 *   member: 'Alice',
 *   socket: mySocketInstance,
 *   adminRestrictSetting: false
 * };
 * reInitiateRecordingService.reInitiateRecording(options)
 *   .then(() => console.log('Recording re-initiated'))
 *   .catch(error => console.error(error.message));
 */
class ReInitiateRecording {
    /**
     * Re-initiates recording based on specific conditions.
     * @async
     * @function
     * @param {ReInitiateRecordingOptions} options - The options for re-initiating recording.
     * @param {string} options.roomName - The name of the room to re-initiate recording.
     * @param {string} options.member - The member re-initiating the recording.
     * @param {Socket} options.socket - The socket instance for communication.
     * @param {boolean} options.adminRestrictSetting - Indicates whether the admin restrict setting is enabled.
     * @returns {Promise<void>} A promise that resolves when the recording is re-initiated.
     */
    reInitiateRecording = async ({ roomName, member, socket, adminRestrictSetting, }) => {
        if (!adminRestrictSetting) {
            await new Promise((resolve, reject) => {
                socket.emit('startRecordIng', { roomName, member }, ({ success }) => {
                    if (success) {
                        resolve();
                    }
                    else {
                        reject(new Error('Failed to re-initiate recording.'));
                    }
                });
            });
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReInitiateRecording, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReInitiateRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReInitiateRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service for receiving and processing messages, including handling group and direct messages, filtering banned senders, and updating message states.
 *
 * @class
 * @name ReceiveMessage
 * @description Manages incoming messages, appends them to the existing messages array, filters out banned senders, and updates message badge visibility as needed.
 *
 * @method
 * receiveMessage
 *
 * @param {ReceiveMessageOptions} options - Options for handling a received message:
 *   - `message` {Message}: The new message object to process.
 *   - `messages` {Message[]}: The current list of messages.
 *   - `participantsAll` {Participant[]}: All participants in the chat.
 *   - `member` {string}: The current member's name.
 *   - `eventType` {EventType}: The type of event (e.g., "broadcast" or "chat").
 *   - `islevel` {string}: The level of the current user.
 *   - `coHost` {string}: The name of the co-host.
 *   - `updateMessages` {Function}: A function to update the messages list.
 *   - `updateShowMessagesBadge` {Function}: A function to toggle the visibility of the message badge.
 *
 * @returns {Promise<void>} Resolves when the message processing and updates are complete.
 *
 * @example
 * const message = { sender: 'Alice', receivers: ['Bob'], message: 'Hello!', timestamp: Date.now(), group: false };
 * const options = {
 *   message,
 *   messages: [],
 *   participantsAll: [{ name: 'Alice' }, { name: 'Bob' }],
 *   member: 'Bob',
 *   eventType: 'chat',
 *   islevel: '1',
 *   coHost: 'Charlie',
 *   updateMessages: (updatedMessages) => console.log('Messages updated:', updatedMessages),
 *   updateShowMessagesBadge: (show) => console.log('Show badge:', show)
 * };
 * receiveMessageService.receiveMessage(options);
 */
class ReceiveMessage {
    /**
     * Receives and processes a message, updating the messages array and handling
     * various message types and events.
     *
     * @param {ReceiveMessageOptions} options - The options for receiving the message.
     * @param {Object} options.message - The message object containing sender, receivers, content, timestamp, and group.
     * @param {Function} options.getUpdatedAllParams - Function to get updated parameters.
     * @param {Array} options.messages - Array of current messages.
     * @param {Array} options.participantsAll - Array of all participants.
     * @param {string} options.member - The current member.
     * @param {string} options.eventType - The type of event (e.g., "broadcast", "chat").
     * @param {string} options.islevel - The level of the current member.
     * @param {string} options.coHost - The co-host of the event.
     * @param {Function} options.updateMessages - Function to update the messages array.
     * @param {Function} options.updateShowMessagesBadge - Function to update the visibility of the messages badge.
     *
     * @returns {Promise<void>} A promise that resolves when the message has been processed.
     */
    receiveMessage = async ({ message, messages, participantsAll, member, eventType, islevel, coHost, updateMessages, updateShowMessagesBadge, }) => {
        // Add the received message to the messages array
        const { sender, receivers, message: content, timestamp, group } = message;
        let oldMessages = messages;
        messages = [...messages, { sender, receivers, message: content, timestamp, group }];
        // Filter out messages with banned senders in the participants array
        if (eventType !== 'broadcast' && eventType !== 'chat') {
            messages = messages.filter((message) => participantsAll.some((participant) => participant.name === message.sender && !participant.isBanned));
        }
        else {
            messages = messages.filter((message) => {
                const participant = participantsAll.find((participant) => participant.name === message.sender);
                return !participant || !participant.isBanned;
            });
        }
        updateMessages(messages);
        // Separate group and direct messages
        const oldGroupMessages = oldMessages.filter((message) => message.group);
        const oldDirectMessages = oldMessages.filter((message) => !message.group);
        // Render and update counts for group messages
        const groupMessages = messages.filter((message) => message.group);
        if (eventType !== 'broadcast' && eventType !== 'chat') {
            // Check if oldGroupMessages length is different from groupMessages length
            if (oldGroupMessages.length !== groupMessages.length) {
                // Identify new messages
                const newGroupMessages = groupMessages.filter((message) => !oldGroupMessages.some((oldMessage) => oldMessage.timestamp === message.timestamp));
                // Check if newGroupMessages sender is the member or receivers include the member
                const newGroupMessages2 = newGroupMessages.filter((message) => message.sender === member || message.receivers.includes(member));
                // Check if member is the sender of any newGroupMessages
                const newGroupMessages3 = newGroupMessages2.filter((message) => message.sender === member);
                // Check if member is the receiver of any newGroupMessages
                if (newGroupMessages.length > 0 && newGroupMessages.length !== newGroupMessages3.length) {
                    updateShowMessagesBadge(true);
                }
            }
        }
        // Render and update counts for direct messages
        const directMessages = messages.filter((message) => !message.group);
        if (eventType !== 'broadcast' && eventType !== 'chat') {
            // Check if oldDirectMessages length is different from directMessages length
            if (oldDirectMessages.length !== directMessages.length) {
                // Identify new direct messages
                const newDirectMessages = directMessages.filter((message) => !oldDirectMessages.some((oldMessage) => oldMessage.timestamp === message.timestamp));
                // Check if newDirectMessages sender is the member or receivers include the member
                const newDirectMessages2 = newDirectMessages.filter((message) => message.sender === member || message.receivers.includes(member));
                // Check if member is the sender of any newDirectMessages
                const newDirectMessages3 = newDirectMessages2.filter((message) => message.sender === member);
                if ((newDirectMessages.length > 0 && newDirectMessages2.length > 0) ||
                    (newDirectMessages.length > 0 && islevel === '2') ||
                    coHost === member) {
                    if (islevel === '2' || coHost === member) {
                        if (newDirectMessages.length !== newDirectMessages3.length) {
                            updateShowMessagesBadge(true);
                        }
                    }
                    else {
                        if (newDirectMessages2.length > 0 &&
                            newDirectMessages.length !== newDirectMessages3.length) {
                            updateShowMessagesBadge(true);
                        }
                    }
                }
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReceiveMessage, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReceiveMessage, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReceiveMessage, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * SoundPlayer service for playing a sound from a provided URL.
 *
 * @class SoundPlayer
 * @implements {OnInit}
 *
 * @example
 * ```typescript
 * const soundUrl = 'https://example.com/sound.mp3';
 * const soundPlayer = new SoundPlayer();
 * soundPlayer.playSound({ soundUrl });
 * ```
 *
 * ### Details
 * - **soundUrl**: URL to the sound file that will be played.
 * - **playSound**: Initiates the audio playback.
 * - **ngOnInit**: Automatically triggers sound playback if `soundUrl` is set.
 *
 * @param {SoundPlayerOptions} options - Contains the URL of the sound to play.
 * @returns {void} - No return; sound is played asynchronously.
 */
/**
 * Plays a sound from a given URL.
 * @class
 * @implements {OnInit}
 * @param {string} soundUrl - The URL of the sound to play.
 * @returns {void}
 * @example
 * const soundUrl = 'https://example.com/sound.mp3';
 * const soundPlayer = new SoundPlayer();
 * soundPlayer.playSound({ soundUrl });
 */
class SoundPlayer {
    soundUrl;
    ngOnInit() {
        const shouldPlaySound = true;
        if (shouldPlaySound) {
            if (this.soundUrl) {
                this.playSound({ soundUrl: this.soundUrl });
            }
            else {
                console.log('Sound URL is not defined');
            }
        }
    }
    playSound({ soundUrl }) {
        const audio = new Audio(soundUrl);
        audio.play().catch((error) => console.error('Error playing sound:', error));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SoundPlayer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SoundPlayer, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SoundPlayer, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], propDecorators: { soundUrl: [{
                type: Input
            }] } });

/**
 * Service for handling recording notices, managing recording states, and updating related parameters.
 *
 * @class
 * @name RecordingNotice
 * @description Provides methods to handle the recording notice state, manage user recording parameters, and play appropriate sounds for different states.
 *
 * @method
 * RecordingNotice
 *
 * @param {RecordingNoticeOptions} options - The options for recording notices:
 *   - `state` {string}: The current recording state (`pause`, `stop`, etc.).
 *   - `userRecordingParam` {UserRecordingParams | null}: The user recording parameters (if available).
 *   - `pauseCount` {number}: The number of pauses in the recording.
 *   - `timeDone` {number}: The total recording time completed.
 *   - `parameters` {RecordingNoticeParameters}: Functions and properties to update recording details.
 *     - `updateRecordElapsedTime` {Function}: Updates elapsed recording time.
 *     - `updateShowRecordButtons` {Function}: Toggles record button visibility.
 *     - `updateRecordState` {Function}: Sets the record state (e.g., `red`, `green`, `yellow`).
 *     - `updatePauseRecordCount` {Function}: Sets the pause record count.
 *     - `updateRecordStarted`, `updateRecordPaused`, `updateCanLaunchRecord`, etc.: Other update functions to control recording settings and states.
 *
 * @returns {Promise<void>} Resolves when the recording state and parameters have been updated.
 *
 * @example
 * const options = {
 *   state: 'pause',
 *   userRecordingParam: { mainSpecs: { mediaOptions: 'audio', ... } },
 *   pauseCount: 3,
 *   timeDone: 3600,
 *   parameters: {
 *     updateRecordStarted: (started) => console.log(`Recording started: ${started}`),
 *     updateRecordPaused: (paused) => console.log(`Recording paused: ${paused}`),
 *     // Define other update functions similarly
 *   }
 * };
 * await recordingNoticeService.RecordingNotice(options);
 */
class RecordingNotice {
    SoundPlayerService;
    constructor(SoundPlayerService) {
        this.SoundPlayerService = SoundPlayerService;
    }
    /**
     * Handles the recording notice state and updates various recording parameters accordingly.
     *
     * @param {Object} options - The options object.
     * @param {string} options.state - The current state of the recording (e.g., "pause", "stop").
     * @param {Object} options.userRecordingParam - The user recording parameters.
     * @param {number} options.pauseCount - The count of pauses during the recording.
     * @param {number} options.timeDone - The elapsed time of the recording.
     * @param {Object} options.parameters - The parameters object containing various update functions and state variables.
     * @param {string} options.parameters.islevel - The level of the recording.
     * @param {Object} options.parameters.userRecordingParams - The user recording parameters.
     * @param {number} options.parameters.pauseRecordCount - The count of pauses during the recording.
     * @param {number} options.parameters.recordElapsedTime - The elapsed time of the recording.
     * @param {number} options.parameters.recordStartTime - The start time of the recording.
     * @param {boolean} options.parameters.recordStarted - Indicates if the recording has started.
     * @param {boolean} options.parameters.recordPaused - Indicates if the recording is paused.
     * @param {boolean} options.parameters.canLaunchRecord - Indicates if the recording can be launched.
     * @param {boolean} options.parameters.stopLaunchRecord - Indicates if the recording launch should be stopped.
     * @param {boolean} options.parameters.recordStopped - Indicates if the recording is stopped.
     * @param {boolean} options.parameters.isTimerRunning - Indicates if the timer is running.
     * @param {boolean} options.parameters.canPauseResume - Indicates if the recording can be paused or resumed.
     * @param {string} options.parameters.eventType - The type of event triggering the recording notice.
     * @param {Function} options.parameters.updateRecordingProgressTime - Function to update the recording progress time.
     * @param {Function} options.parameters.updateShowRecordButtons - Function to update the visibility of record buttons.
     * @param {Function} options.parameters.updateUserRecordingParams - Function to update user recording parameters.
     * @param {Function} options.parameters.updateRecordingMediaOptions - Function to update recording media options.
     * @param {Function} options.parameters.updateRecordingAudioOptions - Function to update recording audio options.
     * @param {Function} options.parameters.updateRecordingVideoOptions - Function to update recording video options.
     * @param {Function} options.parameters.updateRecordingVideoType - Function to update recording video type.
     * @param {Function} options.parameters.updateRecordingVideoOptimized - Function to update recording video optimization.
     * @param {Function} options.parameters.updateRecordingDisplayType - Function to update recording display type.
     * @param {Function} options.parameters.updateRecordingAddHLS - Function to update HLS addition in recording.
     * @param {Function} options.parameters.updateRecordingNameTags - Function to update recording name tags.
     * @param {Function} options.parameters.updateRecordingBackgroundColor - Function to update recording background color.
     * @param {Function} options.parameters.updateRecordingNameTagsColor - Function to update recording name tags color.
     * @param {Function} options.parameters.updateRecordingOrientationVideo - Function to update recording orientation video.
     * @param {Function} options.parameters.updateRecordingAddText - Function to update recording text addition.
     * @param {Function} options.parameters.updateRecordingCustomText - Function to update custom text in recording.
     * @param {Function} options.parameters.updateRecordingCustomTextPosition - Function to update custom text position.
     * @param {Function} options.parameters.updateRecordingCustomTextColor - Function to update custom text color.
     * @param {Function} options.parameters.updatePauseRecordCount - Function to update pause record count.
     * @param {Function} options.parameters.updateRecordElapsedTime - Function to update record elapsed time.
     * @param {Function} options.parameters.updateRecordStartTime - Function to update record start time.
     * @param {Function} options.parameters.updateRecordStarted - Function to update record started status.
     * @param {Function} options.parameters.updateRecordPaused - Function to update record paused status.
     * @param {Function} options.parameters.updateCanLaunchRecord - Function to update can launch record status.
     * @param {Function} options.parameters.updateStopLaunchRecord - Function to update stop launch record status.
     * @param {Function} options.parameters.updateRecordStopped - Function to update record stopped status.
     * @param {Function} options.parameters.updateIsTimerRunning - Function to update timer running status.
     * @param {Function} options.parameters.updateCanPauseResume - Function to update can pause/resume status.
     * @param {Function} options.parameters.updateRecordState - Function to update the record state.
     *
     * @returns {Promise<void>} A promise that resolves when the recording notice handling is complete.
     *
     * @throws {Error} Throws an error if handling the recording state and status fails.
     */
    RecordingNotice = async ({ state, userRecordingParam, pauseCount, timeDone, parameters, }) => {
        let { islevel, userRecordingParams, pauseRecordCount, recordElapsedTime, recordStartTime, recordStarted, recordPaused, canLaunchRecord, stopLaunchRecord, recordStopped, isTimerRunning, canPauseResume, eventType, updateRecordingProgressTime, updateShowRecordButtons, updateUserRecordingParams, updateRecordingMediaOptions, updateRecordingAudioOptions, updateRecordingVideoOptions, updateRecordingVideoType, updateRecordingVideoOptimized, updateRecordingDisplayType, updateRecordingAddHLS, updateRecordingNameTags, updateRecordingBackgroundColor, updateRecordingNameTagsColor, updateRecordingOrientationVideo, updateRecordingAddText, updateRecordingCustomText, updateRecordingCustomTextPosition, updateRecordingCustomTextColor, updatePauseRecordCount, updateRecordElapsedTime, updateRecordStartTime, updateRecordStarted, updateRecordPaused, updateCanLaunchRecord, updateStopLaunchRecord, updateRecordStopped, updateIsTimerRunning, updateCanPauseResume, updateRecordState, } = parameters;
        try {
            if (islevel !== '2') {
                if (state === 'pause') {
                    updateRecordStarted(true);
                    updateRecordPaused(true);
                    updateRecordState('yellow');
                    eventType !== 'broadcast' &&
                        this.SoundPlayerService.playSound({
                            soundUrl: 'https://www.mediasfu.com/sounds/record-paused.mp3',
                        });
                }
                else if (state === 'stop') {
                    updateRecordStarted(true);
                    updateRecordStopped(true);
                    updateRecordState('green');
                    eventType !== 'broadcast' &&
                        this.SoundPlayerService.playSound({
                            soundUrl: 'https://www.mediasfu.com/sounds/record-stopped.mp3',
                        });
                }
                else {
                    updateRecordState('red');
                    updateRecordStarted(true);
                    updateRecordPaused(false);
                    eventType !== 'broadcast' &&
                        this.SoundPlayerService.playSound({
                            soundUrl: 'https://www.mediasfu.com/sounds/record-progress.mp3',
                        });
                }
            }
            else {
                if (state === 'pause') {
                    updateRecordState('yellow');
                    if (userRecordingParam) {
                        userRecordingParams.mainSpecs = userRecordingParam.mainSpecs;
                        userRecordingParams.dispSpecs = userRecordingParam.dispSpecs;
                        userRecordingParams.textSpecs = userRecordingParam.textSpecs;
                        updateUserRecordingParams(userRecordingParams);
                        updateRecordingMediaOptions(userRecordingParams.mainSpecs.mediaOptions);
                        updateRecordingAudioOptions(userRecordingParams.mainSpecs.audioOptions);
                        updateRecordingVideoOptions(userRecordingParams.mainSpecs.videoOptions);
                        updateRecordingVideoType(userRecordingParams.mainSpecs.videoType);
                        updateRecordingVideoOptimized(userRecordingParams.mainSpecs.videoOptimized);
                        updateRecordingDisplayType(userRecordingParams.mainSpecs.recordingDisplayType);
                        updateRecordingAddHLS(userRecordingParams.mainSpecs.addHLS);
                        updateRecordingNameTags(userRecordingParams.dispSpecs.nameTags);
                        updateRecordingBackgroundColor(userRecordingParams.dispSpecs.backgroundColor);
                        updateRecordingNameTagsColor(userRecordingParams.dispSpecs.nameTagsColor);
                        updateRecordingOrientationVideo(userRecordingParams.dispSpecs.orientationVideo);
                        updateRecordingAddText(userRecordingParams.textSpecs?.addText ?? false);
                        updateRecordingCustomText(userRecordingParams.textSpecs?.customText ?? '');
                        updateRecordingCustomTextPosition(userRecordingParams.textSpecs?.customTextPosition ?? '');
                        updateRecordingCustomTextColor(userRecordingParams.textSpecs?.customTextColor ?? '');
                        pauseRecordCount = pauseCount;
                        updatePauseRecordCount(pauseRecordCount);
                        recordElapsedTime = timeDone;
                        recordElapsedTime = Math.floor(recordElapsedTime / 1000);
                        recordStartTime = Math.floor(Date.now() / 1000) - recordElapsedTime;
                        updateRecordStartTime(recordStartTime);
                        updateRecordElapsedTime(recordElapsedTime);
                        recordStarted = true;
                        recordPaused = true;
                        canLaunchRecord = false;
                        recordStopped = false;
                        updateRecordStarted(recordStarted);
                        updateRecordPaused(recordPaused);
                        updateCanLaunchRecord(canLaunchRecord);
                        updateRecordStopped(recordStopped);
                        updateShowRecordButtons(true);
                        isTimerRunning = false;
                        canPauseResume = true;
                        updateIsTimerRunning(isTimerRunning);
                        updateCanPauseResume(canPauseResume);
                        const formattedTime = this.formatElapsedTime(recordElapsedTime);
                        updateRecordingProgressTime(formattedTime);
                    }
                    this.SoundPlayerService.playSound({
                        soundUrl: 'https://www.mediasfu.com/sounds/record-paused.mp3',
                    });
                }
                else if (state === 'stop') {
                    updateRecordStarted(true);
                    updateRecordStopped(true);
                    canLaunchRecord = false;
                    stopLaunchRecord = true;
                    updateRecordStarted(recordStarted);
                    updateRecordStopped(recordStopped);
                    updateCanLaunchRecord(canLaunchRecord);
                    updateStopLaunchRecord(stopLaunchRecord);
                    updateShowRecordButtons(false);
                    updateRecordState('green');
                    this.SoundPlayerService.playSound({
                        soundUrl: 'https://www.mediasfu.com/sounds/record-stopped.mp3',
                    });
                }
                else {
                    updateRecordState('red');
                    updateRecordStarted(true);
                    updateRecordPaused(false);
                    this.SoundPlayerService.playSound({
                        soundUrl: 'https://www.mediasfu.com/sounds/record-progress.mp3',
                    });
                }
            }
        }
        catch (error) {
            console.log('Error in RecordingNotice: ', error);
            // throw new Error("Failed to handle recording state and status.");
        }
    };
    formatElapsedTime = (recordElapsedTime) => {
        const hours = Math.floor(recordElapsedTime / 3600);
        const minutes = Math.floor((recordElapsedTime % 3600) / 60);
        const seconds = recordElapsedTime % 60;
        return `${this.padNumber(hours)}:${this.padNumber(minutes)}:${this.padNumber(seconds)}`;
    };
    padNumber = (number) => {
        return number.toString().padStart(2, '0');
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordingNotice, deps: [{ token: SoundPlayer }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordingNotice, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordingNotice, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: SoundPlayer }] });

/**
 * Service to update recording parameters for a room.
 *
 * @class
 * @name RoomRecordParams
 * @description Updates multiple recording parameters at once, using provided functions for each specific setting.
 *
 * @method
 * roomRecordParams
 *
 * @param {RoomRecordParamsOptions} options - The options for updating recording parameters:
 *   - `recordParams` {RecordParams}: The new recording parameters to apply.
 *   - `parameters` {RoomRecordParamsParameters}: The update functions for each recording parameter.
 *     - `updateRecordingAudioPausesLimit` {Function}: Updates the audio pauses limit.
 *     - `updateRecordingAudioPausesCount` {Function}: Updates the audio pauses count.
 *     - `updateRecordingAudioSupport` {Function}: Updates the audio support status.
 *     - `updateRecordingAudioPeopleLimit` {Function}: Updates the audio people limit.
 *     - `updateRecordingAudioParticipantsTimeLimit` {Function}: Updates the audio participants time limit.
 *     - `updateRecordingVideoPausesCount` {Function}: Updates the video pauses count.
 *     - `updateRecordingVideoPausesLimit` {Function}: Updates the video pauses limit.
 *     - `updateRecordingVideoSupport` {Function}: Updates the video support status.
 *     - `updateRecordingVideoPeopleLimit` {Function}: Updates the video people limit.
 *     - `updateRecordingVideoParticipantsTimeLimit` {Function}: Updates the video participants time limit.
 *     - `updateRecordingAllParticipantsSupport` {Function}: Updates support for all participants.
 *     - `updateRecordingVideoParticipantsSupport` {Function}: Updates video participants support.
 *     - `updateRecordingAllParticipantsFullRoomSupport` {Function}: Updates full room support for all participants.
 *     - `updateRecordingVideoParticipantsFullRoomSupport` {Function}: Updates full room support for video participants.
 *     - `updateRecordingPreferredOrientation` {Function}: Updates the preferred recording orientation.
 *     - `updateRecordingSupportForOtherOrientation` {Function}: Updates support for other orientations.
 *     - `updateRecordingMultiFormatsSupport` {Function}: Updates support for multiple formats.
 *
 * @returns {Promise<void>} A promise that resolves after all parameters are updated.
 *
 * @example
 * const recordParams = {
 *   recordingAudioPausesLimit: 5,
 *   recordingAudioPausesCount: 2,
 *   recordingAudioSupport: true,
 *   recordingAudioPeopleLimit: 10,
 *   recordingAudioParticipantsTimeLimit: 60,
 *   recordingVideoPausesCount: 1,
 *   recordingVideoPausesLimit: 3,
 *   recordingVideoSupport: true,
 *   recordingVideoPeopleLimit: 8,
 *   recordingVideoParticipantsTimeLimit: 90,
 *   recordingAllParticipantsSupport: true,
 *   recordingVideoParticipantsSupport: true,
 *   recordingAllParticipantsFullRoomSupport: false,
 *   recordingVideoParticipantsFullRoomSupport: true,
 *   recordingPreferredOrientation: 'landscape',
 *   recordingSupportForOtherOrientation: false,
 *   recordingMultiFormatsSupport: true,
 * };
 *
 * const parameters = {
 *   updateRecordingAudioPausesLimit: (value) => console.log(`Audio pauses limit: ${value}`),
 *   updateRecordingAudioPausesCount: (value) => console.log(`Audio pauses count: ${value}`),
 *   // Define other update functions similarly
 * };
 *
 * roomRecordParamsService.roomRecordParams({ recordParams, parameters });
 */
class RoomRecordParams {
    /**
     * Updates various recording parameters based on the provided `recordParams`.
     *
     * @param {Object} params - The parameters object.
     * @param {RecordParams} params.recordParams - The recording parameters to update.
     * @param {Parameters} params.parameters - The functions to update each recording parameter.
     * @param {Function} params.parameters.updateRecordingAudioPausesLimit - Function to update the audio pauses limit.
     * @param {Function} params.parameters.updateRecordingAudioPausesCount - Function to update the audio pauses count.
     * @param {Function} params.parameters.updateRecordingAudioSupport - Function to update the audio support.
     * @param {Function} params.parameters.updateRecordingAudioPeopleLimit - Function to update the audio people limit.
     * @param {Function} params.parameters.updateRecordingAudioParticipantsTimeLimit - Function to update the audio participants time limit.
     * @param {Function} params.parameters.updateRecordingVideoPausesCount - Function to update the video pauses count.
     * @param {Function} params.parameters.updateRecordingVideoPausesLimit - Function to update the video pauses limit.
     * @param {Function} params.parameters.updateRecordingVideoSupport - Function to update the video support.
     * @param {Function} params.parameters.updateRecordingVideoPeopleLimit - Function to update the video people limit.
     * @param {Function} params.parameters.updateRecordingVideoParticipantsTimeLimit - Function to update the video participants time limit.
     * @param {Function} params.parameters.updateRecordingAllParticipantsSupport - Function to update the all participants support.
     * @param {Function} params.parameters.updateRecordingVideoParticipantsSupport - Function to update the video participants support.
     * @param {Function} params.parameters.updateRecordingAllParticipantsFullRoomSupport - Function to update the all participants full room support.
     * @param {Function} params.parameters.updateRecordingVideoParticipantsFullRoomSupport - Function to update the video participants full room support.
     * @param {Function} params.parameters.updateRecordingPreferredOrientation - Function to update the preferred orientation.
     * @param {Function} params.parameters.updateRecordingSupportForOtherOrientation - Function to update the support for other orientation.
     * @param {Function} params.parameters.updateRecordingMultiFormatsSupport - Function to update the multi-formats support.
     * @returns {Promise<void>} A promise that resolves when all parameters have been updated.
     */
    roomRecordParams = ({ recordParams, parameters }) => {
        let { updateRecordingAudioPausesLimit, updateRecordingAudioPausesCount, updateRecordingAudioSupport, updateRecordingAudioPeopleLimit, updateRecordingAudioParticipantsTimeLimit, updateRecordingVideoPausesCount, updateRecordingVideoPausesLimit, updateRecordingVideoSupport, updateRecordingVideoPeopleLimit, updateRecordingVideoParticipantsTimeLimit, updateRecordingAllParticipantsSupport, updateRecordingVideoParticipantsSupport, updateRecordingAllParticipantsFullRoomSupport, updateRecordingVideoParticipantsFullRoomSupport, updateRecordingPreferredOrientation, updateRecordingSupportForOtherOrientation, updateRecordingMultiFormatsSupport, } = parameters;
        // Update each recording parameter based on the provided recordParams
        updateRecordingAudioPausesLimit(recordParams.recordingAudioPausesLimit);
        updateRecordingAudioPausesCount(recordParams.recordingAudioPausesCount);
        updateRecordingAudioSupport(recordParams.recordingAudioSupport);
        updateRecordingAudioPeopleLimit(recordParams.recordingAudioPeopleLimit);
        updateRecordingAudioParticipantsTimeLimit(recordParams.recordingAudioParticipantsTimeLimit);
        updateRecordingVideoPausesCount(recordParams.recordingVideoPausesCount);
        updateRecordingVideoPausesLimit(recordParams.recordingVideoPausesLimit);
        updateRecordingVideoSupport(recordParams.recordingVideoSupport);
        updateRecordingVideoPeopleLimit(recordParams.recordingVideoPeopleLimit);
        updateRecordingVideoParticipantsTimeLimit(recordParams.recordingVideoParticipantsTimeLimit);
        updateRecordingAllParticipantsSupport(recordParams.recordingAllParticipantsSupport);
        updateRecordingVideoParticipantsSupport(recordParams.recordingVideoParticipantsSupport);
        updateRecordingAllParticipantsFullRoomSupport(recordParams.recordingAllParticipantsFullRoomSupport);
        updateRecordingVideoParticipantsFullRoomSupport(recordParams.recordingVideoParticipantsFullRoomSupport);
        updateRecordingPreferredOrientation(recordParams.recordingPreferredOrientation);
        updateRecordingSupportForOtherOrientation(recordParams.recordingSupportForOtherOrientation);
        updateRecordingMultiFormatsSupport(recordParams.recordingMultiFormatsSupport);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RoomRecordParams, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RoomRecordParams, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RoomRecordParams, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to manage screen producer ID and screen sharing status for participants.
 *
 * @class
 * @name ScreenProducerId
 * @description This service processes and updates the screen producer ID, manages screen sharing states, and defers screen updates as needed based on participant data.
 *
 * @method
 * screenProducerId
 *
 * @param {ScreenProducerIdOptions} options - Options for handling screen producer ID:
 *   - `producerId` {string}: The ID of the screen producer.
 *   - `screenId` {string}: The current screen ID.
 *   - `membersReceived` {boolean}: Indicates if members data has been received.
 *   - `shareScreenStarted` {boolean}: Indicates if screen sharing has started.
 *   - `deferScreenReceived` {boolean}: Indicates if screen sharing should be deferred.
 *   - `participants` {Participant[]}: The list of current participants.
 *   - `updateScreenId` {Function}: Function to update the screen ID.
 *   - `updateShareScreenStarted` {Function}: Function to update the screen sharing status.
 *   - `updateDeferScreenReceived` {Function}: Function to update the deferred screen status.
 *
 * @returns {void} Updates states directly through provided functions.
 *
 * @example
 * const options = {
 *   producerId: 'abc123',
 *   screenId: 'screen45',
 *   membersReceived: true,
 *   shareScreenStarted: false,
 *   deferScreenReceived: false,
 *   participants: [
 *     { id: 'p1', ScreenID: 'screen45', ScreenOn: true },
 *     // Additional participants
 *   ],
 *   updateScreenId: (id) => console.log(`Screen ID updated to: ${id}`),
 *   updateShareScreenStarted: (started) => console.log(`Screen sharing started: ${started}`),
 *   updateDeferScreenReceived: (received) => console.log(`Screen sharing deferred: ${received}`)
 * };
 *
 * screenProducerIdService.screenProducerId(options);
 */
class ScreenProducerId {
    /**
     * Handles the screen producer id.
     *
     * @param producerId - The id of the producer.
     * @param screenId - The id of the screen.
     * @param membersReceived - Whether the members data has been received.
     * @param shareScreenStarted - Whether the screen sharing has started.
     * @param deferScreenReceived - Whether the screen sharing has been deferred.
     * @param participants - The list of participants.
     * @param updateScreenId - Function to update the screen id.
     * @param updateShareScreenStarted - Function to update the screen sharing status.
     * @param updateDeferScreenReceived - Function to update the screen sharing defer status.
     */
    screenProducerId = ({ producerId, screenId, membersReceived, shareScreenStarted, deferScreenReceived, participants, updateScreenId, updateShareScreenStarted, updateDeferScreenReceived, }) => {
        // Check if members data has been received with the screenId participant in it
        let host = participants.find((participant) => participant.ScreenID === screenId && participant.ScreenOn === true);
        // Operations to update the UI
        if (host && membersReceived) {
            screenId = producerId;
            shareScreenStarted = true;
            deferScreenReceived = false;
            updateScreenId(screenId);
            updateShareScreenStarted(shareScreenStarted);
            updateDeferScreenReceived(deferScreenReceived);
        }
        else {
            deferScreenReceived = true;
            screenId = producerId;
            updateScreenId(screenId);
            updateDeferScreenReceived(deferScreenReceived);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ScreenProducerId, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ScreenProducerId, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ScreenProducerId, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to initiate recording for a specified room.
 *
 * @class
 * @name StartRecords
 * @description Sends a request to the server to begin recording a room, using socket communication.
 *
 * @method
 * startRecords
 *
 * @param {StartRecordsOptions} options - Options required to start the recording:
 *   - `roomName` {string}: The name of the room to record.
 *   - `member` {string}: The identifier of the member initiating the recording.
 *   - `socket` {Socket}: The socket instance for server communication.
 *
 * @returns {Promise<void>} Resolves when the server confirms the recording start request.
 *
 * @example
 * const options = {
 *   roomName: 'Room101',
 *   member: 'user123',
 *   socket: io('http://localhost:3000')
 * };
 * startRecordsService.startRecords(options);
 */
class StartRecords {
    /**
     * Starts recording the room.
     *
     * @param {Object} options - The options for starting the recording.
     * @param {string} options.roomName - The name of the room to start recording.
     * @param {string} options.member - The member starting the recording.
     * @param {Socket} options.socket - The socket instance for communication.
     *
     * @returns {Promise<void>} A promise that resolves when the recording is started.
     */
    startRecords = async ({ roomName, member, socket }) => {
        // Send the 'startRecording' event to the server with roomName and member information
        socket.emit('startRecordIng', { roomName, member }, ({ success }) => {
            // Handle the success or failure of starting recording (if needed)
            if (success) {
                console.log('Recording started successfully');
            }
            else {
                console.log('Recording failed to start');
            }
        });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartRecords, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartRecords, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StartRecords, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to display an alert message when recording has stopped.
 *
 * @class
 * @name StoppedRecording
 * @description Provides a method to show an alert indicating that the recording has stopped.
 *
 * @method
 * stoppedRecording
 *
 * @param {StoppedRecordingOptions} options - Options for displaying the alert:
 *   - `state` {string}: The state of the recording, typically 'stop'.
 *   - `reason` {string}: The reason for stopping the recording.
 *   - `showAlert` {Function}: Optional function to show alert messages.
 *
 * @returns {Promise<void>} Resolves when the alert message has been displayed.
 *
 * @example
 * const options = {
 *   state: 'stop',
 *   reason: 'User ended recording',
 *   showAlert: ({ message, duration, type }) => console.log(message)
 * };
 * stoppedRecordingService.stoppedRecording(options);
 */
class StoppedRecording {
    /**
     * Displays an alert message when the recording has stopped.
     *
     * @param {Object} options - The options for displaying the alert message.
     * @param {string} options.state - The state of the recording.
     * @param {string} options.reason - The reason for stopping the recording.
     * @param {Function} options.showAlert - Function to show alerts.
     * @returns {Promise<void>} A promise that resolves when the alert message is displayed.
     */
    stoppedRecording = async ({ state, reason, showAlert, }) => {
        try {
            if (state === 'stop') {
                showAlert?.({
                    message: `The recording has stopped - ${reason}.`,
                    duration: 3000,
                    type: 'danger',
                });
            }
        }
        catch (error) {
            console.error('Error in stoppedRecording: ', error);
            // throw new Error("Failed to display the recording stopped alert message.");
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StoppedRecording, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StoppedRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StoppedRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to display an alert indicating the remaining recording time.
 *
 * @class
 * @name TimeLeftRecording
 * @description Provides a method to show an alert when the recording is close to its end.
 *
 * @method
 * timeLeftRecording
 *
 * @param {TimeLeftRecordingOptions} options - Options for the remaining time alert:
 *   - `timeLeft` {number}: The time left in seconds before the recording stops.
 *   - `showAlert` {Function}: Optional function to display the alert message.
 *
 * @example
 * const options = {
 *   timeLeft: 30,
 *   showAlert: ({ message, duration, type }) => console.log(message)
 * };
 * timeLeftRecordingService.timeLeftRecording(options);
 */
class TimeLeftRecording {
    /**
     * Displays an alert message indicating the remaining time left for recording.
     *
     * @param {TimeLeftRecordingOptions} options - The options for the time left recording.
     * @param {number} options.timeLeft - The amount of time left in seconds.
     * @param {Function} options.showAlert - The function to display the alert message.
     *
     * @throws {Error} If there is an issue displaying the alert message.
     */
    timeLeftRecording = ({ timeLeft, showAlert }) => {
        try {
            // Display alert message
            showAlert?.({
                message: `The recording will stop in less than ${timeLeft} seconds.`,
                duration: 3000,
                type: 'danger',
            });
        }
        catch (error) {
            console.log('Error in timeLeftRecording: ', error);
            // throw new Error("Failed to display the time left alert message.");
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: TimeLeftRecording, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: TimeLeftRecording, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: TimeLeftRecording, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service to update consuming domains based on specified options and parameters.
 *
 * @class
 * @name UpdateConsumingDomains
 * @description Provides a method to update consuming domains and optionally connect IPs based on the domains provided.
 *
 * @method
 * updateConsumingDomains
 *
 * @param {UpdateConsumingDomainsOptions} options - Options for updating consuming domains:
 *   - `domains` {Array<string>}: The list of domains to be updated.
 *   - `alt_domains` {AltDomains}: Alternative domains for fallback scenarios.
 *   - `apiUserName` {string}: API username for authentication.
 *   - `apiKey` {string}: API key for access.
 *   - `apiToken` {string}: API token for additional security.
 *   - `parameters` {UpdateConsumingDomainsParameters}: The parameters needed for updating, including:
 *     - `participants` {Array<Participant>}: List of participants.
 *     - `consume_sockets` {Array<ConsumeSocket>}: Sockets to use for consuming domains.
 *     - `getDomains` {Function}: Function to retrieve current domain configurations.
 *     - `connectIps` {Function}: Function to initiate IP connections.
 *     - `getUpdatedAllParams` {Function}: Refreshes and returns the latest parameters.
 *
 * @returns {Promise<void>} Resolves when the consuming domains have been successfully updated.
 *
 * @example
 * const options = {
 *   domains: ['example.com', 'sample.org'],
 *   alt_domains: { primary: 'primary.com', backup: 'backup.com' },
 *   apiUserName: 'user123',
 *   apiKey: 'apikey123',
 *   apiToken: 'token123',
 *   parameters: {
 *     participants: [{ id: '1', name: 'John Doe' }],
 *     consume_sockets: [socket1, socket2],
 *     getDomains: (opts) => fetchDomains(opts),
 *     connectIps: (opts) => connectToIPs(opts),
 *     getUpdatedAllParams: () => refreshParams(),
 *   },
 * };
 * await updateConsumingDomainsService.updateConsumingDomains(options);
 */
class UpdateConsumingDomains {
    /**
     * Updates the consuming domains based on the provided options.
     *
     * @param {Object} options - The options for updating the consuming domains.
     * @param {Array<string>} options.domains - The consuming domains to update.
     * @param {Object} options.alt_domains - The alternative consuming domains to update.
     * @param {string} options.apiUserName - The API username for the consuming domains.
     * @param {string} options.apiKey - The API key for the consuming domains.
     * @param {string} options.apiToken - The API token for the consuming domains.
     * @param {Object} options.parameters - The parameters for updating the consuming domains.
     * @param {Array<Participant>} options.parameters.participants - The participants to update consuming domains for.
     * @param {Array<ConsumeSocket>} options.parameters.consume_sockets - The consume sockets to update consuming domains for.
     * @param {Function} options.parameters.getDomains - Function to get the consuming domains.
     * @param {Function} options.parameters.connectIps - Function to connect IPs.
     * @param {Function} options.parameters.getUpdatedAllParams - Function to get updated parameters.
     *
     * @returns {Promise<void>} A promise that resolves when the consuming domains have been updated.
     *
     * @throws Will log an error message if an error occurs during the update process.
     */
    updateConsumingDomains = async ({ domains, alt_domains, parameters, apiUserName, apiKey, apiToken, }) => {
        let { participants, getDomains, consume_sockets, connectIps } = parameters;
        parameters = parameters.getUpdatedAllParams();
        consume_sockets = parameters.consume_sockets;
        console.log('Updating consuming domains...');
        try {
            // Check if participants array is not empty
            if (participants.length > 0) {
                // Check if alt_domains has keys and remove duplicates
                if (Object.keys(alt_domains).length > 0) {
                    console.log('Getting domains...');
                    await getDomains({ domains, alt_domains, apiUserName, apiKey, apiToken, parameters });
                }
                else {
                    await connectIps({
                        consume_sockets,
                        remIP: domains,
                        parameters,
                        apiUserName,
                        apiKey,
                        apiToken,
                    });
                }
            }
        }
        catch (error) {
            console.log('Error in updateConsumingDomains: ', error);
            // throw new Error('Failed to update consuming domains.');
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateConsumingDomains, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateConsumingDomains, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateConsumingDomains, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service for updating media settings including audio, video, screenshare, and chat.
 *
 * @class
 * @name UpdateMediaSettings
 * @description Provides a method to update multiple media settings at once using specified update functions.
 *
 * @method
 * updateMediaSettings
 *
 * @param {UpdateMediaSettingsOptions} options - Options for updating media settings:
 *   - `settings` {Settings}: The settings values to apply.
 *   - `updateAudioSetting` {Function}: Function to update the audio setting.
 *   - `updateVideoSetting` {Function}: Function to update the video setting.
 *   - `updateScreenshareSetting` {Function}: Function to update the screenshare setting.
 *   - `updateChatSetting` {Function}: Function to update the chat setting.
 *
 * @returns {void} Updates settings directly through the provided functions.
 *
 * @example
 * const settings = ['mute', 'HD', 'enabled', 'disabled'];
 * const options = {
 *   settings,
 *   updateAudioSetting: (value) => console.log(`Audio setting updated to: ${value}`),
 *   updateVideoSetting: (value) => console.log(`Video setting updated to: ${value}`),
 *   updateScreenshareSetting: (value) => console.log(`Screenshare setting updated to: ${value}`),
 *   updateChatSetting: (value) => console.log(`Chat setting updated to: ${value}`)
 * };
 * updateMediaSettingsService.updateMediaSettings(options);
 */
class UpdateMediaSettings {
    /**
     * Updates the media settings by invoking the provided update functions for each setting.
     *
     * @param {Object} options - The options for updating the media settings.
     * @param {Settings} options.settings - The media settings to update.
     * @param {Function} options.updateAudioSetting - Function to update the audio setting.
     * @param {Function} options.updateVideoSetting - Function to update the video setting.
     * @param {Function} options.updateScreenshareSetting - Function to update the screenshare setting.
     * @param {Function} options.updateChatSetting - Function to update the chat setting.
     * @returns {void} A promise that resolves when the media settings have been updated.
     * @memberof UpdateMediaSettings
     */
    updateMediaSettings = ({ settings, updateAudioSetting, updateVideoSetting, updateScreenshareSetting, updateChatSetting, }) => {
        const [audioSetting, videoSetting, screenshareSetting, chatSetting] = settings;
        // Update audio setting
        updateAudioSetting(audioSetting);
        // Update video setting
        updateVideoSetting(videoSetting);
        // Update screenshare setting
        updateScreenshareSetting(screenshareSetting);
        // Update chat setting
        updateChatSetting(chatSetting);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateMediaSettings, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateMediaSettings, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdateMediaSettings, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service for updating co-host information, responsibilities, and the user's co-host status.
 *
 * @class
 * @name UpdatedCoHost
 * @description Manages co-host updates for different event types, assigning responsibilities and notifying the user if their co-host status changes.
 *
 * @method
 * updatedCoHost
 * @async
 *
 * @param {UpdatedCoHostOptions} options - The options for co-host updates:
 *   - `coHost` {string}: The name of the co-host.
 *   - `coHostResponsibility` {CoHostResponsibility[]}: List of responsibilities assigned to the co-host.
 *   - `showAlert` {ShowAlert}: Optional function to display an alert message.
 *   - `eventType` {EventType}: Type of the event, determining if co-host can be updated.
 *   - `islevel` {string}: Current level of the event.
 *   - `member` {string}: The current user's identifier.
 *   - `youAreCoHost` {boolean}: Current user's co-host status.
 *   - `updateCoHost` {Function}: Function to set the new co-host.
 *   - `updateCoHostResponsibility` {Function}: Function to assign responsibilities to the co-host.
 *   - `updateYouAreCoHost` {Function}: Function to update the user's co-host status.
 *
 * @returns {Promise<void>} Resolves after co-host information is updated.
 *
 * @example
 * const options = {
 *   coHost: 'Alice',
 *   coHostResponsibility: ['moderate', 'manageParticipants'],
 *   showAlert: ({ message, type, duration }) => console.log(message),
 *   eventType: 'conference',
 *   islevel: '1',
 *   member: 'Alice',
 *   youAreCoHost: false,
 *   updateCoHost: (newCoHost) => console.log(`Updated co-host: ${newCoHost}`),
 *   updateCoHostResponsibility: (responsibilities) => console.log(responsibilities),
 *   updateYouAreCoHost: (status) => console.log(`You are co-host: ${status}`)
 * };
 * await updatedCoHostService.updatedCoHost(options);
 */
class UpdatedCoHost {
    /**
     * Updates the co-host information, responsibility, and user's co-host status based on the provided options.
     *
     * @param options - The options for updating the co-host.
     * @param options.coHost - The co-host to be updated.
     * @param options.coHostResponsibility - The responsibility of the co-host.
     * @param options.showAlert - A function to show alerts.
     * @param options.eventType - The type of event triggering the update.
     * @param options.islevel - The level of the event.
     * @param options.member - The member to be checked against the co-host.
     * @param options.youAreCoHost - The current co-host status of the user.
     * @param options.updateCoHost - A function to update the co-host.
     * @param options.updateCoHostResponsibility - A function to update the co-host's responsibility.
     * @param options.updateYouAreCoHost - A function to update the user's co-host status.
     *
     * @returns A promise that resolves when the co-host information has been updated.
     */
    updatedCoHost = async ({ coHost, coHostResponsibility, showAlert, eventType, islevel, member, youAreCoHost, updateCoHost, updateCoHostResponsibility, updateYouAreCoHost, }) => {
        // Update co-host information, responsibility, and user's co-host status
        if (eventType !== 'broadcast' && eventType !== 'chat') {
            // Only update the co-host if the event type is not broadcast or chat
            updateCoHost(coHost);
            updateCoHostResponsibility(coHostResponsibility);
            if (member === coHost) {
                if (!youAreCoHost) {
                    updateYouAreCoHost(true);
                    showAlert?.({
                        message: 'You are now a co-host.',
                        type: 'success',
                        duration: 3000,
                    });
                }
            }
            else {
                updateYouAreCoHost(false);
            }
        }
        else {
            if (islevel !== '2') {
                updateYouAreCoHost(true);
            }
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdatedCoHost, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdatedCoHost, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UpdatedCoHost, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Service for handling user waiting room actions, including notifications and updating request counts.
 *
 * @class
 * @name UserWaiting
 * @description Manages the logic when a user joins the waiting room by displaying alerts and incrementing the total request count.
 *
 * @method
 * userWaiting
 * @async
 *
 * @param {UserWaitingOptions} options - The options for handling user waiting actions:
 *   - `name` {string}: Name of the user joining the waiting room.
 *   - `showAlert` {ShowAlert}: Optional function for showing an alert with a customizable message, type, and duration.
 *   - `totalReqWait` {number}: Current count of waiting requests.
 *   - `updateTotalReqWait` {Function}: Updates the total waiting request count.
 *
 * @returns {Promise<void>} Resolves after alert is shown and request count is updated.
 *
 * @example
 * const options = {
 *   name: 'Alice',
 *   showAlert: ({ message, type, duration }) => console.log(message),
 *   totalReqWait: 3,
 *   updateTotalReqWait: (newTotal) => console.log(`Updated count: ${newTotal}`)
 * };
 * await userWaitingService.userWaiting(options);
 */
class UserWaiting {
    userWaiting = async ({ name, showAlert, totalReqWait, updateTotalReqWait, }) => {
        // Display an alert/notification about the user joining the waiting room
        showAlert?.({
            message: `${name} joined the waiting room.`,
            type: 'success',
            duration: 3000,
        });
        // Update the total number of requests waiting in the waiting room
        const totalReqs = totalReqWait + 1;
        updateTotalReqWait(totalReqs);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UserWaiting, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UserWaiting, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: UserWaiting, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * BackgroundModal - Component to manage background selection and manipulation in media streams.
 *
 * This component allows users to choose, apply, and manipulate virtual backgrounds for media streams, leveraging MediaPipe’s Selfie Segmentation and MediaSoup functionalities.
 *
 * @component
 * @name BackgroundModal
 * @example
 * ```typescript
 * <app-background-modal
 *   [isVisible]="isModalVisible"
 *   [parameters]="modalParameters"
 *   position="topLeft"
 *   backgroundColor="#f5f5f5"
 *   (onClose)="handleModalClose()"
 * ></app-background-modal>
 * ```
 *
 * @param {boolean} isVisible - Visibility state of the modal.
 * @param {BackgroundModalParameters} parameters - Parameters including settings and methods for media and background management.
 * @param {string} position - The position of the modal, e.g., 'topLeft'.
 * @param {string} backgroundColor - Background color of the modal.
 * @param {Function} onClose - Callback function when the modal is closed.
 *
 * @property {faTimes} faTimes - Icon used for closing the modal.
 * @property {string} customImage - Custom image URL for background.
 * @property {string} selectedImage - Selected image URL for background.
 * @property {MediaStream | null} segmentVideo - Media stream for video segmentation.
 * @property {SelfieSegmentation | null} selfieSegmentation - SelfieSegmentation instance.
 * @property {boolean} pauseSegmentation - Pause state for segmentation.
 * @property {MediaStream | null} processedStream - Processed media stream with applied background.
 * @property {boolean} keepBackground - State to keep or reset background.
 *
 * @method
 * ngOnInit - Initializes the modal component by updating properties based on parameters.
 */
class BackgroundModal {
    isVisible = false;
    parameters = {};
    position = 'topLeft';
    backgroundColor = '#f5f5f5';
    onClose = () => {
        console.log('onClose');
    };
    defaultImagesContainerRef;
    uploadImageInputRef;
    backgroundCanvasRef;
    videoPreviewRef;
    captureVideoRef;
    loadingOverlayRef;
    applyBackgroundButtonRef;
    saveBackgroundButtonRef;
    faTimes = faTimes;
    customImage = '';
    selectedImage = '';
    segmentVideo = null;
    selfieSegmentation = null;
    pauseSegmentation = false;
    processedStream = null;
    keepBackground = false;
    backgroundHasChanged = false;
    virtualStream = null;
    mainCanvas;
    prevKeepBackground = false;
    appliedBackground = false;
    videoAlreadyOn = false;
    audioOnlyRoom = false;
    islevel = '0';
    recordStarted = false;
    recordResumed = false;
    recordPaused = false;
    recordStopped = false;
    recordingMediaOptions = '';
    vidCons = {};
    frameRate = 5;
    targetResolution = '1280x720';
    videoParams = {};
    autoClickBackground = false;
    localStreamVideo = null;
    clonedStream = null;
    clonedTrack = null;
    updateCustomImage;
    updateSelectedImage;
    updateSegmentVideo;
    updateSelfieSegmentation;
    updatePauseSegmentation;
    updateProcessedStream;
    updateKeepBackground;
    updateBackgroundHasChanged;
    updateVirtualStream;
    updateMainCanvas;
    updatePrevKeepBackground;
    updateAppliedBackground;
    updateVideoParams;
    updateAutoClickBackground;
    // Media functions
    createSendTransport;
    connectSendTransportVideo;
    disconnectSendTransportVideo;
    onScreenChanges;
    sleep;
    ngOnInit() {
        // Initialize local properties from the parameters
        if (this.parameters) {
            try {
                this.updateVariables();
            }
            catch {
                /* handle error */
            }
        }
    }
    ngOnChanges(changes) {
        if (changes['isVisible']) {
            this.onVisibilityChange();
        }
        if (changes['autoClickBackground']) {
            console.log('Auto click background changed:', this.autoClickBackground, changes['autoClickBackground']);
        }
    }
    updateVariables() {
        this.customImage = this.parameters.customImage || '';
        this.selectedImage = this.parameters.selectedImage || '';
        this.segmentVideo = this.parameters.segmentVideo || null;
        this.selfieSegmentation = this.parameters.selfieSegmentation || null;
        this.pauseSegmentation = this.parameters.pauseSegmentation || false;
        this.processedStream = this.parameters.processedStream || null;
        this.keepBackground = this.parameters.keepBackground || false;
        this.backgroundHasChanged = this.parameters.backgroundHasChanged || false;
        this.virtualStream = this.parameters.virtualStream || null;
        this.mainCanvas = this.parameters.mainCanvas || this.backgroundCanvasRef?.nativeElement || null;
        this.prevKeepBackground = this.parameters.prevKeepBackground || false;
        this.appliedBackground = this.parameters.appliedBackground || false;
        this.videoAlreadyOn = this.parameters.videoAlreadyOn || false;
        this.audioOnlyRoom = this.parameters.audioOnlyRoom || false;
        this.islevel = this.parameters.islevel || '0';
        this.recordStarted = this.parameters.recordStarted || false;
        this.recordResumed = this.parameters.recordResumed || false;
        this.recordPaused = this.parameters.recordPaused || false;
        this.recordStopped = this.parameters.recordStopped || false;
        this.recordingMediaOptions = this.parameters.recordingMediaOptions || '';
        this.vidCons = this.parameters.vidCons || {};
        this.frameRate = this.parameters.frameRate || 5;
        this.videoParams = this.parameters.videoParams || null;
        this.autoClickBackground = this.parameters.autoClickBackground || false;
        this.localStreamVideo = this.parameters.localStreamVideo || null;
        // Assign method references
        this.updateCustomImage = this.parameters.updateCustomImage;
        this.updateSelectedImage = this.parameters.updateSelectedImage;
        this.updateSegmentVideo = this.parameters.updateSegmentVideo;
        this.updateSelfieSegmentation = this.parameters.updateSelfieSegmentation;
        this.updatePauseSegmentation = this.parameters.updatePauseSegmentation;
        this.updateProcessedStream = this.parameters.updateProcessedStream;
        this.updateKeepBackground = this.parameters.updateKeepBackground;
        this.updateBackgroundHasChanged = this.parameters.updateBackgroundHasChanged;
        this.updateVirtualStream = this.parameters.updateVirtualStream;
        this.updateMainCanvas = this.parameters.updateMainCanvas;
        this.updatePrevKeepBackground = this.parameters.updatePrevKeepBackground;
        this.updateAppliedBackground = this.parameters.updateAppliedBackground;
        this.updateVideoParams = this.parameters.updateVideoParams;
        this.updateAutoClickBackground = this.parameters.updateAutoClickBackground;
        this.createSendTransport = this.parameters.createSendTransport;
        this.connectSendTransportVideo = this.parameters.connectSendTransportVideo;
        this.disconnectSendTransportVideo = this.parameters.disconnectSendTransportVideo;
        this.onScreenChanges = this.parameters.onScreenChanges;
        this.sleep = this.parameters.sleep;
    }
    onVisibilityChange = async () => {
        if (this.parameters) {
            this.parameters = this.parameters.getUpdatedAllParams();
            this.updateVariables();
        }
        if (this.isVisible) {
            if (!this.selfieSegmentation) {
                await this.preloadModel().catch(() => console.log('Error preloading model:'));
            }
            this.renderDefaultImages();
            if (this.selectedImage) {
                await this.loadImageToCanvas(this.selectedImage, this.selectedImage);
            }
            else {
                this.clearCanvas();
                this.backgroundCanvasRef.nativeElement.classList.remove('d-none');
            }
            this.saveBackgroundButtonRef.nativeElement.classList.add('d-none');
            this.saveBackgroundButtonRef.nativeElement.disabled = true;
            this.applyBackgroundButtonRef.nativeElement.classList.remove('d-none');
            this.applyBackgroundButtonRef.nativeElement.disabled = false;
            if (this.processedStream &&
                this.prevKeepBackground == this.keepBackground &&
                this.keepBackground &&
                this.appliedBackground) {
                this.applyBackgroundButtonRef.nativeElement.innerText = 'Apply Background';
            }
            else {
                this.applyBackgroundButtonRef.nativeElement.innerText = 'Preview Background';
            }
            if (this.autoClickBackground) {
                await this.applyBackground();
                await this.saveBackground();
                this.autoClickBackground = false;
                this.updateAutoClickBackground(this.autoClickBackground);
            }
        }
        else {
            try {
                // If no background is applied or the applied background should not be kept
                if (!this.appliedBackground ||
                    (this.appliedBackground && !this.keepBackground) ||
                    (this.appliedBackground && !this.videoAlreadyOn)) {
                    const refVideo = this.captureVideoRef.nativeElement;
                    this.pauseSegmentation = true;
                    this.updatePauseSegmentation(this.pauseSegmentation);
                    if (!this.videoAlreadyOn) {
                        // Stop video tracks and clear the video element's srcObject
                        if (refVideo && refVideo.srcObject) {
                            refVideo.srcObject.getTracks().forEach((track) => track.stop());
                            refVideo.srcObject = null;
                        }
                        // Stop segmentVideo tracks
                        if (this.segmentVideo) {
                            this.segmentVideo.getTracks().forEach((track) => track.stop());
                            this.segmentVideo = null;
                            this.updateSegmentVideo(this.segmentVideo);
                        }
                        // Stop virtualStream tracks
                        if (this.virtualStream) {
                            this.virtualStream.getTracks().forEach((track) => track.stop());
                            this.virtualStream = null;
                            this.updateVirtualStream(this.virtualStream);
                        }
                    }
                }
                // Hide the video preview and show the canvas
                this.videoPreviewRef.nativeElement.classList.add('d-none');
                this.backgroundCanvasRef.nativeElement.classList.remove('d-none');
            }
            catch {
                /* handle error */
            }
        }
    };
    async preloadModel() {
        this.selfieSegmentation = new SelfieSegmentation({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`,
        });
        this.selfieSegmentation.setOptions({
            modelSelection: 1,
            selfieMode: false,
        });
        await this.selfieSegmentation.initialize();
        this.updateSelfieSegmentation(this.selfieSegmentation);
    }
    renderDefaultImages() {
        const defaultImages = ['wall', 'wall2', 'shelf', 'clock', 'desert', 'flower'];
        const defaultImagesContainer = this.defaultImagesContainerRef.nativeElement;
        defaultImagesContainer.innerHTML = '';
        defaultImages.forEach((baseName) => {
            const thumb = `https://mediasfu.com/images/backgrounds/${baseName}_thumbnail.jpg`;
            const small = `https://mediasfu.com/images/backgrounds/${baseName}_small.jpg`;
            const large = `https://mediasfu.com/images/backgrounds/${baseName}_large.jpg`;
            const full = `https://mediasfu.com/images/backgrounds/${baseName}.jpg`;
            const img = document.createElement('img');
            img.src = thumb;
            img.classList.add('img-thumbnail', 'm-1');
            img.style.width = '80px';
            img.style.cursor = 'pointer';
            img.addEventListener('click', async () => {
                if (this.targetResolution == 'fhd' || this.targetResolution == 'qhd') {
                    await this.loadImageToCanvas(small, large);
                }
                else {
                    await this.loadImageToCanvas(small, full);
                }
            });
            defaultImagesContainer.appendChild(img);
        });
        const noBackgroundImg = document.createElement('div');
        noBackgroundImg.classList.add('img-thumbnail', 'm-1', 'd-flex', 'align-items-center', 'justify-content-center');
        noBackgroundImg.style.width = '76px';
        noBackgroundImg.style.minHeight = '60px';
        noBackgroundImg.style.cursor = 'pointer';
        noBackgroundImg.style.backgroundColor = '#f8f9fa';
        noBackgroundImg.style.border = '1px solid #dee2e6';
        noBackgroundImg.style.position = 'relative';
        noBackgroundImg.innerHTML =
            '<span style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#000;">None</span>';
        noBackgroundImg.addEventListener('click', async () => {
            this.selectedImage = '';
            this.updateSelectedImage(this.selectedImage);
            this.updateCustomImage('');
            this.showLoading();
            this.videoPreviewRef.nativeElement.classList.add('d-none');
            this.backgroundCanvasRef.nativeElement.classList.remove('d-none');
            this.clearCanvas();
            this.hideLoading();
        });
        defaultImagesContainer.appendChild(noBackgroundImg);
        if (this.customImage) {
            const img = document.createElement('img');
            img.src = this.customImage;
            img.classList.add('img-thumbnail', 'm-1');
            img.style.width = '80px';
            img.style.cursor = 'pointer';
            img.addEventListener('click', async () => {
                await this.loadImageToCanvas(this.customImage, this.customImage);
            });
            defaultImagesContainer.appendChild(img);
        }
    }
    async handleImageUpload(event) {
        let minWidth = 1280;
        let minHeight = 1280;
        let maxWidth = 2560;
        let maxHeight = 2560;
        if (this.targetResolution == 'fhd') {
            minWidth = 1920;
            minHeight = 1920;
        }
        else if (this.targetResolution == 'qhd') {
            minWidth = 2560;
            minHeight = 2560;
        } // For other resolutions, stick to the default 1280x1280
        const input = event.target;
        if (input.files && input.files.length > 0) {
            const file = input.files[0];
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = async () => {
                if (img.width < minWidth ||
                    img.height < minHeight ||
                    img.width > maxWidth ||
                    img.height > maxHeight) {
                    this.customImage = img.src;
                    this.updateCustomImage(this.customImage);
                    await this.loadImageToCanvas(img.src, img.src);
                }
            };
            const reader = new FileReader();
            reader.onload = (e) => {
                if (e.target) {
                    img.src = e.target.result;
                }
            };
            reader.readAsDataURL(file);
        }
    }
    clearCanvas() {
        const ctx = this.backgroundCanvasRef.nativeElement.getContext('2d');
        ctx.clearRect(0, 0, this.backgroundCanvasRef.nativeElement.width, this.backgroundCanvasRef.nativeElement.height);
        ctx.font = '30px Arial';
        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('No Background', this.backgroundCanvasRef.nativeElement.width / 2, this.backgroundCanvasRef.nativeElement.height / 2);
        this.applyBackgroundButtonRef.nativeElement.classList.remove('d-none');
        this.applyBackgroundButtonRef.nativeElement.disabled = false;
        if (this.processedStream &&
            this.prevKeepBackground == this.keepBackground &&
            this.keepBackground &&
            this.appliedBackground) {
            this.applyBackgroundButtonRef.nativeElement.innerText = 'Apply Background';
        }
        else {
            this.applyBackgroundButtonRef.nativeElement.innerText = 'Preview Background';
        }
    }
    async loadImageToCanvas(src, fullSrc) {
        this.showLoading();
        await this.backgroundCanvasRef.nativeElement.classList.remove('d-none');
        await this.videoPreviewRef.nativeElement.classList.add('d-none');
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = async () => {
            const ctx = await this.backgroundCanvasRef.nativeElement.getContext('2d');
            this.backgroundCanvasRef.nativeElement.width = img.width;
            this.backgroundCanvasRef.nativeElement.height = img.height;
            await ctx.drawImage(img, 0, 0);
            this.removeBackground(img);
            this.hideLoading();
        };
        img.src = src;
        this.selectedImage = fullSrc;
        this.updateSelectedImage(this.selectedImage);
        this.saveBackgroundButtonRef.nativeElement.classList.add('d-none');
        this.saveBackgroundButtonRef.nativeElement.disabled = true;
        this.applyBackgroundButtonRef.nativeElement.classList.remove('d-none');
        this.applyBackgroundButtonRef.nativeElement.disabled = false;
        if (this.processedStream &&
            this.prevKeepBackground == this.keepBackground &&
            this.keepBackground &&
            this.appliedBackground) {
            this.applyBackgroundButtonRef.nativeElement.innerText = 'Apply Background';
        }
        else {
            this.applyBackgroundButtonRef.nativeElement.innerText = 'Preview Background';
        }
    }
    removeBackground(img) {
        const ctx = this.backgroundCanvasRef.nativeElement.getContext('2d');
        ctx.clearRect(0, 0, this.backgroundCanvasRef.nativeElement.width, this.backgroundCanvasRef.nativeElement.height);
        ctx.drawImage(img, 0, 0);
    }
    async applyBackground() {
        try {
            if (this.audioOnlyRoom) {
                this.parameters.showAlert?.({
                    message: 'You cannot use a background in an audio only event.',
                    type: 'danger',
                });
                return;
            }
            this.showLoading();
            this.videoPreviewRef.nativeElement.classList.remove('d-none');
            this.backgroundCanvasRef.nativeElement.classList.add('d-none');
            const doSegmentation = this.selectedImage ? true : false;
            this.pauseSegmentation = false;
            this.updatePauseSegmentation(this.pauseSegmentation);
            await this.selfieSegmentationPreview(doSegmentation);
            this.hideLoading();
            this.applyBackgroundButtonRef.nativeElement.classList.add('d-none');
            this.applyBackgroundButtonRef.nativeElement.disabled = true;
            if (this.processedStream &&
                this.prevKeepBackground == this.keepBackground &&
                this.keepBackground &&
                this.appliedBackground) {
                this.saveBackgroundButtonRef.nativeElement.classList.add('d-none');
                this.saveBackgroundButtonRef.nativeElement.disabled = true;
            }
            else {
                this.saveBackgroundButtonRef.nativeElement.classList.remove('d-none');
                this.saveBackgroundButtonRef.nativeElement.disabled = false;
            }
        }
        catch (error) {
            console.log(error);
        }
    }
    async selfieSegmentationPreview(doSegmentation) {
        const refVideo = this.captureVideoRef.nativeElement;
        const previewVideo = this.videoPreviewRef.nativeElement;
        const virtualImage = new Image();
        virtualImage.crossOrigin = 'anonymous';
        virtualImage.src = this.selectedImage;
        if (!this.mainCanvas) {
            this.mainCanvas = await this.backgroundCanvasRef.nativeElement;
        }
        let mediaCanvas = this.mainCanvas;
        mediaCanvas.width = refVideo.videoWidth;
        mediaCanvas.height = refVideo.videoHeight;
        let ctx = mediaCanvas.getContext('2d');
        this.backgroundHasChanged = true;
        this.updateBackgroundHasChanged(this.backgroundHasChanged);
        this.prevKeepBackground = this.keepBackground;
        this.updatePrevKeepBackground(this.keepBackground);
        if (!doSegmentation) {
            const tracks = this.processedStream?.getVideoTracks();
            if (tracks) {
                tracks.forEach((track) => track.stop());
            }
            this.processedStream = null;
            this.keepBackground = false;
            this.updateProcessedStream(null);
            this.updateKeepBackground(false);
            previewVideo.classList.remove('d-none');
        }
        const segmentImage = async (videoElement) => {
            const processFrame = () => {
                if (!this.selfieSegmentation ||
                    this.pauseSegmentation ||
                    !videoElement ||
                    videoElement.videoWidth == 0 ||
                    videoElement.videoHeight == 0) {
                    return;
                }
                this.selfieSegmentation.send({ image: videoElement });
                requestAnimationFrame(processFrame);
            };
            videoElement.onloadeddata = () => {
                processFrame();
            };
            setTimeout(async () => {
                console.log('Capturing stream:', this.frameRate || 5);
                this.processedStream = mediaCanvas.captureStream(this.frameRate || 5);
                this.updateProcessedStream(this.processedStream);
                previewVideo.srcObject = this.processedStream;
                previewVideo.classList.remove('d-none');
                this.keepBackground = true;
                this.updateKeepBackground(this.keepBackground);
                if (previewVideo.paused) {
                    try {
                        // play the video
                        previewVideo.play().then(() => {
                            /* handle success */
                        });
                    }
                    catch {
                        /* handle error */
                    }
                }
            }, 100);
        };
        if (this.videoAlreadyOn) {
            if (this.clonedTrack &&
                this.clonedTrack.readyState == 'live' &&
                this.localStreamVideo?.getVideoTracks()[0].label == this.clonedTrack.label) {
                // Use existing clonedTrack
            }
            else {
                const localTracks = this.localStreamVideo?.getVideoTracks()[0];
                this.clonedTrack = localTracks.clone();
                this.clonedStream = new MediaStream([this.clonedTrack]);
                this.segmentVideo = this.clonedStream;
            }
            this.updateSegmentVideo(this.segmentVideo);
            refVideo.srcObject = this.segmentVideo;
            if (refVideo.paused) {
                refVideo.play();
            }
            refVideo.width = this.segmentVideo.getVideoTracks()[0].getSettings().width;
            refVideo.height = this.segmentVideo.getVideoTracks()[0].getSettings().height;
            mediaCanvas.width = refVideo.width;
            mediaCanvas.height = refVideo.height;
            ctx = mediaCanvas.getContext('2d');
            try {
                doSegmentation
                    ? await segmentImage(refVideo)
                    : (previewVideo.srcObject = this.clonedStream
                        ? this.clonedStream
                        : this.localStreamVideo);
            }
            catch (error) {
                console.log('Error segmenting image:', error);
            }
        }
        else {
            if (this.segmentVideo && this.segmentVideo.getVideoTracks()[0].readyState == 'live') {
                // Use existing segmentVideo
            }
            else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { ...this.vidCons, frameRate: { ideal: this.frameRate || 5 } },
                        audio: false,
                    });
                    this.segmentVideo = stream;
                    this.updateSegmentVideo(this.segmentVideo);
                    refVideo.srcObject = this.segmentVideo;
                    if (refVideo.paused) {
                        refVideo.play();
                    }
                }
                catch (error) {
                    // remove the frameRate constraint and try again
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({
                            video: { ...this.vidCons },
                            audio: false,
                        });
                        this.segmentVideo = stream;
                        this.updateSegmentVideo(this.segmentVideo);
                        refVideo.srcObject = this.segmentVideo;
                        if (refVideo.paused) {
                            refVideo.play();
                        }
                    }
                    catch (error) {
                        console.log('Error getting user media:', error);
                    }
                }
                refVideo.width = this.segmentVideo.getVideoTracks()[0].getSettings().width;
                refVideo.height = this.segmentVideo.getVideoTracks()[0].getSettings().height;
                mediaCanvas.width = refVideo.width;
                mediaCanvas.height = refVideo.height;
                ctx = mediaCanvas.getContext('2d');
            }
            try {
                doSegmentation
                    ? await segmentImage(refVideo)
                    : (previewVideo.srcObject = refVideo.srcObject);
            }
            catch (error) {
                console.log(error);
            }
        }
        let repeatPattern = 'no-repeat';
        try {
            if (virtualImage.width < mediaCanvas.width || virtualImage.height < mediaCanvas.height) {
                repeatPattern = 'repeat';
            }
        }
        catch {
            /* handle error */
        }
        const onResults = (results) => {
            try {
                if (!this.pauseSegmentation &&
                    mediaCanvas &&
                    mediaCanvas.width > 0 &&
                    mediaCanvas.height > 0 &&
                    virtualImage.width > 0 &&
                    virtualImage.height > 0) {
                    ctx.clearRect(0, 0, mediaCanvas.width, mediaCanvas.height);
                    ctx.drawImage(results.segmentationMask, 0, 0, mediaCanvas.width, mediaCanvas.height);
                    ctx.globalCompositeOperation = 'source-out';
                    const pat = ctx.createPattern(virtualImage, repeatPattern);
                    ctx.fillStyle = pat;
                    ctx.fillRect(0, 0, mediaCanvas.width, mediaCanvas.height);
                    ctx.globalCompositeOperation = 'destination-atop';
                    ctx.drawImage(results.image, 0, 0, mediaCanvas.width, mediaCanvas.height);
                }
            }
            catch (error) {
                console.log('Error processing results:', error);
            }
        };
        if (!this.selfieSegmentation) {
            await this.preloadModel().catch(() => console.log('Error preloading model:'));
        }
        try {
            this.selfieSegmentation.onResults(onResults);
        }
        catch (error) {
            console.log(error);
        }
    }
    saveBackground = async () => {
        if (this.audioOnlyRoom) {
            this.parameters.showAlert?.({
                message: 'You cannot use a background in an audio-only event.',
                type: 'danger',
            });
            return;
        }
        if (this.backgroundHasChanged) {
            if (this.videoAlreadyOn) {
                if (this.islevel == '2' && (this.recordStarted || this.recordResumed)) {
                    if (!(this.recordPaused || this.recordStopped)) {
                        if (this.recordingMediaOptions == 'video') {
                            this.parameters.showAlert?.({
                                message: 'Please pause the recording before changing the background.',
                                type: 'danger',
                            });
                            return;
                        }
                    }
                }
                if (this.keepBackground && this.selectedImage && this.processedStream) {
                    this.virtualStream = this.processedStream;
                    this.updateVirtualStream(this.virtualStream);
                    this.videoParams = { track: this.virtualStream.getVideoTracks()[0] };
                    this.updateVideoParams(this.videoParams);
                }
                else {
                    if (this.localStreamVideo?.getVideoTracks()[0].readyState == 'live') {
                        this.videoParams = { track: this.localStreamVideo.getVideoTracks()[0] };
                        this.updateVideoParams(this.videoParams);
                    }
                    else {
                        try {
                            if (this.localStreamVideo?.getVideoTracks()[0].readyState !== 'live') {
                                this.localStreamVideo?.removeTrack(this.localStreamVideo.getVideoTracks()[0]);
                                this.localStreamVideo?.addTrack(this.segmentVideo.getVideoTracks()[0].clone());
                            }
                        }
                        catch (error) {
                            console.log('Error handling local stream video:', error);
                        }
                        this.videoParams = { track: this.segmentVideo.getVideoTracks()[0] };
                        this.updateVideoParams(this.videoParams);
                    }
                }
                if (this.keepBackground) {
                    this.appliedBackground = true;
                    this.updateAppliedBackground(this.appliedBackground);
                }
                else {
                    this.appliedBackground = false;
                    this.updateAppliedBackground(this.appliedBackground);
                }
                if (!this.parameters.transportCreated) {
                    await this.createSendTransport({
                        option: 'video',
                        parameters: { ...this.parameters, videoParams: this.videoParams },
                    });
                }
                else {
                    try {
                        if (this.parameters.videoProducer?.id &&
                            this.parameters.videoProducer.track?.id !== this.videoParams?.track?.id) {
                            await this.disconnectSendTransportVideo({ parameters: this.parameters });
                            await this.sleep({ ms: 500 });
                        }
                        await this.connectSendTransportVideo({
                            videoParams: this.videoParams,
                            parameters: this.parameters,
                        });
                    }
                    catch (error) {
                        console.log(error);
                    }
                }
                await this.onScreenChanges({ changed: true, parameters: this.parameters });
            }
        }
        if (this.keepBackground) {
            this.appliedBackground = true;
            this.updateAppliedBackground(this.appliedBackground);
        }
        else {
            this.appliedBackground = false;
            this.updateAppliedBackground(this.appliedBackground);
        }
        this.saveBackgroundButtonRef.nativeElement.classList.add('d-none');
        this.saveBackgroundButtonRef.nativeElement.disabled = true;
    };
    handleModalClose = () => {
        try {
            // If no background is applied or the applied background should not be kept
            if (!this.appliedBackground ||
                (this.appliedBackground && !this.keepBackground) ||
                (this.appliedBackground && !this.videoAlreadyOn)) {
                console.log('No background applied or applied background should not be kept');
                const refVideo = this.captureVideoRef.nativeElement;
                this.pauseSegmentation = true;
                this.updatePauseSegmentation(this.pauseSegmentation);
                if (!this.videoAlreadyOn) {
                    // Stop video tracks and clear the video element's srcObject
                    if (refVideo && refVideo.srcObject) {
                        refVideo.srcObject.getTracks().forEach((track) => track.stop());
                        refVideo.srcObject = null;
                    }
                    // Stop segmentVideo tracks
                    if (this.segmentVideo) {
                        this.segmentVideo.getTracks().forEach((track) => track.stop());
                        this.segmentVideo = null;
                        this.updateSegmentVideo(this.segmentVideo);
                    }
                    // Stop virtualStream tracks
                    if (this.virtualStream) {
                        this.virtualStream.getTracks().forEach((track) => track.stop());
                        this.virtualStream = null;
                        this.updateVirtualStream(this.virtualStream);
                    }
                }
            }
            // Hide the video preview and show the canvas
            this.videoPreviewRef.nativeElement.classList.add('d-none');
            this.backgroundCanvasRef.nativeElement.classList.remove('d-none');
            // Hide the modal
            // this.isVisible = false;
            this.onClose();
        }
        catch (error) {
            console.log('Error during modal close:', error);
        }
    };
    showLoading() {
        this.loadingOverlayRef.nativeElement.classList.remove('d-none');
    }
    hideLoading() {
        this.loadingOverlayRef.nativeElement.classList.add('d-none');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: BackgroundModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: BackgroundModal, isStandalone: true, selector: "app-background-modal", inputs: { isVisible: "isVisible", parameters: "parameters", position: "position", backgroundColor: "backgroundColor", onClose: "onClose" }, viewQueries: [{ propertyName: "defaultImagesContainerRef", first: true, predicate: ["defaultImagesContainer"], descendants: true }, { propertyName: "uploadImageInputRef", first: true, predicate: ["uploadImageInput"], descendants: true }, { propertyName: "backgroundCanvasRef", first: true, predicate: ["backgroundCanvas"], descendants: true }, { propertyName: "videoPreviewRef", first: true, predicate: ["videoPreview"], descendants: true }, { propertyName: "captureVideoRef", first: true, predicate: ["captureVideo"], descendants: true }, { propertyName: "loadingOverlayRef", first: true, predicate: ["loadingOverlay"], descendants: true }, { propertyName: "applyBackgroundButtonRef", first: true, predicate: ["applyBackgroundButton"], descendants: true }, { propertyName: "saveBackgroundButtonRef", first: true, predicate: ["saveBackgroundButton"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, 0.5)', display: isVisible ? 'block' : 'none', zIndex: 999 }\">\r\n    <div [ngStyle]=\"{ position: 'fixed', backgroundColor: backgroundColor, borderRadius: '10px', padding: '10px', width: '80%', maxWidth: '500px', maxHeight: '75%', overflowY: 'auto', overflowX: 'hidden', top: position.includes('top') ? '10px' : 'auto', bottom: position.includes('bottom') ? '10px' : 'auto', left: position.includes('Left') ? '10px' : 'auto', right: position.includes('Right') ? '10px' : 'auto' }\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">Background Settings</h2>\r\n        <button (click)=\"onClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr style=\"height: 1px; background-color: black; margin-top: 5px; margin-bottom: 5px;\" />\r\n      <div style=\"max-width: 95%; overflow-x: auto;\">\r\n        <div id=\"defaultImages\" #defaultImagesContainer></div>\r\n        <div class=\"form-group\" style=\"max-width: 70%; overflow-x: auto;\">\r\n          <label for=\"uploadImage\">Upload Custom Image</label>\r\n          <input type=\"file\" class=\"form-control\" id=\"uploadImage\" #uploadImageInput (change)=\"handleImageUpload($event)\" />\r\n        </div>\r\n        <canvas id=\"mainCanvas\" #mainCanvas class=\"d-none\"></canvas>\r\n        <canvas id=\"backgroundCanvas\" #backgroundCanvas class=\"d-none\" style=\"width: 100%; max-width: 400px; height: auto; background-color: transparent; border: 1px solid black;\"></canvas>\r\n        <video id=\"captureVideo\" #captureVideo class=\"d-none\" muted autoplay playsinline></video>\r\n        <video id=\"previewVideo\" #videoPreview class=\"d-none\" muted autoplay playsinline style=\"width: 100%; max-width: 400px; height: auto; background-color: transparent; border: 1px solid black;\"></video>\r\n        <div id=\"loadingOverlay\" #loadingOverlay class=\"d-none\" [ngStyle]=\"{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, 0.5)', display: 'flex', 'justify-content': 'center', 'align-items': 'center', zIndex: 1000 }\">\r\n          <div [ngStyle]=\"{ width: '50px', height: '50px', border: '5px solid rgba(255, 255, 255, 0.3)', borderRadius: '50%', borderTop: '5px solid white', animation: 'spin 1s linear infinite' }\"></div>\r\n        </div>\r\n        <br />\r\n        <button id=\"applyBackgroundButton\" #applyBackgroundButton class=\"btn btn-primary\" (click)=\"applyBackground()\">Preview Background</button>\r\n        <button id=\"saveBackgroundButton\" #saveBackgroundButton class=\"btn btn-success d-none\" (click)=\"saveBackground()\">Save Background</button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n", styles: ["@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: BackgroundModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-background-modal', imports: [CommonModule, FontAwesomeModule], template: "<div [ngStyle]=\"{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, 0.5)', display: isVisible ? 'block' : 'none', zIndex: 999 }\">\r\n    <div [ngStyle]=\"{ position: 'fixed', backgroundColor: backgroundColor, borderRadius: '10px', padding: '10px', width: '80%', maxWidth: '500px', maxHeight: '75%', overflowY: 'auto', overflowX: 'hidden', top: position.includes('top') ? '10px' : 'auto', bottom: position.includes('bottom') ? '10px' : 'auto', left: position.includes('Left') ? '10px' : 'auto', right: position.includes('Right') ? '10px' : 'auto' }\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">Background Settings</h2>\r\n        <button (click)=\"onClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr style=\"height: 1px; background-color: black; margin-top: 5px; margin-bottom: 5px;\" />\r\n      <div style=\"max-width: 95%; overflow-x: auto;\">\r\n        <div id=\"defaultImages\" #defaultImagesContainer></div>\r\n        <div class=\"form-group\" style=\"max-width: 70%; overflow-x: auto;\">\r\n          <label for=\"uploadImage\">Upload Custom Image</label>\r\n          <input type=\"file\" class=\"form-control\" id=\"uploadImage\" #uploadImageInput (change)=\"handleImageUpload($event)\" />\r\n        </div>\r\n        <canvas id=\"mainCanvas\" #mainCanvas class=\"d-none\"></canvas>\r\n        <canvas id=\"backgroundCanvas\" #backgroundCanvas class=\"d-none\" style=\"width: 100%; max-width: 400px; height: auto; background-color: transparent; border: 1px solid black;\"></canvas>\r\n        <video id=\"captureVideo\" #captureVideo class=\"d-none\" muted autoplay playsinline></video>\r\n        <video id=\"previewVideo\" #videoPreview class=\"d-none\" muted autoplay playsinline style=\"width: 100%; max-width: 400px; height: auto; background-color: transparent; border: 1px solid black;\"></video>\r\n        <div id=\"loadingOverlay\" #loadingOverlay class=\"d-none\" [ngStyle]=\"{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, 0.5)', display: 'flex', 'justify-content': 'center', 'align-items': 'center', zIndex: 1000 }\">\r\n          <div [ngStyle]=\"{ width: '50px', height: '50px', border: '5px solid rgba(255, 255, 255, 0.3)', borderRadius: '50%', borderTop: '5px solid white', animation: 'spin 1s linear infinite' }\"></div>\r\n        </div>\r\n        <br />\r\n        <button id=\"applyBackgroundButton\" #applyBackgroundButton class=\"btn btn-primary\" (click)=\"applyBackground()\">Preview Background</button>\r\n        <button id=\"saveBackgroundButton\" #saveBackgroundButton class=\"btn btn-success d-none\" (click)=\"saveBackground()\">Save Background</button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n", styles: ["@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n"] }]
        }], propDecorators: { isVisible: [{
                type: Input
            }], parameters: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], onClose: [{
                type: Input
            }], defaultImagesContainerRef: [{
                type: ViewChild,
                args: ['defaultImagesContainer']
            }], uploadImageInputRef: [{
                type: ViewChild,
                args: ['uploadImageInput']
            }], backgroundCanvasRef: [{
                type: ViewChild,
                args: ['backgroundCanvas']
            }], videoPreviewRef: [{
                type: ViewChild,
                args: ['videoPreview']
            }], captureVideoRef: [{
                type: ViewChild,
                args: ['captureVideo']
            }], loadingOverlayRef: [{
                type: ViewChild,
                args: ['loadingOverlay']
            }], applyBackgroundButtonRef: [{
                type: ViewChild,
                args: ['applyBackgroundButton']
            }], saveBackgroundButtonRef: [{
                type: ViewChild,
                args: ['saveBackgroundButton']
            }] } });

class RoomListComponent {
    rooms = [];
    editRoom = new EventEmitter();
    deleteRoom = new EventEmitter();
    removeParticipant = new EventEmitter();
    faPen = faPen;
    faTimes = faTimes;
    faUsers = faUsers;
    handleEditRoom(roomIndex) {
        this.editRoom.emit(roomIndex);
    }
    handleDeleteRoom(roomIndex) {
        this.deleteRoom.emit(roomIndex);
    }
    handleRemoveParticipant(roomIndex, participant) {
        this.removeParticipant.emit({ roomIndex, participant });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RoomListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: RoomListComponent, isStandalone: true, selector: "app-room-list", inputs: { rooms: "rooms" }, outputs: { editRoom: "editRoom", deleteRoom: "deleteRoom", removeParticipant: "removeParticipant" }, ngImport: i0, template: "<div *ngFor=\"let room of rooms; let roomIndex = index\" class=\"card mb-3 text-dark\">\r\n    <div class=\"card-header d-flex justify-content-between align-items-center\">\r\n      <span>Room {{ roomIndex + 1 }} <fa-icon [icon]=\"faUsers\"></fa-icon></span>\r\n      <div>\r\n        <button class=\"btn btn-secondary btn-sm\" (click)=\"handleEditRoom(roomIndex)\">\r\n          <fa-icon [icon]=\"faPen\"></fa-icon>\r\n        </button>\r\n        <button class=\"btn btn-danger btn-sm\" (click)=\"handleDeleteRoom(roomIndex)\">\r\n          <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n        </button>\r\n      </div>\r\n    </div>\r\n    <div class=\"card-body\">\r\n      <ul class=\"list-group\">\r\n        <li *ngFor=\"let participant of room; let index = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n          {{ participant.name }}\r\n          <button class=\"btn btn-danger btn-sm\" (click)=\"handleRemoveParticipant(roomIndex, participant)\">\r\n            <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n          </button>\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RoomListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-room-list', imports: [CommonModule, FontAwesomeModule], template: "<div *ngFor=\"let room of rooms; let roomIndex = index\" class=\"card mb-3 text-dark\">\r\n    <div class=\"card-header d-flex justify-content-between align-items-center\">\r\n      <span>Room {{ roomIndex + 1 }} <fa-icon [icon]=\"faUsers\"></fa-icon></span>\r\n      <div>\r\n        <button class=\"btn btn-secondary btn-sm\" (click)=\"handleEditRoom(roomIndex)\">\r\n          <fa-icon [icon]=\"faPen\"></fa-icon>\r\n        </button>\r\n        <button class=\"btn btn-danger btn-sm\" (click)=\"handleDeleteRoom(roomIndex)\">\r\n          <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n        </button>\r\n      </div>\r\n    </div>\r\n    <div class=\"card-body\">\r\n      <ul class=\"list-group\">\r\n        <li *ngFor=\"let participant of room; let index = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n          {{ participant.name }}\r\n          <button class=\"btn btn-danger btn-sm\" (click)=\"handleRemoveParticipant(roomIndex, participant)\">\r\n            <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n          </button>\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n" }]
        }], propDecorators: { rooms: [{
                type: Input
            }], editRoom: [{
                type: Output
            }], deleteRoom: [{
                type: Output
            }], removeParticipant: [{
                type: Output
            }] } });

/**
 * EditRoomModalComponent allows managing participants within a breakout room for an event.
 *
 * @selector app-edit-room-modal
 * @inputs
 * - `editRoomModalVisible` (boolean): Controls the visibility of the edit room modal. Default is false.
 * - `currentRoom` (BreakoutParticipant[]): List of participants currently assigned to the room.
 * - `participantsRef` (Participant[]): Reference list of all participants.
 * - `currentRoomIndex` (number): Index of the room being edited.
 * - `position` (string): Position of the modal on the screen. Default is 'center'.
 * - `backgroundColor` (string): Background color of the modal. Default is '#fff'.
 *
 * @outputs
 * - `setEditRoomModalVisible` (EventEmitter<boolean>): Emits a boolean to toggle the visibility of the modal.
 * - `addParticipant` (EventEmitter<{ roomIndex: number; participant: Participant | BreakoutParticipant; }>): Emits data for adding a participant to the room.
 * - `removeParticipant` (EventEmitter<{ roomIndex: number; participant: Participant | BreakoutParticipant; }>): Emits data for removing a participant from the room.
 *
 * @methods
 * - `ngOnInit()`: Lifecycle hook to initialize modal width and attach resize event listener.
 * - `ngOnDestroy()`: Lifecycle hook to remove the resize event listener.
 * - `calculateModalWidth()`: Dynamically calculates and sets modal width based on screen width.
 * - `modalContainerStyle()`: Returns style object for modal container.
 * - `modalContentStyle()`: Returns style object for modal content.
 * - `handleAddParticipant(roomIndex: number, participant: BreakoutParticipant)`: Emits event to add participant to specified room.
 * - `handleRemoveParticipant(roomIndex: number, participant: BreakoutParticipant)`: Emits event to remove participant from specified room.
 * - `closeModal()`: Closes the modal by emitting a visibility change.
 * - `unassignedParticipants()`: Filters and returns a list of unassigned participants.
 *
 * @dependencies
 * - `CommonModule`: Provides Angular's common directives.
 * - `FontAwesomeModule`: Allows usage of Font Awesome icons.
 *
 * @example
 * ```html
 * <app-edit-room-modal
 *  [editRoomModalVisible]="editRoomModalVisible"
 * [currentRoom]="currentRoom"
 * [participantsRef]="participantsRef"
 * [currentRoomIndex]="currentRoomIndex"
 * [position]="position"
 * [backgroundColor]="backgroundColor"
 * (setEditRoomModalVisible)="setEditRoomModalVisible($event)"
 * (addParticipant)="addParticipant($event)"
 * (removeParticipant)="removeParticipant($event)">
 * </app-edit-room-modal>
 * ```
 *
 **/
class EditRoomModalComponent {
    editRoomModalVisible = false;
    currentRoom = [];
    participantsRef = [];
    currentRoomIndex = -1;
    position = 'center';
    backgroundColor = '#fff';
    setEditRoomModalVisible = new EventEmitter();
    addParticipant = new EventEmitter();
    removeParticipant = new EventEmitter();
    faTimes = faTimes;
    faPlus = faPlus;
    faUsers = faUsers;
    faPen = faPen;
    modalWidth = 400;
    ngOnInit() {
        this.calculateModalWidth();
        window.addEventListener('resize', this.calculateModalWidth.bind(this));
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.calculateModalWidth.bind(this));
    }
    calculateModalWidth() {
        const screenWidth = window.innerWidth;
        this.modalWidth = screenWidth > 500 ? 400 : screenWidth * 0.8;
    }
    modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            zIndex: 1000,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
        };
    }
    modalContentStyle() {
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '20px',
            width: `${this.modalWidth}px`,
            maxHeight: '80%',
            overflowY: 'auto',
        };
    }
    handleAddParticipant(roomIndex, participant) {
        this.addParticipant.emit({ roomIndex, participant });
    }
    handleRemoveParticipant(roomIndex, participant) {
        this.removeParticipant.emit({ roomIndex, participant });
    }
    closeModal() {
        this.setEditRoomModalVisible.emit(false);
    }
    unassignedParticipants() {
        return this.participantsRef.filter((participant) => participant['breakRoom'] == null);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: EditRoomModalComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: EditRoomModalComponent, isStandalone: true, selector: "app-edit-room-modal", inputs: { editRoomModalVisible: "editRoomModalVisible", currentRoom: "currentRoom", participantsRef: "participantsRef", currentRoomIndex: "currentRoomIndex", position: "position", backgroundColor: "backgroundColor" }, outputs: { setEditRoomModalVisible: "setEditRoomModalVisible", addParticipant: "addParticipant", removeParticipant: "removeParticipant" }, ngImport: i0, template: "<div *ngIf=\"editRoomModalVisible\" class=\"modal-container\" [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content text-dark\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <h5 class=\"modal-title\">Edit Room {{ currentRoomIndex + 1 }} <fa-icon [icon]=\"faPen\"></fa-icon></h5>\r\n      <button type=\"button\" class=\"close\" (click)=\"closeModal()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <div class=\"modal-body\">\r\n      <div class=\"list-container\">\r\n        <h5>Assigned Participants <fa-icon [icon]=\"faUsers\"></fa-icon></h5>\r\n        <ul class=\"list-group\">\r\n          <li *ngFor=\"let participant of currentRoom; let i = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            {{ participant.name }}\r\n            <button class=\"btn btn-danger btn-sm\" (click)=\"handleRemoveParticipant(currentRoomIndex, participant)\">\r\n              <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n            </button>\r\n          </li>\r\n          <li *ngIf=\"currentRoom.length === 0\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            None assigned\r\n          </li>\r\n        </ul>\r\n      </div>\r\n      <div class=\"list-container\">\r\n        <h5>Unassigned Participants <fa-icon [icon]=\"faUsers\"></fa-icon></h5>\r\n        <ul class=\"list-group\">\r\n          <li *ngFor=\"let participant of unassignedParticipants(); let i = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            {{ participant.name }}\r\n            <button class=\"btn btn-primary btn-sm\" (click)=\"handleAddParticipant(currentRoomIndex, participant)\">\r\n              <fa-icon [icon]=\"faPlus\"></fa-icon>\r\n            </button>\r\n          </li>\r\n          <li *ngIf=\"unassignedParticipants().length === 0\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            None pending\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button type=\"button\" class=\"btn btn-secondary\" (click)=\"closeModal()\">Close</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-content{background-color:#fff;border-radius:10px;padding:20px;max-width:500px;max-height:80%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}.modal-title{font-size:1.25rem;font-weight:700}.list-container{border:1px solid #ccc;border-radius:5px;padding:10px;margin-bottom:20px}.list-group-item{display:flex;justify-content:space-between;align-items:center}.modal-footer{display:flex;justify-content:flex-end;margin-top:20px}.close-button{border:none;background:none;cursor:pointer}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: EditRoomModalComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-edit-room-modal', imports: [CommonModule, FontAwesomeModule], template: "<div *ngIf=\"editRoomModalVisible\" class=\"modal-container\" [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content text-dark\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <h5 class=\"modal-title\">Edit Room {{ currentRoomIndex + 1 }} <fa-icon [icon]=\"faPen\"></fa-icon></h5>\r\n      <button type=\"button\" class=\"close\" (click)=\"closeModal()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <div class=\"modal-body\">\r\n      <div class=\"list-container\">\r\n        <h5>Assigned Participants <fa-icon [icon]=\"faUsers\"></fa-icon></h5>\r\n        <ul class=\"list-group\">\r\n          <li *ngFor=\"let participant of currentRoom; let i = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            {{ participant.name }}\r\n            <button class=\"btn btn-danger btn-sm\" (click)=\"handleRemoveParticipant(currentRoomIndex, participant)\">\r\n              <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n            </button>\r\n          </li>\r\n          <li *ngIf=\"currentRoom.length === 0\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            None assigned\r\n          </li>\r\n        </ul>\r\n      </div>\r\n      <div class=\"list-container\">\r\n        <h5>Unassigned Participants <fa-icon [icon]=\"faUsers\"></fa-icon></h5>\r\n        <ul class=\"list-group\">\r\n          <li *ngFor=\"let participant of unassignedParticipants(); let i = index\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            {{ participant.name }}\r\n            <button class=\"btn btn-primary btn-sm\" (click)=\"handleAddParticipant(currentRoomIndex, participant)\">\r\n              <fa-icon [icon]=\"faPlus\"></fa-icon>\r\n            </button>\r\n          </li>\r\n          <li *ngIf=\"unassignedParticipants().length === 0\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n            None pending\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button type=\"button\" class=\"btn btn-secondary\" (click)=\"closeModal()\">Close</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-content{background-color:#fff;border-radius:10px;padding:20px;max-width:500px;max-height:80%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}.modal-title{font-size:1.25rem;font-weight:700}.list-container{border:1px solid #ccc;border-radius:5px;padding:10px;margin-bottom:20px}.list-group-item{display:flex;justify-content:space-between;align-items:center}.modal-footer{display:flex;justify-content:flex-end;margin-top:20px}.close-button{border:none;background:none;cursor:pointer}\n"] }]
        }], propDecorators: { editRoomModalVisible: [{
                type: Input
            }], currentRoom: [{
                type: Input
            }], participantsRef: [{
                type: Input
            }], currentRoomIndex: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], setEditRoomModalVisible: [{
                type: Output
            }], addParticipant: [{
                type: Output
            }], removeParticipant: [{
                type: Output
            }] } });

/**
 * BreakoutRoomsModal component manages the creation, modification, and assignment of breakout rooms.
 *
 * @selector app-breakout-rooms-modal
 * @inputs
 * - `isVisible` (boolean): Controls the visibility of the breakout rooms modal. Default is false.
 * - `parameters` (BreakoutRoomsModalParameters): Parameters for managing breakout room settings and behavior.
 * - `position` (string): Position of the modal on the screen. Default is 'topRight'.
 * - `backgroundColor` (string): Background color of the modal. Default is '#83c0e9'.
 * - `onBreakoutRoomsClose` (function): Callback function triggered when the modal is closed.
 *
 * @methods
 * - `ngOnInit()`: Lifecycle hook to initialize modal width and breakout rooms.
 * - `ngOnChanges(changes: SimpleChanges)`: Lifecycle hook called when any data-bound input properties change.
 * - `calculateModalWidth()`: Dynamically calculates and sets modal width based on screen width.
 * - `modalContainerStyle()`: Returns style object for modal container.
 * - `modalContentStyle()`: Returns style object for modal content.
 * - `initializeBreakoutRooms()`: Initializes the breakout rooms based on the current participants and parameters.
 * - `handleRandomAssign()`: Randomly assigns participants to breakout rooms.
 * - `handleManualAssign()`: Initializes manual room assignment by setting empty breakout rooms.
 * - `handleAddRoom()`: Adds a new breakout room.
 * - `handleSaveRooms()`: Validates and saves breakout room configurations.
 * - `validateRooms()`: Validates room configurations and participants' uniqueness and quantity.
 * - `checkCanStartBreakout()`: Checks conditions to enable the start of breakout rooms.
 * - `handleStartBreakout()`: Starts the breakout session if conditions are met.
 * - `handleStopBreakout()`: Stops the breakout session and reverts to the initial meeting display type.
 * - `handleEditRoom(roomIndex: number)`: Opens the modal to edit the specified breakout room.
 * - `handleDeleteRoom(roomIndex: number)`: Deletes a breakout room and updates participants' room assignments.
 * - `handleAddParticipant(event)`: Adds a participant to a specified breakout room.
 * - `handleRemoveParticipant(event)`: Removes a participant from a specified breakout room.
 *
 * @dependencies
 * - `CommonModule`: Angular's common directives.
 * - `FormsModule`: Angular's forms module for form handling.
 * - `FontAwesomeModule`: Font Awesome icons for UI elements.
 * - `RoomListComponent`: Component for listing rooms.
 * - `EditRoomModalComponent`: Component for editing room participants.
 *
 * @example
 * ```html
 * <app-breakout-rooms-modal
 *  [isVisible]="isBreakoutRoomsModalVisible"
 * [parameters]="breakoutRoomsParams"
 * [position]="modalPosition"
 * [backgroundColor]="modalBgColor"
 * [onBreakoutRoomsClose]="onCloseBreakoutRooms">
 * </app-breakout-rooms-modal>
 * ```
 *
 **/
class BreakoutRoomsModal {
    isVisible = false;
    parameters;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    onBreakoutRoomsClose = () => {
        console.log('Breakout rooms closed');
    };
    roomsContainerRef;
    faDoorOpen = faDoorOpen;
    faTimes = faTimes;
    faRandom = faRandom;
    faHandPointer = faHandPointer;
    faPlus = faPlus;
    faSave = faSave;
    faPlay = faPlay;
    faSyncAlt = faSyncAlt;
    faStop = faStop;
    faUsers = faUsers;
    participantsRef = [];
    breakoutRoomsRef = [];
    numRooms = '';
    newParticipantAction = 'autoAssignNewRoom';
    currentRoom = null;
    editRoomModalVisible = false;
    startBreakoutButtonVisible = false;
    stopBreakoutButtonVisible = false;
    modalWidth = 400;
    calculateModalWidth() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.85 * screenWidth;
        if (modalWidth > 700) {
            modalWidth = 700;
        }
        this.modalWidth = modalWidth;
    }
    modalContainerStyle() {
        return {
            display: this.isVisible ? 'block' : 'none',
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            zIndex: '999',
        };
    }
    modalContentStyle() {
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${this.modalWidth}px`,
            maxHeight: '75%',
            overflowX: 'hidden',
            overflowY: 'auto',
            position: 'fixed',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    ngOnChanges(changes) {
        if (changes['isVisible'] && this.isVisible) {
            this.initializeBreakoutRooms();
        }
    }
    ngOnInit() {
        this.calculateModalWidth();
    }
    initializeBreakoutRooms = () => {
        this.parameters = this.parameters.getUpdatedAllParams();
        const filteredParticipants = this.parameters.participants.filter((participant) => participant.islevel != '2');
        this.participantsRef = filteredParticipants;
        this.breakoutRoomsRef =
            this.parameters.breakoutRooms && this.parameters.breakoutRooms.length > 0
                ? [...this.parameters.breakoutRooms]
                : [];
        this.checkCanStartBreakout();
    };
    handleRandomAssign() {
        const numRoomsInt = parseInt(this.numRooms);
        if (!numRoomsInt || numRoomsInt <= 0) {
            this.parameters.showAlert?.({
                message: 'Please enter a valid number of rooms',
                type: 'danger',
            });
            return;
        }
        const newBreakoutRooms = Array.from({ length: numRoomsInt }, () => []);
        const shuffledParticipants = [...this.participantsRef].sort(() => 0.5 - Math.random());
        shuffledParticipants.forEach((participant, index) => {
            const roomIndex = index % numRoomsInt;
            if (newBreakoutRooms[roomIndex].length < this.parameters.itemPageLimit) {
                const participant_ = { name: participant.name, breakRoom: roomIndex };
                newBreakoutRooms[roomIndex].push(participant_);
                participant['breakRoom'] = roomIndex;
            }
            else {
                for (let i = 0; i < numRoomsInt; i++) {
                    if (newBreakoutRooms[i].length < this.parameters.itemPageLimit) {
                        newBreakoutRooms[i].push(participant);
                        participant['breakRoom'] = i;
                        break;
                    }
                }
            }
        });
        this.breakoutRoomsRef = newBreakoutRooms;
        this.checkCanStartBreakout();
    }
    handleManualAssign() {
        const numRoomsInt = parseInt(this.numRooms);
        if (!numRoomsInt || numRoomsInt <= 0) {
            this.parameters.showAlert?.({
                message: 'Please enter a valid number of rooms',
                type: 'danger',
            });
            return;
        }
        this.breakoutRoomsRef = Array.from({ length: numRoomsInt }, () => []);
        this.parameters.updateCanStartBreakout(false);
        this.checkCanStartBreakout();
    }
    handleAddRoom() {
        this.breakoutRoomsRef = [...this.breakoutRoomsRef, []];
        this.parameters.updateCanStartBreakout(false);
        this.checkCanStartBreakout();
    }
    handleSaveRooms() {
        if (this.validateRooms()) {
            this.parameters.updateBreakoutRooms(this.breakoutRoomsRef);
            this.parameters.updateCanStartBreakout(true);
            this.checkCanStartBreakout();
            this.parameters.showAlert?.({ message: 'Rooms saved successfully', type: 'success' });
        }
        else {
            this.parameters.showAlert?.({ message: 'Rooms validation failed', type: 'danger' });
        }
    }
    validateRooms() {
        if (this.breakoutRoomsRef.length == 0) {
            this.parameters.showAlert?.({ message: 'There must be at least one room', type: 'danger' });
            return false;
        }
        for (let room of this.breakoutRoomsRef) {
            if (room.length == 0) {
                this.parameters.showAlert?.({ message: 'Rooms must not be empty', type: 'danger' });
                return false;
            }
            const participantNames = room.map((p) => p.name);
            const uniqueNames = new Set(participantNames);
            if (participantNames.length != uniqueNames.size) {
                this.parameters.showAlert?.({
                    message: 'Duplicate participant names in a room',
                    type: 'danger',
                });
                return false;
            }
            if (room.length > this.parameters.itemPageLimit) {
                this.parameters.showAlert?.({
                    message: 'A room exceeds the participant limit',
                    type: 'danger',
                });
                return false;
            }
        }
        return true;
    }
    checkCanStartBreakout = () => {
        this.parameters = this.parameters.getUpdatedAllParams();
        if (this.parameters.canStartBreakout) {
            this.startBreakoutButtonVisible = true;
            this.stopBreakoutButtonVisible =
                this.parameters.breakOutRoomStarted && !this.parameters.breakOutRoomEnded;
        }
        else {
            this.startBreakoutButtonVisible = false;
            this.stopBreakoutButtonVisible = false;
        }
    };
    handleStartBreakout = () => {
        this.parameters = this.parameters.getUpdatedAllParams();
        if (this.parameters.shareScreenStarted || this.parameters.shared) {
            this.parameters.showAlert?.({
                message: 'You cannot start breakout rooms while screen sharing is active',
                type: 'danger',
            });
            return;
        }
        if (this.parameters.canStartBreakout) {
            const emitName = this.parameters.breakOutRoomStarted && !this.parameters.breakOutRoomEnded
                ? 'updateBreakout'
                : 'startBreakout';
            const filteredBreakoutRooms = this.breakoutRoomsRef.map((room) => room.map(({ name, breakRoom }) => ({ name, breakRoom })));
            this.parameters.socket.emit(emitName, {
                breakoutRooms: filteredBreakoutRooms,
                newParticipantAction: this.newParticipantAction,
                roomName: this.parameters.roomName,
            }, (response) => {
                if (response.success) {
                    this.parameters.showAlert?.({ message: 'Breakout rooms active', type: 'success' });
                    this.parameters.updateBreakOutRoomStarted(true);
                    this.parameters.updateBreakOutRoomEnded(false);
                    this.onBreakoutRoomsClose();
                    if (this.parameters.meetingDisplayType != 'all') {
                        this.parameters.updateMeetingDisplayType('all');
                    }
                }
                else {
                    this.parameters.showAlert?.({ message: response.reason, type: 'danger' });
                }
            });
            if (this.parameters.localSocket && this.parameters.localSocket.id) {
                try {
                    this.parameters.localSocket.emit(emitName, {
                        breakoutRooms: filteredBreakoutRooms,
                        newParticipantAction: this.newParticipantAction,
                        roomName: this.parameters.roomName,
                    }, (response) => {
                        if (response.success) {
                            // do nothing
                        }
                    });
                }
                catch (error) {
                    console.log('Error starting local breakout rooms:');
                }
            }
        }
    };
    handleStopBreakout() {
        this.parameters.socket.emit('stopBreakout', { roomName: this.parameters.roomName }, (response) => {
            if (response.success) {
                this.parameters.showAlert?.({ message: 'Breakout rooms stopped', type: 'success' });
                this.parameters.updateBreakOutRoomStarted(false);
                this.parameters.updateBreakOutRoomEnded(true);
                this.onBreakoutRoomsClose();
                if (this.parameters.meetingDisplayType != this.parameters.prevMeetingDisplayType) {
                    this.parameters.updateMeetingDisplayType(this.parameters.prevMeetingDisplayType);
                }
            }
            else {
                this.parameters.showAlert?.({ message: response.reason, type: 'danger' });
            }
        });
        if (this.parameters.localSocket && this.parameters.localSocket.id) {
            try {
                this.parameters.localSocket.emit('stopBreakout', { roomName: this.parameters.roomName }, (response) => {
                    if (response.success) {
                        // do nothing
                    }
                });
            }
            catch (error) {
                console.log('Error starting local breakout rooms:');
            }
        }
    }
    handleEditRoom(roomIndex) {
        this.parameters.updateCurrentRoomIndex(roomIndex);
        this.currentRoom = this.breakoutRoomsRef[roomIndex];
        this.editRoomModalVisible = true;
        this.parameters.updateCanStartBreakout(false);
        this.checkCanStartBreakout();
    }
    handleDeleteRoom(roomIndex) {
        if (this.breakoutRoomsRef.length > 0) {
            const room = this.breakoutRoomsRef[roomIndex];
            room.forEach((participant) => (participant.breakRoom = null));
            const newBreakoutRooms = [...this.breakoutRoomsRef];
            newBreakoutRooms.splice(roomIndex, 1);
            newBreakoutRooms.forEach((room, index) => {
                room.forEach((participant) => (participant.breakRoom = index));
            });
            this.breakoutRoomsRef = newBreakoutRooms;
            this.checkCanStartBreakout();
        }
    }
    handleAddParticipant(event) {
        const { roomIndex, participant } = event;
        if (this.breakoutRoomsRef[roomIndex].length < this.parameters.itemPageLimit) {
            const newBreakoutRooms = [...this.breakoutRoomsRef];
            newBreakoutRooms[roomIndex].push(participant);
            this.breakoutRoomsRef = newBreakoutRooms;
            participant['breakRoom'] = roomIndex;
            if (this.parameters.currentRoomIndex != null) {
                this.handleEditRoom(this.parameters.currentRoomIndex);
            }
        }
        else {
            this.parameters.showAlert?.({ message: 'Room is full', type: 'danger' });
        }
    }
    handleRemoveParticipant(event) {
        const { roomIndex, participant } = event;
        const newBreakoutRooms = [...this.breakoutRoomsRef];
        newBreakoutRooms[roomIndex] = newBreakoutRooms[roomIndex].filter((p) => p != participant);
        this.breakoutRoomsRef = newBreakoutRooms;
        participant['breakRoom'] = null;
        if (this.parameters.currentRoomIndex != null) {
            this.handleEditRoom(this.parameters.currentRoomIndex);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: BreakoutRoomsModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: BreakoutRoomsModal, isStandalone: true, selector: "app-breakout-rooms-modal", inputs: { isVisible: "isVisible", parameters: "parameters", position: "position", backgroundColor: "backgroundColor", onBreakoutRoomsClose: "onBreakoutRoomsClose" }, viewQueries: [{ propertyName: "roomsContainerRef", first: true, predicate: ["roomsContainer"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isVisible\" class=\"modal-container\" [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <h2>Breakout Rooms <fa-icon [icon]=\"faDoorOpen\"></fa-icon></h2>\r\n      <button class=\"close-btn\" (click)=\"onBreakoutRoomsClose()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <hr>\r\n    <div class=\"form-group\">\r\n      <label for=\"numRooms\">Number of Rooms <fa-icon [icon]=\"faUsers\"></fa-icon></label>\r\n      <input type=\"number\" class=\"form-control\" id=\"numRooms\" [(ngModel)]=\"numRooms\">\r\n    </div>\r\n    <div class=\"form-group\">\r\n      <button class=\"btn btn-primary\" (click)=\"handleRandomAssign()\">Random Assign <fa-icon [icon]=\"faRandom\"></fa-icon></button>\r\n      <button class=\"btn btn-secondary\" (click)=\"handleManualAssign()\">Manual Assign <fa-icon [icon]=\"faHandPointer\"></fa-icon></button>\r\n      <button class=\"btn btn-success\" (click)=\"handleAddRoom()\">Add Room <fa-icon [icon]=\"faPlus\"></fa-icon></button>\r\n      <button class=\"btn btn-info\" (click)=\"handleSaveRooms()\">Save Rooms <fa-icon [icon]=\"faSave\"></fa-icon></button>\r\n    </div>\r\n    <div class=\"form-group\">\r\n      <label for=\"newParticipantAction\">New Participant Action <fa-icon [icon]=\"faUsers\"></fa-icon></label>\r\n      <select class=\"form-control\" id=\"newParticipantAction\" [(ngModel)]=\"newParticipantAction\">\r\n        <option value=\"autoAssignNewRoom\">Add to new room</option>\r\n        <option value=\"autoAssignAvailableRoom\">Add to open room</option>\r\n        <option value=\"manualAssign\">No action</option>\r\n      </select>\r\n    </div>\r\n    <div #roomsContainer>\r\n      <app-room-list [rooms]=\"breakoutRoomsRef\" (editRoom)=\"handleEditRoom($event)\" (deleteRoom)=\"handleDeleteRoom($event)\" (removeParticipant)=\"handleRemoveParticipant($event)\"></app-room-list>\r\n    </div>\r\n    <div *ngIf=\"startBreakoutButtonVisible\">\r\n      <button class=\"btn btn-primary mr-2 mb-2\" (click)=\"handleStartBreakout()\">\r\n        {{ parameters.breakOutRoomStarted && !parameters.breakOutRoomEnded ? 'Update Breakout' : 'Start Breakout' }} <fa-icon [icon]=\"parameters.breakOutRoomStarted && !parameters.breakOutRoomEnded ? faSyncAlt : faPlay\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <div *ngIf=\"stopBreakoutButtonVisible\">\r\n      <button class=\"btn btn-danger mr-2 mb-2\" (click)=\"handleStopBreakout()\">\r\n        Stop Breakout <fa-icon [icon]=\"faStop\"></fa-icon>\r\n      </button>\r\n    </div>\r\n  </div>\r\n  <app-edit-room-modal [editRoomModalVisible]=\"editRoomModalVisible\" [currentRoom]=\"currentRoom!\" [participantsRef]=\"participantsRef\" [currentRoomIndex]=\"parameters.currentRoomIndex!\" (setEditRoomModalVisible)=\"editRoomModalVisible = $event\" (addParticipant)=\"handleAddParticipant($event)\" (removeParticipant)=\"handleRemoveParticipant($event)\"></app-edit-room-modal>\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$2.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { kind: "directive", type: i2$2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: RoomListComponent, selector: "app-room-list", inputs: ["rooms"], outputs: ["editRoom", "deleteRoom", "removeParticipant"] }, { kind: "component", type: EditRoomModalComponent, selector: "app-edit-room-modal", inputs: ["editRoomModalVisible", "currentRoom", "participantsRef", "currentRoomIndex", "position", "backgroundColor"], outputs: ["setEditRoomModalVisible", "addParticipant", "removeParticipant"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: BreakoutRoomsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-breakout-rooms-modal', imports: [
                        CommonModule,
                        FormsModule,
                        FontAwesomeModule,
                        RoomListComponent,
                        EditRoomModalComponent,
                    ], template: "<div *ngIf=\"isVisible\" class=\"modal-container\" [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <h2>Breakout Rooms <fa-icon [icon]=\"faDoorOpen\"></fa-icon></h2>\r\n      <button class=\"close-btn\" (click)=\"onBreakoutRoomsClose()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <hr>\r\n    <div class=\"form-group\">\r\n      <label for=\"numRooms\">Number of Rooms <fa-icon [icon]=\"faUsers\"></fa-icon></label>\r\n      <input type=\"number\" class=\"form-control\" id=\"numRooms\" [(ngModel)]=\"numRooms\">\r\n    </div>\r\n    <div class=\"form-group\">\r\n      <button class=\"btn btn-primary\" (click)=\"handleRandomAssign()\">Random Assign <fa-icon [icon]=\"faRandom\"></fa-icon></button>\r\n      <button class=\"btn btn-secondary\" (click)=\"handleManualAssign()\">Manual Assign <fa-icon [icon]=\"faHandPointer\"></fa-icon></button>\r\n      <button class=\"btn btn-success\" (click)=\"handleAddRoom()\">Add Room <fa-icon [icon]=\"faPlus\"></fa-icon></button>\r\n      <button class=\"btn btn-info\" (click)=\"handleSaveRooms()\">Save Rooms <fa-icon [icon]=\"faSave\"></fa-icon></button>\r\n    </div>\r\n    <div class=\"form-group\">\r\n      <label for=\"newParticipantAction\">New Participant Action <fa-icon [icon]=\"faUsers\"></fa-icon></label>\r\n      <select class=\"form-control\" id=\"newParticipantAction\" [(ngModel)]=\"newParticipantAction\">\r\n        <option value=\"autoAssignNewRoom\">Add to new room</option>\r\n        <option value=\"autoAssignAvailableRoom\">Add to open room</option>\r\n        <option value=\"manualAssign\">No action</option>\r\n      </select>\r\n    </div>\r\n    <div #roomsContainer>\r\n      <app-room-list [rooms]=\"breakoutRoomsRef\" (editRoom)=\"handleEditRoom($event)\" (deleteRoom)=\"handleDeleteRoom($event)\" (removeParticipant)=\"handleRemoveParticipant($event)\"></app-room-list>\r\n    </div>\r\n    <div *ngIf=\"startBreakoutButtonVisible\">\r\n      <button class=\"btn btn-primary mr-2 mb-2\" (click)=\"handleStartBreakout()\">\r\n        {{ parameters.breakOutRoomStarted && !parameters.breakOutRoomEnded ? 'Update Breakout' : 'Start Breakout' }} <fa-icon [icon]=\"parameters.breakOutRoomStarted && !parameters.breakOutRoomEnded ? faSyncAlt : faPlay\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <div *ngIf=\"stopBreakoutButtonVisible\">\r\n      <button class=\"btn btn-danger mr-2 mb-2\" (click)=\"handleStopBreakout()\">\r\n        Stop Breakout <fa-icon [icon]=\"faStop\"></fa-icon>\r\n      </button>\r\n    </div>\r\n  </div>\r\n  <app-edit-room-modal [editRoomModalVisible]=\"editRoomModalVisible\" [currentRoom]=\"currentRoom!\" [participantsRef]=\"participantsRef\" [currentRoomIndex]=\"parameters.currentRoomIndex!\" (setEditRoomModalVisible)=\"editRoomModalVisible = $event\" (addParticipant)=\"handleAddParticipant($event)\" (removeParticipant)=\"handleRemoveParticipant($event)\"></app-edit-room-modal>\r\n</div>\r\n" }]
        }], propDecorators: { isVisible: [{
                type: Input
            }], parameters: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], onBreakoutRoomsClose: [{
                type: Input
            }], roomsContainerRef: [{
                type: ViewChild,
                args: ['roomsContainer']
            }] } });

/* eslint-disable @typescript-eslint/no-empty-function */
/**
 * CoHostModal component allows managing co-host settings for an event.
 *
 * @selector app-co-host-modal
 * @inputs
 * - `isCoHostModalVisible` (boolean): A boolean value that determines whether the modal is visible. Default is false.
 * - `currentCohost` (string): The current co-host for the event. Default is 'No coHost'.
 * - `participants` (Participant[]): An array of participants in the event.
 * - `coHostResponsibility` (CoHostResponsibility[]): An array of co-host responsibilities.
 * - `position` (string): The position of the modal. Default is 'topRight'.
 * - `backgroundColor` (string): The background color of the modal. Default is '#83c0e9'.
 * - `roomName` (string): The name of the room.
 * - `showAlert` (ShowAlert): A function to show alerts.
 *
 * @outputs
 * - `updateCoHostResponsibility` (coHostResponsibility: CoHostResponsibility[]): A function to update co-host responsibilities.
 * - `updateCoHost` (coHost: string): A function to update the co-host.
 * - `updateIsCoHostModalVisible` (isCoHostModalVisible: boolean): A function to update the visibility of the modal.
 * - `socket` (Socket): The socket object.
 *
 * @methods
 * - `ngOnInit()`: Lifecycle hook that is called after the component is initialized. It sets the default value for `onModifyCoHost` if not provided.
 * - `ngOnChanges(changes: SimpleChanges)`: Lifecycle hook that is called when any data-bound property of the component changes. It initializes the responsibilities and calculates the modal width.
 * - `initializeResponsibilities()`: Initializes the responsibilities.
 * - `get filteredParticipants()`: Returns the filtered participants.
 * - `handleToggleSwitch(key: string)`: Handles the toggle switch for the given key.
 * - `handleSave()`: Handles the save action.
 * - `handleClose()`: Handles the close action.
 * - `calculateModalWidth()`: Calculates the modal width.
 * - `modalContainerStyle()`: Returns the modal container style.
 * - `modalContentStyle()`: Returns the modal content style.
 *
 * @dependencies
 * - `CommonModule`: Angular's common module is imported for common directives.
 * - `FontAwesomeModule`: Angular's font awesome module is imported for icons.
 * - `FormsModule`: Angular's forms module is imported for form-related directives.
 * - `ModifyCoHostSettings`: The ModifyCoHostSettings service is used to modify co-host settings.
 *
 * @styles
 * - `.container`: The container style.
 *
 * @example
 * ```html
 * <app-co-host-modal
 *  [isCoHostModalVisible]="isCoHostModalVisible"
 * [currentCohost]="currentCohost"
 * [participants]="participants"
 * [coHostResponsibility]="coHostResponsibility"
 * [position]="position"
 * [backgroundColor]="backgroundColor"
 * [roomName]="roomName"
 * [showAlert]="showAlert"
 * [updateCoHostResponsibility]="updateCoHostResponsibility"
 * [updateCoHost]="updateCoHost"
 * [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
 * [socket]="socket"
 * [onCoHostClose]="onCoHostClose"
 * [onModifyCoHost]="onModifyCoHost">
 * </app-co-host-modal>
 * ```
 *
 **/
class CoHostModal {
    modifyCoHostSettingsService;
    isCoHostModalVisible = false;
    currentCohost = 'No coHost';
    participants = [];
    coHostResponsibility = [];
    position = 'topRight';
    backgroundColor = '#83c0e9';
    roomName = '';
    showAlert = () => { };
    updateCoHostResponsibility = () => { };
    updateCoHost = () => { };
    updateIsCoHostModalVisible = () => { };
    socket = {};
    onCoHostClose;
    onModifyCoHost;
    faTimes = faTimes;
    selectedCohost = this.currentCohost;
    CoHostResponsibilityCopy = [];
    CoHostResponsibilityCopyAlt = [];
    responsibilities = {};
    responsibilityKeys = [];
    modalWidth;
    constructor(modifyCoHostSettingsService) {
        this.modifyCoHostSettingsService = modifyCoHostSettingsService;
    }
    ngOnInit() {
        // Set default value for onModifyCoHost if not provided
        if (!this.onModifyCoHost) {
            this.onModifyCoHost = (params) => this.modifyCoHostSettingsService.modifyCoHostSettings(params);
        }
    }
    ngOnChanges(changes) {
        if (changes['isCoHostModalVisible'] && this.isCoHostModalVisible) {
            this.initializeResponsibilities();
            this.calculateModalWidth();
        }
    }
    initializeResponsibilities() {
        this.CoHostResponsibilityCopy = [...this.coHostResponsibility];
        this.CoHostResponsibilityCopyAlt = [...this.coHostResponsibility];
        this.responsibilityKeys = this.coHostResponsibility.map((item) => {
            const manageKey = `manage${item.name.charAt(0).toUpperCase() + item.name.slice(1)}`;
            const dedicateKey = `dedicateToManage${item.name.charAt(0).toUpperCase() + item.name.slice(1)}`;
            return { manageKey, dedicateKey };
        });
        const initialResponsibilities = this.CoHostResponsibilityCopyAlt.reduce((acc, item) => {
            const str2 = item.name.charAt(0).toUpperCase() + item.name.slice(1);
            acc[`manage${str2}`] = item.value;
            acc[`dedicateToManage${str2}`] = item.dedicated;
            return acc;
        }, {});
        this.responsibilities = initialResponsibilities;
    }
    get filteredParticipants() {
        return this.participants.filter((participant) => participant.name !== this.currentCohost && participant.islevel !== '2');
    }
    handleToggleSwitch(key) {
        if (key.startsWith('dedicateTo')) {
            const responsibilityName = key.replace('dedicateToManage', '').toLowerCase();
            const manageKey = `manage${responsibilityName.charAt(0).toUpperCase() + responsibilityName.slice(1)}`;
            // Ensure that the 'dedicated' checkbox can only be toggled if the corresponding 'responsibility' is checked
            if (this.responsibilities[manageKey]) {
                const responsibilityDedicated = this.CoHostResponsibilityCopy.find((item) => item.name === responsibilityName).dedicated;
                this.responsibilities[key] = !responsibilityDedicated;
                this.CoHostResponsibilityCopy.find((item) => item.name === responsibilityName).dedicated =
                    !responsibilityDedicated;
            }
        }
        else if (key.startsWith('manage')) {
            const responsibilityName = key.replace('manage', '').toLowerCase();
            const responsibilityValue = this.CoHostResponsibilityCopy.find((item) => item.name === responsibilityName).value;
            // Toggle the 'responsibility' checkbox and ensure the corresponding 'dedicated' checkbox is also disabled if unchecked
            this.responsibilities[key] = !responsibilityValue;
            this.CoHostResponsibilityCopy.find((item) => item.name === responsibilityName).value =
                !responsibilityValue;
            if (!this.responsibilities[key]) {
                const dedicateKey = `dedicateToManage${responsibilityName.charAt(0).toUpperCase() + responsibilityName.slice(1)}`;
                this.responsibilities[dedicateKey] = false;
                this.CoHostResponsibilityCopy.find((item) => item.name === responsibilityName).dedicated =
                    false;
            }
        }
    }
    handleSave() {
        this.onModifyCoHost({
            roomName: this.roomName,
            showAlert: this.showAlert,
            selectedParticipant: this.selectedCohost,
            coHost: this.currentCohost,
            coHostResponsibility: this.CoHostResponsibilityCopy,
            updateCoHostResponsibility: this.updateCoHostResponsibility,
            updateCoHost: this.updateCoHost,
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible,
            socket: this.socket,
        });
    }
    handleClose() {
        this.onCoHostClose();
    }
    calculateModalWidth() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 400) {
            modalWidth = 400;
        }
        this.modalWidth = modalWidth;
    }
    modalContainerStyle() {
        return {
            display: this.isCoHostModalVisible ? 'block' : 'none',
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            zIndex: '999',
        };
    }
    modalContentStyle() {
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${this.modalWidth}px`,
            maxHeight: '65%',
            overflowX: 'hidden',
            overflowY: 'auto',
            position: 'fixed',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CoHostModal, deps: [{ token: ModifyCoHostSettings }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: CoHostModal, isStandalone: true, selector: "app-co-host-modal", inputs: { isCoHostModalVisible: "isCoHostModalVisible", currentCohost: "currentCohost", participants: "participants", coHostResponsibility: "coHostResponsibility", position: "position", backgroundColor: "backgroundColor", roomName: "roomName", showAlert: "showAlert", updateCoHostResponsibility: "updateCoHostResponsibility", updateCoHost: "updateCoHost", updateIsCoHostModalVisible: "updateIsCoHostModalVisible", socket: "socket", onCoHostClose: "onCoHostClose", onModifyCoHost: "onModifyCoHost" }, usesOnChanges: true, ngImport: i0, template: "<!-- co-host-modal.component.html -->\r\n<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Manage Co-Host</div>\r\n      <div class=\"btn-close-settings\" (click)=\"handleClose()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label class=\"font-weight-bold\">Current Co-host:</label>\r\n        <input class=\"form-control\" [value]=\"currentCohost\" readonly />\r\n      </div>\r\n      <div class=\"form-group\">\r\n        <label class=\"font-weight-bold\">Select New Co-host:</label>\r\n        <select class=\"form-control\" [(ngModel)]=\"selectedCohost\">\r\n          <option value=\"\">Select a participant</option>\r\n          <option *ngFor=\"let participant of filteredParticipants\" [value]=\"participant.name\">\r\n            {{ participant.name }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <div class=\"row\">\r\n        <div class=\"col-5\">\r\n          <label style=\"font-weight: bold\">Responsibility</label>\r\n        </div>\r\n        <div class=\"col-3\">\r\n          <label style=\"font-weight: bold\">Select</label>\r\n        </div>\r\n        <div class=\"col-4\">\r\n          <label style=\"font-weight: bold\">Dedicated</label>\r\n        </div>\r\n      </div>\r\n      <div *ngFor=\"let key of responsibilityKeys\" class=\"row\" style=\"margin-bottom: 10px;\">\r\n        <div class=\"col-5\" style=\"font-weight: bold\">{{ key.manageKey.replace('manage', '') }}</div>\r\n        <div class=\"col-3\">\r\n          <input type=\"checkbox\" [(ngModel)]=\"responsibilities[key.manageKey]\" (change)=\"handleToggleSwitch(key.manageKey)\">\r\n        </div>\r\n        <div class=\"col-4\">\r\n          <input type=\"checkbox\" [(ngModel)]=\"responsibilities[key.dedicateKey]\" (change)=\"handleToggleSwitch(key.dedicateKey)\" [disabled]=\"!responsibilities[key.manageKey]\">\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"btn-apply-settings\" (click)=\"handleSave()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#e7caca80;z-index:999;display:flex;justify-content:center;align-items:center}.modal-content{background-color:#83c0e9;border-radius:10px;padding:10px;width:400px;max-height:65%;overflow-x:hidden;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center}.modal-title{font-size:1.25rem;font-weight:700}.btn-close-settings{cursor:pointer}.hr{margin:10px 0}.form-group{margin-bottom:15px}.modal-footer{display:flex;justify-content:flex-end}.btn-apply-settings{background-color:#007bff;color:#fff;border:none;padding:10px 20px;border-radius:5px;cursor:pointer}.btn-apply-settings:hover{background-color:#0056b3}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i2$2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CoHostModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-co-host-modal', imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<!-- co-host-modal.component.html -->\r\n<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Manage Co-Host</div>\r\n      <div class=\"btn-close-settings\" (click)=\"handleClose()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label class=\"font-weight-bold\">Current Co-host:</label>\r\n        <input class=\"form-control\" [value]=\"currentCohost\" readonly />\r\n      </div>\r\n      <div class=\"form-group\">\r\n        <label class=\"font-weight-bold\">Select New Co-host:</label>\r\n        <select class=\"form-control\" [(ngModel)]=\"selectedCohost\">\r\n          <option value=\"\">Select a participant</option>\r\n          <option *ngFor=\"let participant of filteredParticipants\" [value]=\"participant.name\">\r\n            {{ participant.name }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <div class=\"row\">\r\n        <div class=\"col-5\">\r\n          <label style=\"font-weight: bold\">Responsibility</label>\r\n        </div>\r\n        <div class=\"col-3\">\r\n          <label style=\"font-weight: bold\">Select</label>\r\n        </div>\r\n        <div class=\"col-4\">\r\n          <label style=\"font-weight: bold\">Dedicated</label>\r\n        </div>\r\n      </div>\r\n      <div *ngFor=\"let key of responsibilityKeys\" class=\"row\" style=\"margin-bottom: 10px;\">\r\n        <div class=\"col-5\" style=\"font-weight: bold\">{{ key.manageKey.replace('manage', '') }}</div>\r\n        <div class=\"col-3\">\r\n          <input type=\"checkbox\" [(ngModel)]=\"responsibilities[key.manageKey]\" (change)=\"handleToggleSwitch(key.manageKey)\">\r\n        </div>\r\n        <div class=\"col-4\">\r\n          <input type=\"checkbox\" [(ngModel)]=\"responsibilities[key.dedicateKey]\" (change)=\"handleToggleSwitch(key.dedicateKey)\" [disabled]=\"!responsibilities[key.manageKey]\">\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"btn-apply-settings\" (click)=\"handleSave()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#e7caca80;z-index:999;display:flex;justify-content:center;align-items:center}.modal-content{background-color:#83c0e9;border-radius:10px;padding:10px;width:400px;max-height:65%;overflow-x:hidden;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center}.modal-title{font-size:1.25rem;font-weight:700}.btn-close-settings{cursor:pointer}.hr{margin:10px 0}.form-group{margin-bottom:15px}.modal-footer{display:flex;justify-content:flex-end}.btn-apply-settings{background-color:#007bff;color:#fff;border:none;padding:10px 20px;border-radius:5px;cursor:pointer}.btn-apply-settings:hover{background-color:#0056b3}\n"] }]
        }], ctorParameters: () => [{ type: ModifyCoHostSettings }], propDecorators: { isCoHostModalVisible: [{
                type: Input
            }], currentCohost: [{
                type: Input
            }], participants: [{
                type: Input
            }], coHostResponsibility: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], roomName: [{
                type: Input
            }], showAlert: [{
                type: Input
            }], updateCoHostResponsibility: [{
                type: Input
            }], updateCoHost: [{
                type: Input
            }], updateIsCoHostModalVisible: [{
                type: Input
            }], socket: [{
                type: Input
            }], onCoHostClose: [{
                type: Input
            }], onModifyCoHost: [{
                type: Input
            }] } });

/**
 * AlertComponent displays an alert message of type 'success' or 'danger' with customizable options.
 * It can automatically hide after a set duration and includes a manual dismiss option.
 *
 * @selector app-alert-component
 * @standalone true
 * @imports CommonModule
 *
 * @inputs
 * - `visible` (boolean): Determines if the alert is visible. Default is false.
 * - `message` (string): The message displayed in the alert.
 * - `type` ('success' | 'danger'): Type of alert, either 'success' or 'danger'. Default is 'success'.
 * - `duration` (number): Duration in milliseconds for the alert to remain visible before hiding. Default is 4000 ms.
 * - `textColor` (string): Optional color for alert text. Default is 'black'.
 * - `onHide` (function): Optional callback invoked when the alert is hidden.
 *
 * @methods
 * - `ngOnChanges(changes: SimpleChanges)`: Lifecycle hook invoked on input changes; initiates auto-hide based on duration if `visible` is true.
 * - `handlePress()`: Manually hides the alert by invoking the `onHide` callback.
 *
 * @example
 * ```html
 * <app-alert-component
 *  [visible]="showAlert"
 * [message]="alertMessage"
 * [type]="alertType"
 * [duration]="5000"
 * [textColor]="alertTextColor"
 * [onHide]="onAlertHide">
 * </app-alert-component>
 * ```
 **/
class AlertComponent {
    visible = false;
    message = '';
    type = 'success';
    duration = 4000;
    textColor = 'black';
    onHide;
    alertType = 'success';
    ngOnChanges(changes) {
        if (changes['type']) {
            this.alertType = this.type;
        }
        if (changes['visible']) {
            if (this.visible) {
                setTimeout(() => {
                    this.onHide();
                }, this.duration);
            }
        }
    }
    handlePress() {
        this.onHide();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AlertComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: AlertComponent, isStandalone: true, selector: "app-alert-component", inputs: { visible: "visible", message: "message", type: "type", duration: "duration", textColor: "textColor", onHide: "onHide" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"visible\" (click)=\"handlePress()\" class=\"centeredView\">\r\n  <div [ngStyle]=\"{ 'background-color': alertType === 'success' ? 'green' : 'red' }\" class=\"modalView\">\r\n    <p [ngStyle]=\"{ color: textColor }\" class=\"modalText\">{{ message }}</p>\r\n  </div>\r\n</div>\r\n", styles: [".centeredView{display:flex;justify-content:center;align-items:center;position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;z-index:1000}.modalView{background-color:#fff;border-radius:10px;padding:20px;max-width:400px;box-shadow:0 4px 6px #0000001a}.modalText{color:#000;font-size:16px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AlertComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-alert-component', imports: [CommonModule], template: "<div *ngIf=\"visible\" (click)=\"handlePress()\" class=\"centeredView\">\r\n  <div [ngStyle]=\"{ 'background-color': alertType === 'success' ? 'green' : 'red' }\" class=\"modalView\">\r\n    <p [ngStyle]=\"{ color: textColor }\" class=\"modalText\">{{ message }}</p>\r\n  </div>\r\n</div>\r\n", styles: [".centeredView{display:flex;justify-content:center;align-items:center;position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;z-index:1000}.modalView{background-color:#fff;border-radius:10px;padding:20px;max-width:400px;box-shadow:0 4px 6px #0000001a}.modalText{color:#000;font-size:16px}\n"] }]
        }], propDecorators: { visible: [{
                type: Input
            }], message: [{
                type: Input
            }], type: [{
                type: Input
            }], duration: [{
                type: Input
            }], textColor: [{
                type: Input
            }], onHide: [{
                type: Input
            }] } });

/**
 * AudioGrid component renders a dynamic grid of components with individually provided inputs.
 *
 * @selector app-audio-grid
 * @standalone true
 * @imports CommonModule
 *
 * @inputs
 * - `componentsToRender` ({ component: any; inputs?: any }[]): Array of components with optional inputs to render in the grid.
 *
 * @methods
 * - `ngOnChanges(changes: SimpleChanges)`: Clears the injector cache on changes to `componentsToRender`.
 * - `createInjector(inputs: any)`: Creates and caches an injector with specific inputs for each component.
 * - `clearInjectorCache()`: Clears the cache to avoid memory leaks and ensure updated injectors.
 *
 * @example
 * ```html
 * <app-audio-grid [componentsToRender]="[{ component: AudioCard, inputs: { name: 'Participant 1' } }]"></app-audio-grid>
 * ```
 **/
class AudioGrid {
    injector;
    componentsToRender = [];
    injectorCache = new WeakMap();
    constructor(injector) {
        this.injector = injector;
    }
    ngOnChanges(changes) {
        if (changes['componentsToRender']) {
            this.clearInjectorCache();
        }
    }
    createInjector(inputs) {
        if (!this.injectorCache.has(inputs)) {
            const injector = Injector.create({
                providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
                parent: this.injector,
            });
            this.injectorCache.set(inputs, injector);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.injectorCache.get(inputs);
    }
    clearInjectorCache() {
        this.injectorCache = new WeakMap();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AudioGrid, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: AudioGrid, isStandalone: true, selector: "app-audio-grid", inputs: { componentsToRender: "componentsToRender" }, usesOnChanges: true, ngImport: i0, template: `
    <div style="z-index: 9">
      <ng-container *ngFor="let item of componentsToRender; let i = index">
        <div style="z-index: 9" [attr.key]="i">
          <ng-container
            *ngComponentOutlet="item.component; injector: createInjector(item.inputs)"
          ></ng-container>
        </div>
      </ng-container>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AudioGrid, decorators: [{
            type: Component,
            args: [{ selector: 'app-audio-grid', imports: [CommonModule], template: `
    <div style="z-index: 9">
      <ng-container *ngFor="let item of componentsToRender; let i = index">
        <div style="z-index: 9" [attr.key]="i">
          <ng-container
            *ngComponentOutlet="item.component; injector: createInjector(item.inputs)"
          ></ng-container>
        </div>
      </ng-container>
    </div>
  ` }]
        }], ctorParameters: () => [{ type: i0.Injector }], propDecorators: { componentsToRender: [{
                type: Input
            }] } });

class ControlButtonsComponent {
    buttons = [];
    buttonColor = '';
    buttonBackgroundColor = {};
    alignment = 'flex-start';
    vertical = false;
    buttonsContainerStyle = {};
    // Function to get the alignment styles dynamically
    getAlignmentStyle() {
        const alignmentMap = {
            center: { 'justify-content': 'center' },
            'flex-end': { 'justify-content': 'flex-end' },
            'space-between': { 'justify-content': 'space-between' },
            'space-around': { 'justify-content': 'space-around' },
            'space-evenly': { 'justify-content': 'space-evenly' },
            'flex-start': { 'justify-content': 'flex-start' },
        };
        return {
            display: 'flex',
            flexDirection: this.vertical ? 'column' : 'row',
            ...alignmentMap[this.alignment],
        };
    }
    // Utility function to merge multiple styles into one object
    mergeStyles(...styles) {
        return Object.assign({}, ...styles);
    }
    isCustomComponent(comp) {
        return (comp &&
            typeof comp === 'object' &&
            'component' in comp &&
            typeof comp.component === 'function' &&
            'injector' in comp);
    }
    isFunctionComponent(comp) {
        return typeof comp === 'function';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlButtonsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ControlButtonsComponent, isStandalone: true, selector: "app-control-buttons-component", inputs: { buttons: "buttons", buttonColor: "buttonColor", buttonBackgroundColor: "buttonBackgroundColor", alignment: "alignment", vertical: "vertical", buttonsContainerStyle: "buttonsContainerStyle" }, ngImport: i0, template: `
    <div class="container" [ngStyle]="mergeStyles(getAlignmentStyle(), buttonsContainerStyle)">
      <button
        *ngFor="let button of buttons; let i = index"
        class="buttonContainer"
        [ngClass]="{ verticalButton: vertical }"
        [ngStyle]="{
          'background-color': button.show
            ? buttonBackgroundColor?.default || 'transparent'
            : 'transparent',
          display: button.show ? 'flex' : 'none'
        }"
        [disabled]="button.disabled"
        (click)="button.onPress ? button.onPress() : null"
      >
        <!-- Custom component when defined -->
        <ng-container *ngIf="button.customComponent; else iconTemplate">
          <ng-container *ngIf="isCustomComponent(button.customComponent)">
            <ng-container
              *ngComponentOutlet="
                button.customComponent.component;
                injector: button.customComponent.injector
              "
            ></ng-container>
          </ng-container>
          <ng-container
            *ngIf="
              !isCustomComponent(button.customComponent) &&
              !isFunctionComponent(button.customComponent)
            "
          >
            <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
            <div [innerHTML]="button.customComponent.outerHTML"></div>
          </ng-container>
        </ng-container>

        <!-- Icon logic for active/inactive states -->
        <ng-template #iconTemplate>
          <ng-container *ngIf="button.active && button.alternateIconComponent; else defaultIcon">
            <!-- Alternate icon component when button is active -->
            <ng-container *ngIf="isCustomComponent(button.alternateIconComponent)">
              <ng-container
                *ngComponentOutlet="
                  button.alternateIconComponent.component;
                  injector: button.alternateIconComponent.injector
                "
              ></ng-container>
            </ng-container>
            <ng-container
              *ngIf="
                !isCustomComponent(button.alternateIconComponent) &&
                !isFunctionComponent(button.alternateIconComponent)
              "
            >
              <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
              <div [innerHTML]="button.alternateIconComponent.outerHTML"></div>
            </ng-container>
          </ng-container>

          <!-- Default icon fallback for active/inactive states -->
          <ng-template #defaultIcon>
            <fa-icon
              *ngIf="button.active"
              [icon]="button.alternateIcon! || button.icon"
              [style.color]="button.activeColor || 'transparent'"
            ></fa-icon>
            <fa-icon
              *ngIf="!button.active"
              [icon]="button.icon!"
              [style.color]="button.inActiveColor || '#ffffff'"
            ></fa-icon>
          </ng-template>
        </ng-template>

        <!-- Button text -->
        <span
          *ngIf="button.name"
          class="buttonText"
          [ngStyle]="{ color: button.color || '#ffffff' }"
        >
          {{ button.name }}
        </span>
      </button>
    </div>
  `, isInline: true, styles: [".container{display:flex;width:100%;flex-direction:row;margin-top:0}.buttonContainer{display:flex;align-items:center;justify-content:center;padding:8px;border-radius:5px;margin-right:4px;font-size:medium;border:none}.buttonContainer:hover{cursor:pointer}.verticalButton{flex-direction:column}.buttonText{font-size:12px;margin-top:5px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlButtonsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-control-buttons-component', imports: [CommonModule, FontAwesomeModule], template: `
    <div class="container" [ngStyle]="mergeStyles(getAlignmentStyle(), buttonsContainerStyle)">
      <button
        *ngFor="let button of buttons; let i = index"
        class="buttonContainer"
        [ngClass]="{ verticalButton: vertical }"
        [ngStyle]="{
          'background-color': button.show
            ? buttonBackgroundColor?.default || 'transparent'
            : 'transparent',
          display: button.show ? 'flex' : 'none'
        }"
        [disabled]="button.disabled"
        (click)="button.onPress ? button.onPress() : null"
      >
        <!-- Custom component when defined -->
        <ng-container *ngIf="button.customComponent; else iconTemplate">
          <ng-container *ngIf="isCustomComponent(button.customComponent)">
            <ng-container
              *ngComponentOutlet="
                button.customComponent.component;
                injector: button.customComponent.injector
              "
            ></ng-container>
          </ng-container>
          <ng-container
            *ngIf="
              !isCustomComponent(button.customComponent) &&
              !isFunctionComponent(button.customComponent)
            "
          >
            <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
            <div [innerHTML]="button.customComponent.outerHTML"></div>
          </ng-container>
        </ng-container>

        <!-- Icon logic for active/inactive states -->
        <ng-template #iconTemplate>
          <ng-container *ngIf="button.active && button.alternateIconComponent; else defaultIcon">
            <!-- Alternate icon component when button is active -->
            <ng-container *ngIf="isCustomComponent(button.alternateIconComponent)">
              <ng-container
                *ngComponentOutlet="
                  button.alternateIconComponent.component;
                  injector: button.alternateIconComponent.injector
                "
              ></ng-container>
            </ng-container>
            <ng-container
              *ngIf="
                !isCustomComponent(button.alternateIconComponent) &&
                !isFunctionComponent(button.alternateIconComponent)
              "
            >
              <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
              <div [innerHTML]="button.alternateIconComponent.outerHTML"></div>
            </ng-container>
          </ng-container>

          <!-- Default icon fallback for active/inactive states -->
          <ng-template #defaultIcon>
            <fa-icon
              *ngIf="button.active"
              [icon]="button.alternateIcon! || button.icon"
              [style.color]="button.activeColor || 'transparent'"
            ></fa-icon>
            <fa-icon
              *ngIf="!button.active"
              [icon]="button.icon!"
              [style.color]="button.inActiveColor || '#ffffff'"
            ></fa-icon>
          </ng-template>
        </ng-template>

        <!-- Button text -->
        <span
          *ngIf="button.name"
          class="buttonText"
          [ngStyle]="{ color: button.color || '#ffffff' }"
        >
          {{ button.name }}
        </span>
      </button>
    </div>
  `, styles: [".container{display:flex;width:100%;flex-direction:row;margin-top:0}.buttonContainer{display:flex;align-items:center;justify-content:center;padding:8px;border-radius:5px;margin-right:4px;font-size:medium;border:none}.buttonContainer:hover{cursor:pointer}.verticalButton{flex-direction:column}.buttonText{font-size:12px;margin-top:5px}\n"] }]
        }], propDecorators: { buttons: [{
                type: Input
            }], buttonColor: [{
                type: Input
            }], buttonBackgroundColor: [{
                type: Input
            }], alignment: [{
                type: Input
            }], vertical: [{
                type: Input
            }], buttonsContainerStyle: [{
                type: Input
            }] } });

/**
 * ControlButtonsAltComponent provides configurable button controls with custom icons, colors, and positioning options.
 *
 * @selector app-control-buttons-alt-component
 * @standalone true
 * @imports CommonModule, FontAwesomeModule
 *
 * @inputs
 * - `buttons` (AltButton[]): Array of button configurations with options for icon, color, state, and actions.
 * - `position` ('left' | 'right' | 'middle'): Horizontal alignment of buttons. Default is 'left'.
 * - `location` ('top' | 'bottom' | 'center'): Vertical alignment of buttons. Default is 'top'.
 * - `direction` ('horizontal' | 'vertical'): Layout direction for buttons. Default is 'horizontal'.
 * - `buttonsContainerStyle` (Partial<CSSStyleDeclaration>): Custom styles for the container of buttons.
 * - `showAspect` (boolean): Controls the visibility of the button container. Default is false.
 *
 * @methods
 * - `getAlignmentStyle()`: Returns alignment styles based on `position`, `location`, and `direction`.
 * - `getContainerStyle()`: Combines container styles, alignment styles, and visibility settings.
 * - `getButtonStyle(button: AltButton)`: Applies style to each button based on its properties.
 * - `getTextStyle(button: AltButton)`: Sets text styles for button labels.
 * - `isCustomComponent(comp)`: Type guard to identify custom component objects.
 * - `isFunctionComponent(comp)`: Type guard to identify function components.
 *
 * @example
 * ```html
 * <app-control-buttons-alt-component
 *  [buttons]="[
 *    { name: 'Pause', icon: faPause, onPress: pauseAction, activeColor: 'blue' },
 *    { name: 'Play', icon: faPlay, onPress: playAction, color: 'green' }
 *  ]"
 * [position]="'middle'"
 * [location]="'bottom'"
 * [direction]="'vertical'"
 * [buttonsContainerStyle]="{ backgroundColor: '#333' }"
 * [showAspect]="true">
 * </app-control-buttons-alt-component>
 * ```
 **/
class ControlButtonsAltComponent {
    buttons = [];
    position = 'left';
    location = 'top';
    direction = 'horizontal';
    buttonsContainerStyle = {};
    showAspect = false;
    getAlignmentStyle() {
        let alignmentStyle = {};
        if (this.position === 'left' || this.position === 'right' || this.position === 'middle') {
            alignmentStyle.justifyContent =
                this.position === 'left' ? 'flex-start' : this.position === 'right' ? 'flex-end' : 'center';
        }
        if (this.location === 'top' || this.location === 'bottom' || this.location === 'center') {
            alignmentStyle.alignItems =
                this.location === 'top' ? 'flex-start' : this.location === 'bottom' ? 'flex-end' : 'center';
        }
        alignmentStyle.flexDirection = this.direction === 'vertical' ? 'column' : 'row';
        return alignmentStyle;
    }
    getContainerStyle() {
        return {
            ...this.styles.container,
            ...this.getAlignmentStyle(),
            ...this.buttonsContainerStyle,
            display: this.showAspect ? 'flex' : 'none',
        };
    }
    getButtonStyle(button) {
        return {
            ...this.styles.buttonContainer,
            backgroundColor: button.backgroundColor?.default || 'transparent',
            ...(this.direction === 'vertical' ? this.styles.verticalButton : {}),
        };
    }
    getTextStyle(button) {
        return {
            ...this.styles.buttonText,
            color: button.color || '#ffffff',
        };
    }
    isCustomComponent(comp) {
        return (comp &&
            typeof comp === 'object' &&
            'component' in comp &&
            typeof comp.component === 'function' &&
            'injector' in comp);
    }
    isFunctionComponent(comp) {
        return typeof comp === 'function';
    }
    styles = {
        container: {
            marginTop: '5px',
            marginBottom: '5px',
            zIndex: 9,
        },
        buttonContainer: {
            display: 'flex',
            alignItems: 'center',
            padding: '10px',
            borderRadius: '5px',
            marginLeft: '5px',
            marginRight: '5px',
            cursor: 'pointer',
        },
        verticalButton: {
            flexDirection: 'column',
        },
        buttonText: {
            fontSize: '12px',
            marginTop: '5px',
        },
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlButtonsAltComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ControlButtonsAltComponent, isStandalone: true, selector: "app-control-buttons-alt-component", inputs: { buttons: "buttons", position: "position", location: "location", direction: "direction", buttonsContainerStyle: "buttonsContainerStyle", showAspect: "showAspect" }, ngImport: i0, template: "<div [ngStyle]=\"getContainerStyle()\">\r\n  <div\r\n    *ngFor=\"let button of buttons; let i = index\"\r\n    [ngStyle]=\"getButtonStyle(button)\"\r\n    (click)=\"button.onPress && button.onPress()\"\r\n  >\r\n    <ng-container *ngIf=\"button.icon\">\r\n      <fa-icon\r\n        *ngIf=\"button.active\"\r\n        [icon]=\"button.alternateIcon || button.icon\"\r\n        [style.color]=\"button.inActiveColor || 'transparent'\"\r\n      ></fa-icon>\r\n      <fa-icon\r\n        *ngIf=\"!button.active\"\r\n        [icon]=\"button.icon\"\r\n        [style.color]=\"button.inActiveColor || 'transparent'\"\r\n      ></fa-icon>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"!button.icon\">\r\n      <ng-container *ngIf=\"button.customComponent\">\r\n        <ng-container *ngIf=\"isCustomComponent(button.customComponent)\">\r\n          <ng-container\r\n            *ngComponentOutlet=\"\r\n              button.customComponent.component;\r\n              injector: button.customComponent.injector\r\n            \"\r\n          ></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!isCustomComponent(button.customComponent) && !isFunctionComponent(button.customComponent)\">\r\n          <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->\r\n          <div [innerHTML]=\"button.customComponent.outerHTML\"></div>\r\n        </ng-container>\r\n      </ng-container>\r\n    </ng-container>\r\n    <span *ngIf=\"button.name\" [ngStyle]=\"getTextStyle(button)\">{{\r\n      button.name\r\n    }}</span>\r\n  </div>\r\n</div>\r\n", styles: [".container{margin-top:5px;margin-bottom:5px;z-index:9}.buttonContainer{display:flex;align-items:center;padding:10px;border-radius:5px;margin-left:5px;margin-right:5px;cursor:pointer}.verticalButton{flex-direction:column}.buttonText{font-size:12px;margin-top:5px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlButtonsAltComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-control-buttons-alt-component', imports: [CommonModule, FontAwesomeModule], template: "<div [ngStyle]=\"getContainerStyle()\">\r\n  <div\r\n    *ngFor=\"let button of buttons; let i = index\"\r\n    [ngStyle]=\"getButtonStyle(button)\"\r\n    (click)=\"button.onPress && button.onPress()\"\r\n  >\r\n    <ng-container *ngIf=\"button.icon\">\r\n      <fa-icon\r\n        *ngIf=\"button.active\"\r\n        [icon]=\"button.alternateIcon || button.icon\"\r\n        [style.color]=\"button.inActiveColor || 'transparent'\"\r\n      ></fa-icon>\r\n      <fa-icon\r\n        *ngIf=\"!button.active\"\r\n        [icon]=\"button.icon\"\r\n        [style.color]=\"button.inActiveColor || 'transparent'\"\r\n      ></fa-icon>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"!button.icon\">\r\n      <ng-container *ngIf=\"button.customComponent\">\r\n        <ng-container *ngIf=\"isCustomComponent(button.customComponent)\">\r\n          <ng-container\r\n            *ngComponentOutlet=\"\r\n              button.customComponent.component;\r\n              injector: button.customComponent.injector\r\n            \"\r\n          ></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!isCustomComponent(button.customComponent) && !isFunctionComponent(button.customComponent)\">\r\n          <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->\r\n          <div [innerHTML]=\"button.customComponent.outerHTML\"></div>\r\n        </ng-container>\r\n      </ng-container>\r\n    </ng-container>\r\n    <span *ngIf=\"button.name\" [ngStyle]=\"getTextStyle(button)\">{{\r\n      button.name\r\n    }}</span>\r\n  </div>\r\n</div>\r\n", styles: [".container{margin-top:5px;margin-bottom:5px;z-index:9}.buttonContainer{display:flex;align-items:center;padding:10px;border-radius:5px;margin-left:5px;margin-right:5px;cursor:pointer}.verticalButton{flex-direction:column}.buttonText{font-size:12px;margin-top:5px}\n"] }]
        }], propDecorators: { buttons: [{
                type: Input
            }], position: [{
                type: Input
            }], location: [{
                type: Input
            }], direction: [{
                type: Input
            }], buttonsContainerStyle: [{
                type: Input
            }], showAspect: [{
                type: Input
            }] } });

/**
 * ControlButtonsComponentTouch provides customizable touch controls with various icons, colors, and alignment options.
 *
 * @selector app-control-buttons-component-touch
 * @standalone true
 * @imports CommonModule, FontAwesomeModule
 *
 * @inputs
 * - `buttons` (ButtonTouch[]): Array of button configurations with properties for icon, color, action, and visibility.
 * - `position` ('left' | 'right' | 'middle'): Horizontal alignment of the buttons container. Default is 'left'.
 * - `location` ('top' | 'bottom' | 'center'): Vertical alignment of the buttons container. Default is 'top'.
 * - `direction` ('horizontal' | 'vertical'): Layout direction of buttons. Default is 'horizontal'.
 * - `buttonsContainerStyle` (Partial<CSSStyleDeclaration>): Custom styles for the buttons container.
 * - `showAspect` (boolean): Controls the visibility of the buttons container. Default is false.
 *
 * @methods
 * - `getAlignmentStyle()`: Returns alignment styles based on `position`, `location`, and `direction` inputs.
 * - `mergeStyles(...styles: any[])`: Merges multiple style objects into one for flexible styling.
 * - `isCustomComponent(comp)`: Type guard for identifying custom component objects.
 * - `isFunctionComponent(comp)`: Type guard for identifying function components.
 *
 * @example
 * ```html
 * <app-control-buttons-component-touch
 *   [buttons]="[
 *     { name: 'Mute', icon: faMicrophoneSlash, onPress: muteAction, activeColor: 'red' },
 *     { name: 'Unmute', icon: faMicrophone, onPress: unmuteAction, activeColor: 'green' }
 *   ]"
 *   position="right"
 *   location="bottom"
 *   direction="vertical"
 *   [buttonsContainerStyle]="{ backgroundColor: '#333' }"
 *   [showAspect]="true"
 * ></app-control-buttons-component-touch>
 * ```
 **/
class ControlButtonsComponentTouch {
    buttons = [];
    position = 'left';
    location = 'top';
    direction = 'horizontal';
    buttonsContainerStyle = {};
    showAspect = false;
    getAlignmentStyle() {
        let alignmentStyle = {};
        if (this.position === 'left' || this.position === 'right' || this.position === 'middle') {
            alignmentStyle['justify-content'] =
                this.position === 'left' ? 'flex-start' : this.position === 'right' ? 'flex-end' : 'center';
        }
        if (this.location === 'top' || this.location === 'bottom' || this.location === 'center') {
            alignmentStyle['align-items'] =
                this.location === 'top' ? 'flex-start' : this.location === 'bottom' ? 'flex-end' : 'center';
        }
        if (this.direction === 'vertical') {
            alignmentStyle['flex-direction'] = 'column';
        }
        else {
            alignmentStyle['flex-direction'] = 'row';
        }
        return alignmentStyle;
    }
    mergeStyles(...styles) {
        return Object.assign({}, ...styles);
    }
    isCustomComponent(comp) {
        return (comp &&
            typeof comp === 'object' &&
            'component' in comp &&
            typeof comp.component === 'function' &&
            'injector' in comp);
    }
    isFunctionComponent(comp) {
        return typeof comp === 'function';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlButtonsComponentTouch, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ControlButtonsComponentTouch, isStandalone: true, selector: "app-control-buttons-component-touch", inputs: { buttons: "buttons", position: "position", location: "location", direction: "direction", buttonsContainerStyle: "buttonsContainerStyle", showAspect: "showAspect" }, ngImport: i0, template: `
    <div
      [ngStyle]="
        mergeStyles(getAlignmentStyle(), buttonsContainerStyle, {
          position: 'absolute',
          bottom: '0',
          left: '0',
          right: '0',
          'margin-top': '5px',
          'margin-bottom': '5px',
          elevation: '9',
          'z-index': '9',
          'background-color': 'transparent',
          display: showAspect ? 'flex' : 'none'
        })
      "
    >
      <button
        *ngFor="let button of buttons"
        [ngStyle]="
          mergeStyles(
            {
              'align-items': 'center',
              padding: '10px',
              'border-radius': '5px',
              'margin-right': '5px',
              'margin-left': '5px',
              'margin-bottom': '5px',
              'margin-top': '5px',
              cursor: 'pointer',
              'background-color': button.show
                ? button.backgroundColor?.default || 'rgba(255, 255, 255, 0.25)'
                : 'transparent',
              border: 'none',
              display: button.show
                ? 'flex'
                : button.inActiveColor === 'transparent' && button.activeColor === 'transparent'
                ? 'flex'
                : 'none'
            },
            direction === 'vertical' ? { 'flex-direction': 'column' } : {}
          )
        "
        (click)="button.onPress ? button.onPress() : null"
        [disabled]="button.disabled"
      >
        <ng-container *ngIf="button.icon">
          <fa-icon
            *ngIf="button.active"
            [icon]="button.alternateIcon || button.icon"
            [style.color]="button.activeColor || 'transparent'"
          ></fa-icon>
          <fa-icon
            *ngIf="!button.active"
            [icon]="button.icon"
            [style.color]="button.inActiveColor || 'transparent'"
          ></fa-icon>
        </ng-container>
        <ng-container *ngIf="!button.icon">
          <ng-container *ngIf="button.customComponent">
            <ng-container *ngIf="isCustomComponent(button.customComponent)">
              <ng-container
                *ngComponentOutlet="
                  button.customComponent.component;
                  injector: button.customComponent.injector
                "
              ></ng-container>
            </ng-container>
            <ng-container
              *ngIf="
                !isCustomComponent(button.customComponent) &&
                !isFunctionComponent(button.customComponent)
              "
            >
              <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
              <div [innerHTML]="button.customComponent.outerHTML"></div>
            </ng-container>
          </ng-container>
        </ng-container>
        <span
          *ngIf="button.name"
          [ngStyle]="{
            color: button.color || 'transparent',
            'font-size': '12px',
            'margin-top': '5px'
          }"
        >
          {{ button.name }}
        </span>
      </button>
    </div>
  `, isInline: true, styles: [":host{display:flex;justify-content:center;align-items:center}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ControlButtonsComponentTouch, decorators: [{
            type: Component,
            args: [{ selector: 'app-control-buttons-component-touch', imports: [CommonModule, FontAwesomeModule], template: `
    <div
      [ngStyle]="
        mergeStyles(getAlignmentStyle(), buttonsContainerStyle, {
          position: 'absolute',
          bottom: '0',
          left: '0',
          right: '0',
          'margin-top': '5px',
          'margin-bottom': '5px',
          elevation: '9',
          'z-index': '9',
          'background-color': 'transparent',
          display: showAspect ? 'flex' : 'none'
        })
      "
    >
      <button
        *ngFor="let button of buttons"
        [ngStyle]="
          mergeStyles(
            {
              'align-items': 'center',
              padding: '10px',
              'border-radius': '5px',
              'margin-right': '5px',
              'margin-left': '5px',
              'margin-bottom': '5px',
              'margin-top': '5px',
              cursor: 'pointer',
              'background-color': button.show
                ? button.backgroundColor?.default || 'rgba(255, 255, 255, 0.25)'
                : 'transparent',
              border: 'none',
              display: button.show
                ? 'flex'
                : button.inActiveColor === 'transparent' && button.activeColor === 'transparent'
                ? 'flex'
                : 'none'
            },
            direction === 'vertical' ? { 'flex-direction': 'column' } : {}
          )
        "
        (click)="button.onPress ? button.onPress() : null"
        [disabled]="button.disabled"
      >
        <ng-container *ngIf="button.icon">
          <fa-icon
            *ngIf="button.active"
            [icon]="button.alternateIcon || button.icon"
            [style.color]="button.activeColor || 'transparent'"
          ></fa-icon>
          <fa-icon
            *ngIf="!button.active"
            [icon]="button.icon"
            [style.color]="button.inActiveColor || 'transparent'"
          ></fa-icon>
        </ng-container>
        <ng-container *ngIf="!button.icon">
          <ng-container *ngIf="button.customComponent">
            <ng-container *ngIf="isCustomComponent(button.customComponent)">
              <ng-container
                *ngComponentOutlet="
                  button.customComponent.component;
                  injector: button.customComponent.injector
                "
              ></ng-container>
            </ng-container>
            <ng-container
              *ngIf="
                !isCustomComponent(button.customComponent) &&
                !isFunctionComponent(button.customComponent)
              "
            >
              <!-- Handle the HTMLElement case, e.g., render it using [innerHTML] -->
              <div [innerHTML]="button.customComponent.outerHTML"></div>
            </ng-container>
          </ng-container>
        </ng-container>
        <span
          *ngIf="button.name"
          [ngStyle]="{
            color: button.color || 'transparent',
            'font-size': '12px',
            'margin-top': '5px'
          }"
        >
          {{ button.name }}
        </span>
      </button>
    </div>
  `, styles: [":host{display:flex;justify-content:center;align-items:center}\n"] }]
        }], propDecorators: { buttons: [{
                type: Input
            }], position: [{
                type: Input
            }], location: [{
                type: Input
            }], direction: [{
                type: Input
            }], buttonsContainerStyle: [{
                type: Input
            }], showAspect: [{
                type: Input
            }] } });

/**
 * FlexibleGrid is a dynamic, customizable grid component that renders a specified number of rows and columns,
 * with each grid item containing a provided component.
 *
 * @selector app-flexible-grid
 * @standalone true
 * @imports CommonModule
 *
 * @inputs
 * - `customWidth` (number): The width for each grid item in pixels. Default is 0.
 * - `customHeight` (number): The height for each grid item in pixels. Default is 0.
 * - `rows` (number): Number of rows in the grid. Default is 0.
 * - `columns` (number): Number of columns in the grid. Default is 0.
 * - `componentsToRender` ({ component: any, inputs?: any }[]): Array of components to render in the grid, each with optional inputs.
 * - `backgroundColor` (string): Background color for each grid item. Default is 'transparent'.
 *
 * @methods
 * - `ngOnInit()`: Initializes and generates the grid on component load.
 * - `ngOnChanges(changes: SimpleChanges)`: Regenerates the grid if `columns`, `componentsToRender`, or `rows` change.
 * - `generateGrid()`: Builds the grid based on the row, column, and component configurations.
 * - `getGridItemStyle()`: Returns a style object for each grid item, including custom width, height, and background color.
 * - `createInjector(inputs: any)`: Creates a cached injector for each component to support dynamic component inputs.
 *
 * @example
 * ```html
 * <app-flexible-grid
 *   [customWidth]="100"
 *   [customHeight]="100"
 *   [rows]="2"
 *   [columns]="3"
 *   [componentsToRender]="[{ component: MyComponent, inputs: { prop: 'value' } }]"
 *   backgroundColor="lightgrey"
 * ></app-flexible-grid>
 * ```
 **/
class FlexibleGrid {
    injector;
    customWidth = 0;
    customHeight = 0;
    rows = 0;
    columns = 0;
    componentsToRender = [];
    backgroundColor = 'transparent';
    grid = [];
    injectorCache = new WeakMap();
    constructor(injector) {
        this.injector = injector;
    }
    ngOnInit() {
        this.generateGrid();
    }
    ngOnChanges(changes) {
        if (changes['columns'] || changes['componentsToRender'] || changes['rows']) {
            this.generateGrid();
        }
    }
    generateGrid() {
        this.grid = [];
        for (let row = 0; row < this.rows; row++) {
            const rowComponents = [];
            for (let col = 0; col < this.columns; col++) {
                const index = row * this.columns + col;
                const component = this.componentsToRender[index];
                rowComponents.push(component);
            }
            this.grid.push(rowComponents);
        }
    }
    getGridItemStyle() {
        return {
            flex: 1,
            width: this.customWidth + 'px',
            height: this.customHeight + 'px',
            backgroundColor: this.backgroundColor,
            margin: '1px',
            padding: 0,
            borderRadius: '8px',
        };
    }
    createInjector(inputs) {
        if (!this.injectorCache.has(inputs)) {
            const injector = Injector.create({
                providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
                parent: this.injector,
            });
            this.injectorCache.set(inputs, injector);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.injectorCache.get(inputs);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: FlexibleGrid, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: FlexibleGrid, isStandalone: true, selector: "app-flexible-grid", inputs: { customWidth: "customWidth", customHeight: "customHeight", rows: "rows", columns: "columns", componentsToRender: "componentsToRender", backgroundColor: "backgroundColor" }, usesOnChanges: true, ngImport: i0, template: `
    <div style="padding: 0;">
      <div
        *ngFor="let rowComponents of grid; let rowIndex = index"
        style="display: flex; flex-direction: row;"
      >
        <div
          *ngFor="let component of rowComponents; let colIndex = index"
          [ngStyle]="getGridItemStyle()"
        >
          <ng-container
            *ngComponentOutlet="component.component; injector: createInjector(component.inputs)"
          ></ng-container>
        </div>
      </div>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: FlexibleGrid, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-flexible-grid',
                    imports: [CommonModule],
                    template: `
    <div style="padding: 0;">
      <div
        *ngFor="let rowComponents of grid; let rowIndex = index"
        style="display: flex; flex-direction: row;"
      >
        <div
          *ngFor="let component of rowComponents; let colIndex = index"
          [ngStyle]="getGridItemStyle()"
        >
          <ng-container
            *ngComponentOutlet="component.component; injector: createInjector(component.inputs)"
          ></ng-container>
        </div>
      </div>
    </div>
  `
                }]
        }], ctorParameters: () => [{ type: i0.Injector }], propDecorators: { customWidth: [{
                type: Input
            }], customHeight: [{
                type: Input
            }], rows: [{
                type: Input
            }], columns: [{
                type: Input
            }], componentsToRender: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }] } });

/**
 * FlexibleVideo component displays a customizable video grid, supporting dynamic layout and optional screenboard overlay.
 *
 * @selector app-flexible-video
 * @standalone true
 * @imports CommonModule
 *
 * @inputs
 * - `customWidth` (number): The custom width for each video grid item in pixels. Default is 0.
 * - `customHeight` (number): The custom height for each video grid item in pixels. Default is 0.
 * - `rows` (number): Number of rows in the video grid. Default is 0.
 * - `columns` (number): Number of columns in the video grid. Default is 0.
 * - `componentsToRender` (CustomMediaComponent[]): Array of components to render in the grid.
 * - `showAspect` (boolean): Flag to control aspect ratio display. Default is false.
 * - `backgroundColor` (string): Background color for the video grid. Default is 'transparent'.
 * - `Screenboard` (CustomMediaComponent): Optional screenboard component to overlay on the grid.
 * - `annotateScreenStream` (boolean): Flag to annotate the screen stream. Default is false.
 * - `localStreamScreen` (MediaStream): Local screen stream for video.
 *
 * @methods
 * - `ngOnInit()`: Initializes and generates the grid on component load if `showAspect` is true.
 * - `ngOnChanges(changes: SimpleChanges)`: Updates grid layout and dimensions if properties change.
 * - `generateGrid()`: Generates grid structure based on rows, columns, and `componentsToRender`.
 * - `createInjector(inputs: any)`: Creates and caches an injector for component inputs.
 *
 * @example
 * ```html
 * <app-flexible-video
 *   [customWidth]="300"
 *   [customHeight]="200"
 *   [rows]="2"
 *   [columns]="3"
 *   [componentsToRender]="[{ component: VideoComponent, inputs: { stream: videoStream } }]"
 *   showAspect="true"
 *   [Screenboard]="{ component: ScreenOverlayComponent, inputs: { overlayData: data } }"
 * ></app-flexible-video>
 * ```
 **/
class FlexibleVideo {
    injector;
    customWidth = 0;
    customHeight = 0;
    rows = 0;
    columns = 0;
    componentsToRender = [];
    showAspect = false;
    backgroundColor = 'transparent';
    Screenboard;
    annotateScreenStream = false;
    localStreamScreen;
    key = 0;
    cardWidth = 0;
    cardHeight = 0;
    cardTop = 0;
    cardLeft = 0;
    canvasLeft = 0;
    grid = [];
    injectorCache = new WeakMap();
    constructor(injector) {
        this.injector = injector;
    }
    ngOnInit() {
        if (this.showAspect) {
            this.generateGrid();
        }
    }
    ngOnChanges(changes) {
        if (changes['columns'] ||
            changes['rows'] ||
            changes['componentsToRender'] ||
            changes['customWidth'] ||
            changes['customHeight']) {
            if (this.showAspect) {
                this.key++;
                this.generateGrid();
            }
        }
        if (this.annotateScreenStream && this.localStreamScreen) {
            const videoHeight = this.localStreamScreen.getVideoTracks()[0].getSettings().height || 0;
            const videoWidth = this.localStreamScreen.getVideoTracks()[0].getSettings().width || 0;
            this.cardWidth = videoWidth;
            this.cardHeight = videoHeight;
            this.cardTop = Math.floor((this.customHeight - videoHeight) / 2);
            this.cardLeft = Math.floor((this.customWidth - videoWidth) / 2);
            this.canvasLeft = this.cardLeft < 0 ? this.cardLeft : 0;
        }
        else {
            this.cardWidth = this.customWidth;
            this.cardHeight = this.customHeight;
            this.cardTop = 0;
            this.cardLeft = 0;
            this.canvasLeft = 0;
        }
    }
    generateGrid() {
        this.grid = [];
        for (let row = 0; row < this.rows; row++) {
            const rowComponents = [];
            for (let col = 0; col < this.columns; col++) {
                const index = row * this.columns + col;
                const component = this.componentsToRender[index];
                rowComponents.push(component);
            }
            this.grid.push(rowComponents);
        }
    }
    createInjector(inputs) {
        if (!this.injectorCache.has(inputs)) {
            const injector = Injector.create({
                providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
                parent: this.injector,
            });
            this.injectorCache.set(inputs, injector);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.injectorCache.get(inputs);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: FlexibleVideo, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: FlexibleVideo, isStandalone: true, selector: "app-flexible-video", inputs: { customWidth: "customWidth", customHeight: "customHeight", rows: "rows", columns: "columns", componentsToRender: "componentsToRender", showAspect: "showAspect", backgroundColor: "backgroundColor", Screenboard: "Screenboard", annotateScreenStream: "annotateScreenStream", localStreamScreen: "localStreamScreen" }, usesOnChanges: true, ngImport: i0, template: `
    <div
      style="padding: 0; flex: 1; margin: 0; position: relative; display: {{
        showAspect ? 'flex' : 'none'
      }};
             max-width: {{ customWidth }}px; overflow-x: hidden; overflow-y: auto; left: {{
        cardLeft > 0 ? cardLeft : 0
      }}px;"
    >
      <div
        *ngFor="let rowComponents of grid; let rowIndex = index"
        style="display: flex; flex-direction: row;"
      >
        <div
          *ngFor="let component of rowComponents; let colIndex = index"
          [ngStyle]="{
            flex: 1,
            width: cardWidth + 'px',
            height: cardHeight + 'px',
            backgroundColor: backgroundColor,
            margin: '1px',
            padding: 0,
            borderRadius: '0px',
            left: cardLeft + 'px'
          }"
        >
          <ng-container
            *ngComponentOutlet="component.component; injector: createInjector(component.inputs)"
          ></ng-container>
        </div>
      </div>
      <div
        *ngIf="Screenboard && Screenboard.component"
        [ngStyle]="{
          position: 'absolute',
          top: '0',
          left: canvasLeft + 'px',
          width: cardWidth + 'px',
          height: cardHeight + 'px',
          backgroundColor: 'rgba(0, 0, 0, 0.005)',
          zIndex: '2'
        }"
      >
        <ng-container
          *ngComponentOutlet="Screenboard.component; injector: createInjector(Screenboard.inputs)"
        ></ng-container>
      </div>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: FlexibleVideo, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-flexible-video',
                    imports: [CommonModule],
                    template: `
    <div
      style="padding: 0; flex: 1; margin: 0; position: relative; display: {{
        showAspect ? 'flex' : 'none'
      }};
             max-width: {{ customWidth }}px; overflow-x: hidden; overflow-y: auto; left: {{
        cardLeft > 0 ? cardLeft : 0
      }}px;"
    >
      <div
        *ngFor="let rowComponents of grid; let rowIndex = index"
        style="display: flex; flex-direction: row;"
      >
        <div
          *ngFor="let component of rowComponents; let colIndex = index"
          [ngStyle]="{
            flex: 1,
            width: cardWidth + 'px',
            height: cardHeight + 'px',
            backgroundColor: backgroundColor,
            margin: '1px',
            padding: 0,
            borderRadius: '0px',
            left: cardLeft + 'px'
          }"
        >
          <ng-container
            *ngComponentOutlet="component.component; injector: createInjector(component.inputs)"
          ></ng-container>
        </div>
      </div>
      <div
        *ngIf="Screenboard && Screenboard.component"
        [ngStyle]="{
          position: 'absolute',
          top: '0',
          left: canvasLeft + 'px',
          width: cardWidth + 'px',
          height: cardHeight + 'px',
          backgroundColor: 'rgba(0, 0, 0, 0.005)',
          zIndex: '2'
        }"
      >
        <ng-container
          *ngComponentOutlet="Screenboard.component; injector: createInjector(Screenboard.inputs)"
        ></ng-container>
      </div>
    </div>
  `
                }]
        }], ctorParameters: () => [{ type: i0.Injector }], propDecorators: { customWidth: [{
                type: Input
            }], customHeight: [{
                type: Input
            }], rows: [{
                type: Input
            }], columns: [{
                type: Input
            }], componentsToRender: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], Screenboard: [{
                type: Input
            }], annotateScreenStream: [{
                type: Input
            }], localStreamScreen: [{
                type: Input
            }] } });

/**
 * LoadingModal displays a loading spinner and a customizable "Loading..." text as an overlay.
 *
 * @selector app-loading-modal
 * @standalone true
 * @imports CommonModule
 *
 * @inputs
 * - `isVisible` (boolean): Controls the visibility of the modal overlay. Default is `false`.
 * - `backgroundColor` (string): Background color of the modal overlay. Default is `'rgba(0, 0, 0, 0.5)'`.
 * - `displayColor` (string): Color of the loading text. Default is `'white'`.
 *
 * @properties
 * - `modalContainerStyle` (object): Computed styles for the modal container.
 * - `modalContentStyle` (object): Computed styles for the modal content.
 * - `spinnerContainerStyle` (object): Computed styles for the spinner container.
 * - `loadingTextStyle` (object): Computed styles for the loading text.
 *
 * @example
 * ```html
 * <app-loading-modal
 *   [isVisible]="true"
 *   [backgroundColor]="'rgba(0, 0, 0, 0.5)'"
 *   [displayColor]="'white'">
 * </app-loading-modal>
 * ```
 *
 * @styles
 * - `.spinner`: Styles for the loading spinner.
 * - `@keyframes spin`: Keyframes for the spinner rotation animation.
 * - `.modal-content`: Styles for the modal content container.
 * - `.loading-text`: Styles for the loading text.
 **/
class LoadingModal {
    isVisible = false;
    backgroundColor = 'rgba(0, 0, 0, 0.5)';
    displayColor = 'white';
    get modalContainerStyle() {
        return {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: this.backgroundColor,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: '999',
        };
    }
    get modalContentStyle() {
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            maxWidth: '200px',
            textAlign: 'center',
        };
    }
    get spinnerContainerStyle() {
        return {
            marginBottom: '20px',
        };
    }
    get loadingTextStyle() {
        return {
            color: this.displayColor,
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LoadingModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: LoadingModal, isStandalone: true, selector: "app-loading-modal", inputs: { isVisible: "isVisible", backgroundColor: "backgroundColor", displayColor: "displayColor" }, ngImport: i0, template: `
    <div *ngIf="isVisible" [ngStyle]="modalContainerStyle">
      <div [ngStyle]="modalContentStyle" class="modal-content">
        <div class="spinner" [ngStyle]="spinnerContainerStyle"></div>
        <div [ngStyle]="loadingTextStyle" class="loading-text">Loading...</div>
      </div>
    </div>
  `, isInline: true, styles: [".spinner{border:12px solid #f3f3f3;border-top:12px solid black;border-radius:50%;width:50px;height:50px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.modal-content{display:flex;flex-direction:column;align-items:center}.loading-text{margin-top:10px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: LoadingModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-loading-modal', imports: [CommonModule], template: `
    <div *ngIf="isVisible" [ngStyle]="modalContainerStyle">
      <div [ngStyle]="modalContentStyle" class="modal-content">
        <div class="spinner" [ngStyle]="spinnerContainerStyle"></div>
        <div [ngStyle]="loadingTextStyle" class="loading-text">Loading...</div>
      </div>
    </div>
  `, styles: [".spinner{border:12px solid #f3f3f3;border-top:12px solid black;border-radius:50%;width:50px;height:50px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.modal-content{display:flex;flex-direction:column;align-items:center}.loading-text{margin-top:10px}\n"] }]
        }], propDecorators: { isVisible: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], displayColor: [{
                type: Input
            }] } });

/**
 * MainAspectComponent dynamically adjusts its aspect ratio based on window size, providing an adaptable container for content.
 * It listens for window resize and orientation changes to update its layout, making it suitable for responsive applications.
 *
 * @selector app-main-aspect-component
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * ```html
 * <div [ngStyle]="aspectStyles" [style.backgroundColor]="backgroundColor" class="aspect-container">
 *   <ng-content></ng-content>
 * </div>
 * ```
 *
 * @styles
 * - `.aspect-container`: Styles for overflow handling.
 *
 * @inputs
 * - `backgroundColor` (string): The background color of the aspect container.
 * - `showControls` (boolean): Toggles control display, adjusting the container height. Default is true.
 * - `containerWidthFraction` (number): Fraction of window width for container width. Default is 1.
 * - `containerHeightFraction` (number): Fraction of window height for container height. Default is 1.
 * - `defaultFraction` (number): Height adjustment factor when controls are shown. Default is 0.94.
 * - `updateIsWideScreen` (function): Callback to set wide screen status.
 * - `updateIsMediumScreen` (function): Callback to set medium screen status.
 * - `updateIsSmallScreen` (function): Callback to set small screen status.
 *
 * @methods
 * - `ngOnInit()`: Initializes component and sets up resize and orientation listeners.
 * - `ngOnChanges(changes: SimpleChanges)`: Updates layout when relevant inputs change.
 * - `ngOnDestroy()`: Removes event listeners to prevent memory leaks.
 * - `updateAspectStyles()`: Calculates and applies styles based on current window dimensions and component inputs.
 *
 * @example
 * ```html
 * <app-main-aspect-component
 *   [backgroundColor]="'lightblue'"
 *   [showControls]="true"
 *   [containerWidthFraction]="0.9"
 *   [containerHeightFraction]="0.8"
 *   [defaultFraction]="0.95"
 *   [updateIsWideScreen]="onWideScreenUpdate"
 *   [updateIsMediumScreen]="onMediumScreenUpdate"
 *   [updateIsSmallScreen]="onSmallScreenUpdate"
 * ></app-main-aspect-component>
 * ```
 **/
class MainAspectComponent {
    backgroundColor = '';
    showControls = true;
    containerWidthFraction = 1;
    containerHeightFraction = 1;
    defaultFraction = 0.94;
    updateIsWideScreen;
    updateIsMediumScreen;
    updateIsSmallScreen;
    aspectStyles = {};
    ngOnInit() {
        this.updateAspectStyles();
        window.addEventListener('resize', this.updateAspectStyles);
        window.addEventListener('orientationchange', this.updateAspectStyles);
    }
    ngOnChanges(changes) {
        if (changes['showControls'] ||
            changes['containerWidthFraction'] ||
            changes['containerHeightFraction'] ||
            changes['defaultFraction']) {
            this.updateAspectStyles();
        }
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.updateAspectStyles);
        window.removeEventListener('orientationchange', this.updateAspectStyles);
    }
    updateAspectStyles = () => {
        const windowHeight = window.innerHeight;
        const windowWidth = window.innerWidth;
        const parentWidth = Math.floor(this.containerWidthFraction * windowWidth);
        const parentHeight = this.showControls
            ? Math.floor(this.containerHeightFraction * windowHeight * this.defaultFraction)
            : Math.floor(this.containerHeightFraction * windowHeight);
        let isWideScreen = parentWidth >= 768;
        const isMediumScreen = parentWidth >= 576 && parentWidth < 768;
        const isSmallScreen = parentWidth < 576;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        this.updateIsMediumScreen(isMediumScreen);
        this.updateIsSmallScreen(isSmallScreen);
        this.aspectStyles = {
            height: parentHeight + 'px',
            width: parentWidth + 'px',
        };
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MainAspectComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MainAspectComponent, isStandalone: true, selector: "app-main-aspect-component", inputs: { backgroundColor: "backgroundColor", showControls: "showControls", containerWidthFraction: "containerWidthFraction", containerHeightFraction: "containerHeightFraction", defaultFraction: "defaultFraction", updateIsWideScreen: "updateIsWideScreen", updateIsMediumScreen: "updateIsMediumScreen", updateIsSmallScreen: "updateIsSmallScreen" }, usesOnChanges: true, ngImport: i0, template: `
    <div
      [ngStyle]="aspectStyles"
      [style.backgroundColor]="backgroundColor"
      class="aspect-container"
    >
      <ng-content></ng-content>
    </div>
  `, isInline: true, styles: [".aspect-container{overflow:hidden}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MainAspectComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-main-aspect-component', imports: [CommonModule], template: `
    <div
      [ngStyle]="aspectStyles"
      [style.backgroundColor]="backgroundColor"
      class="aspect-container"
    >
      <ng-content></ng-content>
    </div>
  `, styles: [".aspect-container{overflow:hidden}\n"] }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], showControls: [{
                type: Input
            }], containerWidthFraction: [{
                type: Input
            }], containerHeightFraction: [{
                type: Input
            }], defaultFraction: [{
                type: Input
            }], updateIsWideScreen: [{
                type: Input
            }], updateIsMediumScreen: [{
                type: Input
            }], updateIsSmallScreen: [{
                type: Input
            }] } });

/**
 * MainContainerComponent dynamically adjusts its styles based on input properties and window size,
 * providing a responsive container for content.
 *
 * @selector app-main-container-component
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * ```html
 * <div [ngStyle]="containerStyles">
 *   <ng-content></ng-content>
 * </div>
 * ```
 *
 * @inputs
 * - `backgroundColor` (string): Background color of the container.
 * - `containerWidthFraction` (number): Fraction of the window width the container should occupy. Default is 1.
 * - `containerHeightFraction` (number): Fraction of the window height the container should occupy. Default is 1.
 * - `marginLeft` (number): Left margin of the container in pixels.
 * - `marginRight` (number): Right margin of the container in pixels.
 * - `marginTop` (number): Top margin of the container in pixels.
 * - `marginBottom` (number): Bottom margin of the container in pixels.
 * - `padding` (number): Padding inside the container in pixels.
 *
 * @methods
 * - `ngOnInit()`: Initializes the component, sets up event listeners for resize and orientation changes, and updates container styles.
 * - `ngOnChanges(changes: SimpleChanges)`: Updates container styles when input properties change.
 * - `ngOnDestroy()`: Removes event listeners to avoid memory leaks.
 * - `updateContainerStyles()`: Computes and applies styles to the container based on current window size and input properties.
 *
 * @example
 * ```html
 * <app-main-container-component
 *   [backgroundColor]="'lightgrey'"
 *   [containerWidthFraction]="0.8"
 *   [containerHeightFraction]="0.9"
 *   [marginLeft]="10"
 *   [marginTop]="15"
 *   [padding]="5"
 * ></app-main-container-component>
 * ```
 **/
class MainContainerComponent {
    backgroundColor = '';
    containerWidthFraction = 1;
    containerHeightFraction = 1;
    marginLeft = 0;
    marginRight = 0;
    marginTop = 0;
    marginBottom = 0;
    padding = 0;
    containerStyles = {};
    ngOnInit() {
        this.updateContainerStyles();
        window.addEventListener('resize', this.updateContainerStyles);
        window.addEventListener('orientationchange', this.updateContainerStyles);
    }
    ngOnChanges(changes) {
        if (changes['containerHeightFraction'] ||
            changes['containerWidthFraction'] ||
            changes['backgroundColor'] ||
            changes['marginLeft'] ||
            changes['marginRight'] ||
            changes['marginTop'] ||
            changes['marginBottom']) {
            this.updateContainerStyles();
        }
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.updateContainerStyles);
        window.removeEventListener('orientationchange', this.updateContainerStyles);
    }
    updateContainerStyles = () => {
        const windowHeight = window.innerHeight;
        const windowWidth = window.innerWidth;
        this.containerStyles = {
            backgroundColor: this.backgroundColor,
            marginLeft: `${this.marginLeft}px`,
            marginRight: `${this.marginRight}px`,
            marginTop: `${this.marginTop}px`,
            marginBottom: `${this.marginBottom}px`,
            height: Math.floor(this.containerHeightFraction * windowHeight) + 'px',
            maxHeight: Math.floor(this.containerHeightFraction * windowHeight) + 'px',
            width: Math.floor(this.containerWidthFraction * windowWidth) + 'px',
            maxWidth: Math.floor(this.containerWidthFraction * windowWidth) + 'px',
            padding: `${this.padding}px`,
            overflow: 'hidden',
        };
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MainContainerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MainContainerComponent, isStandalone: true, selector: "app-main-container-component", inputs: { backgroundColor: "backgroundColor", containerWidthFraction: "containerWidthFraction", containerHeightFraction: "containerHeightFraction", marginLeft: "marginLeft", marginRight: "marginRight", marginTop: "marginTop", marginBottom: "marginBottom", padding: "padding" }, usesOnChanges: true, ngImport: i0, template: `
    <div [ngStyle]="containerStyles">
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MainContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-main-container-component',
                    imports: [CommonModule],
                    template: `
    <div [ngStyle]="containerStyles">
      <ng-content></ng-content>
    </div>
  `
                }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], containerWidthFraction: [{
                type: Input
            }], containerHeightFraction: [{
                type: Input
            }], marginLeft: [{
                type: Input
            }], marginRight: [{
                type: Input
            }], marginTop: [{
                type: Input
            }], marginBottom: [{
                type: Input
            }], padding: [{
                type: Input
            }] } });

/**
 * MeetingProgressTimer displays a customizable timer badge to track meeting progress time.
 *
 * @selector app-meeting-progress-timer
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * ```html
 * <div [ngStyle]="positions[position]" class="badge-container">
 *   <div [ngStyle]="{ backgroundColor: initialBackgroundColor, display: showTimer ? 'block' : 'none' }" class="progress-timer">
 *     <span [ngStyle]="textStyle" class="progress-timer-text">{{ meetingProgressTime }}</span>
 *   </div>
 * </div>
 * ```
 *
 * @styles
 * - `.badge-container`: General container style with positioning.
 * - `.progress-timer`: Timer badge with default padding, background, and border-radius.
 * - `.progress-timer-text`: Text styling within the timer badge.
 *
 * @inputs
 * - `meetingProgressTime` (string): Time to be displayed in the timer.
 * - `initialBackgroundColor` (string): Background color of the timer badge. Default is 'green'.
 * - `position` ('topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight'): Position of the timer on the screen. Default is 'topLeft'.
 * - `textStyle` (object): Custom styles for the timer text.
 * - `showTimer` (boolean): If true, displays the timer. Default is true.
 *
 * @property `positions` (object): Preset styles for timer positioning options.
 *
 * @methods
 * - `ngOnChanges(changes: SimpleChanges)`: Handles changes to input properties and updates styles accordingly.
 *
 * @example
 * ```html
 * <app-meeting-progress-timer
 *   [meetingProgressTime]="'10:30'"
 *   [initialBackgroundColor]="'blue'"
 *   [position]="'bottomRight'"
 *   [textStyle]="{ color: 'white', fontWeight: 'bold' }"
 *   [showTimer]="true"
 * ></app-meeting-progress-timer>
 * ```
 **/
class MeetingProgressTimer {
    meetingProgressTime;
    initialBackgroundColor = 'green';
    position = 'topLeft';
    textStyle = {};
    showTimer = true;
    positions = {
        topLeft: { position: 'absolute', top: '0', left: '0' },
        topRight: { position: 'absolute', top: '0', right: '0' },
        bottomLeft: { position: 'absolute', bottom: '0', left: '0' },
        bottomRight: { position: 'absolute', bottom: '0', right: '0' },
    };
    ngOnChanges(changes) {
        if (changes['position']) {
            this.positions = {
                topLeft: { position: 'absolute', top: '0', left: '0' },
                topRight: { position: 'absolute', top: '0', right: '0' },
                bottomLeft: { position: 'absolute', bottom: '0', left: '0' },
                bottomRight: { position: 'absolute', bottom: '0', right: '0' },
            };
        }
        if (changes['showTimer']) {
            this.showTimer = changes['showTimer'].currentValue;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingProgressTimer, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MeetingProgressTimer, isStandalone: true, selector: "app-meeting-progress-timer", inputs: { meetingProgressTime: "meetingProgressTime", initialBackgroundColor: "initialBackgroundColor", position: "position", textStyle: "textStyle", showTimer: "showTimer" }, usesOnChanges: true, ngImport: i0, template: `
    <div [ngStyle]="positions[position]" class="badge-container">
      <div
        [ngStyle]="{
          backgroundColor: initialBackgroundColor,
          display: showTimer ? 'block' : 'none'
        }"
        class="progress-timer"
      >
        <span [ngStyle]="textStyle" class="progress-timer-text">{{ meetingProgressTime }}</span>
      </div>
    </div>
  `, isInline: true, styles: [".badge-container{padding:5px;position:relative;z-index:1000}.progress-timer{background-color:green;padding:5px;border-radius:5px;color:#fff}.progress-timer-text{color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingProgressTimer, decorators: [{
            type: Component,
            args: [{ selector: 'app-meeting-progress-timer', imports: [CommonModule], template: `
    <div [ngStyle]="positions[position]" class="badge-container">
      <div
        [ngStyle]="{
          backgroundColor: initialBackgroundColor,
          display: showTimer ? 'block' : 'none'
        }"
        class="progress-timer"
      >
        <span [ngStyle]="textStyle" class="progress-timer-text">{{ meetingProgressTime }}</span>
      </div>
    </div>
  `, styles: [".badge-container{padding:5px;position:relative;z-index:1000}.progress-timer{background-color:green;padding:5px;border-radius:5px;color:#fff}.progress-timer-text{color:#000}\n"] }]
        }], propDecorators: { meetingProgressTime: [{
                type: Input
            }], initialBackgroundColor: [{
                type: Input
            }], position: [{
                type: Input
            }], textStyle: [{
                type: Input
            }], showTimer: [{
                type: Input
            }] } });

/**
 * MainGridComponent displays a customizable grid container with an optional meeting progress timer.
 *
 * @selector app-main-grid-component
 * @standalone true
 * @imports CommonModule, MeetingProgressTimer
 *
 * @template
 * ```html
 * <div [ngStyle]="maingridContainerStyle">
 *   <app-meeting-progress-timer
 *     *ngIf="showTimer"
 *     [meetingProgressTime]="meetingProgressTime"
 *     [initialBackgroundColor]="timeBackgroundColor"
 *   ></app-meeting-progress-timer>
 *   <ng-content></ng-content>
 * </div>
 * ```
 *
 * @inputs
 * - `backgroundColor` (string): Background color of the grid container. Default is an empty string.
 * - `mainSize` (number): Main size of the grid container, used for layout adjustments.
 * - `height` (number): Height of the grid container in pixels.
 * - `width` (number): Width of the grid container in pixels.
 * - `showAspect` (boolean): If true, displays the grid container in flex layout. Default is true.
 * - `timeBackgroundColor` (string): Background color of the meeting progress timer. Default is 'green'.
 * - `showTimer` (boolean): If true, displays the meeting progress timer. Default is true.
 * - `meetingProgressTime` (string): Time displayed in the meeting progress timer.
 *
 * @getter
 * - `maingridContainerStyle`: Returns a style object for the grid container, including display, color, dimensions, and border styling.
 *
 * @example
 * ```html
 * <app-main-grid-component
 *   [backgroundColor]="'lightgrey'"
 *   [height]="500"
 *   [width]="500"
 *   [showAspect]="true"
 *   [timeBackgroundColor]="'blue'"
 *   [showTimer]="true"
 *   [meetingProgressTime]="'10:45'"
 * ></app-main-grid-component>
 * ```
 **/
class MainGridComponent {
    backgroundColor = '';
    mainSize = 0;
    height = 0;
    width = 0;
    showAspect = true;
    timeBackgroundColor = 'green';
    showTimer = true;
    meetingProgressTime = '0';
    get maingridContainerStyle() {
        return {
            display: this.showAspect ? 'flex' : 'none',
            backgroundColor: this.backgroundColor,
            height: `${this.height}px`,
            width: `${this.width}px`,
            flexDirection: 'row',
            justifyContent: 'center',
            alignItems: 'center',
            borderStyle: 'solid',
            borderColor: '#000',
            borderWidth: '4px',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MainGridComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MainGridComponent, isStandalone: true, selector: "app-main-grid-component", inputs: { backgroundColor: "backgroundColor", mainSize: "mainSize", height: "height", width: "width", showAspect: "showAspect", timeBackgroundColor: "timeBackgroundColor", showTimer: "showTimer", meetingProgressTime: "meetingProgressTime" }, ngImport: i0, template: `
    <div [ngStyle]="maingridContainerStyle">
      <app-meeting-progress-timer
        *ngIf="showTimer"
        [meetingProgressTime]="meetingProgressTime"
        [initialBackgroundColor]="timeBackgroundColor"
      ></app-meeting-progress-timer>
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: MeetingProgressTimer, selector: "app-meeting-progress-timer", inputs: ["meetingProgressTime", "initialBackgroundColor", "position", "textStyle", "showTimer"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MainGridComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-main-grid-component',
                    imports: [CommonModule, MeetingProgressTimer],
                    template: `
    <div [ngStyle]="maingridContainerStyle">
      <app-meeting-progress-timer
        *ngIf="showTimer"
        [meetingProgressTime]="meetingProgressTime"
        [initialBackgroundColor]="timeBackgroundColor"
      ></app-meeting-progress-timer>
      <ng-content></ng-content>
    </div>
  `
                }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], mainSize: [{
                type: Input
            }], height: [{
                type: Input
            }], width: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], timeBackgroundColor: [{
                type: Input
            }], showTimer: [{
                type: Input
            }], meetingProgressTime: [{
                type: Input
            }] } });

/**
 * MainScreenComponent dynamically displays a main screen area with responsive dimensions, adjustable layout, and stacking options based on the screen size and input properties.
 *
 * @selector app-main-screen-component
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * ```html
 * <div [ngStyle]="containerStyle">
 *   <ng-content></ng-content>
 * </div>
 * ```
 *
 * @inputs
 * - `mainSize` (number): Percentage size of the main component. Default is 40.
 * - `doStack` (boolean): Determines if components should be stacked. Default is true.
 * - `containerWidthFraction` (number): Fraction of the container width to use. Default is 1.
 * - `containerHeightFraction` (number): Fraction of the container height to use. Default is 1.
 * - `defaultFraction` (number): Default height fraction for the container when controls are shown. Default is 0.94.
 * - `showControls` (boolean): If true, shows control elements, affecting container height. Default is true.
 * - `updateComponentSizes` (function): Callback for updating component sizes.
 *
 * @ContentChildren('child') children - Query list of child elements within the component.
 *
 * @properties
 * - `containerStyle`: Returns a style object for the container based on dimensions and layout options.
 *
 * @methods
 * - `ngOnInit()`: Initializes the component and sets up event listeners for window resize and orientation changes.
 * - `ngOnChanges(changes: SimpleChanges)`: Updates dimensions and layout if any relevant inputs change.
 * - `ngOnDestroy()`: Removes event listeners to prevent memory leaks.
 * - `ngAfterViewInit()`: Applies computed styles to child elements after view initialization.
 * - `computeDimensions()`: Calculates the dimensions for main and secondary components based on current layout settings.
 * - `updateDimensions()`: Updates component dimensions based on window size and input properties.
 * - `applyChildStyles()`: Applies computed styles to child components.
 *
 * @example
 * ```html
 * <app-main-screen-component
 *   [mainSize]="60"
 *   [doStack]="false"
 *   [containerWidthFraction]="0.8"
 *   [containerHeightFraction]="0.9"
 *   [defaultFraction]="0.9"
 *   [showControls]="true"
 *   [updateComponentSizes]="onUpdateSizes"
 * >
 *   <div #child>Child Component</div>
 * </app-main-screen-component>
 * ```
 **/
class MainScreenComponent {
    renderer;
    mainSize = 40; // percentage
    doStack = true;
    containerWidthFraction = 1;
    containerHeightFraction = 1;
    defaultFraction = 0.94;
    showControls = true;
    updateComponentSizes = (sizes) => {
        console.log(sizes);
    };
    children;
    parentWidth;
    parentHeight;
    isWideScreen;
    constructor(renderer) {
        this.renderer = renderer;
    }
    ngOnInit() {
        this.updateDimensions();
        window.addEventListener('resize', this.updateDimensions);
        window.addEventListener('orientationchange', this.updateDimensions);
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.updateDimensions);
        window.removeEventListener('orientationchange', this.updateDimensions);
    }
    ngOnChanges(changes) {
        if (changes['mainSize'] ||
            changes['doStack'] ||
            changes['parentWidth'] ||
            changes['parentHeight'] ||
            changes['showControls'] ||
            changes['defaultFraction']) {
            this.updateDimensions();
        }
    }
    ngAfterViewInit() {
        this.applyChildStyles();
    }
    computeDimensions() {
        if (this.doStack) {
            return this.isWideScreen
                ? {
                    mainHeight: Math.floor(this.parentHeight),
                    otherHeight: Math.floor(this.parentHeight),
                    mainWidth: Math.floor((this.mainSize / 100) * this.parentWidth),
                    otherWidth: Math.floor(((100 - this.mainSize) / 100) * this.parentWidth),
                }
                : {
                    mainHeight: Math.floor((this.mainSize / 100) * this.parentHeight),
                    otherHeight: Math.floor(((100 - this.mainSize) / 100) * this.parentHeight),
                    mainWidth: Math.floor(this.parentWidth),
                    otherWidth: Math.floor(this.parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(this.parentHeight),
                otherHeight: Math.floor(this.parentHeight),
                mainWidth: Math.floor(this.parentWidth),
                otherWidth: Math.floor(this.parentWidth),
            };
        }
    }
    updateDimensions = () => {
        this.parentWidth = window.innerWidth * this.containerWidthFraction;
        this.parentHeight = this.showControls
            ? window.innerHeight * this.containerHeightFraction * this.defaultFraction
            : window.innerHeight * this.containerHeightFraction;
        this.isWideScreen = this.parentWidth >= 768;
        if (!this.isWideScreen && this.parentWidth > 1.5 * this.parentHeight) {
            this.isWideScreen = true;
        }
        const { mainHeight, otherHeight, mainWidth, otherWidth } = this.computeDimensions();
        this.updateComponentSizes({ mainHeight, otherHeight, mainWidth, otherWidth });
        this.applyChildStyles();
    };
    get containerStyle() {
        return {
            display: 'flex',
            flex: 1,
            flexDirection: this.isWideScreen ? 'row' : 'column',
            width: `${this.parentWidth}px`,
            height: `${this.parentHeight}px`,
            padding: 0,
            margin: 0,
        };
    }
    applyChildStyles() {
        if (this.children) {
            const { mainHeight, otherHeight, mainWidth, otherWidth } = this.computeDimensions();
            this.children.forEach((child, index) => {
                const childStyle = this.doStack
                    ? {
                        height: index === 0 ? mainHeight : otherHeight,
                        width: index === 0 ? mainWidth : otherWidth,
                    }
                    : {
                        height: mainHeight,
                        width: mainWidth,
                    };
                this.renderer.setStyle(child.nativeElement, 'height', `${childStyle.height}px`);
                this.renderer.setStyle(child.nativeElement, 'width', `${childStyle.width}px`);
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MainScreenComponent, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MainScreenComponent, isStandalone: true, selector: "app-main-screen-component", inputs: { mainSize: "mainSize", doStack: "doStack", containerWidthFraction: "containerWidthFraction", containerHeightFraction: "containerHeightFraction", defaultFraction: "defaultFraction", showControls: "showControls", updateComponentSizes: "updateComponentSizes" }, queries: [{ propertyName: "children", predicate: ["child"] }], usesOnChanges: true, ngImport: i0, template: `
    <div [ngStyle]="containerStyle">
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MainScreenComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-main-screen-component',
                    imports: [CommonModule],
                    template: `
    <div [ngStyle]="containerStyle">
      <ng-content></ng-content>
    </div>
  `
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }], propDecorators: { mainSize: [{
                type: Input
            }], doStack: [{
                type: Input
            }], containerWidthFraction: [{
                type: Input
            }], containerHeightFraction: [{
                type: Input
            }], defaultFraction: [{
                type: Input
            }], showControls: [{
                type: Input
            }], updateComponentSizes: [{
                type: Input
            }], children: [{
                type: ContentChildren,
                args: ['child']
            }] } });

/**
 * MiniCardAudio component displays an audio card with optional waveform animation and overlay.
 *
 * @selector app-mini-card-audio
 * @standalone true
 * @imports CommonModule
 *
 * @template
 * - Displays:
 *   - A customizable card with optional image and name.
 *   - Overlay with waveform animation and text.
 *
 * @styles
 * - Customizable card, overlay, and waveform styles.
 *
 * @inputs
 * - `customStyle` (Partial<CSSStyleDeclaration>): Custom CSS styles for the card.
 * - `name` (string): Name displayed on the card.
 * - `showWaveform` (boolean): Controls visibility of waveform animation.
 * - `overlayPosition` (string): Position for the overlay on the card.
 * - `barColor` (string): Color of waveform bars.
 * - `textColor` (string): Color of the name text.
 * - `imageSource` (string): URL for the background image.
 * - `roundedImage` (boolean): Rounds image corners if true.
 * - `imageStyle` (Partial<CSSStyleDeclaration>): Custom styles for the background image.
 *
 * @class MiniCardAudio
 * @implements OnInit, OnDestroy
 *
 * @constructor
 * - Optional injected values for all input properties.
 *
 * @methods
 * - `ngOnInit`: Initializes the component, starts waveform animation if `showWaveform` is true.
 * - `ngOnDestroy`: Cleans up intervals.
 * - `animateWaveform`: Starts animation of the waveform bars.
 * - `resetWaveform`: Resets waveform to initial state.
 * - `clearIntervals`: Clears all active intervals.
 * - `getAnimationDuration`: Returns duration for animation at a given index.
 * - `getImageStyle`: Combines custom image styles with rounded corners if enabled.
 * - `getOverlayPosition`: Uses utility to determine the overlay's position.
 *
 * @example
 * ```html
 * <app-mini-card-audio
 *   [customStyle]="{ backgroundColor: 'blue' }"
 *   name="Audio Name"
 *   [showWaveform]="true"
 *   overlayPosition="bottomRight"
 *   barColor="red"
 *   textColor="white"
 *   imageSource="/path/to/image.jpg"
 *   [roundedImage]="true"
 *   [imageStyle]="{ border: '2px solid black' }"
 * ></app-mini-card-audio>
 * ```
 */
class MiniCardAudio {
    customStyle;
    name = '';
    showWaveform = false;
    overlayPosition = 'bottomLeft';
    barColor = 'white';
    textColor = 'white';
    imageSource = '';
    roundedImage = false;
    imageStyle = {};
    waveformAnimations = Array.from({ length: 9 }, () => 0);
    intervals = [];
    constructor(injectedCustomStyle, injectedName, injectedShowWaveform, injectedOverlayPosition, injectedBarColor, injectedTextColor, injectedImageSource, injectedRoundedImage, injectedImageStyle) {
        // Use injected values if available
        this.customStyle = injectedCustomStyle || this.customStyle;
        this.name = injectedName || this.name;
        this.showWaveform = injectedShowWaveform || this.showWaveform;
        this.overlayPosition = injectedOverlayPosition || this.overlayPosition;
        this.barColor = injectedBarColor || this.barColor;
        this.textColor = injectedTextColor || this.textColor;
        this.imageSource = injectedImageSource || this.imageSource;
        this.roundedImage = injectedRoundedImage || this.roundedImage;
        this.imageStyle = injectedImageStyle || this.imageStyle;
    }
    ngOnInit() {
        if (this.showWaveform) {
            this.animateWaveform();
        }
        else {
            this.resetWaveform();
        }
    }
    ngOnDestroy() {
        this.clearIntervals();
    }
    animateWaveform() {
        this.intervals = this.waveformAnimations.map((_, index) => setInterval(() => {
            this.waveformAnimations[index] = (this.waveformAnimations[index] + 1) % 2;
        }, this.getAnimationDuration(index)));
    }
    resetWaveform() {
        this.waveformAnimations.fill(0);
    }
    clearIntervals() {
        this.intervals.forEach((interval) => clearInterval(interval));
    }
    getAnimationDuration(index) {
        const durations = [474, 433, 407, 458, 400, 427, 441, 419, 487];
        return durations[index] || 0;
    }
    getImageStyle() {
        return {
            ...this.imageStyle,
            ...(this.roundedImage ? { borderRadius: '20%' } : {}),
        };
    }
    getOverlayPosition(position) {
        return getOverlayPosition({ position });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MiniCardAudio, deps: [{ token: 'customStyle', optional: true }, { token: 'name', optional: true }, { token: 'showWaveform', optional: true }, { token: 'overlayPosition', optional: true }, { token: 'barColor', optional: true }, { token: 'textColor', optional: true }, { token: 'imageSource', optional: true }, { token: 'roundedImage', optional: true }, { token: 'imageStyle', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MiniCardAudio, isStandalone: true, selector: "app-mini-card-audio", inputs: { customStyle: "customStyle", name: "name", showWaveform: "showWaveform", overlayPosition: "overlayPosition", barColor: "barColor", textColor: "textColor", imageSource: "imageSource", roundedImage: "roundedImage", imageStyle: "imageStyle" }, ngImport: i0, template: `
    <div class="card" [ngStyle]="customStyle">
      <img *ngIf="imageSource" [src]="imageSource" [ngStyle]="getImageStyle()" alt="Background" />
      <div [ngStyle]="getOverlayPosition(overlayPosition)" [class.overlay-web]="true">
        <div class="name-column">
          <span class="name-text" [ngStyle]="{ color: textColor }">{{ name }}</span>
        </div>
        <div [class.waveform-web]="true">
          <div
            *ngFor="let animation of waveformAnimations"
            [ngStyle]="{
              height: animation === 0 ? '1px' : '16px',
              backgroundColor: barColor
            }"
            class="bar"
          ></div>
        </div>
      </div>
    </div>
  `, isInline: true, styles: [".card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f}.overlay-web{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.name-column{display:flex;justify-content:center;align-items:center;background-color:#00000080;padding:5px 10px;margin-right:2px;font-size:14px}.name-text{font-size:14px;color:#fff}.waveform-web{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin:0 1px}.background-image{position:absolute;width:80px;height:80px;display:flex;justify-content:center;align-items:center;top:50%;left:50%;transform:translate(-40px,-40px)}.rounded-image{border-radius:20%}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MiniCardAudio, decorators: [{
            type: Component,
            args: [{ selector: 'app-mini-card-audio', imports: [CommonModule], template: `
    <div class="card" [ngStyle]="customStyle">
      <img *ngIf="imageSource" [src]="imageSource" [ngStyle]="getImageStyle()" alt="Background" />
      <div [ngStyle]="getOverlayPosition(overlayPosition)" [class.overlay-web]="true">
        <div class="name-column">
          <span class="name-text" [ngStyle]="{ color: textColor }">{{ name }}</span>
        </div>
        <div [class.waveform-web]="true">
          <div
            *ngFor="let animation of waveformAnimations"
            [ngStyle]="{
              height: animation === 0 ? '1px' : '16px',
              backgroundColor: barColor
            }"
            class="bar"
          ></div>
        </div>
      </div>
    </div>
  `, styles: [".card{width:100%;height:100%;margin:0;padding:0;background-color:#2c678f}.overlay-web{position:absolute;min-width:50%;min-height:5%;max-height:100%;display:grid;grid-template-columns:4fr 2fr;grid-gap:3px}.name-column{display:flex;justify-content:center;align-items:center;background-color:#00000080;padding:5px 10px;margin-right:2px;font-size:14px}.name-text{font-size:14px;color:#fff}.waveform-web{display:flex;justify-content:left;align-items:center;background-color:#0000000d;padding:0;flex-direction:row}.bar{flex:1;opacity:.35;margin:0 1px}.background-image{position:absolute;width:80px;height:80px;display:flex;justify-content:center;align-items:center;top:50%;left:50%;transform:translate(-40px,-40px)}.rounded-image{border-radius:20%}\n"] }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customStyle']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['name']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showWaveform']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['overlayPosition']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['barColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['textColor']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageSource']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['roundedImage']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['imageStyle']
                }] }], propDecorators: { customStyle: [{
                type: Input
            }], name: [{
                type: Input
            }], showWaveform: [{
                type: Input
            }], overlayPosition: [{
                type: Input
            }], barColor: [{
                type: Input
            }], textColor: [{
                type: Input
            }], imageSource: [{
                type: Input
            }], roundedImage: [{
                type: Input
            }], imageStyle: [{
                type: Input
            }] } });

/**
 * OtherGridComponent represents a customizable grid container with optional meeting progress timer.
 *
 * @selector app-other-grid-component
 * @standalone true
 * @imports CommonModule, MeetingProgressTimer
 *
 * @template
 * - The template consists of:
 *   - A grid container styled with specified dimensions, background color, and border.
 *   - An optional `MeetingProgressTimer` component displayed within the grid if `showTimer` is true.
 *
 * @styles
 * - Default border, padding, and display styles for the grid container.
 *
 * @inputs
 * - `backgroundColor` (string): Background color of the grid container. Default is `'transparent'`.
 * - `width` (number): Width of the grid in pixels. Default is `0`.
 * - `height` (number): Height of the grid in pixels. Default is `0`.
 * - `showAspect` (boolean): Controls visibility of the grid container. Default is `true`.
 * - `timeBackgroundColor` (string): Background color of the timer. Default is `'green'`.
 * - `showTimer` (boolean): Determines if the timer should be displayed. Default is `false`.
 * - `meetingProgressTime` (string): Time to display in the timer. Default is `'00:00:00'`.
 *
 * @class OtherGridComponent
 * @example
 * ```html
 * <app-other-grid-component
 *   [backgroundColor]="'lightgray'"
 *   [width]="300"
 *   [height]="200"
 *   [showAspect]="true"
 *   [timeBackgroundColor]="'blue'"
 *   [showTimer]="true"
 *   [meetingProgressTime]="'00:05:32'"
 * ></app-other-grid-component>
 * ```
 */
class OtherGridComponent {
    backgroundColor = 'transparent';
    width = 0;
    height = 0;
    showAspect = true;
    timeBackgroundColor = 'green';
    showTimer = false;
    meetingProgressTime = '00:00:00';
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: OtherGridComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: OtherGridComponent, isStandalone: true, selector: "app-other-grid-component", inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", showAspect: "showAspect", timeBackgroundColor: "timeBackgroundColor", showTimer: "showTimer", meetingProgressTime: "meetingProgressTime" }, ngImport: i0, template: `
    <div
      [ngStyle]="{
        'background-color': backgroundColor,
        width: width + 'px',
        height: height + 'px',
        display: showAspect ? 'block' : 'none',
        overflow: 'hidden',
        'border-style': 'solid',
        'border-color': 'black',
        'border-width': '2px',
        'border-radius': '0',
        margin: '0',
        padding: '0'
      }"
    >
      <app-meeting-progress-timer
        *ngIf="showTimer"
        [meetingProgressTime]="meetingProgressTime"
        [initialBackgroundColor]="timeBackgroundColor"
        [showTimer]="showTimer"
      ></app-meeting-progress-timer>
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: MeetingProgressTimer, selector: "app-meeting-progress-timer", inputs: ["meetingProgressTime", "initialBackgroundColor", "position", "textStyle", "showTimer"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: OtherGridComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-other-grid-component',
                    imports: [CommonModule, MeetingProgressTimer],
                    template: `
    <div
      [ngStyle]="{
        'background-color': backgroundColor,
        width: width + 'px',
        height: height + 'px',
        display: showAspect ? 'block' : 'none',
        overflow: 'hidden',
        'border-style': 'solid',
        'border-color': 'black',
        'border-width': '2px',
        'border-radius': '0',
        margin: '0',
        padding: '0'
      }"
    >
      <app-meeting-progress-timer
        *ngIf="showTimer"
        [meetingProgressTime]="meetingProgressTime"
        [initialBackgroundColor]="timeBackgroundColor"
        [showTimer]="showTimer"
      ></app-meeting-progress-timer>
      <ng-content></ng-content>
    </div>
  `
                }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], width: [{
                type: Input
            }], height: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], timeBackgroundColor: [{
                type: Input
            }], showTimer: [{
                type: Input
            }], meetingProgressTime: [{
                type: Input
            }] } });

/**
 * Pagination component for managing and displaying page navigation controls with various layouts and customizations.
 *
 * @selector app-pagination
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule]
 *
 * @description
 * This component renders pagination controls, allowing users to navigate through pages. The controls support horizontal and vertical layouts, customizable styles, and dynamic page content handling, with special support for breakout room navigation.
 *
 * @example
 * ```html
 * <app-pagination
 *   [totalPages]="10"
 *   [currentUserPage]="1"
 *   [handlePageChange]="handlePageChange"
 *   [position]="'middle'"
 *   [location]="'bottom'"
 *   [direction]="'horizontal'"
 *   [backgroundColor]="'#ffffff'"
 *   [paginationHeight]="40"
 *   [showAspect]="true"
 *   [parameters]="paginationParameters">
 * </app-pagination>
 * ```
 *
 * @input {number} totalPages - Total number of pages available for navigation.
 * @input {number} currentUserPage - Current active page number.
 * @input {Function} handlePageChange - Callback function to handle page changes.
 * @input {'left' | 'middle' | 'right' | string} position - Horizontal position of the pagination controls (default is 'middle').
 * @input {'top' | 'middle' | 'bottom' | string} location - Vertical position of the pagination controls (default is 'middle').
 * @input {'horizontal' | 'vertical' | string} direction - Layout direction of the pagination controls (default is 'horizontal').
 * @input {any} buttonsContainerStyle - Custom CSS styles for the buttons container.
 * @input {any} activePageStyle - CSS styles for the active page button.
 * @input {any} inactivePageStyle - CSS styles for inactive page buttons.
 * @input {string} backgroundColor - Background color for the pagination controls.
 * @input {number} paginationHeight - Height of the pagination controls in pixels.
 * @input {boolean} showAspect - Flag to display or hide the pagination controls.
 * @input {PaginationParameters} parameters - Additional configuration parameters for managing breakout rooms and related state.
 *
 * @property {number[]} data - Array representing pages to be displayed in pagination controls.
 * @property {ComponentSizes} componentSizes - Stores calculated sizes for pagination controls.
 *
 * @method ngOnInit - Lifecycle hook that initializes the component and sets up page data.
 * @method ngOnChanges - Handles input property changes to update page data when needed.
 * @method handleClick - Asynchronously handles page button clicks and manages breakout room navigation logic.
 * @method getPageStyle - Returns specific styles for a page button based on its active or inactive state.
 * @method isBreakoutRoom - Checks if a page represents a breakout room.
 * @method getDisplayItem - Returns the display label for a page, accounting for breakout room naming conventions.
 *
 * @dependencies
 * This component requires an external pagination parameters configuration (`PaginationParameters`) and access to the `GeneratePageContent` service for managing dynamic content loading.
 */
class Pagination {
    generatePageContentService;
    totalPages = 0;
    currentUserPage = 0;
    handlePageChange;
    position = 'middle';
    location = 'middle';
    direction = 'horizontal';
    buttonsContainerStyle = {};
    activePageStyle = { backgroundColor: '#2c678f' };
    inactivePageStyle = {};
    backgroundColor = '#ffffff';
    paginationHeight = 40;
    showAspect = true;
    parameters = {};
    constructor(generatePageContentService) {
        this.generatePageContentService = generatePageContentService;
    }
    faStar = faStar;
    faLock = faLock;
    data = [];
    ngOnInit() {
        this.data = Array.from({ length: this.totalPages + 1 }, (_, index) => index);
        this.componentSizes = this.parameters.componentSizes;
        if (!this.handlePageChange) {
            this.handlePageChange = this.generatePageContentService.generatePageContent.bind(this.generatePageContentService);
        }
    }
    ngOnChanges(changes) {
        if (changes['totalPages'] || changes['currentUserPage']) {
            this.data = Array.from({ length: this.totalPages + 1 }, (_, index) => index);
        }
    }
    handleClick = async (page) => {
        if (page == this.currentUserPage) {
            return;
        }
        this.parameters = this.parameters.getUpdatedAllParams();
        const params = { ...this.parameters };
        this.componentSizes = params.componentSizes;
        if (this.parameters.breakOutRoomStarted && !this.parameters.breakOutRoomEnded && page !== 0) {
            const roomMember = this.parameters.breakoutRooms.find((r) => r.find((p) => p.name == this.parameters.member));
            const pageInt = page - this.parameters.mainRoomsLength;
            let memberBreakRoom = -1;
            if (roomMember) {
                memberBreakRoom = this.parameters.breakoutRooms.indexOf(roomMember);
            }
            if ((memberBreakRoom == -1 || memberBreakRoom !== pageInt) && pageInt >= 0) {
                if (this.parameters.islevel !== '2') {
                    if (this.parameters.showAlert) {
                        this.parameters.showAlert({
                            message: `You are not part of the breakout room ${pageInt + 1}.`,
                            type: 'danger',
                        });
                    }
                    return;
                }
                await this.handlePageChange({
                    page,
                    parameters: params,
                    breakRoom: pageInt,
                    inBreakRoom: true,
                });
                if (this.parameters.hostNewRoom !== pageInt) {
                    this.parameters.socket.emit('updateHostBreakout', {
                        newRoom: pageInt,
                        roomName: this.parameters.roomName,
                    });
                }
            }
            else {
                await this.handlePageChange({
                    page,
                    parameters: params,
                    breakRoom: pageInt,
                    inBreakRoom: pageInt >= 0,
                });
                if (this.parameters.islevel == '2' && this.parameters.hostNewRoom !== -1) {
                    this.parameters.socket.emit('updateHostBreakout', {
                        prevRoom: this.parameters.hostNewRoom,
                        newRoom: -1,
                        roomName: this.parameters.roomName,
                    });
                }
            }
        }
        else {
            await this.handlePageChange({ page, parameters: params, breakRoom: 0, inBreakRoom: false });
            if (this.parameters.islevel == '2' && this.parameters.hostNewRoom !== -1) {
                this.parameters.socket.emit('updateHostBreakout', {
                    prevRoom: this.parameters.hostNewRoom,
                    newRoom: -1,
                    roomName: this.parameters.roomName,
                });
            }
        }
    };
    componentSizes = {};
    getPageStyle(item) {
        return item == this.currentUserPage ? this.activePageStyle : this.inactivePageStyle;
    }
    isBreakoutRoom = (item) => {
        this.parameters = this.parameters.getUpdatedAllParams();
        return (this.parameters.breakOutRoomStarted &&
            !this.parameters.breakOutRoomEnded &&
            item >= this.parameters.mainRoomsLength);
    };
    getDisplayItem(item) {
        const roomNumber = item - (this.parameters.mainRoomsLength - 1);
        if (this.isBreakoutRoom(item)) {
            if (this.parameters.memberRoom + 1 !== roomNumber) {
                return `Room ${roomNumber}`;
            }
            else {
                return `Room ${roomNumber}`;
            }
        }
        return item.toString();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Pagination, deps: [{ token: GeneratePageContent }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: Pagination, isStandalone: true, selector: "app-pagination", inputs: { totalPages: "totalPages", currentUserPage: "currentUserPage", handlePageChange: "handlePageChange", position: "position", location: "location", direction: "direction", buttonsContainerStyle: "buttonsContainerStyle", activePageStyle: "activePageStyle", inactivePageStyle: "inactivePageStyle", backgroundColor: "backgroundColor", paginationHeight: "paginationHeight", showAspect: "showAspect", parameters: "parameters" }, usesOnChanges: true, ngImport: i0, template: `
    <div
      [ngStyle]="{
        'background-color': backgroundColor,
        'justify-content': position == 'middle' ? 'space-evenly' : position == 'left' ? 'flex-start' : 'flex-end',
        'align-items': location == 'middle' ? 'center' : location == 'top' ? 'flex-start' : 'flex-end',
        'padding': '0',
        'margin': '0',
        'min-height': direction == 'horizontal' ? paginationHeight + 'px' : componentSizes.otherHeight + 'px',
        'min-width': direction == 'horizontal' ? componentSizes.otherWidth + 'px' : paginationHeight + 'px',
        'width': direction == 'horizontal' ? '100%' : paginationHeight + 'px',
        'height': direction == 'horizontal' ? paginationHeight + 'px' : '100%',
        'display': showAspect ? 'flex' : 'none',
        'max-height': direction == 'horizontal' ? paginationHeight + 'px' : '100%',
        'max-width': direction == 'horizontal' ? '100%' : paginationHeight + 'px',
        'flex-direction': direction == 'vertical' ? 'column' : 'row',
        'overflow-x': 'auto',
      }"
    >
      <ng-container *ngFor="let item of data; let index = index">
        <button
          *ngIf="item == 0"
          [ngClass]="{ active: item == currentUserPage }"
          [ngStyle]="getPageStyle(item)"
          (click)="handleClick(item)"
        >
          <fa-icon
            [icon]="faStar"
            size="lg"
            [style.color]="item == currentUserPage ? 'yellow' : 'gray'"
          ></fa-icon>
        </button>
        <button
          *ngIf="item !== 0"
          [ngClass]="{ active: item == currentUserPage }"
          [ngStyle]="getPageStyle(item)"
          (click)="handleClick(item)"
        >
          <span
            *ngIf="!isBreakoutRoom(item)"
            class="pageText"
            [ngStyle]="{ color: item == currentUserPage ? '#ffffff' : '#000000' }"
            >{{ item }}</span
          >
          <span
            *ngIf="isBreakoutRoom(item)"
            class="pageText"
            [ngStyle]="{ color: item == currentUserPage ? '#ffffff' : '#000000' }"
            >{{ getDisplayItem(item) }}
            <fa-icon
              *ngIf="
                parameters.memberRoom + 1 !== item - (parameters.mainRoomsLength - 1) &&
                parameters.islevel !== '2'
              "
              [icon]="faLock"
            ></fa-icon
          ></span>
        </button>
      </ng-container>
    </div>
  `, isInline: true, styles: [".pageButton.active{background-color:#2c678f}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Pagination, decorators: [{
            type: Component,
            args: [{ selector: 'app-pagination', imports: [CommonModule, FontAwesomeModule], template: `
    <div
      [ngStyle]="{
        'background-color': backgroundColor,
        'justify-content': position == 'middle' ? 'space-evenly' : position == 'left' ? 'flex-start' : 'flex-end',
        'align-items': location == 'middle' ? 'center' : location == 'top' ? 'flex-start' : 'flex-end',
        'padding': '0',
        'margin': '0',
        'min-height': direction == 'horizontal' ? paginationHeight + 'px' : componentSizes.otherHeight + 'px',
        'min-width': direction == 'horizontal' ? componentSizes.otherWidth + 'px' : paginationHeight + 'px',
        'width': direction == 'horizontal' ? '100%' : paginationHeight + 'px',
        'height': direction == 'horizontal' ? paginationHeight + 'px' : '100%',
        'display': showAspect ? 'flex' : 'none',
        'max-height': direction == 'horizontal' ? paginationHeight + 'px' : '100%',
        'max-width': direction == 'horizontal' ? '100%' : paginationHeight + 'px',
        'flex-direction': direction == 'vertical' ? 'column' : 'row',
        'overflow-x': 'auto',
      }"
    >
      <ng-container *ngFor="let item of data; let index = index">
        <button
          *ngIf="item == 0"
          [ngClass]="{ active: item == currentUserPage }"
          [ngStyle]="getPageStyle(item)"
          (click)="handleClick(item)"
        >
          <fa-icon
            [icon]="faStar"
            size="lg"
            [style.color]="item == currentUserPage ? 'yellow' : 'gray'"
          ></fa-icon>
        </button>
        <button
          *ngIf="item !== 0"
          [ngClass]="{ active: item == currentUserPage }"
          [ngStyle]="getPageStyle(item)"
          (click)="handleClick(item)"
        >
          <span
            *ngIf="!isBreakoutRoom(item)"
            class="pageText"
            [ngStyle]="{ color: item == currentUserPage ? '#ffffff' : '#000000' }"
            >{{ item }}</span
          >
          <span
            *ngIf="isBreakoutRoom(item)"
            class="pageText"
            [ngStyle]="{ color: item == currentUserPage ? '#ffffff' : '#000000' }"
            >{{ getDisplayItem(item) }}
            <fa-icon
              *ngIf="
                parameters.memberRoom + 1 !== item - (parameters.mainRoomsLength - 1) &&
                parameters.islevel !== '2'
              "
              [icon]="faLock"
            ></fa-icon
          ></span>
        </button>
      </ng-container>
    </div>
  `, styles: [".pageButton.active{background-color:#2c678f}\n"] }]
        }], ctorParameters: () => [{ type: GeneratePageContent }], propDecorators: { totalPages: [{
                type: Input
            }], currentUserPage: [{
                type: Input
            }], handlePageChange: [{
                type: Input
            }], position: [{
                type: Input
            }], location: [{
                type: Input
            }], direction: [{
                type: Input
            }], buttonsContainerStyle: [{
                type: Input
            }], activePageStyle: [{
                type: Input
            }], inactivePageStyle: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], paginationHeight: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], parameters: [{
                type: Input
            }] } });

/**
 * SubAspectComponent is an Angular component that displays a sub-aspect of a media element with customizable dimensions and background color.
 * The component adapts its size and visibility based on the provided properties and listens for window resize and orientation change events.
 *
 * @selector app-sub-aspect-component
 * @standalone true
 * @imports CommonModule
 *
 * @example
 * ```html
 * <app-sub-aspect-component [backgroundColor]="'blue'" [showControls]="true" [containerWidthFraction]="0.8"></app-sub-aspect-component>
 * ```
 *
 * @input {string} backgroundColor - The background color of the component. Default is 'transparent'.
 * @input {boolean} showControls - Determines if controls are shown within the component. Default is true.
 * @input {number} containerWidthFraction - Fraction of the window width for the component width. Default is 1.
 * @input {number} containerHeightFraction - Fraction of the window height for the component height. Default is 1.
 * @input {number} defaultFractionSub - The default fraction for the sub-aspect height. Default is 0.0.
 *
 * @property {object} aspectStyles - Contains calculated styles for the component's height and width.
 * @property {number} aspectStyles.height - Calculated height of the component.
 * @property {number} aspectStyles.width - Calculated width of the component.
 *
 * @method ngOnInit - Initializes the component and adds event listeners for responsive adjustments.
 * @method ngOnChanges - Updates the aspect styles when any of the input properties change.
 * @method ngOnDestroy - Removes event listeners when the component is destroyed.
 * @method updateAspectStyles - Calculates and applies updated styles based on the window size and input properties.
 */
class SubAspectComponent {
    backgroundColor = 'transparent';
    showControls = true;
    containerWidthFraction = 1;
    containerHeightFraction = 1;
    defaultFractionSub = 0.0;
    aspectStyles = {
        height: 0,
        width: 0,
    };
    ngOnInit() {
        this.updateAspectStyles();
        window.addEventListener('resize', this.updateAspectStyles.bind(this));
        window.addEventListener('orientationchange', this.updateAspectStyles.bind(this));
    }
    ngOnChanges(changes) {
        if (changes['showControls'] ||
            changes['containerWidthFraction'] ||
            changes['containerHeightFraction'] ||
            changes['defaultFractionSub']) {
            this.updateAspectStyles();
        }
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.updateAspectStyles.bind(this));
        window.removeEventListener('orientationchange', this.updateAspectStyles.bind(this));
    }
    updateAspectStyles() {
        const windowWidth = window.innerWidth;
        this.aspectStyles = {
            height: this.showControls ? 40 : 0,
            width: this.containerWidthFraction ? this.containerWidthFraction * windowWidth : windowWidth,
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SubAspectComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: SubAspectComponent, isStandalone: true, selector: "app-sub-aspect-component", inputs: { backgroundColor: "backgroundColor", showControls: "showControls", containerWidthFraction: "containerWidthFraction", containerHeightFraction: "containerHeightFraction", defaultFractionSub: "defaultFractionSub" }, usesOnChanges: true, ngImport: i0, template: `
    <div
      *ngIf="showControls"
      [ngStyle]="{
        position: 'absolute',
        bottom: '0',
        margin: '0',
        backgroundColor: backgroundColor,
        height: aspectStyles.height + 'px',
        width: aspectStyles.width + 'px'
      }"
    >
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: SubAspectComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-sub-aspect-component', imports: [CommonModule], template: `
    <div
      *ngIf="showControls"
      [ngStyle]="{
        position: 'absolute',
        bottom: '0',
        margin: '0',
        backgroundColor: backgroundColor,
        height: aspectStyles.height + 'px',
        width: aspectStyles.width + 'px'
      }"
    >
      <ng-content></ng-content>
    </div>
  ` }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], showControls: [{
                type: Input
            }], containerWidthFraction: [{
                type: Input
            }], containerHeightFraction: [{
                type: Input
            }], defaultFractionSub: [{
                type: Input
            }] } });

/**
 * DisplaySettingsModal component is a modal dialog for managing display settings in a meeting.
 *
 * @component
 * @selector app-display-settings-modal
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule, FormsModule]
 *
 * @example
 * ```html
 * <app-display-settings-modal
 *   [isDisplaySettingsModalVisible]="true"
 *   [onDisplaySettingsClose]="closeModal"
 *   [onModifyDisplaySettings]="saveSettings"
 *   [parameters]="displaySettingsParams"
 *   position="topRight"
 *   backgroundColor="#83c0e9"
 * ></app-display-settings-modal>
 * ```
 *
 * @input {boolean} isDisplaySettingsModalVisible - Determines if the modal is visible.
 * @input {() => void} onDisplaySettingsClose - Callback to close the modal.
 * @input {(params: any) => void} onModifyDisplaySettings - Callback to modify display settings.
 * @input {DisplaySettingsModalParameters} parameters - Input parameters for modal settings.
 * @input {string} position - Modal's screen position, default is 'topRight'.
 * @input {string} backgroundColor - Background color of the modal, default is '#83c0e9'.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for closing the modal.
 *
 * @property {string} meetingDisplayTypeState - State variable for meeting display type.
 * @property {boolean} autoWaveState - State variable for auto wave setting.
 * @property {boolean} forceFullDisplayState - State variable for force full display setting.
 * @property {boolean} meetingVideoOptimizedState - State variable for video optimized setting.
 *
 * @constructor
 * @param {ModifyDisplaySettings} modifyDisplaySettingsService - Service to handle display settings modifications.
 *
 * @method ngOnInit - Initializes component state based on input parameters.
 * @method handleSaveSettings - Triggers the modification of display settings using `onModifyDisplaySettings`.
 */
class DisplaySettingsModal {
    modifyDisplaySettingsService;
    isDisplaySettingsModalVisible = false;
    onDisplaySettingsClose;
    onModifyDisplaySettings;
    parameters;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    faTimes = faTimes;
    meetingDisplayTypeState;
    autoWaveState = false;
    forceFullDisplayState = false;
    meetingVideoOptimizedState = false;
    constructor(modifyDisplaySettingsService) {
        this.modifyDisplaySettingsService = modifyDisplaySettingsService;
    }
    ngOnInit() {
        this.meetingDisplayTypeState = this.parameters.meetingDisplayType;
        this.autoWaveState = this.parameters.autoWave;
        this.forceFullDisplayState = this.parameters.forceFullDisplay;
        this.meetingVideoOptimizedState = this.parameters.meetingVideoOptimized;
        if (!this.onModifyDisplaySettings) {
            this.onModifyDisplaySettings = this.modifyDisplaySettingsService.modifyDisplaySettings.bind(this.modifyDisplaySettingsService);
        }
    }
    handleSaveSettings = async () => {
        await this.onModifyDisplaySettings({
            parameters: {
                ...this.parameters,
                meetingDisplayType: this.meetingDisplayTypeState,
                autoWave: this.autoWaveState,
                forceFullDisplay: this.forceFullDisplayState,
                meetingVideoOptimized: this.meetingVideoOptimizedState,
            },
        });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisplaySettingsModal, deps: [{ token: ModifyDisplaySettings }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: DisplaySettingsModal, isStandalone: true, selector: "app-display-settings-modal", inputs: { isDisplaySettingsModalVisible: "isDisplaySettingsModalVisible", onDisplaySettingsClose: "onDisplaySettingsClose", onModifyDisplaySettings: "onModifyDisplaySettings", parameters: "parameters", position: "position", backgroundColor: "backgroundColor" }, ngImport: i0, template: "<div *ngIf=\"isDisplaySettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{ 'background-color': backgroundColor }\">\r\n    <div class=\"modal-header\">\r\n      <h2>Display Settings</h2>\r\n      <div class=\"btn-close-media-settings\" (click)=\"onDisplaySettingsClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"modal-divider\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"setting-group\">\r\n        <label>Display Option:</label>\r\n        <select [(ngModel)]=\"meetingDisplayTypeState\" class=\"select-control\">\r\n          <option value=\"video\">Video Participants Only</option>\r\n          <option value=\"media\">Media Participants Only</option>\r\n          <option value=\"all\">Show All Participants</option>\r\n        </select>\r\n      </div>\r\n      <hr class=\"modal-divider\" />\r\n      <div class=\"setting-group\">\r\n        <div class=\"setting-toggle\">\r\n          <label>Display Audiographs</label>\r\n          <button (click)=\"autoWaveState = !autoWaveState\" [ngClass]=\"{ 'active': autoWaveState }\">\r\n            <span class=\"toggle-icon\">{{ autoWaveState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n        <div class=\"setting-toggle\">\r\n          <label>Force Full Display</label>\r\n          <button (click)=\"forceFullDisplayState = !forceFullDisplayState\" [ngClass]=\"{ 'active': forceFullDisplayState }\">\r\n            <span class=\"toggle-icon\">{{ forceFullDisplayState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n        <div class=\"setting-toggle\">\r\n          <label>Force Video Participants</label>\r\n          <button (click)=\"meetingVideoOptimizedState = !meetingVideoOptimizedState\" [ngClass]=\"{ 'active': meetingVideoOptimizedState }\">\r\n            <span class=\"toggle-icon\">{{ meetingVideoOptimizedState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"save-button\" (click)=\"handleSaveSettings()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:80vw;max-width:350px;max-height:65%;overflow-y:auto;top:10px;right:10px}.modal-header{display:flex;flex-direction:row;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-divider{height:1px;background-color:#000;margin:5px 0}.modal-body{flex:1}.setting-group{margin-bottom:10px}.setting-toggle{display:flex;flex-direction:row;justify-content:space-between;align-items:center;margin-bottom:10px}.select-control{font-size:medium;padding:12px 30px 12px 10px;border:1px solid gray;border-radius:4px;color:#000;background-color:#fff}.toggle-icon{font-size:large;font-weight:bolder}.active{color:green}.inactive{color:red}.modal-footer{margin-top:10px;display:flex;justify-content:flex-end}.save-button{padding:5px;border-radius:5px;background-color:#000;color:#fff;font-size:medium}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: DisplaySettingsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-display-settings-modal', imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div *ngIf=\"isDisplaySettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{ 'background-color': backgroundColor }\">\r\n    <div class=\"modal-header\">\r\n      <h2>Display Settings</h2>\r\n      <div class=\"btn-close-media-settings\" (click)=\"onDisplaySettingsClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"modal-divider\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"setting-group\">\r\n        <label>Display Option:</label>\r\n        <select [(ngModel)]=\"meetingDisplayTypeState\" class=\"select-control\">\r\n          <option value=\"video\">Video Participants Only</option>\r\n          <option value=\"media\">Media Participants Only</option>\r\n          <option value=\"all\">Show All Participants</option>\r\n        </select>\r\n      </div>\r\n      <hr class=\"modal-divider\" />\r\n      <div class=\"setting-group\">\r\n        <div class=\"setting-toggle\">\r\n          <label>Display Audiographs</label>\r\n          <button (click)=\"autoWaveState = !autoWaveState\" [ngClass]=\"{ 'active': autoWaveState }\">\r\n            <span class=\"toggle-icon\">{{ autoWaveState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n        <div class=\"setting-toggle\">\r\n          <label>Force Full Display</label>\r\n          <button (click)=\"forceFullDisplayState = !forceFullDisplayState\" [ngClass]=\"{ 'active': forceFullDisplayState }\">\r\n            <span class=\"toggle-icon\">{{ forceFullDisplayState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n        <div class=\"setting-toggle\">\r\n          <label>Force Video Participants</label>\r\n          <button (click)=\"meetingVideoOptimizedState = !meetingVideoOptimizedState\" [ngClass]=\"{ 'active': meetingVideoOptimizedState }\">\r\n            <span class=\"toggle-icon\">{{ meetingVideoOptimizedState ? '&#10003;' : '&#10007;' }}</span>\r\n          </button>\r\n        </div>\r\n        <hr class=\"modal-divider\" />\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"save-button\" (click)=\"handleSaveSettings()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:80vw;max-width:350px;max-height:65%;overflow-y:auto;top:10px;right:10px}.modal-header{display:flex;flex-direction:row;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-divider{height:1px;background-color:#000;margin:5px 0}.modal-body{flex:1}.setting-group{margin-bottom:10px}.setting-toggle{display:flex;flex-direction:row;justify-content:space-between;align-items:center;margin-bottom:10px}.select-control{font-size:medium;padding:12px 30px 12px 10px;border:1px solid gray;border-radius:4px;color:#000;background-color:#fff}.toggle-icon{font-size:large;font-weight:bolder}.active{color:green}.inactive{color:red}.modal-footer{margin-top:10px;display:flex;justify-content:flex-end}.save-button{padding:5px;border-radius:5px;background-color:#000;color:#fff;font-size:medium}\n"] }]
        }], ctorParameters: () => [{ type: ModifyDisplaySettings }], propDecorators: { isDisplaySettingsModalVisible: [{
                type: Input
            }], onDisplaySettingsClose: [{
                type: Input
            }], onModifyDisplaySettings: [{
                type: Input
            }], parameters: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }] } });

// event-settings-modal.component.ts
/**
 * EventSettingsModal component provides a modal interface to manage and update event settings like audio, video, screenshare, and chat settings.
 *
 * @component
 * @selector app-event-settings-modal
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule, FormsModule]
 *
 * @example
 * ```html
 * <app-event-settings-modal
 *   [isEventSettingsModalVisible]="true"
 *   [onEventSettingsClose]="closeModal"
 *   [onModifyEventSettings]="saveSettings"
 *   [audioSetting]="audio"
 *   [videoSetting]="video"
 *   [screenshareSetting]="screenshare"
 *   [chatSetting]="chat"
 *   [position]="'topRight'"
 *   [backgroundColor]="'#83c0e9'"
 * ></app-event-settings-modal>
 * ```
 *
 * @input {boolean} isEventSettingsModalVisible - Indicates if the event settings modal is visible.
 * @input {() => void} onEventSettingsClose - Callback to close the modal.
 * @input {(options: ModifySettingsOptions) => Promise<void>} onModifyEventSettings - Callback to handle event settings modifications.
 * @input {string} position - Position of the modal on the screen, default is 'topRight'.
 * @input {string} backgroundColor - Background color of the modal, default is '#83c0e9'.
 * @input {string} audioSetting - Current audio setting.
 * @input {string} videoSetting - Current video setting.
 * @input {string} screenshareSetting - Current screenshare setting.
 * @input {string} chatSetting - Current chat setting.
 * @input {(setting: string) => void} updateAudioSetting - Function to update audio setting.
 * @input {(setting: string) => void} updateVideoSetting - Function to update video setting.
 * @input {(setting: string) => void} updateScreenshareSetting - Function to update screenshare setting.
 * @input {(setting: string) => void} updateChatSetting - Function to update chat setting.
 * @input {(isVisible: boolean) => void} updateIsSettingsModalVisible - Function to update modal visibility.
 * @input {string} roomName - Room name associated with the settings.
 * @input {Socket} socket - Socket for real-time communication.
 * @input {ShowAlert} [showAlert] - Optional alert function.
 *
 * @property {string} audioState - Internal state for audio setting.
 * @property {string} videoState - Internal state for video setting.
 * @property {string} screenshareState - Internal state for screenshare setting.
 * @property {string} chatState - Internal state for chat setting.
 * @property {IconDefinition} faTimes - FontAwesome icon for the close button.
 *
 * @constructor
 * @param {ModifySettings} modifySettingsService - Service for modifying settings.
 *
 * @method ngOnInit - Initializes the component and binds the settings modification service.
 * @method ngOnChanges - Updates internal states when `isEventSettingsModalVisible` changes.
 * @param {SimpleChanges} changes - Object containing previous and current values of bound properties.
 *
 * @method updateStatesFromParameters - Sets internal state variables based on input parameters.
 * @method getModalContentStyle - Returns style object for modal content with dynamic positioning and size.
 * @returns {Object} Style object for modal content.
 *
 * @method handleSaveSettings - Invokes the settings modification function with updated values.
 * @returns {Promise<void>} Promise that resolves after saving settings.
 *
 * @method closeModal - Closes the modal.
 */
class EventSettingsModal {
    modifySettingsService;
    isEventSettingsModalVisible = false;
    onEventSettingsClose;
    onModifyEventSettings;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    audioSetting = '';
    videoSetting = '';
    screenshareSetting = '';
    chatSetting = '';
    updateAudioSetting;
    updateVideoSetting;
    updateScreenshareSetting;
    updateChatSetting;
    updateIsSettingsModalVisible;
    roomName = '';
    socket = {};
    showAlert;
    audioState;
    videoState;
    screenshareState;
    chatState;
    faTimes = faTimes;
    constructor(modifySettingsService) {
        this.modifySettingsService = modifySettingsService;
    }
    ngOnInit() {
        if (!this.onModifyEventSettings) {
            this.onModifyEventSettings = this.modifySettingsService.modifySettings.bind(this.modifySettingsService);
        }
    }
    ngOnChanges(changes) {
        if (changes['isEventSettingsModalVisible']) {
            if (this.isEventSettingsModalVisible) {
                this.updateStatesFromParameters();
            }
        }
    }
    updateStatesFromParameters() {
        this.audioState = this.audioSetting;
        this.videoState = this.videoSetting;
        this.screenshareState = this.screenshareSetting;
        this.chatState = this.chatSetting;
    }
    getModalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxHeight: '65%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    async handleSaveSettings() {
        await this.onModifyEventSettings({
            audioSet: this.audioState,
            videoSet: this.videoState,
            screenshareSet: this.screenshareState,
            chatSet: this.chatState,
            updateAudioSetting: this.updateAudioSetting,
            updateVideoSetting: this.updateVideoSetting,
            updateScreenshareSetting: this.updateScreenshareSetting,
            updateChatSetting: this.updateChatSetting,
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible,
            roomName: this.roomName,
            socket: this.socket,
            showAlert: this.showAlert,
        });
    }
    closeModal() {
        this.onEventSettingsClose();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: EventSettingsModal, deps: [{ token: ModifySettings }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: EventSettingsModal, isStandalone: true, selector: "app-event-settings-modal", inputs: { isEventSettingsModalVisible: "isEventSettingsModalVisible", onEventSettingsClose: "onEventSettingsClose", onModifyEventSettings: "onModifyEventSettings", position: "position", backgroundColor: "backgroundColor", audioSetting: "audioSetting", videoSetting: "videoSetting", screenshareSetting: "screenshareSetting", chatSetting: "chatSetting", updateAudioSetting: "updateAudioSetting", updateVideoSetting: "updateVideoSetting", updateScreenshareSetting: "updateScreenshareSetting", updateChatSetting: "updateChatSetting", updateIsSettingsModalVisible: "updateIsSettingsModalVisible", roomName: "roomName", socket: "socket", showAlert: "showAlert" }, usesOnChanges: true, ngImport: i0, template: "<!-- event-settings-modal.component.html -->\r\n\r\n<div *ngIf=\"isEventSettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"getModalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Event Settings</div>\r\n      <div (click)=\"closeModal()\" class=\"icon-close\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User audio:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"audioState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User video:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"videoState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User screenshare:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"screenshareState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User chat:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"chatState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n        </select>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"btn-apply-settings\" (click)=\"handleSaveSettings()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:999}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.icon-close{cursor:pointer}.hr{height:1px;background-color:#000;margin:5px 0}.modal-body .form-group{margin-bottom:10px}.label{font-size:medium;color:#000;margin-bottom:5px;font-weight:700;margin-right:10px}.picker-select{font-size:medium;padding:6px 5px;border:1px solid gray;border-radius:4px;color:#000;background-color:#fff}.sep{height:1px;background-color:#fff;margin:2px 0}.modal-footer{margin-top:10px;display:flex;justify-content:flex-end}.btn-apply-settings{padding:5px 10px;border-radius:5px;background-color:#000;color:#fff;font-size:medium;cursor:pointer}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: EventSettingsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-event-settings-modal', imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<!-- event-settings-modal.component.html -->\r\n\r\n<div *ngIf=\"isEventSettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"getModalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Event Settings</div>\r\n      <div (click)=\"closeModal()\" class=\"icon-close\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User audio:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"audioState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User video:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"videoState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User screenshare:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"screenshareState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n          <option value=\"approval\">Upon approval</option>\r\n        </select>\r\n      </div>\r\n      <div class=\"sep\"></div>\r\n      <div class=\"form-group\">\r\n        <label class=\"label\">User chat:</label>\r\n        <select class=\"picker-select\" [(ngModel)]=\"chatState\">\r\n          <option value=\"disallow\">Disallow</option>\r\n          <option value=\"allow\">Allow</option>\r\n        </select>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-footer\">\r\n      <button class=\"btn-apply-settings\" (click)=\"handleSaveSettings()\">Save</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:999}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.icon-close{cursor:pointer}.hr{height:1px;background-color:#000;margin:5px 0}.modal-body .form-group{margin-bottom:10px}.label{font-size:medium;color:#000;margin-bottom:5px;font-weight:700;margin-right:10px}.picker-select{font-size:medium;padding:6px 5px;border:1px solid gray;border-radius:4px;color:#000;background-color:#fff}.sep{height:1px;background-color:#fff;margin:2px 0}.modal-footer{margin-top:10px;display:flex;justify-content:flex-end}.btn-apply-settings{padding:5px 10px;border-radius:5px;background-color:#000;color:#fff;font-size:medium;cursor:pointer}\n"] }]
        }], ctorParameters: () => [{ type: ModifySettings }], propDecorators: { isEventSettingsModalVisible: [{
                type: Input
            }], onEventSettingsClose: [{
                type: Input
            }], onModifyEventSettings: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], audioSetting: [{
                type: Input
            }], videoSetting: [{
                type: Input
            }], screenshareSetting: [{
                type: Input
            }], chatSetting: [{
                type: Input
            }], updateAudioSetting: [{
                type: Input
            }], updateVideoSetting: [{
                type: Input
            }], updateScreenshareSetting: [{
                type: Input
            }], updateChatSetting: [{
                type: Input
            }], updateIsSettingsModalVisible: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], showAlert: [{
                type: Input
            }] } });

/**
 * ConfirmExitModal component renders a modal view for exit confirmation,
 * allowing users to confirm or cancel an exit event from a session or room.
 *
 * @component
 * @selector app-confirm-exit-modal
 * @standalone true
 * @imports [CommonModule, FormsModule, FontAwesomeModule]
 *
 * @example
 * ```html
 * <app-confirm-exit-modal
 *   [isConfirmExitModalVisible]="true"
 *   [onConfirmExitClose]="closeModal"
 *   [exitEventOnConfirm]="confirmExit"
 *   [member]="memberName"
 *   [ban]="false"
 *   [roomName]="currentRoom"
 *   [socket]="socketInstance"
 *   [islevel]="userLevel">
 * </app-confirm-exit-modal>
 * ```
 *
 * @input {boolean} isConfirmExitModalVisible - Determines the visibility of the modal.
 * @input {() => void} onConfirmExitClose - Callback to close the modal.
 * @input {string} position - Position on the screen (default: 'topRight').
 * @input {string} backgroundColor - Background color of the modal (default: '#83c0e9').
 * @input {(options: ConfirmExitOptions) => void} exitEventOnConfirm - Callback function to handle exit confirmation.
 * @input {string} member - Identifies the member for whom the exit is confirmed.
 * @input {boolean} ban - Indicates if the exit action includes a ban.
 * @input {string} roomName - Name of the room involved in the exit action.
 * @input {Socket} socket - Socket instance for real-time interaction.
 * @input {string} islevel - User level information.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for the close button.
 * @property {any} modalContentStyle - Object defining the style for modal content.
 *
 * @constructor
 * @param {ConfirmExit} confirmExitService - Service to handle the exit confirmation.
 *
 * @method ngOnInit - Initializes component properties and default styles for the modal content.
 * @method ngOnChanges - Updates component state upon changes in input properties.
 * @param {SimpleChanges} changes - Object containing the current and previous property values.
 *
 * @method handleConfirmExit - Handles the exit confirmation event, triggering the provided `exitEventOnConfirm` function and then closing the modal.
 */
class ConfirmExitModal {
    confirmExitService;
    isConfirmExitModalVisible = false;
    onConfirmExitClose;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    exitEventOnConfirm;
    member = '';
    ban = false;
    roomName = '';
    socket = {};
    islevel = '';
    faTimes = faTimes;
    modalContentStyle;
    constructor(confirmExitService) {
        this.confirmExitService = confirmExitService;
    }
    ngOnInit() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        this.modalContentStyle = {
            backgroundColor: this.backgroundColor,
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
            width: `${modalWidth}px`,
        };
        if (!this.exitEventOnConfirm) {
            this.exitEventOnConfirm = this.confirmExitService.confirmExit.bind(this.confirmExitService);
        }
    }
    ngOnChanges(changes) {
        if (changes['isConfirmExitModalVisible'] && changes['islevel']) {
            this.islevel = changes['islevel'].currentValue;
        }
    }
    handleConfirmExit() {
        this.exitEventOnConfirm({
            socket: this.socket,
            member: this.member,
            roomName: this.roomName,
            ban: this.ban,
        });
        this.onConfirmExitClose();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfirmExitModal, deps: [{ token: ConfirmExit }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ConfirmExitModal, isStandalone: true, selector: "app-confirm-exit-modal", inputs: { isConfirmExitModalVisible: "isConfirmExitModalVisible", onConfirmExitClose: "onConfirmExitClose", position: "position", backgroundColor: "backgroundColor", exitEventOnConfirm: "exitEventOnConfirm", member: "member", ban: "ban", roomName: "roomName", socket: "socket", islevel: "islevel" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isConfirmExitModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\" style=\"display: flex; justify-content: space-between;\">\r\n      <h2 class=\"modal-title\">Confirm Exit</h2>\r\n      <span class=\"close-icon\" (click)=\"onConfirmExitClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"lg\"></fa-icon>\r\n      </span>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <p class=\"confirm-exit-text\">\r\n        {{ islevel === '2' ? 'This will end the event for all. Confirm exit.' : 'Are you sure you want to exit?' }}\r\n      </p>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-footer\">\r\n      <button class=\"cancel-button\" (click)=\"onConfirmExitClose()\">Cancel</button>\r\n      <button class=\"confirm-button\" (click)=\"handleConfirmExit()\">\r\n        {{ islevel === '2' ? 'End Event' : 'Exit' }}\r\n      </button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:350px;max-height:65%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between}.close-icon{cursor:pointer;color:#000;font-size:large;font-weight:700;margin-right:20px}.modal-footer{display:flex;justify-content:flex-end}.cancel-button,.confirm-button{border-radius:5px;color:#fff;padding:5px 10px}.cancel-button{background-color:#000;margin-right:20px}.confirm-button{background-color:red}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FormsModule }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfirmExitModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-confirm-exit-modal', imports: [CommonModule, FormsModule, FontAwesomeModule], template: "<div *ngIf=\"isConfirmExitModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\" style=\"display: flex; justify-content: space-between;\">\r\n      <h2 class=\"modal-title\">Confirm Exit</h2>\r\n      <span class=\"close-icon\" (click)=\"onConfirmExitClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"lg\"></fa-icon>\r\n      </span>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <p class=\"confirm-exit-text\">\r\n        {{ islevel === '2' ? 'This will end the event for all. Confirm exit.' : 'Are you sure you want to exit?' }}\r\n      </p>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-footer\">\r\n      <button class=\"cancel-button\" (click)=\"onConfirmExitClose()\">Cancel</button>\r\n      <button class=\"confirm-button\" (click)=\"handleConfirmExit()\">\r\n        {{ islevel === '2' ? 'End Event' : 'Exit' }}\r\n      </button>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:350px;max-height:65%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between}.close-icon{cursor:pointer;color:#000;font-size:large;font-weight:700;margin-right:20px}.modal-footer{display:flex;justify-content:flex-end}.cancel-button,.confirm-button{border-radius:5px;color:#fff;padding:5px 10px}.cancel-button{background-color:#000;margin-right:20px}.confirm-button{background-color:red}\n"] }]
        }], ctorParameters: () => [{ type: ConfirmExit }], propDecorators: { isConfirmExitModalVisible: [{
                type: Input
            }], onConfirmExitClose: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], exitEventOnConfirm: [{
                type: Input
            }], member: [{
                type: Input
            }], ban: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], islevel: [{
                type: Input
            }] } });

/**
 * MediaSettingsModal component renders a modal interface for managing media settings.
 * Users can switch between different audio and video input devices and adjust other settings.
 *
 * @component
 * @selector app-media-settings-modal
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule, FormsModule]
 *
 * @example
 * ```html
 * <app-media-settings-modal
 *   [isMediaSettingsModalVisible]="true"
 *   [onMediaSettingsClose]="closeModal"
 *   [switchCameraOnPress]="handleCameraSwitch"
 *   [switchVideoOnPress]="handleVideoSwitch"
 *   [switchAudioOnPress]="handleAudioSwitch"
 *   [parameters]="mediaSettingsParams"
 *   position="topRight"
 *   backgroundColor="#83c0e9">
 * </app-media-settings-modal>
 * ```
 *
 * @input {boolean} isMediaSettingsModalVisible - Indicates whether the modal is visible.
 * @input {() => void} onMediaSettingsClose - Function to close the modal.
 * @input {(params: SwitchVideoAltOptions) => Promise<void>} switchCameraOnPress - Function to handle camera switching.
 * @input {(params: SwitchVideoOptions) => Promise<void>} switchVideoOnPress - Function to handle video switching.
 * @input {(params: SwitchAudioOptions) => Promise<void>} switchAudioOnPress - Function to handle audio switching.
 * @input {MediaSettingsModalParameters} parameters - Parameters for the modal.
 * @input {string} position - Position of the modal on the screen (default: 'topRight').
 * @input {string} backgroundColor - Background color of the modal (default: '#83c0e9').
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for closing the modal.
 * @property {IconDefinition} faSyncAlt - FontAwesome icon for sync.
 * @property {IconDefinition} faCamera - FontAwesome icon for camera.
 * @property {IconDefinition} faMicrophone - FontAwesome icon for microphone.
 * @property {IconDefinition} faPhotoFilm - FontAwesome icon for photo film.
 *
 * @property {string} selectedVideoInput - Currently selected video input device ID.
 * @property {string} selectedAudioInput - Currently selected audio input device ID.
 * @property {string} prevSelectedVideoInput - Previously selected video input device ID.
 * @property {string} prevSelectedAudioInput - Previously selected audio input device ID.
 *
 * @constructor
 * @param {SwitchAudio} switchAudioService - Service for switching audio.
 * @param {SwitchVideo} switchVideoService - Service for switching video.
 * @param {SwitchVideoAlt} switchVideoAltService - Alternative service for switching video.
 *
 * @method ngOnInit - Initializes the component and sets up default selections and services.
 * @method ngOnChanges - Updates component state based on input changes.
 * @method setupDefaultServices - Configures default services for switching camera, video, and audio.
 * @method updateParameters - Updates the modal parameters.
 * @method ensureDefaultSelections - Ensures default selections for video and audio inputs.
 * @method initializeModalSettings - Initializes the modal settings.
 * @method modalContentStyle - Returns the style object for the modal content.
 * @method handleSwitchCamera - Initiates camera switching.
 * @method handleVideoSwitch - Initiates video input switching.
 * @method handleAudioSwitch - Initiates audio input switching.
 * @method handleModalClose - Closes the modal.
 * @method showVirtual - Toggles the virtual background modal.
 */
class MediaSettingsModal {
    switchAudioService;
    switchVideoService;
    switchVideoAltService;
    isMediaSettingsModalVisible = false;
    onMediaSettingsClose;
    switchCameraOnPress;
    switchVideoOnPress;
    switchAudioOnPress;
    parameters;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    faTimes = faTimes;
    faSyncAlt = faSyncAlt;
    faCamera = faCamera;
    faMicrophone = faMicrophone;
    faPhotoFilm = faPhotoFilm;
    selectedVideoInput;
    selectedAudioInput;
    prevSelectedVideoInput;
    prevSelectedAudioInput;
    constructor(switchAudioService, switchVideoService, switchVideoAltService) {
        this.switchAudioService = switchAudioService;
        this.switchVideoService = switchVideoService;
        this.switchVideoAltService = switchVideoAltService;
    }
    ngOnInit() {
        if (this.isMediaSettingsModalVisible) {
            this.updateParameters();
            this.setupDefaultServices();
            this.initializeModalSettings();
            this.ensureDefaultSelections();
        }
    }
    ngOnChanges(changes) {
        if (changes['isMediaSettingsModalVisible'] &&
            this.isMediaSettingsModalVisible &&
            this.parameters) {
            this.updateParameters();
            this.setupDefaultServices();
            this.ensureDefaultSelections();
        }
    }
    setupDefaultServices() {
        if (!this.switchCameraOnPress) {
            this.switchCameraOnPress = (params) => this.switchVideoAltService.switchVideoAlt(params);
        }
        if (!this.switchVideoOnPress) {
            this.switchVideoOnPress = (params) => this.switchVideoService.switchVideo(params);
        }
        if (!this.switchAudioOnPress) {
            this.switchAudioOnPress = (params) => this.switchAudioService.switchAudio(params);
        }
    }
    updateParameters() {
        this.parameters = {
            ...this.parameters,
            ...this.parameters.getUpdatedAllParams(),
        };
    }
    ensureDefaultSelections() {
        if (!this.selectedVideoInput && this.parameters.videoInputs.length > 0) {
            this.selectedVideoInput = this.parameters.videoInputs[0].deviceId;
            this.prevSelectedVideoInput = this.selectedVideoInput;
            this.handleVideoSwitch({ target: { value: this.selectedVideoInput } });
        }
        if (!this.selectedAudioInput && this.parameters.audioInputs.length > 0) {
            this.selectedAudioInput = this.parameters.audioInputs[0].deviceId;
            this.prevSelectedAudioInput = this.selectedAudioInput;
            this.handleAudioSwitch({ target: { value: this.selectedAudioInput } });
        }
    }
    initializeModalSettings() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.7 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
    }
    modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxHeight: '65%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    handleSwitchCamera = async () => {
        await this.switchCameraOnPress({ parameters: this.parameters });
    };
    handleVideoSwitch = async (event) => {
        const value = event.target.value;
        if (value !== this.prevSelectedVideoInput) {
            this.selectedVideoInput = value;
            this.prevSelectedVideoInput = this.selectedVideoInput;
            await this.switchVideoOnPress({ videoPreference: value, parameters: this.parameters });
        }
    };
    handleAudioSwitch = async (event) => {
        const value = event.target.value;
        if (value !== this.prevSelectedAudioInput) {
            this.selectedAudioInput = value;
            this.prevSelectedAudioInput = this.selectedAudioInput;
            await this.switchAudioOnPress({ audioPreference: value, parameters: this.parameters });
        }
    };
    handleModalClose() {
        this.onMediaSettingsClose();
    }
    showVirtual() {
        this.parameters.updateIsBackgroundModalVisible(!this.parameters.isBackgroundModalVisible);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediaSettingsModal, deps: [{ token: SwitchAudio }, { token: SwitchVideo }, { token: SwitchVideoAlt }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MediaSettingsModal, isStandalone: true, selector: "app-media-settings-modal", inputs: { isMediaSettingsModalVisible: "isMediaSettingsModalVisible", onMediaSettingsClose: "onMediaSettingsClose", switchCameraOnPress: "switchCameraOnPress", switchVideoOnPress: "switchVideoOnPress", switchAudioOnPress: "switchAudioOnPress", parameters: "parameters", position: "position", backgroundColor: "backgroundColor" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isMediaSettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Media Settings</div>\r\n      <div (click)=\"handleModalClose()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label>\r\n          <fa-icon [icon]=\"faCamera\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Select Camera:\r\n        </label>\r\n        <select [(ngModel)]=\"selectedVideoInput\" (change)=\"handleVideoSwitch($event)\" class=\"form-control\">\r\n          <option *ngFor=\"let input of parameters.videoInputs\" [value]=\"input.deviceId\">\r\n            {{ input.label }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <div class=\"form-group\">\r\n        <label>\r\n          <fa-icon [icon]=\"faMicrophone\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Select Microphone:\r\n        </label>\r\n        <select [(ngModel)]=\"selectedAudioInput\" (change)=\"handleAudioSwitch($event)\" class=\"form-control\">\r\n          <option *ngFor=\"let input of parameters.audioInputs\" [value]=\"input.deviceId\">\r\n            {{ input.label }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <hr class=\"hr\" />\r\n      <div class=\"form-group\">\r\n        <button (click)=\"handleSwitchCamera()\" class=\"btn-switch\">\r\n          <fa-icon [icon]=\"faSyncAlt\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Switch Camera\r\n        </button>\r\n      </div>\r\n      <hr class=\"hr\" />\r\n      <div class=\"form-group\">\r\n        <button (click)=\"showVirtual()\" class=\"btn-virtual\">\r\n          <fa-icon [icon]=\"faPhotoFilm\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Virtual Background\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:999}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:5px}.modal-title{font-size:18px;font-weight:700;color:#000}.icon{cursor:pointer;color:#000;font-size:24px;font-weight:700}.form-group{margin-bottom:15px}.form-group label{display:flex;align-items:center;font-size:16px;margin-bottom:5px}.form-control{width:100%;padding:8px;font-size:16px;border:1px solid #ccc;border-radius:4px}.hr{margin:10px 0;border:none;border-top:1px solid #ccc}.btn-switch,.btn-virtual{width:100%;padding:10px;border:none;border-radius:5px;cursor:pointer;font-size:16px;margin-bottom:10px}.btn-switch,.btn-virtual{background-color:#83c0e9;color:#000}.btn-switch:hover,.btn-virtual:hover{background-color:#6aa6d1}.btn-switch:focus,.btn-virtual:focus{outline:none}.button{border-radius:5px;color:#fff;padding:5px 10px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediaSettingsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-media-settings-modal', imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div *ngIf=\"isMediaSettingsModalVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Media Settings</div>\r\n      <div (click)=\"handleModalClose()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <label>\r\n          <fa-icon [icon]=\"faCamera\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Select Camera:\r\n        </label>\r\n        <select [(ngModel)]=\"selectedVideoInput\" (change)=\"handleVideoSwitch($event)\" class=\"form-control\">\r\n          <option *ngFor=\"let input of parameters.videoInputs\" [value]=\"input.deviceId\">\r\n            {{ input.label }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <div class=\"form-group\">\r\n        <label>\r\n          <fa-icon [icon]=\"faMicrophone\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Select Microphone:\r\n        </label>\r\n        <select [(ngModel)]=\"selectedAudioInput\" (change)=\"handleAudioSwitch($event)\" class=\"form-control\">\r\n          <option *ngFor=\"let input of parameters.audioInputs\" [value]=\"input.deviceId\">\r\n            {{ input.label }}\r\n          </option>\r\n        </select>\r\n      </div>\r\n      <hr class=\"hr\" />\r\n      <div class=\"form-group\">\r\n        <button (click)=\"handleSwitchCamera()\" class=\"btn-switch\">\r\n          <fa-icon [icon]=\"faSyncAlt\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Switch Camera\r\n        </button>\r\n      </div>\r\n      <hr class=\"hr\" />\r\n      <div class=\"form-group\">\r\n        <button (click)=\"showVirtual()\" class=\"btn-virtual\">\r\n          <fa-icon [icon]=\"faPhotoFilm\" [ngStyle]=\"{'margin-right': '8px'}\"></fa-icon> Virtual Background\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:999}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:5px}.modal-title{font-size:18px;font-weight:700;color:#000}.icon{cursor:pointer;color:#000;font-size:24px;font-weight:700}.form-group{margin-bottom:15px}.form-group label{display:flex;align-items:center;font-size:16px;margin-bottom:5px}.form-control{width:100%;padding:8px;font-size:16px;border:1px solid #ccc;border-radius:4px}.hr{margin:10px 0;border:none;border-top:1px solid #ccc}.btn-switch,.btn-virtual{width:100%;padding:10px;border:none;border-radius:5px;cursor:pointer;font-size:16px;margin-bottom:10px}.btn-switch,.btn-virtual{background-color:#83c0e9;color:#000}.btn-switch:hover,.btn-virtual:hover{background-color:#6aa6d1}.btn-switch:focus,.btn-virtual:focus{outline:none}.button{border-radius:5px;color:#fff;padding:5px 10px}\n"] }]
        }], ctorParameters: () => [{ type: SwitchAudio }, { type: SwitchVideo }, { type: SwitchVideoAlt }], propDecorators: { isMediaSettingsModalVisible: [{
                type: Input
            }], onMediaSettingsClose: [{
                type: Input
            }], switchCameraOnPress: [{
                type: Input
            }], switchVideoOnPress: [{
                type: Input
            }], switchAudioOnPress: [{
                type: Input
            }], parameters: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }] } });

/**
 * CustomButtons component renders a list of customizable buttons.
 *
 * @selector app-custom-buttons
 * @standalone true
 * @imports [CommonModule, FormsModule, FontAwesomeModule]
 *
 * @input {CustomButton[]} buttons - Array of button configurations.
 * Each button configuration includes properties such as:
 * - **action**: Function executed on button click.
 * - **show**: Boolean or function determining button visibility.
 * - **backgroundColor**: Background color of the button.
 * - **disabled**: Boolean to disable button if set to true.
 * - **icon**: Optional FontAwesome icon displayed on the button.
 * - **iconStyle**: Style applied to the icon.
 * - **text**: Text displayed on the button.
 * - **textStyle**: Style applied to the text.
 * - **customComponent**: A custom Angular component or HTML element rendered within the button.
 * - **injector**: Injector used for providing dependencies to the custom component.
 *
 * @example
 * ```html
 * <app-custom-buttons [buttons]="buttonsArray"></app-custom-buttons>
 * ```
 *
 * @example
 * ```typescript
 * const buttonsArray: CustomButton[] = [
 *   {
 *     action: () => console.log('Button 1 clicked'),
 *     show: true,
 *     backgroundColor: 'blue',
 *     disabled: false,
 *     icon: faCoffee,
 *     iconStyle: { color: 'white' },
 *     text: 'Button 1',
 *     textStyle: { color: 'white' },
 *     customComponent: <CustomComponent />,
 *     injector: Injector.create({
 *       providers: [{ provide: 'customProp', useValue: 'customValue' }]
 *     }),
 *   },
 * ];
 * ```
 *
 * @class CustomButtons
 * @method mergeStyles - Merges default styles with user-provided custom styles.
 * @method isCustomComponentConfig - Type guard to check if an object is of type CustomComponent.
 */
class CustomButtons {
    buttons;
    faSpinner = faSpinner;
    mergeStyles(defaultStyle, customStyle) {
        return { ...defaultStyle, ...customStyle };
    }
    get customButtonIcon() {
        return {
            fontSize: '20px',
            marginRight: '5px',
        };
    }
    // Type guard to check if customComponent is of type CustomComponentConfig
    isCustomComponentConfig(obj) {
        return obj && typeof obj === 'object' && 'component' in obj && 'injector' in obj;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CustomButtons, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: CustomButtons, isStandalone: true, selector: "app-custom-buttons", inputs: { buttons: "buttons" }, ngImport: i0, template: "<div class=\"customButtonsContainer\">\r\n  <button\r\n    *ngFor=\"let button of buttons; let i = index\"\r\n    (click)=\"button.action()\"\r\n    class=\"customButton\"\r\n    [ngStyle]=\"{\r\n      'background-color': button.show ? button.backgroundColor : 'transparent',\r\n      'display': button.show ? 'flex' : 'none'\r\n    }\"\r\n    [disabled]=\"button.disabled\"\r\n  >\r\n    <div class=\"buttonContent\">\r\n      <ng-container *ngIf=\"button.icon; else customOrSpinner\">\r\n        <fa-icon [icon]=\"button.icon\" [ngStyle]=\"mergeStyles(customButtonIcon, button.iconStyle)\"></fa-icon>\r\n        <span *ngIf=\"button.text\" class=\"customButtonText\" [ngStyle]=\"button.textStyle\">{{ button.text }}</span>\r\n      </ng-container>\r\n      <ng-template #customOrSpinner>\r\n        <ng-container *ngIf=\"isCustomComponentConfig(button.customComponent)\">\r\n          <ng-container *ngComponentOutlet=\"button.customComponent.component; injector: button.customComponent.injector\"></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"button.customComponent && !isCustomComponentConfig(button.customComponent)\">\r\n          <div #customElementContainer></div>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!button.customComponent\">\r\n          <fa-icon [icon]=\"faSpinner\"></fa-icon>\r\n        </ng-container>\r\n      </ng-template>\r\n    </div>\r\n  </button>\r\n</div>\r\n", styles: [".customButtonsContainer{display:flex;flex-direction:column;flex-wrap:wrap;justify-content:space-between;align-items:left}.customButton{width:100%;margin:10px 0;padding:10px;border-radius:5px;background-color:transparent;align-items:left;justify-content:left;border:none}.buttonContent{display:flex;align-items:left;justify-content:left}.customButtonIcon{font-size:20px;color:#000;margin-right:4px}.customButtonText{color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FormsModule }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CustomButtons, decorators: [{
            type: Component,
            args: [{ selector: 'app-custom-buttons', imports: [CommonModule, FormsModule, FontAwesomeModule], template: "<div class=\"customButtonsContainer\">\r\n  <button\r\n    *ngFor=\"let button of buttons; let i = index\"\r\n    (click)=\"button.action()\"\r\n    class=\"customButton\"\r\n    [ngStyle]=\"{\r\n      'background-color': button.show ? button.backgroundColor : 'transparent',\r\n      'display': button.show ? 'flex' : 'none'\r\n    }\"\r\n    [disabled]=\"button.disabled\"\r\n  >\r\n    <div class=\"buttonContent\">\r\n      <ng-container *ngIf=\"button.icon; else customOrSpinner\">\r\n        <fa-icon [icon]=\"button.icon\" [ngStyle]=\"mergeStyles(customButtonIcon, button.iconStyle)\"></fa-icon>\r\n        <span *ngIf=\"button.text\" class=\"customButtonText\" [ngStyle]=\"button.textStyle\">{{ button.text }}</span>\r\n      </ng-container>\r\n      <ng-template #customOrSpinner>\r\n        <ng-container *ngIf=\"isCustomComponentConfig(button.customComponent)\">\r\n          <ng-container *ngComponentOutlet=\"button.customComponent.component; injector: button.customComponent.injector\"></ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"button.customComponent && !isCustomComponentConfig(button.customComponent)\">\r\n          <div #customElementContainer></div>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!button.customComponent\">\r\n          <fa-icon [icon]=\"faSpinner\"></fa-icon>\r\n        </ng-container>\r\n      </ng-template>\r\n    </div>\r\n  </button>\r\n</div>\r\n", styles: [".customButtonsContainer{display:flex;flex-direction:column;flex-wrap:wrap;justify-content:space-between;align-items:left}.customButton{width:100%;margin:10px 0;padding:10px;border-radius:5px;background-color:transparent;align-items:left;justify-content:left;border:none}.buttonContent{display:flex;align-items:left;justify-content:left}.customButtonIcon{font-size:20px;color:#000;margin-right:4px}.customButtonText{color:#000}\n"] }]
        }], propDecorators: { buttons: [{
                type: Input
            }] } });

/**
 * Component representing a meeting ID.
 *
 * @selector app-meeting-id-component
 * @standalone true
 * @templateUrl ./meeting-id-component.component.html
 * @styleUrls ./meeting-id-component.component.css
 *
 * @example
 * ```html
 * <app-meeting-id-component [meetingID]="'123-456-789'"></app-meeting-id-component>
 * ```
 */
class MeetingIdComponent {
    meetingID = '';
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingIdComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MeetingIdComponent, isStandalone: true, selector: "app-meeting-id-component", inputs: { meetingID: "meetingID" }, ngImport: i0, template: "<div class=\"form-group\">\r\n  <label class=\"label\">Event ID:</label>\r\n  <input\r\n    class=\"disabled-input\"\r\n    [value]=\"meetingID\"\r\n    readonly\r\n  />\r\n</div>\r\n", styles: [".form-group{margin-top:10px;max-width:300px}.label{font-weight:700}.disabled-input{border-width:1px;border-color:gray;padding:10px;margin-top:5px;background-color:#f0f0f0;color:#000;width:100%;border-radius:5px}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingIdComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-meeting-id-component', standalone: true, template: "<div class=\"form-group\">\r\n  <label class=\"label\">Event ID:</label>\r\n  <input\r\n    class=\"disabled-input\"\r\n    [value]=\"meetingID\"\r\n    readonly\r\n  />\r\n</div>\r\n", styles: [".form-group{margin-top:10px;max-width:300px}.label{font-weight:700}.disabled-input{border-width:1px;border-color:gray;padding:10px;margin-top:5px;background-color:#f0f0f0;color:#000;width:100%;border-radius:5px}\n"] }]
        }], propDecorators: { meetingID: [{
                type: Input
            }] } });

/**
 * Component for displaying and managing a meeting passcode.
 *
 * @selector app-meeting-passcode-component
 * @standalone true
 * @templateUrl ./meeting-passcode-component.component.html
 * @styleUrls ./meeting-passcode-component.component.css
 *
 * @example
 * ```html
 * <app-meeting-passcode-component [meetingPasscode]="'ABC123'"></app-meeting-passcode-component>
 * ```
 */
class MeetingPasscodeComponent {
    meetingPasscode = '';
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingPasscodeComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MeetingPasscodeComponent, isStandalone: true, selector: "app-meeting-passcode-component", inputs: { meetingPasscode: "meetingPasscode" }, ngImport: i0, template: "<div class=\"form-group\">\r\n  <label class=\"label\">Event Passcode (Host):</label>\r\n  <input\r\n    class=\"disabled-input\"\r\n    [value]=\"meetingPasscode\"\r\n    readonly\r\n  />\r\n</div>\r\n", styles: [".form-group{margin-top:10px;max-width:300px}.label{font-weight:700}.disabled-input{border-width:1px;border-color:gray;padding:10px;margin-top:5px;background-color:#f0f0f0;color:#000;width:100%;border-radius:5px}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MeetingPasscodeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-meeting-passcode-component', standalone: true, template: "<div class=\"form-group\">\r\n  <label class=\"label\">Event Passcode (Host):</label>\r\n  <input\r\n    class=\"disabled-input\"\r\n    [value]=\"meetingPasscode\"\r\n    readonly\r\n  />\r\n</div>\r\n", styles: [".form-group{margin-top:10px;max-width:300px}.label{font-weight:700}.disabled-input{border-width:1px;border-color:gray;padding:10px;margin-top:5px;background-color:#f0f0f0;color:#000;width:100%;border-radius:5px}\n"] }]
        }], propDecorators: { meetingPasscode: [{
                type: Input
            }] } });

/**
 * @component ShareButtonsComponent
 * @selector app-share-buttons-component
 * @description Displays a set of share buttons for sharing a meeting link on social media and email.
 *
 * @example
 * ```html
 * <app-share-buttons-component
 *   [meetingID]="'12345'"
 *   [eventType]="'broadcast'"
 *   [shareButtons]="customShareButtons"
 *   [localLink]="'https://www.google.com'"
 * ></app-share-buttons-component>
 * ```
 *
 * ```typescript
 * const customShareButtons = [
 *   { icon: faEnvelope, action: () => console.log('Email'), show: true },
 *   { icon: faFacebook, action: () => console.log('Facebook'), show: true },
 * ];
 * ```
 */
class ShareButtonsComponent {
    meetingID;
    shareButtons = [];
    eventType;
    localLink;
    defaultShareButtons = [
        {
            icon: faCopy,
            action: async () => {
                try {
                    await navigator.clipboard.writeText(this.getShareUrl());
                }
                catch (error) {
                    console.error('Failed to copy to clipboard:', error);
                }
            },
            show: true,
        },
        {
            icon: faEnvelope,
            action: () => {
                const emailUrl = `mailto:?subject=Join my meeting&body=Here's the link to the meeting: ${this.getShareUrl()}`;
                window.open(emailUrl, '_blank');
            },
            show: true,
        },
        {
            icon: faFacebook,
            action: () => {
                const facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(this.getShareUrl())}`;
                window.open(facebookUrl, '_blank');
            },
            show: true,
        },
        {
            icon: faWhatsapp,
            action: () => {
                const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(this.getShareUrl())}`;
                window.open(whatsappUrl, '_blank');
            },
            show: true,
        },
        {
            icon: faTelegram,
            action: () => {
                const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(this.getShareUrl())}`;
                window.open(telegramUrl, '_blank');
            },
            show: true,
        },
    ];
    get shareName() {
        return this.eventType === 'chat'
            ? 'chat'
            : this.eventType === 'broadcast'
                ? 'broadcast'
                : 'meeting';
    }
    getShareUrl() {
        if (this.localLink && !this.localLink.includes('mediasfu.com')) {
            return `${this.localLink}/meeting/${this.meetingID}`;
        }
        return `https://${this.shareName}.mediasfu.com/${this.shareName}/${this.meetingID}`;
    }
    get filteredShareButtons() {
        return this.shareButtons.length > 0
            ? this.shareButtons.filter((button) => button.show)
            : this.defaultShareButtons.filter((button) => button.show);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ShareButtonsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ShareButtonsComponent, isStandalone: true, selector: "app-share-buttons-component", inputs: { meetingID: "meetingID", shareButtons: "shareButtons", eventType: "eventType", localLink: "localLink" }, ngImport: i0, template: "<div class=\"share-buttons-container\">\r\n  <div\r\n    *ngFor=\"let button of filteredShareButtons; let i = index\"\r\n    (click)=\"button.action()\"\r\n    [ngStyle]=\"{\r\n      'background-color': button.color || 'black',\r\n      'margin-right': i !== filteredShareButtons.length - 1 ? '10px' : '0'\r\n    }\"\r\n    class=\"share-button\"\r\n  >\r\n    <fa-icon [icon]=\"button.icon\" [ngStyle]=\"{ color: button.iconColor || '#ffffff', 'font-size': '24px' }\"></fa-icon>\r\n  </div>\r\n</div>\r\n", styles: [".share-buttons-container{display:flex;flex-direction:row;margin:10px 0}.share-button{display:flex;align-items:center;justify-content:center;padding:10px;border-radius:5px;margin:0 5px;cursor:pointer}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ShareButtonsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-share-buttons-component', imports: [CommonModule, FontAwesomeModule], template: "<div class=\"share-buttons-container\">\r\n  <div\r\n    *ngFor=\"let button of filteredShareButtons; let i = index\"\r\n    (click)=\"button.action()\"\r\n    [ngStyle]=\"{\r\n      'background-color': button.color || 'black',\r\n      'margin-right': i !== filteredShareButtons.length - 1 ? '10px' : '0'\r\n    }\"\r\n    class=\"share-button\"\r\n  >\r\n    <fa-icon [icon]=\"button.icon\" [ngStyle]=\"{ color: button.iconColor || '#ffffff', 'font-size': '24px' }\"></fa-icon>\r\n  </div>\r\n</div>\r\n", styles: [".share-buttons-container{display:flex;flex-direction:row;margin:10px 0}.share-button{display:flex;align-items:center;justify-content:center;padding:10px;border-radius:5px;margin:0 5px;cursor:pointer}\n"] }]
        }], propDecorators: { meetingID: [{
                type: Input
            }], shareButtons: [{
                type: Input
            }], eventType: [{
                type: Input
            }], localLink: [{
                type: Input
            }] } });

/**
 * Component for displaying a customizable menu modal with various options.
 *
 * @selector app-menu-modal
 * @standalone true
 * @templateUrl ./menu-modal.component.html
 * @styleUrls ./menu-modal.component.css
 *
 * @example
 * ```html
 * <app-menu-modal
 *   [isVisible]="true"
 *   backgroundColor="#83c0e9"
 *   roomName="Room 123"
 *   adminPasscode="AdminPass"
 *   [customButtons]="customButtons"
 *   [shareButtons]="true"
 *   position="bottomRight"
 *   islevel="2"
 *   eventType="meeting"
 *   localLink="https://www.google.com"
 *   (onClose)="closeMenu()"
 * ></app-menu-modal>
 * ```
 *
 * ```typescript
 * const customButtons = [
 *   { action: () => console.log('Clicked'), show: true, text: 'Button' },
 * ];
 * closeMenu() { console.log('Menu closed'); }
 * ```
 */
class MenuModal {
    backgroundColor = '#83c0e9';
    isVisible;
    customButtons = [];
    shareButtons = true;
    position = 'bottomRight';
    roomName;
    adminPasscode;
    islevel;
    eventType;
    localLink;
    // Define inputs for functions
    onClose;
    faBars = faBars;
    faTimes = faTimes;
    modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isVisible ? 'block' : 'none',
            zIndex: 999,
        };
    }
    modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.7 * screenWidth;
        if (modalWidth > 400) {
            modalWidth = 400;
        }
        return {
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '5px',
            width: `${modalWidth}px`,
            maxHeight: '80%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    handleClose() {
        this.onClose();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MenuModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MenuModal, isStandalone: true, selector: "app-menu-modal", inputs: { backgroundColor: "backgroundColor", isVisible: "isVisible", customButtons: "customButtons", shareButtons: "shareButtons", position: "position", roomName: "roomName", adminPasscode: "adminPasscode", islevel: "islevel", eventType: "eventType", localLink: "localLink", onClose: "onClose" }, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;\">\r\n      <div style=\"font-size: 18px; font-weight: bold; color: black;\">\r\n        <fa-icon [icon]=\"faBars\" style=\"font-size: 20px; color: black;\"></fa-icon> Menu\r\n      </div>\r\n      <div (click)=\"handleClose()\" style=\"padding: 5px;\">\r\n        <fa-icon [icon]=\"faTimes\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n    <div style=\"flex: 1;\">\r\n      <div style=\"max-height: calc(70% - 70px); overflow-y: auto;\">\r\n        <app-custom-buttons [buttons]=\"customButtons\"></app-custom-buttons>\r\n        <div style=\"height: 1px; background-color: #ffffff; margin: 10px 0;\"></div>\r\n        <ng-container *ngIf=\"islevel === '2'\">\r\n          <app-meeting-passcode-component\r\n            [meetingPasscode]=\"adminPasscode\"\r\n          ></app-meeting-passcode-component>\r\n        </ng-container>\r\n        <div style=\"margin-bottom: 10px;\">\r\n          <app-meeting-id-component [meetingID]=\"roomName\"></app-meeting-id-component>\r\n        </div>\r\n        <ng-container *ngIf=\"true\">\r\n          <app-share-buttons-component [meetingID]=\"roomName\" [eventType]=\"eventType\" [localLink]=\"localLink\"></app-share-buttons-component>\r\n        </ng-container>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:9}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "component", type: CustomButtons, selector: "app-custom-buttons", inputs: ["buttons"] }, { kind: "component", type: MeetingIdComponent, selector: "app-meeting-id-component", inputs: ["meetingID"] }, { kind: "component", type: MeetingPasscodeComponent, selector: "app-meeting-passcode-component", inputs: ["meetingPasscode"] }, { kind: "component", type: ShareButtonsComponent, selector: "app-share-buttons-component", inputs: ["meetingID", "shareButtons", "eventType", "localLink"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MenuModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-menu-modal', imports: [
                        CommonModule,
                        FontAwesomeModule,
                        FormsModule,
                        CustomButtons,
                        MeetingIdComponent,
                        MeetingPasscodeComponent,
                        ShareButtonsComponent,
                    ], template: "<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div class=\"modal-content\" [ngStyle]=\"modalContentStyle()\">\r\n    <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;\">\r\n      <div style=\"font-size: 18px; font-weight: bold; color: black;\">\r\n        <fa-icon [icon]=\"faBars\" style=\"font-size: 20px; color: black;\"></fa-icon> Menu\r\n      </div>\r\n      <div (click)=\"handleClose()\" style=\"padding: 5px;\">\r\n        <fa-icon [icon]=\"faTimes\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n    <div style=\"flex: 1;\">\r\n      <div style=\"max-height: calc(70% - 70px); overflow-y: auto;\">\r\n        <app-custom-buttons [buttons]=\"customButtons\"></app-custom-buttons>\r\n        <div style=\"height: 1px; background-color: #ffffff; margin: 10px 0;\"></div>\r\n        <ng-container *ngIf=\"islevel === '2'\">\r\n          <app-meeting-passcode-component\r\n            [meetingPasscode]=\"adminPasscode\"\r\n          ></app-meeting-passcode-component>\r\n        </ng-container>\r\n        <div style=\"margin-bottom: 10px;\">\r\n          <app-meeting-id-component [meetingID]=\"roomName\"></app-meeting-id-component>\r\n        </div>\r\n        <ng-container *ngIf=\"true\">\r\n          <app-share-buttons-component [meetingID]=\"roomName\" [eventType]=\"eventType\" [localLink]=\"localLink\"></app-share-buttons-component>\r\n        </ng-container>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:flex;justify-content:center;align-items:center;z-index:9}.modal-content{position:absolute;display:flex;flex-direction:column}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}\n"] }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], isVisible: [{
                type: Input
            }], customButtons: [{
                type: Input
            }], shareButtons: [{
                type: Input
            }], position: [{
                type: Input
            }], roomName: [{
                type: Input
            }], adminPasscode: [{
                type: Input
            }], islevel: [{
                type: Input
            }], eventType: [{
                type: Input
            }], localLink: [{
                type: Input
            }], onClose: [{
                type: Input
            }] } });

/**
 * @fileoverview MessagePanel component for handling message interactions in the MediaSFU-Angular application.
 *
 * @component
 * @selector app-message-panel
 * @templateUrl ./message-panel.component.html
 * @styleUrls ['./message-panel.component.css']
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule, FormsModule]
 *
 * @description
 * The MessagePanel component is responsible for displaying and managing messages in a chat interface.
 * It supports both group and direct messaging, and includes various input properties to customize its behavior.
 *
 * @property {Array<any>} messages - Array of messages to be displayed.
 * @property {number} messagesLength - The length of the messages array.
 * @property {string} type - The type of chat, either 'group' or 'direct'.
 * @property {string} username - The username of the current user.
 * @property {(options: SendMessageOptions) => Promise<void>} onSendMessagePress - Function to handle sending messages.
 * @property {string} backgroundColor - Background color of the message panel.
 * @property {boolean} focusedInput - Indicates if the input field is focused.
 * @property {EventType} eventType - The type of event, e.g., 'webinar'.
 * @property {string} member - The member associated with the chat.
 * @property {string} islevel - The level of the user.
 * @property {boolean} startDirectMessage - Indicates if a direct message should be started.
 * @property {(start: boolean) => void} updateStartDirectMessage - Function to update the startDirectMessage state.
 * @property {Participant | null} directMessageDetails - Details of the participant for direct messaging.
 * @property {(participant: Participant | null) => void} updateDirectMessageDetails - Function to update directMessageDetails.
 * @property {CoHostResponsibility[]} coHostResponsibility - Array of co-host responsibilities.
 * @property {string} coHost - The co-host of the chat.
 * @property {string} roomName - The name of the chat room.
 * @property {Socket} socket - The socket connection for real-time communication.
 * @property {string} chatSetting - Settings for the chat.
 * @property {ShowAlert} [showAlert] - Optional function to show alerts.
 *
 * @property {IconDefinition} faPaperPlane - FontAwesome icon for paper plane.
 * @property {IconDefinition} faReply - FontAwesome icon for reply.
 *
 * @property {any} replyInfo - Information about the reply.
 * @property {string | null} senderId - ID of the sender.
 * @property {string} directMessageText - Text of the direct message.
 * @property {string} groupMessageText - Text of the group message.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method defaultSendMessage - Default implementation for sending a message.
 * @method handleTextInputChange - Handles changes in the text input field.
 * @method openReplyInput - Opens the reply input for a specific sender.
 * @method handleSendButton - Handles the send button click event.
 *
 * @example
 * ```html
 * <app-message-panel
 *   [messages]="chatMessages"
 *   [messagesLength]="chatMessages.length"
 *   [type]="'group'"
 *   [username]="'JohnDoe'"
 *   [onSendMessagePress]="sendMessage"
 *   [focusedInput]="true"
 *   [eventType]="'webinar'"
 *   [member]="'JohnDoe'"
 *   [islevel]="'2'"
 *   [startDirectMessage]="false"
 *   [updateStartDirectMessage]="updateDirectMessageStart"
 *   [directMessageDetails]="selectedParticipant"
 *   [updateDirectMessageDetails]="updateParticipantDetails"
 *   [coHostResponsibility]="coHostRoles"
 *   [coHost]="'coHost123'"
 *   [roomName]="'RoomName'"
 *   [socket]="chatSocket"
 *   [chatSetting]="'enabled'"
 * ></app-message-panel>
 * ```
 */
class MessagePanel {
    messages = [];
    messagesLength = 0;
    type = 'group';
    username = '';
    onSendMessagePress;
    backgroundColor = '#f5f5f5';
    focusedInput = false;
    eventType = 'webinar';
    member = '';
    islevel = '';
    startDirectMessage = false;
    updateStartDirectMessage;
    directMessageDetails = null;
    updateDirectMessageDetails;
    coHostResponsibility = [];
    coHost = '';
    roomName = '';
    socket = {};
    chatSetting = '';
    showAlert;
    faPaperPlane = faPaperPlane;
    faReply = faReply;
    replyInfo = null;
    senderId = null;
    directMessageText = '';
    groupMessageText = '';
    ngOnInit() {
        if (!this.onSendMessagePress) {
            this.onSendMessagePress = this.defaultSendMessage.bind(this);
        }
    }
    defaultSendMessage() {
        // Default send message implementation
        return Promise.resolve();
    }
    handleTextInputChange(event) {
        const text = event.target.value;
        if (this.type === 'direct') {
            this.directMessageText = text;
        }
        else {
            this.groupMessageText = text;
        }
    }
    ngOnChanges() {
        if (this.startDirectMessage && this.directMessageDetails) {
            this.openReplyInput(this.directMessageDetails['name']);
        }
    }
    openReplyInput(senderId) {
        this.replyInfo = {
            text: 'Replying to: ',
            username: senderId,
        };
        this.senderId = senderId;
    }
    async handleSendButton() {
        const message = this.type === 'direct' ? this.directMessageText : this.groupMessageText;
        if (!message) {
            this.showAlert?.({ message: 'Please enter a message', type: 'danger' });
            return;
        }
        if (message.length > 350) {
            this.showAlert?.({ message: 'Message is too long.', type: 'danger' });
            return;
        }
        if (message.trim() === '') {
            this.showAlert?.({ message: 'Message cannot be empty.', type: 'danger' });
            return;
        }
        if (this.type === 'direct' && !this.senderId && this.islevel == '2') {
            this.showAlert?.({ message: 'Please select a user to send a message to.', type: 'danger' });
            return;
        }
        await this.onSendMessagePress({
            message,
            receivers: this.type === 'direct' && this.senderId ? [this.senderId] : [],
            group: this.type === 'group',
            messagesLength: this.messagesLength,
            member: this.member,
            sender: this.username,
            islevel: this.islevel,
            showAlert: this.showAlert,
            coHostResponsibility: this.coHostResponsibility,
            coHost: this.coHost,
            roomName: this.roomName,
            socket: this.socket,
            chatSetting: this.chatSetting,
        });
        if (this.type === 'direct') {
            this.directMessageText = '';
        }
        else {
            this.groupMessageText = '';
        }
        this.replyInfo = null;
        this.senderId = null;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MessagePanel, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MessagePanel, isStandalone: true, selector: "app-message-panel", inputs: { messages: "messages", messagesLength: "messagesLength", type: "type", username: "username", onSendMessagePress: "onSendMessagePress", backgroundColor: "backgroundColor", focusedInput: "focusedInput", eventType: "eventType", member: "member", islevel: "islevel", startDirectMessage: "startDirectMessage", updateStartDirectMessage: "updateStartDirectMessage", directMessageDetails: "directMessageDetails", updateDirectMessageDetails: "updateDirectMessageDetails", coHostResponsibility: "coHostResponsibility", coHost: "coHost", roomName: "roomName", socket: "socket", chatSetting: "chatSetting", showAlert: "showAlert" }, usesOnChanges: true, ngImport: i0, template: "<div [style.maxHeight]=\"'100%'\" [style.backgroundColor]=\"backgroundColor\" style=\"overflow-y: auto;\">\r\n  <!-- Message rendering logic -->\r\n  <div *ngFor=\"let message of messages; let index = index\" [ngStyle]=\"{ marginBottom: '10px' }\">\r\n    <div [ngStyle]=\"{ display: 'flex', flexDirection: 'column', alignItems: message.sender === username ? 'flex-end' : 'flex-start', marginBottom: '10px' }\">\r\n      <div [ngStyle]=\"{ display: 'flex', flexDirection: 'row', justifyContent: 'space-between', marginBottom: '3px' }\">\r\n        <span *ngIf=\"message.sender === username && !message.group\" [ngStyle]=\"{ fontWeight: 'bold', color: 'black', fontSize: '8px', marginLeft: '6px' }\">To: {{ message.receivers.join(', ') }}</span>\r\n        <span [ngStyle]=\"{ fontWeight: 'bold', color: 'black', fontSize: '8px', marginRight: '10px' }\">{{ message.sender === username ? '' : message.sender }}</span>\r\n        <span [ngStyle]=\"{ fontSize: '8px', color: '#0D0D0DFF' }\">{{ message.timestamp }}</span>\r\n        <div *ngIf=\"message.sender !== username && !message.group\" (click)=\"openReplyInput(message.sender)\" [ngStyle]=\"{ padding: '1px', marginLeft: '5px', borderRadius: '2px', backgroundColor: 'transparent' }\">\r\n          <fa-icon [icon]=\"faReply\" size=\"xs\" color=\"black\"></fa-icon>\r\n        </div>\r\n      </div>\r\n      <div [ngStyle]=\"{ backgroundColor: message.sender === member ? '#DCF8C6' : '#1ce5c7', padding: '10px', borderRadius: '10px' }\">\r\n        <span [ngStyle]=\"{ color: 'black' }\">{{ message.message }}</span>\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n  <!-- Reply info -->\r\n  <div *ngIf=\"replyInfo\" [ngStyle]=\"{ flexDirection: 'row', alignItems: 'center', padding: '2px', backgroundColor: '#e6e6e6', borderRadius: '5px', marginBottom: '1px' }\">\r\n    <span [ngStyle]=\"{ fontWeight: 'bold', marginRight: '2px', fontSize: '8px' }\">Replying to: </span>\r\n    <span [ngStyle]=\"{ color: 'red', fontSize: '8px' }\">{{ replyInfo.username }}</span>\r\n  </div>\r\n\r\n  <!-- Input area -->\r\n  <div [ngStyle]=\"{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '10px', marginTop: 'auto' }\">\r\n    <input\r\n      type=\"text\"\r\n      [ngStyle]=\"{ flex: 1, minHeight: '40px', maxHeight: '80px', resize: 'vertical', border: '1px solid gray', borderRadius: '5px', padding: '10px', overflowY: 'auto' }\"\r\n      placeholder=\"{{ type === 'direct' ? (focusedInput && startDirectMessage && directMessageDetails ? 'Send a direct message to ' + directMessageDetails.name : 'Select a message to reply to') : (eventType === 'chat' ? 'Send a message' : 'Send a message to everyone') }}\"\r\n      maxLength=\"350\"\r\n      (input)=\"handleTextInputChange($event)\"\r\n      [value]=\"type === 'direct' ? directMessageText : groupMessageText\"\r\n    />\r\n    <button [ngStyle]=\"{ backgroundColor: '#83c0e9', padding: '10px', borderRadius: '5px', display: 'flex', alignItems: 'center' }\" (click)=\"handleSendButton()\">\r\n      <fa-icon [icon]=\"faPaperPlane\" size=\"sm\" color=\"white\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MessagePanel, decorators: [{
            type: Component,
            args: [{ selector: 'app-message-panel', imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div [style.maxHeight]=\"'100%'\" [style.backgroundColor]=\"backgroundColor\" style=\"overflow-y: auto;\">\r\n  <!-- Message rendering logic -->\r\n  <div *ngFor=\"let message of messages; let index = index\" [ngStyle]=\"{ marginBottom: '10px' }\">\r\n    <div [ngStyle]=\"{ display: 'flex', flexDirection: 'column', alignItems: message.sender === username ? 'flex-end' : 'flex-start', marginBottom: '10px' }\">\r\n      <div [ngStyle]=\"{ display: 'flex', flexDirection: 'row', justifyContent: 'space-between', marginBottom: '3px' }\">\r\n        <span *ngIf=\"message.sender === username && !message.group\" [ngStyle]=\"{ fontWeight: 'bold', color: 'black', fontSize: '8px', marginLeft: '6px' }\">To: {{ message.receivers.join(', ') }}</span>\r\n        <span [ngStyle]=\"{ fontWeight: 'bold', color: 'black', fontSize: '8px', marginRight: '10px' }\">{{ message.sender === username ? '' : message.sender }}</span>\r\n        <span [ngStyle]=\"{ fontSize: '8px', color: '#0D0D0DFF' }\">{{ message.timestamp }}</span>\r\n        <div *ngIf=\"message.sender !== username && !message.group\" (click)=\"openReplyInput(message.sender)\" [ngStyle]=\"{ padding: '1px', marginLeft: '5px', borderRadius: '2px', backgroundColor: 'transparent' }\">\r\n          <fa-icon [icon]=\"faReply\" size=\"xs\" color=\"black\"></fa-icon>\r\n        </div>\r\n      </div>\r\n      <div [ngStyle]=\"{ backgroundColor: message.sender === member ? '#DCF8C6' : '#1ce5c7', padding: '10px', borderRadius: '10px' }\">\r\n        <span [ngStyle]=\"{ color: 'black' }\">{{ message.message }}</span>\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n  <!-- Reply info -->\r\n  <div *ngIf=\"replyInfo\" [ngStyle]=\"{ flexDirection: 'row', alignItems: 'center', padding: '2px', backgroundColor: '#e6e6e6', borderRadius: '5px', marginBottom: '1px' }\">\r\n    <span [ngStyle]=\"{ fontWeight: 'bold', marginRight: '2px', fontSize: '8px' }\">Replying to: </span>\r\n    <span [ngStyle]=\"{ color: 'red', fontSize: '8px' }\">{{ replyInfo.username }}</span>\r\n  </div>\r\n\r\n  <!-- Input area -->\r\n  <div [ngStyle]=\"{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '10px', marginTop: 'auto' }\">\r\n    <input\r\n      type=\"text\"\r\n      [ngStyle]=\"{ flex: 1, minHeight: '40px', maxHeight: '80px', resize: 'vertical', border: '1px solid gray', borderRadius: '5px', padding: '10px', overflowY: 'auto' }\"\r\n      placeholder=\"{{ type === 'direct' ? (focusedInput && startDirectMessage && directMessageDetails ? 'Send a direct message to ' + directMessageDetails.name : 'Select a message to reply to') : (eventType === 'chat' ? 'Send a message' : 'Send a message to everyone') }}\"\r\n      maxLength=\"350\"\r\n      (input)=\"handleTextInputChange($event)\"\r\n      [value]=\"type === 'direct' ? directMessageText : groupMessageText\"\r\n    />\r\n    <button [ngStyle]=\"{ backgroundColor: '#83c0e9', padding: '10px', borderRadius: '5px', display: 'flex', alignItems: 'center' }\" (click)=\"handleSendButton()\">\r\n      <fa-icon [icon]=\"faPaperPlane\" size=\"sm\" color=\"white\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n" }]
        }], propDecorators: { messages: [{
                type: Input
            }], messagesLength: [{
                type: Input
            }], type: [{
                type: Input
            }], username: [{
                type: Input
            }], onSendMessagePress: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], focusedInput: [{
                type: Input
            }], eventType: [{
                type: Input
            }], member: [{
                type: Input
            }], islevel: [{
                type: Input
            }], startDirectMessage: [{
                type: Input
            }], updateStartDirectMessage: [{
                type: Input
            }], directMessageDetails: [{
                type: Input
            }], updateDirectMessageDetails: [{
                type: Input
            }], coHostResponsibility: [{
                type: Input
            }], coHost: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], chatSetting: [{
                type: Input
            }], showAlert: [{
                type: Input
            }] } });

/* eslint-disable @typescript-eslint/no-empty-function */
/**
 * @component MessagesModal
 * @description A modal component for managing chat messages in MediaSFU applications, supporting both group and direct messaging, and providing a customizable user interface.
 *
 * @selector app-messages-modal
 * @templateUrl ./messages-modal.component.html
 * @styleUrls ./messages-modal.component.css
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule, MessagePanel]
 *
 * @example
 * ```html
 * <app-messages-modal
 *   [isMessagesModalVisible]="true"
 *   [onMessagesClose]="closeMessages"
 *   [messages]="chatMessages"
 *   [position]="'bottomRight'"
 *   [backgroundColor]="'#f5f5f5'"
 *   [eventType]="'webinar'"
 *   [member]="'JohnDoe'"
 *   [islevel]="'2'"
 *   [coHostResponsibility]="coHostRoles"
 *   [coHost]="'coHost123'"
 *   [startDirectMessage]="false"
 *   [directMessageDetails]="selectedParticipant"
 *   [updateStartDirectMessage]="updateDirectMessageStart"
 *   [updateDirectMessageDetails]="updateParticipantDetails"
 *   [showAlert]="displayAlert"
 *   [roomName]="'RoomName'"
 *   [socket]="chatSocket"
 *   [chatSetting]="'enabled'"
 * ></app-messages-modal>
 * ```
 */
class MessagesModal {
    SendMessageService;
    constructor(SendMessageService) {
        this.SendMessageService = SendMessageService;
    }
    isMessagesModalVisible = false;
    onMessagesClose = () => { };
    onSendMessagePress;
    messages = [];
    position = 'topRight';
    backgroundColor = '#f5f5f5';
    activeTabBackgroundColor = '#2b7ce5';
    eventType = 'webinar';
    member = '';
    islevel = '';
    coHostResponsibility = [];
    coHost = '';
    startDirectMessage = false;
    directMessageDetails = null;
    updateStartDirectMessage = (start) => {
        console.log(start);
    };
    updateDirectMessageDetails = (participant) => {
        console.log(participant);
    };
    showAlert;
    roomName = '';
    socket = {};
    chatSetting = '';
    faTimes = faTimes;
    directMessages = [];
    groupMessages = [];
    activeTab = 'group';
    focusedInput = false;
    reRender = false;
    modalContainerStyle;
    modalContentStyle;
    ngOnInit() {
        if (!this.onSendMessagePress) {
            this.onSendMessagePress = this.SendMessageService.sendMessage.bind(this.SendMessageService);
        }
        if (this.eventType == 'webinar' || this.eventType == 'conference') {
            this.activeTab = 'direct';
        }
        else {
            this.activeTab = 'group';
            this.switchToGroupTab();
        }
        this.updateModalStyles();
    }
    ngOnChanges(changes) {
        if (changes['isMessagesModalVisible']) {
            this.updateModalStyles();
            if (this.eventType != 'webinar' &&
                this.eventType != 'conference' &&
                this.activeTab == 'direct') {
                this.activeTab = 'group';
                this.focusedInput = false;
                this.switchToGroupTab();
            }
            else if (this.eventType == 'webinar' || this.eventType == 'conference') {
                if (this.startDirectMessage && this.directMessageDetails) {
                    this.activeTab = 'direct';
                    this.focusedInput = true;
                    this.switchToDirectTab();
                }
            }
            if (this.isMessagesModalVisible) {
                this.populateMessages();
            }
        }
        if (changes['messages']) {
            this.populateMessages();
        }
    }
    switchToDirectTab() {
        this.activeTab = 'direct';
        this.reRender = !this.reRender;
    }
    switchToGroupTab() {
        this.activeTab = 'group';
        this.reRender = !this.reRender;
    }
    populateMessages() {
        let chatValue = false;
        try {
            chatValue =
                this.coHostResponsibility?.find((item) => item.name == 'chat')?.value || false;
        }
        catch {
            /* handle error */
        }
        let directMsgs = this.messages ? this.messages.filter((message) => !message.group) : [];
        directMsgs = directMsgs.filter((message) => message.sender == this.member ||
            message.receivers.includes(this.member) ||
            this.islevel == '2' ||
            (this.coHost == this.member && chatValue == true));
        this.directMessages = directMsgs;
        const groupMsgs = this.messages ? this.messages.filter((message) => message.group) : [];
        this.groupMessages = groupMsgs;
    }
    closeMessagesModal() {
        this.onMessagesClose();
    }
    updateModalStyles() {
        const screenWidth = window.innerWidth;
        const modalWidth = Math.min(0.8 * screenWidth, 400);
        this.modalContainerStyle = {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isMessagesModalVisible ? 'block' : 'none',
            zIndex: 999,
        };
        this.modalContentStyle = {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxWidth: `${modalWidth}px`,
            maxHeight: '75%',
            overflowY: 'auto',
            overflowX: 'hidden',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    getTabStyle(tab) {
        return {
            ...this.styles.tabText,
            ...(this.activeTab == tab ? this.styles.activeTabText : {}),
            ...(this.activeTab == tab ? { backgroundColor: this.activeTabBackgroundColor } : {}),
        };
    }
    getButtonCloseStyle() {
        return {
            ...this.styles.btnCloseMessages,
            marginLeft: this.eventType == 'webinar' || this.eventType == 'conference' ? '20%' : '65%',
        };
    }
    get styles() {
        return {
            modalContent: {
                borderRadius: '10px',
                padding: '10px',
            },
            modalBody: {
                marginTop: '10px',
            },
            tabText: {
                paddingRight: '10px',
                paddingLeft: '10px',
                paddingTop: '5px',
                paddingBottom: '5px',
                fontWeight: 'bold',
                marginRight: '10px',
                marginLeft: '10px',
            },
            activeTabText: {
                color: '#ffffff',
                backgroundColor: '#2b7ce5',
                borderRadius: '4px',
            },
            separator: {
                height: '1px',
                backgroundColor: 'black',
                marginVertical: '1px',
            },
            btnCloseMessages: {
                padding: '5px',
                marginRight: '0',
                paddingRight: '0',
            },
            icon: {
                fontSize: '24px',
                color: 'black',
            },
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MessagesModal, deps: [{ token: SendMessage }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MessagesModal, isStandalone: true, selector: "app-messages-modal", inputs: { isMessagesModalVisible: "isMessagesModalVisible", onMessagesClose: "onMessagesClose", onSendMessagePress: "onSendMessagePress", messages: "messages", position: "position", backgroundColor: "backgroundColor", activeTabBackgroundColor: "activeTabBackgroundColor", eventType: "eventType", member: "member", islevel: "islevel", coHostResponsibility: "coHostResponsibility", coHost: "coHost", startDirectMessage: "startDirectMessage", directMessageDetails: "directMessageDetails", updateStartDirectMessage: "updateStartDirectMessage", updateDirectMessageDetails: "updateDirectMessageDetails", showAlert: "showAlert", roomName: "roomName", socket: "socket", chatSetting: "chatSetting" }, usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div\r\n      [ngStyle]=\"{\r\n        flexDirection: 'row',\r\n        justifyContent: 'space-between',\r\n        alignItems: 'center'\r\n      }\"\r\n    >\r\n      <button\r\n        *ngIf=\"eventType === 'webinar' || eventType === 'conference'\"\r\n        (click)=\"switchToDirectTab()\"\r\n        [ngStyle]=\"getTabStyle('direct')\"\r\n      >\r\n        Direct\r\n      </button>\r\n      <button\r\n        *ngIf=\"eventType === 'webinar' || eventType === 'conference'\"\r\n        (click)=\"switchToGroupTab()\"\r\n        [ngStyle]=\"getTabStyle('group')\"\r\n      >\r\n        Group\r\n      </button>\r\n      <span (click)=\"closeMessagesModal()\" [ngStyle]=\"getButtonCloseStyle()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\" size=\"xl\"></fa-icon>\r\n      </span>\r\n    </div>\r\n    <hr [ngStyle]=\"styles.separator\" />\r\n    <div [ngStyle]=\"styles.modalBody\">\r\n      <app-message-panel\r\n        *ngIf=\"\r\n          activeTab === 'direct' &&\r\n          (eventType === 'webinar' || eventType === 'conference')\r\n        \"\r\n        [messages]=\"directMessages\"\r\n        [messagesLength]=\"messages.length\"\r\n        type=\"direct\"\r\n        [onSendMessagePress]=\"onSendMessagePress\"\r\n        [username]=\"member\"\r\n        [backgroundColor]=\"backgroundColor\"\r\n        [focusedInput]=\"focusedInput\"\r\n        [showAlert]=\"showAlert\"\r\n        [eventType]=\"eventType\"\r\n        [member]=\"member\"\r\n        [islevel]=\"islevel\"\r\n        [coHostResponsibility]=\"coHostResponsibility\"\r\n        [coHost]=\"coHost\"\r\n        [directMessageDetails]=\"directMessageDetails\"\r\n        [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n        [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n        [roomName]=\"roomName\"\r\n        [socket]=\"socket\"\r\n        [chatSetting]=\"chatSetting\"\r\n        [startDirectMessage]=\"startDirectMessage\"\r\n      >\r\n      </app-message-panel>\r\n\r\n      <app-message-panel\r\n        *ngIf=\"activeTab === 'group'\"\r\n        [messages]=\"groupMessages\"\r\n        [messagesLength]=\"messages.length\"\r\n        type=\"group\"\r\n        [onSendMessagePress]=\"onSendMessagePress\"\r\n        [username]=\"member\"\r\n        [backgroundColor]=\"backgroundColor\"\r\n        [focusedInput]=\"focusedInput\"\r\n        [showAlert]=\"showAlert\"\r\n        [eventType]=\"eventType\"\r\n        [member]=\"member\"\r\n        [islevel]=\"islevel\"\r\n        [coHostResponsibility]=\"coHostResponsibility\"\r\n        [coHost]=\"coHost\"\r\n        [directMessageDetails]=\"directMessageDetails\"\r\n        [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n        [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n        [roomName]=\"roomName\"\r\n        [socket]=\"socket\"\r\n        [chatSetting]=\"chatSetting\"\r\n        [startDirectMessage]=\"startDirectMessage\"\r\n      >\r\n      </app-message-panel>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modalContent{border-radius:10px;padding:10px}.modalBody{margin-top:10px}.tabText{padding:5px 10px;font-weight:700;margin-right:10px;margin-left:10px}.activeTabText{color:#fff;background-color:#2b7ce5;border-radius:4px}.separator{height:1px;background-color:#000;margin-top:1px;margin-bottom:1px}.btnCloseMessages{padding:5px 0 5px 5px;margin-right:0}.icon{font-size:24px;color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: MessagePanel, selector: "app-message-panel", inputs: ["messages", "messagesLength", "type", "username", "onSendMessagePress", "backgroundColor", "focusedInput", "eventType", "member", "islevel", "startDirectMessage", "updateStartDirectMessage", "directMessageDetails", "updateDirectMessageDetails", "coHostResponsibility", "coHost", "roomName", "socket", "chatSetting", "showAlert"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MessagesModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-messages-modal', imports: [CommonModule, FontAwesomeModule, MessagePanel], template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div\r\n      [ngStyle]=\"{\r\n        flexDirection: 'row',\r\n        justifyContent: 'space-between',\r\n        alignItems: 'center'\r\n      }\"\r\n    >\r\n      <button\r\n        *ngIf=\"eventType === 'webinar' || eventType === 'conference'\"\r\n        (click)=\"switchToDirectTab()\"\r\n        [ngStyle]=\"getTabStyle('direct')\"\r\n      >\r\n        Direct\r\n      </button>\r\n      <button\r\n        *ngIf=\"eventType === 'webinar' || eventType === 'conference'\"\r\n        (click)=\"switchToGroupTab()\"\r\n        [ngStyle]=\"getTabStyle('group')\"\r\n      >\r\n        Group\r\n      </button>\r\n      <span (click)=\"closeMessagesModal()\" [ngStyle]=\"getButtonCloseStyle()\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\" size=\"xl\"></fa-icon>\r\n      </span>\r\n    </div>\r\n    <hr [ngStyle]=\"styles.separator\" />\r\n    <div [ngStyle]=\"styles.modalBody\">\r\n      <app-message-panel\r\n        *ngIf=\"\r\n          activeTab === 'direct' &&\r\n          (eventType === 'webinar' || eventType === 'conference')\r\n        \"\r\n        [messages]=\"directMessages\"\r\n        [messagesLength]=\"messages.length\"\r\n        type=\"direct\"\r\n        [onSendMessagePress]=\"onSendMessagePress\"\r\n        [username]=\"member\"\r\n        [backgroundColor]=\"backgroundColor\"\r\n        [focusedInput]=\"focusedInput\"\r\n        [showAlert]=\"showAlert\"\r\n        [eventType]=\"eventType\"\r\n        [member]=\"member\"\r\n        [islevel]=\"islevel\"\r\n        [coHostResponsibility]=\"coHostResponsibility\"\r\n        [coHost]=\"coHost\"\r\n        [directMessageDetails]=\"directMessageDetails\"\r\n        [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n        [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n        [roomName]=\"roomName\"\r\n        [socket]=\"socket\"\r\n        [chatSetting]=\"chatSetting\"\r\n        [startDirectMessage]=\"startDirectMessage\"\r\n      >\r\n      </app-message-panel>\r\n\r\n      <app-message-panel\r\n        *ngIf=\"activeTab === 'group'\"\r\n        [messages]=\"groupMessages\"\r\n        [messagesLength]=\"messages.length\"\r\n        type=\"group\"\r\n        [onSendMessagePress]=\"onSendMessagePress\"\r\n        [username]=\"member\"\r\n        [backgroundColor]=\"backgroundColor\"\r\n        [focusedInput]=\"focusedInput\"\r\n        [showAlert]=\"showAlert\"\r\n        [eventType]=\"eventType\"\r\n        [member]=\"member\"\r\n        [islevel]=\"islevel\"\r\n        [coHostResponsibility]=\"coHostResponsibility\"\r\n        [coHost]=\"coHost\"\r\n        [directMessageDetails]=\"directMessageDetails\"\r\n        [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n        [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n        [roomName]=\"roomName\"\r\n        [socket]=\"socket\"\r\n        [chatSetting]=\"chatSetting\"\r\n        [startDirectMessage]=\"startDirectMessage\"\r\n      >\r\n      </app-message-panel>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modalContent{border-radius:10px;padding:10px}.modalBody{margin-top:10px}.tabText{padding:5px 10px;font-weight:700;margin-right:10px;margin-left:10px}.activeTabText{color:#fff;background-color:#2b7ce5;border-radius:4px}.separator{height:1px;background-color:#000;margin-top:1px;margin-bottom:1px}.btnCloseMessages{padding:5px 0 5px 5px;margin-right:0}.icon{font-size:24px;color:#000}\n"] }]
        }], ctorParameters: () => [{ type: SendMessage }], propDecorators: { isMessagesModalVisible: [{
                type: Input
            }], onMessagesClose: [{
                type: Input
            }], onSendMessagePress: [{
                type: Input
            }], messages: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], activeTabBackgroundColor: [{
                type: Input
            }], eventType: [{
                type: Input
            }], member: [{
                type: Input
            }], islevel: [{
                type: Input
            }], coHostResponsibility: [{
                type: Input
            }], coHost: [{
                type: Input
            }], startDirectMessage: [{
                type: Input
            }], directMessageDetails: [{
                type: Input
            }], updateStartDirectMessage: [{
                type: Input
            }], updateDirectMessageDetails: [{
                type: Input
            }], showAlert: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], chatSetting: [{
                type: Input
            }] } });

/**
 * @component ConfirmHereModal
 * @description Displays a confirmation modal with a countdown timer, allowing users to confirm their presence or be automatically disconnected after the timer expires.
 *
 * @selector app-confirm-here-modal
 * @templateUrl ./confirm-here-modal.component.html
 * @styleUrls ./confirm-here-modal.component.css
 * @imports [CommonModule, FontAwesomeModule]
 *
 * @example
 * ```html
 * <app-confirm-here-modal
 *   [isConfirmHereModalVisible]="true"
 *   [position]="'center'"
 *   [backgroundColor]="'#83c0e9'"
 *   [displayColor]="'#000000'"
 *   [onConfirmHereClose]="closeConfirmModal"
 *   [countdownDuration]="120"
 *   [socket]="socketInstance"
 *   [localSocket]="localSocketInstance"
 *   [roomName]="'exampleRoom'"
 *   [member]="'exampleMember'"
 * ></app-confirm-here-modal>
 * ```
 */
class ConfirmHereModal {
    isConfirmHereModalVisible = false;
    position = 'center';
    backgroundColor = '#83c0e9';
    displayColor = '#000000';
    onConfirmHereClose;
    countdownDuration = 120;
    socket;
    localSocket; // Added localSocket input
    roomName;
    member;
    faSpinner = faSpinner;
    counter;
    countdownInterval;
    ngOnInit() {
        this.counter = this.countdownDuration ? this.countdownDuration : 120;
        if (this.isConfirmHereModalVisible) {
            this.startCountdown();
        }
    }
    ngOnChanges(changes) {
        if (changes['isConfirmHereModalVisible'] && changes['isConfirmHereModalVisible'].currentValue) {
            this.counter = this.countdownDuration ? this.countdownDuration : 120;
            this.startCountdown();
        }
        else {
            this.clearCountdown();
        }
    }
    ngOnDestroy() {
        this.clearCountdown();
    }
    startCountdown = () => {
        this.countdownInterval = setInterval(() => {
            this.counter--;
            if (this.counter <= 0) {
                this.clearCountdown();
                this.socket.emit('disconnectUser', {
                    member: this.member,
                    roomName: this.roomName,
                    ban: false,
                });
                // Emit to localSocket if available
                if (this.localSocket && this.localSocket.id) {
                    try {
                        this.localSocket.emit('disconnectUser', {
                            member: this.member,
                            roomName: this.roomName,
                            ban: false,
                        });
                    }
                    catch (error) {
                        console.error('Error emitting disconnect to localSocket:', error);
                    }
                }
                this.onConfirmHereClose();
            }
        }, 1000);
    };
    clearCountdown = () => {
        if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
        }
    };
    handleConfirmHere() {
        this.clearCountdown();
        this.onConfirmHereClose();
    }
    get spinnerContainerStyle() {
        return {
            marginBottom: '20px',
        };
    }
    get modalContainerStyle() {
        return {
            'background-color': this.backgroundColor || 'rgba(0, 0, 0, 0.5)',
            display: this.isConfirmHereModalVisible ? 'block' : 'none',
        };
    }
    get modalContentStyle() {
        return {
            'background-color': this.backgroundColor,
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfirmHereModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ConfirmHereModal, isStandalone: true, selector: "app-confirm-here-modal", inputs: { isConfirmHereModalVisible: "isConfirmHereModalVisible", position: "position", backgroundColor: "backgroundColor", displayColor: "displayColor", onConfirmHereClose: "onConfirmHereClose", countdownDuration: "countdownDuration", socket: "socket", localSocket: "localSocket", roomName: "roomName", member: "member" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isConfirmHereModalVisible\" [ngStyle]=\"modalContainerStyle\" class=\"modal-container\">\r\n  <div [ngStyle]=\"modalContentStyle\" class=\"modal-content\">\r\n    <div class=\"spinner\" [ngStyle]=\"spinnerContainerStyle\"></div>\r\n    <h2 style=\"font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem; color: black;\">Are you still there?</h2>\r\n    <p style=\"font-size: 1rem; color: black; margin-bottom: 1.5rem;\">Please confirm if you are still present.</p>\r\n    <p style=\"font-size: 0.9rem; color: black; margin-bottom: 1rem;\">Time remaining: <strong>{{ counter }}</strong></p>\r\n    <button (click)=\"handleConfirmHere()\" style=\"background-color: #dc3545; color: white; padding: 0.5rem 1rem; border-radius: 5px; border: none; cursor: pointer; font-weight: bold; font-size: 1rem;\">\r\n      Yes\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:100%;max-height:100%;overflow-y:auto}\n", ".spinner{border:12px solid #f3f3f3;border-top:12px solid black;border-radius:50%;width:50px;height:50px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.modal-content{display:flex;flex-direction:column;align-items:center}.loading-text{margin-top:10px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfirmHereModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-confirm-here-modal', imports: [CommonModule, FontAwesomeModule], template: "<div *ngIf=\"isConfirmHereModalVisible\" [ngStyle]=\"modalContainerStyle\" class=\"modal-container\">\r\n  <div [ngStyle]=\"modalContentStyle\" class=\"modal-content\">\r\n    <div class=\"spinner\" [ngStyle]=\"spinnerContainerStyle\"></div>\r\n    <h2 style=\"font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem; color: black;\">Are you still there?</h2>\r\n    <p style=\"font-size: 1rem; color: black; margin-bottom: 1.5rem;\">Please confirm if you are still present.</p>\r\n    <p style=\"font-size: 0.9rem; color: black; margin-bottom: 1rem;\">Time remaining: <strong>{{ counter }}</strong></p>\r\n    <button (click)=\"handleConfirmHere()\" style=\"background-color: #dc3545; color: white; padding: 0.5rem 1rem; border-radius: 5px; border: none; cursor: pointer; font-weight: bold; font-size: 1rem;\">\r\n      Yes\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:100%;max-height:100%;overflow-y:auto}\n", ".spinner{border:12px solid #f3f3f3;border-top:12px solid black;border-radius:50%;width:50px;height:50px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.modal-content{display:flex;flex-direction:column;align-items:center}.loading-text{margin-top:10px}\n"] }]
        }], propDecorators: { isConfirmHereModalVisible: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], displayColor: [{
                type: Input
            }], onConfirmHereClose: [{
                type: Input
            }], countdownDuration: [{
                type: Input
            }], socket: [{
                type: Input
            }], localSocket: [{
                type: Input
            }], roomName: [{
                type: Input
            }], member: [{
                type: Input
            }] } });

/**
 * Asynchronously creates a room on MediaSFU.
 *
 * This method sends a POST request to the MediaSFU API to create a new room.
 * It validates the provided credentials and dynamically constructs the API endpoint,
 * supporting the Community Edition via a custom `localLink`.
 *
 * @param {object} options - Configuration options for creating the room.
 * @param {CreateMediaSFURoomOptions | JoinMediaSFURoomOptions} options.payload -
 *   The payload containing the room creation details.
 * @param {string} options.apiUserName - The API username, used for authentication.
 * @param {string} options.apiKey - The API key, used for authentication.
 * @param {string} [options.localLink=""] -
 *   The local link for Community Edition users. If provided, it overrides the default API URL.
 *
 * @returns {Promise<{
*   data: CreateJoinRoomResponse | CreateJoinRoomError | null;
*   success: boolean;
* }>} A promise resolving to an object containing the API response:
* - `data`: The response object, either `CreateJoinRoomResponse` or `CreateJoinRoomError`.
* - `success`: Boolean indicating whether the operation was successful.
*
* @throws {Error} Throws an error if the request fails or if the provided credentials are invalid.
*
* @example
* const response = await createRoomOnMediaSFU.createRoomOnMediaSFU({
*   payload: {
*     action: 'create',
*     duration: 120, // Duration in minutes
*     capacity: 20, // Max participants
*     userName: 'hostUser',
*     scheduledDate: Date.now() + 3600000, // One hour from now
*     secureCode: 'secure123', // Optional
*     eventType: 'webinar', // Optional
*   },
*   apiUserName: 'yourAPIUSERNAME',
*   apiKey: 'yourAPIKEY',
*   localLink: 'http://localhost:3000', // Optional for Community Edition
* });
*
* if (response.success) {
*   console.log('Room created successfully:', response.data);
* } else {
*   console.error('Failed to create room:', response.data?.error);
* }
*/
class CreateRoomOnMediaSFU {
    constructor() { }
    /**
   * Asynchronously creates a room on MediaSFU.
   *
   * This method sends a POST request to the MediaSFU API to create a new room.
   * It validates the provided credentials and dynamically constructs the API endpoint,
   * supporting the Community Edition via a custom `localLink`.
   *
   * @param {object} options - Configuration options for creating the room.
   * @param {CreateMediaSFURoomOptions | JoinMediaSFURoomOptions} options.payload -
   *   The payload containing the room creation details.
   * @param {string} options.apiUserName - The API username, used for authentication.
   * @param {string} options.apiKey - The API key, used for authentication.
   * @param {string} [options.localLink=""] -
   *   The local link for Community Edition users. If provided, it overrides the default API URL.
   *
   * @returns {Promise<{
   *   data: CreateJoinRoomResponse | CreateJoinRoomError | null;
    *   success: boolean;
    * }>} A promise resolving to an object containing the API response:
    * - `data`: The response object, either `CreateJoinRoomResponse` or `CreateJoinRoomError`.
    * - `success`: Boolean indicating whether the operation was successful.
    *
    * @throws {Error} Throws an error if the request fails or if the provided credentials are invalid.
    *
    * @example
    * const response = await createRoomOnMediaSFU.createRoomOnMediaSFU({
    *   payload: {
    *     action: 'create',
    *     duration: 120, // Duration in minutes
    *     capacity: 20, // Max participants
    *     userName: 'hostUser',
    *     scheduledDate: Date.now() + 3600000, // One hour from now
    *     secureCode: 'secure123', // Optional
    *     eventType: 'webinar', // Optional
    *   },
    *   apiUserName: 'yourAPIUSERNAME',
    *   apiKey: 'yourAPIKEY',
    *   localLink: 'http://localhost:3000', // Optional for Community Edition
    * });
    *
    * if (response.success) {
    *   console.log('Room created successfully:', response.data);
    * } else {
    *   console.error('Failed to create room:', response.data?.error);
    * }
    */
    async createRoomOnMediaSFU({ payload, apiUserName, apiKey, localLink, }) {
        try {
            if (!apiUserName ||
                !apiKey ||
                apiUserName === 'yourAPIUSERNAME' ||
                apiKey === 'yourAPIKEY' ||
                apiKey.length !== 64 ||
                apiUserName.length < 6) {
                return { data: { error: 'Invalid credentials' }, success: false };
            }
            let API_URL = 'https://mediasfu.com/v1/rooms/';
            if (localLink && localLink.trim() !== '' && !localLink.includes('mediasfu.com')) {
                localLink = localLink.replace(/\/$/, '');
                API_URL = localLink + '/createRoom';
            }
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${apiUserName}:${apiKey}`,
                },
                body: JSON.stringify(payload),
            });
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            const data = await response.json();
            return { data, success: true };
        }
        catch (error) {
            const errorMessage = error.reason ? error.reason : 'unknown error';
            return {
                data: { error: `Unable to create room, ${errorMessage}` },
                success: false,
            };
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CreateRoomOnMediaSFU, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CreateRoomOnMediaSFU, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: CreateRoomOnMediaSFU, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

/**
 * @fileoverview PreJoinPage component for handling room creation and joining on MediaSFU.
 *
 * @component
 * @selector app-pre-join-page
 * @standalone true
 * @templateUrl ./pre-join-page.component.html
 * @styleUrls ./pre-join-page.component.css
 * @imports [CommonModule, ReactiveFormsModule]
 *
 * @description
 * This component provides functionality for users to create or join a room on MediaSFU.
 * It includes form validation, error handling, and API requests to the MediaSFU service.
 *
 * @property {any} parameters - Input parameters for the component.
 * @property {Object} credentials - API credentials for MediaSFU.
 * @property {string} credentials.apiUserName - API username.
 * @property {string} credentials.apiKey - API key.
 * @property {boolean} isCreateMode - Flag to toggle between create and join modes.
 * @property {FormGroup} preJoinForm - Form group for pre-join form.
 * @property {string} error - Error message to display.
 *
 * @constructor
 * @param {FormBuilder} fb - FormBuilder service for creating form groups.
 * @param {HttpClient} http - HttpClient service for making HTTP requests.
 * @param {CookieService} cookieService - CookieService for managing cookies.
 *
 * @method ngOnInit
 * @description Lifecycle hook that is called after data-bound properties are initialized.
 *
 * @method toggleMode
 * @description Toggles between create and join modes and resets the error message.
 *
 * @method handleCreateRoom
 * @description Handles the creation of a room on MediaSFU. Validates form inputs, sends a request to create a room, and handles the response.
 *
 * @method handleJoinRoom
 * @description Handles joining a room on MediaSFU. Validates form inputs, sends a request to join a room, and handles the response.
 *
 * @method checkLimitsAndMakeRequest
 * @description Checks rate limits and makes a request to connect to a room. Handles unsuccessful attempts and updates the state accordingly.
 *
 * @method createRoomOnMediaSFU
 * @description Sends a request to create a room on MediaSFU.
 * @param {Object} params - Parameters for the request.
 * @param {any} params.payload - Payload for the request.
 * @param {string} params.apiUserName - API username.
 * @param {string} params.apiKey - API key.
 * @returns {Promise<{ data: CreateJoinRoomResponse | CreateJoinRoomError | null; success: boolean }>} Response from the API.
 *
 * @method joinRoomOnMediaSFU
 * @description Sends a request to join a room on MediaSFU.
 * @param {Object} params - Parameters for the request.
 * @param {any} params.payload - Payload for the request.
 * @param {string} params.apiUserName - API username.
 * @param {string} params.apiKey - API key.
 * @returns {Promise<{ data: CreateJoinRoomResponse | CreateJoinRoomError | null; success: boolean }>} Response from the API.
 *
 * @example
 * ```html
 * <app-pre-join-page
 *   [parameters]="preJoinPageParameters"
 *   [credentials]="{ apiUserName: 'username', apiKey: 'apiKey' }"
 *   [localLink]="'http://localhost:3000'"
 *   [connectMediaSFU]="false"
 * ></app-pre-join-page>
 * ```
 */
class PreJoinPage {
    fb;
    checkLimitsService;
    createRoomService;
    joinRoomService;
    parameters = {};
    credentials = { apiUserName: 'yourAPIUSERNAME', apiKey: 'yourAPIKEY' };
    localLink = "";
    connectMediaSFU = true;
    returnUI;
    noUIPreJoinOptions;
    createMediaSFURoom;
    joinMediaSFURoom;
    isCreateMode = false;
    preJoinForm;
    error = '';
    imgSrc = this.parameters.imgSrc || '';
    localConnected = false;
    localData = undefined;
    initSocket = undefined;
    pending = new BehaviorSubject(false);
    constructor(fb, injectedParameters, injectedCredentials, injectedLocalLink, injectedConnectMediaSFU, injectedReturnUI, injectedNoUIPreJoinOptions, injectedCreateMediaSFURoom, injectedJoinMediaSFURoom, checkLimitsService, createRoomService, joinRoomService) {
        this.fb = fb;
        this.checkLimitsService = checkLimitsService;
        this.createRoomService = createRoomService;
        this.joinRoomService = joinRoomService;
        this.preJoinForm = this.fb.group({
            name: ['', Validators.required],
            duration: [''],
            eventType: [''],
            capacity: [''],
            eventID: [''],
        });
        this.parameters = injectedParameters || this.parameters;
        this.credentials = injectedCredentials || this.credentials;
        this.localLink = injectedLocalLink || this.localLink;
        this.connectMediaSFU = injectedConnectMediaSFU !== undefined ? injectedConnectMediaSFU : this.connectMediaSFU;
        this.returnUI = injectedReturnUI !== undefined ? injectedReturnUI : this.returnUI;
        this.noUIPreJoinOptions = injectedNoUIPreJoinOptions || this.noUIPreJoinOptions;
        this.createMediaSFURoom = injectedCreateMediaSFURoom || this.createMediaSFURoom;
        this.joinMediaSFURoom = injectedJoinMediaSFURoom || this.joinMediaSFURoom;
    }
    ngOnInit() {
        // If we have a localLink and not connected yet, try to connect
        if (this.localLink && !this.localConnected && !this.initSocket) {
            this.connectLocalSocket().then(() => {
                this.checkProceed();
            });
        }
        else {
            // If no localLink or already connected, try to proceed
            this.checkProceed();
        }
    }
    async connectLocalSocket() {
        try {
            const response = await this.parameters.connectLocalSocket?.({ link: this.localLink });
            if (response) {
                this.localData = response.data;
                this.initSocket = response.socket;
                this.localConnected = true;
            }
        }
        catch (error) {
            this.parameters.showAlert?.({
                message: `Unable to connect to ${this.localLink}. ${error}`,
                type: 'danger',
                duration: 3000,
            });
        }
    }
    async checkProceed() {
        // If we do not need to return UI and we have noUIPreJoinOptions, proceed like in the React code
        if (!this.returnUI && this.noUIPreJoinOptions) {
            if ('action' in this.noUIPreJoinOptions && this.noUIPreJoinOptions.action === 'create') {
                const createOptions = this.noUIPreJoinOptions;
                if (!createOptions.userName || !createOptions.duration || !createOptions.eventType || !createOptions.capacity) {
                    throw new Error('Please provide all the required parameters: userName, duration, eventType, capacity');
                }
                await this.handleCreateRoom();
            }
            else if ('action' in this.noUIPreJoinOptions && this.noUIPreJoinOptions.action === 'join') {
                const joinOptions = this.noUIPreJoinOptions;
                if (!joinOptions.userName || !joinOptions.meetingID) {
                    throw new Error('Please provide all the required parameters: userName, meetingID');
                }
                await this.handleJoinRoom();
            }
            else {
                throw new Error('Invalid options provided for creating/joining a room without UI.');
            }
        }
    }
    toggleMode() {
        this.isCreateMode = !this.isCreateMode;
        this.error = '';
    }
    async joinLocalRoom(options) {
        this.initSocket?.emit('joinEventRoom', options.joinData, (response) => {
            if (response.success) {
                this.parameters.updateSocket(this.initSocket);
                this.parameters.updateApiUserName(this.localData?.apiUserName || '');
                this.parameters.updateApiToken(response.secret);
                this.parameters.updateLink(options.link || '');
                this.parameters.updateRoomName(options.joinData.eventID);
                this.parameters.updateMember(options.joinData.userName);
                this.parameters.updateIsLoadingModalVisible(false);
                this.parameters.updateValidated(true);
            }
            else {
                this.parameters.updateIsLoadingModalVisible(false);
                this.error = `Unable to join room. ${response.reason}`;
            }
        });
    }
    async createLocalRoom(options) {
        this.initSocket?.emit('createRoom', options.createData, (response) => {
            if (response.success) {
                this.parameters.updateSocket(this.initSocket);
                this.parameters.updateApiUserName(this.localData?.apiUserName || '');
                this.parameters.updateApiToken(response.secret);
                this.parameters.updateLink(options.link || '');
                this.parameters.updateRoomName(options.createData.eventID);
                // Update member as `userName` + "_2" to split in the room
                this.parameters.updateMember(`${options.createData.userName}_2`);
                this.parameters.updateIsLoadingModalVisible(false);
                this.parameters.updateValidated(true);
            }
            else {
                this.parameters.updateIsLoadingModalVisible(false);
                this.error = `Unable to create room. ${response.reason}`;
            }
        });
    }
    async roomCreator(options) {
        const { payload, apiUserName, apiKey, validate = true } = options;
        if (!this.createMediaSFURoom) {
            this.createMediaSFURoom = this.createRoomService.createRoomOnMediaSFU;
        }
        const response = await this.createMediaSFURoom({
            payload,
            apiUserName,
            apiKey,
            localLink: this.localLink,
        });
        if (response.success && response.data && 'roomName' in response.data) {
            await this.checkLimitsService.checkLimitsAndMakeRequest({
                apiUserName: response.data.roomName,
                apiToken: response.data.secret,
                link: response.data.link,
                userName: payload.userName,
                parameters: this.parameters,
                validate: validate,
            });
            return response;
        }
        else {
            this.parameters.updateIsLoadingModalVisible(false);
            this.error = `Unable to create room. ${response.data
                ? 'error' in response.data
                    ? response.data.error
                    : ''
                : ''}`;
        }
    }
    async handleCreateRoom() {
        if (this.pending.value) {
            return;
        }
        this.pending.next(true);
        let payload = {};
        if (this.returnUI) {
            const { name, duration, eventType, capacity } = this.preJoinForm.value;
            if (!name || !duration || !eventType || !capacity) {
                this.error = 'Please fill all the fields.';
                return;
            }
            payload = {
                action: 'create',
                duration: parseInt(duration),
                capacity: parseInt(capacity),
                eventType,
                userName: name,
                recordOnly: false,
            };
        }
        else {
            if (this.noUIPreJoinOptions && 'action' in this.noUIPreJoinOptions && this.noUIPreJoinOptions.action === 'create') {
                payload = this.noUIPreJoinOptions;
            }
            else {
                this.error = 'Invalid options provided for creating a room without UI.';
                this.pending.next(false);
                return;
            }
        }
        this.parameters.updateIsLoadingModalVisible(true);
        if (this.localLink) {
            const secureCode = Math.random().toString(30).substring(2, 14) +
                Math.random().toString(30).substring(2, 14);
            let eventID = new Date().getTime().toString(30) +
                new Date().getUTCMilliseconds() +
                Math.floor(10 + Math.random() * 99).toString();
            eventID = 'm' + eventID;
            const eventRoomParams = this.localData?.meetingRoomParams_;
            eventRoomParams.type = payload.eventType;
            const createData = {
                eventID: eventID,
                duration: payload.duration,
                capacity: payload.capacity,
                userName: payload.userName,
                scheduledDate: new Date(),
                secureCode: secureCode,
                waitRoom: false,
                recordingParams: this.localData?.recordingParams_,
                eventRoomParams: eventRoomParams,
                videoPreference: null,
                audioPreference: null,
                audioOutputPreference: null,
                mediasfuURL: '',
            };
            if (this.connectMediaSFU &&
                this.initSocket &&
                this.localData &&
                this.localData.apiUserName &&
                this.localData.apiKey) {
                payload.recordOnly = true; // allow production to MediaSFU only; no consumption
                const response = await this.roomCreator({
                    payload,
                    apiUserName: this.localData.apiUserName,
                    apiKey: this.localData.apiKey,
                    validate: false,
                });
                if (response && response.success && response.data && 'roomName' in response.data) {
                    createData.eventID = response.data.roomName;
                    createData.secureCode = response.data.secureCode;
                    createData.mediasfuURL = response.data.publicURL;
                    await this.createLocalRoom({ createData: createData, link: response.data.link });
                }
                else {
                    this.pending.next(false);
                    this.parameters.updateIsLoadingModalVisible(false);
                    this.error = 'Unable to create room on MediaSFU.';
                    try {
                        this.parameters.updateSocket(this.initSocket);
                        await this.createLocalRoom({ createData: createData });
                    }
                    catch (error) {
                        this.pending.next(false);
                        this.parameters.updateIsLoadingModalVisible(false);
                        this.error = `Unable to create room. ${error}`;
                    }
                }
            }
            else {
                try {
                    this.parameters.updateSocket(this.initSocket);
                    await this.createLocalRoom({ createData: createData });
                }
                catch (error) {
                    this.pending.next(false);
                    this.parameters.updateIsLoadingModalVisible(false);
                    this.error = `Unable to create room. ${error}`;
                }
            }
        }
        else {
            await this.roomCreator({
                payload,
                apiUserName: this.credentials.apiUserName,
                apiKey: this.credentials.apiKey,
                validate: true,
            });
            this.pending.next(false);
        }
    }
    async handleJoinRoom() {
        if (this.pending.value) {
            return;
        }
        this.pending.next(true);
        let payload = {};
        if (this.returnUI) {
            const { name, eventID } = this.preJoinForm.value;
            if (!name || !eventID) {
                this.error = 'Please fill all the fields.';
                return;
            }
            payload = {
                action: 'join',
                meetingID: eventID,
                userName: name,
            };
        }
        else {
            if (this.noUIPreJoinOptions && 'action' in this.noUIPreJoinOptions && this.noUIPreJoinOptions.action === 'join') {
                payload = this.noUIPreJoinOptions;
            }
            else {
                this.error = 'Invalid options provided for joining a room without UI.';
                this.pending.next(false);
                return;
            }
        }
        if (this.localLink && !this.localLink.includes('mediasfu.com')) {
            const joinData = {
                eventID: payload.meetingID,
                userName: payload.userName,
                secureCode: '',
                videoPreference: null,
                audioPreference: null,
                audioOutputPreference: null,
            };
            await this.joinLocalRoom({ joinData: joinData });
            this.pending.next(false);
            return;
        }
        this.parameters.updateIsLoadingModalVisible(true);
        try {
            if (!this.joinMediaSFURoom) {
                this.joinMediaSFURoom = this.joinRoomService.joinRoomOnMediaSFU;
            }
            const response = await this.joinMediaSFURoom({
                payload,
                apiUserName: this.credentials.apiUserName,
                apiKey: this.credentials.apiKey,
                localLink: this.localLink,
            });
            if (response.success && response.data && 'roomName' in response.data) {
                await this.checkLimitsService.checkLimitsAndMakeRequest({
                    apiUserName: response.data.roomName,
                    apiToken: response.data.secret,
                    link: response.data.link,
                    userName: payload.userName,
                    parameters: this.parameters,
                    validate: true,
                });
                this.error = '';
                this.pending.next(false);
            }
            else {
                this.parameters.updateIsLoadingModalVisible(false);
                this.pending.next(false);
                this.error = `Unable to connect to room. ${response.data ? ('error' in response.data ? response.data.error : '') : ''}`;
            }
        }
        catch (error) {
            this.parameters.updateIsLoadingModalVisible(false);
            this.error = `Unable to connect. ${error.message}`;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PreJoinPage, deps: [{ token: i2$2.FormBuilder }, { token: 'parameters', optional: true }, { token: 'credentials', optional: true }, { token: 'localLink', optional: true }, { token: 'connectMediaSFU', optional: true }, { token: 'returnUI', optional: true }, { token: 'noUIPreJoinOptions', optional: true }, { token: 'createMediaSFURoom', optional: true }, { token: 'joinMediaSFURoom', optional: true }, { token: CheckLimitsAndMakeRequest }, { token: CreateRoomOnMediaSFU }, { token: JoinRoomOnMediaSFU }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: PreJoinPage, isStandalone: true, selector: "app-pre-join-page", inputs: { parameters: "parameters", credentials: "credentials", localLink: "localLink", connectMediaSFU: "connectMediaSFU", returnUI: "returnUI", noUIPreJoinOptions: "noUIPreJoinOptions", createMediaSFURoom: "createMediaSFURoom", joinMediaSFURoom: "joinMediaSFURoom" }, ngImport: i0, template: "<div class=\"container-fluid\" *ngIf=\"returnUI !== false\">\r\n  <div class=\"logo-container\">\r\n    <img [src]=\"imgSrc || 'https://mediasfu.com/images/logo192.png'\" class=\"logo-image\" alt=\"Logo\" />\r\n  </div>\r\n  <div class=\"input-container\">\r\n    <form [formGroup]=\"preJoinForm\">\r\n      <input type=\"text\" placeholder=\"Display Name\" formControlName=\"name\" class=\"input-field\" />\r\n      <div *ngIf=\"isCreateMode\">\r\n        <input type=\"text\" placeholder=\"Duration (minutes)\" formControlName=\"duration\" class=\"input-field\" />\r\n        <select formControlName=\"eventType\" class=\"select-field\">\r\n          <option value=\"\">Select Event Type</option>\r\n          <option value=\"chat\">Chat</option>\r\n          <option value=\"broadcast\">Broadcast</option>\r\n          <option value=\"webinar\">Webinar</option>\r\n          <option value=\"conference\">Conference</option>\r\n        </select>\r\n        <input type=\"text\" placeholder=\"Room Capacity\" formControlName=\"capacity\" class=\"input-field\" />\r\n        <button type=\"button\" (click)=\"handleCreateRoom()\" class=\"action-button\">Create Room</button>\r\n      </div>\r\n      <div *ngIf=\"!isCreateMode\">\r\n        <input type=\"text\" placeholder=\"Event ID\" formControlName=\"eventID\" class=\"input-field\" />\r\n        <button type=\"button\" (click)=\"handleJoinRoom()\" class=\"action-button\">Join Room</button>\r\n      </div>\r\n      <p *ngIf=\"error\" class=\"error\">{{ error }}</p>\r\n    </form>\r\n  </div>\r\n  <div class=\"or-container\">\r\n    <span class=\"or-text\">OR</span>\r\n  </div>\r\n  <div class=\"toggle-container\">\r\n    <button type=\"button\" (click)=\"toggleMode()\" class=\"toggle-button\">\r\n      {{ isCreateMode ? 'Switch to Join Mode' : 'Switch to Create Mode' }}\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".container-fluid{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:20px;height:100vh;background-color:#53c6e0;overflow:auto}.logo-container{display:flex;flex-direction:column;align-items:center;justify-content:center;margin-top:30px;padding-top:10px;margin-bottom:10px}.logo-image{width:100px;height:100px;border-radius:50%}.input-container{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%}.input-field,.select-field{display:block;width:100%;max-width:300px;height:30px;border:1px solid gray;margin-bottom:10px;padding:0 5px;border-radius:5px}.action-button,.toggle-button{display:block;width:100%;max-width:300px;background-color:#000;color:#fff;padding:5px 20px;border-radius:5px;margin-bottom:10px;margin-top:10px;text-align:center;cursor:pointer}.error{color:red;margin-bottom:10px;width:100%;max-width:300px;text-align:center}.or-container{display:flex;flex-direction:column;align-items:center;justify-content:center;margin:10px 0}.or-text{color:#000;font-size:medium;font-weight:700;text-align:center}.toggle-container{display:flex;flex-direction:column;align-items:center;justify-content:center}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i2$2.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$2.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$2.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PreJoinPage, decorators: [{
            type: Component,
            args: [{ selector: 'app-pre-join-page', imports: [CommonModule, ReactiveFormsModule], template: "<div class=\"container-fluid\" *ngIf=\"returnUI !== false\">\r\n  <div class=\"logo-container\">\r\n    <img [src]=\"imgSrc || 'https://mediasfu.com/images/logo192.png'\" class=\"logo-image\" alt=\"Logo\" />\r\n  </div>\r\n  <div class=\"input-container\">\r\n    <form [formGroup]=\"preJoinForm\">\r\n      <input type=\"text\" placeholder=\"Display Name\" formControlName=\"name\" class=\"input-field\" />\r\n      <div *ngIf=\"isCreateMode\">\r\n        <input type=\"text\" placeholder=\"Duration (minutes)\" formControlName=\"duration\" class=\"input-field\" />\r\n        <select formControlName=\"eventType\" class=\"select-field\">\r\n          <option value=\"\">Select Event Type</option>\r\n          <option value=\"chat\">Chat</option>\r\n          <option value=\"broadcast\">Broadcast</option>\r\n          <option value=\"webinar\">Webinar</option>\r\n          <option value=\"conference\">Conference</option>\r\n        </select>\r\n        <input type=\"text\" placeholder=\"Room Capacity\" formControlName=\"capacity\" class=\"input-field\" />\r\n        <button type=\"button\" (click)=\"handleCreateRoom()\" class=\"action-button\">Create Room</button>\r\n      </div>\r\n      <div *ngIf=\"!isCreateMode\">\r\n        <input type=\"text\" placeholder=\"Event ID\" formControlName=\"eventID\" class=\"input-field\" />\r\n        <button type=\"button\" (click)=\"handleJoinRoom()\" class=\"action-button\">Join Room</button>\r\n      </div>\r\n      <p *ngIf=\"error\" class=\"error\">{{ error }}</p>\r\n    </form>\r\n  </div>\r\n  <div class=\"or-container\">\r\n    <span class=\"or-text\">OR</span>\r\n  </div>\r\n  <div class=\"toggle-container\">\r\n    <button type=\"button\" (click)=\"toggleMode()\" class=\"toggle-button\">\r\n      {{ isCreateMode ? 'Switch to Join Mode' : 'Switch to Create Mode' }}\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".container-fluid{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:20px;height:100vh;background-color:#53c6e0;overflow:auto}.logo-container{display:flex;flex-direction:column;align-items:center;justify-content:center;margin-top:30px;padding-top:10px;margin-bottom:10px}.logo-image{width:100px;height:100px;border-radius:50%}.input-container{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%}.input-field,.select-field{display:block;width:100%;max-width:300px;height:30px;border:1px solid gray;margin-bottom:10px;padding:0 5px;border-radius:5px}.action-button,.toggle-button{display:block;width:100%;max-width:300px;background-color:#000;color:#fff;padding:5px 20px;border-radius:5px;margin-bottom:10px;margin-top:10px;text-align:center;cursor:pointer}.error{color:red;margin-bottom:10px;width:100%;max-width:300px;text-align:center}.or-container{display:flex;flex-direction:column;align-items:center;justify-content:center;margin:10px 0}.or-text{color:#000;font-size:medium;font-weight:700;text-align:center}.toggle-container{display:flex;flex-direction:column;align-items:center;justify-content:center}\n"] }]
        }], ctorParameters: () => [{ type: i2$2.FormBuilder }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['credentials']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['localLink']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['connectMediaSFU']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['returnUI']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['noUIPreJoinOptions']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['createMediaSFURoom']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['joinMediaSFURoom']
                }] }, { type: CheckLimitsAndMakeRequest }, { type: CreateRoomOnMediaSFU }, { type: JoinRoomOnMediaSFU }], propDecorators: { parameters: [{
                type: Input
            }], credentials: [{
                type: Input
            }], localLink: [{
                type: Input
            }], connectMediaSFU: [{
                type: Input
            }], returnUI: [{
                type: Input
            }], noUIPreJoinOptions: [{
                type: Input
            }], createMediaSFURoom: [{
                type: Input
            }], joinMediaSFURoom: [{
                type: Input
            }] } });

/**
 * Component for displaying a modal to share event details.
 *
 * @component
 * @selector app-share-event-modal
 * @templateUrl ./share-event-modal.component.html
 * @styleUrls ./share-event-modal.component.css
 *
 * @imports CommonModule, FontAwesomeModule, MeetingIdComponent, MeetingPasscodeComponent, ShareButtonsComponent
 *
 * @property {string} backgroundColor - Background color of the modal content.
 * @property {boolean} isShareEventModalVisible - Visibility state of the share event modal.
 * @property {Function} onShareEventClose - Callback function to handle modal close event.
 * @property {string} roomName - Name of the room to be shared.
 * @property {string} adminPasscode - Admin passcode for the room.
 * @property {string} islevel - Level of the event (e.g., admin, user).
 * @property {string} position - Position of the modal on the screen (e.g., topRight, bottomLeft).
 * @property {boolean} shareButtons - Flag to display share buttons in the modal.
 * @property {EventType} eventType - Type of event (e.g., chat, broadcast, webinar).
 * @property {string} localLink - Local link for the event (Community Edition server).
 *
 * @method handleClose - Closes the share event modal by invoking the onShareEventClose callback.
 *
 * @getter modalContainerStyle - Returns the style object for the modal container.
 * @getter modalContentStyle - Returns the style object for the modal content.
 * @example
 * ```html
 * <app-share-event-modal
 *   [backgroundColor]="'rgba(255, 255, 255, 0.25)'"
 *   [isShareEventModalVisible]="isModalVisible"
 *   [onShareEventClose]="handleModalClose"
 *   [roomName]="roomName"
 *   [adminPasscode]="adminPasscode"
 *   [islevel]="userLevel"
 *   [position]="'topRight'"
 *   [shareButtons]="true"
 *   [eventType]="eventType"
 *   [localLink]="localLink"
 * ></app-share-event-modal>
 * ```
 */
class ShareEventModal {
    backgroundColor = 'rgba(255, 255, 255, 0.25)';
    isShareEventModalVisible = false;
    onShareEventClose;
    roomName;
    adminPasscode;
    islevel;
    position = 'topRight';
    shareButtons = true;
    eventType;
    localLink = '';
    faTimes = faTimes;
    handleClose() {
        this.onShareEventClose();
    }
    get modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isShareEventModalVisible ? 'block' : 'none',
            zIndex: 999,
        };
    }
    get modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        return {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxHeight: '60%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ShareEventModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ShareEventModal, isStandalone: true, selector: "app-share-event-modal", inputs: { backgroundColor: "backgroundColor", isShareEventModalVisible: "isShareEventModalVisible", onShareEventClose: "onShareEventClose", roomName: "roomName", adminPasscode: "adminPasscode", islevel: "islevel", position: "position", shareButtons: "shareButtons", eventType: "eventType", localLink: "localLink" }, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div style=\"display: flex; flex-direction: row-reverse; margin-bottom: 15px;\">\r\n      <div (click)=\"handleClose()\" style=\"padding: 5px;\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n    <div style=\"flex: 1;\">\r\n      <div style=\"margin-bottom: 10px;\" *ngIf=\"islevel === '2'\">\r\n        <app-meeting-passcode-component [meetingPasscode]=\"adminPasscode\"></app-meeting-passcode-component>\r\n      </div>\r\n      <div style=\"margin-bottom: 10px;\">\r\n        <app-meeting-id-component [meetingID]=\"roomName\"></app-meeting-id-component>\r\n      </div>\r\n      <div *ngIf=\"shareButtons\">\r\n        <app-share-buttons-component [meetingID]=\"roomName\" [eventType]=\"eventType\" [localLink]=\"localLink\"></app-share-buttons-component>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: MeetingIdComponent, selector: "app-meeting-id-component", inputs: ["meetingID"] }, { kind: "component", type: MeetingPasscodeComponent, selector: "app-meeting-passcode-component", inputs: ["meetingPasscode"] }, { kind: "component", type: ShareButtonsComponent, selector: "app-share-buttons-component", inputs: ["meetingID", "shareButtons", "eventType", "localLink"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ShareEventModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-share-event-modal', imports: [
                        CommonModule,
                        FontAwesomeModule,
                        MeetingIdComponent,
                        MeetingPasscodeComponent,
                        ShareButtonsComponent,
                    ], template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div style=\"display: flex; flex-direction: row-reverse; margin-bottom: 15px;\">\r\n      <div (click)=\"handleClose()\" style=\"padding: 5px;\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n    <div style=\"flex: 1;\">\r\n      <div style=\"margin-bottom: 10px;\" *ngIf=\"islevel === '2'\">\r\n        <app-meeting-passcode-component [meetingPasscode]=\"adminPasscode\"></app-meeting-passcode-component>\r\n      </div>\r\n      <div style=\"margin-bottom: 10px;\">\r\n        <app-meeting-id-component [meetingID]=\"roomName\"></app-meeting-id-component>\r\n      </div>\r\n      <div *ngIf=\"shareButtons\">\r\n        <app-share-buttons-component [meetingID]=\"roomName\" [eventType]=\"eventType\" [localLink]=\"localLink\"></app-share-buttons-component>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n" }]
        }], propDecorators: { backgroundColor: [{
                type: Input
            }], isShareEventModalVisible: [{
                type: Input
            }], onShareEventClose: [{
                type: Input
            }], roomName: [{
                type: Input
            }], adminPasscode: [{
                type: Input
            }], islevel: [{
                type: Input
            }], position: [{
                type: Input
            }], shareButtons: [{
                type: Input
            }], eventType: [{
                type: Input
            }], localLink: [{
                type: Input
            }] } });

const MAX_ATTEMPTS = 10; // Maximum number of unsuccessful attempts before rate limiting
const RATE_LIMIT_DURATION = 3 * 60 * 60 * 1000; // 3 hours in milliseconds
/**
 * @component WelcomePage
 * @description Component for handling room creation and joining on MediaSFU with QR scanning and form submission.
 *
 * @selector app-welcome-page
 * @standalone true
 * @templateUrl ./welcome-page.component.html
 * @styleUrls ['./welcome-page.component.css']
 * @imports [ZXingScannerModule, CommonModule, FontAwesomeModule, ReactiveFormsModule]
 *
 * @example
 * ```html
 * <app-welcome-page [parameters]="welcomeParameters"></app-welcome-page>
 * ```
 */
class WelcomePage {
    fb;
    cookieService;
    welcomeForm;
    error = '';
    isScannerVisible = false;
    scannedData = null;
    parameters = {};
    faQrcode = faQrcode;
    allowedCameras = []; // List of allowed cameras
    currentDevice = null; // Active camera device
    imgSrc = '';
    constructor(fb, cookieService, injectedParameters) {
        this.fb = fb;
        this.cookieService = cookieService;
        this.welcomeForm = this.fb.group({
            name: [
                '',
                [Validators.required, Validators.pattern('^[a-zA-Z0-9]+$'), Validators.maxLength(12)],
            ],
            secret: [
                '',
                [Validators.required, Validators.pattern('^[a-zA-Z0-9]+$'), Validators.maxLength(64)],
            ],
            eventID: [
                '',
                [Validators.required, Validators.pattern('^[a-zA-Z0-9]+$'), Validators.maxLength(32)],
            ],
            link: ['', [Validators.required, Validators.pattern('^https?://.+mediasfu\\.com.+$')]],
        });
        this.parameters = injectedParameters || this.parameters;
    }
    ngOnInit() {
        this.askForCameraPermission();
    }
    async checkLimitsAndMakeRequest(apiUserName, apiToken, link, userName) {
        const TIMEOUT_DURATION = 10000; // 10 seconds
        let unsuccessfulAttempts = parseInt(this.cookieService.get('unsuccessfulAttempts')) || 0;
        let lastRequestTimestamp = parseInt(this.cookieService.get('lastRequestTimestamp')) || 0;
        if (unsuccessfulAttempts >= MAX_ATTEMPTS) {
            if (Date.now() - lastRequestTimestamp < RATE_LIMIT_DURATION) {
                this.parameters.showAlert?.({
                    message: 'Too many unsuccessful attempts. Please try again later.',
                    type: 'danger',
                    duration: 3000,
                });
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
                return;
            }
            else {
                unsuccessfulAttempts = 0;
                this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
            }
        }
        try {
            this.parameters.updateIsLoadingModalVisible(true);
            const socketPromise = this.parameters.connectSocket({ apiUserName, apiToken, link });
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Request timed out')), TIMEOUT_DURATION));
            const socket = await Promise.race([socketPromise, timeoutPromise]);
            if (socket && socket instanceof Socket && socket.id) {
                unsuccessfulAttempts = 0;
                this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
                this.parameters.updateSocket(socket);
                this.parameters.updateApiUserName(apiUserName);
                this.parameters.updateApiToken(apiToken);
                this.parameters.updateLink(link);
                this.parameters.updateRoomName(apiUserName);
                this.parameters.updateMember(userName);
                this.parameters.updateValidated(true);
            }
            else {
                unsuccessfulAttempts += 1;
                this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
                this.cookieService.set('lastRequestTimestamp', Date.now().toString());
                this.parameters.updateIsLoadingModalVisible(false);
                if (unsuccessfulAttempts >= MAX_ATTEMPTS) {
                    this.parameters.showAlert?.({
                        message: 'Too many unsuccessful attempts. Please try again later.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
                else {
                    this.parameters.showAlert?.({
                        message: 'Invalid credentials.',
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
        }
        catch (error) {
            this.parameters.showAlert?.({
                message: 'Unable to connect. Check your credentials and try again.',
                type: 'danger',
                duration: 3000,
            });
            unsuccessfulAttempts += 1;
            this.cookieService.set('unsuccessfulAttempts', unsuccessfulAttempts.toString());
            this.cookieService.set('lastRequestTimestamp', Date.now().toString());
            this.parameters.updateIsLoadingModalVisible(false);
        }
    }
    handleScanSuccess(data) {
        try {
            const scannedText = data;
            const parts = scannedText.split(';');
            if (parts.length === 5) {
                const [userName, link, userSecret, passWord, meetingID] = parts;
                if (!userName.length ||
                    !link.length ||
                    !userSecret.length ||
                    !passWord.length ||
                    !meetingID.length ||
                    !this.validateAlphanumeric(userName) ||
                    !this.validateAlphanumeric(userSecret) ||
                    !this.validateAlphanumeric(passWord) ||
                    !this.validateAlphanumeric(meetingID) ||
                    userSecret.length !== 64 ||
                    userName.length > 12 ||
                    userName.length < 2 ||
                    meetingID.length > 32 ||
                    meetingID.length < 8 ||
                    !link.includes('mediasfu.com') ||
                    meetingID.toLowerCase().startsWith('d')) {
                    this.parameters.showAlert?.({
                        message: 'Invalid scanned data.',
                        type: 'danger',
                        duration: 3000,
                    });
                    return;
                }
                this.welcomeForm.setValue({
                    name: userName,
                    secret: userSecret,
                    eventID: meetingID,
                    link: link,
                });
                this.isScannerVisible = false;
                this.scannedData = null;
                this.checkLimitsAndMakeRequest(meetingID, userSecret, link, userName);
            }
            else {
                this.parameters.showAlert?.({
                    message: 'Invalid scanned data.',
                    type: 'danger',
                    duration: 3000,
                });
            }
        }
        catch (error) {
            this.parameters.showAlert?.({
                message: 'Invalid scanned data.',
                type: 'danger',
                duration: 3000,
            });
        }
    }
    validateAlphanumeric(str) {
        const alphanumericRegex = /^[a-zA-Z0-9]+$/;
        return alphanumericRegex.test(str);
    }
    // Method to list available cameras
    askForCameraPermission() {
        navigator.mediaDevices
            .enumerateDevices()
            .then((devices) => {
            this.allowedCameras = devices.filter((device) => device.kind === 'videoinput');
            if (this.allowedCameras.length > 0) {
                this.currentDevice = this.allowedCameras[0]; // Set the first available camera as the default
            }
        })
            .catch((err) => {
            console.error(err);
            this.parameters.showAlert?.({
                message: 'Camera access denied.',
                type: 'danger',
                duration: 3000,
            });
        });
    }
    toggleScanner() {
        this.isScannerVisible = !this.isScannerVisible;
        if (this.isScannerVisible) {
            this.askForCameraPermission();
        }
    }
    async handleConfirm() {
        if (this.welcomeForm.invalid) {
            this.error = 'Please fill all the fields correctly.';
            return;
        }
        const { name, secret, eventID, link } = this.welcomeForm.value;
        await this.checkLimitsAndMakeRequest(eventID, secret, link, name);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: WelcomePage, deps: [{ token: i2$2.FormBuilder }, { token: i1$1.CookieService }, { token: 'parameters', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: WelcomePage, isStandalone: true, selector: "app-welcome-page", providers: [CookieService], ngImport: i0, template: "<div class=\"container\">\r\n  <div class=\"logo-container\">\r\n    <img [src]=\"imgSrc || 'https://mediasfu.com/images/logo192.png'\" class=\"logo-image\" alt=\"Logo\" />\r\n  </div>\r\n  <form [formGroup]=\"welcomeForm\" (ngSubmit)=\"handleConfirm()\">\r\n    <div class=\"input-container\">\r\n      <input\r\n        formControlName=\"name\"\r\n        type=\"text\"\r\n        placeholder=\"Event Display Name\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"secret\"\r\n        type=\"text\"\r\n        placeholder=\"Event Token (Secret)\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"eventID\"\r\n        type=\"text\"\r\n        placeholder=\"Event ID\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"link\"\r\n        type=\"text\"\r\n        placeholder=\"Event Link\"\r\n        class=\"input-field\"\r\n      />\r\n    </div>\r\n    <button type=\"submit\" class=\"confirm-button\">Confirm</button>\r\n  </form>\r\n\r\n  <div class=\"scanner-container\">\r\n    <div class=\"or-container\">\r\n      <hr class=\"horizontal-line\" />\r\n      <span class=\"or-text\">OR</span>\r\n      <hr class=\"horizontal-line\" />\r\n    </div>\r\n    <div *ngIf=\"isScannerVisible\" class=\"scanner-wrapper\">\r\n      <zxing-scanner\r\n        [device]=\"currentDevice!\"\r\n        (scanSuccess)=\"handleScanSuccess($event)\"\r\n        [tryHarder]=\"true\"\r\n      ></zxing-scanner>\r\n    </div>\r\n    <div class=\"scan-button-container\" *ngIf=\"!isScannerVisible\">\r\n      <button (click)=\"toggleScanner()\" class=\"scan-button\">\r\n        <fa-icon [icon]=\"faQrcode\" style=\"margin-right: 5px\"></fa-icon>\r\n        Scan QR Code\r\n      </button>\r\n    </div>\r\n  </div>\r\n\r\n  <div class=\"additional-options-container\">\r\n    <p>\r\n      Provide the event details either by typing manually or scanning the\r\n      QR-code to autofill.\r\n    </p>\r\n    <p>Don't have a secret?</p>\r\n    <a\r\n      href=\"https://meeting.mediasfu.com/meeting/start/\"\r\n      target=\"_blank\"\r\n      class=\"link\"\r\n      >Get one from mediasfu.com</a\r\n    >\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100vw;height:100vh;max-width:100vw;max-height:100vh;margin:0;padding:0;background-color:#53c6e0;overflow:auto}.logo-container{margin-top:30px;padding-top:10px;margin-bottom:10px}.logo-image{width:100px;height:100px;border-radius:50%}.input-container{margin-bottom:10px;display:flex;flex-direction:column;align-items:center;justify-content:center}.input-field{height:30px;border-color:gray;border-width:1px;margin-bottom:10px;padding:0 5px;border-radius:5px}.confirm-button{background-color:#000;color:#fff;padding:5px;border-radius:5px;margin-bottom:10px;width:100%}.scanner-container{margin-bottom:10px;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}.additional-options-container{text-align:center}.link{color:#00f;text-decoration:none;font-weight:700;margin-left:5px}.scan-button{background-color:#000;color:#fff;padding:10px 20px;border-radius:5px;margin-bottom:20px}.scan-button-container{display:flex;justify-content:center;align-items:center}.or-container{display:flex;align-items:center;justify-content:center;width:100%;margin:10px 0}.horizontal-line{flex-grow:1;height:1px;background-color:gray;margin:0 10px}.or-text{color:#000;font-size:medium;font-weight:700}.scanner-wrapper{width:300px;height:300px;max-width:300px;max-height:300px;overflow:hidden;position:relative}zxing-scanner{width:100%;height:100%;object-fit:cover}\n"], dependencies: [{ kind: "ngmodule", type: ZXingScannerModule }, { kind: "component", type: i3.ZXingScannerComponent, selector: "zxing-scanner", inputs: ["autofocusEnabled", "timeBetweenScans", "delayBetweenScanSuccess", "autostart", "previewFitMode", "poster", "device", "formats", "videoConstraints", "torch", "enable", "tryHarder"], outputs: ["autostarted", "autostarting", "torchCompatible", "scanSuccess", "scanFailure", "scanError", "scanComplete", "camerasFound", "camerasNotFound", "permissionResponse", "hasDevices", "deviceChange"] }, { kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i2$2.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$2.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$2.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: WelcomePage, decorators: [{
            type: Component,
            args: [{ selector: 'app-welcome-page', imports: [ZXingScannerModule, CommonModule, FontAwesomeModule, ReactiveFormsModule], providers: [CookieService], template: "<div class=\"container\">\r\n  <div class=\"logo-container\">\r\n    <img [src]=\"imgSrc || 'https://mediasfu.com/images/logo192.png'\" class=\"logo-image\" alt=\"Logo\" />\r\n  </div>\r\n  <form [formGroup]=\"welcomeForm\" (ngSubmit)=\"handleConfirm()\">\r\n    <div class=\"input-container\">\r\n      <input\r\n        formControlName=\"name\"\r\n        type=\"text\"\r\n        placeholder=\"Event Display Name\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"secret\"\r\n        type=\"text\"\r\n        placeholder=\"Event Token (Secret)\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"eventID\"\r\n        type=\"text\"\r\n        placeholder=\"Event ID\"\r\n        class=\"input-field\"\r\n      />\r\n      <input\r\n        formControlName=\"link\"\r\n        type=\"text\"\r\n        placeholder=\"Event Link\"\r\n        class=\"input-field\"\r\n      />\r\n    </div>\r\n    <button type=\"submit\" class=\"confirm-button\">Confirm</button>\r\n  </form>\r\n\r\n  <div class=\"scanner-container\">\r\n    <div class=\"or-container\">\r\n      <hr class=\"horizontal-line\" />\r\n      <span class=\"or-text\">OR</span>\r\n      <hr class=\"horizontal-line\" />\r\n    </div>\r\n    <div *ngIf=\"isScannerVisible\" class=\"scanner-wrapper\">\r\n      <zxing-scanner\r\n        [device]=\"currentDevice!\"\r\n        (scanSuccess)=\"handleScanSuccess($event)\"\r\n        [tryHarder]=\"true\"\r\n      ></zxing-scanner>\r\n    </div>\r\n    <div class=\"scan-button-container\" *ngIf=\"!isScannerVisible\">\r\n      <button (click)=\"toggleScanner()\" class=\"scan-button\">\r\n        <fa-icon [icon]=\"faQrcode\" style=\"margin-right: 5px\"></fa-icon>\r\n        Scan QR Code\r\n      </button>\r\n    </div>\r\n  </div>\r\n\r\n  <div class=\"additional-options-container\">\r\n    <p>\r\n      Provide the event details either by typing manually or scanning the\r\n      QR-code to autofill.\r\n    </p>\r\n    <p>Don't have a secret?</p>\r\n    <a\r\n      href=\"https://meeting.mediasfu.com/meeting/start/\"\r\n      target=\"_blank\"\r\n      class=\"link\"\r\n      >Get one from mediasfu.com</a\r\n    >\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100vw;height:100vh;max-width:100vw;max-height:100vh;margin:0;padding:0;background-color:#53c6e0;overflow:auto}.logo-container{margin-top:30px;padding-top:10px;margin-bottom:10px}.logo-image{width:100px;height:100px;border-radius:50%}.input-container{margin-bottom:10px;display:flex;flex-direction:column;align-items:center;justify-content:center}.input-field{height:30px;border-color:gray;border-width:1px;margin-bottom:10px;padding:0 5px;border-radius:5px}.confirm-button{background-color:#000;color:#fff;padding:5px;border-radius:5px;margin-bottom:10px;width:100%}.scanner-container{margin-bottom:10px;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}.additional-options-container{text-align:center}.link{color:#00f;text-decoration:none;font-weight:700;margin-left:5px}.scan-button{background-color:#000;color:#fff;padding:10px 20px;border-radius:5px;margin-bottom:20px}.scan-button-container{display:flex;justify-content:center;align-items:center}.or-container{display:flex;align-items:center;justify-content:center;width:100%;margin:10px 0}.horizontal-line{flex-grow:1;height:1px;background-color:gray;margin:0 10px}.or-text{color:#000;font-size:medium;font-weight:700}.scanner-wrapper{width:300px;height:300px;max-width:300px;max-height:300px;overflow:hidden;position:relative}zxing-scanner{width:100%;height:100%;object-fit:cover}\n"] }]
        }], ctorParameters: () => [{ type: i2$2.FormBuilder }, { type: i1$1.CookieService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }] });

/**
 * Component representing an individual participant item in the participant list.
 * Provides controls for muting, messaging, and removing a participant.
 *
 * @component
 * @selector app-participant-list-item
 * @standalone true
 * @templateUrl ./participant-list-item.component.html
 * @styleUrls ['./participant-list-item.component.css']
 * @imports [CommonModule, FontAwesomeModule]
 *
 * @example
 * ```html
 * <app-participant-list-item [participant]="participant" [isBroadcast]="isBroadcast"
 *                            [onMuteParticipants]="muteHandler" [onMessageParticipants]="messageHandler"
 *                            [onRemoveParticipants]="removeHandler" [socket]="socket" [member]="member">
 * </app-participant-list-item>
 * ```
 */
class ParticipantListItem {
    participant;
    isBroadcast;
    onMuteParticipants;
    onMessageParticipants;
    onRemoveParticipants;
    socket;
    coHostResponsibility;
    member;
    islevel;
    showAlert;
    coHost;
    roomName;
    updateIsMessagesModalVisible;
    updateDirectMessageDetails;
    updateStartDirectMessage;
    participants;
    updateParticipants;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faComment = faComment;
    faTrash = faTrash;
    faDotCircle = faDotCircle;
    getIconName() {
        return this.participant.muted ? this.faMicrophoneSlash : this.faMicrophone;
    }
    muteParticipant() {
        if (this.onMuteParticipants) {
            this.onMuteParticipants({
                socket: this.socket,
                participant: this.participant,
                coHostResponsibility: this.coHostResponsibility,
                member: this.member,
                islevel: this.islevel,
                showAlert: this.showAlert,
                coHost: this.coHost,
                roomName: this.roomName,
            });
        }
    }
    messageParticipant() {
        if (this.onMessageParticipants) {
            this.onMessageParticipants({
                participant: this.participant,
                coHostResponsibility: this.coHostResponsibility,
                member: this.member,
                islevel: this.islevel,
                showAlert: this.showAlert,
                coHost: this.coHost,
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible,
                updateDirectMessageDetails: this.updateDirectMessageDetails,
                updateStartDirectMessage: this.updateStartDirectMessage,
            });
        }
    }
    removeParticipant() {
        if (this.onRemoveParticipants) {
            this.onRemoveParticipants({
                socket: this.socket,
                participant: this.participant,
                coHostResponsibility: this.coHostResponsibility,
                member: this.member,
                islevel: this.islevel,
                showAlert: this.showAlert,
                coHost: this.coHost,
                roomName: this.roomName,
                participants: this.participants,
                updateParticipants: this.updateParticipants,
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantListItem, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ParticipantListItem, isStandalone: true, selector: "app-participant-list-item", inputs: { participant: "participant", isBroadcast: "isBroadcast", onMuteParticipants: "onMuteParticipants", onMessageParticipants: "onMessageParticipants", onRemoveParticipants: "onRemoveParticipants", socket: "socket", coHostResponsibility: "coHostResponsibility", member: "member", islevel: "islevel", showAlert: "showAlert", coHost: "coHost", roomName: "roomName", updateIsMessagesModalVisible: "updateIsMessagesModalVisible", updateDirectMessageDetails: "updateDirectMessageDetails", updateStartDirectMessage: "updateStartDirectMessage", participants: "participants", updateParticipants: "updateParticipants" }, ngImport: i0, template: "<div class=\"container\" style=\"display: flex; flex-direction: row; align-items: center; margin-bottom: 0px; margin-top: 0px;\">\r\n  <div class=\"nameContainer\" style=\"flex: 4;\">\r\n    <p class=\"nameText\" style=\"font-size: 16px;\">\r\n      {{ participant.islevel === '2' ? participant.name + ' (host)' : participant.name }}\r\n    </p>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"iconContainer\" style=\"flex: 1; align-items: center;\">\r\n    <fa-icon [icon]=\"participant.muted ? faDotCircle : faDotCircle\" [style.font-size.px]=\"20\" [style.color]=\"participant.muted ? 'red' : 'green'\"></fa-icon>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"muteParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #007bff; color: white;\">\r\n      <fa-icon [icon]=\"getIconName()\" style=\"font-size: 20px;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"messageParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #007bff; color: white;\">\r\n      <fa-icon [icon]=\"faComment\" style=\"font-size: 20px; color: white;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"removeParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #dc3545; color: white;\">\r\n      <fa-icon [icon]=\"faTrash\" style=\"font-size: 20px; color: white;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:row;align-items:center;margin-bottom:0;margin-top:0}.nameContainer{flex:4}.nameText{font-size:16px}.iconContainer,.buttonContainer{flex:2;align-items:center}button{padding:5px;border-radius:5px;background-color:#007bff;color:#fff}button.remove{background-color:#dc3545}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantListItem, decorators: [{
            type: Component,
            args: [{ selector: 'app-participant-list-item', imports: [CommonModule, FontAwesomeModule], template: "<div class=\"container\" style=\"display: flex; flex-direction: row; align-items: center; margin-bottom: 0px; margin-top: 0px;\">\r\n  <div class=\"nameContainer\" style=\"flex: 4;\">\r\n    <p class=\"nameText\" style=\"font-size: 16px;\">\r\n      {{ participant.islevel === '2' ? participant.name + ' (host)' : participant.name }}\r\n    </p>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"iconContainer\" style=\"flex: 1; align-items: center;\">\r\n    <fa-icon [icon]=\"participant.muted ? faDotCircle : faDotCircle\" [style.font-size.px]=\"20\" [style.color]=\"participant.muted ? 'red' : 'green'\"></fa-icon>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"muteParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #007bff; color: white;\">\r\n      <fa-icon [icon]=\"getIconName()\" style=\"font-size: 20px;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div *ngIf=\"!isBroadcast\" class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"messageParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #007bff; color: white;\">\r\n      <fa-icon [icon]=\"faComment\" style=\"font-size: 20px; color: white;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div class=\"buttonContainer\" style=\"flex: 2; align-items: flex-end;\">\r\n    <button (click)=\"removeParticipant()\" style=\"padding: 5px; border-radius: 5px; align-items: center; background-color: #dc3545; color: white;\">\r\n      <fa-icon [icon]=\"faTrash\" style=\"font-size: 20px; color: white;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:row;align-items:center;margin-bottom:0;margin-top:0}.nameContainer{flex:4}.nameText{font-size:16px}.iconContainer,.buttonContainer{flex:2;align-items:center}button{padding:5px;border-radius:5px;background-color:#007bff;color:#fff}button.remove{background-color:#dc3545}\n"] }]
        }], propDecorators: { participant: [{
                type: Input
            }], isBroadcast: [{
                type: Input
            }], onMuteParticipants: [{
                type: Input
            }], onMessageParticipants: [{
                type: Input
            }], onRemoveParticipants: [{
                type: Input
            }], socket: [{
                type: Input
            }], coHostResponsibility: [{
                type: Input
            }], member: [{
                type: Input
            }], islevel: [{
                type: Input
            }], showAlert: [{
                type: Input
            }], coHost: [{
                type: Input
            }], roomName: [{
                type: Input
            }], updateIsMessagesModalVisible: [{
                type: Input
            }], updateDirectMessageDetails: [{
                type: Input
            }], updateStartDirectMessage: [{
                type: Input
            }], participants: [{
                type: Input
            }], updateParticipants: [{
                type: Input
            }] } });

/* eslint-disable @typescript-eslint/no-empty-function */
/**
 * @component ParticipantList
 * @description Displays a list of participants and provides actions like muting, messaging, and removing participants.
 *
 * @selector app-participant-list
 * @standalone true
 * @templateUrl ./participant-list.component.html
 * @styleUrls ['./participant-list.component.css']
 * @imports [CommonModule, ParticipantListItem]
 *
 * @example
 * ```html
 * <app-participant-list [participants]="participants" [isBroadcast]="isBroadcast"
 *                       [onMuteParticipants]="muteParticipantsHandler"
 *                       [onMessageParticipants]="messageParticipantsHandler"
 *                       [onRemoveParticipants]="removeParticipantsHandler">
 * </app-participant-list>
 * ```
 */
class ParticipantList {
    participants = [];
    isBroadcast = false;
    onMuteParticipants;
    onMessageParticipants;
    onRemoveParticipants;
    socket = {};
    coHostResponsibility = [];
    member = '';
    islevel = '';
    showAlert;
    coHost = '';
    roomName = '';
    updateIsMessagesModalVisible = () => { };
    updateDirectMessageDetails = () => { };
    updateStartDirectMessage = () => { };
    updateParticipants = () => { };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantList, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ParticipantList, isStandalone: true, selector: "app-participant-list", inputs: { participants: "participants", isBroadcast: "isBroadcast", onMuteParticipants: "onMuteParticipants", onMessageParticipants: "onMessageParticipants", onRemoveParticipants: "onRemoveParticipants", socket: "socket", coHostResponsibility: "coHostResponsibility", member: "member", islevel: "islevel", showAlert: "showAlert", coHost: "coHost", roomName: "roomName", updateIsMessagesModalVisible: "updateIsMessagesModalVisible", updateDirectMessageDetails: "updateDirectMessageDetails", updateStartDirectMessage: "updateStartDirectMessage", updateParticipants: "updateParticipants" }, ngImport: i0, template: "<div *ngFor=\"let participant of participants; let i = index\">\r\n  <app-participant-list-item\r\n    [participant]=\"participant\"\r\n    [isBroadcast]=\"isBroadcast\"\r\n    [onMuteParticipants]=\"onMuteParticipants\"\r\n    [onMessageParticipants]=\"onMessageParticipants\"\r\n    [onRemoveParticipants]=\"onRemoveParticipants\"\r\n    [socket]=\"socket\"\r\n    [coHostResponsibility]=\"coHostResponsibility\"\r\n    [coHost]=\"coHost\"\r\n    [member]=\"member\"\r\n    [islevel]=\"islevel\"\r\n    [roomName]=\"roomName\"\r\n    [participants]=\"participants\"\r\n    [updateIsMessagesModalVisible]=\"updateIsMessagesModalVisible\"\r\n    [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n    [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n    [updateParticipants]=\"updateParticipants\"\r\n  ></app-participant-list-item>\r\n  <hr *ngIf=\"i < participants.length - 1\" class=\"separator\" />\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ParticipantListItem, selector: "app-participant-list-item", inputs: ["participant", "isBroadcast", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "socket", "coHostResponsibility", "member", "islevel", "showAlert", "coHost", "roomName", "updateIsMessagesModalVisible", "updateDirectMessageDetails", "updateStartDirectMessage", "participants", "updateParticipants"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantList, decorators: [{
            type: Component,
            args: [{ selector: 'app-participant-list', imports: [CommonModule, ParticipantListItem], template: "<div *ngFor=\"let participant of participants; let i = index\">\r\n  <app-participant-list-item\r\n    [participant]=\"participant\"\r\n    [isBroadcast]=\"isBroadcast\"\r\n    [onMuteParticipants]=\"onMuteParticipants\"\r\n    [onMessageParticipants]=\"onMessageParticipants\"\r\n    [onRemoveParticipants]=\"onRemoveParticipants\"\r\n    [socket]=\"socket\"\r\n    [coHostResponsibility]=\"coHostResponsibility\"\r\n    [coHost]=\"coHost\"\r\n    [member]=\"member\"\r\n    [islevel]=\"islevel\"\r\n    [roomName]=\"roomName\"\r\n    [participants]=\"participants\"\r\n    [updateIsMessagesModalVisible]=\"updateIsMessagesModalVisible\"\r\n    [updateStartDirectMessage]=\"updateStartDirectMessage\"\r\n    [updateDirectMessageDetails]=\"updateDirectMessageDetails\"\r\n    [updateParticipants]=\"updateParticipants\"\r\n  ></app-participant-list-item>\r\n  <hr *ngIf=\"i < participants.length - 1\" class=\"separator\" />\r\n</div>\r\n" }]
        }], propDecorators: { participants: [{
                type: Input
            }], isBroadcast: [{
                type: Input
            }], onMuteParticipants: [{
                type: Input
            }], onMessageParticipants: [{
                type: Input
            }], onRemoveParticipants: [{
                type: Input
            }], socket: [{
                type: Input
            }], coHostResponsibility: [{
                type: Input
            }], member: [{
                type: Input
            }], islevel: [{
                type: Input
            }], showAlert: [{
                type: Input
            }], coHost: [{
                type: Input
            }], roomName: [{
                type: Input
            }], updateIsMessagesModalVisible: [{
                type: Input
            }], updateDirectMessageDetails: [{
                type: Input
            }], updateStartDirectMessage: [{
                type: Input
            }], updateParticipants: [{
                type: Input
            }] } });

/**
 * Component for displaying an individual participant item in the "others" participant list.
 * Provides a display name with conditional labels for roles such as host, co-host, or self.
 *
 * @component
 * @selector app-participant-list-others-item
 * @standalone true
 * @templateUrl ./participant-list-others-item.component.html
 * @styleUrls ['./participant-list-others-item.component.css']
 * @imports [CommonModule, FontAwesomeModule]
 *
 * @example
 * ```html
 * <app-participant-list-others-item [participant]="participant" [member]="currentMember" [coHost]="coHostID">
 * </app-participant-list-others-item>
 * ```
 */
class ParticipantListOthersItem {
    participant;
    member;
    coHost;
    faCircle = faCircle;
    getParticipantDisplayName() {
        if (this.participant.islevel === '2') {
            return this.participant.name === this.member
                ? `${this.participant.name} (you)`
                : `${this.participant.name} (host)`;
        }
        else {
            if (this.participant.name === this.member) {
                return `${this.participant.name} (you)`;
            }
            else if (this.coHost === this.participant.name) {
                return `${this.participant.name} (co-host)`;
            }
            else {
                return this.participant.name;
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantListOthersItem, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ParticipantListOthersItem, isStandalone: true, selector: "app-participant-list-others-item", inputs: { participant: "participant", member: "member", coHost: "coHost" }, ngImport: i0, template: "<div class=\"container\">\r\n  <div class=\"name-container\">\r\n    <span class=\"name-text\">\r\n      {{ getParticipantDisplayName() }}\r\n    </span>\r\n  </div>\r\n  <div class=\"icon-container\">\r\n    <fa-icon [icon]=\"faCircle\" [style.color]=\"participant.muted ? 'red' : 'green'\"></fa-icon>\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:row;align-items:center;margin-bottom:10px}.name-container{flex:8}.name-text{font-size:16px}.icon-container{flex:4;display:flex;align-items:center}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantListOthersItem, decorators: [{
            type: Component,
            args: [{ selector: 'app-participant-list-others-item', imports: [CommonModule, FontAwesomeModule], template: "<div class=\"container\">\r\n  <div class=\"name-container\">\r\n    <span class=\"name-text\">\r\n      {{ getParticipantDisplayName() }}\r\n    </span>\r\n  </div>\r\n  <div class=\"icon-container\">\r\n    <fa-icon [icon]=\"faCircle\" [style.color]=\"participant.muted ? 'red' : 'green'\"></fa-icon>\r\n  </div>\r\n</div>\r\n", styles: [".container{display:flex;flex-direction:row;align-items:center;margin-bottom:10px}.name-container{flex:8}.name-text{font-size:16px}.icon-container{flex:4;display:flex;align-items:center}\n"] }]
        }], propDecorators: { participant: [{
                type: Input
            }], member: [{
                type: Input
            }], coHost: [{
                type: Input
            }] } });

/**
 * Component for displaying a list of other participants.
 * It renders individual participant items within the list.
 *
 * @component
 * @selector app-participant-list-others
 * @standalone true
 * @templateUrl ./participant-list-others.component.html
 * @styleUrls ['./participant-list-others.component.css']
 * @imports [CommonModule, ParticipantListOthersItem]
 *
 * @example
 * ```html
 * <app-participant-list-others [participants]="participantsList" [coHost]="coHostID" [member]="memberID">
 * </app-participant-list-others>
 * ```
 */
class ParticipantListOthers {
    participants = [];
    coHost = '';
    member = '';
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantListOthers, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ParticipantListOthers, isStandalone: true, selector: "app-participant-list-others", inputs: { participants: "participants", coHost: "coHost", member: "member" }, ngImport: i0, template: "<div *ngFor=\"let participant of participants; let i = index\">\r\n  <app-participant-list-others-item\r\n    [participant]=\"participant\"\r\n    [coHost]=\"coHost\"\r\n    [member]=\"member\"\r\n  ></app-participant-list-others-item>\r\n  <hr *ngIf=\"i < participants.length - 1\" class=\"separator\" />\r\n</div>\r\n", styles: [".separator{border:none;border-top:1px solid #e0e0e0;margin:10px 0}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ParticipantListOthersItem, selector: "app-participant-list-others-item", inputs: ["participant", "member", "coHost"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantListOthers, decorators: [{
            type: Component,
            args: [{ selector: 'app-participant-list-others', imports: [CommonModule, ParticipantListOthersItem], template: "<div *ngFor=\"let participant of participants; let i = index\">\r\n  <app-participant-list-others-item\r\n    [participant]=\"participant\"\r\n    [coHost]=\"coHost\"\r\n    [member]=\"member\"\r\n  ></app-participant-list-others-item>\r\n  <hr *ngIf=\"i < participants.length - 1\" class=\"separator\" />\r\n</div>\r\n", styles: [".separator{border:none;border-top:1px solid #e0e0e0;margin:10px 0}\n"] }]
        }], propDecorators: { participants: [{
                type: Input
            }], coHost: [{
                type: Input
            }], member: [{
                type: Input
            }] } });

/**
 * Component for displaying a modal containing a list of participants with options to mute, message, or remove participants.
 * Supports both regular participants and a subset of "other" participants.
 *
 * @component
 * @selector app-participants-modal
 * @standalone true
 * @templateUrl ./participants-modal.component.html
 * @styleUrls ['./participants-modal.component.css']
 * @imports [CommonModule, FontAwesomeModule, ParticipantList, ParticipantListOthers]
 *
 * @example
 * ```html
 * <app-participants-modal
 *   [isParticipantsModalVisible]="true"
 *   [onParticipantsClose]="closeModalFunction"
 *   [onParticipantsFilterChange]="filterFunction"
 *   [participantsCounter]="5"
 *   [parameters]="participantsModalParameters"
 *   [position]="'topRight'"
 *   [backgroundColor]="'#83c0e9'"
 * ></app-participants-modal>
 * ```
 */
class ParticipantsModal {
    muteParticipantsService;
    messageParticipantsService;
    removeParticipantsService;
    isParticipantsModalVisible = false;
    onParticipantsClose;
    onParticipantsFilterChange;
    participantsCounter = 0;
    onMuteParticipants;
    onMessageParticipants;
    onRemoveParticipants;
    parameters = {};
    position = 'topRight';
    backgroundColor = '#83c0e9';
    participant_s = [];
    participantsCounter_s = 0;
    reRender = false;
    faTimes = faTimes;
    constructor(muteParticipantsService, messageParticipantsService, removeParticipantsService) {
        this.muteParticipantsService = muteParticipantsService;
        this.messageParticipantsService = messageParticipantsService;
        this.removeParticipantsService = removeParticipantsService;
    }
    ngOnInit() {
        this.updateParticipantsData();
        if (!this.onMuteParticipants) {
            this.onMuteParticipants = this.muteParticipantsService.muteParticipants.bind(this.muteParticipantsService);
        }
        if (!this.onMessageParticipants) {
            this.onMessageParticipants = this.messageParticipantsService.messageParticipants.bind(this.messageParticipantsService);
        }
        if (!this.onRemoveParticipants) {
            this.onRemoveParticipants = this.removeParticipantsService.removeParticipants.bind(this.removeParticipantsService);
        }
    }
    ngOnChanges(changes) {
        if (changes['parameters'] || changes['participantsCounter']) {
            this.updateParticipantsData();
        }
    }
    updateParticipantsData() {
        let { getUpdatedAllParams } = this.parameters;
        this.parameters = getUpdatedAllParams();
        this.participant_s = this.parameters.filteredParticipants;
        this.participantsCounter_s = this.parameters.filteredParticipants.length;
    }
    handleFilterChange(event) {
        const inputElement = event.target;
        const filterValue = inputElement.value;
        this.onParticipantsFilterChange(filterValue);
        this.reRender = !this.reRender;
    }
    handleClose() {
        this.onParticipantsClose();
    }
    canShowParticipantList() {
        const participantsValue = this.parameters.coHostResponsibility?.find((item) => item.name === 'participants')?.value;
        return (this.parameters.islevel === '2' ||
            (this.parameters.coHost === this.parameters.member && participantsValue === true));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantsModal, deps: [{ token: MuteParticipants }, { token: MessageParticipants }, { token: RemoveParticipants }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ParticipantsModal, isStandalone: true, selector: "app-participants-modal", inputs: { isParticipantsModalVisible: "isParticipantsModalVisible", onParticipantsClose: "onParticipantsClose", onParticipantsFilterChange: "onParticipantsFilterChange", participantsCounter: "participantsCounter", onMuteParticipants: "onMuteParticipants", onMessageParticipants: "onMessageParticipants", onRemoveParticipants: "onRemoveParticipants", parameters: "parameters", position: "position", backgroundColor: "backgroundColor" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isParticipantsModalVisible\" class=\"modal-container\" [ngStyle]=\"{'background-color': 'rgba(0, 0, 0, 0.5)'}\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{'background-color': backgroundColor, 'top': position.includes('top') ? '10px' : 'auto', 'bottom': position.includes('bottom') ? '10px' : 'auto', 'left': position.includes('Left') ? '10px' : 'auto', 'right': position.includes('Right') ? '10px' : 'auto'}\">\r\n    <div class=\"modal-header\">\r\n      <div>\r\n        Participants <span class=\"badge\">{{ participantsCounter_s }}</span>\r\n      </div>\r\n      <div class=\"close-icon\" (click)=\"handleClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-body\">\r\n      <input type=\"text\" class=\"filter-input\" placeholder=\"Search ...\" (input)=\"handleFilterChange($event)\">\r\n      <ng-container *ngIf=\"parameters.participants\">\r\n        <ng-container *ngIf=\"canShowParticipantList()\">\r\n          <app-participant-list\r\n            [participants]=\"participant_s\"\r\n            [isBroadcast]=\"parameters.eventType === 'broadcast'\"\r\n            [onMuteParticipants]=\"onMuteParticipants\"\r\n            [onMessageParticipants]=\"onMessageParticipants\"\r\n            [onRemoveParticipants]=\"onRemoveParticipants\"\r\n            [socket]=\"parameters.socket\"\r\n            [coHostResponsibility]=\"parameters.coHostResponsibility\"\r\n            [coHost]=\"parameters.coHost\"\r\n            [member]=\"parameters.member\"\r\n            [islevel]=\"parameters.islevel\"\r\n            [roomName]=\"parameters.roomName\"\r\n            [updateIsMessagesModalVisible]=\"parameters.updateIsMessagesModalVisible\"\r\n            [updateStartDirectMessage]=\"parameters.updateStartDirectMessage\"\r\n            [updateDirectMessageDetails]=\"parameters.updateDirectMessageDetails\"\r\n            [updateParticipants]=\"parameters.updateParticipants\"\r\n          >\r\n          </app-participant-list>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!canShowParticipantList()\">\r\n          <app-participant-list-others\r\n            [participants]=\"participant_s\"\r\n            [coHost]=\"parameters.coHost\"\r\n            [member]=\"parameters.member\"\r\n            >\r\n          </app-participant-list-others>\r\n        </ng-container>\r\n      </ng-container>\r\n      <div *ngIf=\"!parameters.participants\">No participants</div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:80%;max-width:400px;max-height:75%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center}.badge{background-color:#fff;color:#000;border-radius:10px;padding:5px}.close-icon{padding:5px;cursor:pointer}.modal-body{margin-top:10px}.filter-input{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: ParticipantList, selector: "app-participant-list", inputs: ["participants", "isBroadcast", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "socket", "coHostResponsibility", "member", "islevel", "showAlert", "coHost", "roomName", "updateIsMessagesModalVisible", "updateDirectMessageDetails", "updateStartDirectMessage", "updateParticipants"] }, { kind: "component", type: ParticipantListOthers, selector: "app-participant-list-others", inputs: ["participants", "coHost", "member"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ParticipantsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-participants-modal', imports: [CommonModule, FontAwesomeModule, ParticipantList, ParticipantListOthers], template: "<div *ngIf=\"isParticipantsModalVisible\" class=\"modal-container\" [ngStyle]=\"{'background-color': 'rgba(0, 0, 0, 0.5)'}\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{'background-color': backgroundColor, 'top': position.includes('top') ? '10px' : 'auto', 'bottom': position.includes('bottom') ? '10px' : 'auto', 'left': position.includes('Left') ? '10px' : 'auto', 'right': position.includes('Right') ? '10px' : 'auto'}\">\r\n    <div class=\"modal-header\">\r\n      <div>\r\n        Participants <span class=\"badge\">{{ participantsCounter_s }}</span>\r\n      </div>\r\n      <div class=\"close-icon\" (click)=\"handleClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"xl\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <div class=\"modal-body\">\r\n      <input type=\"text\" class=\"filter-input\" placeholder=\"Search ...\" (input)=\"handleFilterChange($event)\">\r\n      <ng-container *ngIf=\"parameters.participants\">\r\n        <ng-container *ngIf=\"canShowParticipantList()\">\r\n          <app-participant-list\r\n            [participants]=\"participant_s\"\r\n            [isBroadcast]=\"parameters.eventType === 'broadcast'\"\r\n            [onMuteParticipants]=\"onMuteParticipants\"\r\n            [onMessageParticipants]=\"onMessageParticipants\"\r\n            [onRemoveParticipants]=\"onRemoveParticipants\"\r\n            [socket]=\"parameters.socket\"\r\n            [coHostResponsibility]=\"parameters.coHostResponsibility\"\r\n            [coHost]=\"parameters.coHost\"\r\n            [member]=\"parameters.member\"\r\n            [islevel]=\"parameters.islevel\"\r\n            [roomName]=\"parameters.roomName\"\r\n            [updateIsMessagesModalVisible]=\"parameters.updateIsMessagesModalVisible\"\r\n            [updateStartDirectMessage]=\"parameters.updateStartDirectMessage\"\r\n            [updateDirectMessageDetails]=\"parameters.updateDirectMessageDetails\"\r\n            [updateParticipants]=\"parameters.updateParticipants\"\r\n          >\r\n          </app-participant-list>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!canShowParticipantList()\">\r\n          <app-participant-list-others\r\n            [participants]=\"participant_s\"\r\n            [coHost]=\"parameters.coHost\"\r\n            [member]=\"parameters.member\"\r\n            >\r\n          </app-participant-list-others>\r\n        </ng-container>\r\n      </ng-container>\r\n      <div *ngIf=\"!parameters.participants\">No participants</div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;width:80%;max-width:400px;max-height:75%;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center}.badge{background-color:#fff;color:#000;border-radius:10px;padding:5px}.close-icon{padding:5px;cursor:pointer}.modal-body{margin-top:10px}.filter-input{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}\n"] }]
        }], ctorParameters: () => [{ type: MuteParticipants }, { type: MessageParticipants }, { type: RemoveParticipants }], propDecorators: { isParticipantsModalVisible: [{
                type: Input
            }], onParticipantsClose: [{
                type: Input
            }], onParticipantsFilterChange: [{
                type: Input
            }], participantsCounter: [{
                type: Input
            }], onMuteParticipants: [{
                type: Input
            }], onMessageParticipants: [{
                type: Input
            }], onRemoveParticipants: [{
                type: Input
            }], parameters: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }] } });

/* eslint-disable @typescript-eslint/no-empty-function */
/**
 * Component for displaying a poll modal, allowing users to create, vote, and end polls within a session.
 *
 * @component
 * @selector app-poll-modal
 * @standalone true
 * @templateUrl ./poll-modal.component.html
 * @styleUrls ['./poll-modal.component.css']
 * @imports [CommonModule, FontAwesomeModule, FormsModule]
 *
 * @example
 * ```html
 * <app-poll-modal
 *   [isPollModalVisible]="true"
 *   [onClose]="closeModalFunction"
 *   [member]="currentMember"
 *   [islevel]="'2'"
 *   [polls]="pollList"
 *   [poll]="selectedPoll"
 *   [socket]="socketInstance"
 *   [roomName]="'exampleRoom'"
 *   [handleCreatePoll]="createPollFunction"
 *   [handleEndPoll]="endPollFunction"
 *   [handleVotePoll]="votePollFunction"
 * ></app-poll-modal>
 * ```
 */
class PollModal {
    isPollModalVisible = false;
    onClose;
    position = 'topRight';
    backgroundColor = '#f5f5f5';
    member = '';
    islevel = '';
    polls = [];
    poll = null;
    socket = {};
    roomName = '';
    showAlert = () => { };
    updateIsPollModalVisible = () => { };
    handleCreatePoll;
    handleEndPoll;
    handleVotePoll;
    faTimes = faTimes;
    newPoll = { question: '', type: '', options: [] };
    screenWidth = window.innerWidth;
    modalWidth = this.screenWidth > 500 ? 350 : 0.7 * this.screenWidth;
    ngOnInit() {
        this.renderPolls();
    }
    ngOnChanges(changes) {
        if (changes['isPollModalVisible']) {
            this.renderPolls();
        }
    }
    renderPolls = () => {
        let activePollCount = 0;
        this.polls &&
            this.polls.forEach((polled) => {
                if (polled.status === 'active' && this.poll && polled.id === this.poll.id) {
                    activePollCount++;
                }
            });
        if (this.islevel == '2' && activePollCount === 0) {
            if (this.poll && this.poll.status === 'active') {
                this.poll.status = 'inactive';
            }
        }
    };
    calculatePercentage(votes, optionIndex) {
        const totalVotes = votes.reduce((a, b) => a + b, 0);
        return totalVotes > 0 ? parseFloat(((votes[optionIndex] / totalVotes) * 100).toFixed(2)) : 0;
    }
    handlePollTypeChange(event) {
        const type = event.target.value;
        let options = [];
        switch (type) {
            case 'trueFalse':
                options = ['True', 'False'];
                break;
            case 'yesNo':
                options = ['Yes', 'No'];
                break;
            case 'custom':
                options = ['', '', '', '', '']; // Preload 5 empty options
                break;
            default:
                options = [];
                break;
        }
        this.newPoll = { ...this.newPoll, type, options };
    }
    async validateAndCreatePoll() {
        // Remove empty options before creating the poll
        this.newPoll.options = this.newPoll.options.filter((option) => option.trim() !== '');
        // Ensure there's at least one valid option
        if (this.newPoll.options.length > 0) {
            await this.handleCreatePoll({
                poll: this.newPoll,
                socket: this.socket,
                roomName: this.roomName,
                showAlert: this.showAlert,
                updateIsPollModalVisible: this.updateIsPollModalVisible,
            });
        }
    }
    handledVotePoll(pollId, optionIndex) {
        this.handleVotePoll({
            pollId,
            optionIndex,
            socket: this.socket,
            member: this.member,
            roomName: this.roomName,
            showAlert: this.showAlert,
            updateIsPollModalVisible: this.updateIsPollModalVisible,
        });
    }
    handledEndPoll(pollId) {
        this.handleEndPoll({
            pollId,
            socket: this.socket,
            roomName: this.roomName,
            showAlert: this.showAlert,
            updateIsPollModalVisible: this.updateIsPollModalVisible,
        });
    }
    get modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isPollModalVisible ? 'block' : 'none',
            zIndex: 999,
        };
    }
    get modalContentStyle() {
        return {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${this.modalWidth}px`,
            maxHeight: '75%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PollModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: PollModal, isStandalone: true, selector: "app-poll-modal", inputs: { isPollModalVisible: "isPollModalVisible", onClose: "onClose", position: "position", backgroundColor: "backgroundColor", member: "member", islevel: "islevel", polls: "polls", poll: "poll", socket: "socket", roomName: "roomName", showAlert: "showAlert", updateIsPollModalVisible: "updateIsPollModalVisible", handleCreatePoll: "handleCreatePoll", handleEndPoll: "handleEndPoll", handleVotePoll: "handleVotePoll" }, usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\">\r\n      <h2>Polls</h2>\r\n      <button (click)=\"onClose()\" class=\"close-button\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <!-- Previous Polls Section -->\r\n      <div *ngIf=\"islevel === '2'\">\r\n        <div class=\"previous-polls\">\r\n          <h5>Previous Polls</h5>\r\n          <div *ngIf=\"polls.length === 0\">No polls available</div>\r\n\r\n          <!-- Using ng-container to avoid multiple structural directives on the same element -->\r\n          <ng-container *ngFor=\"let polled of polls\">\r\n            <div\r\n              *ngIf=\"!poll || polled.id !== poll.id || poll.status !== 'active'\"\r\n              class=\"poll\"\r\n            >\r\n              <h6>Question:</h6>\r\n              <textarea\r\n                class=\"form-control\"\r\n                rows=\"3\"\r\n                [disabled]=\"true\"\r\n                [value]=\"polled.question\"\r\n              ></textarea>\r\n              <br />\r\n              <h6>Options:</h6>\r\n              <div *ngFor=\"let option of polled.options; let i = index\">\r\n                {{ option }}: {{ polled.votes[i] }} votes ({{\r\n                  calculatePercentage(polled.votes, i)\r\n                }}%)\r\n              </div>\r\n              <!-- End Poll Button (if poll is active) -->\r\n              <button\r\n                *ngIf=\"polled.status === 'active'\"\r\n                class=\"btn btn-danger\"\r\n                (click)=\"handledEndPoll(polled.id)\"\r\n              >\r\n                End Poll\r\n              </button>\r\n            </div>\r\n          </ng-container>\r\n        </div>\r\n        <hr />\r\n\r\n        <!-- Create Poll Section -->\r\n        <div class=\"create-poll\">\r\n          <h5>Create a New Poll</h5>\r\n          <form (ngSubmit)=\"validateAndCreatePoll()\">\r\n            <div class=\"form-group\">\r\n              <label for=\"pollQuestion\">Poll Question</label>\r\n              <textarea\r\n                class=\"form-control\"\r\n                id=\"pollQuestion\"\r\n                rows=\"3\"\r\n                maxLength=\"300\"\r\n                required\r\n                [(ngModel)]=\"newPoll.question\"\r\n                name=\"question\"\r\n              ></textarea>\r\n            </div>\r\n            <div class=\"form-group\">\r\n              <label for=\"pollType\">Select Poll Answer Type</label>\r\n              <select\r\n                class=\"form-control\"\r\n                id=\"pollType\"\r\n                required\r\n                (change)=\"handlePollTypeChange($event)\"\r\n                [(ngModel)]=\"newPoll.type\"\r\n                name=\"type\"\r\n              >\r\n                <option value=\"\">Choose...</option>\r\n                <option value=\"trueFalse\">True/False</option>\r\n                <option value=\"yesNo\">Yes/No</option>\r\n                <option value=\"custom\">Custom</option>\r\n              </select>\r\n            </div>\r\n\r\n            <!-- Render Poll Options -->\r\n            <div\r\n              *ngIf=\"newPoll.type === 'trueFalse' || newPoll.type === 'yesNo'\"\r\n            >\r\n              <div\r\n                *ngFor=\"let option of newPoll.options; let i = index\"\r\n                class=\"form-check\"\r\n              >\r\n                <input\r\n                  class=\"form-check-input\"\r\n                  type=\"radio\"\r\n                  name=\"pollOption\"\r\n                  [value]=\"option.toLowerCase()\"\r\n                  [id]=\"'option' + option\"\r\n                />\r\n                <label class=\"form-check-label\" [for]=\"'option' + option\">{{\r\n                  option\r\n                }}</label>\r\n              </div>\r\n            </div>\r\n            <div *ngIf=\"newPoll.type === 'custom'\">\r\n              <div\r\n                *ngFor=\"let option of newPoll.options; let i = index\"\r\n                class=\"form-group\"\r\n              >\r\n                <input\r\n                  type=\"text\"\r\n                  class=\"form-control\"\r\n                  placeholder=\"Option {{ i + 1 }}\"\r\n                  maxLength=\"50\"\r\n                  [(ngModel)]=\"newPoll.options[i]\"\r\n                  name=\"option{{ i }}\"\r\n                />\r\n              </div>\r\n            </div>\r\n            <button type=\"submit\" class=\"btn btn-primary\">Create Poll</button>\r\n          </form>\r\n        </div>\r\n        <hr />\r\n      </div>\r\n\r\n      <!-- Current Poll Section -->\r\n      <div class=\"current-poll\">\r\n        <h5>Current Poll</h5>\r\n        <div *ngIf=\"poll && poll.status === 'active'\">\r\n          <h6>Question:</h6>\r\n          <textarea\r\n            class=\"form-control\"\r\n            rows=\"3\"\r\n            [disabled]=\"true\"\r\n            [value]=\"poll.question\"\r\n          ></textarea>\r\n          <h6>Options:</h6>\r\n          <div\r\n            *ngFor=\"let option of poll.options; let i = index\"\r\n            class=\"form-check\"\r\n          >\r\n            <input\r\n              class=\"form-check-input\"\r\n              type=\"radio\"\r\n              name=\"pollOption\"\r\n              [value]=\"i\"\r\n              id=\"pollOption{{ i }}\"\r\n              [checked]=\"poll.voters?.[member] === i\"\r\n              (change)=\"handledVotePoll(poll.id, i)\"\r\n            />\r\n            <label class=\"form-check-label\" [for]=\"'pollOption' + i\">{{\r\n              option\r\n            }}</label>\r\n          </div>\r\n          <button\r\n            *ngIf=\"poll.status === 'active' && islevel === '2'\"\r\n            class=\"btn btn-danger\"\r\n            (click)=\"handledEndPoll(poll.id)\"\r\n          >\r\n            End Poll\r\n          </button>\r\n        </div>\r\n        <div *ngIf=\"!poll || poll.status !== 'active'\">\r\n          <hr />\r\n          No active poll\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-body{display:flex;flex-direction:column;gap:10px}.previous-polls,.create-poll,.current-poll{overflow-y:auto;max-height:20%}.poll{margin-bottom:15px}.close-button{border:none;background:none;cursor:pointer}.form-group{max-width:80%;overflow-x:auto}textarea.form-control{resize:none}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$2.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: i2$2.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: PollModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-poll-modal', imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\">\r\n      <h2>Polls</h2>\r\n      <button (click)=\"onClose()\" class=\"close-button\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <!-- Previous Polls Section -->\r\n      <div *ngIf=\"islevel === '2'\">\r\n        <div class=\"previous-polls\">\r\n          <h5>Previous Polls</h5>\r\n          <div *ngIf=\"polls.length === 0\">No polls available</div>\r\n\r\n          <!-- Using ng-container to avoid multiple structural directives on the same element -->\r\n          <ng-container *ngFor=\"let polled of polls\">\r\n            <div\r\n              *ngIf=\"!poll || polled.id !== poll.id || poll.status !== 'active'\"\r\n              class=\"poll\"\r\n            >\r\n              <h6>Question:</h6>\r\n              <textarea\r\n                class=\"form-control\"\r\n                rows=\"3\"\r\n                [disabled]=\"true\"\r\n                [value]=\"polled.question\"\r\n              ></textarea>\r\n              <br />\r\n              <h6>Options:</h6>\r\n              <div *ngFor=\"let option of polled.options; let i = index\">\r\n                {{ option }}: {{ polled.votes[i] }} votes ({{\r\n                  calculatePercentage(polled.votes, i)\r\n                }}%)\r\n              </div>\r\n              <!-- End Poll Button (if poll is active) -->\r\n              <button\r\n                *ngIf=\"polled.status === 'active'\"\r\n                class=\"btn btn-danger\"\r\n                (click)=\"handledEndPoll(polled.id)\"\r\n              >\r\n                End Poll\r\n              </button>\r\n            </div>\r\n          </ng-container>\r\n        </div>\r\n        <hr />\r\n\r\n        <!-- Create Poll Section -->\r\n        <div class=\"create-poll\">\r\n          <h5>Create a New Poll</h5>\r\n          <form (ngSubmit)=\"validateAndCreatePoll()\">\r\n            <div class=\"form-group\">\r\n              <label for=\"pollQuestion\">Poll Question</label>\r\n              <textarea\r\n                class=\"form-control\"\r\n                id=\"pollQuestion\"\r\n                rows=\"3\"\r\n                maxLength=\"300\"\r\n                required\r\n                [(ngModel)]=\"newPoll.question\"\r\n                name=\"question\"\r\n              ></textarea>\r\n            </div>\r\n            <div class=\"form-group\">\r\n              <label for=\"pollType\">Select Poll Answer Type</label>\r\n              <select\r\n                class=\"form-control\"\r\n                id=\"pollType\"\r\n                required\r\n                (change)=\"handlePollTypeChange($event)\"\r\n                [(ngModel)]=\"newPoll.type\"\r\n                name=\"type\"\r\n              >\r\n                <option value=\"\">Choose...</option>\r\n                <option value=\"trueFalse\">True/False</option>\r\n                <option value=\"yesNo\">Yes/No</option>\r\n                <option value=\"custom\">Custom</option>\r\n              </select>\r\n            </div>\r\n\r\n            <!-- Render Poll Options -->\r\n            <div\r\n              *ngIf=\"newPoll.type === 'trueFalse' || newPoll.type === 'yesNo'\"\r\n            >\r\n              <div\r\n                *ngFor=\"let option of newPoll.options; let i = index\"\r\n                class=\"form-check\"\r\n              >\r\n                <input\r\n                  class=\"form-check-input\"\r\n                  type=\"radio\"\r\n                  name=\"pollOption\"\r\n                  [value]=\"option.toLowerCase()\"\r\n                  [id]=\"'option' + option\"\r\n                />\r\n                <label class=\"form-check-label\" [for]=\"'option' + option\">{{\r\n                  option\r\n                }}</label>\r\n              </div>\r\n            </div>\r\n            <div *ngIf=\"newPoll.type === 'custom'\">\r\n              <div\r\n                *ngFor=\"let option of newPoll.options; let i = index\"\r\n                class=\"form-group\"\r\n              >\r\n                <input\r\n                  type=\"text\"\r\n                  class=\"form-control\"\r\n                  placeholder=\"Option {{ i + 1 }}\"\r\n                  maxLength=\"50\"\r\n                  [(ngModel)]=\"newPoll.options[i]\"\r\n                  name=\"option{{ i }}\"\r\n                />\r\n              </div>\r\n            </div>\r\n            <button type=\"submit\" class=\"btn btn-primary\">Create Poll</button>\r\n          </form>\r\n        </div>\r\n        <hr />\r\n      </div>\r\n\r\n      <!-- Current Poll Section -->\r\n      <div class=\"current-poll\">\r\n        <h5>Current Poll</h5>\r\n        <div *ngIf=\"poll && poll.status === 'active'\">\r\n          <h6>Question:</h6>\r\n          <textarea\r\n            class=\"form-control\"\r\n            rows=\"3\"\r\n            [disabled]=\"true\"\r\n            [value]=\"poll.question\"\r\n          ></textarea>\r\n          <h6>Options:</h6>\r\n          <div\r\n            *ngFor=\"let option of poll.options; let i = index\"\r\n            class=\"form-check\"\r\n          >\r\n            <input\r\n              class=\"form-check-input\"\r\n              type=\"radio\"\r\n              name=\"pollOption\"\r\n              [value]=\"i\"\r\n              id=\"pollOption{{ i }}\"\r\n              [checked]=\"poll.voters?.[member] === i\"\r\n              (change)=\"handledVotePoll(poll.id, i)\"\r\n            />\r\n            <label class=\"form-check-label\" [for]=\"'pollOption' + i\">{{\r\n              option\r\n            }}</label>\r\n          </div>\r\n          <button\r\n            *ngIf=\"poll.status === 'active' && islevel === '2'\"\r\n            class=\"btn btn-danger\"\r\n            (click)=\"handledEndPoll(poll.id)\"\r\n          >\r\n            End Poll\r\n          </button>\r\n        </div>\r\n        <div *ngIf=\"!poll || poll.status !== 'active'\">\r\n          <hr />\r\n          No active poll\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-body{display:flex;flex-direction:column;gap:10px}.previous-polls,.create-poll,.current-poll{overflow-y:auto;max-height:20%}.poll{margin-bottom:15px}.close-button{border:none;background:none;cursor:pointer}.form-group{max-width:80%;overflow-x:auto}textarea.form-control{resize:none}\n"] }]
        }], propDecorators: { isPollModalVisible: [{
                type: Input
            }], onClose: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], member: [{
                type: Input
            }], islevel: [{
                type: Input
            }], polls: [{
                type: Input
            }], poll: [{
                type: Input
            }], socket: [{
                type: Input
            }], roomName: [{
                type: Input
            }], showAlert: [{
                type: Input
            }], updateIsPollModalVisible: [{
                type: Input
            }], handleCreatePoll: [{
                type: Input
            }], handleEndPoll: [{
                type: Input
            }], handleVotePoll: [{
                type: Input
            }] } });

/**
 * @component StandardPanelComponent
 * @description This component represents a standard panel for recording options.
 * It allows users to select media, audio, and video options, as well as toggle HLS recording.
 *
 * @selector app-standard-panel-component
 * @standalone true
 * @templateUrl ./standard-panel-component.component.html
 * @styleUrls ./standard-panel-component.component.css
 * @imports [CommonModule, FormsModule]
 *
 * @input {StandardPanelParameters} parameters - The parameters for the standard panel component.
 *
 * @property {string} selectedRecordingMediaOptions - The selected media options for recording.
 * @property {string} selectedRecordingAudioOptions - The selected audio options for recording.
 * @property {string} selectedRecordingVideoOptions - The selected video options for recording.
 * @property {boolean} selectedRecordingAddHLS - The flag indicating whether HLS recording is enabled.
 *
 * @method ngOnInit - Initializes the component and sets the initial values for recording options.
 * @method ngOnChanges - Handles changes to the input parameters and updates the recording options accordingly.
 * @method handleMediaOptionsChange - Handles changes to the media options and updates the parameters.
 * @method handleAudioOptionsChange - Handles changes to the audio options and updates the parameters.
 * @method handleVideoOptionsChange - Handles changes to the video options and updates the parameters.
 * @method handleAddHLSChange - Handles changes to the HLS recording option and updates the parameters.
 *
 * @param {SimpleChanges} changes - The changes to the input properties.
 * @param {any} event - The event object from the change event.
 *
 * @example
 * ```html
 * <app-standard-panel-component [parameters]="standardPanelParameters"></app-standard-panel-component>
 * ```
 */
class StandardPanelComponent {
    parameters = {};
    selectedRecordingMediaOptions;
    selectedRecordingAudioOptions;
    selectedRecordingVideoOptions;
    selectedRecordingAddHLS;
    ngOnInit() {
        this.selectedRecordingMediaOptions = this.parameters.recordingMediaOptions;
        this.selectedRecordingAudioOptions = this.parameters.recordingAudioOptions;
        this.selectedRecordingVideoOptions = this.parameters.recordingVideoOptions;
        this.selectedRecordingAddHLS = this.parameters.recordingAddHLS;
    }
    ngOnChanges(changes) {
        if (changes['parameters']) {
            this.parameters = changes['parameters'].currentValue;
            this.selectedRecordingMediaOptions = this.parameters.recordingMediaOptions;
            this.selectedRecordingAudioOptions = this.parameters.recordingAudioOptions;
            this.selectedRecordingVideoOptions = this.parameters.recordingVideoOptions;
            this.selectedRecordingAddHLS = this.parameters.recordingAddHLS;
        }
    }
    handleMediaOptionsChange(event) {
        const value = event.target.value;
        this.selectedRecordingMediaOptions = value;
        this.parameters.updateRecordingMediaOptions(value);
    }
    handleAudioOptionsChange(event) {
        const value = event.target.value;
        this.selectedRecordingAudioOptions = value;
        this.parameters.updateRecordingAudioOptions(value);
    }
    handleVideoOptionsChange(event) {
        const value = event.target.value;
        this.selectedRecordingVideoOptions = value;
        this.parameters.updateRecordingVideoOptions(value);
    }
    handleAddHLSChange(event) {
        const value = event.target.value === 'true';
        this.selectedRecordingAddHLS = value;
        this.parameters.updateRecordingAddHLS(value);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StandardPanelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: StandardPanelComponent, isStandalone: true, selector: "app-standard-panel-component", inputs: { parameters: "parameters" }, usesOnChanges: true, ngImport: i0, template: "<div>\r\n  <!-- Media Options -->\r\n  <div>\r\n    <label style=\"margin-right:10px; font-weight: bold;\">Media Options:</label>\r\n    <select [(ngModel)]=\"selectedRecordingMediaOptions\" (change)=\"handleMediaOptionsChange($event)\">\r\n      <option value=\"video\">Record Video</option>\r\n      <option value=\"audio\">Record Audio Only</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Specific Audios -->\r\n  <div *ngIf=\"parameters.eventType !== 'broadcast'\">\r\n    <div>\r\n      <label style=\"margin-right:10px; font-weight: bold;\">Specific Audios:</label>\r\n      <select [(ngModel)]=\"selectedRecordingAudioOptions\" (change)=\"handleAudioOptionsChange($event)\">\r\n        <option value=\"all\">Add All</option>\r\n        <option value=\"onScreen\">Add All On Screen</option>\r\n        <option value=\"host\">Add Host Only</option>\r\n      </select>\r\n    </div>\r\n    <hr />\r\n\r\n    <!-- Specific Videos -->\r\n    <div id=\"conditionalConference\">\r\n      <label style=\"margin-right:10px; font-weight: bold;\">Specific Videos:</label>\r\n      <select [(ngModel)]=\"selectedRecordingVideoOptions\" (change)=\"handleVideoOptionsChange($event)\">\r\n        <option value=\"all\">Add All</option>\r\n        <option value=\"mainScreen\">Big Screen Only (includes screenshare)</option>\r\n      </select>\r\n    </div>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Add HLS -->\r\n  <div id=\"addHLSPart\">\r\n    <label style=\"margin-right:10px; font-weight: bold;\">Add HLS:</label>\r\n    <select [(ngModel)]=\"selectedRecordingAddHLS\" (change)=\"handleAddHLSChange($event)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: StandardPanelComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-standard-panel-component', imports: [CommonModule, FormsModule], template: "<div>\r\n  <!-- Media Options -->\r\n  <div>\r\n    <label style=\"margin-right:10px; font-weight: bold;\">Media Options:</label>\r\n    <select [(ngModel)]=\"selectedRecordingMediaOptions\" (change)=\"handleMediaOptionsChange($event)\">\r\n      <option value=\"video\">Record Video</option>\r\n      <option value=\"audio\">Record Audio Only</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Specific Audios -->\r\n  <div *ngIf=\"parameters.eventType !== 'broadcast'\">\r\n    <div>\r\n      <label style=\"margin-right:10px; font-weight: bold;\">Specific Audios:</label>\r\n      <select [(ngModel)]=\"selectedRecordingAudioOptions\" (change)=\"handleAudioOptionsChange($event)\">\r\n        <option value=\"all\">Add All</option>\r\n        <option value=\"onScreen\">Add All On Screen</option>\r\n        <option value=\"host\">Add Host Only</option>\r\n      </select>\r\n    </div>\r\n    <hr />\r\n\r\n    <!-- Specific Videos -->\r\n    <div id=\"conditionalConference\">\r\n      <label style=\"margin-right:10px; font-weight: bold;\">Specific Videos:</label>\r\n      <select [(ngModel)]=\"selectedRecordingVideoOptions\" (change)=\"handleVideoOptionsChange($event)\">\r\n        <option value=\"all\">Add All</option>\r\n        <option value=\"mainScreen\">Big Screen Only (includes screenshare)</option>\r\n      </select>\r\n    </div>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Add HLS -->\r\n  <div id=\"addHLSPart\">\r\n    <label style=\"margin-right:10px; font-weight: bold;\">Add HLS:</label>\r\n    <select [(ngModel)]=\"selectedRecordingAddHLS\" (change)=\"handleAddHLSChange($event)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n</div>\r\n" }]
        }], propDecorators: { parameters: [{
                type: Input
            }] } });

/**
 * Component for configuring advanced recording options in a MediaSFU session.
 *
 * @component
 * @selector app-advanced-panel-component
 * @standalone true
 * @templateUrl ./advanced-panel-component.component.html
 * @styleUrls ['./advanced-panel-component.component.css']
 * @imports [CommonModule, FormsModule]
 *
 * @example
 * ```html
 * <app-advanced-panel-component [parameters]="advancedPanelOptions"></app-advanced-panel-component>
 * ```
 */
class AdvancedPanelComponent {
    parameters = {};
    selectedOrientationVideo;
    selectedRecordingNameTags;
    selectedRecordingVideoType;
    selectedRecordingDisplayType;
    showBackgroundColorModal = false;
    showNameTagsColorModal = false;
    selectedColorType = '';
    recordingText;
    customText;
    recordingPosition;
    ngOnInit() {
        this.selectedOrientationVideo = this.parameters?.recordingOrientationVideo ?? '';
        this.selectedRecordingNameTags = this.parameters?.recordingNameTags ?? false;
        this.selectedRecordingVideoType = this.parameters?.recordingVideoType ?? '';
        this.selectedRecordingDisplayType = this.parameters?.recordingDisplayType ?? 'media';
        this.recordingText = this.parameters?.recordingAddText ?? false;
        this.customText = this.parameters?.recordingCustomText ?? '';
        this.recordingPosition = this.parameters?.recordingCustomTextPosition ?? '';
    }
    ngOnChanges(changes) {
        if (changes['parameters']) {
            this.parameters = changes['parameters'].currentValue;
            this.selectedOrientationVideo = this.parameters.recordingOrientationVideo;
            this.selectedRecordingNameTags = this.parameters.recordingNameTags;
            this.selectedRecordingVideoType = this.parameters.recordingVideoType;
            this.selectedRecordingDisplayType = this.parameters.recordingDisplayType;
            this.recordingText = this.parameters.recordingAddText;
            this.customText = this.parameters.recordingCustomText;
            this.recordingPosition = this.parameters.recordingCustomTextPosition;
        }
    }
    validateTextInput(input) {
        const regex = /^[a-zA-Z0-9\s]{1,40}$/;
        return regex.test(input);
    }
    handleTextChange(value) {
        this.recordingText = value;
        this.parameters.updateRecordingAddText(value);
    }
    onChangeTextHandler(text) {
        if (text && text.length > 0 && !this.validateTextInput(text)) {
            return;
        }
        this.parameters.updateRecordingCustomText(text);
        this.customText = text;
    }
    handleColorChange(selectedColor, event) {
        const input = event.target;
        const color = input.value;
        if (selectedColor === 'backgroundColor') {
            this.parameters.updateRecordingBackgroundColor(color);
        }
        else if (selectedColor === 'customTextColor') {
            this.parameters.updateRecordingCustomTextColor(color);
        }
        else if (selectedColor === 'nameTagsColor') {
            this.parameters.updateRecordingNameTagsColor(color);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AdvancedPanelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: AdvancedPanelComponent, isStandalone: true, selector: "app-advanced-panel-component", inputs: { parameters: "parameters" }, usesOnChanges: true, ngImport: i0, template: "<div>\r\n  <!-- Video Type -->\r\n  <div>\r\n    <label class=\"label\">Video Type:</label>\r\n    <select [(ngModel)]=\"selectedRecordingVideoType\" (change)=\"parameters.updateRecordingVideoType(selectedRecordingVideoType)\">\r\n      <option value=\"fullDisplay\">Full Display (no background)</option>\r\n      <option value=\"bestDisplay\">Full Video</option>\r\n      <option value=\"all\">All</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Display Type -->\r\n  <div *ngIf=\"parameters.eventType !== 'broadcast'\">\r\n    <label class=\"label\">Display Type:</label>\r\n    <select [(ngModel)]=\"selectedRecordingDisplayType\" (change)=\"parameters.updateRecordingDisplayType(selectedRecordingDisplayType)\">\r\n      <option value=\"video\">Only Video Participants</option>\r\n      <option value=\"videoOpt\">Only Video Participants (optimized)</option>\r\n      <option value=\"media\">Participants with media</option>\r\n      <option value=\"all\">All Participants</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Background Color -->\r\n  <div>\r\n    <label class=\"label\">Background Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingBackgroundColor}\">\r\n      {{ parameters.recordingBackgroundColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingBackgroundColor\" (change)=\"handleColorChange('backgroundColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Add Text -->\r\n  <div>\r\n    <label class=\"label\">Add Text:</label>\r\n    <select [(ngModel)]=\"recordingText\" (change)=\"handleTextChange(recordingText)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Custom Text -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text:</label>\r\n    <input type=\"text\" [(ngModel)]=\"customText\" (input)=\"onChangeTextHandler(customText)\" />\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Custom Text Position -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text Position:</label>\r\n    <select [(ngModel)]=\"recordingPosition\" (change)=\"parameters.updateRecordingCustomTextPosition(recordingPosition)\">\r\n      <option value=\"top\">Top</option>\r\n      <option value=\"middle\">Middle</option>\r\n      <option value=\"bottom\">Bottom</option>\r\n    </select>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Custom Text Color -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingCustomTextColor}\">\r\n      {{ parameters.recordingCustomTextColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingCustomTextColor\" (change)=\"handleColorChange('customTextColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Add Name Tags -->\r\n  <div>\r\n    <label class=\"label\">Add Name Tags:</label>\r\n    <select [(ngModel)]=\"selectedRecordingNameTags\" (change)=\"parameters.updateRecordingNameTags(selectedRecordingNameTags)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Name Tags Color -->\r\n  <div>\r\n    <label class=\"label\">Name Tags Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingNameTagsColor}\">\r\n      {{ parameters.recordingNameTagsColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingNameTagsColor\" (change)=\"handleColorChange('nameTagsColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Orientation (Video) -->\r\n  <div>\r\n    <label class=\"label\">Orientation (Video):</label>\r\n    <select [(ngModel)]=\"selectedOrientationVideo\" (change)=\"parameters.updateRecordingOrientationVideo(selectedOrientationVideo)\">\r\n      <option value=\"landscape\">Landscape</option>\r\n      <option value=\"portrait\">Portrait</option>\r\n      <option value=\"all\">All</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: AdvancedPanelComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-advanced-panel-component', imports: [CommonModule, FormsModule], template: "<div>\r\n  <!-- Video Type -->\r\n  <div>\r\n    <label class=\"label\">Video Type:</label>\r\n    <select [(ngModel)]=\"selectedRecordingVideoType\" (change)=\"parameters.updateRecordingVideoType(selectedRecordingVideoType)\">\r\n      <option value=\"fullDisplay\">Full Display (no background)</option>\r\n      <option value=\"bestDisplay\">Full Video</option>\r\n      <option value=\"all\">All</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Display Type -->\r\n  <div *ngIf=\"parameters.eventType !== 'broadcast'\">\r\n    <label class=\"label\">Display Type:</label>\r\n    <select [(ngModel)]=\"selectedRecordingDisplayType\" (change)=\"parameters.updateRecordingDisplayType(selectedRecordingDisplayType)\">\r\n      <option value=\"video\">Only Video Participants</option>\r\n      <option value=\"videoOpt\">Only Video Participants (optimized)</option>\r\n      <option value=\"media\">Participants with media</option>\r\n      <option value=\"all\">All Participants</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Background Color -->\r\n  <div>\r\n    <label class=\"label\">Background Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingBackgroundColor}\">\r\n      {{ parameters.recordingBackgroundColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingBackgroundColor\" (change)=\"handleColorChange('backgroundColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Add Text -->\r\n  <div>\r\n    <label class=\"label\">Add Text:</label>\r\n    <select [(ngModel)]=\"recordingText\" (change)=\"handleTextChange(recordingText)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Custom Text -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text:</label>\r\n    <input type=\"text\" [(ngModel)]=\"customText\" (input)=\"onChangeTextHandler(customText)\" />\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Custom Text Position -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text Position:</label>\r\n    <select [(ngModel)]=\"recordingPosition\" (change)=\"parameters.updateRecordingCustomTextPosition(recordingPosition)\">\r\n      <option value=\"top\">Top</option>\r\n      <option value=\"middle\">Middle</option>\r\n      <option value=\"bottom\">Bottom</option>\r\n    </select>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Custom Text Color -->\r\n  <div *ngIf=\"recordingText\">\r\n    <label class=\"label\">Custom Text Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingCustomTextColor}\">\r\n      {{ parameters.recordingCustomTextColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingCustomTextColor\" (change)=\"handleColorChange('customTextColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n    <hr />\r\n  </div>\r\n\r\n  <!-- Add Name Tags -->\r\n  <div>\r\n    <label class=\"label\">Add Name Tags:</label>\r\n    <select [(ngModel)]=\"selectedRecordingNameTags\" (change)=\"parameters.updateRecordingNameTags(selectedRecordingNameTags)\">\r\n      <option [ngValue]=\"true\">True</option>\r\n      <option [ngValue]=\"false\">False</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Name Tags Color -->\r\n  <div>\r\n    <label class=\"label\">Name Tags Color:</label>\r\n    <div class=\"color-preview\" [ngStyle]=\"{'background-color': parameters.recordingNameTagsColor}\">\r\n      {{ parameters.recordingNameTagsColor }}\r\n    </div>\r\n    <input type=\"color\" [(ngModel)]=\"parameters.recordingNameTagsColor\" (change)=\"handleColorChange('nameTagsColor', $event)\" />\r\n    <span class=\"label\">Click to select color</span>\r\n  </div>\r\n  <hr />\r\n\r\n  <!-- Orientation (Video) -->\r\n  <div>\r\n    <label class=\"label\">Orientation (Video):</label>\r\n    <select [(ngModel)]=\"selectedOrientationVideo\" (change)=\"parameters.updateRecordingOrientationVideo(selectedOrientationVideo)\">\r\n      <option value=\"landscape\">Landscape</option>\r\n      <option value=\"portrait\">Portrait</option>\r\n      <option value=\"all\">All</option>\r\n    </select>\r\n  </div>\r\n  <hr />\r\n</div>\r\n" }]
        }], propDecorators: { parameters: [{
                type: Input
            }] } });

/**
 * Component representing a recording modal.
 *
 * @selector app-recording-modal
 * @standalone true
 * @imports CommonModule, FontAwesomeModule, StandardPanelComponent, AdvancedPanelComponent
 * @templateUrl ./recording-modal.component.html
 * @styleUrls ./recording-modal.component.css
 *
 * @class RecordingModal
 * @implements OnChanges
 *
 * @property {boolean} isRecordingModalVisible - Determines if the recording modal is visible.
 * @property {() => void} onClose - Callback function to close the modal.
 * @property {string} backgroundColor - Background color of the modal.
 * @property {string} position - Position of the modal on the screen.
 * @property {(options: ConfirmRecordingOptions) => void} confirmRecording - Callback function to confirm recording.
 * @property {(options: StartRecordingOptions) => void} startRecording - Callback function to start recording.
 * @property {RecordingModalParameters} parameters - Parameters for the recording modal.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for times (close).
 * @property {IconDefinition} faCheck - FontAwesome icon for check (confirm).
 * @property {IconDefinition} faPlay - FontAwesome icon for play (start).
 *
 * @method modalContainerStyle - Returns the style object for the modal container.
 * @method modalContentStyle - Returns the style object for the modal content.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property of a directive changes.
 * @method confirm - Calls the confirmRecording callback with the current parameters.
 * @method start - Calls the startRecording callback with the current parameters.
 * @example
 * ```html
 * <app-recording-modal
 *   [isRecordingModalVisible]="true"
 *   [onClose]="closeRecordingModal"
 *   [backgroundColor]="'#83c0e9'"
 *   [position]="'bottomRight'"
 *   [confirmRecording]="confirmRecording"
 *   [startRecording]="startRecording"
 *   [parameters]="recordingModalParams"
 * ></app-recording-modal>
 * ```
 */
class RecordingModal {
    isRecordingModalVisible = false;
    onClose;
    backgroundColor = '#83c0e9';
    position = 'bottomRight';
    confirmRecording;
    startRecording;
    parameters = {};
    faTimes = faTimes;
    faCheck = faCheck;
    faPlay = faPlay;
    get modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isRecordingModalVisible ? 'block' : 'none',
            zIndex: 999,
        };
    }
    get modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        return {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxHeight: '85%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    ngOnChanges(changes) {
        if (changes['isRecordingModalVisible']) {
            if (this.parameters) {
                this.parameters = this.parameters.getUpdatedAllParams();
            }
        }
    }
    confirm() {
        this.confirmRecording({
            parameters: { ...this.parameters },
        });
    }
    start() {
        this.startRecording({
            parameters: { ...this.parameters },
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordingModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: RecordingModal, isStandalone: true, selector: "app-recording-modal", inputs: { isRecordingModalVisible: "isRecordingModalVisible", onClose: "onClose", backgroundColor: "backgroundColor", position: "position", confirmRecording: "confirmRecording", startRecording: "startRecording", parameters: "parameters" }, usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div style=\"display: flex; flex-direction: column;\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">\r\n          Recording Settings\r\n        </h2>\r\n        <button (click)=\"onClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n      <div style=\"flex: 1;\">\r\n        <div style=\"overflow-y: auto; max-height: calc(100% - 120px); padding: 0;\">\r\n          <div style=\"margin: 0; padding: 0;\">\r\n            <app-standard-panel-component [parameters]=\"parameters\"></app-standard-panel-component>\r\n            <app-advanced-panel-component [parameters]=\"parameters\"></app-advanced-panel-component>\r\n          </div>\r\n        </div>\r\n        <div style=\"height: 1px; background-color: white; \"></div>\r\n        <div style=\"display: flex; justify-content: space-between; margin-top: 20px;\">\r\n          <button\r\n            (click)=\"confirm()\"\r\n            style=\"flex: 1; padding: 5px; border-radius: 5px; justify-content: center; align-items: center; margin: 0 10px; background: #4CAF50; cursor: pointer;\">\r\n            <span style=\"color: black; font-size: 14px;\">Confirm</span>\r\n          </button>\r\n          <button *ngIf=\"!parameters.recordPaused\"\r\n            (click)=\"start()\"\r\n            style=\"flex: 1; padding: 5px; border-radius: 5px; justify-content: center; align-items: center; margin: 0 10px; background: #f44336; cursor: pointer;\">\r\n            <span style=\"color: black; font-size: 14px;\">Start <fa-icon [icon]=\"faPlay\"></fa-icon></span>\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: StandardPanelComponent, selector: "app-standard-panel-component", inputs: ["parameters"] }, { kind: "component", type: AdvancedPanelComponent, selector: "app-advanced-panel-component", inputs: ["parameters"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordingModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-recording-modal', imports: [CommonModule, FontAwesomeModule, StandardPanelComponent, AdvancedPanelComponent], template: "<div [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div style=\"display: flex; flex-direction: column;\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">\r\n          Recording Settings\r\n        </h2>\r\n        <button (click)=\"onClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr style=\"height: 1px; background-color: black; margin: 5px 0;\" />\r\n      <div style=\"flex: 1;\">\r\n        <div style=\"overflow-y: auto; max-height: calc(100% - 120px); padding: 0;\">\r\n          <div style=\"margin: 0; padding: 0;\">\r\n            <app-standard-panel-component [parameters]=\"parameters\"></app-standard-panel-component>\r\n            <app-advanced-panel-component [parameters]=\"parameters\"></app-advanced-panel-component>\r\n          </div>\r\n        </div>\r\n        <div style=\"height: 1px; background-color: white; \"></div>\r\n        <div style=\"display: flex; justify-content: space-between; margin-top: 20px;\">\r\n          <button\r\n            (click)=\"confirm()\"\r\n            style=\"flex: 1; padding: 5px; border-radius: 5px; justify-content: center; align-items: center; margin: 0 10px; background: #4CAF50; cursor: pointer;\">\r\n            <span style=\"color: black; font-size: 14px;\">Confirm</span>\r\n          </button>\r\n          <button *ngIf=\"!parameters.recordPaused\"\r\n            (click)=\"start()\"\r\n            style=\"flex: 1; padding: 5px; border-radius: 5px; justify-content: center; align-items: center; margin: 0 10px; background: #f44336; cursor: pointer;\">\r\n            <span style=\"color: black; font-size: 14px;\">Start <fa-icon [icon]=\"faPlay\"></fa-icon></span>\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n" }]
        }], propDecorators: { isRecordingModalVisible: [{
                type: Input
            }], onClose: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], position: [{
                type: Input
            }], confirmRecording: [{
                type: Input
            }], startRecording: [{
                type: Input
            }], parameters: [{
                type: Input
            }] } });

/**
 * @component RenderRequestComponent
 * @description Component to render and manage individual requests in a list. Each request can be responded to with specified actions (e.g., approve, deny).
 *
 * @selector app-render-request-component
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule]
 * @templateUrl ./render-request-component.component.html
 * @styleUrls ./render-request-component.component.css
 *
 * @example
 * ```html
 * <app-render-request-component
 *   [request]="request"
 *   [requestList]="requestList"
 *   [roomName]="roomName"
 *   [socket]="socket"
 *   [onRequestItemPress]="handleRequestPress"
 *   [updateRequestList]="updateRequestList">
 * </app-render-request-component>
 * ```
 */
class RenderRequestComponent {
    request = {};
    requestList = [];
    roomName;
    socket = {};
    onRequestItemPress;
    updateRequestList;
    faMicrophone = faMicrophone;
    faDesktop = faDesktop;
    faVideo = faVideo;
    faComments = faComments;
    faCheck = faCheck;
    faTimes = faTimes;
    keyMap = {
        'fa-microphone': this.faMicrophone,
        'fa-desktop': this.faDesktop,
        'fa-video': this.faVideo,
        'fa-comments': this.faComments,
    };
    getIcon(iconName) {
        return this.keyMap[iconName];
    }
    handleRequestAction = (action) => {
        this.onRequestItemPress({
            request: this.request,
            updateRequestList: this.updateRequestList,
            requestList: this.requestList,
            action: action,
            roomName: this.roomName,
            socket: this.socket,
        });
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RenderRequestComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: RenderRequestComponent, isStandalone: true, selector: "app-render-request-component", inputs: { request: "request", requestList: "requestList", roomName: "roomName", socket: "socket", onRequestItemPress: "onRequestItemPress", updateRequestList: "updateRequestList" }, ngImport: i0, template: "<div class=\"request-container\" *ngIf=\"request\">\r\n  <div class=\"request-name\">{{ request.name }}</div>\r\n  <div class=\"request-icon\">\r\n    <fa-icon [icon]=\"getIcon(request.icon)\" size=\"lg\" color=\"black\"></fa-icon>\r\n  </div>\r\n  <div class=\"request-action accept\">\r\n    <button (click)=\"handleRequestAction('accepted')\">\r\n      <fa-icon [icon]=\"faCheck\" size=\"lg\" style=\"color: green;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div class=\"request-action reject\">\r\n    <button (click)=\"handleRequestAction('rejected')\">\r\n      <fa-icon [icon]=\"faTimes\" size=\"lg\" style=\"color: red;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".request-container{display:flex;flex-direction:row;align-items:center;margin:10px 0;padding-bottom:5px}.request-name{flex:5}.request-icon,.request-action{flex:2;display:flex;justify-content:center;align-items:center}.request-action{padding-right:10px}.request-action.accept,.request-action.reject{margin-right:10px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RenderRequestComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-render-request-component', imports: [CommonModule, FontAwesomeModule], template: "<div class=\"request-container\" *ngIf=\"request\">\r\n  <div class=\"request-name\">{{ request.name }}</div>\r\n  <div class=\"request-icon\">\r\n    <fa-icon [icon]=\"getIcon(request.icon)\" size=\"lg\" color=\"black\"></fa-icon>\r\n  </div>\r\n  <div class=\"request-action accept\">\r\n    <button (click)=\"handleRequestAction('accepted')\">\r\n      <fa-icon [icon]=\"faCheck\" size=\"lg\" style=\"color: green;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n  <div class=\"request-action reject\">\r\n    <button (click)=\"handleRequestAction('rejected')\">\r\n      <fa-icon [icon]=\"faTimes\" size=\"lg\" style=\"color: red;\"></fa-icon>\r\n    </button>\r\n  </div>\r\n</div>\r\n", styles: [".request-container{display:flex;flex-direction:row;align-items:center;margin:10px 0;padding-bottom:5px}.request-name{flex:5}.request-icon,.request-action{flex:2;display:flex;justify-content:center;align-items:center}.request-action{padding-right:10px}.request-action.accept,.request-action.reject{margin-right:10px}\n"] }]
        }], propDecorators: { request: [{
                type: Input
            }], requestList: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], onRequestItemPress: [{
                type: Input
            }], updateRequestList: [{
                type: Input
            }] } });

/**
 * @component RequestsModal
 * @description A modal component to display and manage requests.
 *
 * @selector app-requests-modal
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule, RenderRequestComponent]
 * @templateUrl ./requests-modal.component.html
 * @styleUrls ./requests-modal.component.css
 *
 * @property {boolean} isRequestsModalVisible - Determines if the requests modal is visible.
 * @property {number} requestCounter - Counter for the number of requests.
 * @property {Request[]} requestList - List of requests.
 * @property {string} roomName - Name of the room.
 * @property {Socket} socket - Socket instance for communication.
 * @property {string} backgroundColor - Background color of the modal.
 * @property {string} position - Position of the modal.
 * @property {any} parameters - Additional parameters for the modal.
 * @property {Function} onRequestClose - Callback function when the modal is closed.
 * @property {Function} onRequestFilterChange - Callback function when the request filter changes.
 * @property {Function} onRequestItemPress - Callback function when a request item is pressed.
 * @property {Function} updateRequestList - Function to update the request list.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for closing the modal.
 * @property {any[]} requestList_s - Filtered list of requests.
 * @property {number} requestCounter_s - Counter for the filtered list of requests.
 * @property {boolean} reRender - Flag to trigger re-rendering.
 *
 * @constructor
 * @param {RespondToRequests} respondToRequestsService - Service to handle request responses.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes.
 * @param {SimpleChanges} changes - Object of current and previous property values.
 *
 * @method updateRequests - Updates the request list and counter based on the current parameters.
 * @method handleModalClose - Handles the modal close action.
 * @method handleFilterChange - Handles the filter change event.
 * @param {Event} event - The filter change event.
 * @example
 * ```html
 * <app-requests-modal
 *   [isRequestsModalVisible]="isModalVisible"
 *   [requestCounter]="requestCounter"
 *   [requestList]="requests"
 *   [roomName]="roomName"
 *   [socket]="socket"
 *   [backgroundColor]="'#83c0e9'"
 *   [position]="'topRight'"
 *   [parameters]="requestParams"
 *   (onRequestClose)="handleModalClose()"
 *   (onRequestFilterChange)="handleFilterChange($event)"
 *   (onRequestItemPress)="handleRequestPress($event)"
 *   [updateRequestList]="updateRequestList">
 * </app-requests-modal>
 * ```
 */
class RequestsModal {
    respondToRequestsService;
    isRequestsModalVisible = false;
    requestCounter = 0;
    requestList = [];
    roomName;
    socket = {};
    backgroundColor = '#83c0e9';
    position = 'topRight';
    parameters;
    onRequestClose;
    onRequestFilterChange;
    onRequestItemPress;
    updateRequestList;
    faTimes = faTimes;
    requestList_s = [];
    requestCounter_s = 0;
    reRender = false;
    constructor(respondToRequestsService) {
        this.respondToRequestsService = respondToRequestsService;
    }
    ngOnInit() {
        if (!this.onRequestItemPress) {
            this.onRequestItemPress = (params) => this.respondToRequestsService.respondToRequests(params);
        }
    }
    ngOnChanges(changes) {
        if (changes['requestList'] || changes['reRender'] || changes['requestCounter']) {
            this.updateRequests();
        }
        if (changes['isRequestsModalVisible'] && this.isRequestsModalVisible) {
            this.parameters = this.parameters.getUpdatedAllParams();
            this.updateRequests();
        }
    }
    updateRequests() {
        this.parameters = this.parameters.getUpdatedAllParams();
        this.requestList_s = this.parameters.filteredRequestList || [];
        this.requestCounter_s = this.parameters.filteredRequestList.length;
    }
    handleModalClose() {
        this.onRequestClose();
    }
    handleFilterChange(event) {
        const input = event.target;
        this.onRequestFilterChange(input.value);
        this.parameters = this.parameters.getUpdatedAllParams();
        this.reRender = !this.reRender;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RequestsModal, deps: [{ token: RespondToRequests }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: RequestsModal, isStandalone: true, selector: "app-requests-modal", inputs: { isRequestsModalVisible: "isRequestsModalVisible", requestCounter: "requestCounter", requestList: "requestList", roomName: "roomName", socket: "socket", backgroundColor: "backgroundColor", position: "position", parameters: "parameters", onRequestClose: "onRequestClose", onRequestFilterChange: "onRequestFilterChange", onRequestItemPress: "onRequestItemPress", updateRequestList: "updateRequestList" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isRequestsModalVisible\" class=\"modal-container\" [ngStyle]=\"{'background-color': 'rgba(0, 0, 0, 0.5)'}\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{'background-color': backgroundColor, 'top': position.includes('top') ? '10px' : 'auto', 'bottom': position.includes('bottom') ? '10px' : 'auto', 'left': position.includes('Left') ? '10px' : 'auto', 'right': position.includes('Right') ? '10px' : 'auto'}\">\r\n    <div class=\"modal-header\">\r\n      <div>\r\n        Requests <span class=\"badge text-dark\">{{ requestCounter_s }}</span>\r\n      </div>\r\n      <div class=\"close-icon\" (click)=\"handleModalClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"lg\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"separator\" />\r\n    <div class=\"modal-body\">\r\n      <input type=\"text\" class=\"filter-input\" placeholder=\"Search ...\" (input)=\"handleFilterChange($event)\">\r\n      <div class=\"request-list\">\r\n        <ng-container *ngFor=\"let requestItem of requestList_s; let i = index\">\r\n          <app-render-request-component\r\n            [request]=\"requestItem\"\r\n            [requestList]=\"requestList\"\r\n            [roomName]=\"roomName\"\r\n            [socket]=\"socket\"\r\n            [onRequestItemPress]=\"onRequestItemPress\"\r\n            [updateRequestList]=\"updateRequestList\">\r\n          </app-render-request-component>\r\n        </ng-container>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:350px;max-height:65%;overflow-y:auto;top:10px;right:10px}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.close-button{border:none;background:none;cursor:pointer}.separator{height:1px;background-color:#000;margin:5px 0}.modal-body{margin-bottom:20px}.filter-input{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}.request-list{max-height:calc(100% - 150px);overflow-y:auto}.icon{font-size:20px;color:#000}.text-dark{color:#000}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "component", type: RenderRequestComponent, selector: "app-render-request-component", inputs: ["request", "requestList", "roomName", "socket", "onRequestItemPress", "updateRequestList"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RequestsModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-requests-modal', imports: [CommonModule, FontAwesomeModule, RenderRequestComponent], template: "<div *ngIf=\"isRequestsModalVisible\" class=\"modal-container\" [ngStyle]=\"{'background-color': 'rgba(0, 0, 0, 0.5)'}\">\r\n  <div class=\"modal-content\" [ngStyle]=\"{'background-color': backgroundColor, 'top': position.includes('top') ? '10px' : 'auto', 'bottom': position.includes('bottom') ? '10px' : 'auto', 'left': position.includes('Left') ? '10px' : 'auto', 'right': position.includes('Right') ? '10px' : 'auto'}\">\r\n    <div class=\"modal-header\">\r\n      <div>\r\n        Requests <span class=\"badge text-dark\">{{ requestCounter_s }}</span>\r\n      </div>\r\n      <div class=\"close-icon\" (click)=\"handleModalClose()\">\r\n        <fa-icon [icon]=\"faTimes\" size=\"lg\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"separator\" />\r\n    <div class=\"modal-body\">\r\n      <input type=\"text\" class=\"filter-input\" placeholder=\"Search ...\" (input)=\"handleFilterChange($event)\">\r\n      <div class=\"request-list\">\r\n        <ng-container *ngFor=\"let requestItem of requestList_s; let i = index\">\r\n          <app-render-request-component\r\n            [request]=\"requestItem\"\r\n            [requestList]=\"requestList\"\r\n            [roomName]=\"roomName\"\r\n            [socket]=\"socket\"\r\n            [onRequestItemPress]=\"onRequestItemPress\"\r\n            [updateRequestList]=\"updateRequestList\">\r\n          </app-render-request-component>\r\n        </ng-container>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:350px;max-height:65%;overflow-y:auto;top:10px;right:10px}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.close-button{border:none;background:none;cursor:pointer}.separator{height:1px;background-color:#000;margin:5px 0}.modal-body{margin-bottom:20px}.filter-input{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}.request-list{max-height:calc(100% - 150px);overflow-y:auto}.icon{font-size:20px;color:#000}.text-dark{color:#000}\n"] }]
        }], ctorParameters: () => [{ type: RespondToRequests }], propDecorators: { isRequestsModalVisible: [{
                type: Input
            }], requestCounter: [{
                type: Input
            }], requestList: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], position: [{
                type: Input
            }], parameters: [{
                type: Input
            }], onRequestClose: [{
                type: Input
            }], onRequestFilterChange: [{
                type: Input
            }], onRequestItemPress: [{
                type: Input
            }], updateRequestList: [{
                type: Input
            }] } });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * @fileoverview Screenboard component for MediaSFU-Angular application.
 *
 * This component provides a screenboard with drawing, freehand, shape, and erase modes.
 * It supports mouse and touch events for drawing on a canvas.
 *
 * @component
 * @selector app-screenboard
 * @templateUrl ./screenboard.component.html
 * @styleUrls ./screenboard.component.css
 * @imports CommonModule, FontAwesomeModule, FormsModule
 *
 * @class Screenboard
 * @implements OnInit, AfterViewInit, OnDestroy, OnChanges
 *
 * @property {number} customWidth - Custom width for the screenboard.
 * @property {number} customHeight - Custom height for the screenboard.
 * @property {any} parameters - Parameters for the screenboard.
 * @property {boolean} showAspect - Flag to show aspect ratio.
 *
 * @property {ElementRef<HTMLCanvasElement>} canvasRef - Reference to the canvas element.
 * @property {ElementRef<HTMLDivElement>} screenboardRef - Reference to the screenboard div element.
 * @property {ElementRef<HTMLDivElement>} screenboardContentRef - Reference to the screenboard content div element.
 *
 * @property {IconDefinition} faChevronRight - FontAwesome icon for chevron right.
 * @property {IconDefinition} faChevronLeft - FontAwesome icon for chevron left.
 * @property {IconDefinition} faPencilAlt - FontAwesome icon for pencil.
 * @property {IconDefinition} faPaintBrush - FontAwesome icon for paint brush.
 * @property {IconDefinition} faShapes - FontAwesome icon for shapes.
 * @property {IconDefinition} faEraser - FontAwesome icon for eraser.
 * @property {IconDefinition} faSearch - FontAwesome icon for search.
 * @property {IconDefinition} faSearchPlus - FontAwesome icon for search plus.
 * @property {IconDefinition} faSearchMinus - FontAwesome icon for search minus.
 * @property {IconDefinition} faFont - FontAwesome icon for font.
 * @property {IconDefinition} faTextHeight - FontAwesome icon for text height.
 * @property {IconDefinition} faUndo - FontAwesome icon for undo.
 * @property {IconDefinition} faRedo - FontAwesome icon for redo.
 * @property {IconDefinition} faSave - FontAwesome icon for save.
 * @property {IconDefinition} faTrash - FontAwesome icon for trash.
 * @property {IconDefinition} faTimes - FontAwesome icon for times.
 * @property {IconDefinition} faMousePointer - FontAwesome icon for mouse pointer.
 *
 * @property {'draw' | 'freehand' | 'shape' | 'erase'} mode - Current drawing mode.
 * @property {boolean} isDrawing - Flag to indicate if drawing is in progress.
 * @property {number} startX - Starting X coordinate for drawing.
 * @property {number} startY - Starting Y coordinate for drawing.
 * @property {number} currentX - Current X coordinate for drawing.
 * @property {number} currentY - Current Y coordinate for drawing.
 * @property {Array<{ x: number; y: number; color: string; thickness: number }>} freehandDrawing - Array of points for freehand drawing.
 * @property {any[]} shapes - Array of shapes drawn on the canvas.
 * @property {number} eraserThickness - Thickness of the eraser.
 * @property {number} brushThickness - Thickness of the brush.
 * @property {number} lineThickness - Thickness of the line.
 * @property {string} lineType - Type of the line (solid, dashed, dotted, dashDot).
 * @property {string} color - Color for drawing.
 * @property {string} font - Font for text.
 * @property {number} fontSize - Font size for text.
 * @property {string | null} shape - Current shape being drawn.
 * @property {boolean} toolbarVisible - Flag to indicate if the toolbar is visible.
 * @property {string | null} dropdownOpen - ID of the currently open dropdown.
 * @property {HTMLCanvasElement} canvas - Canvas element.
 * @property {CanvasRenderingContext2D} ctx - Canvas rendering context.
 *
 * @constructor
 * @param {number} [injectedCustomWidth] - Injected custom width.
 * @param {number} [injectedCustomHeight] - Injected custom height.
 * @param {any} [injectedParameters] - Injected parameters.
 * @param {boolean} [injectedShowAspect] - Injected show aspect flag.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property changes.
 * @method ngAfterViewInit - Lifecycle hook that is called after the component's view has been fully initialized.
 * @method ngOnDestroy - Lifecycle hook that is called just before the component is destroyed.
 *
 * @method addListeners - Adds event listeners to the canvas.
 * @method handleMouseDown - Handles mouse down events.
 * @method handleMouseMove - Handles mouse move events.
 * @method handleMouseUp - Handles mouse up events.
 * @method handleTouchStart - Handles touch start events.
 * @method handleTouchMove - Handles touch move events.
 * @method handleTouchEnd - Handles touch end events.
 * @method handleClickOutside - Handles click events outside the component.
 * @method handleDropdownClick - Handles dropdown click events.
 * @method setDrawMode - Sets the drawing mode.
 * @method setFreehandMode - Sets the freehand mode.
 * @method setShapeMode - Sets the shape mode.
 * @method setEraseMode - Sets the erase mode.
 * @method startDrawing - Starts the drawing process.
 * @method draw - Draws on the canvas.
 * @method stopDrawing - Stops the drawing process.
 * @method drawLine - Draws a line on the canvas.
 * @method drawShapes - Draws all shapes on the canvas.
 * @method drawFreehand - Draws freehand on the canvas.
 * @method drawShape - Draws a shape on the canvas.
 * @method drawPolygon - Draws a polygon on the canvas.
 * @method removeShape - Removes the first shape from the shapes array.
 * @method erase - Erases part of the drawing.
 * @method isPointNearLine - Checks if a point is near a line.
 * @method toggleToolbar - Toggles the visibility of the toolbar.
 * @method toggleAnnotate - Toggles the annotation mode.
 *
 * @example
 * ```html
 * <app-screenboard
 *  [customWidth]="customWidth"
 * [customHeight]="customHeight"
 * [parameters]="screenboardParameters"
 * [showAspect]="showAspect"
 * ></app-screenboard>
 * ```
 */
class Screenboard {
    customWidth;
    customHeight;
    parameters = {};
    showAspect;
    canvasRef;
    screenboardRef;
    screenboardContentRef;
    faChevronRight = faChevronRight;
    faChevronLeft = faChevronLeft;
    faPencilAlt = faPencilAlt;
    faPaintBrush = faPaintBrush;
    faShapes = faShapes;
    faEraser = faEraser;
    faSearch = faSearch;
    faSearchPlus = faSearchPlus;
    faSearchMinus = faSearchMinus;
    faFont = faFont;
    faTextHeight = faTextHeight;
    faUndo = faUndo;
    faRedo = faRedo;
    faSave = faSave;
    faTrash = faTrash;
    faTimes = faTimes;
    faMousePointer = faMousePointer;
    mode = 'draw';
    isDrawing = false;
    startX = 0;
    startY = 0;
    currentX = 0;
    currentY = 0;
    freehandDrawing = [];
    shapes = [];
    eraserThickness = 10;
    brushThickness = 6;
    lineThickness = 6;
    lineType = 'solid';
    color = '#000000';
    font = 'Arial';
    fontSize = 20;
    shape = null;
    toolbarVisible = false;
    dropdownOpen = null;
    canvas;
    ctx;
    constructor(injectedCustomWidth, injectedCustomHeight, injectedParameters, injectedShowAspect) {
        this.customWidth = injectedCustomWidth || this.customWidth || 0;
        this.customHeight = injectedCustomHeight || this.customHeight || 0;
        this.parameters = injectedParameters || this.parameters || {};
        this.showAspect = injectedShowAspect || this.showAspect || false;
    }
    ngOnInit() {
        setTimeout(() => {
            if (this.parameters) {
                this.parameters = this.parameters.getUpdatedAllParams();
            }
        }, 100);
    }
    ngOnChanges(changes) {
        if (changes['showAspect']) {
            if (!this.canvas && this.canvasRef) {
                this.canvas = this.canvasRef.nativeElement;
                this.addListeners();
            }
        }
    }
    ngAfterViewInit() {
        if (this.canvasRef && !this.canvas) {
            this.canvas = this.canvasRef.nativeElement;
            this.addListeners();
        }
    }
    ngOnDestroy() {
        if (this.canvas) {
            this.canvas.removeEventListener('mousedown', this.handleMouseDown.bind(this));
            this.canvas.removeEventListener('mousemove', this.handleMouseMove.bind(this));
            this.canvas.removeEventListener('mouseup', this.handleMouseUp.bind(this));
            this.canvas.removeEventListener('mouseout', this.handleMouseUp.bind(this));
            this.canvas.removeEventListener('touchstart', this.handleTouchStart.bind(this));
            this.canvas.removeEventListener('touchmove', this.handleTouchMove.bind(this));
            this.canvas.removeEventListener('touchend', this.handleTouchEnd.bind(this));
            document.removeEventListener('mousedown', this.handleClickOutside.bind(this));
        }
    }
    addListeners = () => {
        if (this.canvas) {
            this.ctx = this.canvas.getContext('2d');
            this.parameters.updateCanvasScreenboard(this.canvas);
            this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
            this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
            this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
            this.canvas.addEventListener('mouseout', this.handleMouseUp.bind(this));
            this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
            this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
            this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
            document.addEventListener('mousedown', this.handleClickOutside.bind(this));
        }
    };
    handleMouseDown(event) {
        this.startDrawing(event);
    }
    handleMouseMove(event) {
        this.draw(event);
    }
    handleMouseUp() {
        this.stopDrawing();
    }
    handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY,
        });
        this.canvas.dispatchEvent(mouseEvent);
    }
    handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY,
        });
        this.canvas.dispatchEvent(mouseEvent);
    }
    handleTouchEnd(e) {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        this.canvas.dispatchEvent(mouseEvent);
    }
    handleClickOutside(event) {
        if (this.dropdownOpen && !event.target.closest('.btn-group')) {
            this.dropdownOpen = null;
        }
    }
    handleDropdownClick(id) {
        this.dropdownOpen = this.dropdownOpen === id ? null : id;
    }
    setDrawMode(thickness) {
        this.lineThickness = thickness;
        this.mode = 'draw';
        this.dropdownOpen = null;
    }
    setFreehandMode(thickness) {
        this.brushThickness = thickness;
        this.mode = 'freehand';
        this.dropdownOpen = null;
    }
    setShapeMode(shape) {
        this.shape = shape;
        this.mode = 'shape';
        this.dropdownOpen = null;
    }
    setEraseMode(thickness) {
        this.eraserThickness = thickness;
        this.mode = 'erase';
        this.dropdownOpen = null;
    }
    startDrawing(event) {
        this.isDrawing = true;
        this.startX = event.offsetX;
        this.startY = event.offsetY;
        if (this.mode === 'erase') {
            this.erase(event.offsetX, event.offsetY);
        }
        else if (this.mode === 'draw' || this.mode === 'freehand') {
            this.ctx.beginPath();
            this.ctx.moveTo(event.offsetX, event.offsetY);
            if (this.mode === 'freehand') {
                this.freehandDrawing = [
                    { x: event.offsetX, y: event.offsetY, color: this.color, thickness: this.brushThickness },
                ];
            }
        }
    }
    draw(event) {
        if (!this.isDrawing)
            return;
        this.currentX = event.offsetX;
        this.currentY = event.offsetY;
        if (this.mode === 'erase') {
            this.erase(event.offsetX, event.offsetY);
        }
        else if (this.mode === 'draw') {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawShapes();
            this.drawLine(this.startX, this.startY, event.offsetX, event.offsetY);
        }
        else if (this.mode === 'freehand') {
            this.ctx.lineTo(event.offsetX, event.offsetY);
            this.ctx.strokeStyle = this.color;
            this.ctx.lineWidth = this.brushThickness;
            this.ctx.stroke();
            this.freehandDrawing.push({
                x: event.offsetX,
                y: event.offsetY,
                color: this.color,
                thickness: this.brushThickness,
            });
        }
        else if (this.mode === 'shape') {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawShapes();
            this.drawShape(this.shape, this.startX, this.startY, event.offsetX, event.offsetY);
        }
    }
    stopDrawing() {
        this.isDrawing = false;
        if (this.mode === 'draw') {
            this.shapes.push({
                type: 'line',
                x1: this.startX,
                y1: this.startY,
                x2: this.currentX,
                y2: this.currentY,
                color: this.color,
                thickness: this.lineThickness,
                lineType: this.lineType,
            });
        }
        else if (this.mode === 'freehand') {
            this.shapes.push({
                type: 'freehand',
                points: this.freehandDrawing,
                color: this.color,
                thickness: this.brushThickness,
            });
            this.freehandDrawing = [];
        }
        else if (this.mode === 'shape') {
            this.shapes.push({
                type: this.shape,
                x1: this.startX,
                y1: this.startY,
                x2: this.currentX,
                y2: this.currentY,
                color: this.color,
                thickness: this.lineThickness,
                lineType: this.lineType,
            });
        }
        setTimeout(() => this.removeShape(), 15000);
    }
    drawLine = (x1, y1, x2, y2) => {
        this.ctx.beginPath();
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.lineThickness;
        if (this.lineType === 'dashed') {
            this.ctx.setLineDash([10, 10]);
        }
        else if (this.lineType === 'dotted') {
            this.ctx.setLineDash([2, 10]);
        }
        else if (this.lineType === 'dashDot') {
            this.ctx.setLineDash([10, 5, 2, 5]);
        }
        else {
            this.ctx.setLineDash([]);
        }
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
    };
    drawShapes = () => {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.shapes.forEach((shape) => {
            if (shape.type === 'line') {
                this.drawLine(shape.x1, shape.y1, shape.x2, shape.y2);
            }
            else if (shape.type === 'freehand') {
                this.drawFreehand(shape.points);
            }
            else {
                this.drawShape(shape.type, shape.x1, shape.y1, shape.x2, shape.y2);
            }
        });
    };
    drawFreehand = (points) => {
        if (points.length < 2)
            return;
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.brushThickness;
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            this.ctx.lineTo(points[i].x, points[i].y);
        }
        this.ctx.stroke();
    };
    drawShape = (type, x1, y1, x2, y2) => {
        this.ctx.beginPath();
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.lineThickness;
        if (this.lineType === 'dashed') {
            this.ctx.setLineDash([10, 10]);
        }
        else if (this.lineType === 'dotted') {
            this.ctx.setLineDash([2, 10]);
        }
        else if (this.lineType === 'dashDot') {
            this.ctx.setLineDash([10, 5, 2, 5]);
        }
        else {
            this.ctx.setLineDash([]);
        }
        if (type === 'rectangle') {
            this.ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
        }
        else if (type === 'circle') {
            const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            this.ctx.arc(x1, y1, radius, 0, 2 * Math.PI);
            this.ctx.stroke();
        }
        else if (type === 'rhombus') {
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            this.ctx.moveTo(centerX, y1);
            this.ctx.lineTo(x2, centerY);
            this.ctx.lineTo(centerX, y2);
            this.ctx.lineTo(x1, centerY);
            this.ctx.closePath();
            this.ctx.stroke();
        }
        else if (type === 'pentagon') {
            this.drawPolygon(5, x1, y1, x2, y2);
        }
        else if (type === 'hexagon') {
            this.drawPolygon(6, x1, y1, x2, y2);
        }
        else if (type === 'triangle') {
            const centerXTriangle = (x1 + x2) / 2;
            this.ctx.moveTo(centerXTriangle, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.lineTo(x1, y2);
            this.ctx.closePath();
            this.ctx.stroke();
        }
        else if (type === 'square') {
            this.ctx.strokeRect(x1, y1, x2 - x1, x2 - x1);
        }
        else if (type === 'octagon') {
            this.drawPolygon(8, x1, y1, x2, y2);
        }
        else if (type === 'oval') {
            const radiusX = Math.abs(x2 - x1) / 2;
            const radiusY = Math.abs(y2 - y1) / 2;
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            this.ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            this.ctx.stroke();
        }
        else if (type === 'parallelogram') {
            const centerX = (x1 + x2) / 2;
            this.ctx.moveTo(centerX, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.lineTo(centerX, y2);
            this.ctx.lineTo(x1, y1);
            this.ctx.closePath();
            this.ctx.stroke();
        }
        this.ctx.setLineDash([]);
    };
    drawPolygon = (sides, x1, y1, x2, y2) => {
        const centerX = (x1 + x2) / 2;
        const centerY = (y1 + y2) / 2;
        const radius = Math.min(Math.abs(x2 - x1), Math.abs(y2 - y1)) / 2;
        const angle = (2 * Math.PI) / sides;
        this.ctx.beginPath();
        for (let i = 0; i < sides; i++) {
            const x = centerX + radius * Math.cos(i * angle - Math.PI / 2);
            const y = centerY + radius * Math.sin(i * angle - Math.PI / 2);
            if (i === 0) {
                this.ctx.moveTo(x, y);
            }
            else {
                this.ctx.lineTo(x, y);
            }
        }
        this.ctx.closePath();
        this.ctx.stroke();
    };
    removeShape = () => {
        this.shapes.shift();
        this.drawShapes();
    };
    erase = (x, y) => {
        this.ctx.save();
        this.ctx.globalCompositeOperation = 'destination-out';
        this.ctx.beginPath();
        this.ctx.arc(x, y, this.eraserThickness / 2, 0, Math.PI * 2, false);
        this.ctx.fill();
        this.ctx.restore();
        this.shapes = this.shapes
            .map((shape) => {
            if (shape.type === 'freehand') {
                return {
                    ...shape,
                    points: shape.points.filter((point) => {
                        const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                        return distance > this.eraserThickness / 2;
                    }),
                };
            }
            else if (shape.type === 'line') {
                if (this.isPointNearLine(x, y, shape.x1, shape.y1, shape.x2, shape.y2, this.eraserThickness / 2)) {
                    return null;
                }
            }
            else if (shape.type === 'text') {
                const textWidth = this.ctx.measureText(shape.text).width;
                if (x > shape.x &&
                    x < shape.x + textWidth &&
                    y > shape.y - shape.fontSize &&
                    y < shape.y) {
                    return null;
                }
            }
            else {
                if (x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2) {
                    return null;
                }
            }
            return shape;
        })
            .filter((shape) => shape && (shape.type !== 'freehand' || shape.points.length > 0));
    };
    isPointNearLine(px, py, x1, y1, x2, y2, threshold) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        const dot = ((px - x1) * dx + (py - y1) * dy) / (length * length);
        const closestX = x1 + dot * dx;
        const closestY = y1 + dot * dy;
        const distance = Math.sqrt(Math.pow(px - closestX, 2) + Math.pow(py - closestY, 2));
        return distance <= threshold;
    }
    toggleToolbar = () => {
        this.toolbarVisible = !this.toolbarVisible;
    };
    toggleAnnotate = async () => {
        const annotateScreenStream = this.parameters.annotateScreenStream;
        this.parameters.annotateScreenStream = !annotateScreenStream;
        setTimeout(() => {
            this.parameters.updateAnnotateScreenStream(!annotateScreenStream);
        });
        if (this.parameters.annotateScreenStream) {
            this.toolbarVisible = true;
            this.parameters.showAlert?.({
                message: `You can now annotate the screen. If you cannot see your annotation controls (on top), try minimizing your screen by using 'Cmd' + '-' (on Mac) or 'Ctrl' + '-' (on Windows).`,
                type: 'success',
                duration: 9000,
            });
        }
        else {
            this.toolbarVisible = false;
        }
        this.parameters.updateIsScreenboardModalVisible(true);
        await this.parameters.sleep({ ms: 500 });
        this.parameters.updateIsScreenboardModalVisible(false);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Screenboard, deps: [{ token: 'customWidth', optional: true }, { token: 'customHeight', optional: true }, { token: 'parameters', optional: true }, { token: 'showAspect', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: Screenboard, isStandalone: true, selector: "app-screenboard", inputs: { customWidth: "customWidth", customHeight: "customHeight", parameters: "parameters", showAspect: "showAspect" }, viewQueries: [{ propertyName: "canvasRef", first: true, predicate: ["canvasRef"], descendants: true }, { propertyName: "screenboardRef", first: true, predicate: ["screenboardRef"], descendants: true }, { propertyName: "screenboardContentRef", first: true, predicate: ["screenboardContentRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div id=\"screenboard-interface\" *ngIf=\"showAspect\" style=\"position: relative; display: block; justify-content: center; align-items: center; background-color: transparent; z-index: 1000; width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: auto;\" #screenboardRef>\r\n  <div id=\"screenboardContent\" style=\"position: relative; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; overflow: hidden; top: 0; left: 0;\" #screenboardContentRef>\r\n    <button id=\"annotateScreen\" class=\"btn btn-primary btnBoardScreen annotateScreenBtn\" style=\"position: absolute; top: 5px; right: 10px; z-index: 1000;\" (click)=\"toggleAnnotate()\">\r\n      <fa-icon [icon]=\"faPencilAlt\" [ngStyle]=\"{'color': parameters.annotateScreenStream ? 'red' : 'green'}\"></fa-icon>\r\n    </button>\r\n\r\n    <button id=\"toolbarToggleScreen\" *ngIf=\"parameters.annotateScreenStream\" class=\"btn btnBoardScreen btn-primary\" style=\"position: absolute; top: 5px; right: 55px; z-index: 1000;\" (click)=\"toggleToolbar()\">\r\n      <fa-icon [icon]=\"toolbarVisible ? faChevronRight : faChevronLeft\"></fa-icon>\r\n    </button>\r\n\r\n    <div class=\"toolbarScreen mb-3\" id=\"toolbarScreen\" style=\"position: absolute; top: 5px; right: 105px; z-index: 1000; background-color: transparent;\" [style.display]=\"toolbarVisible ? 'block' : 'none'\">\r\n      <!-- Draw Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-secondary dropdown-toggle\" id=\"drawModeScreen\" (click)=\"handleDropdownClick('drawModeScreen')\">\r\n          <fa-icon [icon]=\"faPencilAlt\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'drawModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(3)\">XX-Small (3px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(6)\">X-Small (6px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(12)\">Small (12px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(18)\">Medium (18px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(24)\">Large (24px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(36)\">X-Large (36px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Freehand Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-dark dropdown-toggle\" id=\"freehandModeScreen\" (click)=\"handleDropdownClick('freehandModeScreen')\">\r\n          <fa-icon [icon]=\"faPaintBrush\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'freehandModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(5)\">X-Small (5px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(10)\">Small (10px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(20)\">Medium (20px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(40)\">Large (40px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(60)\">X-Large (60px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Shape Mode Dropdown with Images -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-dark dropdown-toggle\" id=\"shapeModeScreen\" (click)=\"handleDropdownClick('shapeModeScreen')\">\r\n          <fa-icon [icon]=\"faShapes\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'shapeModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('square')\">\r\n            <img src=\"https://mediasfu.com/images/svg/square.svg\" alt=\"Square\" class=\"shape-icon\" /> Square\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('rectangle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/rectangle.svg\" alt=\"Rectangle\" class=\"shape-icon\" /> Rectangle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('circle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/circle.svg\" alt=\"Circle\" class=\"shape-icon\" /> Circle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('triangle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/triangle.svg\" alt=\"Triangle\" class=\"shape-icon\" /> Triangle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('hexagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/hexagon.svg\" alt=\"Hexagon\" class=\"shape-icon\" /> Hexagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('pentagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/pentagon.svg\" alt=\"Pentagon\" class=\"shape-icon\" /> Pentagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('rhombus')\">\r\n            <img src=\"https://mediasfu.com/images/svg/rhombus.svg\" alt=\"Rhombus\" class=\"shape-icon\" /> Rhombus\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('octagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/octagon.svg\" alt=\"Octagon\" class=\"shape-icon\" /> Octagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('oval')\">\r\n            <img src=\"https://mediasfu.com/images/svg/oval.svg\" alt=\"Oval\" class=\"shape-icon\" /> Oval\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('parallelogram')\">\r\n            <img src=\"https://mediasfu.com/images/svg/parallelogram.svg\" alt=\"Parallelogram\" class=\"shape-icon\" /> Parallelogram\r\n          </button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Erase Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-danger dropdown-toggle\" id=\"eraseModeScreen\" (click)=\"handleDropdownClick('eraseModeScreen')\">\r\n          <fa-icon [icon]=\"faEraser\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'eraseModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(5)\">X-Small (5px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(10)\">Small (10px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(20)\">Medium (20px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(30)\">Large (30px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(60)\">X-Large (60px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Additional Toolbar Controls -->\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomResetScreen\" style=\"display: none;\">\r\n        <fa-icon [icon]=\"faSearch\"></fa-icon>\r\n      </button>\r\n\r\n      <input type=\"color\" class=\"btn\" id=\"colorPickerScreen\" [(ngModel)]=\"color\">\r\n      <select id=\"lineTypePickerScreen\" class=\"custom-select\" style=\"width: auto;\" [(ngModel)]=\"lineType\">\r\n        <option value=\"solid\">Solid</option>\r\n        <option value=\"dashed\">Dashed</option>\r\n        <option value=\"dotted\">Dotted</option>\r\n        <option value=\"dashDot\">Dash-Dot</option>\r\n      </select>\r\n    </div>\r\n\r\n    <canvas id=\"canvasRef\" width=\"1280\" height=\"720\" [ngStyle]=\"{'display': parameters.annotateScreenStream ? 'block' : 'none'}\" style=\"padding: 0; margin: 0;\" #canvasRef></canvas>\r\n  </div>\r\n</div>\r\n", styles: ["#whiteboardCanvas{border:1px solid #000;cursor:crosshair;background-color:#fff}.resize-handle,.move-handle{width:8px;height:8px;background:red;position:absolute}.move-handle{background:#00f}#textInput{display:none;position:absolute;z-index:10;width:200px}.shape-icon{width:20px;height:20px;color:#fff}.toolbar .btn-group button,.toolbar .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s}.toolbar .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbar .btn-group button:hover,.toolbar .dropdown-menu a:hover{background-color:#e3e7eb}.toolbar .btn-group button.active{background-color:#454d55}.toolbarScreen .btn-group button,.toolbarScreen .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:1px 2px;border-radius:4px;transition:background-color .2s;background-color:transparent;color:\"black\"}.toolbarScreen .btn-group button{color:#060606;border:none}.toolbarScreen .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbarScreen .btn-group button.active{background-color:#454d55}#toolbar,#toolbarScreen{transition:display .3s ease-in-out}#toolbarToggle,#toolbarToggleScreen{cursor:pointer;border:\"2px solid black\"!important;font-size:.8rem}#colorPicker,#colorPickerScreen{font-size:.8rem;padding:2px;width:32px;height:32px}#lineTypePicker{font-size:.8rem;padding:2px auto;width:32px;height:32px}.btnBoard{font-size:1rem;padding:2px;width:40px;height:40px;margin:2px}#lineTypePickerScreen{font-size:.7rem;padding:2px auto;width:28px;height:28px;background-color:#d6d1d166;color:#000;border-radius:4px}.toggle-icon{width:30px;height:30px;padding:0;margin:0}#toggleBackground.active{background-color:#fdfeff}.annotateScreenBtn{background-color:#2d2e2f!important;border:2px solid #000!important;color:green!important;font-size:.75rem}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Screenboard, decorators: [{
            type: Component,
            args: [{ selector: 'app-screenboard', imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div id=\"screenboard-interface\" *ngIf=\"showAspect\" style=\"position: relative; display: block; justify-content: center; align-items: center; background-color: transparent; z-index: 1000; width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: auto;\" #screenboardRef>\r\n  <div id=\"screenboardContent\" style=\"position: relative; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; overflow: hidden; top: 0; left: 0;\" #screenboardContentRef>\r\n    <button id=\"annotateScreen\" class=\"btn btn-primary btnBoardScreen annotateScreenBtn\" style=\"position: absolute; top: 5px; right: 10px; z-index: 1000;\" (click)=\"toggleAnnotate()\">\r\n      <fa-icon [icon]=\"faPencilAlt\" [ngStyle]=\"{'color': parameters.annotateScreenStream ? 'red' : 'green'}\"></fa-icon>\r\n    </button>\r\n\r\n    <button id=\"toolbarToggleScreen\" *ngIf=\"parameters.annotateScreenStream\" class=\"btn btnBoardScreen btn-primary\" style=\"position: absolute; top: 5px; right: 55px; z-index: 1000;\" (click)=\"toggleToolbar()\">\r\n      <fa-icon [icon]=\"toolbarVisible ? faChevronRight : faChevronLeft\"></fa-icon>\r\n    </button>\r\n\r\n    <div class=\"toolbarScreen mb-3\" id=\"toolbarScreen\" style=\"position: absolute; top: 5px; right: 105px; z-index: 1000; background-color: transparent;\" [style.display]=\"toolbarVisible ? 'block' : 'none'\">\r\n      <!-- Draw Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-secondary dropdown-toggle\" id=\"drawModeScreen\" (click)=\"handleDropdownClick('drawModeScreen')\">\r\n          <fa-icon [icon]=\"faPencilAlt\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'drawModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(3)\">XX-Small (3px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(6)\">X-Small (6px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(12)\">Small (12px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(18)\">Medium (18px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(24)\">Large (24px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setDrawMode(36)\">X-Large (36px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Freehand Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-dark dropdown-toggle\" id=\"freehandModeScreen\" (click)=\"handleDropdownClick('freehandModeScreen')\">\r\n          <fa-icon [icon]=\"faPaintBrush\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'freehandModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(5)\">X-Small (5px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(10)\">Small (10px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(20)\">Medium (20px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(40)\">Large (40px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setFreehandMode(60)\">X-Large (60px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Shape Mode Dropdown with Images -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-dark dropdown-toggle\" id=\"shapeModeScreen\" (click)=\"handleDropdownClick('shapeModeScreen')\">\r\n          <fa-icon [icon]=\"faShapes\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'shapeModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('square')\">\r\n            <img src=\"https://mediasfu.com/images/svg/square.svg\" alt=\"Square\" class=\"shape-icon\" /> Square\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('rectangle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/rectangle.svg\" alt=\"Rectangle\" class=\"shape-icon\" /> Rectangle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('circle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/circle.svg\" alt=\"Circle\" class=\"shape-icon\" /> Circle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('triangle')\">\r\n            <img src=\"https://mediasfu.com/images/svg/triangle.svg\" alt=\"Triangle\" class=\"shape-icon\" /> Triangle\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('hexagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/hexagon.svg\" alt=\"Hexagon\" class=\"shape-icon\" /> Hexagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('pentagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/pentagon.svg\" alt=\"Pentagon\" class=\"shape-icon\" /> Pentagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('rhombus')\">\r\n            <img src=\"https://mediasfu.com/images/svg/rhombus.svg\" alt=\"Rhombus\" class=\"shape-icon\" /> Rhombus\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('octagon')\">\r\n            <img src=\"https://mediasfu.com/images/svg/octagon.svg\" alt=\"Octagon\" class=\"shape-icon\" /> Octagon\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('oval')\">\r\n            <img src=\"https://mediasfu.com/images/svg/oval.svg\" alt=\"Oval\" class=\"shape-icon\" /> Oval\r\n          </button>\r\n          <button class=\"dropdown-item\" (click)=\"setShapeMode('parallelogram')\">\r\n            <img src=\"https://mediasfu.com/images/svg/parallelogram.svg\" alt=\"Parallelogram\" class=\"shape-icon\" /> Parallelogram\r\n          </button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Erase Mode Dropdown -->\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoardScreen btn-danger dropdown-toggle\" id=\"eraseModeScreen\" (click)=\"handleDropdownClick('eraseModeScreen')\">\r\n          <fa-icon [icon]=\"faEraser\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'eraseModeScreen'\" class=\"dropdown-menu show\">\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(5)\">X-Small (5px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(10)\">Small (10px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(20)\">Medium (20px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(30)\">Large (30px)</button>\r\n          <button class=\"dropdown-item\" (click)=\"setEraseMode(60)\">X-Large (60px)</button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Additional Toolbar Controls -->\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomResetScreen\" style=\"display: none;\">\r\n        <fa-icon [icon]=\"faSearch\"></fa-icon>\r\n      </button>\r\n\r\n      <input type=\"color\" class=\"btn\" id=\"colorPickerScreen\" [(ngModel)]=\"color\">\r\n      <select id=\"lineTypePickerScreen\" class=\"custom-select\" style=\"width: auto;\" [(ngModel)]=\"lineType\">\r\n        <option value=\"solid\">Solid</option>\r\n        <option value=\"dashed\">Dashed</option>\r\n        <option value=\"dotted\">Dotted</option>\r\n        <option value=\"dashDot\">Dash-Dot</option>\r\n      </select>\r\n    </div>\r\n\r\n    <canvas id=\"canvasRef\" width=\"1280\" height=\"720\" [ngStyle]=\"{'display': parameters.annotateScreenStream ? 'block' : 'none'}\" style=\"padding: 0; margin: 0;\" #canvasRef></canvas>\r\n  </div>\r\n</div>\r\n", styles: ["#whiteboardCanvas{border:1px solid #000;cursor:crosshair;background-color:#fff}.resize-handle,.move-handle{width:8px;height:8px;background:red;position:absolute}.move-handle{background:#00f}#textInput{display:none;position:absolute;z-index:10;width:200px}.shape-icon{width:20px;height:20px;color:#fff}.toolbar .btn-group button,.toolbar .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s}.toolbar .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbar .btn-group button:hover,.toolbar .dropdown-menu a:hover{background-color:#e3e7eb}.toolbar .btn-group button.active{background-color:#454d55}.toolbarScreen .btn-group button,.toolbarScreen .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:1px 2px;border-radius:4px;transition:background-color .2s;background-color:transparent;color:\"black\"}.toolbarScreen .btn-group button{color:#060606;border:none}.toolbarScreen .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbarScreen .btn-group button.active{background-color:#454d55}#toolbar,#toolbarScreen{transition:display .3s ease-in-out}#toolbarToggle,#toolbarToggleScreen{cursor:pointer;border:\"2px solid black\"!important;font-size:.8rem}#colorPicker,#colorPickerScreen{font-size:.8rem;padding:2px;width:32px;height:32px}#lineTypePicker{font-size:.8rem;padding:2px auto;width:32px;height:32px}.btnBoard{font-size:1rem;padding:2px;width:40px;height:40px;margin:2px}#lineTypePickerScreen{font-size:.7rem;padding:2px auto;width:28px;height:28px;background-color:#d6d1d166;color:#000;border-radius:4px}.toggle-icon{width:30px;height:30px;padding:0;margin:0}#toggleBackground.active{background-color:#fdfeff}.annotateScreenBtn{background-color:#2d2e2f!important;border:2px solid #000!important;color:green!important;font-size:.75rem}\n"] }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customWidth']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['customHeight']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['parameters']
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['showAspect']
                }] }], propDecorators: { customWidth: [{
                type: Input
            }], customHeight: [{
                type: Input
            }], parameters: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], canvasRef: [{
                type: ViewChild,
                args: ['canvasRef']
            }], screenboardRef: [{
                type: ViewChild,
                args: ['screenboardRef']
            }], screenboardContentRef: [{
                type: ViewChild,
                args: ['screenboardContentRef']
            }] } });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * @fileoverview ScreenboardModal component for handling screen annotation and modal visibility.
 *
 * @component
 * @selector app-screenboard-modal
 * @standalone true
 * @templateUrl ./screenboard-modal.component.html
 * @styleUrls ./screenboard-modal.component.css
 * @imports CommonModule, FormsModule, FontAwesomeModule
 *
 * @class ScreenboardModal
 * @implements OnInit, OnDestroy, OnChanges, AfterViewInit
 *
 * @description
 * This component is responsible for managing the screen annotation modal, including showing and hiding the modal,
 * handling screen annotations, and managing media streams.
 *
 * @property {ScreenboardModalParameters} parameters - Input parameter for screen annotation modal.
 * @property {boolean} isVisible - Input flag to control the visibility of the modal.
 * @property {() => void} onClose - Input callback function to be called when the modal is closed.
 * @property {string} position - Input string to set the position of the modal.
 * @property {string} backgroundColor - Input string to set the background color of the modal.
 *
 * @property {ElementRef<HTMLVideoElement>} screenVideoRef - ViewChild reference to the screen video element.
 * @property {ElementRef<HTMLCanvasElement>} screenCanvasRef - ViewChild reference to the screen canvas element.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for the close button.
 *
 * @property {any} annotationInterval - Interval for annotation updates.
 * @property {any} annotationCheckInterval - Interval for checking annotation updates.
 * @property {MediaStream | null} clonedStreamScreen - Cloned media stream for screen sharing.
 * @property {CanvasRenderingContext2D | null} ctx - Canvas rendering context.
 *
 * @method ngOnInit - Initialization logic that does not depend on the view.
 * @method ngOnDestroy - Cleanup logic when the component is destroyed.
 * @method ngOnChanges - Logic to handle changes in input properties.
 * @method ngAfterViewInit - Logic that requires view access.
 * @method showModal - Method to show the modal and handle screen annotation setup.
 * @method hideModal - Method to hide the modal and cleanup screen annotation.
 * @method annotatationPreview - Method to handle the preview of screen annotations.
 * @method handleScreenTransport - Method to handle screen transport logic.
 * @method stopAnnotation - Method to stop the screen annotation.
 * @method stopAllTracks - Method to stop all media tracks.
 * @returns {HTMLElement} The screenboard modal component.
 * @example
 * ```html
 * <app-screenboard-modal
 *  [parameters]="screenboardModalParams"
 * [isVisible]="isModalVisible"
 * [onClose]="closeModal"
 * [position]="'topRight'"
 * [backgroundColor]="'#83c0e9'">
 * </app-screenboard-modal>
 * ```
 */
class ScreenboardModal {
    parameters = {};
    isVisible = false;
    onClose;
    position = 'topRight';
    backgroundColor = '#83c0e9';
    screenVideoRef;
    screenCanvasRef;
    faTimes = faTimes;
    annotationInterval;
    annotationCheckInterval;
    clonedStreamScreen = null;
    ctx = null;
    ngOnInit() {
        // Initialization logic that does not depend on the view
    }
    ngOnDestroy() {
        this.stopAnnotation();
    }
    ngOnChanges(changes) {
        if (changes['isVisible']) {
            this.isVisible = changes['isVisible'].currentValue;
            if (this.isVisible) {
                // In case isVisible changes after view init
                if (this.screenCanvasRef && this.screenVideoRef) {
                    this.showModal();
                }
                else {
                    setTimeout(() => {
                        if (this.screenCanvasRef && this.screenVideoRef) {
                            this.showModal();
                        }
                    }, 100);
                }
            }
            else {
                if (this.screenCanvasRef && this.screenVideoRef) {
                    this.hideModal();
                }
            }
        }
    }
    ngAfterViewInit() {
        // Move logic that requires view access here
    }
    showModal = async () => {
        try {
            this.parameters = this.parameters.getUpdatedAllParams();
            const { annotateScreenStream, shared, createSendTransport, prepopulateUserMedia, hostLabel } = this.parameters;
            const annotate = annotateScreenStream;
            const screenVideo = this.screenVideoRef.nativeElement;
            if (annotate && shared) {
                screenVideo.classList.remove('d-none');
                await this.annotatationPreview();
                setTimeout(async () => {
                    if (!this.parameters.transportCreated) {
                        await createSendTransport({ option: 'screen', parameters: this.parameters });
                    }
                    else {
                        try {
                            await this.handleScreenTransport();
                            await this.parameters.sleep({ ms: 250 });
                        }
                        catch {
                            /* handle error */
                        }
                    }
                    await this.parameters.connectSendTransportScreen({
                        stream: this.parameters.processedScreenStream,
                        parameters: this.parameters,
                    });
                    await prepopulateUserMedia({ name: hostLabel, parameters: this.parameters });
                }, 100);
            }
            else {
                screenVideo.classList.add('d-none');
            }
        }
        catch {
            /* handle error */
        }
    };
    hideModal = async () => {
        this.parameters = this.parameters.getUpdatedAllParams();
        const { annotateScreenStream, shared, createSendTransport, disconnectSendTransportScreen, stopShareScreen, prepopulateUserMedia, hostLabel, } = this.parameters;
        const annotate = annotateScreenStream;
        const screenVideo = this.screenVideoRef && this.screenVideoRef.nativeElement;
        try {
            if (!annotate) {
                try {
                    await this.stopAnnotation();
                }
                catch {
                    /* handle error */
                }
                if (shared) {
                    if (!this.parameters.transportCreated) {
                        await createSendTransport({ option: 'screen', parameters: this.parameters });
                    }
                    else {
                        try {
                            await disconnectSendTransportScreen({ parameters: this.parameters });
                            await this.parameters.sleep({ ms: 500 });
                        }
                        catch {
                            /* handle error */
                        }
                        if (this.parameters.localStreamScreen &&
                            this.parameters.localStreamScreen.getVideoTracks().length > 0 &&
                            this.parameters.localStreamScreen.getVideoTracks()[0].readyState === 'ended') {
                            this.parameters.localStreamScreen.removeTrack(this.parameters.localStreamScreen.getVideoTracks()[0]);
                            if (this.clonedStreamScreen) {
                                this.parameters.localStreamScreen.addTrack(this.clonedStreamScreen.getVideoTracks()[0].clone());
                            }
                            this.parameters.updateLocalStreamScreen(this.parameters.localStreamScreen);
                        }
                        if (this.clonedStreamScreen) {
                            this.clonedStreamScreen.getVideoTracks()[0].onended = async () => {
                                await disconnectSendTransportScreen({ parameters: this.parameters });
                                await stopShareScreen({ parameters: this.parameters });
                            };
                        }
                        await this.parameters.connectSendTransportScreen({
                            stream: this.parameters.localStreamScreen,
                            parameters: this.parameters,
                        });
                    }
                }
                else {
                    await this.stopAllTracks();
                }
                await prepopulateUserMedia({ name: hostLabel, parameters: this.parameters });
            }
            screenVideo && screenVideo.classList.add('d-none');
            if (this.parameters.mainScreenCanvas && this.screenCanvasRef) {
                this.screenCanvasRef.nativeElement.classList.add('d-none');
            }
            this.onClose();
        }
        catch {
            /* handle error */
        }
    };
    annotatationPreview = async () => {
        const screenVideo = this.screenVideoRef.nativeElement;
        if (!this.parameters.mainScreenCanvas) {
            this.parameters.mainScreenCanvas = this.screenCanvasRef.nativeElement;
            this.parameters.updateMainScreenCanvas(this.parameters.mainScreenCanvas);
        }
        const annotate = this.parameters.annotateScreenStream;
        if (annotate &&
            (!this.clonedStreamScreen ||
                (this.clonedStreamScreen &&
                    this.clonedStreamScreen.getVideoTracks().length > 0 &&
                    this.clonedStreamScreen.getVideoTracks()[0].readyState === 'ended'))) {
            const originalTrack = this.parameters.localStreamScreen.getVideoTracks()[0];
            const originalSettings = originalTrack.getSettings();
            const cloned = originalTrack.clone();
            await cloned.applyConstraints({
                width: originalSettings.width,
                height: originalSettings.height,
                frameRate: originalSettings.frameRate,
                aspectRatio: originalSettings.aspectRatio,
            });
            this.clonedStreamScreen = new MediaStream([cloned]);
        }
        if (this.clonedStreamScreen &&
            this.parameters.localStreamScreen &&
            this.parameters.localStreamScreen.getVideoTracks().length > 0 &&
            this.parameters.localStreamScreen.getVideoTracks()[0].readyState === 'ended') {
            this.parameters.localStreamScreen.removeTrack(this.parameters.localStreamScreen.getVideoTracks()[0]);
            this.parameters.localStreamScreen.addTrack(this.clonedStreamScreen.getVideoTracks()[0].clone());
        }
        if (this.clonedStreamScreen) {
            this.clonedStreamScreen.getVideoTracks()[0].onended = async () => {
                await this.parameters.disconnectSendTransportScreen({ parameters: this.parameters });
                await this.parameters.stopShareScreen({ parameters: this.parameters });
            };
        }
        const mediaCanvas = this.parameters.mainScreenCanvas;
        const ctx = mediaCanvas.getContext('2d');
        mediaCanvas.width = this.parameters.localStreamScreen.getVideoTracks()[0].getSettings().width;
        mediaCanvas.height = this.parameters
            .localStreamScreen.getVideoTracks()[0]
            .getSettings().height;
        if (!annotate) {
            this.parameters.processedScreenStream = null;
            this.parameters.updateProcessedScreenStream(null);
        }
        const captureStream = () => {
            const stream = mediaCanvas.captureStream(30);
            this.annotationCheckInterval = setInterval(() => {
                const params = this.parameters.getUpdatedAllParams();
                canvasElement = params.canvasScreenboard;
                const height = canvasElement.height;
                const width = canvasElement.width;
                const refHeight = params.localStreamScreen.getVideoTracks()[0].getSettings().height;
                const refWidth = params.localStreamScreen.getVideoTracks()[0].getSettings().width;
                if (height !== refHeight || width !== refWidth) {
                    canvasElement.width = refWidth;
                    canvasElement.height = refHeight;
                    mediaCanvas.width = refWidth;
                    mediaCanvas.height = refHeight;
                }
            }, 1000);
            this.annotationInterval = setInterval(() => {
                drawCombined();
            }, 30);
            return stream;
        };
        const annotateImage = async () => {
            this.parameters.processedScreenStream = await captureStream();
            this.parameters.updateProcessedScreenStream(this.parameters.processedScreenStream);
        };
        const annotateVideo = this.clonedStreamScreen;
        if (annotateVideo && annotate) {
            screenVideo.style.width = `${annotateVideo.getVideoTracks()[0].getSettings().width}px`;
            screenVideo.style.height = `${annotateVideo.getVideoTracks()[0].getSettings().height}px`;
            screenVideo.srcObject = annotateVideo;
            await annotateImage();
        }
        let canvasElement = this.parameters.getUpdatedAllParams().canvasScreenboard;
        canvasElement.width = mediaCanvas.width;
        canvasElement.height = mediaCanvas.height;
        const drawCombined = () => {
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            ctx.drawImage(screenVideo, 0, 0, canvasElement.width, canvasElement.height);
            ctx.drawImage(canvasElement, 0, 0, canvasElement.width, canvasElement.height);
            ctx.restore();
        };
    };
    handleScreenTransport = async () => {
        if (this.parameters.localStreamScreen.getVideoTracks().length > 0 &&
            this.parameters.localStreamScreen.getVideoTracks()[0].id ===
                this.parameters.screenProducer?.track.id) {
            if (this.clonedStreamScreen &&
                this.clonedStreamScreen.getVideoTracks().length > 0 &&
                this.clonedStreamScreen.getVideoTracks()[0].readyState === 'ended') {
                this.clonedStreamScreen.removeTrack(this.clonedStreamScreen.getVideoTracks()[0]);
                this.clonedStreamScreen.addTrack(this.parameters.localStreamScreen.getVideoTracks()[0].clone());
            }
            this.parameters.localStreamScreen.removeTrack(this.parameters.localStreamScreen.getVideoTracks()[0]);
            this.parameters.localStreamScreen.addTrack(this.clonedStreamScreen.getVideoTracks()[0].clone());
        }
        await this.parameters.disconnectSendTransportScreen({ parameters: this.parameters });
    };
    stopAnnotation = async () => {
        if (this.annotationInterval) {
            clearInterval(this.annotationInterval);
            clearInterval(this.annotationCheckInterval);
            this.annotationInterval = null;
            this.annotationCheckInterval = null;
        }
        if (this.parameters.processedScreenStream) {
            this.parameters.processedScreenStream
                .getTracks()
                .forEach((track) => track.stop());
            this.parameters.processedScreenStream = null;
            this.parameters.updateProcessedScreenStream(null);
        }
        if (this.parameters.mainScreenCanvas) {
            this.parameters.mainScreenCanvas
                ?.getContext('2d')
                .clearRect(0, 0, this.parameters.mainScreenCanvas.width, this.parameters.mainScreenCanvas.height);
        }
    };
    stopAllTracks = async () => {
        try {
            if (this.parameters.localStreamScreen &&
                this.parameters.localStreamScreen.getVideoTracks().length > 0) {
                this.parameters.localStreamScreen
                    .getVideoTracks()
                    .forEach((track) => track.stop());
                this.parameters.updateLocalStreamScreen(null);
            }
            else {
                this.parameters.updateLocalStreamScreen(null);
            }
        }
        catch {
            /* handle error */
        }
        try {
            if (this.clonedStreamScreen && this.clonedStreamScreen.getVideoTracks().length > 0) {
                this.clonedStreamScreen.getVideoTracks().forEach((track) => track.stop());
            }
        }
        catch {
            /* handle error */
        }
        try {
            if (this.parameters.processedScreenStream) {
                this.parameters.processedScreenStream
                    .getTracks()
                    .forEach((track) => track.stop());
                this.parameters.updateProcessedScreenStream(null);
            }
        }
        catch {
            /* handle error */
        }
        this.clonedStreamScreen = null;
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ScreenboardModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ScreenboardModal, isStandalone: true, selector: "app-screenboard-modal", inputs: { parameters: "parameters", isVisible: "isVisible", onClose: "onClose", position: "position", backgroundColor: "backgroundColor" }, viewQueries: [{ propertyName: "screenVideoRef", first: true, predicate: ["screenVideo"], descendants: true }, { propertyName: "screenCanvasRef", first: true, predicate: ["screenCanvas"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Screen Annotation</div>\r\n      <div class=\"modal-close\" (click)=\"hideModal()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <video #screenVideo id=\"screenVideo\" class=\"d-none\" autoplay></video>\r\n      <canvas #screenCanvas id=\"screenCanvas\"></canvas>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:500px;max-height:75%;overflow-y:auto;overflow-x:hidden;top:10px;right:10px}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.modal-close{padding:5px}.modal-body{flex:1}#screenCanvas{width:100%;height:auto}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FormsModule }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ScreenboardModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-screenboard-modal', imports: [CommonModule, FormsModule, FontAwesomeModule], template: "<div *ngIf=\"isVisible\" class=\"modal-container\">\r\n  <div class=\"modal-content\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">Screen Annotation</div>\r\n      <div class=\"modal-close\" (click)=\"hideModal()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr />\r\n    <div class=\"modal-body\">\r\n      <video #screenVideo id=\"screenVideo\" class=\"d-none\" autoplay></video>\r\n      <canvas #screenCanvas id=\"screenCanvas\"></canvas>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;background-color:#83c0e9;border-radius:10px;padding:10px;width:80%;max-width:500px;max-height:75%;overflow-y:auto;overflow-x:hidden;top:10px;right:10px}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.modal-title{font-size:18px;font-weight:700;color:#000}.modal-close{padding:5px}.modal-body{flex:1}#screenCanvas{width:100%;height:auto}\n"] }]
        }], propDecorators: { parameters: [{
                type: Input
            }], isVisible: [{
                type: Input
            }], onClose: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], screenVideoRef: [{
                type: ViewChild,
                args: ['screenVideo']
            }], screenCanvasRef: [{
                type: ViewChild,
                args: ['screenCanvas']
            }] } });

/* eslint-disable @typescript-eslint/no-empty-function */
/**
 * Component representing a modal for managing participants in a waiting room.
 *
 * @component
 * @selector app-waiting-room-modal
 * @standalone true
 * @imports CommonModule, FontAwesomeModule, FormsModule
 * @templateUrl ./waiting-room-modal.component.html
 * @styleUrls ['./waiting-room-modal.component.css']
 *
 * @property {boolean} isWaitingModalVisible - Visibility state of the modal.
 * @property {number} waitingRoomCounter - Counter for the number of participants in the waiting room.
 * @property {WaitingRoomParticipant[]} waitingRoomList - List of participants in the waiting room.
 * @property {string} roomName - Name of the room.
 * @property {Socket} socket - Socket instance for communication.
 * @property {string} position - Position of the modal on the screen.
 * @property {string} backgroundColor - Background color of the modal.
 * @property {WaitingRoomModalParameters} parameters - Parameters for the waiting room modal.
 * @property {function} onWaitingRoomClose - Function to call when the modal is closed.
 * @property {function} onWaitingRoomFilterChange - Function to call when the filter value changes.
 * @property {function} updateWaitingList - Function to update the waiting list.
 * @property {function} onWaitingRoomItemPress - Function to call when an item in the waiting room is pressed.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for the close button.
 * @property {IconDefinition} faCheck - FontAwesome icon for the check button.
 * @property {WaitingRoomParticipant[]} waitingRoomList_s - Filtered list of participants in the waiting room.
 * @property {number} waitingRoomCounter_s - Counter for the filtered list of participants in the waiting room.
 * @property {boolean} reRender - Flag to trigger re-rendering of the component.
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property of a directive changes.
 * @method updateParameters - Updates the parameters for the waiting room modal.
 * @method handleModalClose - Handles the closing of the modal.
 * @method handleFilterChange - Handles the change in the filter input.
 * @method handleItemPress - Handles the pressing of an item in the waiting room.
 *
 * @getter modalContainerStyle - Returns the style object for the modal container.
 * @getter modalContentStyle - Returns the style object for the modal content.
 * @getter inputStyle - Returns the style object for the input field.
 *
 * @example
 * ```html
 * <app-waiting-room-modal
 *  [isWaitingModalVisible]="true"
 * [waitingRoomCounter]="waitingRoomCounter"
 * [waitingRoomList]="waitingRoomList"
 * [roomName]="roomName"
 * [socket]="socket"
 * [position]="'topRight'"
 * [backgroundColor]="'#83c0e9'"
 * [parameters]="waitingRoomModalParams"
 * [onWaitingRoomClose]="closeWaitingRoomModal"
 * [onWaitingRoomFilterChange]="filterWaitingRoom"
 * [updateWaitingList]="updateWaitingList"
 * [onWaitingRoomItemPress]="handleWaitingRoomItemPress"
 * ></app-waiting-room-modal>
 * ```
 *
 */
class WaitingRoomModal {
    respondToWaitingService;
    constructor(respondToWaitingService) {
        this.respondToWaitingService = respondToWaitingService;
    }
    isWaitingModalVisible = false;
    waitingRoomCounter = 0;
    waitingRoomList = [];
    roomName = '';
    socket = {};
    position = 'topRight';
    backgroundColor = '#83c0e9';
    parameters = {};
    onWaitingRoomClose = () => { };
    onWaitingRoomFilterChange = () => { };
    updateWaitingList = () => { };
    onWaitingRoomItemPress;
    faTimes = faTimes;
    faCheck = faCheck;
    waitingRoomList_s = [];
    waitingRoomCounter_s = 0;
    reRender = false;
    ngOnInit() {
        if (!this.onWaitingRoomItemPress) {
            this.onWaitingRoomItemPress = (data) => this.respondToWaitingService.respondToWaiting(data);
        }
    }
    ngOnChanges(changes) {
        if (changes['waitingRoomList'] || changes['reRender']) {
            this.updateParameters();
        }
    }
    updateParameters() {
        let { getUpdatedAllParams } = this.parameters;
        this.parameters = getUpdatedAllParams();
        this.waitingRoomList_s = this.parameters.filteredWaitingRoomList;
        this.waitingRoomCounter_s = this.parameters.filteredWaitingRoomList.length;
    }
    handleModalClose() {
        this.onWaitingRoomClose();
    }
    handleFilterChange(event) {
        const inputElement = event.target;
        const value = inputElement?.value || '';
        this.onWaitingRoomFilterChange(value);
        this.reRender = !this.reRender;
    }
    handleItemPress(participant, type) {
        this.onWaitingRoomItemPress({
            participantId: participant.id,
            participantName: participant.name,
            updateWaitingList: this.updateWaitingList,
            waitingList: this.waitingRoomList,
            roomName: this.roomName,
            type: type, // true for accepted, false for rejected
            socket: this.socket,
        });
    }
    get modalContainerStyle() {
        return {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isWaitingModalVisible ? 'block' : 'none',
            zIndex: '999',
        };
    }
    get modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.8 * screenWidth;
        if (modalWidth > 350) {
            modalWidth = 350;
        }
        return {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: `${modalWidth}px`,
            maxHeight: '65%',
            overflowY: 'auto',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    get inputStyle() {
        return {
            width: '90%',
            padding: '10px',
            borderRadius: '5px',
            border: '1px solid #000',
            fontSize: '16px',
            marginBottom: '10px',
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: WaitingRoomModal, deps: [{ token: RespondToWaiting }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: WaitingRoomModal, isStandalone: true, selector: "app-waiting-room-modal", inputs: { isWaitingModalVisible: "isWaitingModalVisible", waitingRoomCounter: "waitingRoomCounter", waitingRoomList: "waitingRoomList", roomName: "roomName", socket: "socket", position: "position", backgroundColor: "backgroundColor", parameters: "parameters", onWaitingRoomClose: "onWaitingRoomClose", onWaitingRoomFilterChange: "onWaitingRoomFilterChange", updateWaitingList: "updateWaitingList", onWaitingRoomItemPress: "onWaitingRoomItemPress" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"isWaitingModalVisible\" [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">\r\n        Waiting <span class=\"badge\">{{ waitingRoomCounter_s }}</span>\r\n      </div>\r\n      <div (click)=\"handleModalClose()\" class=\"btn-close-waitings\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <input\r\n          class=\"form-control\"\r\n          [ngStyle]=\"inputStyle\"\r\n          placeholder=\"Search ...\"\r\n          (input)=\"handleFilterChange($event)\"\r\n        />\r\n      </div>\r\n      <div class=\"waiting-list\">\r\n        <div\r\n          *ngFor=\"let participant of waitingRoomList_s\"\r\n          class=\"waiting-item\"\r\n        >\r\n          <div class=\"col7\">{{ participant.name }}</div>\r\n          <div class=\"col2\">\r\n            <button (click)=\"handleItemPress(participant, true)\">\r\n              <fa-icon [icon]=\"faCheck\" size=\"lg\" color=\"green\"></fa-icon>\r\n            </button>\r\n          </div>\r\n          <div class=\"col2\">\r\n            <button (click)=\"handleItemPress(participant, false)\">\r\n              <fa-icon [icon]=\"faTimes\" size=\"lg\" color=\"red\"></fa-icon>\r\n            </button>\r\n          </div>\r\n          <div class=\"col1\"></div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;max-height:65%;overflow-y:auto;top:10px;right:10px;width:80vw;max-width:350px}.form-control{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}.modal-header{display:flex;justify-content:space-between;align-items:center}.modal-title{font-size:1.2em}.badge{background-color:#fff;color:#000;border-radius:10px;padding:5px}.btn-close-waitings{cursor:pointer}.waiting-list{display:flex;flex-direction:column}.waiting-item{display:flex;flex-direction:row;margin-top:5px}.col7{flex:5;display:flex;align-items:center}.col2{flex:2;display:flex;align-items:center;justify-content:center}.col1{flex:1}.hr{margin:.5em 0;border:0;border-top:1px solid #ccc}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { kind: "ngmodule", type: FormsModule }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: WaitingRoomModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-waiting-room-modal', imports: [CommonModule, FontAwesomeModule, FormsModule], template: "<div *ngIf=\"isWaitingModalVisible\" [ngStyle]=\"modalContainerStyle\">\r\n  <div [ngStyle]=\"modalContentStyle\">\r\n    <div class=\"modal-header\">\r\n      <div class=\"modal-title\">\r\n        Waiting <span class=\"badge\">{{ waitingRoomCounter_s }}</span>\r\n      </div>\r\n      <div (click)=\"handleModalClose()\" class=\"btn-close-waitings\">\r\n        <fa-icon [icon]=\"faTimes\" class=\"icon\"></fa-icon>\r\n      </div>\r\n    </div>\r\n    <hr class=\"hr\" />\r\n    <div class=\"modal-body\">\r\n      <div class=\"form-group\">\r\n        <input\r\n          class=\"form-control\"\r\n          [ngStyle]=\"inputStyle\"\r\n          placeholder=\"Search ...\"\r\n          (input)=\"handleFilterChange($event)\"\r\n        />\r\n      </div>\r\n      <div class=\"waiting-list\">\r\n        <div\r\n          *ngFor=\"let participant of waitingRoomList_s\"\r\n          class=\"waiting-item\"\r\n        >\r\n          <div class=\"col7\">{{ participant.name }}</div>\r\n          <div class=\"col2\">\r\n            <button (click)=\"handleItemPress(participant, true)\">\r\n              <fa-icon [icon]=\"faCheck\" size=\"lg\" color=\"green\"></fa-icon>\r\n            </button>\r\n          </div>\r\n          <div class=\"col2\">\r\n            <button (click)=\"handleItemPress(participant, false)\">\r\n              <fa-icon [icon]=\"faTimes\" size=\"lg\" color=\"red\"></fa-icon>\r\n            </button>\r\n          </div>\r\n          <div class=\"col1\"></div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-container{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#00000080;display:block;z-index:999}.modal-content{position:fixed;border-radius:10px;padding:10px;max-height:65%;overflow-y:auto;top:10px;right:10px;width:80vw;max-width:350px}.form-control{width:90%;padding:10px;border-radius:5px;border:1px solid #000;font-size:16px;margin-bottom:10px}.modal-header{display:flex;justify-content:space-between;align-items:center}.modal-title{font-size:1.2em}.badge{background-color:#fff;color:#000;border-radius:10px;padding:5px}.btn-close-waitings{cursor:pointer}.waiting-list{display:flex;flex-direction:column}.waiting-item{display:flex;flex-direction:row;margin-top:5px}.col7{flex:5;display:flex;align-items:center}.col2{flex:2;display:flex;align-items:center;justify-content:center}.col1{flex:1}.hr{margin:.5em 0;border:0;border-top:1px solid #ccc}\n"] }]
        }], ctorParameters: () => [{ type: RespondToWaiting }], propDecorators: { isWaitingModalVisible: [{
                type: Input
            }], waitingRoomCounter: [{
                type: Input
            }], waitingRoomList: [{
                type: Input
            }], roomName: [{
                type: Input
            }], socket: [{
                type: Input
            }], position: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], parameters: [{
                type: Input
            }], onWaitingRoomClose: [{
                type: Input
            }], onWaitingRoomFilterChange: [{
                type: Input
            }], updateWaitingList: [{
                type: Input
            }], onWaitingRoomItemPress: [{
                type: Input
            }] } });

/**
 * @component ConfigureWhiteboardModal
 * @description A modal component to configure and manage whiteboard settings and participants.
 *
 * @selector app-configure-whiteboard-modal
 * @standalone true
 * @imports [CommonModule, FontAwesomeModule]
 * @templateUrl ./configure-whiteboard-modal.component.html
 * @styleUrls ./configure-whiteboard-modal.component.css
 *
 * @example
 * ```html
 * <app-configure-whiteboard-modal
 *   [isVisible]="isWhiteboardModalVisible"
 *   [parameters]="whiteboardParameters"
 *   [backgroundColor]="'#83c0e9'"
 *   [position]="'topRight'"
 *   (onConfigureWhiteboardClose)="handleCloseModal()">
 * </app-configure-whiteboard-modal>
 * ```
 */
class ConfigureWhiteboardModal {
    isVisible = false;
    parameters = {};
    backgroundColor = '#83c0e9';
    position = 'topRight';
    onConfigureWhiteboardClose;
    faTimes = faTimes;
    faCheck = faCheck;
    faSyncAlt = faSyncAlt;
    faPlay = faPlay;
    faSave = faSave;
    participantsCopy = [];
    whiteboardLimit;
    isEditing = false;
    canStartWhiteboard = false;
    assignedParticipants = [];
    unassignedParticipants = [];
    whiteboardStarted = false;
    whiteboardEnded = false;
    socket = {};
    ngOnInit() {
        if (this.parameters && this.isVisible) {
            try {
                this.parameters = this.parameters.getUpdatedAllParams();
            }
            catch {
                /* handle error */
            }
            this.whiteboardLimit = this.parameters.itemPageLimit;
            this.whiteboardStarted = this.parameters.whiteboardStarted;
            this.whiteboardEnded = this.parameters.whiteboardEnded;
            this.checkCanStartWhiteboard();
        }
        if (this.parameters) {
            this.socket = this.parameters.socket;
            if (this.socket) {
                this.setupSocketListeners();
            }
        }
    }
    ngOnChanges(changes) {
        if (changes['parameters'] && this.parameters) {
            if (this.parameters && this.isVisible) {
                this.whiteboardLimit = this.parameters.itemPageLimit;
                this.whiteboardStarted = this.parameters.whiteboardStarted;
                this.whiteboardEnded = this.parameters.whiteboardEnded;
                this.checkCanStartWhiteboard();
            }
            this.socket = this.parameters.socket;
            if (this.socket) {
                this.setupSocketListeners();
            }
        }
        if (changes['isVisible'] && this.isVisible) {
            this.parameters = this.parameters.getUpdatedAllParams();
            if (!this.participantsCopy.length) {
                const filteredParticipants = this.parameters.participants.filter((participant) => participant.islevel != '2');
                this.participantsCopy = filteredParticipants;
                this.updateParticipantsLists();
            }
            this.checkCanStartWhiteboard();
        }
    }
    setupSocketListeners = () => {
        if (this.socket && this.socket instanceof Socket) {
            this.socket.on('whiteboardUpdated', async (data) => {
                if (this.parameters.islevel == '2' && data.members) {
                    const filteredParticipants = data.members.filter((participant) => !participant.isBanned);
                    this.participantsCopy = filteredParticipants;
                    this.updateParticipantsLists();
                }
                this.parameters.updateWhiteboardUsers(data.whiteboardUsers);
                if (data.status == 'started') {
                    this.whiteboardStarted = true;
                    this.whiteboardEnded = false;
                    this.parameters.updateWhiteboardStarted(true);
                    this.parameters.updateWhiteboardEnded(false);
                    if (this.parameters.islevel != '2') {
                        this.parameters.shareScreenStarted = true;
                        await this.parameters.onScreenChanges({ changed: true, parameters: this.parameters });
                    }
                }
                else if (data.status == 'ended') {
                    this.whiteboardEnded = true;
                    this.whiteboardStarted = false;
                    this.parameters.updateWhiteboardStarted(false);
                    this.parameters.updateWhiteboardEnded(true);
                    this.parameters.shareScreenStarted = false;
                    await this.parameters.onScreenChanges({ changed: true, parameters: this.parameters });
                    await this.parameters.prepopulateUserMedia({
                        name: this.parameters.hostLabel,
                        parameters: this.parameters,
                    });
                    await this.parameters.rePort({ restart: true, parameters: this.parameters });
                }
            });
        }
    };
    toggleParticipant = (participant, add) => {
        this.isEditing = true;
        const selectedParticipants = this.participantsCopy.filter((p) => p.useBoard);
        if (add && selectedParticipants.length >= this.whiteboardLimit - 1) {
            this.parameters.showAlert?.({
                message: `Participant limit exceeded - you can only add ${this.whiteboardLimit - 1} other participants`,
                type: 'danger',
            });
            return;
        }
        this.participantsCopy = this.participantsCopy.map((p) => p.name === participant.name ? { ...p, useBoard: add } : p);
        this.updateParticipantsLists();
    };
    validateWhiteboard() {
        const selectedParticipants = this.participantsCopy.filter((participant) => participant.useBoard);
        if (selectedParticipants.length > this.whiteboardLimit) {
            this.parameters.showAlert?.({ message: 'Participant limit exceeded', type: 'danger' });
            return false;
        }
        return true;
    }
    checkCanStartWhiteboard() {
        const isValid = this.validateWhiteboard();
        this.canStartWhiteboard = isValid;
        this.parameters.updateCanStartWhiteboard(isValid);
    }
    handleSaveWhiteboard() {
        if (this.validateWhiteboard()) {
            this.isEditing = false;
            this.canStartWhiteboard = true;
            this.parameters.updateCanStartWhiteboard(true);
            this.checkCanStartWhiteboard();
            this.parameters.showAlert?.({ message: 'Whiteboard saved successfully', type: 'success' });
        }
        else {
            this.parameters.showAlert?.({ message: 'Whiteboard validation failed', type: 'danger' });
        }
    }
    async handleStartWhiteboard() {
        const { shareScreenStarted, shared, breakOutRoomStarted, breakOutRoomEnded, roomName, socket, recordStarted, recordResumed, recordPaused, recordStopped, recordingMediaOptions, onScreenChanges, captureCanvasStream, showAlert, } = this.parameters;
        if ((shareScreenStarted || shared) && !this.whiteboardStarted) {
            showAlert?.({
                message: 'You cannot start whiteboard while screen sharing is active',
                type: 'danger',
            });
            return;
        }
        if (breakOutRoomStarted && !breakOutRoomEnded) {
            showAlert?.({
                message: 'You cannot start whiteboard while breakout rooms are active',
                type: 'danger',
            });
            return;
        }
        if (this.canStartWhiteboard) {
            const emitName = this.whiteboardStarted && !this.whiteboardEnded ? 'updateWhiteboard' : 'startWhiteboard';
            const filteredWhiteboardUsers = this.participantsCopy
                .filter((participant) => participant.useBoard)
                .map(({ name, useBoard }) => ({ name, useBoard }));
            socket.emit(emitName, { whiteboardUsers: filteredWhiteboardUsers, roomName }, async (response) => {
                if (response.success) {
                    showAlert?.({ message: 'Whiteboard active', type: 'success' });
                    this.parameters.whiteboardStarted = true;
                    this.parameters.whiteboardEnded = false;
                    this.parameters.updateWhiteboardStarted(true);
                    this.parameters.updateWhiteboardEnded(false);
                    this.parameters.updateIsConfigureWhiteboardModalVisible(false);
                    if (this.parameters.islevel != '2') {
                        this.parameters.shareScreenStarted = true;
                        await onScreenChanges({ changed: true, parameters: this.parameters });
                    }
                    if (this.parameters.islevel == '2' && (recordStarted || recordResumed)) {
                        if (!(recordPaused || recordStopped) && recordingMediaOptions == 'video') {
                            await captureCanvasStream({ parameters: this.parameters });
                        }
                    }
                }
                else {
                    showAlert?.({ message: response.reason, type: 'danger' });
                }
            });
        }
    }
    async handleStopWhiteboard() {
        const { roomName, socket, showAlert, updateWhiteboardStarted, updateWhiteboardEnded, updateIsConfigureWhiteboardModalVisible, onScreenChanges, prepopulateUserMedia, rePort, hostLabel, } = this.parameters;
        socket.emit('stopWhiteboard', { roomName }, async (response) => {
            if (response.success) {
                showAlert?.({ message: 'Whiteboard stopped', type: 'success' });
                this.parameters.whiteboardEnded = true;
                this.parameters.whiteboardStarted = false;
                updateWhiteboardStarted(false);
                updateWhiteboardEnded(true);
                updateIsConfigureWhiteboardModalVisible(false);
                this.parameters.shareScreenStarted = false;
                await onScreenChanges({ changed: true, parameters: this.parameters });
                await prepopulateUserMedia({ name: hostLabel, parameters: this.parameters });
                await rePort({ restart: true, parameters: this.parameters });
            }
            else {
                showAlert?.({ message: response.reason, type: 'danger' });
            }
        });
    }
    modalContainerStyle() {
        return {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: this.isVisible ? 'block' : 'none',
            zIndex: 999,
        };
    }
    modalContentStyle() {
        const screenWidth = window.innerWidth;
        let modalWidth = 0.7 * screenWidth;
        if (modalWidth > 400) {
            modalWidth = 400;
        }
        return {
            position: 'fixed',
            backgroundColor: this.backgroundColor,
            borderRadius: '10px',
            padding: '10px',
            width: modalWidth + 'px',
            maxWidth: modalWidth + 'px',
            maxHeight: '75%',
            overflowY: 'auto',
            overflowX: 'hidden',
            top: this.position.includes('top') ? '10px' : 'auto',
            bottom: this.position.includes('bottom') ? '10px' : 'auto',
            left: this.position.includes('Left') ? '10px' : 'auto',
            right: this.position.includes('Right') ? '10px' : 'auto',
        };
    }
    updateParticipantsLists = () => {
        this.assignedParticipants = this.participantsCopy.filter((p) => p.useBoard);
        this.unassignedParticipants = this.participantsCopy.filter((p) => !p.useBoard);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfigureWhiteboardModal, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ConfigureWhiteboardModal, isStandalone: true, selector: "app-configure-whiteboard-modal", inputs: { isVisible: "isVisible", parameters: "parameters", backgroundColor: "backgroundColor", position: "position", onConfigureWhiteboardClose: "onConfigureWhiteboardClose" }, usesOnChanges: true, ngImport: i0, template: "<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div [ngStyle]=\"modalContentStyle()\">\r\n    <div style=\"display: flex; flex-direction: column;\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">\r\n          Configure Whiteboard\r\n        </h2>\r\n        <button (click)=\"onConfigureWhiteboardClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <div class=\"modal-body\">\r\n        <div class=\"row\">\r\n          <div class=\"col-md-6 mb-3\">\r\n            <h6>Assigned</h6>\r\n            <ul class=\"list-group\" style=\"max-height: 200px; overflow-y: auto; border: 1px solid #ccc;\">\r\n              <ng-container *ngIf=\"assignedParticipants.length > 0; else noAssignedParticipants\">\r\n                <li *ngFor=\"let participant of assignedParticipants\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark mb-2 mr-2\">\r\n                  {{ participant.name }}\r\n                  <button class=\"btn btn-danger btn-sm mr-2 ml-2\" (click)=\"toggleParticipant(participant, false)\">\r\n                    <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n                  </button>\r\n                </li>\r\n              </ng-container>\r\n              <ng-template #noAssignedParticipants>\r\n                <li class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n                  None\r\n                </li>\r\n              </ng-template>\r\n            </ul>\r\n          </div>\r\n          <div class=\"col-md-6 mt-xs-3 mb-3\">\r\n            <h6>Pending</h6>\r\n            <ul class=\"list-group\" style=\"max-height: 200px; overflow-y: auto; border: 1px solid #ccc;\">\r\n              <ng-container *ngIf=\"unassignedParticipants.length > 0; else noPendingParticipants\">\r\n                <li *ngFor=\"let participant of unassignedParticipants\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark mb-2 mr-2\">\r\n                  {{ participant.name }}\r\n                  <button class=\"btn btn-primary btn-sm mr-2 ml-2\" (click)=\"toggleParticipant(participant, true)\">\r\n                    <fa-icon [icon]=\"faCheck\"></fa-icon>\r\n                  </button>\r\n                </li>\r\n              </ng-container>\r\n              <ng-template #noPendingParticipants>\r\n                <li class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n                  None\r\n                </li>\r\n              </ng-template>\r\n            </ul>\r\n          </div>\r\n        </div>\r\n      </div>\r\n      <div class=\"modal-footer\">\r\n        <button type=\"button\" class=\"btn btn-info\" (click)=\"handleSaveWhiteboard()\">\r\n          Save <fa-icon [icon]=\"faSave\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr />\r\n      <div *ngIf=\"!isEditing\">\r\n        <button *ngIf=\"canStartWhiteboard && whiteboardStarted && !whiteboardEnded\" class=\"btn btn-warning mb-2 mr-2\" (click)=\"handleStartWhiteboard()\">\r\n          Update <fa-icon [icon]=\"faSyncAlt\"></fa-icon>\r\n        </button>\r\n        <button *ngIf=\"canStartWhiteboard && !whiteboardStarted\" class=\"btn btn-success mb-2 mr-2\" (click)=\"handleStartWhiteboard()\">\r\n          Start <fa-icon [icon]=\"faPlay\"></fa-icon>\r\n        </button>\r\n        <button *ngIf=\"whiteboardStarted && !whiteboardEnded\" class=\"btn btn-danger mb-2 ml-2\" (click)=\"handleStopWhiteboard()\">\r\n          Stop <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-body{max-height:400px;overflow-y:auto}.list-group-item{cursor:pointer}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ConfigureWhiteboardModal, decorators: [{
            type: Component,
            args: [{ selector: 'app-configure-whiteboard-modal', imports: [CommonModule, FontAwesomeModule], template: "<div [ngStyle]=\"modalContainerStyle()\">\r\n  <div [ngStyle]=\"modalContentStyle()\">\r\n    <div style=\"display: flex; flex-direction: column;\">\r\n      <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\r\n        <h2 style=\"font-size: x-large; font-weight: bold; color: black;\">\r\n          Configure Whiteboard\r\n        </h2>\r\n        <button (click)=\"onConfigureWhiteboardClose()\" style=\"border: none; background: none; cursor: pointer;\">\r\n          <fa-icon [icon]=\"faTimes\" size=\"xl\" style=\"font-size: 20px; color: black;\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <div class=\"modal-body\">\r\n        <div class=\"row\">\r\n          <div class=\"col-md-6 mb-3\">\r\n            <h6>Assigned</h6>\r\n            <ul class=\"list-group\" style=\"max-height: 200px; overflow-y: auto; border: 1px solid #ccc;\">\r\n              <ng-container *ngIf=\"assignedParticipants.length > 0; else noAssignedParticipants\">\r\n                <li *ngFor=\"let participant of assignedParticipants\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark mb-2 mr-2\">\r\n                  {{ participant.name }}\r\n                  <button class=\"btn btn-danger btn-sm mr-2 ml-2\" (click)=\"toggleParticipant(participant, false)\">\r\n                    <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n                  </button>\r\n                </li>\r\n              </ng-container>\r\n              <ng-template #noAssignedParticipants>\r\n                <li class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n                  None\r\n                </li>\r\n              </ng-template>\r\n            </ul>\r\n          </div>\r\n          <div class=\"col-md-6 mt-xs-3 mb-3\">\r\n            <h6>Pending</h6>\r\n            <ul class=\"list-group\" style=\"max-height: 200px; overflow-y: auto; border: 1px solid #ccc;\">\r\n              <ng-container *ngIf=\"unassignedParticipants.length > 0; else noPendingParticipants\">\r\n                <li *ngFor=\"let participant of unassignedParticipants\" class=\"list-group-item d-flex justify-content-between align-items-center text-dark mb-2 mr-2\">\r\n                  {{ participant.name }}\r\n                  <button class=\"btn btn-primary btn-sm mr-2 ml-2\" (click)=\"toggleParticipant(participant, true)\">\r\n                    <fa-icon [icon]=\"faCheck\"></fa-icon>\r\n                  </button>\r\n                </li>\r\n              </ng-container>\r\n              <ng-template #noPendingParticipants>\r\n                <li class=\"list-group-item d-flex justify-content-between align-items-center text-dark\">\r\n                  None\r\n                </li>\r\n              </ng-template>\r\n            </ul>\r\n          </div>\r\n        </div>\r\n      </div>\r\n      <div class=\"modal-footer\">\r\n        <button type=\"button\" class=\"btn btn-info\" (click)=\"handleSaveWhiteboard()\">\r\n          Save <fa-icon [icon]=\"faSave\"></fa-icon>\r\n        </button>\r\n      </div>\r\n      <hr />\r\n      <div *ngIf=\"!isEditing\">\r\n        <button *ngIf=\"canStartWhiteboard && whiteboardStarted && !whiteboardEnded\" class=\"btn btn-warning mb-2 mr-2\" (click)=\"handleStartWhiteboard()\">\r\n          Update <fa-icon [icon]=\"faSyncAlt\"></fa-icon>\r\n        </button>\r\n        <button *ngIf=\"canStartWhiteboard && !whiteboardStarted\" class=\"btn btn-success mb-2 mr-2\" (click)=\"handleStartWhiteboard()\">\r\n          Start <fa-icon [icon]=\"faPlay\"></fa-icon>\r\n        </button>\r\n        <button *ngIf=\"whiteboardStarted && !whiteboardEnded\" class=\"btn btn-danger mb-2 ml-2\" (click)=\"handleStopWhiteboard()\">\r\n          Stop <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".modal-body{max-height:400px;overflow-y:auto}.list-group-item{cursor:pointer}\n"] }]
        }], propDecorators: { isVisible: [{
                type: Input
            }], parameters: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], position: [{
                type: Input
            }], onConfigureWhiteboardClose: [{
                type: Input
            }] } });

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Whiteboard component for drawing and manipulating shapes, text, and images on a canvas.
 *
 * @component
 * @selector app-whiteboard
 * @templateUrl ./whiteboard.component.html
 * @styleUrls ./whiteboard.component.css
 * @encapsulation ViewEncapsulation.None
 * @imports [CommonModule, FormsModule, FontAwesomeModule]
 *
 * @class Whiteboard
 * @implements OnInit, OnDestroy, OnChanges
 *
 * @property {number} customWidth - Custom width for the whiteboard.
 * @property {number} customHeight - Custom height for the whiteboard.
 * @property {WhiteboardParameters} parameters - Parameters for the whiteboard.
 * @property {boolean} showAspect - Flag to show aspect ratio.
 *
 * @property {ElementRef<HTMLCanvasElement>} canvasRef - Reference to the canvas element.
 * @property {ElementRef<HTMLTextAreaElement>} textInputRef - Reference to the text input element.
 * @property {ElementRef<HTMLButtonElement>} toggleBackgroundRef - Reference to the toggle background button element.
 * @property {ElementRef<HTMLAnchorElement>} downloadLinkRef - Reference to the download link element.
 * @property {ElementRef<HTMLCanvasElement>} tempCanvasRef - Reference to the temporary canvas element.
 *
 * @property {IconDefinition} faTimes - FontAwesome icon for times.
 * @property {IconDefinition} faUndo - FontAwesome icon for undo.
 * @property {IconDefinition} faRedo - FontAwesome icon for redo.
 * @property {IconDefinition} faEraser - FontAwesome icon for eraser.
 * @property {IconDefinition} faShapes - FontAwesome icon for shapes.
 * @property {IconDefinition} faMousePointer - FontAwesome icon for mouse pointer.
 * @property {IconDefinition} faHandPaper - FontAwesome icon for hand paper.
 * @property {IconDefinition} faTextHeight - FontAwesome icon for text height.
 * @property {IconDefinition} faFont - FontAwesome icon for font.
 * @property {IconDefinition} faPencilAlt - FontAwesome icon for pencil alt.
 * @property {IconDefinition} faPaintBrush - FontAwesome icon for paint brush.
 * @property {IconDefinition} faTrash - FontAwesome icon for trash.
 * @property {IconDefinition} faSave - FontAwesome icon for save.
 * @property {IconDefinition} faSearch - FontAwesome icon for search.
 * @property {IconDefinition} faSearchMinus - FontAwesome icon for search minus.
 * @property {IconDefinition} faSearchPlus - FontAwesome icon for search plus.
 * @property {IconDefinition} faChevronLeft - FontAwesome icon for chevron left.
 * @property {IconDefinition} faUpload - FontAwesome icon for upload.
 * @property {IconDefinition} faChevronRight - FontAwesome icon for chevron right.
 *
 * @property {string} mode - Current mode of the whiteboard (e.g., 'pan', 'draw', 'erase').
 * @property {boolean} isDrawing - Flag indicating if drawing is in progress.
 * @property {boolean} isPanning - Flag indicating if panning is in progress.
 * @property {boolean} isDragging - Flag indicating if dragging is in progress.
 * @property {number} startX - Starting X coordinate for drawing.
 * @property {number} startY - Starting Y coordinate for drawing.
 * @property {number} currentX - Current X coordinate for drawing.
 * @property {number} currentY - Current Y coordinate for drawing.
 * @property {any[]} freehandDrawing - Array of points for freehand drawing.
 * @property {any} selectedShape - Currently selected shape.
 * @property {any} selectedHandle - Currently selected handle for resizing shapes.
 * @property {boolean} movingShape - Flag indicating if a shape is being moved.
 * @property {number} panX - X coordinate for panning.
 * @property {number} panY - Y coordinate for panning.
 * @property {number} scale - Current scale of the canvas.
 * @property {number} minScale - Minimum scale of the canvas.
 * @property {number} maxScale - Maximum scale of the canvas.
 * @property {number} eraserThickness - Thickness of the eraser.
 * @property {number} brushThickness - Thickness of the brush.
 * @property {number} lineThickness - Thickness of the line.
 * @property {string} lineType - Type of the line (e.g., 'solid', 'dashed').
 * @property {string} color - Current color for drawing.
 * @property {string} font - Current font for text.
 * @property {number} fontSize - Current font size for text.
 * @property {any} shape - Current shape being drawn.
 * @property {HTMLImageElement} backgroundImage - Background image for the canvas.
 * @property {boolean} toolbarVisible - Flag indicating if the toolbar is visible.
 * @property {string | null} dropdownOpen - Currently open dropdown menu.
 * @property {{ clientX: number, clientY: number, offsetX: number, offsetY: number } | null} currentClickPosition - Current click position on the canvas.
 * @property {number} maxWidth - Maximum width of the canvas.
 * @property {number} maxHeight - Maximum height of the canvas.
 * @property {boolean} dimensionsFixed - Flag indicating if the canvas dimensions are fixed.
 *
 * @method updateLineThickness - Updates the thickness of the line.
 * @param {number} thickness - New thickness for the line.
 *
 * @method updateBrushThickness - Updates the thickness of the brush.
 * @param {number} thickness - New thickness for the brush.
 *
 * @method updateEraserThickness - Updates the thickness of the eraser.
 * @param {number} thickness - New thickness for the eraser.
 *
 * @method updateColor - Updates the color for drawing.
 * @param {string} color - New color for drawing.
 *
 * @method updateFont - Updates the font for text.
 * @param {string} font - New font for text.
 *
 * @method updateFontSize - Updates the font size for text.
 * @param {number} fontSize - New font size for text.
 *
 * @method updateShape - Updates the shape being drawn.
 * @param {string} shape - New shape to be drawn.
 *
 * @constructor
 *
 * @method ngOnInit - Lifecycle hook that is called after data-bound properties are initialized.
 *
 * @method ngOnChanges - Lifecycle hook that is called when any data-bound property of a directive changes.
 * @param {SimpleChanges} changes - Object of changes.
 *
 * @method ngOnDestroy - Lifecycle hook that is called when a directive, pipe, or service is destroyed.
 *
 * @method ngAfterViewInit - Lifecycle hook that is called after a component's view has been fully initialized.
 *
 * @method handleTextInput - Handles the text input event.
 * @param {KeyboardEvent} event - Keyboard event.
 *
 * @method addListeners - Adds event listeners to the canvas and document.
 *
 * @method handleTouchStart - Handles the touch start event.
 * @param {TouchEvent} e - Touch event.
 *
 * @method handleTouchMove - Handles the touch move event.
 * @param {TouchEvent} e - Touch event.
 *
 * @method handleTouchEnd - Handles the touch end event.
 * @param {TouchEvent} e - Touch event.
 *
 * @method handleClickOutside - Handles the click outside event.
 * @param {MouseEvent} event - Mouse event.
 *
 * @method handleCanvasClick - Handles the canvas click event.
 * @param {MouseEvent} e - Mouse event.
 *
 * @method startDrawing - Starts the drawing process.
 * @param {MouseEvent} e - Mouse event.
 *
 * @method draw - Draws on the canvas.
 * @param {MouseEvent} e - Mouse event.
 *
 * @method stopDrawing - Stops the drawing process.
 * @param {MouseEvent} e - Mouse event.
 *
 * @method erase - Erases a part of the canvas.
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 *
 * @method isPointNearLine - Checks if a point is near a line.
 * @param {number} px - X coordinate of the point.
 * @param {number} py - Y coordinate of the point.
 * @param {number} x1 - X coordinate of the line start.
 * @param {number} y1 - Y coordinate of the line start.
 * @param {number} x2 - X coordinate of the line end.
 * @param {number} y2 - Y coordinate of the line end.
 * @param {number} threshold - Distance threshold.
 * @returns {boolean} - True if the point is near the line, false otherwise.
 *
 * @method zoomCanvas - Zooms the canvas.
 * @param {number} scaleFactor - Scale factor for zooming.
 * @param {MouseEvent} [event] - Mouse event.
 *
 * @method handleZoom - Handles the zoom event.
 * @param {WheelEvent} e - Wheel event.
 *
 * @method drawEdgeMarkers - Draws edge markers on the canvas.
 *
 * @method drawShapes - Draws all shapes on the canvas.
 *
 * @method drawLine - Draws a line on the canvas.
 * @param {number} x1 - X coordinate of the line start.
 * @param {number} y1 - Y coordinate of the line start.
 * @param {number} x2 - X coordinate of the line end.
 * @param {number} y2 - Y coordinate of the line end.
 * @param {string} color - Color of the line.
 * @param {number} thickness - Thickness of the line.
 * @param {string} lineType - Type of the line (e.g., 'solid', 'dashed').
 *
 * @method drawText - Draws text on the canvas.
 * @param {string} text - Text to be drawn.
 * @param {number} x - X coordinate of the text.
 * @param {number} y - Y coordinate of the text.
 * @param {string} color - Color of the text.
 * @param {string} font - Font of the text.
 *
 * @method drawFreehand - Draws freehand lines on the canvas.
 * @param {{ x: number, y: number }[]} points - Array of points for freehand drawing.
 * @param {string} color - Color of the freehand drawing.
 * @param {number} thickness - Thickness of the freehand drawing.
 *
 * @method drawShape - Draws a shape on the canvas.
 * @param {string} type - Type of the shape.
 * @param {number} x1 - X coordinate of the shape start.
 * @param {number} y1 - Y coordinate of the shape start.
 * @param {number} x2 - X coordinate of the shape end.
 * @param {number} y2 - Y coordinate of the shape end.
 * @param {string} color - Color of the shape.
 * @param {number} thickness - Thickness of the shape.
 * @param {string} lineType - Type of the line (e.g., 'solid', 'dashed').
 * @param {CanvasRenderingContext2D} [ctx] - Canvas rendering context.
 *
 * @method drawPolygon - Draws a polygon on the canvas.
 * @param {CanvasRenderingContext2D} ctx - Canvas rendering context.
 * @param {number} sides - Number of sides of the polygon.
 * @param {number} x1 - X coordinate of the polygon start.
 * @param {number} y1 - Y coordinate of the polygon start.
 * @param {number} x2 - X coordinate of the polygon end.
 * @param {number} y2 - Y coordinate of the polygon end.
 *
 * @example
 * ```html
 * <app-whiteboard
 *  [customWidth]="1280"
 * [customHeight]="720"
 * [parameters]="{
 *  socket: socket,
 * showAlert: showAlert,
 * islevel: islevel,
 * roomName: roomName,
 * shapes: shapes,
 * useImageBackground: useImageBackground,
 * redoStack: redoStack,
 * undoStack: undoStack,
 * whiteboardStarted: whiteboardStarted,
 * whiteboardEnded: whiteboardEnded,
 * whiteboardUsers: whiteboardUsers,
 * participants: participants,
 * participantsAll: participantsAll,
 * screenId: screenId,
 * recordStarted: recordStarted,
 * recordStopped: recordStopped,
 * recordPaused: recordPaused,
 * recordResumed: recordResumed,
 * recordingMediaOptions: recordingMediaOptions,
 * member: member,
 * shareScreenStarted: shareScreenStarted,
 * canvasWhiteboard: canvasWhiteboard,
 * targetResolution: targetResolution,
 * targetResolutionHost: targetResolutionHost,
 * updateShapes: updateShapes,
 * updateUseImageBackground: updateUseImageBackground,
 * updateRedoStack: updateRedoStack,
 * updateUndoStack: updateUndoStack,
 * updateWhiteboardStarted: updateWhiteboardStarted,
 * updateWhiteboardEnded: updateWhiteboardEnded,
 * updateWhiteboardUsers: updateWhiteboardUsers,
 * updateParticipants: updateParticipants,
 * updateScreenId: updateScreenId,
 * updateShareScreenStarted: updateShareScreenStarted,
 * updateCanvasWhiteboard: updateCanvasWhiteboard,
 * onScreenChanges: onScreenChanges,
 * captureCanvasStream: captureCanvasStream,
 * getUpdatedAllParams: getUpdatedAllParams
 * }"
 * [showAspect]="true"
 * ></app-whiteboard>
 * ```
 */
class Whiteboard {
    customWidth;
    customHeight;
    parameters = {};
    showAspect;
    canvasRef;
    textInputRef;
    toggleBackgroundRef;
    downloadLinkRef;
    tempCanvasRef;
    faTimes = faTimes;
    faUndo = faUndo;
    faRedo = faRedo;
    faEraser = faEraser;
    faShapes = faShapes;
    faMousePointer = faMousePointer;
    faHandPaper = faHandPaper;
    faTextHeight = faTextHeight;
    faFont = faFont;
    faPencilAlt = faPencilAlt;
    faPaintBrush = faPaintBrush;
    faTrash = faTrash;
    faSave = faSave;
    faSearch = faSearch;
    faSearchMinus = faSearchMinus;
    faSearchPlus = faSearchPlus;
    faChevronLeft = faChevronLeft;
    faUpload = faUpload;
    faChevronRight = faChevronRight;
    mode = 'pan';
    isDrawing = false;
    isPanning = false;
    isDragging = false;
    startX = 0;
    startY = 0;
    currentX = 0;
    currentY = 0;
    freehandDrawing = [];
    selectedShape = null;
    selectedHandle = null;
    movingShape = false;
    panX = 0;
    panY = 0;
    scale = 1;
    minScale = 0.25;
    maxScale = 1.75;
    eraserThickness = 10;
    brushThickness = 6;
    lineThickness = 6;
    lineType = 'solid';
    color = '#000000';
    font = 'Arial';
    fontSize = 20;
    shape = null;
    backgroundImage = new Image();
    toolbarVisible = true;
    dropdownOpen = null;
    currentClickPosition = null;
    maxWidth = 1280;
    maxHeight = 720;
    dimensionsFixed = false;
    isValidShape = false;
    updateLineThickness = (thickness) => {
        this.lineThickness = thickness;
    };
    updateBrushThickness = (thickness) => {
        this.brushThickness = thickness;
    };
    updateEraserThickness = (thickness) => {
        this.eraserThickness = thickness;
    };
    updateColor = (color) => {
        this.color = color;
    };
    updateFont = (font) => {
        this.font = font;
    };
    updateFontSize = (fontSize) => {
        this.fontSize = fontSize;
    };
    updateShape = (shape) => {
        this.shape = shape;
    };
    ngOnInit() {
        if (this.showAspect) {
            this.addListeners();
        }
    }
    ngOnChanges(changes) {
        if (changes['parameters'] && changes['parameters'].currentValue) {
            this.parameters = changes['parameters'].currentValue;
            if (this.parameters.socket instanceof Socket) {
                this.parameters.socket.on('whiteboardUpdated', async (data) => {
                    this.WhiteboardUpdated(data);
                });
                this.parameters.socket.on('whiteboardAction', (data) => {
                    this.WhiteboardAction(data);
                });
            }
        }
        if (changes['showAspect']) {
            if (changes['showAspect'].currentValue) {
                this.addListeners();
            }
        }
    }
    ngOnDestroy() {
        const canvas = this.canvasRef.nativeElement;
        canvas.removeEventListener('mousedown', this.startDrawing.bind(this));
        canvas.removeEventListener('mousemove', this.draw.bind(this));
        canvas.removeEventListener('mouseup', this.stopDrawing.bind(this));
        canvas.removeEventListener('wheel', this.handleZoom.bind(this));
        canvas.removeEventListener('click', this.handleCanvasClick.bind(this));
        // touch events
        canvas.removeEventListener('touchstart', this.handleTouchStart.bind(this));
        canvas.removeEventListener('touchmove', this.handleTouchMove.bind(this));
        canvas.removeEventListener('touchend', this.handleTouchEnd.bind(this));
        document.removeEventListener('mousedown', this.handleClickOutside.bind(this));
    }
    ngAfterViewInit() {
        // Attach the event listener once after the view has been initialized
        const textInput = this.textInputRef.nativeElement;
        textInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                this.handleTextInput(event);
            }
        });
    }
    handleTextInput(event) {
        const textInput = this.textInputRef.nativeElement;
        if (event.key === 'Enter' && this.currentClickPosition) {
            const { offsetX, offsetY } = this.currentClickPosition;
            const text = textInput.value;
            textInput.style.display = 'none';
            textInput.value = '';
            const x = (offsetX - this.panX) / this.scale;
            const y = (offsetY - this.panY) / this.scale;
            this.parameters.shapes.push({
                type: 'text',
                text,
                x,
                y,
                color: this.color,
                font: this.font,
                fontSize: this.fontSize,
            });
            this.drawShapes();
            this.parameters.updateShapes(this.parameters.shapes);
            this.parameters.socket.emit('updateBoardAction', {
                action: 'text',
                payload: {
                    type: 'text',
                    text,
                    x,
                    y,
                    color: this.color,
                    font: this.font,
                    fontSize: this.fontSize,
                },
            }, this.handleServerResponse);
        }
    }
    addListeners = () => {
        if (this.parameters) {
            this.parameters = this.parameters.getUpdatedAllParams();
        }
        this.backgroundImage.src = 'https://mediasfu.com/images/svg/graph_paper.jpg';
        this.backgroundImage.crossOrigin = 'anonymous';
        this.backgroundImage.onload = () => {
            this.drawShapes();
        };
        const canvas = this.canvasRef.nativeElement;
        if (this.canvasRef.nativeElement) {
            try {
                if (this.parameters.targetResolution == 'qhd' ||
                    this.parameters.targetResolutionHost == 'qhd') {
                    this.maxWidth = 1920;
                    this.maxHeight = 1080;
                }
                else if (this.parameters.targetResolution == 'fhd' ||
                    this.parameters.targetResolutionHost == 'fhd') {
                    this.maxWidth = 1920;
                    this.maxHeight = 1080;
                }
                canvas.width = this.maxWidth;
                canvas.height = this.maxHeight;
                this.dimensionsFixed = true;
            }
            catch {
                /* handle error */
            }
            this.parameters.updateCanvasWhiteboard(this.canvasRef.nativeElement);
        }
        canvas.addEventListener('mousedown', this.startDrawing.bind(this));
        canvas.addEventListener('mousemove', this.draw.bind(this));
        canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
        canvas.addEventListener('wheel', this.handleZoom.bind(this));
        canvas.addEventListener('click', this.handleCanvasClick.bind(this));
        // touch events
        canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
        canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
        canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
        document.addEventListener('mousedown', this.handleClickOutside.bind(this));
    };
    handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY,
        });
        this.canvasRef.nativeElement.dispatchEvent(mouseEvent);
    }
    handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY,
        });
        this.canvasRef.nativeElement.dispatchEvent(mouseEvent);
    }
    handleTouchEnd(e) {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        this.canvasRef.nativeElement.dispatchEvent(mouseEvent);
    }
    handleClickOutside(event) {
        const target = event.target;
        if (this.dropdownOpen && !target.closest('.btn-group')) {
            this.dropdownOpen = null;
        }
    }
    handleCanvasClick(e) {
        if (this.mode === 'text') {
            const textInput = this.textInputRef.nativeElement;
            textInput.style.left = e.clientX + 'px';
            textInput.style.top = e.clientY + 'px';
            textInput.style.display = 'block';
            textInput.focus();
            this.currentClickPosition = {
                clientX: e.clientX,
                clientY: e.clientY,
                offsetX: e.offsetX,
                offsetY: e.offsetY,
            };
        }
    }
    startDrawing(e) {
        this.isDrawing = true;
        this.startX = (e.offsetX - this.panX) / this.scale;
        this.startY = (e.offsetY - this.panY) / this.scale;
        if (this.mode === 'erase') {
            this.erase(this.startX, this.startY);
        }
        else if (this.mode === 'draw' || this.mode === 'freehand') {
            const ctx = this.canvasRef.nativeElement.getContext('2d');
            ctx.beginPath();
            ctx.moveTo(this.startX, this.startY);
            if (this.mode === 'freehand') {
                this.freehandDrawing = [{ x: this.startX, y: this.startY }];
            }
        }
        else if (this.mode === 'pan') {
            this.isPanning = true;
            this.isDragging = false;
        }
        else if (this.mode === 'select') {
            this.selectedHandle = this.getHandleAtPosition(this.startX, this.startY);
            if (this.selectedHandle) {
                this.isDragging = true;
                this.movingShape = this.selectedHandle.isCenter;
            }
            else {
                this.selectedShape = this.findShape(this.startX, this.startY);
                if (this.selectedShape) {
                    this.drawShapes();
                    this.drawSelection(this.selectedShape);
                }
            }
        }
    }
    draw = (e) => {
        if (!this.dimensionsFixed) {
            try {
                if (this.parameters.targetResolution == 'qhd' ||
                    this.parameters.targetResolutionHost == 'qhd') {
                    this.maxWidth = 1920;
                    this.maxHeight = 1080;
                }
                else if (this.parameters.targetResolution == 'fhd' ||
                    this.parameters.targetResolutionHost == 'fhd') {
                    this.maxWidth = 1920;
                    this.maxHeight = 1080;
                }
                this.canvasRef.nativeElement.width = this.maxWidth;
                this.canvasRef.nativeElement.height = this.maxHeight;
                this.dimensionsFixed = true;
                this.parameters.updateCanvasWhiteboard(this.canvasRef.nativeElement);
            }
            catch {
                /* handle error */
            }
        }
        if (!this.isDrawing)
            return;
        this.currentX = (e.offsetX - this.panX) / this.scale;
        this.currentY = (e.offsetY - this.panY) / this.scale;
        if (this.mode == 'draw' || this.mode == 'freehand' || this.mode == 'shape') {
            //if more than max width or height or less than 0, return
            if (this.currentX > this.maxWidth ||
                this.currentY > this.maxHeight ||
                this.currentX < 0 ||
                this.currentY < 0) {
                this.isValidShape = false;
                return;
            }
            else {
                this.isValidShape = true;
            }
        }
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        if (this.mode === 'erase') {
            this.erase(this.currentX, this.currentY);
        }
        else if (this.mode === 'draw') {
            ctx.clearRect(0, 0, this.canvasRef.nativeElement.width, this.canvasRef.nativeElement.height);
            this.drawShapes();
            this.drawLine(this.startX, this.startY, this.currentX, this.currentY, this.color, this.lineThickness, this.lineType);
        }
        else if (this.mode === 'freehand') {
            ctx.lineTo(this.currentX, this.currentY);
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.brushThickness;
            ctx.stroke();
            this.freehandDrawing.push({ x: this.currentX, y: this.currentY });
        }
        else if (this.mode === 'shape') {
            ctx.clearRect(0, 0, this.canvasRef.nativeElement.width, this.canvasRef.nativeElement.height);
            this.drawShapes();
            this.drawShape(this.shape, this.startX, this.startY, this.currentX, this.currentY, this.color, this.lineThickness, this.lineType);
        }
        else if (this.mode === 'pan' && this.isPanning) {
            this.isDragging = true;
            const dx = e.clientX - this.startX;
            const dy = e.clientY - this.startY;
            this.panX += dx;
            this.panY += dy;
            this.startX = e.clientX;
            this.startY = e.clientY;
            ctx.setTransform(this.scale, 0, 0, this.scale, this.panX, this.panY);
            this.drawShapes();
        }
        else if (this.mode === 'select' && this.selectedShape) {
            ctx.clearRect(0, 0, this.canvasRef.nativeElement.width, this.canvasRef.nativeElement.height);
            if (this.movingShape) {
                const dx = this.currentX - this.startX;
                const dy = this.currentY - this.startY;
                this.moveShape(this.selectedShape, dx, dy);
                this.startX = this.currentX;
                this.startY = this.currentY;
            }
            else if (this.isDragging) {
                this.resizeShape(this.selectedShape, this.selectedHandle, this.currentX, this.currentY);
            }
            this.drawShapes();
            this.drawSelection(this.selectedShape);
        }
    };
    stopDrawing() {
        this.isDrawing = false;
        this.isPanning = false;
        this.isDragging = false;
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        ctx.closePath();
        if (this.mode === 'draw' && this.isValidShape) {
            this.parameters.shapes.push({
                type: 'line',
                x1: this.startX,
                y1: this.startY,
                x2: this.currentX,
                y2: this.currentY,
                color: this.color,
                thickness: this.lineThickness,
                lineType: this.lineType,
            });
            this.parameters.updateShapes(this.parameters.shapes);
            this.saveState();
            this.parameters.socket.emit('updateBoardAction', {
                action: 'draw',
                payload: {
                    type: 'line',
                    x1: this.startX,
                    y1: this.startY,
                    x2: this.currentX,
                    y2: this.currentY,
                    color: this.color,
                    thickness: this.lineThickness,
                    lineType: this.lineType,
                },
            }, this.handleServerResponse);
        }
        else if (this.mode === 'freehand' && this.isValidShape) {
            this.parameters.shapes.push({
                type: 'freehand',
                points: this.freehandDrawing,
                color: this.color,
                thickness: this.brushThickness,
            });
            this.parameters.updateShapes(this.parameters.shapes);
            this.parameters.socket.emit('updateBoardAction', {
                action: 'draw',
                payload: {
                    type: 'freehand',
                    points: this.freehandDrawing,
                    color: this.color,
                    thickness: this.brushThickness,
                },
            }, this.handleServerResponse);
            this.freehandDrawing = [];
            this.saveState();
        }
        else if (this.mode === 'shape' && this.isValidShape) {
            this.parameters.shapes.push({
                type: this.shape,
                x1: this.startX,
                y1: this.startY,
                x2: this.currentX,
                y2: this.currentY,
                color: this.color,
                thickness: this.lineThickness,
                lineType: this.lineType,
            });
            this.parameters.updateShapes(this.parameters.shapes);
            this.saveState();
            this.parameters.socket.emit('updateBoardAction', {
                action: 'shape',
                payload: {
                    type: this.shape,
                    x1: this.startX,
                    y1: this.startY,
                    x2: this.currentX,
                    y2: this.currentY,
                    color: this.color,
                    thickness: this.lineThickness,
                    lineType: this.lineType,
                },
            }, this.handleServerResponse);
        }
        else if (this.mode === 'select') {
            if (this.selectedShape && !this.movingShape && !this.isDragging) {
                const shapeFound = this.findShape(this.currentX, this.currentY);
                if (shapeFound) {
                    this.selectedShape = shapeFound;
                    this.drawShapes();
                    this.drawSelection(shapeFound);
                }
            }
            if (this.selectedShape) {
                this.parameters.socket.emit('updateBoardAction', { action: 'shapes', payload: { shapes: this.parameters.shapes } }, this.handleServerResponse);
            }
            this.saveState();
        }
    }
    erase(x, y) {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(x, y, this.eraserThickness / 2, 0, Math.PI * 2, false);
        ctx.fill();
        ctx.restore();
        let changeOccurred = false;
        this.parameters.shapes = this.parameters.shapes
            .map((shape) => {
            if (shape.type === 'freehand') {
                return {
                    ...shape,
                    points: shape.points.filter((point) => {
                        const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                        if (distance <= this.eraserThickness / 2) {
                            changeOccurred = true;
                            return false;
                        }
                        return distance > this.eraserThickness / 2;
                    }),
                };
            }
            else if (shape.type === 'line') {
                if (this.isPointNearLine(x, y, shape.x1, shape.y1, shape.x2, shape.y2, this.eraserThickness / 2)) {
                    changeOccurred = true;
                    return null;
                }
            }
            else if (shape.type === 'text') {
                const textWidth = ctx.measureText(shape.text).width;
                if (x > shape.x &&
                    x < shape.x + textWidth &&
                    y > shape.y - shape.fontSize &&
                    y < shape.y) {
                    changeOccurred = true;
                    return null;
                }
            }
            else if (shape.type === 'image') {
                if (x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2) {
                    changeOccurred = true;
                    return null;
                }
            }
            else {
                if (x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2) {
                    changeOccurred = true;
                    return null;
                }
            }
            return shape;
        })
            .filter((shape) => shape && (shape.type !== 'freehand' || shape.points.length > 0));
        this.parameters.updateShapes(this.parameters.shapes);
        this.drawShapes();
        if (changeOccurred) {
            this.parameters.socket.emit('updateBoardAction', { action: 'shapes', payload: { shapes: this.parameters.shapes } }, this.handleServerResponse);
        }
    }
    isPointNearLine(px, py, x1, y1, x2, y2, threshold) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        const dot = ((px - x1) * dx + (py - y1) * dy) / (length * length);
        const closestX = x1 + dot * dx;
        const closestY = y1 + dot * dy;
        const distance = Math.sqrt(Math.pow(px - closestX, 2) + Math.pow(py - closestY, 2));
        return distance <= threshold;
    }
    zoomCanvas(scaleFactor, event = {
        clientX: this.canvasRef.nativeElement.width / 2,
        clientY: this.canvasRef.nativeElement.height / 2,
    }) {
        const canvas = this.canvasRef.nativeElement;
        const ctx = canvas.getContext('2d');
        if (scaleFactor === 10) {
            this.scale = 1;
            this.panX = 0;
            this.panY = 0;
        }
        else {
            let newScale = this.scale * scaleFactor;
            if (newScale < this.minScale) {
                newScale = this.minScale;
            }
            else if (newScale > this.maxScale) {
                newScale = this.maxScale;
            }
            const rect = canvas.getBoundingClientRect();
            const offsetX = (event.clientX - rect.left) / rect.width;
            const offsetY = (event.clientY - rect.top) / rect.height;
            const dx = offsetX * canvas.width * (1 - scaleFactor);
            const dy = offsetY * canvas.height * (1 - scaleFactor);
            this.scale = newScale;
            this.panX = this.panX * scaleFactor + dx;
            this.panY = this.panY * scaleFactor + dy;
            const maxPanX = (canvas.width * (this.scale - 1)) / this.scale;
            const maxPanY = (canvas.height * (this.scale - 1)) / this.scale;
            this.panX = Math.min(Math.max(this.panX, -maxPanX), 0);
            this.panY = Math.min(Math.max(this.panY, -maxPanY), 0);
        }
        ctx.setTransform(this.scale, 0, 0, this.scale, this.panX, this.panY);
        this.drawShapes();
    }
    handleZoom(e) {
        e.preventDefault();
        if (e.deltaY < 0) {
            this.zoomCanvas(1.2, e);
        }
        else {
            this.zoomCanvas(0.8, e);
        }
    }
    drawEdgeMarkers() {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 5;
        ctx.setLineDash([]); // reset line dash
        const markerLength = 20;
        const topLeftX = this.panX;
        const topLeftY = this.panY;
        const bottomRightX = this.panX + 1280 * this.scale;
        const bottomRightY = this.panY + 720 * this.scale;
        ctx.beginPath();
        ctx.moveTo(topLeftX, topLeftY + markerLength);
        ctx.lineTo(topLeftX, topLeftY);
        ctx.lineTo(topLeftX + markerLength, topLeftY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(bottomRightX - markerLength, topLeftY);
        ctx.lineTo(bottomRightX, topLeftY);
        ctx.lineTo(bottomRightX, topLeftY + markerLength);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(bottomRightX, bottomRightY - markerLength);
        ctx.lineTo(bottomRightX, bottomRightY);
        ctx.lineTo(bottomRightX - markerLength, bottomRightY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(topLeftX + markerLength, bottomRightY);
        ctx.lineTo(topLeftX, bottomRightY);
        ctx.lineTo(topLeftX, bottomRightY - markerLength);
        ctx.stroke();
        ctx.restore();
    }
    drawShapes() {
        const canvas = this.canvasRef.nativeElement;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.setTransform(this.scale, 0, 0, this.scale, this.panX, this.panY);
        if (this.parameters.useImageBackground) {
            ctx.drawImage(this.backgroundImage, -this.panX / this.scale, -this.panY / this.scale, canvas.width / this.scale, canvas.height / this.scale);
        }
        else {
            ctx.fillStyle = '#fff';
            ctx.fillRect(-this.panX / this.scale, -this.panY / this.scale, canvas.width / this.scale, canvas.height / this.scale);
        }
        this.parameters.shapes.forEach((shape) => {
            if (shape.type === 'line') {
                this.drawLine(shape.x1, shape.y1, shape.x2, shape.y2, shape.color, shape.thickness, shape.lineType);
            }
            else if (shape.type === 'freehand') {
                this.drawFreehand(shape.points, shape.color, shape.thickness);
            }
            else if (shape.type === 'text') {
                ctx.font = `${shape.fontSize}px ${shape.font}`;
                ctx.fillStyle = shape.color;
                ctx.fillText(shape.text, shape.x, shape.y);
            }
            else if (shape.type === 'image') {
                ctx.drawImage(shape.img, shape.x1, shape.y1, shape.x2 - shape.x1, shape.y2 - shape.y1);
            }
            else {
                this.drawShape(shape.type, shape.x1, shape.y1, shape.x2, shape.y2, shape.color, shape.thickness, shape.lineType);
            }
        });
        ctx.restore();
        this.drawEdgeMarkers();
    }
    drawLine(x1, y1, x2, y2, color, thickness, lineType) {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        if (lineType === 'dashed') {
            ctx.setLineDash([10, 10]);
        }
        else if (lineType === 'dotted') {
            ctx.setLineDash([2, 10]);
        }
        else if (lineType === 'dashDot') {
            ctx.setLineDash([10, 5, 2, 5]);
        }
        else {
            ctx.setLineDash([]);
        }
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    drawText(text, x, y, color, font) {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        ctx.font = `20px ${font}`;
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
    }
    drawFreehand(points, color, thickness) {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        if (points.length < 2)
            return;
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
    }
    drawShape(type, x1, y1, x2, y2, color, thickness, lineType, ctx = this.canvasRef.nativeElement.getContext('2d')) {
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        if (lineType === 'dashed') {
            ctx.setLineDash([10, 10]);
        }
        else if (lineType === 'dotted') {
            ctx.setLineDash([2, 10]);
        }
        else if (lineType === 'dashDot') {
            ctx.setLineDash([10, 5, 2, 5]);
        }
        else {
            ctx.setLineDash([]);
        }
        if (type === 'rectangle') {
            ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
        }
        else if (type === 'circle') {
            const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            ctx.arc(x1, y1, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }
        else if (type === 'rhombus') {
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            ctx.moveTo(centerX, y1);
            ctx.lineTo(x2, centerY);
            ctx.lineTo(centerX, y2);
            ctx.lineTo(x1, centerY);
            ctx.closePath();
            ctx.stroke();
        }
        else if (type === 'pentagon') {
            this.drawPolygon(ctx, 5, x1, y1, x2, y2);
        }
        else if (type === 'hexagon') {
            this.drawPolygon(ctx, 6, x1, y1, x2, y2);
        }
        else if (type === 'triangle') {
            const centerX = (x1 + x2) / 2;
            ctx.moveTo(centerX, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x1, y2);
            ctx.closePath();
            ctx.stroke();
        }
        else if (type === 'square') {
            ctx.strokeRect(x1, y1, x2 - x1, x2 - x1);
        }
        else if (type === 'octagon') {
            this.drawPolygon(ctx, 8, x1, y1, x2, y2);
        }
        else if (type === 'oval') {
            const radiusX = Math.abs(x2 - x1) / 2;
            const radiusY = Math.abs(y2 - y1) / 2;
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            ctx.stroke();
        }
        else if (type === 'parallelogram') {
            const centerX = (x1 + x2) / 2;
            ctx.moveTo(centerX, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(centerX, y2);
            ctx.lineTo(x1, y1);
            ctx.closePath();
            ctx.stroke();
        }
        else if (type === 'image') {
            ctx.drawImage(this.shape.img, x1, y1, x2 - x1, y2 - y1);
        }
    }
    drawPolygon(ctx, sides, x1, y1, x2, y2) {
        const centerX = (x1 + x2) / 2;
        const centerY = (y1 + y2) / 2;
        const radius = Math.min(Math.abs(x2 - x1), Math.abs(y2 - y1)) / 2;
        const angle = (2 * Math.PI) / sides;
        ctx.beginPath();
        for (let i = 0; i < sides; i++) {
            const x = centerX + radius * Math.cos(i * angle - Math.PI / 2);
            const y = centerY + radius * Math.sin(i * angle - Math.PI / 2);
            if (i === 0) {
                ctx.moveTo(x, y);
            }
            else {
                ctx.lineTo(x, y);
            }
        }
        ctx.closePath();
        ctx.stroke();
    }
    undo() {
        if (this.parameters.shapes.length > 0) {
            this.parameters.redoStack.push(this.parameters.shapes.pop());
            this.parameters.updateRedoStack(this.parameters.redoStack);
            this.drawShapes();
            this.parameters.socket.emit('updateBoardAction', { action: 'undo' }, this.handleServerResponse);
        }
    }
    redo() {
        if (this.parameters.redoStack.length > 0) {
            this.parameters.shapes.push(this.parameters.redoStack.pop());
            this.parameters.updateShapes(this.parameters.shapes);
            this.drawShapes();
            this.parameters.socket.emit('updateBoardAction', { action: 'redo' }, this.handleServerResponse);
        }
    }
    saveState() {
        this.parameters.undoStack.push(JSON.stringify(this.parameters.shapes));
        this.parameters.updateUndoStack(this.parameters.undoStack);
    }
    findShape(x, y) {
        return this.parameters.shapes.find((shape) => {
            if (shape.type === 'freehand') {
                return shape.points.some((point) => {
                    const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                    return distance < shape.thickness;
                });
            }
            else if (shape.type === 'text') {
                const ctx = this.canvasRef.nativeElement.getContext('2d');
                ctx.font = `${shape.fontSize}px ${shape.font}`;
                const textMetrics = ctx.measureText(shape.text);
                return (x > shape.x &&
                    x < shape.x + textMetrics.width &&
                    y > shape.y - shape.fontSize &&
                    y < shape.y);
            }
            else if (shape.type === 'image') {
                return x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2;
            }
            else {
                return x > shape.x1 && x < shape.x2 && y > shape.y1 && y < shape.y2;
            }
        });
    }
    drawSelection(shape) {
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        if (!shape)
            return;
        const handles = this.getResizeHandles(shape);
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 3]);
        if (shape.type === 'line') {
            ctx.beginPath();
            ctx.moveTo(shape.x1, shape.y1);
            ctx.lineTo(shape.x2, shape.y2);
            ctx.stroke();
        }
        else if (shape.type === 'circle') {
            const radius = Math.sqrt(Math.pow(shape.x2 - shape.x1, 2) + Math.pow(shape.y2 - shape.y1, 2));
            ctx.beginPath();
            ctx.arc(shape.x1, shape.y1, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }
        else {
            ctx.strokeRect(shape.x1, shape.y1, shape.x2 - shape.x1, shape.y2 - shape.y1);
        }
        ctx.setLineDash([]);
        handles.forEach((handle) => {
            ctx.fillStyle = handle.isCenter ? 'blue' : 'red';
            ctx.fillRect(handle.x - 6, handle.y - 6, 12, 12);
        });
    }
    getResizeHandles(shape) {
        const handles = [];
        if (shape.type === 'line') {
            handles.push({ x: shape.x1, y: shape.y1 });
            handles.push({ x: shape.x2, y: shape.y2 });
        }
        else if (shape.type === 'circle') {
            const radius = Math.sqrt(Math.pow(shape.x2 - shape.x1, 2) + Math.pow(shape.y2 - shape.y1, 2));
            handles.push({ x: shape.x1 + radius, y: shape.y1 });
            handles.push({ x: shape.x1 - radius, y: shape.y1 });
            handles.push({ x: shape.x1, y: shape.y1 + radius });
            handles.push({ x: shape.x1, y: shape.y1 - radius });
            handles.push({ x: shape.x1, y: shape.y1, isCenter: true });
        }
        else if (shape.type === 'text') {
            const ctx = this.canvasRef.nativeElement.getContext('2d');
            const textMetrics = ctx.measureText(shape.text);
            handles.push({ x: shape.x, y: shape.y - shape.fontSize, isCenter: true });
            handles.push({ x: shape.x + textMetrics.width, y: shape.y, isCenter: false });
        }
        else if (shape.type === 'image') {
            handles.push({ x: shape.x1, y: shape.y1 });
            handles.push({ x: shape.x2, y: shape.y1 });
            handles.push({ x: shape.x2, y: shape.y2 });
            handles.push({ x: shape.x1, y: shape.y2 });
            handles.push({ x: (shape.x1 + shape.x2) / 2, y: (shape.y1 + shape.y2) / 2, isCenter: true });
        }
        else {
            handles.push({ x: shape.x1, y: shape.y1 });
            handles.push({ x: shape.x2, y: shape.y1 });
            handles.push({ x: shape.x2, y: shape.y2 });
            handles.push({ x: shape.x1, y: shape.y2 });
            handles.push({ x: (shape.x1 + shape.x2) / 2, y: (shape.y1 + shape.y2) / 2, isCenter: true });
        }
        return handles.map((handle) => ({
            ...handle,
            isCenter: handle.isCenter || false,
        }));
    }
    getHandleAtPosition(x, y) {
        if (!this.selectedShape)
            return null;
        return this.getResizeHandles(this.selectedShape).find((handle) => {
            return Math.abs(handle.x - x) < 6 && Math.abs(handle.y - y) < 6;
        });
    }
    resizeShape(shape, handle, x, y) {
        if (shape.type === 'line') {
            if (handle.x === shape.x1 && handle.y === shape.y1) {
                shape.x1 = x;
                shape.y1 = y;
            }
            else {
                shape.x2 = x;
                shape.y2 = y;
            }
        }
        else if (shape.type === 'circle') {
            const dx = x - shape.x1;
            const dy = y - shape.y1;
            const radius = Math.sqrt(dx * dx + dy * dy);
            shape.x2 = shape.x1 + radius;
            shape.y2 = shape.y1;
        }
        else if (shape.type === 'text') {
            if (handle.isCenter) {
                shape.x = x;
                shape.y = y;
            }
            else {
                const textMetrics = this.canvasRef.nativeElement.getContext('2d').measureText(shape.text);
                shape.x = x - textMetrics.width;
                shape.y = y;
            }
        }
        else if (shape.type === 'image') {
            if (handle.isCenter) {
                const dx = x - (shape.x1 + shape.x2) / 2;
                const dy = y - (shape.y1 + shape.y2) / 2;
                this.moveShape(shape, dx, dy);
            }
            else {
                if (handle.x === shape.x1 && handle.y === shape.y1) {
                    shape.x1 = x;
                    shape.y1 = y;
                }
                else if (handle.x === shape.x2 && handle.y === shape.y1) {
                    shape.x2 = x;
                    shape.y1 = y;
                }
                else if (handle.x === shape.x2 && handle.y === shape.y2) {
                    shape.x2 = x;
                    shape.y2 = y;
                }
                else {
                    shape.x1 = x;
                    shape.y2 = y;
                }
            }
        }
        else {
            if (handle.isCenter) {
                const dx = x - (shape.x1 + shape.x2) / 2;
                const dy = y - (shape.y1 + shape.y2) / 2;
                this.moveShape(shape, dx, dy);
            }
            else {
                if (handle.x === shape.x1 && handle.y === shape.y1) {
                    shape.x1 = x;
                    shape.y1 = y;
                }
                else if (handle.x === shape.x2 && handle.y === shape.y1) {
                    shape.x2 = x;
                    shape.y1 = y;
                }
                else if (handle.x === shape.x2 && handle.y === shape.y2) {
                    shape.x2 = x;
                    shape.y2 = y;
                }
                else {
                    shape.x1 = x;
                    shape.y2 = y;
                }
            }
        }
        this.drawShapes();
    }
    moveShape(shape, dx, dy) {
        if (shape.type === 'line' || shape.type === 'circle') {
            shape.x1 += dx;
            shape.y1 += dy;
            shape.x2 += dx;
            shape.y2 += dy;
        }
        else if (shape.type === 'freehand') {
            shape.points.forEach((point) => {
                point.x += dx;
                point.y += dy;
            });
        }
        else if (shape.type === 'text') {
            shape.x += dx;
            shape.y += dy;
        }
        else if (shape.type === 'image') {
            shape.x1 += dx;
            shape.y1 += dy;
            shape.x2 += dx;
            shape.y2 += dy;
        }
        else {
            shape.x1 += dx;
            shape.y1 += dy;
            shape.x2 += dx;
            shape.y2 += dy;
        }
    }
    downloadCanvas(tempCanvas) {
        const link = this.downloadLinkRef.nativeElement;
        link.href = tempCanvas.toDataURL();
        link.download = 'whiteboard.png';
        link.click();
    }
    saveCanvas() {
        const tempCanvas = this.tempCanvasRef.nativeElement;
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = this.canvasRef.nativeElement.width;
        tempCanvas.height = this.canvasRef.nativeElement.height;
        const notShapes = ['freehand', 'text', 'image', 'line'];
        if (this.parameters.useImageBackground) {
            const backgroundImage = new Image();
            backgroundImage.crossOrigin = 'anonymous';
            backgroundImage.onload = () => {
                tempCtx.drawImage(backgroundImage, 0, 0, tempCanvas.width, tempCanvas.height);
                this.parameters.shapes.forEach((shape) => {
                    !notShapes.includes(shape.type)
                        ? this.drawShape(shape.type, shape.x1, shape.y1, shape.x2, shape.y2, shape.color, shape.thickness, shape.lineType, tempCtx)
                        : this.drawShapeOnCanvas(shape, tempCtx);
                });
                this.downloadCanvas(tempCanvas);
            };
            backgroundImage.src = 'https://mediasfu.com/images/svg/graph_paper.jpg';
        }
        else {
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            this.parameters.shapes.forEach((shape) => {
                !notShapes.includes(shape.type)
                    ? this.drawShape(shape.type, shape.x1, shape.y1, shape.x2, shape.y2, shape.color, shape.thickness, shape.lineType, tempCtx)
                    : this.drawShapeOnCanvas(shape, tempCtx);
            });
            this.downloadCanvas(tempCanvas);
        }
    }
    drawShapeOnCanvas(shape, ctx = this.canvasRef.nativeElement.getContext('2d')) {
        ctx.beginPath();
        ctx.strokeStyle = shape.color;
        ctx.lineWidth = shape.thickness || 2;
        ctx.fillStyle = shape.color;
        ctx.font = `${shape.fontSize}px ${shape.fontFamily}`;
        const lineType = shape.lineType ? shape.lineType : 'solid';
        if (lineType === 'dashed') {
            ctx.setLineDash([10, 10]);
        }
        else if (lineType === 'dotted') {
            ctx.setLineDash([2, 10]);
        }
        else if (lineType === 'dashDot') {
            ctx.setLineDash([10, 5, 2, 5]);
        }
        else {
            ctx.setLineDash([]);
        }
        switch (shape.type) {
            case 'line':
                ctx.moveTo(shape.x1, shape.y1);
                ctx.lineTo(shape.x2, shape.y2);
                break;
            case 'freehand':
                try {
                    ctx.moveTo(shape.points[0].x, shape.points[0].y);
                    shape.points.forEach((point) => ctx.lineTo(point.x, point.y));
                }
                catch {
                    //console.log('Error drawing freehand shape');
                }
                break;
            case 'text':
                ctx.fillText(shape.text, shape.x, shape.y);
                break;
            case 'image':
                ctx.drawImage(shape.img, shape.x1, shape.y1, shape.x2 - shape.x1, shape.y2 - shape.y1);
                break;
            default:
                break;
        }
        ctx.stroke();
    }
    deleteShape(doEmits = true) {
        if (!this.checkBoardAccess())
            return;
        if (!this.selectedShape)
            return;
        if (this.selectedShape) {
            this.parameters.shapes = this.parameters.shapes.filter((shape) => shape !== this.selectedShape);
            this.parameters.updateShapes(this.parameters.shapes);
            this.selectedShape = null;
            if (doEmits) {
                this.parameters.socket.emit('updateBoardAction', { action: 'shapes', payload: { shapes: this.parameters.shapes } }, this.handleServerResponse);
            }
            this.drawShapes();
        }
    }
    toggleBackground = (doEmits = true) => {
        if (doEmits && !this.checkBoardAccess())
            return;
        this.parameters.useImageBackground = !this.parameters.useImageBackground;
        this.parameters.updateUseImageBackground(this.parameters.useImageBackground);
        const toggleButton = this.toggleBackgroundRef.nativeElement;
        if (this.parameters.useImageBackground) {
            this.canvasRef.nativeElement.style.backgroundImage = `url('https://mediasfu.com/images/svg/graph_paper.jpg')`;
            toggleButton.classList.remove('active');
        }
        else {
            this.canvasRef.nativeElement.style.backgroundImage = 'none';
            this.canvasRef.nativeElement.style.backgroundColor = 'white';
            toggleButton.classList.add('active');
        }
        this.drawShapes();
        if (doEmits) {
            this.parameters.socket.emit('updateBoardAction', { action: 'toggleBackground', payload: this.parameters.useImageBackground }, this.handleServerResponse);
        }
    };
    clearCanvas = (doEmits = true) => {
        if (this.parameters.islevel != '2' && doEmits) {
            this.parameters.showAlert?.({
                message: 'You do not have permission to clear the board',
                type: 'danger',
            });
            return;
        }
        if (this.parameters.shapes.length === 0)
            return;
        this.parameters.shapes = [];
        this.parameters.updateShapes([]);
        this.drawShapes();
        if (doEmits) {
            this.parameters.socket.emit('updateBoardAction', { action: 'clear' }, this.handleServerResponse);
        }
    };
    uploadImage = (event, doEmits = true) => {
        try {
            if (!this.checkBoardAccess())
                return;
            const file = event.target.files[0];
            if (file.size > 1024 * 1024) {
                this.parameters.showAlert?.({ message: 'File size must be less than 1MB', type: 'danger' });
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    if (img.height > 600 && img.height > img.width && !file.type.includes('jpeg')) {
                        this.parameters.showAlert?.({
                            message: 'For better performance, please upload the image in JPG format.',
                            type: 'danger',
                        });
                        return;
                    }
                    let imageWidth = 350;
                    const aspectRatio = img.height / img.width;
                    let imageHeight = imageWidth * aspectRatio;
                    const maxHeight = 600;
                    if (imageHeight > maxHeight) {
                        imageHeight = maxHeight;
                        imageWidth = imageHeight / aspectRatio;
                        if (imageWidth > 600) {
                            imageWidth = 600;
                        }
                    }
                    const imageShape = {
                        type: 'image',
                        img: img,
                        src: event.target.result,
                        x1: 50,
                        y1: 50,
                        x2: 50 + imageWidth,
                        y2: 50 + imageHeight,
                    };
                    this.parameters.shapes.push(imageShape);
                    this.parameters.updateShapes(this.parameters.shapes);
                    this.drawShapes();
                    if (doEmits) {
                        this.parameters.socket.emit('updateBoardAction', { action: 'uploadImage', payload: imageShape }, this.handleServerResponse);
                    }
                };
                img.onerror = () => {
                    this.parameters.showAlert?.({ message: 'Error loading image', type: 'danger' });
                };
                img.src = event.target.result;
            };
            reader.onerror = () => {
                this.parameters.showAlert?.({ message: 'Error reading file', type: 'danger' });
            };
            reader.readAsDataURL(file);
        }
        catch (error) {
            //console.log(error);
        }
    };
    handleServerResponse = (response) => {
        if (!response.success) {
            this.parameters.showAlert?.({
                message: `Whiteboard action failed: ${response.reason}`,
                type: 'danger',
            });
        }
    };
    WhiteboardAction = (data) => {
        const { action, payload } = data;
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        if (!ctx)
            return;
        this.parameters.updateCanvasWhiteboard(this.canvasRef.nativeElement);
        switch (action) {
            case 'draw':
                if (payload.type === 'freehand') {
                    this.drawFreehand(payload.points, payload.color, payload.thickness);
                    this.parameters.shapes.push({
                        type: 'freehand',
                        points: payload.points,
                        color: payload.color,
                        thickness: payload.thickness,
                    });
                    this.parameters.updateShapes(this.parameters.shapes);
                }
                else {
                    this.drawLine(payload.x1, payload.y1, payload.x2, payload.y2, payload.color, payload.thickness, payload.lineType);
                    this.parameters.shapes.push({
                        type: 'line',
                        x1: payload.x1,
                        y1: payload.y1,
                        x2: payload.x2,
                        y2: payload.y2,
                        color: payload.color,
                        thickness: payload.thickness,
                        lineType: payload.lineType,
                    });
                    this.parameters.updateShapes(this.parameters.shapes);
                }
                break;
            case 'shape':
                this.drawShape(payload.type, payload.x1, payload.y1, payload.x2, payload.y2, payload.color, payload.thickness, payload.lineType);
                this.parameters.shapes.push({
                    type: payload.type,
                    x1: payload.x1,
                    y1: payload.y1,
                    x2: payload.x2,
                    y2: payload.y2,
                    color: payload.color,
                    thickness: payload.thickness,
                    lineType: payload.lineType,
                });
                this.parameters.updateShapes(this.parameters.shapes);
                break;
            case 'erase':
                this.erase(payload.x, payload.y);
                break;
            case 'clear':
                this.clearCanvas(false);
                break;
            case 'uploadImage': {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const imageShape = {
                        type: 'image',
                        img,
                        src: payload.src,
                        x1: payload.x1,
                        y1: payload.y1,
                        x2: payload.x2,
                        y2: payload.y2,
                    };
                    this.parameters.shapes.push(imageShape);
                    this.parameters.updateShapes(this.parameters.shapes);
                    this.drawShapes();
                };
                img.src = payload.src;
                break;
            }
            case 'toggleBackground':
                this.toggleBackground(false);
                this.drawShapes();
                break;
            case 'undo':
                if (this.parameters.shapes.length > 0) {
                    this.parameters.redoStack.push(this.parameters.shapes.pop());
                    this.parameters.updateRedoStack(this.parameters.redoStack);
                    this.drawShapes();
                }
                break;
            case 'redo':
                if (this.parameters.redoStack.length > 0) {
                    this.parameters.shapes.push(this.parameters.redoStack.pop());
                    this.parameters.updateShapes(this.parameters.shapes);
                    this.drawShapes();
                }
                break;
            case 'text':
                this.parameters.shapes.push({
                    type: 'text',
                    text: payload.text,
                    x: payload.x,
                    y: payload.y,
                    color: payload.color,
                    font: payload.font,
                    fontSize: payload.fontSize,
                });
                this.parameters.updateShapes(this.parameters.shapes);
                this.drawShapes();
                break;
            case 'deleteShape':
                this.parameters.shapes = this.parameters.shapes.filter((shape) => shape !== payload);
                this.parameters.updateShapes(this.parameters.shapes);
                this.drawShapes();
                break;
            case 'shapes': {
                const oldShapes = this.parameters.shapes.filter((shape) => shape.type === 'image');
                this.parameters.shapes = payload.shapes.map((shape) => {
                    if (shape.type === 'image') {
                        const oldShape = oldShapes.find((oldShape) => oldShape.src === shape.src);
                        if (oldShape) {
                            return { ...shape, img: oldShape.img };
                        }
                        else {
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.src = shape.src;
                            return { ...shape, img };
                        }
                    }
                    else {
                        return shape;
                    }
                });
                this.parameters.updateShapes(this.parameters.shapes);
                this.drawShapes();
                break;
            }
            default:
                break;
        }
    };
    WhiteboardUpdated = (data) => {
        // data = { whiteboardUsers, status}
        // status = 'started', 'ended', 'updated'
        // whiteboardUsers array
        // members (participants) array only sent to the host
        //whiteboardData = {shapes=[], useImageBackground=Boolean, redoStack=[], undoStack=[]} or {} or null
        const ctx = this.canvasRef.nativeElement.getContext('2d');
        if (!ctx)
            return;
        if (this.parameters.islevel == '2' && data.members) {
            this.parameters.participantsAll = data.members.map((participant) => ({
                isBanned: participant.isBanned,
                name: participant.name,
            }));
            this.parameters.participants = data.members.filter((participant) => participant.isBanned == false);
            this.parameters.updateParticipants(this.parameters.participants);
        }
        this.parameters.whiteboardUsers = data.whiteboardUsers;
        this.parameters.updateWhiteboardUsers(this.parameters.whiteboardUsers);
        const useBoard = this.parameters.whiteboardUsers.find((user) => user.name == this.parameters.member && user.useBoard)
            ? true
            : false;
        if (this.parameters.islevel != '2' && !useBoard && !this.parameters.whiteboardEnded) {
            this.changeMode('pan');
        }
        if (data.whiteboardData && Object.keys(data.whiteboardData).length > 0) {
            if (data.whiteboardData.shapes) {
                const oldShapes = this.parameters.shapes.filter((shape) => shape.type === 'image');
                this.parameters.shapes = data.whiteboardData.shapes.map((shape) => {
                    if (shape.type === 'image') {
                        const oldShape = oldShapes.find((oldShape) => oldShape.src === shape.src);
                        if (oldShape) {
                            return { ...shape, img: oldShape.img };
                        }
                        else {
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.src = shape.src;
                            return { ...shape, img };
                        }
                    }
                    else {
                        return shape;
                    }
                });
                this.parameters.updateShapes(this.parameters.shapes);
            }
            if (data.whiteboardData.useImageBackground != null) {
                this.parameters.useImageBackground = data.whiteboardData.useImageBackground;
                this.parameters.updateUseImageBackground(this.parameters.useImageBackground);
            }
            else {
                this.parameters.useImageBackground = true;
                this.parameters.updateUseImageBackground(true);
            }
            if (data.whiteboardData.redoStack) {
                this.parameters.redoStack = data.whiteboardData.redoStack;
                this.parameters.updateRedoStack(this.parameters.redoStack);
            }
            if (data.whiteboardData.undoStack) {
                this.parameters.undoStack = data.whiteboardData.undoStack;
                this.parameters.updateUndoStack(this.parameters.undoStack);
            }
        }
        if (data.status == 'started' && !this.parameters.whiteboardStarted) {
            this.parameters.whiteboardStarted = true;
            this.parameters.whiteboardEnded = false;
            this.parameters.screenId = `whiteboard-${this.parameters.roomName}`;
            this.parameters.updateWhiteboardStarted(true);
            this.parameters.updateWhiteboardEnded(false);
            this.parameters.updateScreenId(this.parameters.screenId);
            if (this.parameters.islevel != '2') {
                this.parameters.shareScreenStarted = true;
                this.parameters.updateShareScreenStarted(true);
                this.parameters.onScreenChanges({ changed: true, parameters: this.parameters });
            }
        }
        else if (data.status == 'ended') {
            const prevWhiteboardEnded = this.parameters.whiteboardEnded;
            const prevWhiteboardStarted = this.parameters.whiteboardStarted;
            this.parameters.whiteboardEnded = true;
            this.parameters.whiteboardStarted = false;
            this.parameters.updateWhiteboardStarted(false);
            this.parameters.updateWhiteboardEnded(true);
            if (this.parameters.islevel == '2' && prevWhiteboardEnded) {
                // No operation needed
            }
            else {
                this.parameters.shareScreenStarted = false;
                this.parameters.screenId = '';
                this.parameters.updateShareScreenStarted(false);
                this.parameters.updateScreenId('');
                this.parameters.onScreenChanges({ changed: true, parameters: this.parameters });
            }
            try {
                if (prevWhiteboardStarted &&
                    this.parameters.islevel == '2' &&
                    (this.parameters.recordStarted || this.parameters.recordResumed)) {
                    if (!(this.parameters.recordPaused || this.parameters.recordStopped)) {
                        if (this.parameters.recordingMediaOptions == 'video') {
                            this.parameters.captureCanvasStream({ parameters: this.parameters, start: false });
                        }
                    }
                }
            }
            catch (error) {
                // Handle error
            }
        }
        else if (data.status == 'started' && this.parameters.whiteboardStarted) {
            this.parameters.whiteboardStarted = true;
            this.parameters.whiteboardEnded = false;
            this.parameters.updateWhiteboardStarted(true);
            this.parameters.updateWhiteboardEnded(false);
            this.parameters.shareScreenStarted = true;
            this.parameters.screenId = `whiteboard-${this.parameters.roomName}`;
            this.parameters.updateShareScreenStarted(true);
            this.parameters.updateScreenId(this.parameters.screenId);
            this.parameters.onScreenChanges({ changed: true, parameters: this.parameters });
        }
    };
    handleDropdownClick(id) {
        this.dropdownOpen = this.dropdownOpen === id ? null : id;
    }
    handleItemClick(callback, name, value) {
        callback(value);
        this.dropdownOpen = null;
        if (['draw', 'freehand', 'shape', 'text', 'erase'].includes(name)) {
            this.changeMode(name);
        }
    }
    dropdownItems(items, name, callback) {
        return items.map((item, index) => `<button key="${index}" class="dropdown-item" (click)="handleItemClick(${callback}, '${name}', ${item.value})" style="padding: 5px;">
        ${item.label}
      </button>`);
    }
    toggleToolbar() {
        this.toolbarVisible = !this.toolbarVisible;
    }
    checkBoardAccess() {
        this.parameters = this.parameters.getUpdatedAllParams();
        if (this.parameters.whiteboardStarted && !this.parameters.whiteboardEnded) {
            const user = this.parameters.whiteboardUsers.find((user) => user.name === this.parameters.member);
            if ((!user || !user.useBoard) && this.parameters.islevel != '2') {
                this.parameters.showAlert?.({
                    message: 'You are not allowed to use the whiteboard. Please ask the host to assign you.',
                    type: 'danger',
                });
                return false;
            }
            else {
                return true;
            }
        }
        else {
            return true;
        }
    }
    changeMode(newMode) {
        if (newMode !== 'pan' && !this.checkBoardAccess())
            return;
        this.mode = newMode;
        const canvas = this.canvasRef.nativeElement;
        if (newMode === 'pan') {
            canvas.style.cursor = 'grab';
        }
        else if (newMode === 'select') {
            canvas.style.cursor = 'pointer';
        }
        else if (newMode === 'erase') {
            canvas.style.cursor = 'crosshair';
        }
        else {
            canvas.style.cursor = 'crosshair';
        }
        if (newMode !== 'freehand' && this.freehandDrawing.length > 0) {
            this.parameters.shapes.push({
                type: 'freehand',
                points: this.freehandDrawing,
                color: this.color,
                thickness: this.brushThickness,
            });
            this.parameters.updateShapes(this.parameters.shapes);
            this.freehandDrawing = [];
            this.saveState();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Whiteboard, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: Whiteboard, isStandalone: true, selector: "app-whiteboard", inputs: { customWidth: "customWidth", customHeight: "customHeight", parameters: "parameters", showAspect: "showAspect" }, viewQueries: [{ propertyName: "canvasRef", first: true, predicate: ["canvasRef"], descendants: true }, { propertyName: "textInputRef", first: true, predicate: ["textInputRef"], descendants: true }, { propertyName: "toggleBackgroundRef", first: true, predicate: ["toggleBackgroundRef"], descendants: true }, { propertyName: "downloadLinkRef", first: true, predicate: ["downloadLinkRef"], descendants: true }, { propertyName: "tempCanvasRef", first: true, predicate: ["tempCanvasRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div id=\"whiteboard-interface\" [style.width.px]=\"customWidth\" [style.height.px]=\"customHeight\" [style.display]=\"showAspect ? 'block' : 'none'\" style=\"position: relative; display: flex; justify-content: center; align-items: center; border: 2px solid #000; background-color: #f0f0f0;\">\r\n  <div id=\"whiteboardContent\" style=\"position: relative; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: auto;\">\r\n    <button id=\"toolbarToggle\" class=\"btn btnBoard btn-primary\" style=\"position: absolute; top: 5px; left: 55px; z-index: 10;\" (click)=\"toggleToolbar()\">\r\n      <fa-icon [icon]=\"toolbarVisible ? faChevronLeft : faChevronRight\"></fa-icon>\r\n    </button>\r\n    <div *ngIf=\"toolbarVisible\" class=\"toolbar mb-3\" id=\"toolbar\" style=\"position: absolute; top: 5px; left: 100px; z-index: 10; background-color: transparent;\">\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"drawMode\" (click)=\"handleDropdownClick('drawMode')\">\r\n          <fa-icon [icon]=\"faPencilAlt\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'drawMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'XX-Small (3px)', value: 3 }, { label: 'X-Small (6px)', value: 6 }, { label: 'Small (12px)', value: 12 }, { label: 'Medium (18px)', value: 18 }, { label: 'Large (24px)', value: 24 }, { label: 'X-Large (36px)', value: 36 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateLineThickness, 'draw', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"freehandMode\" (click)=\"handleDropdownClick('freehandMode')\">\r\n          <fa-icon [icon]=\"faPaintBrush\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'freehandMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (40px)', value: 40 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateBrushThickness, 'freehand', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"shapeMode\" (click)=\"handleDropdownClick('shapeMode')\">\r\n          <fa-icon [icon]=\"faShapes\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'shapeMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/square.svg\\' alt=\\'Square\\' class=\\'shape-icon\\' />', value: 'square' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/rectangle.svg\\' alt=\\'Rectangle\\' class=\\'shape-icon\\' />', value: 'rectangle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/circle.svg\\' alt=\\'Circle\\' class=\\'shape-icon\\' />', value: 'circle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/triangle.svg\\' alt=\\'Triangle\\' class=\\'shape-icon\\' />', value: 'triangle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/hexagon.svg\\' alt=\\'Hexagon\\' class=\\'shape-icon\\' />', value: 'hexagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/pentagon.svg\\' alt=\\'Pentagon\\' class=\\'shape-icon\\' />', value: 'pentagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/rhombus.svg\\' alt=\\'Rhombus\\' class=\\'shape-icon\\' />', value: 'rhombus' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/octagon.svg\\' alt=\\'Octagon\\' class=\\'shape-icon\\' />', value: 'octagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/parallelogram.svg\\' alt=\\'Parallelogram\\' class=\\'shape-icon\\' />', value: 'parallelogram' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/oval.svg\\' alt=\\'Oval\\' class=\\'shape-icon\\' />', value: 'oval' }\r\n          ]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateShape, 'shape', item.value)\" style=\"padding: 5px;\" [innerHTML]=\"item.label\">\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"selectMode\" (click)=\"changeMode('select')\">\r\n        <fa-icon [icon]=\"faMousePointer\"></fa-icon>\r\n      </button>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-danger dropdown-toggle\" id=\"eraseMode\" (click)=\"handleDropdownClick('eraseMode')\">\r\n          <fa-icon [icon]=\"faEraser\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'eraseMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (30px)', value: 30 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateEraserThickness, 'erase', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-info\" id=\"panMode\" (click)=\"changeMode('pan')\">\r\n        <fa-icon [icon]=\"faHandPaper\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomIn\" (click)=\"zoomCanvas(1.2, $event)\">\r\n        <fa-icon [icon]=\"faSearchPlus\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomReset\" (click)=\"zoomCanvas(10, $event)\">\r\n        <fa-icon [icon]=\"faSearch\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomOut\" (click)=\"zoomCanvas(0.8, $event)\">\r\n        <fa-icon [icon]=\"faSearchMinus\"></fa-icon>\r\n      </button>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"addText\" (click)=\"handleDropdownClick('addText')\">\r\n          <fa-icon [icon]=\"faFont\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'addText'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'Arial', value: 'Arial' }, { label: 'Times New Roman', value: 'Times New Roman' }, { label: 'Courier New', value: 'Courier New' }, { label: 'Verdana', value: 'Verdana' }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateFont, 'text', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"fontSize\" (click)=\"handleDropdownClick('fontSize')\">\r\n          <fa-icon [icon]=\"faTextHeight\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'fontSize'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (40px)', value: 40 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateFontSize, '', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"undo\" (click)=\"undo()\">\r\n        <fa-icon [icon]=\"faUndo\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"redo\" (click)=\"redo()\">\r\n        <fa-icon [icon]=\"faRedo\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"save\" (click)=\"saveCanvas()\">\r\n        <fa-icon [icon]=\"faSave\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-danger\" id=\"delete\" (click)=\"deleteShape()\">\r\n        <fa-icon [icon]=\"faTrash\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"clearCanvas\" (click)=\"clearCanvas()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n      <button id=\"toggleBackgroundRef\" #toggleBackgroundRef class=\"btn btnBoard btn-secondary\" (click)=\"toggleBackground()\">\r\n        <img src=\"https://mediasfu.com/images/svg/graph.jpg\" alt=\"Background\" class=\"toggle-icon\" id=\"backgroundIcon\" />\r\n      </button>\r\n      <input type=\"file\" id=\"uploadBoardImage\" accept=\"image/*\" style=\"display: none;\" (change)=\"uploadImage($event)\" />\r\n      <label for=\"uploadBoardImage\" class=\"btn btnBoard btn-primary\">\r\n        <fa-icon [icon]=\"faUpload\"></fa-icon>\r\n      </label>\r\n      <input type=\"color\" id=\"colorPicker\" class=\"btn\" [(ngModel)]=\"color\" />\r\n      <select id=\"lineTypePicker\" class=\"custom-select\" style=\"width: auto;\" [(ngModel)]=\"lineType\">\r\n        <option value=\"solid\">Solid</option>\r\n        <option value=\"dashed\">Dashed</option>\r\n        <option value=\"dotted\">Dotted</option>\r\n        <option value=\"dashDot\">Dash-Dot</option>\r\n      </select>\r\n    </div>\r\n    <canvas id=\"canvasRef\" width=\"1280\" height=\"720\" style=\"border: 2px solid red;\" #canvasRef></canvas>\r\n    <textarea id=\"textInputRef\" class=\"form-control\" #textInputRef style=\"display: none; position: absolute;\"></textarea>\r\n    <a href=\"#\" id=\"downloadLinkRef\" #downloadLinkRef style=\"display: none;\">Download</a>\r\n    <canvas id=\"tempCanvasRef\" #tempCanvasRef style=\"display: none;\"></canvas>\r\n  </div>\r\n</div>\r\n", styles: ["#whiteboardCanvas,#canvsRef{border:1px solid #000;cursor:crosshair;background-color:#fff}.resize-handle,.move-handle{width:8px;height:8px;background:red;position:absolute}.move-handle{background:#00f}#textInput,#textInputRef{display:none;position:absolute;z-index:10;width:200px}.shape-icon{width:20px!important;height:20px!important;color:#fff}.toolbar .btn-group button,.toolbar .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s}.toolbar .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbar .btn-group button:hover,.toolbar .dropdown-menu a:hover{background-color:#e3e7eb}.toolbar .btn-group button.active{background-color:#454d55}.toolbarScreen .btn-group button,.toolbarScreen .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s;color:\"black\"}.toolbarScreen .btn-group button{background-color:#e3e7eb;border:none}.toolbarScreen .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbarScreen .btn-group button:hover,.toolbarScreen .dropdown-menu a:hover{background-color:#d6d1d166;color:#000}.toolbarScreen .btn-group button.active{background-color:#454d55}#toolbarToggleScreen{background-color:#d6d1d166;border:\"1px solid black\"}#toolbar,#toolbarScreen{transition:display .3s ease-in-out}#toolbarToggle,#toolbarToggleScreen{cursor:pointer}#colorPicker,#colorPickerScreen{font-size:.8rem;padding:2px;width:32px;height:32px}#lineTypePicker{font-size:.8rem;padding:2px auto;width:32px;height:32px}.btnBoard{font-size:1rem;padding:2px;width:40px;height:40px;margin:2px}#lineTypePickerScreen{font-size:.8rem;padding:2px auto;width:32px;height:32px;background-color:#d6d1d166;color:#000}.toggle-icon{width:34px;height:34px;padding:0;margin:0}#toggleBackground.active{background-color:#fdfeff}.annotateScreenBtn{background-color:#2d2e2f!important;border:2px solid #000!important;color:green!important}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2$2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2$2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }], encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: Whiteboard, decorators: [{
            type: Component,
            args: [{ selector: 'app-whiteboard', encapsulation: ViewEncapsulation.None, imports: [CommonModule, FormsModule, FontAwesomeModule], template: "<div id=\"whiteboard-interface\" [style.width.px]=\"customWidth\" [style.height.px]=\"customHeight\" [style.display]=\"showAspect ? 'block' : 'none'\" style=\"position: relative; display: flex; justify-content: center; align-items: center; border: 2px solid #000; background-color: #f0f0f0;\">\r\n  <div id=\"whiteboardContent\" style=\"position: relative; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: auto;\">\r\n    <button id=\"toolbarToggle\" class=\"btn btnBoard btn-primary\" style=\"position: absolute; top: 5px; left: 55px; z-index: 10;\" (click)=\"toggleToolbar()\">\r\n      <fa-icon [icon]=\"toolbarVisible ? faChevronLeft : faChevronRight\"></fa-icon>\r\n    </button>\r\n    <div *ngIf=\"toolbarVisible\" class=\"toolbar mb-3\" id=\"toolbar\" style=\"position: absolute; top: 5px; left: 100px; z-index: 10; background-color: transparent;\">\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"drawMode\" (click)=\"handleDropdownClick('drawMode')\">\r\n          <fa-icon [icon]=\"faPencilAlt\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'drawMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'XX-Small (3px)', value: 3 }, { label: 'X-Small (6px)', value: 6 }, { label: 'Small (12px)', value: 12 }, { label: 'Medium (18px)', value: 18 }, { label: 'Large (24px)', value: 24 }, { label: 'X-Large (36px)', value: 36 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateLineThickness, 'draw', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"freehandMode\" (click)=\"handleDropdownClick('freehandMode')\">\r\n          <fa-icon [icon]=\"faPaintBrush\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'freehandMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (40px)', value: 40 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateBrushThickness, 'freehand', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"shapeMode\" (click)=\"handleDropdownClick('shapeMode')\">\r\n          <fa-icon [icon]=\"faShapes\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'shapeMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/square.svg\\' alt=\\'Square\\' class=\\'shape-icon\\' />', value: 'square' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/rectangle.svg\\' alt=\\'Rectangle\\' class=\\'shape-icon\\' />', value: 'rectangle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/circle.svg\\' alt=\\'Circle\\' class=\\'shape-icon\\' />', value: 'circle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/triangle.svg\\' alt=\\'Triangle\\' class=\\'shape-icon\\' />', value: 'triangle' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/hexagon.svg\\' alt=\\'Hexagon\\' class=\\'shape-icon\\' />', value: 'hexagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/pentagon.svg\\' alt=\\'Pentagon\\' class=\\'shape-icon\\' />', value: 'pentagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/rhombus.svg\\' alt=\\'Rhombus\\' class=\\'shape-icon\\' />', value: 'rhombus' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/octagon.svg\\' alt=\\'Octagon\\' class=\\'shape-icon\\' />', value: 'octagon' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/parallelogram.svg\\' alt=\\'Parallelogram\\' class=\\'shape-icon\\' />', value: 'parallelogram' },\r\n            { label: '<img src=\\'https://mediasfu.com/images/svg/oval.svg\\' alt=\\'Oval\\' class=\\'shape-icon\\' />', value: 'oval' }\r\n          ]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateShape, 'shape', item.value)\" style=\"padding: 5px;\" [innerHTML]=\"item.label\">\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"selectMode\" (click)=\"changeMode('select')\">\r\n        <fa-icon [icon]=\"faMousePointer\"></fa-icon>\r\n      </button>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-danger dropdown-toggle\" id=\"eraseMode\" (click)=\"handleDropdownClick('eraseMode')\">\r\n          <fa-icon [icon]=\"faEraser\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'eraseMode'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (30px)', value: 30 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateEraserThickness, 'erase', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-info\" id=\"panMode\" (click)=\"changeMode('pan')\">\r\n        <fa-icon [icon]=\"faHandPaper\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomIn\" (click)=\"zoomCanvas(1.2, $event)\">\r\n        <fa-icon [icon]=\"faSearchPlus\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomReset\" (click)=\"zoomCanvas(10, $event)\">\r\n        <fa-icon [icon]=\"faSearch\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-success\" id=\"zoomOut\" (click)=\"zoomCanvas(0.8, $event)\">\r\n        <fa-icon [icon]=\"faSearchMinus\"></fa-icon>\r\n      </button>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"addText\" (click)=\"handleDropdownClick('addText')\">\r\n          <fa-icon [icon]=\"faFont\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'addText'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'Arial', value: 'Arial' }, { label: 'Times New Roman', value: 'Times New Roman' }, { label: 'Courier New', value: 'Courier New' }, { label: 'Verdana', value: 'Verdana' }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateFont, 'text', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"btn-group\" role=\"group\">\r\n        <button class=\"btn btnBoard btn-secondary dropdown-toggle\" id=\"fontSize\" (click)=\"handleDropdownClick('fontSize')\">\r\n          <fa-icon [icon]=\"faTextHeight\"></fa-icon>\r\n        </button>\r\n        <div *ngIf=\"dropdownOpen === 'fontSize'\" class=\"dropdown-menu show\">\r\n          <button *ngFor=\"let item of [{ label: 'X-Small (5px)', value: 5 }, { label: 'Small (10px)', value: 10 }, { label: 'Medium (20px)', value: 20 }, { label: 'Large (40px)', value: 40 }, { label: 'X-Large (60px)', value: 60 }]\" class=\"dropdown-item\" (click)=\"handleItemClick(updateFontSize, '', item.value)\" style=\"padding: 5px;\">\r\n            {{ item.label }}\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"undo\" (click)=\"undo()\">\r\n        <fa-icon [icon]=\"faUndo\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"redo\" (click)=\"redo()\">\r\n        <fa-icon [icon]=\"faRedo\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"save\" (click)=\"saveCanvas()\">\r\n        <fa-icon [icon]=\"faSave\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-danger\" id=\"delete\" (click)=\"deleteShape()\">\r\n        <fa-icon [icon]=\"faTrash\"></fa-icon>\r\n      </button>\r\n      <button class=\"btn btnBoard btn-secondary\" id=\"clearCanvas\" (click)=\"clearCanvas()\">\r\n        <fa-icon [icon]=\"faTimes\"></fa-icon>\r\n      </button>\r\n      <button id=\"toggleBackgroundRef\" #toggleBackgroundRef class=\"btn btnBoard btn-secondary\" (click)=\"toggleBackground()\">\r\n        <img src=\"https://mediasfu.com/images/svg/graph.jpg\" alt=\"Background\" class=\"toggle-icon\" id=\"backgroundIcon\" />\r\n      </button>\r\n      <input type=\"file\" id=\"uploadBoardImage\" accept=\"image/*\" style=\"display: none;\" (change)=\"uploadImage($event)\" />\r\n      <label for=\"uploadBoardImage\" class=\"btn btnBoard btn-primary\">\r\n        <fa-icon [icon]=\"faUpload\"></fa-icon>\r\n      </label>\r\n      <input type=\"color\" id=\"colorPicker\" class=\"btn\" [(ngModel)]=\"color\" />\r\n      <select id=\"lineTypePicker\" class=\"custom-select\" style=\"width: auto;\" [(ngModel)]=\"lineType\">\r\n        <option value=\"solid\">Solid</option>\r\n        <option value=\"dashed\">Dashed</option>\r\n        <option value=\"dotted\">Dotted</option>\r\n        <option value=\"dashDot\">Dash-Dot</option>\r\n      </select>\r\n    </div>\r\n    <canvas id=\"canvasRef\" width=\"1280\" height=\"720\" style=\"border: 2px solid red;\" #canvasRef></canvas>\r\n    <textarea id=\"textInputRef\" class=\"form-control\" #textInputRef style=\"display: none; position: absolute;\"></textarea>\r\n    <a href=\"#\" id=\"downloadLinkRef\" #downloadLinkRef style=\"display: none;\">Download</a>\r\n    <canvas id=\"tempCanvasRef\" #tempCanvasRef style=\"display: none;\"></canvas>\r\n  </div>\r\n</div>\r\n", styles: ["#whiteboardCanvas,#canvsRef{border:1px solid #000;cursor:crosshair;background-color:#fff}.resize-handle,.move-handle{width:8px;height:8px;background:red;position:absolute}.move-handle{background:#00f}#textInput,#textInputRef{display:none;position:absolute;z-index:10;width:200px}.shape-icon{width:20px!important;height:20px!important;color:#fff}.toolbar .btn-group button,.toolbar .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s}.toolbar .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbar .btn-group button:hover,.toolbar .dropdown-menu a:hover{background-color:#e3e7eb}.toolbar .btn-group button.active{background-color:#454d55}.toolbarScreen .btn-group button,.toolbarScreen .dropdown-menu a{font-size:.8rem;padding:5px 10px;margin:0 2px;border-radius:4px;transition:background-color .2s;color:\"black\"}.toolbarScreen .btn-group button{background-color:#e3e7eb;border:none}.toolbarScreen .dropdown-menu a{background-color:transparent;color:#1b1a1a}.toolbarScreen .btn-group button:hover,.toolbarScreen .dropdown-menu a:hover{background-color:#d6d1d166;color:#000}.toolbarScreen .btn-group button.active{background-color:#454d55}#toolbarToggleScreen{background-color:#d6d1d166;border:\"1px solid black\"}#toolbar,#toolbarScreen{transition:display .3s ease-in-out}#toolbarToggle,#toolbarToggleScreen{cursor:pointer}#colorPicker,#colorPickerScreen{font-size:.8rem;padding:2px;width:32px;height:32px}#lineTypePicker{font-size:.8rem;padding:2px auto;width:32px;height:32px}.btnBoard{font-size:1rem;padding:2px;width:40px;height:40px;margin:2px}#lineTypePickerScreen{font-size:.8rem;padding:2px auto;width:32px;height:32px;background-color:#d6d1d166;color:#000}.toggle-icon{width:34px;height:34px;padding:0;margin:0}#toggleBackground.active{background-color:#fdfeff}.annotateScreenBtn{background-color:#2d2e2f!important;border:2px solid #000!important;color:green!important}\n"] }]
        }], propDecorators: { customWidth: [{
                type: Input
            }], customHeight: [{
                type: Input
            }], parameters: [{
                type: Input
            }], showAspect: [{
                type: Input
            }], canvasRef: [{
                type: ViewChild,
                args: ['canvasRef', { static: false }]
            }], textInputRef: [{
                type: ViewChild,
                args: ['textInputRef', { static: false }]
            }], toggleBackgroundRef: [{
                type: ViewChild,
                args: ['toggleBackgroundRef', { static: false }]
            }], downloadLinkRef: [{
                type: ViewChild,
                args: ['downloadLinkRef', { static: false }]
            }], tempCanvasRef: [{
                type: ViewChild,
                args: ['tempCanvasRef', { static: false }]
            }] } });

// //consumers/socket-receive-methods

const initialValuesState = {
    // The following are the initial values
    roomName: '',
    member: '',
    adminPasscode: '',
    islevel: '1',
    coHost: 'No coHost',
    coHostResponsibility: [
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ],
    youAreCoHost: false,
    youAreHost: false,
    confirmedToRecord: false,
    meetingDisplayType: 'media',
    meetingVideoOptimized: false,
    eventType: 'webinar',
    participants: [],
    filteredParticipants: [],
    participantsCounter: 0,
    participantsFilter: '',
    validated: false,
    localUIMode: false,
    socket: {},
    localSocket: undefined,
    roomData: null,
    device: null,
    apiKey: '',
    apiUserName: '',
    apiToken: '',
    link: '',
    consume_sockets: [],
    rtpCapabilities: null,
    roomRecvIPs: [],
    meetingRoomParams: null,
    itemPageLimit: 4,
    audioOnlyRoom: false,
    addForBasic: false,
    screenPageLimit: 4,
    shareScreenStarted: false,
    shared: false,
    targetOrientation: 'landscape',
    targetResolution: 'sd',
    targetResolutionHost: 'sd',
    vidCons: { width: 640, height: 360 },
    frameRate: 10,
    hParams: {},
    vParams: {},
    screenParams: {},
    aParams: {},
    // Initial Values for New Recording Fields
    recordingAudioPausesLimit: 0,
    recordingAudioPausesCount: 0,
    recordingAudioSupport: false,
    recordingAudioPeopleLimit: 0,
    recordingAudioParticipantsTimeLimit: 0,
    recordingVideoPausesCount: 0,
    recordingVideoPausesLimit: 0,
    recordingVideoSupport: false,
    recordingVideoPeopleLimit: 0,
    recordingVideoParticipantsTimeLimit: 0,
    recordingAllParticipantsSupport: false,
    recordingVideoParticipantsSupport: false,
    recordingAllParticipantsFullRoomSupport: false,
    recordingVideoParticipantsFullRoomSupport: false,
    recordingPreferredOrientation: 'landscape',
    recordingSupportForOtherOrientation: false,
    recordingMultiFormatsSupport: false,
    userRecordingParams: {
        mainSpecs: {
            mediaOptions: 'video',
            audioOptions: 'all',
            videoOptions: 'all',
            videoType: 'fullDisplay',
            videoOptimized: false,
            recordingDisplayType: 'media',
            addHLS: false,
        },
        dispSpecs: {
            nameTags: true,
            backgroundColor: '#000000',
            nameTagsColor: '#ffffff',
            orientationVideo: 'portrait',
        },
    },
    canRecord: false,
    startReport: false,
    endReport: false,
    recordTimerInterval: null,
    recordStartTime: 0,
    recordElapsedTime: 0,
    isTimerRunning: false,
    canPauseResume: false,
    recordChangeSeconds: 15000,
    pauseLimit: 0,
    pauseRecordCount: 0,
    canLaunchRecord: true,
    stopLaunchRecord: false,
    // Room properties
    participantsAll: [],
    firstAll: false,
    updateMainWindow: false,
    first_round: false,
    landScaped: false,
    lock_screen: false,
    screenId: '',
    allVideoStreams: [],
    newLimitedStreams: [],
    newLimitedStreamsIDs: [],
    activeSounds: [],
    screenShareIDStream: '',
    screenShareNameStream: '',
    adminIDStream: '',
    adminNameStream: '',
    youYouStream: [],
    youYouStreamIDs: [],
    localStream: null,
    recordStarted: false,
    recordResumed: false,
    recordPaused: false,
    recordStopped: false,
    adminRestrictSetting: false,
    videoRequestState: null,
    videoRequestTime: 0,
    videoAction: false,
    localStreamVideo: null,
    userDefaultVideoInputDevice: '',
    currentFacingMode: 'user',
    prevFacingMode: 'user',
    defVideoID: '',
    allowed: false,
    dispActiveNames: [],
    activeNames: [],
    prevActiveNames: [],
    p_activeNames: [],
    p_dispActiveNames: [],
    membersReceived: false,
    deferScreenReceived: false,
    hostFirstSwitch: false,
    micAction: false,
    screenAction: false,
    chatAction: false,
    audioRequestState: null,
    screenRequestState: null,
    chatRequestState: null,
    audioRequestTime: 0,
    screenRequestTime: 0,
    chatRequestTime: 0,
    updateRequestIntervalSeconds: 240,
    oldSoundIds: [],
    hostLabel: 'Host',
    mainScreenFilled: false,
    localStreamScreen: null,
    screenAlreadyOn: false,
    chatAlreadyOn: false,
    redirectURL: '',
    oldAllStreams: [],
    adminVidID: '',
    streamNames: [],
    non_alVideoStreams: [],
    sortAudioLoudness: false,
    audioDecibels: [],
    mixed_alVideoStreams: [],
    non_alVideoStreams_muted: [],
    paginatedStreams: [],
    localStreamAudio: null,
    defAudioID: '',
    userDefaultAudioInputDevice: '',
    userDefaultAudioOutputDevice: '',
    prevAudioInputDevice: '',
    prevVideoInputDevice: '',
    audioPaused: false,
    mainScreenPerson: '',
    adminOnMainScreen: false,
    screenStates: [{
            mainScreenPerson: "",
            mainScreenProducerId: "",
            mainScreenFilled: false,
            adminOnMainScreen: false,
        }],
    prevScreenStates: [{
            mainScreenPerson: "",
            mainScreenProducerId: "",
            mainScreenFilled: false,
            adminOnMainScreen: false,
        }],
    updateDateState: null,
    lastUpdate: null,
    nForReadjustRecord: 0,
    fixedPageLimit: 4,
    removeAltGrid: false,
    nForReadjust: 0,
    reorderInterval: 30000,
    fastReorderInterval: 10000,
    lastReorderTime: 0,
    audStreamNames: [],
    currentUserPage: 0,
    mainHeightWidth: 0,
    prevMainHeightWidth: 0,
    prevDoPaginate: false,
    doPaginate: false,
    shareEnded: false,
    lStreams: [],
    chatRefStreams: [],
    controlHeight: 0,
    isWideScreen: false,
    isMediumScreen: false,
    isSmallScreen: false,
    addGrid: false,
    addAltGrid: false,
    gridRows: 0,
    gridCols: 0,
    altGridRows: 0,
    altGridCols: 0,
    numberPages: 0,
    currentStreams: [],
    showMiniView: false,
    nStream: null,
    defer_receive: false,
    allAudioStreams: [],
    remoteScreenStream: [],
    screenProducer: null,
    localScreenProducer: null,
    gotAllVids: false,
    paginationHeightWidth: 40,
    paginationDirection: 'horizontal',
    gridSizes: { gridWidth: 0, gridHeight: 0, altGridWidth: 0, altGridHeight: 0 },
    screenForceFullDisplay: false,
    mainGridStream: [],
    otherGridStreams: [[], []],
    audioOnlyStreams: [],
    videoInputs: [],
    audioInputs: [],
    meetingProgressTime: '00:00:00',
    meetingElapsedTime: 0,
    ref_participants: [],
    // Messaging, event, modals, and other UI states
    messages: [],
    startDirectMessage: false,
    directMessageDetails: null,
    showMessagesBadge: false,
    audioSetting: 'allow',
    videoSetting: 'allow',
    screenshareSetting: 'allow',
    chatSetting: 'allow',
    displayOption: 'media',
    autoWave: true,
    forceFullDisplay: true,
    prevForceFullDisplay: false,
    prevMeetingDisplayType: 'video',
    waitingRoomFilter: '',
    waitingRoomList: [],
    waitingRoomCounter: 0,
    filteredWaitingRoomList: [],
    requestFilter: '',
    requestList: [],
    requestCounter: 0,
    filteredRequestList: [],
    totalReqWait: 0,
    alertVisible: false,
    alertMessage: '',
    alertType: 'success',
    alertDuration: 3000,
    progressTimerVisible: true,
    progressTimerValue: 0,
    isMenuModalVisible: false,
    isRecordingModalVisible: false,
    isSettingsModalVisible: false,
    isRequestsModalVisible: false,
    isWaitingModalVisible: false,
    isCoHostModalVisible: false,
    isMediaSettingsModalVisible: false,
    isDisplaySettingsModalVisible: false,
    isParticipantsModalVisible: false,
    isMessagesModalVisible: false,
    isConfirmExitModalVisible: false,
    isConfirmHereModalVisible: false,
    isShareEventModalVisible: false,
    isLoadingModalVisible: false,
    recordingMediaOptions: 'video',
    recordingAudioOptions: 'all',
    recordingVideoOptions: 'all',
    recordingVideoType: 'fullDisplay',
    recordingVideoOptimized: false,
    recordingDisplayType: 'video',
    recordingAddHLS: true,
    recordingNameTags: true,
    recordingBackgroundColor: '#83c0e9',
    recordingNameTagsColor: '#ffffff',
    recordingAddText: false,
    recordingCustomText: 'Add Text',
    recordingCustomTextPosition: 'top',
    recordingCustomTextColor: '#ffffff',
    recordingOrientationVideo: 'landscape',
    clearedToResume: true,
    clearedToRecord: true,
    recordState: 'green',
    showRecordButtons: false,
    recordingProgressTime: '00:00:00',
    audioSwitching: false,
    videoSwitching: false,
    videoAlreadyOn: false,
    audioAlreadyOn: false,
    componentSizes: { mainHeight: 0, otherHeight: 0, mainWidth: 0, otherWidth: 0 },
    hasCameraPermission: false,
    hasAudioPermission: false,
    transportCreated: false,
    localTransportCreated: false,
    transportCreatedVideo: false,
    transportCreatedAudio: false,
    transportCreatedScreen: false,
    producerTransport: null,
    localProducerTransport: null,
    videoProducer: null,
    localVideoProducer: null,
    params: {},
    videoParams: {},
    audioParams: {},
    audioProducer: null,
    localAudioProducer: null,
    consumerTransports: [],
    consumingTransports: [],
    // Polls
    polls: [],
    poll: null,
    isPollModalVisible: false,
    // Background
    customImage: '',
    selectedImage: '',
    segmentVideo: null,
    selfieSegmentation: null,
    pauseSegmentation: false,
    processedStream: null,
    keepBackground: false,
    backgroundHasChanged: false,
    virtualStream: null,
    mainCanvas: null,
    prevKeepBackground: false,
    appliedBackground: false,
    isBackgroundModalVisible: false,
    autoClickBackground: false,
    // Breakout Rooms
    breakoutRooms: [],
    currentRoomIndex: 0,
    canStartBreakout: false,
    breakOutRoomStarted: false,
    breakOutRoomEnded: false,
    hostNewRoom: -1,
    limitedBreakRoom: [],
    mainRoomsLength: 0,
    memberRoom: -1,
    isBreakoutRoomsModalVisible: false,
    // Whiteboard
    whiteboardUsers: [],
    currentWhiteboardIndex: 0,
    canStartWhiteboard: false,
    whiteboardStarted: false,
    whiteboardEnded: false,
    whiteboardLimit: 4,
    isWhiteboardModalVisible: false,
    isConfigureWhiteboardModalVisible: false,
    shapes: [],
    useImageBackground: true,
    redoStack: [],
    undoStack: [],
    canvasStream: null,
    canvasWhiteboard: null,
    // Screenboard
    canvasScreenboard: null,
    processedScreenStream: null,
    annotateScreenStream: false,
    mainScreenCanvas: null,
    isScreenboardModalVisible: false,
    // Control Buttons
    micActive: false,
    videoActive: false,
    screenShareActive: false,
    endCallActive: false,
    participantsActive: false,
    menuActive: false,
    commentsActive: false,
};

/**
 * Asynchronously retrieves and updates messages for a specified room from the server.
 *
 * This method communicates with the server to request messages for a specific room and updates the messages array accordingly.
 *
 * @param {ReceiveRoomMessagesOptions} options - The function parameters.
 * @param {Socket} options.socket - The socket instance used for communication.
 * @param {string} options.roomName - The name of the room to retrieve messages for.
 * @param {function} options.updateMessages - Function to update the messages array with the retrieved messages.
 *
 * @returns {Promise<void>} A promise that resolves when the messages have been successfully retrieved and updated.
 *
 * @throws Will log an error message if an error occurs during the process of retrieving messages.
 *
 * @example
 * ```typescript
 * const options = {
 *   socket: socketInstance,
 *   roomName: 'Room1',
 *   updateMessages: (messages) => {
 *     // Logic to update messages
 *   },
 * };
 *
 * await receiveRoomMessages(options);
 * ```
 */
class ReceiveRoomMessages {
    /**
     * Asynchronously retrieves and updates messages for a specified room from the server.
     *
     * @param {object} options - The function parameters.
     * @param {object} options.parameters - Additional parameters needed for the function.
     * @param {string} options.parameters.roomName - The name of the room to retrieve messages for.
     * @param {function} options.parameters.updateMessages - Function to update the messages array.
     */
    async receiveRoomMessages({ socket, roomName, updateMessages, }) {
        try {
            // Retrieve messages from the server
            await new Promise((resolve, reject) => {
                socket.emit('getMessage', { roomName }, async ({ messages_ }) => {
                    try {
                        const updatedMessages = messages_;
                        updateMessages(updatedMessages);
                        resolve();
                    }
                    catch (err) {
                        reject(err);
                    }
                });
            });
        }
        catch (error) {
            // Handle errors if any
            console.log('Error tuning messages:', error.message);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReceiveRoomMessages, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReceiveRoomMessages, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ReceiveRoomMessages, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * MenuWidget displays an icon with an optional badge counter, used for notifications or alerts.
 *
 * @selector app-menu-widget
 * @standalone true
 * @imports CommonModule, FontAwesomeModule
 *
 * @inputs
 * - `icon` (IconDefinition): FontAwesome icon to display.
 * - `iconColor` (string): Color of the icon. Default is 'black'.
 * - `badgeValue` (number): The numeric value displayed within the badge.
 * - `showBadge` (boolean): Controls the visibility of the badge. Default is false.
 *
 * @example
 * ```html
 * <app-menu-widget
 *   [icon]="faBell"
 *   iconColor="blue"
 *   [badgeValue]="5"
 *   [showBadge]="true"
 * ></app-menu-widget>
 * ```
 **/
class MenuWidget {
    icon;
    iconColor = 'black';
    badgeValue;
    showBadge = false;
    constructor(icon, iconColor, badgeValue, showBadge) {
        this.icon = icon;
        this.iconColor = iconColor;
        this.badgeValue = badgeValue;
        this.showBadge = showBadge;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MenuWidget, deps: [{ token: 'icon' }, { token: 'iconColor' }, { token: 'badgeValue' }, { token: 'showBadge' }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MenuWidget, isStandalone: true, selector: "app-menu-widget", inputs: { icon: "icon", iconColor: "iconColor", badgeValue: "badgeValue", showBadge: "showBadge" }, ngImport: i0, template: `
    <div style="position: relative; display: inline-block;">
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <div
        style="
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      align-items: center;
      justify-content: center;
    "
      >
        <div
          style="
        background-color: red;
        border-radius: 8px;
        padding: 4px 8px;
        min-width: 16px; /* Ensure a minimum width for consistent circular shape */
        min-height: 16px; /* Ensure a minimum height for consistent circular shape */
        display: flex;
        align-items: center;
        justify-content: center;
      "
          *ngIf="showBadge"
        >
          <span style="color: white; font-size: 8px; font-weight: bold;">
            {{ badgeValue }}
          </span>
        </div>
      </div>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MenuWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-menu-widget',
                    template: `
    <div style="position: relative; display: inline-block;">
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <div
        style="
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      align-items: center;
      justify-content: center;
    "
      >
        <div
          style="
        background-color: red;
        border-radius: 8px;
        padding: 4px 8px;
        min-width: 16px; /* Ensure a minimum width for consistent circular shape */
        min-height: 16px; /* Ensure a minimum height for consistent circular shape */
        display: flex;
        align-items: center;
        justify-content: center;
      "
          *ngIf="showBadge"
        >
          <span style="color: white; font-size: 8px; font-weight: bold;">
            {{ badgeValue }}
          </span>
        </div>
      </div>
    </div>
  `,
                    imports: [CommonModule, FontAwesomeModule]
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['icon']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['iconColor']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['badgeValue']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['showBadge']
                }] }], propDecorators: { icon: [{
                type: Input
            }], iconColor: [{
                type: Input
            }], badgeValue: [{
                type: Input
            }], showBadge: [{
                type: Input
            }] } });

/**
 * MessageWidget displays an icon with an optional badge counter, useful for unread message notifications.
 *
 * @selector app-message-widget
 * @standalone true
 * @imports CommonModule, FontAwesomeModule
 *
 * @inputs
 * - `icon` (IconDefinition): FontAwesome icon to represent the message feature.
 * - `iconColor` (string): Color of the icon. Default is 'black'.
 * - `badgeValue` (number): Numeric value displayed in the badge, e.g., unread message count.
 * - `showBadge` (boolean): Controls the visibility of the badge. Default is false.
 *
 * @example
 * ```html
 * <app-message-widget
 *   [icon]="faEnvelope"
 *   iconColor="blue"
 *   [badgeValue]="3"
 *   [showBadge]="true"
 * ></app-message-widget>
 * ```
 **/
class MessageWidget {
    icon;
    iconColor = 'black';
    badgeValue;
    showBadge = false;
    constructor(icon, iconColor, badgeValue, showBadge) {
        this.icon = icon;
        this.iconColor = iconColor;
        this.badgeValue = badgeValue;
        this.showBadge = showBadge;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MessageWidget, deps: [{ token: 'icon' }, { token: 'iconColor' }, { token: 'badgeValue' }, { token: 'showBadge' }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MessageWidget, isStandalone: true, selector: "app-message-widget", inputs: { icon: "icon", iconColor: "iconColor", badgeValue: "badgeValue", showBadge: "showBadge" }, ngImport: i0, template: `
    <div style="position: relative; display: inline-block;">
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <div
        style="
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      align-items: center;
      justify-content: center;
    "
      >
        <div
          style="
        background-color: red;
        border-radius: 8px;
        padding: 4px 8px;
        min-width: 16px; /* Ensure a minimum width for consistent circular shape */
        min-height: 16px; /* Ensure a minimum height for consistent circular shape */
        display: flex;
        align-items: center;
        justify-content: center;
      "
          *ngIf="showBadge"
        >
          <span style="color: white; font-size: 8px; font-weight: bold;">
            {{ badgeValue }}
          </span>
        </div>
      </div>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MessageWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-message-widget',
                    template: `
    <div style="position: relative; display: inline-block;">
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <div
        style="
      position: absolute;
      top: -8px;
      right: -8px;
      display: flex;
      align-items: center;
      justify-content: center;
    "
      >
        <div
          style="
        background-color: red;
        border-radius: 8px;
        padding: 4px 8px;
        min-width: 16px; /* Ensure a minimum width for consistent circular shape */
        min-height: 16px; /* Ensure a minimum height for consistent circular shape */
        display: flex;
        align-items: center;
        justify-content: center;
      "
          *ngIf="showBadge"
        >
          <span style="color: white; font-size: 8px; font-weight: bold;">
            {{ badgeValue }}
          </span>
        </div>
      </div>
    </div>
  `,
                    imports: [CommonModule, FontAwesomeModule]
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['icon']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['iconColor']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['badgeValue']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['showBadge']
                }] }], propDecorators: { icon: [{
                type: Input
            }], iconColor: [{
                type: Input
            }], badgeValue: [{
                type: Input
            }], showBadge: [{
                type: Input
            }] } });

/**
 * MenuRecordWidget is a configurable widget that displays a set of record control buttons, with customizable icon, color, and actions.
 *
 * @selector app-menu-record-widget
 * @standalone true
 * @imports CommonModule, FontAwesomeModule, ControlButtonsAltComponent
 *
 * @inputs
 * - `buttons` (RecordButton[]): Array of record button configurations, each with properties for icon, active state, colors, and actions.
 * - `direction` ('horizontal' | 'vertical'): Layout direction for the buttons. Default is 'horizontal'.
 *
 * @example
 * ```html
 * <app-menu-record-widget
 *   [buttons]="[
 *     { icon: faCircle, text: 'Record', onPress: startRecording, activeColor: 'red' },
 *     { icon: faStop, text: 'Stop', onPress: stopRecording, inActiveColor: 'gray' }
 *   ]"
 *   direction="horizontal"
 * ></app-menu-record-widget>
 * ```
 **/
class MenuRecordWidget {
    buttons = [];
    direction = 'horizontal';
    constructor(buttons, direction) {
        this.buttons = buttons;
        this.direction = direction;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MenuRecordWidget, deps: [{ token: 'buttons' }, { token: 'direction' }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MenuRecordWidget, isStandalone: true, selector: "app-menu-record-widget", ngImport: i0, template: `
    <app-control-buttons-alt-component
      [buttons]="buttons"
      [direction]="direction"
      [showAspect]="true"
    ></app-control-buttons-alt-component>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: ControlButtonsAltComponent, selector: "app-control-buttons-alt-component", inputs: ["buttons", "position", "location", "direction", "buttonsContainerStyle", "showAspect"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MenuRecordWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-menu-record-widget',
                    template: `
    <app-control-buttons-alt-component
      [buttons]="buttons"
      [direction]="direction"
      [showAspect]="true"
    ></app-control-buttons-alt-component>
  `,
                    imports: [CommonModule, FontAwesomeModule, ControlButtonsAltComponent]
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['buttons']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['direction']
                }] }] });

/**
 * RecordTimerWidget displays the current recording progress time.
 *
 * @selector app-record-timer-widget
 * @standalone true
 * @imports CommonModule
 *
 * @inputs
 * - `recordingProgressTime` (string): The time to display as recording progress.
 *
 * @example
 * ```html
 * <app-record-timer-widget [recordingProgressTime]="'00:05:23'"></app-record-timer-widget>
 * ```
 **/
class RecordTimerWidget {
    recordingProgressTime = '';
    constructor(recordingProgressTime) {
        this.recordingProgressTime = recordingProgressTime;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordTimerWidget, deps: [{ token: 'recordingProgressTime' }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: RecordTimerWidget, isStandalone: true, selector: "app-record-timer-widget", ngImport: i0, template: `
    <div style="background-color: transparent; border-width: 0; padding: 0; margin: 2;">
      <span style="background-color: transparent; border-width: 0; padding: 0; margin: 0;">
        {{ recordingProgressTime }}
      </span>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: RecordTimerWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-record-timer-widget',
                    template: `
    <div style="background-color: transparent; border-width: 0; padding: 0; margin: 2;">
      <span style="background-color: transparent; border-width: 0; padding: 0; margin: 0;">
        {{ recordingProgressTime }}
      </span>
    </div>
  `,
                    imports: [CommonModule]
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['recordingProgressTime']
                }] }] });

/**
 * MenuParticipantsWidget displays an icon and a counter for participants in a compact, customizable widget.
 *
 * @selector app-menu-participants-widget
 * @standalone true
 * @imports CommonModule, FontAwesomeModule
 *
 * @inputs
 * - `icon` (IconDefinition): The FontAwesome icon to display.
 * - `iconColor` (string): The color of the icon. Default is 'black'.
 * - `participantsCounter` (number): The number of participants displayed next to the icon.
 *
 * @example
 * ```html
 * <app-menu-participants-widget
 *   [icon]="faUsers"
 *   iconColor="blue"
 *   [participantsCounter]="10"
 * ></app-menu-participants-widget>
 * ```
 **/
class MenuParticipantsWidget {
    icon;
    iconColor = 'black';
    participantsCounter;
    constructor(icon, iconColor, participantsCounter) {
        this.icon = icon;
        this.iconColor = iconColor;
        this.participantsCounter = participantsCounter;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MenuParticipantsWidget, deps: [{ token: 'icon' }, { token: 'iconColor' }, { token: 'participantsCounter' }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MenuParticipantsWidget, isStandalone: true, selector: "app-menu-participants-widget", inputs: { icon: "icon", iconColor: "iconColor", participantsCounter: "participantsCounter" }, ngImport: i0, template: `
    <div
      style="background-color: transparent; border-width: 0; padding: 0; margin: 5px; display: flex; flex-direction: row; align-items: center; justify-content: center;"
    >
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <span style="background-color: transparent; border-width: 0; padding: 0; margin: 0;">
        {{ participantsCounter }}
      </span>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MenuParticipantsWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-menu-participants-widget',
                    template: `
    <div
      style="background-color: transparent; border-width: 0; padding: 0; margin: 5px; display: flex; flex-direction: row; align-items: center; justify-content: center;"
    >
      <fa-icon [icon]="icon" size="lg" [ngStyle]="{ color: iconColor }"></fa-icon>
      <span style="background-color: transparent; border-width: 0; padding: 0; margin: 0;">
        {{ participantsCounter }}
      </span>
    </div>
  `,
                    imports: [CommonModule, FontAwesomeModule]
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['icon']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['iconColor']
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['participantsCounter']
                }] }], propDecorators: { icon: [{
                type: Input
            }], iconColor: [{
                type: Input
            }], participantsCounter: [{
                type: Input
            }] } });

/**
 * ScreenShareWidget - Component representing a screen share button with an optional disabled state.
 *
 * This component displays a screen share icon (desktop icon) and an overlay ban icon if disabled.
 * The disabled state can be controlled either by an injected dependency or an @Input property.
 *
 * @component
 * @name ScreenShareWidget
 * @example
 * ```html
 * <app-screen-share-button [disabled]="isDisabled"></app-screen-share-button>
 * ```
 *
 * @param {boolean} disabled - Optional input to toggle the disabled state of the button.
 *
 * @property {boolean} computedDisabled - Internal state to determine if the button is disabled, controlled by either injected value or @Input property.
 * @property {faDesktop} faDesktop - FontAwesome desktop icon for screen sharing.
 * @property {faBan} faBan - FontAwesome ban icon indicating a disabled state.
 *
 * @example
 * <app-screen-share-button [disabled]="true"></app-screen-share-button>
 *
 * @constructor
 * @param {boolean} [injectedDisabled] - Optional injected disabled value.
 *
 * @method ngOnChanges - Updates the computedDisabled property based on changes to the @Input disabled.
 */
class ScreenShareWidget {
    injectedDisabled;
    disabled = false; // Input to toggle disabled state
    faDesktop = faDesktop;
    faBan = faBan;
    computedDisabled;
    constructor(injectedDisabled) {
        this.injectedDisabled = injectedDisabled;
        // Use the injected value if provided, otherwise fall back to the @Input value
        this.computedDisabled = this.injectedDisabled != null ? this.injectedDisabled : this.disabled;
    }
    ngOnChanges() {
        // Update computedDisabled whenever the Input changes
        if (this.injectedDisabled == null) {
            this.computedDisabled = this.disabled;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ScreenShareWidget, deps: [{ token: 'disabled', optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: ScreenShareWidget, isStandalone: true, selector: "app-screen-share-button", inputs: { disabled: "disabled" }, usesOnChanges: true, ngImport: i0, template: `
    <div style="position: relative; display: inline-block;">
      <!-- Desktop icon, change color based on disabled state -->
      <fa-icon [icon]="faDesktop" size="lg" [style.color]="computedDisabled ? 'black' : 'green'">
      </fa-icon>

      <!-- Red Ban icon on top if disabled -->
      <fa-icon
        *ngIf="computedDisabled"
        [icon]="faBan"
        size="lg"
        style="color: red; position: absolute; top: 0; right: 0;"
      >
      </fa-icon>
    </div>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FontAwesomeModule }, { kind: "component", type: i2.FaIconComponent, selector: "fa-icon", inputs: ["icon", "title", "animation", "mask", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: ScreenShareWidget, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-screen-share-button',
                    imports: [CommonModule, FontAwesomeModule],
                    template: `
    <div style="position: relative; display: inline-block;">
      <!-- Desktop icon, change color based on disabled state -->
      <fa-icon [icon]="faDesktop" size="lg" [style.color]="computedDisabled ? 'black' : 'green'">
      </fa-icon>

      <!-- Red Ban icon on top if disabled -->
      <fa-icon
        *ngIf="computedDisabled"
        [icon]="faBan"
        size="lg"
        style="color: red; position: absolute; top: 0; right: 0;"
      >
      </fa-icon>
    </div>
  `
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['disabled']
                }] }], propDecorators: { disabled: [{
                type: Input
            }] } });

/**
 * Creates a ResponseJoinRoom object from a ResponseJoinLocalRoom object.
 *
 * @param {CreateResponseJoinRoomOptions} options - The options containing the ResponseJoinLocalRoom object.
 * @returns {Promise<ResponseJoinRoom>} - A promise that resolves to a ResponseJoinRoom object.
 *
 * @example
 * ```typescript
 * const localRoom: ResponseJoinLocalRoom = {
 *   rtpCapabilities: null,
 *   isHost: true,
 *   eventStarted: false,
 *   isBanned: false,
 *   hostNotJoined: false,
 *   eventRoomParams: { /* MeetingRoomParams * / },
 *   recordingParams: { /* RecordingParams * / },
 *   secureCode: "12345",
 *   mediasfuURL: "https://example.com",
 *   apiKey: "api-key",
 *   apiUserName: "user-name",
 *   allowRecord: true,
 * };
 *
 * const joinRoom = await createResponseJoinRoom({ localRoom });
 * console.log(joinRoom);
 * ```
 */
const createResponseJoinRoom = async ({ localRoom, }) => {
    return {
        rtpCapabilities: localRoom.rtpCapabilities ?? null,
        success: localRoom.rtpCapabilities !== null,
        roomRecvIPs: [], // Placeholder; populate with necessary values
        meetingRoomParams: localRoom.eventRoomParams,
        recordingParams: localRoom.recordingParams,
        secureCode: localRoom.secureCode,
        recordOnly: false, // Default assumption unless additional logic applies
        isHost: localRoom.isHost,
        safeRoom: false, // Default assumption unless additional logic applies
        autoStartSafeRoom: false, // Default assumption unless additional logic applies
        safeRoomStarted: false, // Default assumption unless additional logic applies
        safeRoomEnded: false, // Default assumption unless additional logic applies
        reason: localRoom.isBanned ? "User is banned from the room." : undefined,
        banned: localRoom.isBanned,
        suspended: false, // Default assumption unless additional logic applies
        noAdmin: localRoom.hostNotJoined,
    };
};

/**
 * MediasfuGeneric component provides a customizable interface with a full suite of modal windows and flexible layout options for interactive media applications.
 *
 * @component
 * @selector app-mediasfu-generic
 * @standalone true
 * @imports [RouterOutlet, CommonModule, BreakoutRoomsModal, BackgroundModal, CoHostModal, AlertComponent, AudioGrid, ControlButtonsAltComponent, ControlButtonsComponentTouch, ControlButtonsComponent, FlexibleGrid, FlexibleVideo, LoadingModal, Pagination, SubAspectComponent, DisplaySettingsModal, EventSettingsModal, ConfirmExitModal, MediaSettingsModal, MenuModal, MessagesModal, ConfirmHereModal, ShareEventModal, WelcomePage, ParticipantsModal, PollModal, RecordingModal, RequestsModal, MainAspectComponent, MainContainerComponent, MainGridComponent, MainScreenComponent, OtherGridComponent, Screenboard, ScreenboardModal, Whiteboard, ConfigureWhiteboardModal, WaitingRoomModal, MenuWidget, MessageWidget, MenuRecordWidget, RecordTimerWidget, MenuParticipantsWidget, ScreenShareWidget]
 *
 * @template
 * The template structure:
 * - Conditional rendering of a PrejoinPage or WelcomePage for introductory or pre-session screens.
 * - Main content area with nested components for grid layouts, flexible video, and audio grids.
 * - Modals for user interactions, including participant management, event settings, breakout rooms, whiteboarding, and media settings.
 *
 * @input {any} PrejoinPage - Component for the prejoin page, defaults to `WelcomePage`.
 * @input {MediasfuGenericOptions} options - Configuration options for the component.
 * @input {boolean} connectMediaSFU - Flag to enable/disable connection to the MediaSFU server.
 * @input {string} localLink - Local link for the Community Edition server.
 * @input {{ apiUserName: string; apiKey: string }} credentials - API credentials for secure access.
 * @input {boolean} useLocalUIMode - Flag to toggle local UI settings.
 * @input {SeedData} seedData - Seed data for initializing the component with specific configurations.
 * @input {boolean} useSeed - Enable/disable use of seed data.
 * @input {string} imgSrc - URL for branding images or logos.
 * @input {object} sourceParameters - Additional parameters for the source.
 * @input {Function} updateSourceParameters - Function to update the source parameters.
 * @input {boolean} returnUI - Flag to return the UI elements.
 * @input {CreateMediaSFURoomOptions | JoinMediaSFURoomOptions} noUIPreJoinOptions - Options for the prejoin page without UI.
 * @input {JoinRoomOnMediaSFUType} joinMediaSFURoom - Function to join a room on MediaSFU.
 * @input {CreateRoomOnMediaSFUType} createMediaSFURoom - Function to create a room on MediaSFU.
 *
 * @property {string} title - The title of the component, defaults to "MediaSFU-Generic".
 *
 * @styles
 * Component-specific styles, including full-screen settings and customizable colors for backgrounds.
 *
 * @providers [CookieService] - Provides cookies service for session handling.
 *
 * @constructor
 * @class MediasfuGeneric
 * @implements OnInit, OnDestroy
 *
 * @method ngOnInit - Initializes the component and its configurations.
 * @method ngOnDestroy - Performs cleanup, removing event listeners and intervals as needed.
 *
 * @example
 * ```html
 * <app-mediasfu-generic
 *   [PrejoinPage]="CustomPrejoinComponent"
 *   [localLink]="'https://localhost:3000'"
 *   [connectMediaSFU]="true"
 *   [credentials]="{ apiUserName: 'username', apiKey: 'apikey' }"
 *   [useLocalUIMode]="true"
 *   [seedData]="seedDataObject"
 *   [useSeed]="true"
 *   [imgSrc]="https://example.com/logo.png">
 *   [sourceParameters]="{ source: 'camera', width: 640, height: 480 }"
 *   [updateSourceParameters]="updateSourceParameters"
 *   [returnUI]="true"
 *   [noUIPreJoinOptions]="{ roomName: 'room1', userName: 'user1' }"
 *   [joinMediaSFURoom]="joinMediaSFURoom"
 *   [createMediaSFURoom]="createMediaSFURoom">
 * </app-mediasfu-generic>
 * ```
 */
class MediasfuGeneric {
    cdr;
    injector;
    updateMiniCardsGrid;
    mixStreams;
    dispStreams;
    stopShareScreen;
    checkScreenShare;
    startShareScreen;
    requestScreenShare;
    reorderStreams;
    prepopulateUserMedia;
    getVideos;
    rePort;
    trigger;
    consumerResume;
    connectSendTransport;
    connectSendTransportAudio;
    connectSendTransportVideo;
    connectSendTransportScreen;
    processConsumerTransports;
    resumePauseStreams;
    readjust;
    checkGrid;
    getEstimate;
    calculateRowsAndColumns;
    addVideosGrid;
    onScreenChanges;
    changeVids;
    compareActiveNames;
    compareScreenStates;
    createSendTransport;
    resumeSendTransportAudio;
    receiveAllPipedTransports;
    disconnectSendTransportVideo;
    disconnectSendTransportAudio;
    disconnectSendTransportScreen;
    getPipedProducersAlt;
    signalNewConsumerTransport;
    connectRecvTransport;
    reUpdateInter;
    updateParticipantAudioDecibels;
    closeAndResize;
    autoAdjust;
    switchUserVideoAlt;
    switchUserVideo;
    switchUserAudio;
    getDomains;
    formatNumber;
    connectIps;
    connectLocalIps;
    createDeviceClient;
    handleCreatePoll;
    handleEndPoll;
    handleVotePoll;
    captureCanvasStream;
    resumePauseAudioStreams;
    processConsumerTransportsAudio;
    launchMenuModal;
    launchRecording;
    startRecording;
    confirmRecording;
    launchWaiting;
    launchCoHost;
    launchMediaSettings;
    launchDisplaySettings;
    launchSettings;
    launchRequests;
    launchParticipants;
    launchMessages;
    launchConfirmExit;
    launchPoll;
    launchBreakoutRooms;
    launchConfigureWhiteboard;
    startMeetingProgressTimer;
    updateRecording;
    stopRecording;
    userWaiting;
    personJoined;
    allWaitingRoomMembers;
    roomRecordParams;
    banParticipant;
    updatedCoHost;
    participantRequested;
    screenProducerId;
    updateMediaSettings;
    producerMediaPaused;
    producerMediaResumed;
    producerMediaClosed;
    controlMediaHost;
    meetingEnded;
    disconnectUserSelf;
    receiveMessage;
    meetingTimeRemaining;
    meetingStillThere;
    startRecords;
    reInitiateRecording;
    recordingNotice;
    timeLeftRecording;
    stoppedRecording;
    hostRequestResponse;
    allMembers;
    allMembersRest;
    disconnect;
    pollUpdated;
    breakoutRoomUpdated;
    socketManager;
    joinRoomClient;
    joinLocalRoom;
    updateRoomParametersClient;
    clickVideo;
    clickAudio;
    clickScreenShare;
    switchVideoAlt;
    streamSuccessVideo;
    streamSuccessAudio;
    streamSuccessScreen;
    streamSuccessAudioSwitch;
    checkPermission;
    updateConsumingDomains;
    receiveRoomMessages;
    PrejoinPage = WelcomePage;
    localLink = '';
    connectMediaSFU = true;
    credentials = { apiUserName: '', apiKey: '' };
    useLocalUIMode = false;
    seedData;
    useSeed = false;
    imgSrc = 'https://mediasfu.com/images/logo192.png';
    sourceParameters = {};
    updateSourceParameters = (data) => { };
    returnUI = true;
    noUIPreJoinOptions;
    joinMediaSFURoom;
    createMediaSFURoom;
    title = 'MediaSFU-Generic';
    mainHeightWidthSubscription;
    validatedSubscription;
    islevelSubscription;
    coHostSubscription;
    buttonSubscriptions = [];
    ScreenboardSubscription;
    recordingSubscription;
    constructor(cdr, injector, updateMiniCardsGrid, mixStreams, dispStreams, stopShareScreen, checkScreenShare, startShareScreen, requestScreenShare, reorderStreams, prepopulateUserMedia, getVideos, rePort, trigger, consumerResume, connectSendTransport, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, processConsumerTransports, resumePauseStreams, readjust, checkGrid, getEstimate, calculateRowsAndColumns, addVideosGrid, onScreenChanges, changeVids, compareActiveNames, compareScreenStates, createSendTransport, resumeSendTransportAudio, receiveAllPipedTransports, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, getPipedProducersAlt, signalNewConsumerTransport, connectRecvTransport, reUpdateInter, updateParticipantAudioDecibels, closeAndResize, autoAdjust, switchUserVideoAlt, switchUserVideo, switchUserAudio, getDomains, formatNumber, connectIps, connectLocalIps, createDeviceClient, handleCreatePoll, handleEndPoll, handleVotePoll, captureCanvasStream, resumePauseAudioStreams, processConsumerTransportsAudio, launchMenuModal, launchRecording, startRecording, confirmRecording, launchWaiting, launchCoHost, launchMediaSettings, launchDisplaySettings, launchSettings, launchRequests, launchParticipants, launchMessages, launchConfirmExit, launchPoll, launchBreakoutRooms, launchConfigureWhiteboard, startMeetingProgressTimer, updateRecording, stopRecording, userWaiting, personJoined, allWaitingRoomMembers, roomRecordParams, banParticipant, updatedCoHost, participantRequested, screenProducerId, updateMediaSettings, producerMediaPaused, producerMediaResumed, producerMediaClosed, controlMediaHost, meetingEnded, disconnectUserSelf, receiveMessage, meetingTimeRemaining, meetingStillThere, startRecords, reInitiateRecording, recordingNotice, timeLeftRecording, stoppedRecording, hostRequestResponse, allMembers, allMembersRest, disconnect, pollUpdated, breakoutRoomUpdated, socketManager, joinRoomClient, joinLocalRoom, updateRoomParametersClient, clickVideo, clickAudio, clickScreenShare, switchVideoAlt, streamSuccessVideo, streamSuccessAudio, streamSuccessScreen, streamSuccessAudioSwitch, checkPermission, updateConsumingDomains, receiveRoomMessages) {
        this.cdr = cdr;
        this.injector = injector;
        this.updateMiniCardsGrid = updateMiniCardsGrid;
        this.mixStreams = mixStreams;
        this.dispStreams = dispStreams;
        this.stopShareScreen = stopShareScreen;
        this.checkScreenShare = checkScreenShare;
        this.startShareScreen = startShareScreen;
        this.requestScreenShare = requestScreenShare;
        this.reorderStreams = reorderStreams;
        this.prepopulateUserMedia = prepopulateUserMedia;
        this.getVideos = getVideos;
        this.rePort = rePort;
        this.trigger = trigger;
        this.consumerResume = consumerResume;
        this.connectSendTransport = connectSendTransport;
        this.connectSendTransportAudio = connectSendTransportAudio;
        this.connectSendTransportVideo = connectSendTransportVideo;
        this.connectSendTransportScreen = connectSendTransportScreen;
        this.processConsumerTransports = processConsumerTransports;
        this.resumePauseStreams = resumePauseStreams;
        this.readjust = readjust;
        this.checkGrid = checkGrid;
        this.getEstimate = getEstimate;
        this.calculateRowsAndColumns = calculateRowsAndColumns;
        this.addVideosGrid = addVideosGrid;
        this.onScreenChanges = onScreenChanges;
        this.changeVids = changeVids;
        this.compareActiveNames = compareActiveNames;
        this.compareScreenStates = compareScreenStates;
        this.createSendTransport = createSendTransport;
        this.resumeSendTransportAudio = resumeSendTransportAudio;
        this.receiveAllPipedTransports = receiveAllPipedTransports;
        this.disconnectSendTransportVideo = disconnectSendTransportVideo;
        this.disconnectSendTransportAudio = disconnectSendTransportAudio;
        this.disconnectSendTransportScreen = disconnectSendTransportScreen;
        this.getPipedProducersAlt = getPipedProducersAlt;
        this.signalNewConsumerTransport = signalNewConsumerTransport;
        this.connectRecvTransport = connectRecvTransport;
        this.reUpdateInter = reUpdateInter;
        this.updateParticipantAudioDecibels = updateParticipantAudioDecibels;
        this.closeAndResize = closeAndResize;
        this.autoAdjust = autoAdjust;
        this.switchUserVideoAlt = switchUserVideoAlt;
        this.switchUserVideo = switchUserVideo;
        this.switchUserAudio = switchUserAudio;
        this.getDomains = getDomains;
        this.formatNumber = formatNumber;
        this.connectIps = connectIps;
        this.connectLocalIps = connectLocalIps;
        this.createDeviceClient = createDeviceClient;
        this.handleCreatePoll = handleCreatePoll;
        this.handleEndPoll = handleEndPoll;
        this.handleVotePoll = handleVotePoll;
        this.captureCanvasStream = captureCanvasStream;
        this.resumePauseAudioStreams = resumePauseAudioStreams;
        this.processConsumerTransportsAudio = processConsumerTransportsAudio;
        this.launchMenuModal = launchMenuModal;
        this.launchRecording = launchRecording;
        this.startRecording = startRecording;
        this.confirmRecording = confirmRecording;
        this.launchWaiting = launchWaiting;
        this.launchCoHost = launchCoHost;
        this.launchMediaSettings = launchMediaSettings;
        this.launchDisplaySettings = launchDisplaySettings;
        this.launchSettings = launchSettings;
        this.launchRequests = launchRequests;
        this.launchParticipants = launchParticipants;
        this.launchMessages = launchMessages;
        this.launchConfirmExit = launchConfirmExit;
        this.launchPoll = launchPoll;
        this.launchBreakoutRooms = launchBreakoutRooms;
        this.launchConfigureWhiteboard = launchConfigureWhiteboard;
        this.startMeetingProgressTimer = startMeetingProgressTimer;
        this.updateRecording = updateRecording;
        this.stopRecording = stopRecording;
        this.userWaiting = userWaiting;
        this.personJoined = personJoined;
        this.allWaitingRoomMembers = allWaitingRoomMembers;
        this.roomRecordParams = roomRecordParams;
        this.banParticipant = banParticipant;
        this.updatedCoHost = updatedCoHost;
        this.participantRequested = participantRequested;
        this.screenProducerId = screenProducerId;
        this.updateMediaSettings = updateMediaSettings;
        this.producerMediaPaused = producerMediaPaused;
        this.producerMediaResumed = producerMediaResumed;
        this.producerMediaClosed = producerMediaClosed;
        this.controlMediaHost = controlMediaHost;
        this.meetingEnded = meetingEnded;
        this.disconnectUserSelf = disconnectUserSelf;
        this.receiveMessage = receiveMessage;
        this.meetingTimeRemaining = meetingTimeRemaining;
        this.meetingStillThere = meetingStillThere;
        this.startRecords = startRecords;
        this.reInitiateRecording = reInitiateRecording;
        this.recordingNotice = recordingNotice;
        this.timeLeftRecording = timeLeftRecording;
        this.stoppedRecording = stoppedRecording;
        this.hostRequestResponse = hostRequestResponse;
        this.allMembers = allMembers;
        this.allMembersRest = allMembersRest;
        this.disconnect = disconnect;
        this.pollUpdated = pollUpdated;
        this.breakoutRoomUpdated = breakoutRoomUpdated;
        this.socketManager = socketManager;
        this.joinRoomClient = joinRoomClient;
        this.joinLocalRoom = joinLocalRoom;
        this.updateRoomParametersClient = updateRoomParametersClient;
        this.clickVideo = clickVideo;
        this.clickAudio = clickAudio;
        this.clickScreenShare = clickScreenShare;
        this.switchVideoAlt = switchVideoAlt;
        this.streamSuccessVideo = streamSuccessVideo;
        this.streamSuccessAudio = streamSuccessAudio;
        this.streamSuccessScreen = streamSuccessScreen;
        this.streamSuccessAudioSwitch = streamSuccessAudioSwitch;
        this.checkPermission = checkPermission;
        this.updateConsumingDomains = updateConsumingDomains;
        this.receiveRoomMessages = receiveRoomMessages;
    }
    createInjector(inputs) {
        const inj = Injector.create({
            providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
            parent: this.injector,
        });
        return inj;
    }
    // Initial values
    mediaSFUFunctions = () => {
        return {
            updateMiniCardsGrid: this.updateMiniCardsGrid?.updateMiniCardsGrid ||
                (() => {
                    console.log('none');
                }),
            mixStreams: this.mixStreams?.mixStreams ||
                (() => {
                    console.log('none');
                }),
            dispStreams: this.dispStreams?.dispStreams ||
                (() => {
                    console.log('none');
                }),
            stopShareScreen: this.stopShareScreen?.stopShareScreen ||
                (() => {
                    console.log('none');
                }),
            checkScreenShare: this.checkScreenShare?.checkScreenShare ||
                (() => {
                    console.log('none');
                }),
            startShareScreen: this.startShareScreen?.startShareScreen ||
                (() => {
                    console.log('none');
                }),
            requestScreenShare: this.requestScreenShare?.requestScreenShare ||
                (() => {
                    console.log('none');
                }),
            reorderStreams: this.reorderStreams?.reorderStreams ||
                (() => {
                    console.log('none');
                }),
            prepopulateUserMedia: this.prepopulateUserMedia?.prepopulateUserMedia ||
                (() => {
                    console.log('none');
                }),
            getVideos: this.getVideos?.getVideos ||
                (() => {
                    console.log('none');
                }),
            rePort: this.rePort?.rePort ||
                (() => {
                    console.log('none');
                }),
            trigger: this.trigger?.trigger ||
                (() => {
                    console.log('none');
                }),
            consumerResume: this.consumerResume?.consumerResume ||
                (() => {
                    console.log('none');
                }),
            connectSendTransport: this.connectSendTransport?.connectSendTransport ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportAudio: this.connectSendTransportAudio?.connectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportVideo: this.connectSendTransportVideo?.connectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportScreen: this.connectSendTransportScreen?.connectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransports: this.processConsumerTransports?.processConsumerTransports ||
                (() => {
                    console.log('none');
                }),
            resumePauseStreams: this.resumePauseStreams?.resumePauseStreams ||
                (() => {
                    console.log('none');
                }),
            readjust: this.readjust?.readjust ||
                (() => {
                    console.log('none');
                }),
            checkGrid: this.checkGrid?.checkGrid ||
                (() => {
                    console.log('none');
                }),
            getEstimate: this.getEstimate?.getEstimate ||
                (() => {
                    console.log('none');
                }),
            calculateRowsAndColumns: this.calculateRowsAndColumns?.calculateRowsAndColumns ||
                (() => {
                    console.log('none');
                }),
            addVideosGrid: this.addVideosGrid?.addVideosGrid ||
                (() => {
                    console.log('none');
                }),
            onScreenChanges: this.onScreenChanges?.onScreenChanges ||
                (() => {
                    console.log('none');
                }),
            sleep: sleep ||
                (() => {
                    console.log('none');
                }),
            changeVids: this.changeVids?.changeVids ||
                (() => {
                    console.log('none');
                }),
            compareActiveNames: this.compareActiveNames?.compareActiveNames ||
                (() => {
                    console.log('none');
                }),
            compareScreenStates: this.compareScreenStates?.compareScreenStates ||
                (() => {
                    console.log('none');
                }),
            createSendTransport: this.createSendTransport?.createSendTransport ||
                (() => {
                    console.log('none');
                }),
            resumeSendTransportAudio: this.resumeSendTransportAudio?.resumeSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            receiveAllPipedTransports: this.receiveAllPipedTransports?.receiveAllPipedTransports ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportVideo: this.disconnectSendTransportVideo?.disconnectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportAudio: this.disconnectSendTransportAudio?.disconnectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportScreen: this.disconnectSendTransportScreen?.disconnectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            getPipedProducersAlt: this.getPipedProducersAlt?.getPipedProducersAlt ||
                (() => {
                    console.log('none');
                }),
            signalNewConsumerTransport: this.signalNewConsumerTransport?.signalNewConsumerTransport ||
                (() => {
                    console.log('none');
                }),
            connectRecvTransport: this.connectRecvTransport?.connectRecvTransport ||
                (() => {
                    console.log('none');
                }),
            reUpdateInter: this.reUpdateInter?.reUpdateInter ||
                (() => {
                    console.log('none');
                }),
            updateParticipantAudioDecibels: this.updateParticipantAudioDecibels?.updateParticipantAudioDecibels ||
                (() => {
                    console.log('none');
                }),
            closeAndResize: this.closeAndResize?.closeAndResize ||
                (() => {
                    console.log('none');
                }),
            autoAdjust: this.autoAdjust?.autoAdjust ||
                (() => {
                    console.log('none');
                }),
            switchUserVideoAlt: this.switchUserVideoAlt?.switchUserVideoAlt ||
                (() => {
                    console.log('none');
                }),
            switchUserVideo: this.switchUserVideo?.switchUserVideo ||
                (() => {
                    console.log('none');
                }),
            switchUserAudio: this.switchUserAudio?.switchUserAudio ||
                (() => {
                    console.log('none');
                }),
            getDomains: this.getDomains?.getDomains ||
                (() => {
                    console.log('none');
                }),
            formatNumber: this.formatNumber?.formatNumber ||
                (() => {
                    console.log('none');
                }),
            connectIps: this.connectIps?.connectIps ||
                (() => {
                    console.log('none');
                }),
            connectLocalIps: this.connectLocalIps?.connectLocalIps ||
                (() => {
                    console.log('none');
                }),
            createDeviceClient: this.createDeviceClient?.createDeviceClient ||
                (() => {
                    console.log('none');
                }),
            handleCreatePoll: this.handleCreatePoll?.handleCreatePoll ||
                (() => {
                    console.log('none');
                }),
            handleEndPoll: this.handleEndPoll?.handleEndPoll ||
                (() => {
                    console.log('none');
                }),
            handleVotePoll: this.handleVotePoll?.handleVotePoll ||
                (() => {
                    console.log('none');
                }),
            captureCanvasStream: this.captureCanvasStream?.captureCanvasStream ||
                (() => {
                    console.log('none');
                }),
            resumePauseAudioStreams: this.resumePauseAudioStreams?.resumePauseAudioStreams ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransportsAudio: this.processConsumerTransportsAudio?.processConsumerTransportsAudio ||
                (() => {
                    console.log('none');
                }),
            checkPermission: this.checkPermission?.checkPermission ||
                (() => {
                    console.log('none');
                }),
            streamSuccessVideo: this.streamSuccessVideo?.streamSuccessVideo ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudio: this.streamSuccessAudio?.streamSuccessAudio ||
                (() => {
                    console.log('none');
                }),
            streamSuccessScreen: this.streamSuccessScreen?.streamSuccessScreen ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudioSwitch: this.streamSuccessAudioSwitch?.streamSuccessAudioSwitch ||
                (() => {
                    console.log('none');
                }),
            clickVideo: this.clickVideo?.clickVideo ||
                (() => {
                    console.log('none');
                }),
            clickAudio: this.clickAudio?.clickAudio ||
                (() => {
                    console.log('none');
                }),
            clickScreenShare: this.clickScreenShare?.clickScreenShare ||
                (() => {
                    console.log('none');
                }),
            switchVideoAlt: this.switchVideoAlt?.switchVideoAlt ||
                (() => {
                    console.log('none');
                }),
            requestPermissionCamera: this.requestPermissionCamera ||
                (() => {
                    console.log('none');
                }),
            requestPermissionAudio: this.requestPermissionAudio ||
                (() => {
                    console.log('none');
                }),
        };
    };
    validated = new BehaviorSubject$1(false);
    localUIMode = new BehaviorSubject$1(false);
    socket = new BehaviorSubject$1({});
    localSocket = new BehaviorSubject$1(undefined);
    roomData = new BehaviorSubject$1(null);
    device = new BehaviorSubject$1(null);
    apiKey = new BehaviorSubject$1('');
    apiUserName = new BehaviorSubject$1('');
    apiToken = new BehaviorSubject$1('');
    link = new BehaviorSubject$1('');
    roomName = new BehaviorSubject$1('');
    member = new BehaviorSubject$1('');
    adminPasscode = new BehaviorSubject$1('');
    islevel = new BehaviorSubject$1('1');
    coHost = new BehaviorSubject$1('No coHost');
    coHostResponsibility = new BehaviorSubject$1([
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ]);
    youAreCoHost = new BehaviorSubject$1(false);
    youAreHost = new BehaviorSubject$1(false);
    confirmedToRecord = new BehaviorSubject$1(false);
    meetingDisplayType = new BehaviorSubject$1('media');
    meetingVideoOptimized = new BehaviorSubject$1(false);
    eventType = new BehaviorSubject$1('webinar');
    participants = new BehaviorSubject$1([]);
    filteredParticipants = new BehaviorSubject$1([]);
    participantsCounter = new BehaviorSubject$1(0);
    participantsFilter = new BehaviorSubject$1('');
    consume_sockets = new BehaviorSubject$1([]);
    rtpCapabilities = new BehaviorSubject$1(null);
    roomRecvIPs = new BehaviorSubject$1([]);
    meetingRoomParams = new BehaviorSubject$1(null);
    itemPageLimit = new BehaviorSubject$1(4);
    audioOnlyRoom = new BehaviorSubject$1(false);
    addForBasic = new BehaviorSubject$1(false);
    screenPageLimit = new BehaviorSubject$1(4);
    shareScreenStarted = new BehaviorSubject$1(false);
    shared = new BehaviorSubject$1(false);
    targetOrientation = new BehaviorSubject$1('landscape');
    targetResolution = new BehaviorSubject$1('sd');
    targetResolutionHost = new BehaviorSubject$1('sd');
    vidCons = new BehaviorSubject$1({ width: 640, height: 360 });
    frameRate = new BehaviorSubject$1(10);
    hParams = new BehaviorSubject$1({});
    vParams = new BehaviorSubject$1({});
    screenParams = new BehaviorSubject$1({});
    aParams = new BehaviorSubject$1({});
    recordingAudioPausesLimit = new BehaviorSubject$1(0);
    recordingAudioPausesCount = new BehaviorSubject$1(0);
    recordingAudioSupport = new BehaviorSubject$1(false);
    recordingAudioPeopleLimit = new BehaviorSubject$1(0);
    recordingAudioParticipantsTimeLimit = new BehaviorSubject$1(0);
    recordingVideoPausesCount = new BehaviorSubject$1(0);
    recordingVideoPausesLimit = new BehaviorSubject$1(0);
    recordingVideoSupport = new BehaviorSubject$1(false);
    recordingVideoPeopleLimit = new BehaviorSubject$1(0);
    recordingVideoParticipantsTimeLimit = new BehaviorSubject$1(0);
    recordingAllParticipantsSupport = new BehaviorSubject$1(false);
    recordingVideoParticipantsSupport = new BehaviorSubject$1(false);
    recordingAllParticipantsFullRoomSupport = new BehaviorSubject$1(false);
    recordingVideoParticipantsFullRoomSupport = new BehaviorSubject$1(false);
    recordingPreferredOrientation = new BehaviorSubject$1('landscape');
    recordingSupportForOtherOrientation = new BehaviorSubject$1(false);
    recordingMultiFormatsSupport = new BehaviorSubject$1(false);
    userRecordingParams = new BehaviorSubject$1({
        mainSpecs: {
            mediaOptions: 'video', // 'audio', 'video'
            audioOptions: 'all', // 'all', 'onScreen', 'host'
            videoOptions: 'all', // 'all', 'mainScreen'
            videoType: 'fullDisplay', // 'all', 'bestDisplay', 'fullDisplay'
            videoOptimized: false, // true, false
            recordingDisplayType: 'media', // 'media', 'video', 'all'
            addHLS: false, // true, false
        },
        dispSpecs: {
            nameTags: true, // true, false
            backgroundColor: '#000000', // '#000000', '#ffffff'
            nameTagsColor: '#ffffff', // '#000000', '#ffffff'
            orientationVideo: 'portrait', // 'landscape', 'portrait', 'all'
        },
    });
    canRecord = new BehaviorSubject$1(false);
    startReport = new BehaviorSubject$1(false);
    endReport = new BehaviorSubject$1(false);
    recordTimerInterval = new BehaviorSubject$1(null);
    recordStartTime = new BehaviorSubject$1(0);
    recordElapsedTime = new BehaviorSubject$1(0);
    isTimerRunning = new BehaviorSubject$1(false);
    canPauseResume = new BehaviorSubject$1(false);
    recordChangeSeconds = new BehaviorSubject$1(15000);
    pauseLimit = new BehaviorSubject$1(0);
    pauseRecordCount = new BehaviorSubject$1(0);
    canLaunchRecord = new BehaviorSubject$1(true);
    stopLaunchRecord = new BehaviorSubject$1(false);
    participantsAll = new BehaviorSubject$1([]);
    firstAll = new BehaviorSubject$1(false);
    updateMainWindow = new BehaviorSubject$1(false);
    first_round = new BehaviorSubject$1(false);
    landScaped = new BehaviorSubject$1(false);
    lock_screen = new BehaviorSubject$1(false);
    screenId = new BehaviorSubject$1('');
    allVideoStreams = new BehaviorSubject$1([]);
    newLimitedStreams = new BehaviorSubject$1([]);
    newLimitedStreamsIDs = new BehaviorSubject$1([]);
    activeSounds = new BehaviorSubject$1([]);
    screenShareIDStream = new BehaviorSubject$1('');
    screenShareNameStream = new BehaviorSubject$1('');
    adminIDStream = new BehaviorSubject$1('');
    adminNameStream = new BehaviorSubject$1('');
    youYouStream = new BehaviorSubject$1([]);
    youYouStreamIDs = new BehaviorSubject$1([]);
    localStream = new BehaviorSubject$1(null);
    recordStarted = new BehaviorSubject$1(false);
    recordResumed = new BehaviorSubject$1(false);
    recordPaused = new BehaviorSubject$1(false);
    recordStopped = new BehaviorSubject$1(false);
    adminRestrictSetting = new BehaviorSubject$1(false);
    videoRequestState = new BehaviorSubject$1(null);
    videoRequestTime = new BehaviorSubject$1(0);
    videoAction = new BehaviorSubject$1(false);
    localStreamVideo = new BehaviorSubject$1(null);
    userDefaultVideoInputDevice = new BehaviorSubject$1('');
    currentFacingMode = new BehaviorSubject$1('user');
    prevFacingMode = new BehaviorSubject$1('user');
    defVideoID = new BehaviorSubject$1('');
    allowed = new BehaviorSubject$1(false);
    dispActiveNames = new BehaviorSubject$1([]);
    p_dispActiveNames = new BehaviorSubject$1([]);
    activeNames = new BehaviorSubject$1([]);
    prevActiveNames = new BehaviorSubject$1([]);
    p_activeNames = new BehaviorSubject$1([]);
    membersReceived = new BehaviorSubject$1(false);
    deferScreenReceived = new BehaviorSubject$1(false);
    hostFirstSwitch = new BehaviorSubject$1(false);
    micAction = new BehaviorSubject$1(false);
    screenAction = new BehaviorSubject$1(false);
    chatAction = new BehaviorSubject$1(false);
    audioRequestState = new BehaviorSubject$1(null);
    screenRequestState = new BehaviorSubject$1(null);
    chatRequestState = new BehaviorSubject$1(null);
    audioRequestTime = new BehaviorSubject$1(0);
    screenRequestTime = new BehaviorSubject$1(0);
    chatRequestTime = new BehaviorSubject$1(0);
    updateRequestIntervalSeconds = new BehaviorSubject$1(240);
    oldSoundIds = new BehaviorSubject$1([]);
    hostLabel = new BehaviorSubject$1('Host');
    mainScreenFilled = new BehaviorSubject$1(false);
    localStreamScreen = new BehaviorSubject$1(null);
    screenAlreadyOn = new BehaviorSubject$1(false);
    chatAlreadyOn = new BehaviorSubject$1(false);
    redirectURL = new BehaviorSubject$1('');
    oldAllStreams = new BehaviorSubject$1([]);
    adminVidID = new BehaviorSubject$1('');
    streamNames = new BehaviorSubject$1([]);
    non_alVideoStreams = new BehaviorSubject$1([]);
    sortAudioLoudness = new BehaviorSubject$1(false);
    audioDecibels = new BehaviorSubject$1([]);
    mixed_alVideoStreams = new BehaviorSubject$1([]);
    non_alVideoStreams_muted = new BehaviorSubject$1([]);
    paginatedStreams = new BehaviorSubject$1([]);
    localStreamAudio = new BehaviorSubject$1(null);
    defAudioID = new BehaviorSubject$1('');
    userDefaultAudioInputDevice = new BehaviorSubject$1('');
    userDefaultAudioOutputDevice = new BehaviorSubject$1('');
    prevAudioInputDevice = new BehaviorSubject$1('');
    prevVideoInputDevice = new BehaviorSubject$1('');
    audioPaused = new BehaviorSubject$1(false);
    mainScreenPerson = new BehaviorSubject$1('');
    adminOnMainScreen = new BehaviorSubject$1(false);
    screenStates = new BehaviorSubject$1([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    prevScreenStates = new BehaviorSubject$1([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    updateDateState = new BehaviorSubject$1(null);
    lastUpdate = new BehaviorSubject$1(null);
    nForReadjustRecord = new BehaviorSubject$1(0);
    fixedPageLimit = new BehaviorSubject$1(4);
    removeAltGrid = new BehaviorSubject$1(false);
    nForReadjust = new BehaviorSubject$1(0);
    reorderInterval = new BehaviorSubject$1(30000);
    fastReorderInterval = new BehaviorSubject$1(10000);
    lastReorderTime = new BehaviorSubject$1(0);
    audStreamNames = new BehaviorSubject$1([]);
    currentUserPage = new BehaviorSubject$1(0);
    mainHeightWidth = new BehaviorSubject$1(this.eventType.value == 'webinar' ? 67 : this.eventType.value == 'broadcast' ? 100 : 0);
    prevMainHeightWidth = new BehaviorSubject$1(this.mainHeightWidth.value);
    prevDoPaginate = new BehaviorSubject$1(false);
    doPaginate = new BehaviorSubject$1(false);
    shareEnded = new BehaviorSubject$1(false);
    lStreams = new BehaviorSubject$1([]);
    chatRefStreams = new BehaviorSubject$1([]);
    controlHeight = new BehaviorSubject$1(this.eventType.value === 'webinar' || this.eventType.value === 'conference' ? 0 : 0.06);
    isWideScreen = new BehaviorSubject$1(false);
    isMediumScreen = new BehaviorSubject$1(false);
    isSmallScreen = new BehaviorSubject$1(false);
    addGrid = new BehaviorSubject$1(false);
    addAltGrid = new BehaviorSubject$1(false);
    gridRows = new BehaviorSubject$1(0);
    gridCols = new BehaviorSubject$1(0);
    altGridRows = new BehaviorSubject$1(0);
    altGridCols = new BehaviorSubject$1(0);
    numberPages = new BehaviorSubject$1(0);
    currentStreams = new BehaviorSubject$1([]);
    showMiniView = new BehaviorSubject$1(false);
    nStream = new BehaviorSubject$1(null);
    defer_receive = new BehaviorSubject$1(false);
    allAudioStreams = new BehaviorSubject$1([]);
    remoteScreenStream = new BehaviorSubject$1([]);
    screenProducer = new BehaviorSubject$1(null);
    localScreenProducer = new BehaviorSubject$1(null);
    gotAllVids = new BehaviorSubject$1(false);
    paginationHeightWidth = new BehaviorSubject$1(40);
    paginationDirection = new BehaviorSubject$1('horizontal');
    gridSizes = new BehaviorSubject$1({
        gridWidth: 0,
        gridHeight: 0,
        altGridWidth: 0,
        altGridHeight: 0,
    });
    screenForceFullDisplay = new BehaviorSubject$1(false);
    mainGridStream = new BehaviorSubject$1([]);
    otherGridStreams = new BehaviorSubject$1([]);
    audioOnlyStreams = new BehaviorSubject$1([]);
    videoInputs = new BehaviorSubject$1([]);
    audioInputs = new BehaviorSubject$1([]);
    meetingProgressTime = new BehaviorSubject$1('00:00:00');
    meetingElapsedTime = new BehaviorSubject$1(0);
    ref_participants = new BehaviorSubject$1([]);
    updateValidated = (value) => {
        this.validated.next(value);
    };
    updateSocket = (value) => {
        this.socket.next(value);
    };
    updateLocalSocket = (value) => {
        this.localSocket.next(value);
    };
    updateDevice = (value) => {
        this.device.next(value);
    };
    updateRoomData = (value) => {
        this.roomData.next(value);
    };
    updateApiKey = (value) => {
        this.apiKey.next(value);
    };
    updateApiUserName = (value) => {
        this.apiUserName.next(value);
    };
    updateApiToken = (value) => {
        this.apiToken.next(value);
    };
    updateLink = (value) => {
        this.link.next(value);
    };
    updateRoomName = (value) => {
        this.roomName.next(value);
    };
    updateMember = (value) => {
        if (value.length > 0 && value.includes("_")) {
            this.updateIslevel(value.split("_")[1]);
            value = value.split("_")[0];
        }
        this.member.next(value);
    };
    updateAdminPasscode = (value) => {
        this.adminPasscode.next(value);
    };
    updateIslevel = (value) => {
        this.islevel.next(value);
    };
    updateCoHost = (value) => {
        this.coHost.next(value);
    };
    updateCoHostResponsibility = (value) => {
        this.coHostResponsibility.next(value);
    };
    updateYouAreCoHost = (value) => {
        this.youAreCoHost.next(value);
    };
    updateYouAreHost = (value) => {
        this.youAreHost.next(value);
    };
    updateConfirmedToRecord = (value) => {
        this.confirmedToRecord.next(value);
    };
    updateMeetingDisplayType = (value) => {
        this.meetingDisplayType.next(value);
    };
    updateMeetingVideoOptimized = (value) => {
        this.meetingVideoOptimized.next(value);
    };
    updateEventType = (value) => {
        this.eventType.next(value);
        if (value != 'none') {
            try {
                setTimeout(() => {
                    this.handleResize();
                }, 2000);
            }
            catch {
                /* handle error */
            }
        }
    };
    updateParticipants = (value) => {
        this.participants.next(value);
        this.participantsCounter.next(value.length);
        this.filteredParticipants.next(this.participants.value);
    };
    updateFilteredParticipants = (value) => {
        this.filteredParticipants.next(value);
    };
    updateParticipantsCounter = (value) => {
        this.participantsCounter.next(value);
    };
    updateParticipantsFilter = (value) => {
        this.participantsFilter.next(value);
    };
    updateConsume_sockets = (value) => {
        this.consume_sockets.next(value);
    };
    updateRtpCapabilities = (value) => {
        this.rtpCapabilities.next(value);
    };
    updateRoomRecvIPs = (value) => {
        this.roomRecvIPs.next(value);
    };
    updateMeetingRoomParams = (value) => {
        this.meetingRoomParams.next(value);
    };
    updateItemPageLimit = (value) => {
        this.itemPageLimit.next(value);
    };
    updateAudioOnlyRoom = (value) => {
        this.audioOnlyRoom.next(value);
    };
    updateAddForBasic = (value) => {
        this.addForBasic.next(value);
    };
    updateScreenPageLimit = (value) => {
        this.screenPageLimit.next(value);
    };
    updateShareScreenStarted = (value) => {
        this.shareScreenStarted.next(value);
    };
    updateShared = (value) => {
        this.shared.next(value);
        this.screenShareActive.next(value);
        if (value) {
            setTimeout(async () => {
                window.dispatchEvent(new Event('resize'));
            }, 2000);
        }
    };
    updateTargetOrientation = (value) => {
        this.targetOrientation.next(value);
    };
    updateTargetResolution = (value) => {
        this.targetResolution.next(value);
    };
    updateTargetResolutionHost = (value) => {
        this.targetResolutionHost.next(value);
    };
    updateVidCons = (value) => {
        this.vidCons.next(value);
    };
    updateFrameRate = (value) => {
        this.frameRate.next(value);
    };
    updateHParams = (value) => {
        this.hParams.next(value);
    };
    updateVParams = (value) => {
        this.vParams.next(value);
    };
    updateScreenParams = (value) => {
        this.screenParams.next(value);
    };
    updateAParams = (value) => {
        this.aParams.next(value);
    };
    updateRecordingAudioPausesLimit = (value) => {
        this.recordingAudioPausesLimit.next(value);
    };
    updateRecordingAudioPausesCount = (value) => {
        this.recordingAudioPausesCount.next(value);
    };
    updateRecordingAudioSupport = (value) => {
        this.recordingAudioSupport.next(value);
    };
    updateRecordingAudioPeopleLimit = (value) => {
        this.recordingAudioPeopleLimit.next(value);
    };
    updateRecordingAudioParticipantsTimeLimit = (value) => {
        this.recordingAudioParticipantsTimeLimit.next(value);
    };
    updateRecordingVideoPausesCount = (value) => {
        this.recordingVideoPausesCount.next(value);
    };
    updateRecordingVideoPausesLimit = (value) => {
        this.recordingVideoPausesLimit.next(value);
    };
    updateRecordingVideoSupport = (value) => {
        this.recordingVideoSupport.next(value);
    };
    updateRecordingVideoPeopleLimit = (value) => {
        this.recordingVideoPeopleLimit.next(value);
    };
    updateRecordingVideoParticipantsTimeLimit = (value) => {
        this.recordingVideoParticipantsTimeLimit.next(value);
    };
    updateRecordingAllParticipantsSupport = (value) => {
        this.recordingAllParticipantsSupport.next(value);
    };
    updateRecordingVideoParticipantsSupport = (value) => {
        this.recordingVideoParticipantsSupport.next(value);
    };
    updateRecordingAllParticipantsFullRoomSupport = (value) => {
        this.recordingAllParticipantsFullRoomSupport.next(value);
    };
    updateRecordingVideoParticipantsFullRoomSupport = (value) => {
        this.recordingVideoParticipantsFullRoomSupport.next(value);
    };
    updateRecordingPreferredOrientation = (value) => {
        this.recordingPreferredOrientation.next(value);
    };
    updateRecordingSupportForOtherOrientation = (value) => {
        this.recordingSupportForOtherOrientation.next(value);
    };
    updateRecordingMultiFormatsSupport = (value) => {
        this.recordingMultiFormatsSupport.next(value);
    };
    updateUserRecordingParams = (value) => {
        this.userRecordingParams.next(value);
    };
    updateCanRecord = (value) => {
        this.canRecord.next(value);
    };
    updateStartReport = (value) => {
        this.startReport.next(value);
    };
    updateEndReport = (value) => {
        this.endReport.next(value);
    };
    updateRecordTimerInterval = (value) => {
        this.recordTimerInterval.next(value);
    };
    updateRecordStartTime = (value) => {
        this.recordStartTime.next(value);
    };
    updateRecordElapsedTime = (value) => {
        this.recordElapsedTime.next(value);
    };
    updateIsTimerRunning = (value) => {
        this.isTimerRunning.next(value);
    };
    updateCanPauseResume = (value) => {
        this.canPauseResume.next(value);
    };
    updateRecordChangeSeconds = (value) => {
        this.recordChangeSeconds.next(value);
    };
    updatePauseLimit = (value) => {
        this.pauseLimit.next(value);
    };
    updatePauseRecordCount = (value) => {
        this.pauseRecordCount.next(value);
    };
    updateCanLaunchRecord = (value) => {
        this.canLaunchRecord.next(value);
    };
    updateStopLaunchRecord = (value) => {
        this.stopLaunchRecord.next(value);
    };
    updateParticipantsAll = (value) => {
        this.participantsAll.next(value);
    };
    updateFirstAll = (value) => {
        this.firstAll.next(value);
    };
    updateUpdateMainWindow = (value) => {
        this.updateMainWindow.next(value);
    };
    updateFirst_round = (value) => {
        this.first_round.next(value);
    };
    updateLandScaped = (value) => {
        this.landScaped.next(value);
    };
    updateLock_screen = (value) => {
        this.lock_screen.next(value);
    };
    updateScreenId = (value) => {
        this.screenId.next(value);
    };
    updateAllVideoStreams = (value) => {
        this.allVideoStreams.next(value);
    };
    updateNewLimitedStreams = (value) => {
        this.newLimitedStreams.next(value);
    };
    updateNewLimitedStreamsIDs = (value) => {
        this.newLimitedStreamsIDs.next(value);
    };
    updateActiveSounds = (value) => {
        this.activeSounds.next(value);
    };
    updateScreenShareIDStream = (value) => {
        this.screenShareIDStream.next(value);
    };
    updateScreenShareNameStream = (value) => {
        this.screenShareNameStream.next(value);
    };
    updateAdminIDStream = (value) => {
        this.adminIDStream.next(value);
    };
    updateAdminNameStream = (value) => {
        this.adminNameStream.next(value);
    };
    updateYouYouStream = (value) => {
        this.youYouStream.next(value);
    };
    updateYouYouStreamIDs = (value) => {
        this.youYouStreamIDs.next(value);
    };
    updateLocalStream = (value) => {
        this.localStream.next(value);
    };
    updateRecordStarted = (value) => {
        this.recordStarted.next(value);
    };
    updateRecordResumed = (value) => {
        this.recordResumed.next(value);
    };
    updateRecordPaused = (value) => {
        this.recordPaused.next(value);
    };
    updateRecordStopped = (value) => {
        this.recordStopped.next(value);
    };
    updateAdminRestrictSetting = (value) => {
        this.adminRestrictSetting.next(value);
    };
    updateVideoRequestState = (value) => {
        this.videoRequestState.next(value);
    };
    updateVideoRequestTime = (value) => {
        this.videoRequestTime.next(value);
    };
    updateVideoAction = (value) => {
        this.videoAction.next(value);
    };
    updateLocalStreamVideo = (value) => {
        this.localStreamVideo.next(value);
    };
    updateUserDefaultVideoInputDevice = (value) => {
        this.userDefaultVideoInputDevice.next(value);
    };
    updateCurrentFacingMode = (value) => {
        this.currentFacingMode.next(value);
    };
    updatePrevFacingMode = (value) => {
        this.prevFacingMode.next(value);
    };
    updateDefVideoID = (value) => {
        this.defVideoID.next(value);
    };
    updateAllowed = (value) => {
        this.allowed.next(value);
    };
    updateDispActiveNames = (value) => {
        this.dispActiveNames.next(value);
    };
    updateP_dispActiveNames = (value) => {
        this.p_dispActiveNames.next(value);
    };
    updateActiveNames = (value) => {
        this.activeNames.next(value);
    };
    updatePrevActiveNames = (value) => {
        this.prevActiveNames.next(value);
    };
    updateP_activeNames = (value) => {
        this.p_activeNames.next(value);
    };
    updateMembersReceived = (value) => {
        this.membersReceived.next(value);
    };
    updateDeferScreenReceived = (value) => {
        this.deferScreenReceived.next(value);
    };
    updateHostFirstSwitch = (value) => {
        this.hostFirstSwitch.next(value);
    };
    updateMicAction = (value) => {
        this.micAction.next(value);
    };
    updateScreenAction = (value) => {
        this.screenAction.next(value);
    };
    updateChatAction = (value) => {
        this.chatAction.next(value);
    };
    updateAudioRequestState = (value) => {
        this.audioRequestState.next(value);
    };
    updateScreenRequestState = (value) => {
        this.screenRequestState.next(value);
    };
    updateChatRequestState = (value) => {
        this.chatRequestState.next(value);
    };
    updateAudioRequestTime = (value) => {
        this.audioRequestTime.next(value);
    };
    updateScreenRequestTime = (value) => {
        this.screenRequestTime.next(value);
    };
    updateChatRequestTime = (value) => {
        this.chatRequestTime.next(value);
    };
    updateOldSoundIds = (value) => {
        this.oldSoundIds.next(value);
    };
    updateHostLabel = (value) => {
        this.hostLabel.next(value);
    };
    updateMainScreenFilled = (value) => {
        this.mainScreenFilled.next(value);
    };
    updateLocalStreamScreen = (value) => {
        this.localStreamScreen.next(value);
    };
    updateScreenAlreadyOn = (value) => {
        this.screenAlreadyOn.next(value);
    };
    updateChatAlreadyOn = (value) => {
        this.chatAlreadyOn.next(value);
    };
    updateRedirectURL = (value) => {
        this.redirectURL.next(value);
    };
    updateOldAllStreams = (value) => {
        this.oldAllStreams.next(value);
    };
    updateAdminVidID = (value) => {
        this.adminVidID.next(value);
    };
    updateStreamNames = (value) => {
        this.streamNames.next(value);
    };
    updateNon_alVideoStreams = (value) => {
        this.non_alVideoStreams.next(value);
    };
    updateSortAudioLoudness = (value) => {
        this.sortAudioLoudness.next(value);
    };
    updateAudioDecibels = (value) => {
        this.audioDecibels.next(value);
    };
    updateMixed_alVideoStreams = (value) => {
        this.mixed_alVideoStreams.next(value);
    };
    updateNon_alVideoStreams_muted = (value) => {
        this.non_alVideoStreams_muted.next(value);
    };
    updatePaginatedStreams = (value) => {
        this.paginatedStreams.next(value);
    };
    updateLocalStreamAudio = (value) => {
        this.localStreamAudio.next(value);
    };
    updateDefAudioID = (value) => {
        this.defAudioID.next(value);
    };
    updateUserDefaultAudioInputDevice = (value) => {
        this.userDefaultAudioInputDevice.next(value);
    };
    updateUserDefaultAudioOutputDevice = (value) => {
        this.userDefaultAudioOutputDevice.next(value);
    };
    updatePrevAudioInputDevice = (value) => {
        this.prevAudioInputDevice.next(value);
    };
    updatePrevVideoInputDevice = (value) => {
        this.prevVideoInputDevice.next(value);
    };
    updateAudioPaused = (value) => {
        this.audioPaused.next(value);
    };
    updateMainScreenPerson = (value) => {
        this.mainScreenPerson.next(value);
    };
    updateAdminOnMainScreen = (value) => {
        this.adminOnMainScreen.next(value);
    };
    updateScreenStates = (value) => {
        this.screenStates.next(value);
    };
    updatePrevScreenStates = (value) => {
        this.prevScreenStates.next(value);
    };
    updateUpdateDateState = (value) => {
        this.updateDateState.next(value);
    };
    updateLastUpdate = (value) => {
        this.lastUpdate.next(value);
    };
    updateNForReadjustRecord = (value) => {
        this.nForReadjustRecord.next(value);
    };
    updateFixedPageLimit = (value) => {
        this.fixedPageLimit.next(value);
    };
    updateRemoveAltGrid = (value) => {
        this.removeAltGrid.next(value);
    };
    updateNForReadjust = (value) => {
        this.nForReadjust.next(value);
    };
    updateLastReorderTime = (value) => {
        this.lastReorderTime.next(value);
    };
    updateAudStreamNames = (value) => {
        this.audStreamNames.next(value);
    };
    updateCurrentUserPage = (value) => {
        this.currentUserPage.next(value);
    };
    updateMainHeightWidth = (value) => {
        this.mainHeightWidth.next(value);
    };
    updatePrevMainHeightWidth = (value) => {
        this.prevMainHeightWidth.next(value);
    };
    updatePrevDoPaginate = (value) => {
        this.prevDoPaginate.next(value);
    };
    updateDoPaginate = (value) => {
        this.doPaginate.next(value);
    };
    updateShareEnded = (value) => {
        this.shareEnded.next(value);
    };
    updateLStreams = (value) => {
        this.lStreams.next(value);
    };
    updateChatRefStreams = (value) => {
        this.chatRefStreams.next(value);
    };
    updateControlHeight = (value) => {
        this.controlHeight.next(value);
    };
    updateIsWideScreen = (value) => {
        this.isWideScreen.next(value);
    };
    updateIsMediumScreen = (value) => {
        this.isMediumScreen.next(value);
    };
    updateIsSmallScreen = (value) => {
        this.isSmallScreen.next(value);
    };
    updateAddGrid = (value) => {
        this.addGrid.next(value);
    };
    updateAddAltGrid = (value) => {
        this.addAltGrid.next(value);
    };
    updateGridRows = (value) => {
        this.gridRows.next(value);
    };
    updateGridCols = (value) => {
        this.gridCols.next(value);
    };
    updateAltGridRows = (value) => {
        this.altGridRows.next(value);
    };
    updateAltGridCols = (value) => {
        this.altGridCols.next(value);
    };
    updateNumberPages = (value) => {
        this.numberPages.next(value);
    };
    updateCurrentStreams = (value) => {
        this.currentStreams.next(value);
    };
    updateShowMiniView = (value) => {
        this.showMiniView.next(value);
    };
    updateNStream = (value) => {
        this.nStream.next(value);
    };
    updateDefer_receive = (value) => {
        this.defer_receive.next(value);
    };
    updateAllAudioStreams = (value) => {
        this.allAudioStreams.next(value);
    };
    updateRemoteScreenStream = (value) => {
        this.remoteScreenStream.next(value);
    };
    updateScreenProducer = (value) => {
        this.screenProducer.next(value);
    };
    updateLocalScreenProducer = (value) => {
        this.localScreenProducer.next(value);
    };
    updateGotAllVids = (value) => {
        this.gotAllVids.next(value);
    };
    updatePaginationHeightWidth = (value) => {
        this.paginationHeightWidth.next(value);
    };
    updatePaginationDirection = (value) => {
        this.paginationDirection.next(value);
    };
    updateGridSizes = (value) => {
        this.gridSizes.next(value);
    };
    updateScreenForceFullDisplay = (value) => {
        this.screenForceFullDisplay.next(value);
    };
    updateMainGridStream = (value) => {
        this.mainGridStream.next(value);
    };
    updateOtherGridStreams = (value) => {
        this.otherGridStreams.next(value);
    };
    updateAudioOnlyStreams = (value) => {
        this.audioOnlyStreams.next(value);
    };
    updateVideoInputs = (value) => {
        this.videoInputs.next(value);
    };
    updateAudioInputs = (value) => {
        this.audioInputs.next(value);
    };
    updateMeetingProgressTime = (value) => {
        this.meetingProgressTime.next(value);
    };
    updateMeetingElapsedTime = (value) => {
        this.meetingElapsedTime.next(value);
    };
    updateRef_participants = (value) => {
        this.ref_participants.next(value);
    };
    // Messages
    messages = new BehaviorSubject$1([]);
    startDirectMessage = new BehaviorSubject$1(false);
    directMessageDetails = new BehaviorSubject$1(null);
    showMessagesBadge = new BehaviorSubject$1(false);
    // Event Settings
    audioSetting = new BehaviorSubject$1('allow');
    videoSetting = new BehaviorSubject$1('allow');
    screenshareSetting = new BehaviorSubject$1('allow');
    chatSetting = new BehaviorSubject$1('allow');
    // Display Settings
    displayOption = new BehaviorSubject$1('media');
    autoWave = new BehaviorSubject$1(true);
    forceFullDisplay = new BehaviorSubject$1(true);
    prevForceFullDisplay = new BehaviorSubject$1(false);
    prevMeetingDisplayType = new BehaviorSubject$1('video');
    // Waiting Room
    waitingRoomFilter = new BehaviorSubject$1('');
    waitingRoomList = new BehaviorSubject$1(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    waitingRoomCounter = new BehaviorSubject$1(0);
    filteredWaitingRoomList = new BehaviorSubject$1(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    // Requests
    requestFilter = new BehaviorSubject$1('');
    requestList = new BehaviorSubject$1(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    requestCounter = new BehaviorSubject$1(0);
    filteredRequestList = new BehaviorSubject$1(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    // Total Requests and Waiting Room
    totalReqWait = new BehaviorSubject$1(0);
    // Alerts
    alertVisible = new BehaviorSubject$1(false);
    alertMessage = new BehaviorSubject$1('');
    alertType = new BehaviorSubject$1('success');
    alertDuration = new BehaviorSubject$1(3000);
    // Progress Timer
    progressTimerVisible = new BehaviorSubject$1(true);
    progressTimerValue = new BehaviorSubject$1(0);
    // Menu Modals
    isMenuModalVisible = new BehaviorSubject$1(false);
    isRecordingModalVisible = new BehaviorSubject$1(false);
    isSettingsModalVisible = new BehaviorSubject$1(false);
    isRequestsModalVisible = new BehaviorSubject$1(false);
    isWaitingModalVisible = new BehaviorSubject$1(false);
    isCoHostModalVisible = new BehaviorSubject$1(false);
    isMediaSettingsModalVisible = new BehaviorSubject$1(false);
    isDisplaySettingsModalVisible = new BehaviorSubject$1(false);
    // Other Modals
    isParticipantsModalVisible = new BehaviorSubject$1(false);
    isMessagesModalVisible = new BehaviorSubject$1(false);
    isConfirmExitModalVisible = new BehaviorSubject$1(false);
    isConfirmHereModalVisible = new BehaviorSubject$1(false);
    isShareEventModalVisible = new BehaviorSubject$1(false);
    isLoadingModalVisible = new BehaviorSubject$1(false);
    // Recording Options
    recordingMediaOptions = new BehaviorSubject$1('video');
    recordingAudioOptions = new BehaviorSubject$1('all');
    recordingVideoOptions = new BehaviorSubject$1('all');
    recordingVideoType = new BehaviorSubject$1('fullDisplay');
    recordingVideoOptimized = new BehaviorSubject$1(false);
    recordingDisplayType = new BehaviorSubject$1('video');
    recordingAddHLS = new BehaviorSubject$1(true);
    recordingNameTags = new BehaviorSubject$1(true);
    recordingBackgroundColor = new BehaviorSubject$1('#83c0e9');
    recordingNameTagsColor = new BehaviorSubject$1('#ffffff');
    recordingAddText = new BehaviorSubject$1(false);
    recordingCustomText = new BehaviorSubject$1('Add Text');
    recordingCustomTextPosition = new BehaviorSubject$1('top');
    recordingCustomTextColor = new BehaviorSubject$1('#ffffff');
    recordingOrientationVideo = new BehaviorSubject$1('landscape');
    clearedToResume = new BehaviorSubject$1(true);
    clearedToRecord = new BehaviorSubject$1(true);
    recordState = new BehaviorSubject$1('green');
    showRecordButtons = new BehaviorSubject$1(false);
    recordingProgressTime = new BehaviorSubject$1('00:00:00');
    audioSwitching = new BehaviorSubject$1(false);
    videoSwitching = new BehaviorSubject$1(false);
    // Media States
    videoAlreadyOn = new BehaviorSubject$1(false);
    audioAlreadyOn = new BehaviorSubject$1(false);
    componentSizes = new BehaviorSubject$1({
        mainHeight: 0,
        otherHeight: 0,
        mainWidth: 0,
        otherWidth: 0,
    });
    // Permissions
    hasCameraPermission = new BehaviorSubject$1(false);
    hasAudioPermission = new BehaviorSubject$1(false);
    // Transports
    transportCreated = new BehaviorSubject$1(false);
    localTransportCreated = new BehaviorSubject$1(false);
    transportCreatedVideo = new BehaviorSubject$1(false);
    transportCreatedAudio = new BehaviorSubject$1(false);
    transportCreatedScreen = new BehaviorSubject$1(false);
    producerTransport = new BehaviorSubject$1(null);
    localProducerTransport = new BehaviorSubject$1(null);
    videoProducer = new BehaviorSubject$1(null);
    localVideoProducer = new BehaviorSubject$1(null);
    params = new BehaviorSubject$1({});
    videoParams = new BehaviorSubject$1({});
    audioParams = new BehaviorSubject$1({});
    audioProducer = new BehaviorSubject$1(null);
    audioLevel = new BehaviorSubject$1(0);
    localAudioProducer = new BehaviorSubject$1(null);
    consumerTransports = new BehaviorSubject$1([]);
    consumingTransports = new BehaviorSubject$1([]);
    // Polls
    polls = new BehaviorSubject$1(this.useSeed && this.seedData?.polls ? this.seedData.polls : []);
    poll = new BehaviorSubject$1(null);
    isPollModalVisible = new BehaviorSubject$1(false);
    // Background
    customImage = new BehaviorSubject$1('');
    selectedImage = new BehaviorSubject$1('');
    segmentVideo = new BehaviorSubject$1(null);
    selfieSegmentation = new BehaviorSubject$1(null);
    pauseSegmentation = new BehaviorSubject$1(false);
    processedStream = new BehaviorSubject$1(null);
    keepBackground = new BehaviorSubject$1(false);
    backgroundHasChanged = new BehaviorSubject$1(false);
    virtualStream = new BehaviorSubject$1(null);
    mainCanvas = new BehaviorSubject$1(null);
    prevKeepBackground = new BehaviorSubject$1(false);
    appliedBackground = new BehaviorSubject$1(false);
    isBackgroundModalVisible = new BehaviorSubject$1(false);
    autoClickBackground = new BehaviorSubject$1(false);
    // Breakout Rooms
    breakoutRooms = new BehaviorSubject$1(this.useSeed && this.seedData?.breakoutRooms ? this.seedData.breakoutRooms : []);
    currentRoomIndex = new BehaviorSubject$1(0);
    canStartBreakout = new BehaviorSubject$1(false);
    breakOutRoomStarted = new BehaviorSubject$1(false);
    breakOutRoomEnded = new BehaviorSubject$1(false);
    hostNewRoom = new BehaviorSubject$1(-1);
    limitedBreakRoom = new BehaviorSubject$1([]);
    mainRoomsLength = new BehaviorSubject$1(0);
    memberRoom = new BehaviorSubject$1(-1);
    isBreakoutRoomsModalVisible = new BehaviorSubject$1(false);
    // Whiteboard
    whiteboardUsers = new BehaviorSubject$1(this.useSeed && this.seedData?.whiteboardUsers ? this.seedData.whiteboardUsers : []);
    currentWhiteboardIndex = new BehaviorSubject$1(0);
    canStartWhiteboard = new BehaviorSubject$1(false);
    whiteboardStarted = new BehaviorSubject$1(false);
    whiteboardEnded = new BehaviorSubject$1(false);
    whiteboardLimit = new BehaviorSubject$1(4);
    isWhiteboardModalVisible = new BehaviorSubject$1(false);
    isConfigureWhiteboardModalVisible = new BehaviorSubject$1(false);
    shapes = new BehaviorSubject$1([]);
    useImageBackground = new BehaviorSubject$1(true);
    redoStack = new BehaviorSubject$1([]);
    undoStack = new BehaviorSubject$1([]);
    canvasStream = new BehaviorSubject$1(null);
    canvasWhiteboard = new BehaviorSubject$1(null);
    // Screenboard
    canvasScreenboard = new BehaviorSubject$1(null);
    processedScreenStream = new BehaviorSubject$1(null);
    annotateScreenStream = new BehaviorSubject$1(false);
    mainScreenCanvas = new BehaviorSubject$1(null);
    isScreenboardModalVisible = new BehaviorSubject$1(false);
    //state variables for the control buttons
    micActive = new BehaviorSubject$1(this.audioAlreadyOn.value ? this.audioAlreadyOn.value : false);
    videoActive = new BehaviorSubject$1(this.videoAlreadyOn.value ? this.videoAlreadyOn.value : false);
    screenShareActive = new BehaviorSubject$1(false);
    endCallActive = new BehaviorSubject$1(false);
    participantsActive = new BehaviorSubject$1(false);
    menuActive = new BehaviorSubject$1(false);
    commentsActive = new BehaviorSubject$1(false);
    // Update functions
    updateMessages = (value) => {
        this.messages.next(value);
    };
    updateStartDirectMessage = (value) => {
        this.startDirectMessage.next(value);
    };
    updateDirectMessageDetails = (value) => {
        this.directMessageDetails.next(value);
    };
    updateShowMessagesBadge = (value) => {
        this.showMessagesBadge.next(value);
    };
    updateAudioSetting = (value) => {
        this.audioSetting.next(value);
    };
    updateVideoSetting = (value) => {
        this.videoSetting.next(value);
    };
    updateScreenshareSetting = (value) => {
        this.screenshareSetting.next(value);
    };
    updateChatSetting = (value) => {
        this.chatSetting.next(value);
    };
    updateDisplayOption = (value) => {
        this.displayOption.next(value);
    };
    updateAutoWave = (value) => {
        this.autoWave.next(value);
    };
    updateForceFullDisplay = (value) => {
        this.forceFullDisplay.next(value);
    };
    updatePrevForceFullDisplay = (value) => {
        this.prevForceFullDisplay.next(value);
    };
    updatePrevMeetingDisplayType = (value) => {
        this.prevMeetingDisplayType.next(value);
    };
    updateWaitingRoomCounter = (value) => {
        this.waitingRoomCounter.next(value);
    };
    updateWaitingRoomFilter = (value) => {
        this.waitingRoomFilter.next(value);
    };
    updateWaitingRoomList = (value) => {
        this.waitingRoomList.next(value);
        this.filteredWaitingRoomList.next(value);
        this.waitingRoomCounter.next(value.length);
    };
    onWaitingRoomFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredWaitingRoom = this.waitingRoomList
                .getValue()
                .filter((waitingRoom) => {
                return waitingRoom.name.toLowerCase().includes(value.toLowerCase());
            });
            this.filteredWaitingRoomList.next(filteredWaitingRoom);
            this.waitingRoomCounter.next(filteredWaitingRoom.length);
        }
        else {
            this.filteredWaitingRoomList.next(this.waitingRoomList.getValue());
            this.waitingRoomCounter.next(this.waitingRoomList.getValue().length);
        }
    };
    onWaitingRoomClose = () => {
        this.updateIsWaitingModalVisible(false);
    };
    updateRequestCounter = (value) => {
        this.requestCounter.next(value);
    };
    updateRequestFilter = (value) => {
        this.requestFilter.next(value);
    };
    updateRequestList = (value) => {
        this.requestList.next(value);
        this.filteredRequestList.next(value);
        this.requestCounter.next(value.length);
    };
    onRequestFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredRequest = this.requestList.getValue().filter((request) => {
                return request?.name?.toLowerCase().includes(value.toLowerCase());
            });
            this.filteredRequestList.next(filteredRequest);
            this.requestCounter.next(filteredRequest.length);
        }
        else {
            this.filteredRequestList.next(this.requestList.getValue());
            this.requestCounter.next(this.requestList.getValue().length);
        }
    };
    onRequestClose = () => {
        this.updateIsRequestsModalVisible(false);
    };
    updateTotalReqWait = (value) => {
        this.totalReqWait.next(value);
    };
    updateAlertVisible = (value) => {
        this.alertVisible.next(value);
    };
    updateAlertMessage = (value) => {
        this.alertMessage.next(value);
    };
    updateAlertType = (value) => {
        this.alertType.next(value);
    };
    updateAlertDuration = (value) => {
        this.alertDuration.next(value);
    };
    updateProgressTimerVisible = (value) => {
        this.progressTimerVisible.next(value);
    };
    updateProgressTimerValue = (value) => {
        this.progressTimerValue.next(value);
    };
    updateIsMenuModalVisible = (value) => {
        this.isMenuModalVisible.next(value);
    };
    updateIsRecordingModalVisible = (value) => {
        this.isRecordingModalVisible.next(value);
        if (value) {
            this.updateConfirmedToRecord(false);
        }
        else {
            if (this.clearedToRecord.getValue() &&
                this.clearedToResume.getValue() &&
                this.recordStarted.getValue()) {
                this.updateShowRecordButtons(true);
            }
        }
    };
    updateIsSettingsModalVisible = (value) => {
        this.isSettingsModalVisible.next(value);
    };
    updateIsRequestsModalVisible = (value) => {
        this.isRequestsModalVisible.next(value);
    };
    updateIsWaitingModalVisible = (value) => {
        this.isWaitingModalVisible.next(value);
    };
    updateIsCoHostModalVisible = (value) => {
        this.isCoHostModalVisible.next(value);
    };
    updateIsMediaSettingsModalVisible = (value) => {
        this.isMediaSettingsModalVisible.next(value);
    };
    updateIsDisplaySettingsModalVisible = (value) => {
        this.isDisplaySettingsModalVisible.next(value);
    };
    updateIsParticipantsModalVisible = (value) => {
        this.isParticipantsModalVisible.next(value);
    };
    updateIsMessagesModalVisible = (value) => {
        this.isMessagesModalVisible.next(value);
        if (!value) {
            this.updateShowMessagesBadge(false);
        }
    };
    updateIsConfirmExitModalVisible = (value) => {
        this.isConfirmExitModalVisible.next(value);
    };
    updateIsConfirmHereModalVisible = (value) => {
        this.isConfirmHereModalVisible.next(value);
    };
    updateIsLoadingModalVisible = (value) => {
        this.isLoadingModalVisible.next(value);
    };
    updateIsShareEventModalVisible = (value) => {
        this.isShareEventModalVisible.next(value);
    };
    updateRecordingMediaOptions = (value) => {
        this.recordingMediaOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAudioOptions = (value) => {
        this.recordingAudioOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptions = (value) => {
        this.recordingVideoOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoType = (value) => {
        this.recordingVideoType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptimized = (value) => {
        this.recordingVideoOptimized.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingDisplayType = (value) => {
        this.recordingDisplayType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddHLS = (value) => {
        this.recordingAddHLS.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddText = (value) => {
        this.recordingAddText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomText = (value) => {
        this.recordingCustomText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextPosition = (value) => {
        this.recordingCustomTextPosition.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextColor = (value) => {
        this.recordingCustomTextColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTags = (value) => {
        this.recordingNameTags.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingBackgroundColor = (value) => {
        this.recordingBackgroundColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTagsColor = (value) => {
        this.recordingNameTagsColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingOrientationVideo = (value) => {
        this.recordingOrientationVideo.next(value);
        this.clearedToRecord.next(false);
    };
    updateClearedToResume = (value) => {
        this.clearedToResume.next(value);
    };
    updateClearedToRecord = (value) => {
        this.clearedToRecord.next(value);
    };
    updateRecordState = (value) => {
        if (this.recordStarted.value && !this.recordStopped.value) {
            if (!this.recordPaused.value) {
                this.recordState.next('red');
            }
            else {
                this.recordState.next('yellow');
            }
        }
        else {
            this.recordState.next(value);
        }
        this.recordState.next(value);
    };
    updateShowRecordButtons = (value) => {
        this.showRecordButtons.next(value);
    };
    updateRecordingProgressTime = (value) => {
        this.recordingProgressTime.next(value);
        this.updateRecordTimerWidget();
    };
    updateAudioSwitching = (value) => {
        this.audioSwitching.next(value);
    };
    updateVideoSwitching = (value) => {
        this.videoSwitching.next(value);
    };
    updateVideoAlreadyOn = (value) => {
        this.videoAlreadyOn.next(value);
        this.videoActive.next(value);
    };
    updateAudioAlreadyOn = (value) => {
        this.audioAlreadyOn.next(value);
        this.micActive.next(value);
    };
    updateComponentSizes = (sizes) => {
        this.componentSizes.next(sizes);
    };
    updateHasCameraPermission = (value) => {
        this.hasCameraPermission.next(value);
    };
    updateHasAudioPermission = (value) => {
        this.hasAudioPermission.next(value);
    };
    requestPermissionCamera() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    requestPermissionAudio() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    updateTransportCreated = (value) => {
        this.transportCreated.next(value);
    };
    updateLocalTransportCreated = (value) => {
        this.localTransportCreated.next(value);
    };
    updateTransportCreatedVideo = (value) => {
        this.transportCreatedVideo.next(value);
    };
    updateTransportCreatedAudio = (value) => {
        this.transportCreatedAudio.next(value);
    };
    updateTransportCreatedScreen = (value) => {
        this.transportCreatedScreen.next(value);
    };
    updateProducerTransport = (value) => {
        this.producerTransport.next(value);
    };
    updateLocalProducerTransport = (value) => {
        this.localProducerTransport.next(value);
    };
    updateVideoProducer = (value) => {
        this.videoProducer.next(value);
    };
    updateLocalVideoProducer = (value) => {
        this.localVideoProducer.next(value);
    };
    updateParams = (value) => {
        this.params.next(value);
    };
    updateVideoParams = (value) => {
        this.videoParams.next(value);
    };
    updateAudioParams = (value) => {
        this.audioParams.next(value);
    };
    updateAudioProducer = (value) => {
        this.audioProducer.next(value);
    };
    updateAudioLevel = (value) => {
        this.audioLevel.next(value);
    };
    updateLocalAudioProducer = (value) => {
        this.localAudioProducer.next(value);
    };
    updateConsumerTransports = (value) => {
        this.consumerTransports.next(value);
    };
    updateConsumingTransports = (value) => {
        this.consumingTransports.next(value);
    };
    updatePolls = (value) => {
        this.polls.next(value);
    };
    updatePoll = (value) => {
        this.poll.next(value);
    };
    updateIsPollModalVisible = (value) => {
        this.isPollModalVisible.next(value);
    };
    updateCustomImage = (value) => {
        this.customImage.next(value);
    };
    updateSelectedImage = (value) => {
        this.selectedImage.next(value);
    };
    updateSegmentVideo = (value) => {
        this.segmentVideo.next(value);
    };
    updateSelfieSegmentation = (value) => {
        this.selfieSegmentation.next(value);
    };
    updatePauseSegmentation = (value) => {
        this.pauseSegmentation.next(value);
    };
    updateProcessedStream = (value) => {
        this.processedStream.next(value);
    };
    updateKeepBackground = (value) => {
        this.keepBackground.next(value);
    };
    updateBackgroundHasChanged = (value) => {
        this.backgroundHasChanged.next(value);
    };
    updateVirtualStream = (value) => {
        this.virtualStream.next(value);
    };
    updateMainCanvas = (value) => {
        this.mainCanvas.next(value);
    };
    updatePrevKeepBackground = (value) => {
        this.prevKeepBackground.next(value);
    };
    updateAppliedBackground = (value) => {
        this.appliedBackground.next(value);
    };
    updateIsBackgroundModalVisible = (value) => {
        this.isBackgroundModalVisible.next(value);
    };
    updateAutoClickBackground = (value) => {
        this.autoClickBackground.next(value);
    };
    updateBreakoutRooms = (value) => {
        this.breakoutRooms.next(value);
    };
    updateCurrentRoomIndex = (value) => {
        this.currentRoomIndex.next(value);
    };
    updateCanStartBreakout = (value) => {
        this.canStartBreakout.next(value);
    };
    updateBreakOutRoomStarted = (value) => {
        this.breakOutRoomStarted.next(value);
    };
    updateBreakOutRoomEnded = (value) => {
        this.breakOutRoomEnded.next(value);
    };
    updateHostNewRoom = (value) => {
        this.hostNewRoom.next(value);
    };
    updateLimitedBreakRoom = (value) => {
        this.limitedBreakRoom.next(value);
    };
    updateMainRoomsLength = (value) => {
        this.mainRoomsLength.next(value);
    };
    updateMemberRoom = (value) => {
        this.memberRoom.next(value);
    };
    updateIsBreakoutRoomsModalVisible = (value) => {
        this.isBreakoutRoomsModalVisible.next(value);
    };
    updateWhiteboardUsers = (value) => {
        this.whiteboardUsers.next(value);
    };
    updateCurrentWhiteboardIndex = (value) => {
        this.currentWhiteboardIndex.next(value);
    };
    updateCanStartWhiteboard = (value) => {
        this.canStartWhiteboard.next(value);
    };
    updateWhiteboardStarted = (value) => {
        this.whiteboardStarted.next(value);
    };
    updateWhiteboardEnded = (value) => {
        this.whiteboardEnded.next(value);
    };
    updateWhiteboardLimit = (value) => {
        this.whiteboardLimit.next(value);
    };
    updateIsWhiteboardModalVisible = (value) => {
        this.isWhiteboardModalVisible.next(value);
    };
    updateIsConfigureWhiteboardModalVisible = (value) => {
        this.isConfigureWhiteboardModalVisible.next(value);
    };
    updateShapes = (value) => {
        this.shapes.next(value);
    };
    updateUseImageBackground = (value) => {
        this.useImageBackground.next(value);
    };
    updateRedoStack = (value) => {
        this.redoStack.next(value);
    };
    updateUndoStack = (value) => {
        this.undoStack.next(value);
    };
    updateCanvasStream = (value) => {
        this.canvasStream.next(value);
    };
    updateCanvasWhiteboard = (value) => {
        this.canvasWhiteboard.next(value);
    };
    updateCanvasScreenboard = (value) => {
        this.canvasScreenboard.next(value);
    };
    updateProcessedScreenStream = (value) => {
        this.processedScreenStream.next(value);
    };
    updateAnnotateScreenStream = (value) => {
        this.annotateScreenStream.next(value);
    };
    updateMainScreenCanvas = (value) => {
        this.mainScreenCanvas.next(value);
    };
    updateIsScreenboardModalVisible = (value) => {
        this.isScreenboardModalVisible.next(value);
    };
    checkOrientation = () => {
        const isPortrait = window.matchMedia('(orientation: portrait)').matches;
        return isPortrait ? 'portrait' : 'landscape';
    };
    showAlert = ({ message, type, duration = 3000, }) => {
        this.updateAlertMessage(message);
        this.updateAlertType(type);
        this.updateAlertDuration(duration);
        this.updateAlertVisible(true);
    };
    getAllParams() {
        return {
            localUIMode: this.localUIMode.value, // Local UI mode
            // Room Details
            roomName: this.roomName.value,
            member: this.member.value,
            adminPasscode: this.adminPasscode.value,
            youAreCoHost: this.youAreCoHost.value,
            youAreHost: this.youAreHost.value,
            islevel: this.islevel.value,
            confirmedToRecord: this.confirmedToRecord.value,
            meetingDisplayType: this.meetingDisplayType.value,
            meetingVideoOptimized: this.meetingVideoOptimized.value,
            eventType: this.eventType.value,
            participants: this.participants.value,
            filteredParticipants: this.filteredParticipants.value,
            participantsCounter: this.participantsCounter.value,
            participantsFilter: this.participantsFilter.value,
            // More room details - media
            consume_sockets: this.consume_sockets.value,
            rtpCapabilities: this.rtpCapabilities.value,
            roomRecvIPs: this.roomRecvIPs.value,
            meetingRoomParams: this.meetingRoomParams.value,
            itemPageLimit: this.itemPageLimit.value,
            audioOnlyRoom: this.audioOnlyRoom.value,
            addForBasic: this.addForBasic.value,
            screenPageLimit: this.screenPageLimit.value,
            shareScreenStarted: this.shareScreenStarted.value,
            shared: this.shared.value,
            targetOrientation: this.targetOrientation.value,
            targetResolution: this.targetResolution.value,
            targetResolutionHost: this.targetResolutionHost.value,
            vidCons: this.vidCons.value,
            frameRate: this.frameRate.value,
            hParams: this.hParams.value,
            vParams: this.vParams.value,
            screenParams: this.screenParams.value,
            aParams: this.aParams.value,
            // More room details - recording
            recordingAudioPausesLimit: this.recordingAudioPausesLimit.value,
            recordingAudioPausesCount: this.recordingAudioPausesCount.value,
            recordingAudioSupport: this.recordingAudioSupport.value,
            recordingAudioPeopleLimit: this.recordingAudioPeopleLimit.value,
            recordingAudioParticipantsTimeLimit: this.recordingAudioParticipantsTimeLimit.value,
            recordingVideoPausesCount: this.recordingVideoPausesCount.value,
            recordingVideoPausesLimit: this.recordingVideoPausesLimit.value,
            recordingVideoSupport: this.recordingVideoSupport.value,
            recordingVideoPeopleLimit: this.recordingVideoPeopleLimit.value,
            recordingVideoParticipantsTimeLimit: this.recordingVideoParticipantsTimeLimit.value,
            recordingAllParticipantsSupport: this.recordingAllParticipantsSupport.value,
            recordingVideoParticipantsSupport: this.recordingVideoParticipantsSupport.value,
            recordingAllParticipantsFullRoomSupport: this.recordingAllParticipantsFullRoomSupport.value,
            recordingVideoParticipantsFullRoomSupport: this.recordingVideoParticipantsFullRoomSupport.value,
            recordingPreferredOrientation: this.recordingPreferredOrientation.value,
            recordingSupportForOtherOrientation: this.recordingSupportForOtherOrientation.value,
            recordingMultiFormatsSupport: this.recordingMultiFormatsSupport.value,
            userRecordingParams: this.userRecordingParams.value,
            canRecord: this.canRecord.value,
            startReport: this.startReport.value,
            endReport: this.endReport.value,
            recordStartTime: this.recordStartTime.value,
            recordElapsedTime: this.recordElapsedTime.value,
            isTimerRunning: this.isTimerRunning.value,
            canPauseResume: this.canPauseResume.value,
            recordChangeSeconds: this.recordChangeSeconds.value,
            pauseLimit: this.pauseLimit.value,
            pauseRecordCount: this.pauseRecordCount.value,
            canLaunchRecord: this.canLaunchRecord.value,
            stopLaunchRecord: this.stopLaunchRecord.value,
            participantsAll: this.participantsAll.value,
            firstAll: this.firstAll.value,
            updateMainWindow: this.updateMainWindow.value,
            first_round: this.first_round.value,
            landScaped: this.landScaped.value,
            lock_screen: this.lock_screen.value,
            screenId: this.screenId.value,
            allVideoStreams: this.allVideoStreams.value,
            newLimitedStreams: this.newLimitedStreams.value,
            newLimitedStreamsIDs: this.newLimitedStreamsIDs.value,
            activeSounds: this.activeSounds.value,
            screenShareIDStream: this.screenShareIDStream.value,
            screenShareNameStream: this.screenShareNameStream.value,
            adminIDStream: this.adminIDStream.value,
            adminNameStream: this.adminNameStream.value,
            youYouStream: this.youYouStream.value,
            youYouStreamIDs: this.youYouStreamIDs.value,
            localStream: this.localStream.value,
            recordStarted: this.recordStarted.value,
            recordResumed: this.recordResumed.value,
            recordPaused: this.recordPaused.value,
            recordStopped: this.recordStopped.value,
            adminRestrictSetting: this.adminRestrictSetting.value,
            videoRequestState: this.videoRequestState.value,
            videoRequestTime: this.videoRequestTime.value,
            videoAction: this.videoAction.value,
            localStreamVideo: this.localStreamVideo.value,
            userDefaultVideoInputDevice: this.userDefaultVideoInputDevice.value,
            currentFacingMode: this.currentFacingMode.value,
            prevFacingMode: this.prevFacingMode.value,
            defVideoID: this.defVideoID.value,
            allowed: this.allowed.value,
            dispActiveNames: this.dispActiveNames.value,
            p_dispActiveNames: this.p_dispActiveNames.value,
            activeNames: this.activeNames.value,
            prevActiveNames: this.prevActiveNames.value,
            p_activeNames: this.p_activeNames.value,
            membersReceived: this.membersReceived.value,
            deferScreenReceived: this.deferScreenReceived.value,
            hostFirstSwitch: this.hostFirstSwitch.value,
            micAction: this.micAction.value,
            screenAction: this.screenAction.value,
            chatAction: this.chatAction.value,
            audioRequestState: this.audioRequestState.value,
            screenRequestState: this.screenRequestState.value,
            chatRequestState: this.chatRequestState.value,
            audioRequestTime: this.audioRequestTime.value,
            screenRequestTime: this.screenRequestTime.value,
            chatRequestTime: this.chatRequestTime.value,
            updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
            oldSoundIds: this.oldSoundIds.value,
            hostLabel: this.hostLabel.value,
            mainScreenFilled: this.mainScreenFilled.value,
            localStreamScreen: this.localStreamScreen.value,
            screenAlreadyOn: this.screenAlreadyOn.value,
            chatAlreadyOn: this.chatAlreadyOn.value,
            redirectURL: this.redirectURL.value,
            oldAllStreams: this.oldAllStreams.value,
            adminVidID: this.adminVidID.value,
            streamNames: this.streamNames.value,
            non_alVideoStreams: this.non_alVideoStreams.value,
            sortAudioLoudness: this.sortAudioLoudness.value,
            audioDecibels: this.audioDecibels.value,
            mixed_alVideoStreams: this.mixed_alVideoStreams.value,
            non_alVideoStreams_muted: this.non_alVideoStreams_muted.value,
            paginatedStreams: this.paginatedStreams.value,
            localStreamAudio: this.localStreamAudio.value,
            defAudioID: this.defAudioID.value,
            userDefaultAudioInputDevice: this.userDefaultAudioInputDevice.value,
            userDefaultAudioOutputDevice: this.userDefaultAudioOutputDevice.value,
            prevAudioInputDevice: this.prevAudioInputDevice.value,
            prevVideoInputDevice: this.prevVideoInputDevice.value,
            audioPaused: this.audioPaused.value,
            mainScreenPerson: this.mainScreenPerson.value,
            adminOnMainScreen: this.adminOnMainScreen.value,
            screenStates: this.screenStates.value,
            prevScreenStates: this.prevScreenStates.value,
            updateDateState: this.updateDateState.value,
            lastUpdate: this.lastUpdate.value,
            nForReadjustRecord: this.nForReadjustRecord.value,
            fixedPageLimit: this.fixedPageLimit.value,
            removeAltGrid: this.removeAltGrid.value,
            nForReadjust: this.nForReadjust.value,
            lastReorderTime: this.lastReorderTime.value,
            reorderInterval: this.reorderInterval.value,
            fastReorderInterval: this.fastReorderInterval.value,
            audStreamNames: this.audStreamNames.value,
            currentUserPage: this.currentUserPage.value,
            mainHeightWidth: this.mainHeightWidth.value,
            prevMainHeightWidth: this.prevMainHeightWidth.value,
            prevDoPaginate: this.prevDoPaginate.value,
            doPaginate: this.doPaginate.value,
            shareEnded: this.shareEnded.value,
            lStreams: this.lStreams.value,
            chatRefStreams: this.chatRefStreams.value,
            controlHeight: this.controlHeight.value,
            isWideScreen: this.isWideScreen.value,
            isMediumScreen: this.isMediumScreen.value,
            isSmallScreen: this.isSmallScreen.value,
            addGrid: this.addGrid.value,
            addAltGrid: this.addAltGrid.value,
            gridRows: this.gridRows.value,
            gridCols: this.gridCols.value,
            altGridRows: this.altGridRows.value,
            altGridCols: this.altGridCols.value,
            numberPages: this.numberPages.value,
            currentStreams: this.currentStreams.value,
            showMiniView: this.showMiniView.value,
            nStream: this.nStream.value,
            defer_receive: this.defer_receive.value,
            allAudioStreams: this.allAudioStreams.value,
            screenProducer: this.screenProducer.value,
            remoteScreenStream: this.remoteScreenStream.value,
            gotAllVids: this.gotAllVids.value,
            paginationHeightWidth: this.paginationHeightWidth.value,
            paginationDirection: this.paginationDirection.value,
            gridSizes: this.gridSizes.value,
            screenForceFullDisplay: this.screenForceFullDisplay.value,
            mainGridStream: this.mainGridStream.value,
            otherGridStreams: this.otherGridStreams.value,
            audioOnlyStreams: this.audioOnlyStreams.value,
            videoInputs: this.videoInputs.value,
            audioInputs: this.audioInputs.value,
            meetingProgressTime: this.meetingProgressTime.value,
            meetingElapsedTime: this.meetingElapsedTime.value,
            ref_participants: this.ref_participants.value,
            messages: this.messages.value,
            startDirectMessage: this.startDirectMessage.value,
            directMessageDetails: this.directMessageDetails.value,
            coHost: this.coHost.value,
            coHostResponsibility: this.coHostResponsibility.value,
            // Event settings
            audioSetting: this.audioSetting.value,
            videoSetting: this.videoSetting.value,
            screenshareSetting: this.screenshareSetting.value,
            chatSetting: this.chatSetting.value,
            // Display settings
            autoWave: this.autoWave.value,
            forceFullDisplay: this.forceFullDisplay.value,
            prevForceFullDisplay: this.prevForceFullDisplay.value,
            prevMeetingDisplayType: this.prevMeetingDisplayType.value,
            // Waiting room
            waitingRoomFilter: this.waitingRoomFilter.value,
            waitingRoomList: this.waitingRoomList.value,
            waitingRoomCounter: this.waitingRoomCounter.value,
            filteredWaitingRoomList: this.filteredWaitingRoomList.value,
            // Requests
            requestFilter: this.requestFilter.value,
            requestList: this.requestList.value,
            requestCounter: this.requestCounter.value,
            filteredRequestList: this.filteredRequestList.value,
            // Total requests and waiting room
            totalReqWait: this.totalReqWait.value,
            // Alerts
            alertVisible: this.alertVisible.value,
            alertMessage: this.alertMessage.value,
            alertType: this.alertType.value,
            alertDuration: this.alertDuration.value,
            // Progress Timer
            progressTimerVisible: this.progressTimerVisible.value,
            progressTimerValue: this.progressTimerValue.value,
            // Menu modals
            isMenuModalVisible: this.isMenuModalVisible.value,
            isRecordingModalVisible: this.isRecordingModalVisible.value,
            isSettingsModalVisible: this.isSettingsModalVisible.value,
            isRequestsModalVisible: this.isRequestsModalVisible.value,
            isWaitingModalVisible: this.isWaitingModalVisible.value,
            isCoHostModalVisible: this.isCoHostModalVisible.value,
            isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
            isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            // Other Modals
            isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            isMessagesModalVisible: this.isMessagesModalVisible.value,
            isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            isConfirmHereModalVisible: this.isConfirmHereModalVisible.value,
            isLoadingModalVisible: this.isLoadingModalVisible.value,
            // Recording Options
            recordingMediaOptions: this.recordingMediaOptions.value,
            recordingAudioOptions: this.recordingAudioOptions.value,
            recordingVideoOptions: this.recordingVideoOptions.value,
            recordingVideoType: this.recordingVideoType.value,
            recordingVideoOptimized: this.recordingVideoOptimized.value,
            recordingDisplayType: this.recordingDisplayType.value,
            recordingAddHLS: this.recordingAddHLS.value,
            recordingAddText: this.recordingAddText.value,
            recordingCustomText: this.recordingCustomText.value,
            recordingCustomTextPosition: this.recordingCustomTextPosition.value,
            recordingCustomTextColor: this.recordingCustomTextColor.value,
            recordingNameTags: this.recordingNameTags.value,
            recordingBackgroundColor: this.recordingBackgroundColor.value,
            recordingNameTagsColor: this.recordingNameTagsColor.value,
            recordingOrientationVideo: this.recordingOrientationVideo.value,
            clearedToResume: this.clearedToResume.value,
            clearedToRecord: this.clearedToRecord.value,
            recordState: this.recordState.value,
            showRecordButtons: this.showRecordButtons.value,
            recordingProgressTime: this.recordingProgressTime.value,
            audioSwitching: this.audioSwitching.value,
            videoSwitching: this.videoSwitching.value,
            // Media states
            videoAlreadyOn: this.videoAlreadyOn.value,
            audioAlreadyOn: this.audioAlreadyOn.value,
            componentSizes: this.componentSizes.value,
            // Permissions
            hasCameraPermission: this.hasCameraPermission.value,
            hasAudioPermission: this.hasAudioPermission.value,
            // Transports
            transportCreated: this.transportCreated.value,
            localTransportCreated: this.localTransportCreated.value,
            transportCreatedVideo: this.transportCreatedVideo.value,
            transportCreatedAudio: this.transportCreatedAudio.value,
            transportCreatedScreen: this.transportCreatedScreen.value,
            producerTransport: this.producerTransport.value,
            localProducerTransport: this.localProducerTransport.value,
            videoProducer: this.videoProducer.value,
            localVideoProducer: this.localVideoProducer.value,
            params: this.params.value,
            videoParams: this.videoParams.value,
            audioParams: this.audioParams.value,
            audioProducer: this.audioProducer.value,
            audioLevel: this.audioLevel.value,
            localAudioProducer: this.localAudioProducer.value,
            consumerTransports: this.consumerTransports.value,
            consumingTransports: this.consumingTransports.value,
            // Polls
            polls: this.polls.value,
            poll: this.poll.value,
            isPollModalVisible: this.isPollModalVisible.value,
            // Background
            customImage: this.customImage.value,
            selectedImage: this.selectedImage.value,
            segmentVideo: this.segmentVideo.value,
            selfieSegmentation: this.selfieSegmentation.value,
            pauseSegmentation: this.pauseSegmentation.value,
            processedStream: this.processedStream.value,
            keepBackground: this.keepBackground.value,
            backgroundHasChanged: this.backgroundHasChanged.value,
            virtualStream: this.virtualStream.value,
            mainCanvas: this.mainCanvas.value,
            prevKeepBackground: this.prevKeepBackground.value,
            appliedBackground: this.appliedBackground.value,
            isBackgroundModalVisible: this.isBackgroundModalVisible.value,
            autoClickBackground: this.autoClickBackground.value,
            // Breakout rooms
            breakoutRooms: this.breakoutRooms.value,
            currentRoomIndex: this.currentRoomIndex.value,
            canStartBreakout: this.canStartBreakout.value,
            breakOutRoomStarted: this.breakOutRoomStarted.value,
            breakOutRoomEnded: this.breakOutRoomEnded.value,
            hostNewRoom: this.hostNewRoom.value,
            limitedBreakRoom: this.limitedBreakRoom.value,
            mainRoomsLength: this.mainRoomsLength.value,
            memberRoom: this.memberRoom.value,
            isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            // Whiteboard
            whiteboardUsers: this.whiteboardUsers.value,
            currentWhiteboardIndex: this.currentWhiteboardIndex.value,
            canStartWhiteboard: this.canStartWhiteboard.value,
            whiteboardStarted: this.whiteboardStarted.value,
            whiteboardEnded: this.whiteboardEnded.value,
            whiteboardLimit: this.whiteboardLimit.value,
            isWhiteboardModalVisible: this.isWhiteboardModalVisible.value,
            isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            shapes: this.shapes.value,
            useImageBackground: this.useImageBackground.value,
            redoStack: this.redoStack.value,
            undoStack: this.undoStack.value,
            canvasStream: this.canvasStream.value,
            canvasWhiteboard: this.canvasWhiteboard.value,
            // Screenboard
            canvasScreenboard: this.canvasScreenboard.value,
            processedScreenStream: this.processedScreenStream.value,
            annotateScreenStream: this.annotateScreenStream.value,
            mainScreenCanvas: this.mainScreenCanvas.value,
            isScreenboardModalVisible: this.isScreenboardModalVisible.value,
            validated: this.validated.value,
            device: this.device.value,
            socket: this.socket.value,
            localSocket: this.localSocket.value,
            checkMediaPermission: false,
            onWeb: true,
            // Update functions
            updateRoomName: this.updateRoomName.bind(this),
            updateMember: this.updateMember.bind(this),
            updateAdminPasscode: this.updateAdminPasscode.bind(this),
            updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
            updateYouAreHost: this.updateYouAreHost.bind(this),
            updateIslevel: this.updateIslevel.bind(this),
            updateCoHost: this.updateCoHost.bind(this),
            updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
            updateConfirmedToRecord: this.updateConfirmedToRecord.bind(this),
            updateMeetingDisplayType: this.updateMeetingDisplayType.bind(this),
            updateMeetingVideoOptimized: this.updateMeetingVideoOptimized.bind(this),
            updateEventType: this.updateEventType.bind(this),
            updateParticipants: this.updateParticipants.bind(this),
            updateParticipantsCounter: this.updateParticipantsCounter.bind(this),
            updateParticipantsFilter: this.updateParticipantsFilter.bind(this),
            // More update functions for media details
            updateConsume_sockets: this.updateConsume_sockets.bind(this),
            updateRtpCapabilities: this.updateRtpCapabilities.bind(this),
            updateRoomRecvIPs: this.updateRoomRecvIPs.bind(this),
            updateMeetingRoomParams: this.updateMeetingRoomParams.bind(this),
            updateItemPageLimit: this.updateItemPageLimit.bind(this),
            updateAudioOnlyRoom: this.updateAudioOnlyRoom.bind(this),
            updateAddForBasic: this.updateAddForBasic.bind(this),
            updateScreenPageLimit: this.updateScreenPageLimit.bind(this),
            updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
            updateShared: this.updateShared.bind(this),
            updateTargetOrientation: this.updateTargetOrientation.bind(this),
            updateTargetResolution: this.updateTargetResolution.bind(this),
            updateTargetResolutionHost: this.updateTargetResolutionHost.bind(this),
            updateVidCons: this.updateVidCons.bind(this),
            updateFrameRate: this.updateFrameRate.bind(this),
            updateHParams: this.updateHParams.bind(this),
            updateVParams: this.updateVParams.bind(this),
            updateScreenParams: this.updateScreenParams.bind(this),
            updateAParams: this.updateAParams.bind(this),
            // More update functions for recording details
            updateRecordingAudioPausesLimit: this.updateRecordingAudioPausesLimit.bind(this),
            updateRecordingAudioPausesCount: this.updateRecordingAudioPausesCount.bind(this),
            updateRecordingAudioSupport: this.updateRecordingAudioSupport.bind(this),
            updateRecordingAudioPeopleLimit: this.updateRecordingAudioPeopleLimit.bind(this),
            updateRecordingAudioParticipantsTimeLimit: this.updateRecordingAudioParticipantsTimeLimit.bind(this),
            updateRecordingVideoPausesCount: this.updateRecordingVideoPausesCount.bind(this),
            updateRecordingVideoPausesLimit: this.updateRecordingVideoPausesLimit.bind(this),
            updateRecordingVideoSupport: this.updateRecordingVideoSupport.bind(this),
            updateRecordingVideoPeopleLimit: this.updateRecordingVideoPeopleLimit.bind(this),
            updateRecordingVideoParticipantsTimeLimit: this.updateRecordingVideoParticipantsTimeLimit.bind(this),
            updateRecordingAllParticipantsSupport: this.updateRecordingAllParticipantsSupport.bind(this),
            updateRecordingVideoParticipantsSupport: this.updateRecordingVideoParticipantsSupport.bind(this),
            updateRecordingAllParticipantsFullRoomSupport: this.updateRecordingAllParticipantsFullRoomSupport.bind(this),
            updateRecordingVideoParticipantsFullRoomSupport: this.updateRecordingVideoParticipantsFullRoomSupport.bind(this),
            updateRecordingPreferredOrientation: this.updateRecordingPreferredOrientation.bind(this),
            updateRecordingSupportForOtherOrientation: this.updateRecordingSupportForOtherOrientation.bind(this),
            updateRecordingMultiFormatsSupport: this.updateRecordingMultiFormatsSupport.bind(this),
            updateUserRecordingParams: this.updateUserRecordingParams.bind(this),
            updateCanRecord: this.updateCanRecord.bind(this),
            updateStartReport: this.updateStartReport.bind(this),
            updateEndReport: this.updateEndReport.bind(this),
            updateRecordTimerInterval: this.updateRecordTimerInterval.bind(this),
            updateRecordStartTime: this.updateRecordStartTime.bind(this),
            updateRecordElapsedTime: this.updateRecordElapsedTime.bind(this),
            updateIsTimerRunning: this.updateIsTimerRunning.bind(this),
            updateCanPauseResume: this.updateCanPauseResume.bind(this),
            updateRecordChangeSeconds: this.updateRecordChangeSeconds.bind(this),
            updatePauseLimit: this.updatePauseLimit.bind(this),
            updatePauseRecordCount: this.updatePauseRecordCount.bind(this),
            updateCanLaunchRecord: this.updateCanLaunchRecord.bind(this),
            updateStopLaunchRecord: this.updateStopLaunchRecord.bind(this),
            updateParticipantsAll: this.updateParticipantsAll.bind(this),
            updateFirstAll: this.updateFirstAll.bind(this),
            updateUpdateMainWindow: this.updateUpdateMainWindow.bind(this),
            updateFirst_round: this.updateFirst_round.bind(this),
            updateLandScaped: this.updateLandScaped.bind(this),
            updateLock_screen: this.updateLock_screen.bind(this),
            updateScreenId: this.updateScreenId.bind(this),
            updateAllVideoStreams: this.updateAllVideoStreams.bind(this),
            updateNewLimitedStreams: this.updateNewLimitedStreams.bind(this),
            updateNewLimitedStreamsIDs: this.updateNewLimitedStreamsIDs.bind(this),
            updateActiveSounds: this.updateActiveSounds.bind(this),
            updateScreenShareIDStream: this.updateScreenShareIDStream.bind(this),
            updateScreenShareNameStream: this.updateScreenShareNameStream.bind(this),
            updateAdminIDStream: this.updateAdminIDStream.bind(this),
            updateAdminNameStream: this.updateAdminNameStream.bind(this),
            updateYouYouStream: this.updateYouYouStream.bind(this),
            updateYouYouStreamIDs: this.updateYouYouStreamIDs.bind(this),
            updateLocalStream: this.updateLocalStream.bind(this),
            updateRecordStarted: this.updateRecordStarted.bind(this),
            updateRecordResumed: this.updateRecordResumed.bind(this),
            updateRecordPaused: this.updateRecordPaused.bind(this),
            updateRecordStopped: this.updateRecordStopped.bind(this),
            updateAdminRestrictSetting: this.updateAdminRestrictSetting.bind(this),
            updateVideoRequestState: this.updateVideoRequestState.bind(this),
            updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
            updateVideoAction: this.updateVideoAction.bind(this),
            updateLocalStreamVideo: this.updateLocalStreamVideo.bind(this),
            updateUserDefaultVideoInputDevice: this.updateUserDefaultVideoInputDevice.bind(this),
            updateCurrentFacingMode: this.updateCurrentFacingMode.bind(this),
            updatePrevFacingMode: this.updatePrevFacingMode.bind(this),
            updateDefVideoID: this.updateDefVideoID.bind(this),
            updateAllowed: this.updateAllowed.bind(this),
            updateDispActiveNames: this.updateDispActiveNames.bind(this),
            updateP_dispActiveNames: this.updateP_dispActiveNames.bind(this),
            updateActiveNames: this.updateActiveNames.bind(this),
            updatePrevActiveNames: this.updatePrevActiveNames.bind(this),
            updateP_activeNames: this.updateP_activeNames.bind(this),
            updateMembersReceived: this.updateMembersReceived.bind(this),
            updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
            updateHostFirstSwitch: this.updateHostFirstSwitch.bind(this),
            updateMicAction: this.updateMicAction.bind(this),
            updateScreenAction: this.updateScreenAction.bind(this),
            updateChatAction: this.updateChatAction.bind(this),
            updateAudioRequestState: this.updateAudioRequestState.bind(this),
            updateScreenRequestState: this.updateScreenRequestState.bind(this),
            updateChatRequestState: this.updateChatRequestState.bind(this),
            updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
            updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
            updateChatRequestTime: this.updateChatRequestTime.bind(this),
            updateOldSoundIds: this.updateOldSoundIds.bind(this),
            updateHostLabel: this.updateHostLabel.bind(this),
            updateMainScreenFilled: this.updateMainScreenFilled.bind(this),
            updateLocalStreamScreen: this.updateLocalStreamScreen.bind(this),
            updateScreenAlreadyOn: this.updateScreenAlreadyOn.bind(this),
            updateChatAlreadyOn: this.updateChatAlreadyOn.bind(this),
            updateRedirectURL: this.updateRedirectURL.bind(this),
            updateOldAllStreams: this.updateOldAllStreams.bind(this),
            updateAdminVidID: this.updateAdminVidID.bind(this),
            updateStreamNames: this.updateStreamNames.bind(this),
            updateNon_alVideoStreams: this.updateNon_alVideoStreams.bind(this),
            updateSortAudioLoudness: this.updateSortAudioLoudness.bind(this),
            updateAudioDecibels: this.updateAudioDecibels.bind(this),
            updateMixed_alVideoStreams: this.updateMixed_alVideoStreams.bind(this),
            updateNon_alVideoStreams_muted: this.updateNon_alVideoStreams_muted.bind(this),
            updatePaginatedStreams: this.updatePaginatedStreams.bind(this),
            updateLocalStreamAudio: this.updateLocalStreamAudio.bind(this),
            updateDefAudioID: this.updateDefAudioID.bind(this),
            updateUserDefaultAudioInputDevice: this.updateUserDefaultAudioInputDevice.bind(this),
            updateUserDefaultAudioOutputDevice: this.updateUserDefaultAudioOutputDevice.bind(this),
            updatePrevAudioInputDevice: this.updatePrevAudioInputDevice.bind(this),
            updatePrevVideoInputDevice: this.updatePrevVideoInputDevice.bind(this),
            updateAudioPaused: this.updateAudioPaused.bind(this),
            updateMainScreenPerson: this.updateMainScreenPerson.bind(this),
            updateAdminOnMainScreen: this.updateAdminOnMainScreen.bind(this),
            updateScreenStates: this.updateScreenStates.bind(this),
            updatePrevScreenStates: this.updatePrevScreenStates.bind(this),
            updateUpdateDateState: this.updateUpdateDateState.bind(this),
            updateLastUpdate: this.updateLastUpdate.bind(this),
            updateNForReadjustRecord: this.updateNForReadjustRecord.bind(this),
            updateFixedPageLimit: this.updateFixedPageLimit.bind(this),
            updateRemoveAltGrid: this.updateRemoveAltGrid.bind(this),
            updateNForReadjust: this.updateNForReadjust.bind(this),
            updateLastReorderTime: this.updateLastReorderTime.bind(this),
            updateAudStreamNames: this.updateAudStreamNames.bind(this),
            updateCurrentUserPage: this.updateCurrentUserPage.bind(this),
            updateMainHeightWidth: this.updateMainHeightWidth.bind(this),
            updatePrevMainHeightWidth: this.updatePrevMainHeightWidth.bind(this),
            updatePrevDoPaginate: this.updatePrevDoPaginate.bind(this),
            updateDoPaginate: this.updateDoPaginate.bind(this),
            updateShareEnded: this.updateShareEnded.bind(this),
            updateLStreams: this.updateLStreams.bind(this),
            updateChatRefStreams: this.updateChatRefStreams.bind(this),
            updateControlHeight: this.updateControlHeight.bind(this),
            updateIsWideScreen: this.updateIsWideScreen.bind(this),
            updateIsMediumScreen: this.updateIsMediumScreen.bind(this),
            updateIsSmallScreen: this.updateIsSmallScreen.bind(this),
            updateAddGrid: this.updateAddGrid.bind(this),
            updateAddAltGrid: this.updateAddAltGrid.bind(this),
            updateGridRows: this.updateGridRows.bind(this),
            updateGridCols: this.updateGridCols.bind(this),
            updateAltGridRows: this.updateAltGridRows.bind(this),
            updateAltGridCols: this.updateAltGridCols.bind(this),
            updateNumberPages: this.updateNumberPages.bind(this),
            updateCurrentStreams: this.updateCurrentStreams.bind(this),
            updateShowMiniView: this.updateShowMiniView.bind(this),
            updateNStream: this.updateNStream.bind(this),
            updateDefer_receive: this.updateDefer_receive.bind(this),
            updateAllAudioStreams: this.updateAllAudioStreams.bind(this),
            updateRemoteScreenStream: this.updateRemoteScreenStream.bind(this),
            updateScreenProducer: this.updateScreenProducer.bind(this),
            updateGotAllVids: this.updateGotAllVids.bind(this),
            updatePaginationHeightWidth: this.updatePaginationHeightWidth.bind(this),
            updatePaginationDirection: this.updatePaginationDirection.bind(this),
            updateGridSizes: this.updateGridSizes.bind(this),
            updateScreenForceFullDisplay: this.updateScreenForceFullDisplay.bind(this),
            updateMainGridStream: this.updateMainGridStream.bind(this),
            updateOtherGridStreams: this.updateOtherGridStreams.bind(this),
            updateAudioOnlyStreams: this.updateAudioOnlyStreams.bind(this),
            updateVideoInputs: this.updateVideoInputs.bind(this),
            updateAudioInputs: this.updateAudioInputs.bind(this),
            updateMeetingProgressTime: this.updateMeetingProgressTime.bind(this),
            updateMeetingElapsedTime: this.updateMeetingElapsedTime.bind(this),
            updateRef_participants: this.updateRef_participants.bind(this),
            updateMessages: this.updateMessages.bind(this),
            updateStartDirectMessage: this.updateStartDirectMessage.bind(this),
            updateDirectMessageDetails: this.updateDirectMessageDetails.bind(this),
            updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
            // Event settings
            updateAudioSetting: this.updateAudioSetting.bind(this),
            updateVideoSetting: this.updateVideoSetting.bind(this),
            updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
            updateChatSetting: this.updateChatSetting.bind(this),
            // Display settings
            updateAutoWave: this.updateAutoWave.bind(this),
            updateForceFullDisplay: this.updateForceFullDisplay.bind(this),
            updatePrevForceFullDisplay: this.updatePrevForceFullDisplay.bind(this),
            updatePrevMeetingDisplayType: this.updatePrevMeetingDisplayType.bind(this),
            // Waiting room
            updateWaitingRoomFilter: this.updateWaitingRoomFilter.bind(this),
            updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
            updateWaitingRoomCounter: this.updateWaitingRoomCounter.bind(this),
            // Requests
            updateRequestFilter: this.updateRequestFilter.bind(this),
            updateRequestList: this.updateRequestList.bind(this),
            updateRequestCounter: this.updateRequestCounter.bind(this),
            // Total requests and waiting room
            updateTotalReqWait: this.updateTotalReqWait.bind(this),
            // Menu modals
            updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
            updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
            updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
            updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
            updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
            updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
            // Other modals
            updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
            updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
            updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
            updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
            updateIsLoadingModalVisible: this.updateIsLoadingModalVisible.bind(this),
            // Recording Options
            updateRecordingMediaOptions: this.updateRecordingMediaOptions.bind(this),
            updateRecordingAudioOptions: this.updateRecordingAudioOptions.bind(this),
            updateRecordingVideoOptions: this.updateRecordingVideoOptions.bind(this),
            updateRecordingVideoType: this.updateRecordingVideoType.bind(this),
            updateRecordingVideoOptimized: this.updateRecordingVideoOptimized.bind(this),
            updateRecordingDisplayType: this.updateRecordingDisplayType.bind(this),
            updateRecordingAddHLS: this.updateRecordingAddHLS.bind(this),
            updateRecordingAddText: this.updateRecordingAddText.bind(this),
            updateRecordingCustomText: this.updateRecordingCustomText.bind(this),
            updateRecordingCustomTextPosition: this.updateRecordingCustomTextPosition.bind(this),
            updateRecordingCustomTextColor: this.updateRecordingCustomTextColor.bind(this),
            updateRecordingNameTags: this.updateRecordingNameTags.bind(this),
            updateRecordingBackgroundColor: this.updateRecordingBackgroundColor.bind(this),
            updateRecordingNameTagsColor: this.updateRecordingNameTagsColor.bind(this),
            updateRecordingOrientationVideo: this.updateRecordingOrientationVideo.bind(this),
            updateClearedToResume: this.updateClearedToResume.bind(this),
            updateClearedToRecord: this.updateClearedToRecord.bind(this),
            updateRecordState: this.updateRecordState.bind(this),
            updateShowRecordButtons: this.updateShowRecordButtons.bind(this),
            updateRecordingProgressTime: this.updateRecordingProgressTime.bind(this),
            updateAudioSwitching: this.updateAudioSwitching.bind(this),
            updateVideoSwitching: this.updateVideoSwitching.bind(this),
            // Media states
            updateVideoAlreadyOn: this.updateVideoAlreadyOn.bind(this),
            updateAudioAlreadyOn: this.updateAudioAlreadyOn.bind(this),
            updateComponentSizes: this.updateComponentSizes.bind(this),
            // Permissions
            updateHasCameraPermission: this.updateHasCameraPermission.bind(this),
            updateHasAudioPermission: this.updateHasAudioPermission.bind(this),
            // Transports
            updateTransportCreated: this.updateTransportCreated.bind(this),
            updateLocalTransportCreated: this.updateLocalTransportCreated.bind(this),
            updateTransportCreatedVideo: this.updateTransportCreatedVideo.bind(this),
            updateTransportCreatedAudio: this.updateTransportCreatedAudio.bind(this),
            updateTransportCreatedScreen: this.updateTransportCreatedScreen.bind(this),
            updateProducerTransport: this.updateProducerTransport.bind(this),
            updateLocalProducerTransport: this.updateLocalProducerTransport.bind(this),
            updateVideoProducer: this.updateVideoProducer.bind(this),
            updateLocalVideoProducer: this.updateLocalVideoProducer.bind(this),
            updateParams: this.updateParams.bind(this),
            updateVideoParams: this.updateVideoParams.bind(this),
            updateAudioParams: this.updateAudioParams.bind(this),
            updateAudioProducer: this.updateAudioProducer.bind(this),
            updateAudioLevel: this.updateAudioLevel.bind(this),
            updateLocalAudioProducer: this.updateLocalAudioProducer.bind(this),
            updateConsumerTransports: this.updateConsumerTransports.bind(this),
            updateConsumingTransports: this.updateConsumingTransports.bind(this),
            // Polls
            updatePolls: this.updatePolls.bind(this),
            updatePoll: this.updatePoll.bind(this),
            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
            // Background
            updateCustomImage: this.updateCustomImage.bind(this),
            updateSelectedImage: this.updateSelectedImage.bind(this),
            updateSegmentVideo: this.updateSegmentVideo.bind(this),
            updateSelfieSegmentation: this.updateSelfieSegmentation.bind(this),
            updatePauseSegmentation: this.updatePauseSegmentation.bind(this),
            updateProcessedStream: this.updateProcessedStream.bind(this),
            updateKeepBackground: this.updateKeepBackground.bind(this),
            updateBackgroundHasChanged: this.updateBackgroundHasChanged.bind(this),
            updateVirtualStream: this.updateVirtualStream.bind(this),
            updateMainCanvas: this.updateMainCanvas.bind(this),
            updatePrevKeepBackground: this.updatePrevKeepBackground.bind(this),
            updateAppliedBackground: this.updateAppliedBackground.bind(this),
            updateIsBackgroundModalVisible: this.updateIsBackgroundModalVisible.bind(this),
            updateAutoClickBackground: this.updateAutoClickBackground.bind(this),
            // Breakout rooms
            updateBreakoutRooms: this.updateBreakoutRooms.bind(this),
            updateCurrentRoomIndex: this.updateCurrentRoomIndex.bind(this),
            updateCanStartBreakout: this.updateCanStartBreakout.bind(this),
            updateBreakOutRoomStarted: this.updateBreakOutRoomStarted.bind(this),
            updateBreakOutRoomEnded: this.updateBreakOutRoomEnded.bind(this),
            updateHostNewRoom: this.updateHostNewRoom.bind(this),
            updateLimitedBreakRoom: this.updateLimitedBreakRoom.bind(this),
            updateMainRoomsLength: this.updateMainRoomsLength.bind(this),
            updateMemberRoom: this.updateMemberRoom.bind(this),
            updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
            // Whiteboard
            updateWhiteboardUsers: this.updateWhiteboardUsers.bind(this),
            updateCurrentWhiteboardIndex: this.updateCurrentWhiteboardIndex.bind(this),
            updateCanStartWhiteboard: this.updateCanStartWhiteboard.bind(this),
            updateWhiteboardStarted: this.updateWhiteboardStarted.bind(this),
            updateWhiteboardEnded: this.updateWhiteboardEnded.bind(this),
            updateWhiteboardLimit: this.updateWhiteboardLimit.bind(this),
            updateIsWhiteboardModalVisible: this.updateIsWhiteboardModalVisible.bind(this),
            updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
            updateShapes: this.updateShapes.bind(this),
            updateUseImageBackground: this.updateUseImageBackground.bind(this),
            updateRedoStack: this.updateRedoStack.bind(this),
            updateUndoStack: this.updateUndoStack.bind(this),
            updateCanvasStream: this.updateCanvasStream.bind(this),
            updateCanvasWhiteboard: this.updateCanvasWhiteboard.bind(this),
            // Screenboard
            updateCanvasScreenboard: this.updateCanvasScreenboard.bind(this),
            updateProcessedScreenStream: this.updateProcessedScreenStream.bind(this),
            updateAnnotateScreenStream: this.updateAnnotateScreenStream.bind(this),
            updateMainScreenCanvas: this.updateMainScreenCanvas.bind(this),
            updateIsScreenboardModalVisible: this.updateIsScreenboardModalVisible.bind(this),
            // Other functions
            checkOrientation: this.checkOrientation.bind(this),
            updateDevice: this.updateDevice.bind(this),
            updateSocket: this.updateSocket.bind(this),
            updateLocalSocket: this.updateLocalSocket.bind(this),
            updateValidated: this.updateValidated.bind(this),
            showAlert: this.showAlert.bind(this),
            getUpdatedAllParams: () => {
                try {
                    if (this.sourceParameters !== null) {
                        this.sourceParameters = {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        };
                        if (this.updateSourceParameters) {
                            this.updateSourceParameters(this.sourceParameters);
                        }
                    }
                }
                catch {
                    console.log('error updateSourceParameters');
                }
                return {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                };
            },
        };
    }
    mediaSFUParameters = {
        ...this.getAllParams(),
        ...this.mediaSFUFunctions(),
    };
    getUpdatedAllParams = () => {
        return {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    };
    updateButtonState(buttonType, value) {
        this.controlButtons = this.controlButtons.map((button) => {
            if (buttonType === 'micActive' && button.icon === this.faMicrophoneSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'videoActive' && button.icon === this.faVideoSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'screenShareActive' && button.icon === this.faDesktop) {
                if (button.alternateIconComponent) {
                    const updatedInjector = this.createInjector({
                        disabled: !value,
                    });
                    return {
                        ...button,
                        active: true,
                        alternateIconComponent: { ...this.screenShareWidget, injector: updatedInjector },
                    }; //always default to true for active
                }
                else {
                    return { ...button, active: true }; //always default to true for active
                }
            }
            if (buttonType === 'endCallActive' && button.icon === this.faPhone) {
                return { ...button, active: value };
            }
            if (buttonType === 'participantsActive' && button.icon === this.faUsers) {
                return { ...button, active: value };
            }
            if (buttonType === 'showMessagesBadge' &&
                button.customName &&
                button.customName === 'Messages') {
                const updatedInjector = this.createInjector({
                    icon: this.faComments,
                    badgeValue: value ? '*' : '',
                    iconColor: 'black',
                    showBadge: value,
                });
                return { ...button, customComponent: { ...this.messageWidget, injector: updatedInjector } };
            }
            if (buttonType === 'showMenuBadge' && button.customName && button.customName === 'Menu') {
                const updatedInjector = this.createInjector({
                    icon: this.faBars,
                    badgeValue: this.totalReqWait.value,
                    iconColor: 'black',
                    showBadge: true,
                });
                return { ...button, customComponent: { ...this.menuWidget, injector: updatedInjector } };
            }
            return button;
        });
        this.cdr.detectChanges();
    }
    PrejoinPageComponent = {
        component: this.PrejoinPage,
        injector: null,
    };
    updatePrejoinPageComponent = () => {
        const PrejoinComp = {
            component: this.PrejoinPage,
            injector: this.createInjector({
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    connectLocalSocket: this.socketManager.connectLocalSocket,
                    updateSocket: this.updateSocket,
                    updateLocalSocket: this.updateLocalSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                credentials: this.credentials,
                localLink: this.localLink,
                connectMediaSFU: this.connectMediaSFU,
                returnUI: this.returnUI,
                noUIPreJoinOptions: this.noUIPreJoinOptions,
                joinMediaSFURoom: this.joinMediaSFURoom,
                createMediaSFURoom: this.createMediaSFURoom,
            }),
        };
        this.PrejoinPageComponent = { ...PrejoinComp };
        this.cdr.detectChanges();
    };
    ngOnInit() {
        if (this.PrejoinPage) {
            this.updatePrejoinPageComponent();
        }
        this.setupResizeListener();
        if (this.validated) {
            this.connectAndAddSocketMethods();
        }
        this.mainHeightWidthSubscription = this.mainHeightWidth.subscribe(() => {
            this.updateMainVideoSize();
        });
        this.recordingSubscription = combineLatest([
            this.recordPaused,
            this.recordStarted,
            this.recordStopped,
            this.recordResumed,
            this.recordingProgressTime,
            this.showRecordButtons,
            this.islevel,
        ]).subscribe(([recordPaused, recordStarted, recordStopped, recordResumed, recordingProgressTime, showRecordButtons, islevel,]) => {
            if (recordPaused ||
                recordStarted ||
                recordStopped ||
                recordResumed ||
                recordingProgressTime ||
                showRecordButtons ||
                islevel) {
                this.updateRecordButtons();
            }
        });
        this.ScreenboardSubscription = combineLatest([
            this.shared,
            this.componentSizes,
            this.annotateScreenStream,
        ]).subscribe(([shared, componentSizes]) => {
            this.ScreenboardWidget = {
                component: Screenboard,
                inputs: {
                    customWidth: componentSizes.mainWidth,
                    customHeight: componentSizes.mainHeight,
                    parameters: this.mediaSFUParameters,
                    showAspect: shared,
                },
            };
        });
        this.validatedSubscription = this.validated.subscribe((validated) => {
            if (validated) {
                this.handleValidated();
            }
        });
        this.islevelSubscription = this.islevel.subscribe((islevel) => {
            if (islevel) {
                this.updateCustomMenuButtons();
                this.updateControlBroadcastButtons();
                this.updateControlChatButtons();
            }
        });
        this.coHostSubscription = combineLatest([this.coHost, this.coHostResponsibility]).subscribe(([coHost, coHostResponsibility]) => {
            if (coHost || coHostResponsibility) {
                this.updateCustomMenuButtons();
                this.updateControlBroadcastButtons();
                this.updateControlChatButtons();
            }
        });
        // Subscribe to changes in BehaviorSubject and update the buttons accordingly
        this.buttonSubscriptions.push(this.micActive.subscribe((value) => {
            this.updateButtonState('micActive', value);
            this.updateControlBroadcastButtons();
            this.updateControlChatButtons();
        }));
        this.buttonSubscriptions.push(this.videoActive.subscribe((value) => {
            this.updateButtonState('videoActive', value);
            this.updateControlBroadcastButtons();
            this.updateControlChatButtons();
        }));
        this.buttonSubscriptions.push(this.screenShareActive.subscribe((value) => {
            this.updateButtonState('screenShareActive', value);
        }));
        this.buttonSubscriptions.push(this.showMessagesBadge.subscribe((value) => {
            this.updateButtonState('showMessagesBadge', value);
        }));
        this.buttonSubscriptions.push(this.totalReqWait.subscribe(() => {
            this.updateButtonState('showMenuBadge', true);
        }));
        this.buttonSubscriptions.push(this.participantsCounter.subscribe((value) => {
            this.updateMenuParticipantsWidget(value);
        }));
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.handleResize);
        window.removeEventListener('orientationchange', this.handleResize);
        if (this.mainHeightWidthSubscription) {
            this.mainHeightWidthSubscription.unsubscribe();
        }
        if (this.validatedSubscription) {
            this.validatedSubscription.unsubscribe();
        }
        if (this.islevelSubscription) {
            this.islevelSubscription.unsubscribe();
        }
        if (this.coHostSubscription) {
            this.coHostSubscription.unsubscribe();
        }
        if (this.ScreenboardSubscription) {
            this.ScreenboardSubscription.unsubscribe();
        }
        if (this.recordingSubscription) {
            this.recordingSubscription.unsubscribe();
        }
    }
    updateMainVideoSize = async () => {
        if (!this.lock_screen.value && !this.shared.value) {
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
        }
        else {
            if (!this.first_round.value) {
                this.prepopulateUserMedia.prepopulateUserMedia({
                    name: this.hostLabel.value,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            }
        }
    };
    async connectAndAddSocketMethods() {
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
        const socket_ = await this.connect_Socket(this.apiUserName.value, this.apiToken.value);
        if (socket_) {
            this.updateSocket(socket_);
        }
    }
    async handleValidated() {
        this.updateAllVideoStreams([
            { producerId: 'youyou', stream: undefined, id: 'youyou', name: 'youyou' },
        ]);
        this.updateStreamNames([{ id: 'youyou', name: 'youyou', producerId: '' }]);
        if (this.validated.value) {
            try {
                if (!this.localUIMode.value) {
                    this.updateIsLoadingModalVisible(true);
                    await this.connectAndAddSocketMethods();
                }
                else {
                    this.updateIsLoadingModalVisible(false);
                }
            }
            catch (error) {
                console.log('error connectAndaAddSocketMethods', error);
            }
            this.startMeetingProgressTimer.startMeetingProgressTimer({
                startTime: Date.now() / 1000,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            try {
                if (this.sourceParameters !== null) {
                    this.sourceParameters = {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                    };
                    if (this.updateSourceParameters) {
                        this.updateSourceParameters(this.sourceParameters);
                    }
                }
            }
            catch {
                console.log('error updateSourceParameters');
            }
        }
    }
    async handleResize() {
        let fraction = 0;
        if (window.innerHeight < window.innerWidth &&
            (this.eventType.value == 'webinar' || this.eventType.value == 'conference')) {
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        else {
            // Set default control button height for portrait mode or other event types
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            fraction = Number(fraction);
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        const dimensions = this.computeDimensionsMethod({
            containerWidthFraction: 1,
            containerHeightFraction: 1,
            mainSize: this.mainHeightWidth.value,
            doStack: true,
            defaultFraction: this.eventType.value == 'webinar' || this.eventType.value == 'conference'
                ? 1 - fraction
                : 1,
        });
        this.updateComponentSizes(dimensions);
        const orientation = this.checkOrientation();
        if (orientation == 'portrait') {
            if (!this.isWideScreen.value) {
                if (this.shareScreenStarted.value || this.shared.value) {
                    this.updateScreenForceFullDisplay(true);
                }
            }
        }
        // Updates the main grid view
        await this.prepopulateUserMedia.prepopulateUserMedia({
            name: this.hostLabel.value,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
        // Updates the mini grid view
        await this.onScreenChanges.onScreenChanges({
            changed: true,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
    }
    async disconnectAllSockets(consume_sockets) {
        for (const socket of consume_sockets) {
            try {
                const ip = Object.keys(socket)[0];
                await socket[ip].disconnect();
            }
            catch (error) {
                console.log(`Error disconnecting socket with IP: ${Object.keys(socket)[0]}`, error);
            }
        }
    }
    async closeAndReset() {
        //close and clean up all sockets, modals,... and reset all states to initial values
        this.updateIsMessagesModalVisible(false);
        this.updateIsParticipantsModalVisible(false);
        this.updateIsWaitingModalVisible(false);
        this.updateIsRequestsModalVisible(false);
        this.updateIsCoHostModalVisible(false);
        this.updateIsSettingsModalVisible(false);
        this.updateIsDisplaySettingsModalVisible(false);
        this.updateIsMediaSettingsModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsShareEventModalVisible(false);
        this.updateIsConfirmExitModalVisible(false);
        await this.disconnectAllSockets(this.consume_sockets.value);
        await this.updateStatesToInitialValues();
        this.updateMeetingProgressTime('00:00:00');
        this.updateMeetingElapsedTime(0);
        this.updateRecordingProgressTime('00:00:00');
        this.updateRecordElapsedTime(0);
        this.updateShowRecordButtons(false);
        this.updateIsConfigureWhiteboardModalVisible(false);
        this.updateIsWhiteboardModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsRecordingModalVisible(false);
        this.updateIsPollModalVisible(false);
        this.updateIsBreakoutRoomsModalVisible(false);
        this.updateIsBackgroundModalVisible(false);
        this.updateIsLoadingModalVisible(false);
        this.updateIsConfirmHereModalVisible(false);
        await sleep({ ms: 500 });
        this.updateValidated(false);
        //if on web, reload the page
        window.location.reload();
    }
    computeDimensionsMethod = ({ containerWidthFraction = 1, containerHeightFraction = 1, mainSize, doStack = true, defaultFraction, }) => {
        const parentWidth = window.innerWidth * containerWidthFraction;
        const parentHeight = window.innerHeight * containerHeightFraction * defaultFraction;
        let isWideScreen = parentWidth >= 768;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        const dimensions = this.calculateDimensions({
            parentWidth,
            parentHeight,
            isWideScreen,
            mainSize,
            doStack,
        });
        return dimensions;
    };
    calculateDimensions({ parentWidth, parentHeight, isWideScreen, mainSize, doStack, }) {
        if (doStack) {
            return isWideScreen
                ? {
                    mainHeight: Math.floor(parentHeight),
                    otherHeight: Math.floor(parentHeight),
                    mainWidth: Math.floor((mainSize / 100) * parentWidth),
                    otherWidth: Math.floor(((100 - mainSize) / 100) * parentWidth),
                }
                : {
                    mainHeight: Math.floor((mainSize / 100) * parentHeight),
                    otherHeight: Math.floor(((100 - mainSize) / 100) * parentHeight),
                    mainWidth: Math.floor(parentWidth),
                    otherWidth: Math.floor(parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(parentHeight),
                otherHeight: Math.floor(parentHeight),
                mainWidth: Math.floor(parentWidth),
                otherWidth: Math.floor(parentWidth),
            };
        }
    }
    handleOrientationChange() {
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('orientationchange', this.handleResize.bind(this));
    }
    setupResizeListener() {
        this.handleResize();
    }
    orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    async joinRoom(data) {
        const { socket, roomName, islevel, member, sec, apiUserName } = data;
        try {
            const response = await this.joinRoomClient.joinRoomClient({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
            return response;
        }
        catch (error) {
            console.log('Error joining room:', error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    async join_Room({ socket, roomName, islevel, member, sec, apiUserName, isLocal = false, }) {
        let data;
        if (!isLocal) {
            data = await this.joinRoom({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
        }
        else {
            const localData = await this.joinLocalRoom.joinLocalRoom({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    connectLocalSocket: this.socketManager.connectLocalSocket,
                    updateSocket: this.updateSocket,
                    updateLocalSocket: this.updateLocalSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                checkConnect: this.localLink.length > 0 &&
                    this.connectMediaSFU === true &&
                    !this.link.value.includes('mediasfu.com'),
                localLink: this.localLink,
                joinMediaSFURoom: this.joinMediaSFURoom,
            });
            data = await createResponseJoinRoom({ localRoom: localData });
        }
        const updateAndComplete = async (data) => {
            // Update room parameters
            try {
                // Check if roomRecvIPs is not empty
                if (!data.roomRecvIPs || data.roomRecvIPs.length === 0) {
                    data.roomRecvIPs = ['none'];
                    if (this.link.value !== "" &&
                        this.link.value.includes("mediasfu.com") &&
                        !isLocal) {
                        // Community Edition Only
                        await this.receiveAllPipedTransports.receiveAllPipedTransports({
                            community: true,
                            nsock: this.getUpdatedAllParams().socket,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                }
                this.updateRoomParametersClient.updateRoomParametersClient({
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                        data: data,
                    },
                });
                if (data.isHost) {
                    this.updateIslevel('2');
                }
                else {
                    // Issue with isHost for local room
                    if (islevel !== '2') {
                        this.updateIslevel('1');
                    }
                }
                if (data.secureCode && data.secureCode !== '') {
                    this.updateAdminPasscode(data.secureCode);
                }
                if (data.rtpCapabilities) {
                    try {
                        const device_ = await this.createDeviceClient.createDeviceClient({
                            rtpCapabilities: data.rtpCapabilities,
                        });
                        if (device_) {
                            this.device.next(device_);
                        }
                    }
                    catch (error) {
                        console.error('Error creating device:', error);
                    }
                }
            }
            catch (error) {
                console.error('Error in updateAndComplete:', error);
            }
        };
        if (data && data.success) {
            if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && isLocal) {
                this.roomData.next(data);
                return;
            }
            else if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && !isLocal) {
                // Update roomData
                if (this.roomData.value) {
                    // Updating only the recording and meeting room parameters
                    this.roomData.value.recordingParams = data.recordingParams;
                    this.roomData.value.meetingRoomParams = data.meetingRoomParams;
                    this.roomData.next(this.roomData.value);
                }
                else {
                    this.roomData.next(data);
                }
            }
            else {
                // Update roomData
                this.roomData.next(data);
                if (!this.link.value.includes('mediasfu.com')) {
                    this.roomData.value.meetingRoomParams = data.meetingRoomParams;
                }
            }
            await updateAndComplete(data);
        }
        else {
            if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && !isLocal) {
                // Join local room only
                if (this.roomData.value) {
                    await updateAndComplete(this.roomData.value);
                }
                return;
            }
            // Might be a wrong room name or room is full or other error; check reason in data object if available
            try {
                if (this.showAlert && data?.reason) {
                    this.showAlert({
                        message: data.reason,
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
            catch (error) {
                /* handle error */
            }
        }
    }
    onParticipantsFilterChange = (value) => {
        if (value && value.length > 0) {
            this.filteredParticipants.next(this.participants.value.filter((participant) => participant.name.toLowerCase().includes(value.toLowerCase())));
            this.participantsCounter.next(this.filteredParticipants.value.length);
        }
        else {
            this.filteredParticipants.next(this.participants.value);
            this.participantsCounter.next(this.participants.value.length);
        }
    };
    updateStatesToInitialValues = async () => {
        const initialValues = initialValuesState;
        const updateFunctions = this.getAllParams();
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                const updateFunctionName = `update${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const updateFunction = updateFunctions[updateFunctionName];
                if (typeof updateFunction === 'function') {
                    try {
                        updateFunction(initialValues[key]);
                    }
                    catch {
                        /* handle error */
                    }
                }
            }
        }
    };
    faRecordVinyl = faRecordVinyl;
    faPlayCircle = faPlayCircle;
    faPauseCircle = faPauseCircle;
    faStopCircle = faStopCircle;
    faDotCircle = faDotCircle;
    faCog = faCog;
    faUsers = faUsers;
    faClock = faClock;
    faUserPlus = faUserPlus;
    faTools = faTools;
    faDesktop = faDesktop;
    faPoll = faPoll;
    faUserFriends = faUserFriends;
    faChalkboardTeacher = faChalkboardTeacher;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faSync = faSync;
    faPhone = faPhone;
    faShareAlt = faShareAlt;
    faBars = faBars;
    faComments = faComments;
    faChartBar = faChartBar;
    onCloseMenuModal = () => {
        this.updateIsMenuModalVisible(false);
    };
    onEventSettingsClose = () => {
        this.updateIsSettingsModalVisible(false);
    };
    onCoHostClose = () => {
        this.updateIsCoHostModalVisible(false);
    };
    onMediaSettingsClose = () => {
        this.updateIsMediaSettingsModalVisible(false);
    };
    onDisplaySettingsClose = () => {
        this.updateIsDisplaySettingsModalVisible(false);
    };
    onPollClose = () => {
        this.updateIsPollModalVisible(false);
    };
    onBreakoutRoomsClose = () => {
        this.updateIsBreakoutRoomsModalVisible(false);
    };
    onConfigureWhiteboardClose = () => {
        this.updateIsConfigureWhiteboardModalVisible(false);
    };
    onMessagesClose = () => {
        this.updateIsMessagesModalVisible(false);
    };
    onRecordingClose = () => {
        this.updateIsRecordingModalVisible(false);
    };
    onParticipantsClose = () => {
        this.updateIsParticipantsModalVisible(false);
    };
    onBackgroundClose = () => {
        this.updateIsBackgroundModalVisible(false);
    };
    onConfirmExitClose = () => {
        this.updateIsConfirmExitModalVisible(false);
    };
    onConfirmHereClose = () => {
        this.updateIsConfirmHereModalVisible(false);
    };
    onScreenboardClose = () => {
        this.updateIsScreenboardModalVisible(false);
    };
    onShareEventClose = () => {
        this.updateIsShareEventModalVisible(false);
    };
    onAlertHide = () => {
        this.updateAlertVisible(false);
    };
    ScreenboardWidget = {
        component: Screenboard,
        inputs: {
            customWidth: this.componentSizes.value.mainWidth,
            customHeight: this.componentSizes.value.mainHeight,
            parameters: this.mediaSFUParameters,
            showAspect: this.shared.value,
        },
    };
    recordTimerWidget = {
        component: RecordTimerWidget,
        injector: this.createInjector({ recordingProgressTime: this.recordingProgressTime.value }),
    };
    updateRecordTimerWidget = (recordingProgressTime = this.recordingProgressTime.value) => {
        const recordTimerWidget = {
            component: RecordTimerWidget,
            injector: this.createInjector({ recordingProgressTime: recordingProgressTime }),
        };
        this.recordTimerWidget = { ...recordTimerWidget };
        this.cdr.markForCheck();
        return recordTimerWidget;
    };
    recordButton = [
        {
            icon: this.faRecordVinyl,
            text: 'Record',
            onPress: () => {
                this.launchRecording.launchRecording({
                    updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                    isRecordingModalVisible: this.isRecordingModalVisible.value,
                    showAlert: this.showAlert.bind(this),
                    stopLaunchRecord: this.stopLaunchRecord.value,
                    canLaunchRecord: this.canLaunchRecord.value,
                    recordingAudioSupport: this.recordingAudioSupport.value,
                    recordingVideoSupport: this.recordingVideoSupport.value,
                    updateCanRecord: this.updateCanRecord.bind(this),
                    updateClearedToRecord: this.updateClearedToRecord.bind(this),
                    recordStarted: this.recordStarted.value,
                    recordPaused: this.recordPaused.value,
                    localUIMode: this.localUIMode.value,
                });
            },
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
    ];
    recordButtons = [];
    recordButtonsArray = [
        {
            icon: this.faPlayCircle,
            active: () => !this.recordPaused.value,
            onPress: () => this.updateRecording.updateRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            alternateIcon: this.faPauseCircle,
            show: () => true,
        },
        {
            icon: this.faStopCircle,
            active: () => false,
            onPress: () => this.stopRecording.stopRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: () => this.updateRecordTimerWidget(),
            show: () => true,
            active: () => false,
        },
        {
            icon: this.faDotCircle,
            active: () => false,
            onPress: () => console.log('Status pressed'),
            activeColor: 'black',
            inActiveColor: () => (this.recordPaused.value ? 'yellow' : 'red'),
            show: () => true,
        },
        {
            icon: this.faCog,
            active: () => false,
            onPress: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
    ];
    async updateRecordButtons() {
        const recordButtons = this.recordButtonsArray.map((button) => {
            return {
                ...button,
                active: typeof button.active === 'function' ? button.active() : button.active,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
                activeColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
                inActiveColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
            };
        });
        this.recordButtons = [...recordButtons];
        await this.updateMenuRecordWidget(recordButtons);
        this.updateCustomMenuButtons();
        this.updateControlBroadcastButtons();
        this.cdr.markForCheck();
    }
    // Create instances of the custom widgets
    menuWidget = {
        component: MenuWidget,
        injector: this.createInjector({
            icon: this.faBars,
            badgeValue: this.totalReqWait.value,
            iconColor: 'black',
            showBadge: true,
        }),
    };
    messageWidget = {
        component: MessageWidget,
        injector: this.createInjector({
            icon: this.faComments,
            showBadge: this.showMessagesBadge.value,
            badgeValue: 1,
            iconColor: 'black',
        }),
    };
    menuRecordWidget = {
        component: MenuRecordWidget,
        injector: this.createInjector({
            buttons: this.recordButtons,
            showAspect: true,
            direction: 'horizontal',
        }),
    };
    updateMenuRecordWidget = (recordButtons = this.recordButtons) => {
        const menuRecordWidget = {
            component: MenuRecordWidget,
            injector: this.createInjector({
                buttons: recordButtons,
                showAspect: true,
                direction: 'horizontal',
            }),
        };
        this.menuRecordWidget = { ...menuRecordWidget };
        this.cdr.markForCheck();
        return menuRecordWidget;
    };
    menuParticipantsWidget = {
        component: MenuParticipantsWidget,
        injector: this.createInjector({
            icon: this.faChartBar,
            participantsCounter: this.participantsCounter.value,
            iconColor: 'black',
        }),
    };
    updateMenuParticipantsWidget = (count = this.participantsCounter.value) => {
        const menuParticipantsWidget = {
            component: MenuParticipantsWidget,
            injector: this.createInjector({
                icon: this.faChartBar,
                participantsCounter: count,
                iconColor: 'black',
            }),
        };
        this.menuParticipantsWidget = { ...menuParticipantsWidget };
        this.cdr.markForCheck();
        return menuParticipantsWidget;
    };
    customMenuButtonsArray = [
        {
            icon: this.faRecordVinyl,
            text: 'Record',
            action: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            show: () => !this.showRecordButtons.value && this.islevel.value == '2',
        },
        {
            customComponent: () => this.updateMenuRecordWidget(),
            show: () => this.showRecordButtons.value && this.islevel.value == '2',
            action: () => console.log('record buttons pressed'),
        },
        {
            icon: this.faCog,
            text: 'Event Settings',
            action: () => this.launchSettings.launchSettings({
                updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
                isSettingsModalVisible: this.isSettingsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faUsers,
            text: 'Requests',
            action: () => this.launchRequests.launchRequests({
                updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
                isRequestsModalVisible: this.isRequestsModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                ((this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    !!this.coHostResponsibility?.value?.find((item) => item.name === 'media')?.value) ??
                    false) ||
                false,
        },
        {
            icon: this.faClock,
            text: 'Waiting',
            action: () => this.launchWaiting.launchWaiting({
                updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
                isWaitingModalVisible: this.isWaitingModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                (this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    this.coHostResponsibility?.value?.find((item) => item.name === 'waiting')?.value ===
                        true) ||
                false,
        },
        {
            icon: this.faUserPlus,
            text: 'Co-host',
            action: () => this.launchCoHost.launchCoHost({
                updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
                isCoHostModalVisible: this.isCoHostModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faTools,
            text: 'Set Media',
            action: () => this.launchMediaSettings.launchMediaSettings({
                updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
                isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
                audioInputs: this.audioInputs.value,
                videoInputs: this.videoInputs.value,
                updateAudioInputs: this.updateAudioInputs.bind(this),
                updateVideoInputs: this.updateVideoInputs.bind(this),
            }),
            show: () => true,
        },
        {
            icon: this.faDesktop,
            text: 'Display',
            action: () => this.launchDisplaySettings.launchDisplaySettings({
                updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
                isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faPoll,
            text: 'Poll',
            action: () => this.launchPoll.launchPoll({
                updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                isPollModalVisible: this.isPollModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faUserFriends,
            text: 'Breakout Rooms',
            action: () => this.launchBreakoutRooms.launchBreakoutRooms({
                updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
                isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faChalkboardTeacher,
            text: 'Whiteboard',
            action: () => this.launchConfigureWhiteboard.launchConfigureWhiteboard({
                updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
                isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
    ];
    customMenuButtons = [];
    updateCustomMenuButtons() {
        this.customMenuButtons = this.customMenuButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
            };
        });
    }
    controlBroadcastButtons = [];
    updateControlBroadcastButtons() {
        this.controlBroadcastButtons = this.controlBroadcastButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                active: typeof button.active === 'function' ? button.active() : button.active,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
            };
        });
    }
    controlBroadcastButtonsArray = [
        {
            icon: this.faUsers,
            active: true,
            alternateIcon: this.faUsers,
            onPress: () => this.launchParticipants.launchParticipants({
                updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
                isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faShareAlt,
            active: true,
            alternateIcon: this.faShareAlt,
            onPress: () => this.updateIsShareEventModalVisible(!this.isShareEventModalVisible.value),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: this.messageWidget,
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faSync,
            active: true,
            alternateIcon: this.faSync,
            onPress: () => this.switchVideoAlt.switchVideoAlt({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: () => this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            show: () => this.islevel.value == '2',
            activeColor: 'green',
            inActiveColor: 'red',
        },
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: () => this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: () => this.islevel.value == '2',
        },
        {
            customComponent: () => this.menuParticipantsWidget,
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: () => true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => console.log('End Call pressed'),
            activeColor: 'transparent',
            inActiveColor: 'transparent',
            backgroundColor: { default: 'transparent' },
            show: () => false,
        },
    ];
    controlChatButtons = [];
    controlChatButtonsArray = [
        {
            icon: this.faShareAlt,
            active: true,
            alternateIcon: this.faShareAlt,
            onPress: () => this.updateIsShareEventModalVisible(!this.isShareEventModalVisible.value),
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
        {
            customComponent: this.messageWidget,
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: true,
        },
        {
            icon: this.faSync,
            active: true,
            alternateIcon: this.faSync,
            onPress: () => this.switchVideoAlt.switchVideoAlt({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: () => this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: () => this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
    ];
    updateControlChatButtons() {
        this.controlChatButtons = this.controlChatButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                active: typeof button.active === 'function' ? button.active() : button.active,
            };
        });
    }
    screenShareWidget = {
        component: ScreenShareWidget,
        injector: this.createInjector({ disabled: !this.screenShareActive.value }),
    };
    controlButtons = [
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.audioSwitching.value,
            show: true,
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                    MediaStream,
                    MediaStreamTrack,
                    mediaDevices: MediaDevices,
                    device: this.device.value,
                    socket: this.socket.value,
                    showAlert: this.showAlert.bind(this),
                    checkPermission: this.checkPermission.checkPermission,
                    streamSuccessVideo: this.streamSuccessVideo.streamSuccessVideo,
                    hasCameraPermission: this.hasCameraPermission.value,
                    requestPermissionCamera: this.requestPermissionCamera.bind(this),
                    checkMediaPermission: 'web' !== 'web',
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.videoSwitching.value,
            show: true,
        },
        {
            //inverted active for inactive state
            icon: faDesktop,
            alternateIconComponent: this.screenShareWidget,
            active: true,
            onPress: () => this.clickScreenShare.clickScreenShare({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faUsers,
            active: this.participantsActive.value,
            onPress: () => this.launchParticipants.launchParticipants({
                updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
                isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            disabled: false,
            show: true,
        },
        {
            customComponent: this.menuWidget,
            customName: 'Menu',
            onPress: () => this.launchMenuModal.launchMenuModal({
                updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
                isMenuModalVisible: this.isMenuModalVisible.value,
            }),
            show: true,
        },
        {
            customComponent: this.messageWidget,
            customName: 'Messages',
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: true,
        },
    ];
    async connect_Socket(apiUserName, token, skipSockets = false) {
        const socketDefault = this.socket.value;
        const socketAlt = this.connectMediaSFU && this.localSocket.value && this.localSocket.value.id
            ? this.localSocket.value
            : socketDefault;
        if (this.socket.value && this.socket.value.id) {
            if (!skipSockets) {
                // Event listeners on socketDefault
                socketDefault.on('disconnect', async () => {
                    await this.disconnect.disconnect({
                        showAlert: this.showAlert.bind(this),
                        redirectURL: this.redirectURL.value,
                        onWeb: true,
                        updateValidated: this.updateValidated.bind(this),
                    });
                    if (this.videoAlreadyOn.value) {
                        await this.clickVideo.clickVideo({
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    if (this.audioAlreadyOn.value) {
                        await this.clickAudio.clickAudio({
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    await this.closeAndReset();
                });
                socketDefault.on('allMembers', async (membersData) => {
                    if (membersData) {
                        await this.allMembers.allMembers({
                            apiUserName: apiUserName,
                            apiKey: '', //not recommended - use apiToken instead. Use for testing/development only
                            apiToken: token,
                            members: membersData.members,
                            requestss: membersData.requests ? membersData.requests : this.requestList.value,
                            coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                            coHostRes: membersData.coHostResponsibilities
                                ? membersData.coHostResponsibilities
                                : this.coHostResponsibility.value,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                            consume_sockets: this.consume_sockets.value,
                        });
                    }
                });
                socketDefault.on('allMembersRest', async (membersData) => {
                    if (membersData) {
                        await this.allMembersRest.allMembersRest({
                            apiUserName: apiUserName,
                            apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                            members: membersData.members,
                            apiToken: token,
                            settings: membersData.settings,
                            coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                            coHostRes: membersData.coHostResponsibilities
                                ? membersData.coHostResponsibilities
                                : this.coHostResponsibility.value,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                            consume_sockets: this.consume_sockets.value,
                        });
                    }
                });
                socketDefault.on('userWaiting', async ({ name }) => {
                    await this.userWaiting.userWaiting({
                        name,
                        showAlert: this.showAlert.bind(this),
                        totalReqWait: this.totalReqWait.value,
                        updateTotalReqWait: this.updateTotalReqWait.bind(this),
                    });
                });
                socketDefault.on('personJoined', async ({ name }) => {
                    this.personJoined.personJoined({
                        name,
                        showAlert: this.showAlert.bind(this),
                    });
                });
                socketDefault.on('allWaitingRoomMembers', async (waiting_data) => {
                    await this.allWaitingRoomMembers.allWaitingRoomMembers({
                        waitingParticipants: waiting_data.waitingParticipants
                            ? waiting_data.waitingParticipants
                            : waiting_data.waitingParticipantss
                                ? waiting_data.waitingParticipantss
                                : this.waitingRoomList.value,
                        updateTotalReqWait: this.updateTotalReqWait.bind(this),
                        updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
                    });
                });
                socketDefault.on('ban', async ({ name }) => {
                    await this.banParticipant.banParticipant({
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('updatedCoHost', async (cohost_data) => {
                    await this.updatedCoHost.updatedCoHost({
                        coHost: cohost_data.coHost ? cohost_data.coHost : this.coHost.value,
                        coHostResponsibility: cohost_data.coHostResponsibilities
                            ? cohost_data.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        youAreCoHost: this.youAreCoHost.value,
                        updateCoHost: this.updateCoHost.bind(this),
                        updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
                        updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
                        showAlert: this.showAlert.bind(this),
                        eventType: this.eventType.value,
                        islevel: this.islevel.value,
                        member: this.member.value,
                    });
                });
                socketDefault.on('participantRequested', async ({ userRequest }) => {
                    await this.participantRequested.participantRequested({
                        userRequest,
                        requestList: this.requestList.value,
                        waitingRoomList: this.waitingRoomList.value,
                        updateTotalReqWait: this.updateTotalReqWait.bind(this),
                        updateRequestList: this.updateRequestList.bind(this),
                    });
                });
                socketDefault.on('screenProducerId', async ({ producerId }) => {
                    this.screenProducerId.screenProducerId({
                        producerId,
                        screenId: this.screenId.value,
                        membersReceived: this.membersReceived.value,
                        shareScreenStarted: this.shareScreenStarted.value,
                        deferScreenReceived: this.deferScreenReceived.value,
                        participants: this.participants.value,
                        updateScreenId: this.updateScreenId.bind(this),
                        updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
                        updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
                    });
                });
                socketDefault.on('updateMediaSettings', async ({ settings }) => {
                    this.updateMediaSettings.updateMediaSettings({
                        settings,
                        updateAudioSetting: this.updateAudioSetting.bind(this),
                        updateVideoSetting: this.updateVideoSetting.bind(this),
                        updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
                        updateChatSetting: this.updateChatSetting.bind(this),
                    });
                });
                socketDefault.on('producer-media-paused', async ({ producerId, kind, name, }) => {
                    await this.producerMediaPaused.producerMediaPaused({
                        producerId,
                        kind,
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('producer-media-resumed', async ({ kind, name }) => {
                    await this.producerMediaResumed.producerMediaResumed({
                        kind,
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('producer-media-closed', async ({ producerId, kind, }) => {
                    if (producerId && kind) {
                        await this.producerMediaClosed.producerMediaClosed({
                            producerId,
                            kind,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                });
                socketDefault.on('controlMediaHost', async ({ type }) => {
                    await this.controlMediaHost.controlMediaHost({
                        type,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('meetingEnded', async () => {
                    await this.meetingEnded.meetingEnded({
                        showAlert: this.showAlert.bind(this),
                        redirectURL: this.redirectURL.value,
                        onWeb: true,
                        eventType: this.eventType.value,
                        updateValidated: this.updateValidated.bind(this),
                    });
                    if (this.videoAlreadyOn.value) {
                        await this.clickVideo.clickVideo({
                            parameters: {
                                ...this.getAllParams(),
                                ...this.mediaSFUFunctions(),
                            },
                        });
                    }
                    if (this.audioAlreadyOn.value) {
                        await this.clickAudio.clickAudio({
                            parameters: {
                                ...this.getAllParams(),
                                ...this.mediaSFUFunctions(),
                            },
                        });
                    }
                    await this.closeAndReset();
                });
                socketDefault.on('disconnectUserSelf', async () => {
                    await this.disconnectUserSelf.disconnectUserSelf({
                        socket: socketDefault,
                        member: this.member.value,
                        roomName: this.roomName.value,
                    });
                });
                socketDefault.on('receiveMessage', async ({ message }) => {
                    await this.receiveMessage.receiveMessage({
                        message,
                        messages: this.messages.value,
                        participantsAll: this.participantsAll.value,
                        member: this.member.value,
                        eventType: this.eventType.value,
                        islevel: this.islevel.value,
                        coHost: this.coHost.value,
                        updateMessages: this.updateMessages.bind(this),
                        updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
                    });
                });
                socketDefault.on('meetingTimeRemaining', async ({ timeRemaining }) => {
                    await this.meetingTimeRemaining.meetingTimeRemaining({
                        timeRemaining,
                        showAlert: this.showAlert.bind(this),
                        eventType: this.eventType.value,
                    });
                });
                socketDefault.on('meetingStillThere', async () => {
                    this.meetingStillThere.meetingStillThere({
                        updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
                    });
                });
                socketDefault.on('updateConsumingDomains', async ({ domains, alt_domains }) => {
                    await this.updateConsumingDomains.updateConsumingDomains({
                        domains,
                        alt_domains,
                        apiUserName,
                        apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                        apiToken: token,
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                });
                socketDefault.on('hostRequestResponse', ({ requestResponse }) => {
                    this.hostRequestResponse.hostRequestResponse({
                        requestResponse,
                        showAlert: this.showAlert.bind(this),
                        requestList: this.requestList.value,
                        updateRequestList: this.updateRequestList.bind(this),
                        updateMicAction: this.updateMicAction.bind(this),
                        updateVideoAction: this.updateVideoAction.bind(this),
                        updateScreenAction: this.updateScreenAction.bind(this),
                        updateChatAction: this.updateChatAction.bind(this),
                        updateAudioRequestState: this.updateAudioRequestState.bind(this),
                        updateVideoRequestState: this.updateVideoRequestState.bind(this),
                        updateScreenRequestState: this.updateScreenRequestState.bind(this),
                        updateChatRequestState: this.updateChatRequestState.bind(this),
                        updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
                        updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
                        updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
                        updateChatRequestTime: this.updateChatRequestTime.bind(this),
                        updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
                    });
                });
                socketDefault.on('pollUpdated', async (data) => {
                    try {
                        await this.pollUpdated.pollUpdated({
                            data,
                            polls: this.polls.value,
                            poll: this.poll.value ? this.poll.value : {},
                            member: this.member.value,
                            islevel: this.islevel.value,
                            showAlert: this.showAlert.bind(this),
                            updatePolls: this.updatePolls.bind(this),
                            updatePoll: this.updatePoll.bind(this),
                            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                        });
                    }
                    catch {
                        /* handle error */
                    }
                });
                socketDefault.on('breakoutRoomUpdated', async (data) => {
                    try {
                        await this.breakoutRoomUpdated.breakoutRoomUpdated({
                            data,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    catch {
                        /* handle error */
                    }
                });
            }
            if (skipSockets) {
                // Remove specific event listeners from socketDefault and socketAlt
                const events = [
                    'roomRecordParams',
                    'startRecords',
                    'reInitiateRecording',
                    'RecordingNotice',
                    'timeLeftRecording',
                    'stoppedRecording',
                ];
                events.forEach((event) => {
                    socketDefault.off(event);
                    socketAlt.off(event);
                });
            }
            socketAlt.on('roomRecordParams', async ({ recordParams }) => {
                this.roomRecordParams.roomRecordParams({
                    recordParams,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            socketAlt.on('startRecords', async () => {
                await this.startRecords.startRecords({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: socketAlt,
                });
            });
            socketAlt.on('reInitiateRecording', async () => {
                await this.reInitiateRecording.reInitiateRecording({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: socketAlt,
                    adminRestrictSetting: this.adminRestrictSetting.value,
                });
            });
            socketAlt.on('RecordingNotice', async ({ state, userRecordingParam, pauseCount, timeDone }) => {
                await this.recordingNotice.RecordingNotice({
                    state,
                    userRecordingParam,
                    pauseCount,
                    timeDone,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            socketAlt.on('timeLeftRecording', async ({ timeLeft }) => {
                this.timeLeftRecording.timeLeftRecording({
                    timeLeft,
                    showAlert: this.showAlert.bind(this),
                });
            });
            socketAlt.on('stoppedRecording', async ({ state, reason }) => {
                await this.stoppedRecording.stoppedRecording({
                    state,
                    reason,
                    showAlert: this.showAlert.bind(this),
                });
            });
            if (this.localLink !== "" && socketDefault && !skipSockets) {
                await this.join_Room({
                    socket: socketDefault,
                    roomName: this.roomName.value,
                    islevel: this.islevel.value,
                    member: this.member.value,
                    sec: token,
                    apiUserName: apiUserName,
                    isLocal: true,
                });
            }
            // Check if localSocket has changed
            const localChanged = this.localSocket.value && this.localSocket.value.id && this.localSocket.value.id !== socketAlt.id;
            if (!skipSockets && localChanged) {
                // Re-call connect_Socket with skipSockets = true
                await this.connect_Socket(apiUserName, token, true);
                await sleep({ ms: 1000 });
                this.updateIsLoadingModalVisible(false);
                return socketDefault;
            }
            else {
                if (this.link.value !== '' && this.link.value.includes('mediasfu.com')) {
                    // Token might be different for local room
                    const token = this.apiToken.value;
                    await this.join_Room({
                        socket: this.connectMediaSFU && socketAlt && socketAlt.id ? socketAlt : socketDefault,
                        roomName: this.roomName.value,
                        islevel: this.islevel.value,
                        member: this.member.value,
                        sec: token,
                        apiUserName: apiUserName,
                    });
                }
                await this.receiveRoomMessages.receiveRoomMessages({
                    socket: socketDefault,
                    roomName: this.roomName.value,
                    updateMessages: this.updateMessages.bind(this),
                });
                if (!skipSockets) {
                    await this.prepopulateUserMedia.prepopulateUserMedia({
                        name: this.hostLabel.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                return socketDefault;
            }
        }
        else {
            return null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediasfuGeneric, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.Injector }, { token: UpdateMiniCardsGrid }, { token: MixStreams }, { token: DispStreams }, { token: StopShareScreen }, { token: CheckScreenShare }, { token: StartShareScreen }, { token: RequestScreenShare }, { token: ReorderStreams }, { token: PrepopulateUserMedia }, { token: GetVideos }, { token: RePort }, { token: Trigger }, { token: ConsumerResume }, { token: ConnectSendTransport }, { token: ConnectSendTransportAudio }, { token: ConnectSendTransportVideo }, { token: ConnectSendTransportScreen }, { token: ProcessConsumerTransports }, { token: ResumePauseStreams }, { token: Readjust }, { token: CheckGrid }, { token: GetEstimate }, { token: CalculateRowsAndColumns }, { token: AddVideosGrid }, { token: OnScreenChanges }, { token: ChangeVids }, { token: CompareActiveNames }, { token: CompareScreenStates }, { token: CreateSendTransport }, { token: ResumeSendTransportAudio }, { token: ReceiveAllPipedTransports }, { token: DisconnectSendTransportVideo }, { token: DisconnectSendTransportAudio }, { token: DisconnectSendTransportScreen }, { token: GetPipedProducersAlt }, { token: SignalNewConsumerTransport }, { token: ConnectRecvTransport }, { token: ReUpdateInter }, { token: UpdateParticipantAudioDecibels }, { token: CloseAndResize }, { token: AutoAdjust }, { token: SwitchUserVideoAlt }, { token: SwitchUserVideo }, { token: SwitchUserAudio }, { token: GetDomains }, { token: FormatNumber }, { token: ConnectIps }, { token: ConnectLocalIps }, { token: CreateDeviceClient }, { token: HandleCreatePoll }, { token: HandleEndPoll }, { token: HandleVotePoll }, { token: CaptureCanvasStream }, { token: ResumePauseAudioStreams }, { token: ProcessConsumerTransportsAudio }, { token: LaunchMenuModal }, { token: LaunchRecording }, { token: StartRecording }, { token: ConfirmRecording }, { token: LaunchWaiting }, { token: launchCoHost }, { token: LaunchMediaSettings }, { token: LaunchDisplaySettings }, { token: LaunchSettings }, { token: LaunchRequests }, { token: LaunchParticipants }, { token: LaunchMessages }, { token: LaunchConfirmExit }, { token: LaunchPoll }, { token: LaunchBreakoutRooms }, { token: LaunchConfigureWhiteboard }, { token: StartMeetingProgressTimer }, { token: UpdateRecording }, { token: StopRecording }, { token: UserWaiting }, { token: PersonJoined }, { token: AllWaitingRoomMembers }, { token: RoomRecordParams }, { token: BanParticipant }, { token: UpdatedCoHost }, { token: ParticipantRequested }, { token: ScreenProducerId }, { token: UpdateMediaSettings }, { token: ProducerMediaPaused }, { token: ProducerMediaResumed }, { token: ProducerMediaClosed }, { token: ControlMediaHost }, { token: MeetingEnded }, { token: DisconnectUserSelf }, { token: ReceiveMessage }, { token: MeetingTimeRemaining }, { token: MeetingStillThere }, { token: StartRecords }, { token: ReInitiateRecording }, { token: RecordingNotice }, { token: TimeLeftRecording }, { token: StoppedRecording }, { token: HostRequestResponse }, { token: AllMembers }, { token: AllMembersRest }, { token: Disconnect }, { token: PollUpdated }, { token: BreakoutRoomUpdated }, { token: SocketManager }, { token: JoinRoomClient }, { token: JoinLocalRoom }, { token: UpdateRoomParametersClient }, { token: ClickVideo }, { token: ClickAudio }, { token: ClickScreenShare }, { token: SwitchVideoAlt }, { token: StreamSuccessVideo }, { token: StreamSuccessAudio }, { token: StreamSuccessScreen }, { token: StreamSuccessAudioSwitch }, { token: CheckPermission }, { token: UpdateConsumingDomains }, { token: ReceiveRoomMessages }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MediasfuGeneric, isStandalone: true, selector: "app-mediasfu-generic", inputs: { PrejoinPage: "PrejoinPage", localLink: "localLink", connectMediaSFU: "connectMediaSFU", credentials: "credentials", useLocalUIMode: "useLocalUIMode", seedData: "seedData", useSeed: "useSeed", imgSrc: "imgSrc", sourceParameters: "sourceParameters", updateSourceParameters: "updateSourceParameters", returnUI: "returnUI", noUIPreJoinOptions: "noUIPreJoinOptions", joinMediaSFURoom: "joinMediaSFURoom", createMediaSFURoom: "createMediaSFURoom" }, host: { listeners: { "window:resize": "handleResize()", "window:orientationchange": "handleResize()" } }, providers: [CookieService], ngImport: i0, template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component *ngIf="returnUI">
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
                <app-control-buttons-component-touch
                  [buttons]="controlBroadcastButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'broadcast'"
                ></app-control-buttons-component-touch>
                <app-control-buttons-component-touch
                  [buttons]="recordButton"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    !showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>
                <app-control-buttons-component-touch
                  [buttons]="recordButtons"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>
                <app-control-buttons-component-touch
                  [buttons]="controlChatButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'chat'"
                ></app-control-buttons-component-touch>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <ng-container *ngIf="returnUI">
      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
        [localLink]="localLink"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
        [localLink]="localLink"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </ng-container>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: BreakoutRoomsModal, selector: "app-breakout-rooms-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onBreakoutRoomsClose"] }, { kind: "component", type: BackgroundModal, selector: "app-background-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onClose"] }, { kind: "component", type: CoHostModal, selector: "app-co-host-modal", inputs: ["isCoHostModalVisible", "currentCohost", "participants", "coHostResponsibility", "position", "backgroundColor", "roomName", "showAlert", "updateCoHostResponsibility", "updateCoHost", "updateIsCoHostModalVisible", "socket", "onCoHostClose", "onModifyCoHost"] }, { kind: "component", type: AlertComponent, selector: "app-alert-component", inputs: ["visible", "message", "type", "duration", "textColor", "onHide"] }, { kind: "component", type: AudioGrid, selector: "app-audio-grid", inputs: ["componentsToRender"] }, { kind: "component", type: ControlButtonsComponentTouch, selector: "app-control-buttons-component-touch", inputs: ["buttons", "position", "location", "direction", "buttonsContainerStyle", "showAspect"] }, { kind: "component", type: ControlButtonsComponent, selector: "app-control-buttons-component", inputs: ["buttons", "buttonColor", "buttonBackgroundColor", "alignment", "vertical", "buttonsContainerStyle"] }, { kind: "component", type: FlexibleGrid, selector: "app-flexible-grid", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "backgroundColor"] }, { kind: "component", type: FlexibleVideo, selector: "app-flexible-video", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "showAspect", "backgroundColor", "Screenboard", "annotateScreenStream", "localStreamScreen"] }, { kind: "component", type: LoadingModal, selector: "app-loading-modal", inputs: ["isVisible", "backgroundColor", "displayColor"] }, { kind: "component", type: Pagination, selector: "app-pagination", inputs: ["totalPages", "currentUserPage", "handlePageChange", "position", "location", "direction", "buttonsContainerStyle", "activePageStyle", "inactivePageStyle", "backgroundColor", "paginationHeight", "showAspect", "parameters"] }, { kind: "component", type: SubAspectComponent, selector: "app-sub-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFractionSub"] }, { kind: "component", type: DisplaySettingsModal, selector: "app-display-settings-modal", inputs: ["isDisplaySettingsModalVisible", "onDisplaySettingsClose", "onModifyDisplaySettings", "parameters", "position", "backgroundColor"] }, { kind: "component", type: EventSettingsModal, selector: "app-event-settings-modal", inputs: ["isEventSettingsModalVisible", "onEventSettingsClose", "onModifyEventSettings", "position", "backgroundColor", "audioSetting", "videoSetting", "screenshareSetting", "chatSetting", "updateAudioSetting", "updateVideoSetting", "updateScreenshareSetting", "updateChatSetting", "updateIsSettingsModalVisible", "roomName", "socket", "showAlert"] }, { kind: "component", type: ConfirmExitModal, selector: "app-confirm-exit-modal", inputs: ["isConfirmExitModalVisible", "onConfirmExitClose", "position", "backgroundColor", "exitEventOnConfirm", "member", "ban", "roomName", "socket", "islevel"] }, { kind: "component", type: MediaSettingsModal, selector: "app-media-settings-modal", inputs: ["isMediaSettingsModalVisible", "onMediaSettingsClose", "switchCameraOnPress", "switchVideoOnPress", "switchAudioOnPress", "parameters", "position", "backgroundColor"] }, { kind: "component", type: MenuModal, selector: "app-menu-modal", inputs: ["backgroundColor", "isVisible", "customButtons", "shareButtons", "position", "roomName", "adminPasscode", "islevel", "eventType", "localLink", "onClose"] }, { kind: "component", type: MessagesModal, selector: "app-messages-modal", inputs: ["isMessagesModalVisible", "onMessagesClose", "onSendMessagePress", "messages", "position", "backgroundColor", "activeTabBackgroundColor", "eventType", "member", "islevel", "coHostResponsibility", "coHost", "startDirectMessage", "directMessageDetails", "updateStartDirectMessage", "updateDirectMessageDetails", "showAlert", "roomName", "socket", "chatSetting"] }, { kind: "component", type: ConfirmHereModal, selector: "app-confirm-here-modal", inputs: ["isConfirmHereModalVisible", "position", "backgroundColor", "displayColor", "onConfirmHereClose", "countdownDuration", "socket", "localSocket", "roomName", "member"] }, { kind: "component", type: ShareEventModal, selector: "app-share-event-modal", inputs: ["backgroundColor", "isShareEventModalVisible", "onShareEventClose", "roomName", "adminPasscode", "islevel", "position", "shareButtons", "eventType", "localLink"] }, { kind: "component", type: ParticipantsModal, selector: "app-participants-modal", inputs: ["isParticipantsModalVisible", "onParticipantsClose", "onParticipantsFilterChange", "participantsCounter", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "parameters", "position", "backgroundColor"] }, { kind: "component", type: PollModal, selector: "app-poll-modal", inputs: ["isPollModalVisible", "onClose", "position", "backgroundColor", "member", "islevel", "polls", "poll", "socket", "roomName", "showAlert", "updateIsPollModalVisible", "handleCreatePoll", "handleEndPoll", "handleVotePoll"] }, { kind: "component", type: RecordingModal, selector: "app-recording-modal", inputs: ["isRecordingModalVisible", "onClose", "backgroundColor", "position", "confirmRecording", "startRecording", "parameters"] }, { kind: "component", type: RequestsModal, selector: "app-requests-modal", inputs: ["isRequestsModalVisible", "requestCounter", "requestList", "roomName", "socket", "backgroundColor", "position", "parameters", "onRequestClose", "onRequestFilterChange", "onRequestItemPress", "updateRequestList"] }, { kind: "component", type: MainAspectComponent, selector: "app-main-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "updateIsWideScreen", "updateIsMediumScreen", "updateIsSmallScreen"] }, { kind: "component", type: MainContainerComponent, selector: "app-main-container-component", inputs: ["backgroundColor", "containerWidthFraction", "containerHeightFraction", "marginLeft", "marginRight", "marginTop", "marginBottom", "padding"] }, { kind: "component", type: MainGridComponent, selector: "app-main-grid-component", inputs: ["backgroundColor", "mainSize", "height", "width", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: MainScreenComponent, selector: "app-main-screen-component", inputs: ["mainSize", "doStack", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "showControls", "updateComponentSizes"] }, { kind: "component", type: OtherGridComponent, selector: "app-other-grid-component", inputs: ["backgroundColor", "width", "height", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: ScreenboardModal, selector: "app-screenboard-modal", inputs: ["parameters", "isVisible", "onClose", "position", "backgroundColor"] }, { kind: "component", type: Whiteboard, selector: "app-whiteboard", inputs: ["customWidth", "customHeight", "parameters", "showAspect"] }, { kind: "component", type: ConfigureWhiteboardModal, selector: "app-configure-whiteboard-modal", inputs: ["isVisible", "parameters", "backgroundColor", "position", "onConfigureWhiteboardClose"] }, { kind: "component", type: WaitingRoomModal, selector: "app-waiting-room-modal", inputs: ["isWaitingModalVisible", "waitingRoomCounter", "waitingRoomList", "roomName", "socket", "position", "backgroundColor", "parameters", "onWaitingRoomClose", "onWaitingRoomFilterChange", "updateWaitingList", "onWaitingRoomItemPress"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediasfuGeneric, decorators: [{
            type: Component,
            args: [{ selector: 'app-mediasfu-generic', imports: [
                        CommonModule,
                        BreakoutRoomsModal,
                        BackgroundModal,
                        CoHostModal,
                        AlertComponent,
                        AudioGrid,
                        ControlButtonsComponentTouch,
                        ControlButtonsComponent,
                        FlexibleGrid,
                        FlexibleVideo,
                        LoadingModal,
                        Pagination,
                        SubAspectComponent,
                        DisplaySettingsModal,
                        EventSettingsModal,
                        ConfirmExitModal,
                        MediaSettingsModal,
                        MenuModal,
                        MessagesModal,
                        ConfirmHereModal,
                        ShareEventModal,
                        ParticipantsModal,
                        PollModal,
                        RecordingModal,
                        RequestsModal,
                        MainAspectComponent,
                        MainContainerComponent,
                        MainGridComponent,
                        MainScreenComponent,
                        OtherGridComponent,
                        ScreenboardModal,
                        Whiteboard,
                        ConfigureWhiteboardModal,
                        WaitingRoomModal,
                    ], template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component *ngIf="returnUI">
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
                <app-control-buttons-component-touch
                  [buttons]="controlBroadcastButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'broadcast'"
                ></app-control-buttons-component-touch>
                <app-control-buttons-component-touch
                  [buttons]="recordButton"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    !showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>
                <app-control-buttons-component-touch
                  [buttons]="recordButtons"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>
                <app-control-buttons-component-touch
                  [buttons]="controlChatButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'chat'"
                ></app-control-buttons-component-touch>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <ng-container *ngIf="returnUI">
      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
        [localLink]="localLink"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
        [localLink]="localLink"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </ng-container>
    </div>
  `, providers: [CookieService] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: UpdateMiniCardsGrid }, { type: MixStreams }, { type: DispStreams }, { type: StopShareScreen }, { type: CheckScreenShare }, { type: StartShareScreen }, { type: RequestScreenShare }, { type: ReorderStreams }, { type: PrepopulateUserMedia }, { type: GetVideos }, { type: RePort }, { type: Trigger }, { type: ConsumerResume }, { type: ConnectSendTransport }, { type: ConnectSendTransportAudio }, { type: ConnectSendTransportVideo }, { type: ConnectSendTransportScreen }, { type: ProcessConsumerTransports }, { type: ResumePauseStreams }, { type: Readjust }, { type: CheckGrid }, { type: GetEstimate }, { type: CalculateRowsAndColumns }, { type: AddVideosGrid }, { type: OnScreenChanges }, { type: ChangeVids }, { type: CompareActiveNames }, { type: CompareScreenStates }, { type: CreateSendTransport }, { type: ResumeSendTransportAudio }, { type: ReceiveAllPipedTransports }, { type: DisconnectSendTransportVideo }, { type: DisconnectSendTransportAudio }, { type: DisconnectSendTransportScreen }, { type: GetPipedProducersAlt }, { type: SignalNewConsumerTransport }, { type: ConnectRecvTransport }, { type: ReUpdateInter }, { type: UpdateParticipantAudioDecibels }, { type: CloseAndResize }, { type: AutoAdjust }, { type: SwitchUserVideoAlt }, { type: SwitchUserVideo }, { type: SwitchUserAudio }, { type: GetDomains }, { type: FormatNumber }, { type: ConnectIps }, { type: ConnectLocalIps }, { type: CreateDeviceClient }, { type: HandleCreatePoll }, { type: HandleEndPoll }, { type: HandleVotePoll }, { type: CaptureCanvasStream }, { type: ResumePauseAudioStreams }, { type: ProcessConsumerTransportsAudio }, { type: LaunchMenuModal }, { type: LaunchRecording }, { type: StartRecording }, { type: ConfirmRecording }, { type: LaunchWaiting }, { type: launchCoHost }, { type: LaunchMediaSettings }, { type: LaunchDisplaySettings }, { type: LaunchSettings }, { type: LaunchRequests }, { type: LaunchParticipants }, { type: LaunchMessages }, { type: LaunchConfirmExit }, { type: LaunchPoll }, { type: LaunchBreakoutRooms }, { type: LaunchConfigureWhiteboard }, { type: StartMeetingProgressTimer }, { type: UpdateRecording }, { type: StopRecording }, { type: UserWaiting }, { type: PersonJoined }, { type: AllWaitingRoomMembers }, { type: RoomRecordParams }, { type: BanParticipant }, { type: UpdatedCoHost }, { type: ParticipantRequested }, { type: ScreenProducerId }, { type: UpdateMediaSettings }, { type: ProducerMediaPaused }, { type: ProducerMediaResumed }, { type: ProducerMediaClosed }, { type: ControlMediaHost }, { type: MeetingEnded }, { type: DisconnectUserSelf }, { type: ReceiveMessage }, { type: MeetingTimeRemaining }, { type: MeetingStillThere }, { type: StartRecords }, { type: ReInitiateRecording }, { type: RecordingNotice }, { type: TimeLeftRecording }, { type: StoppedRecording }, { type: HostRequestResponse }, { type: AllMembers }, { type: AllMembersRest }, { type: Disconnect }, { type: PollUpdated }, { type: BreakoutRoomUpdated }, { type: SocketManager }, { type: JoinRoomClient }, { type: JoinLocalRoom }, { type: UpdateRoomParametersClient }, { type: ClickVideo }, { type: ClickAudio }, { type: ClickScreenShare }, { type: SwitchVideoAlt }, { type: StreamSuccessVideo }, { type: StreamSuccessAudio }, { type: StreamSuccessScreen }, { type: StreamSuccessAudioSwitch }, { type: CheckPermission }, { type: UpdateConsumingDomains }, { type: ReceiveRoomMessages }], propDecorators: { PrejoinPage: [{
                type: Input
            }], localLink: [{
                type: Input
            }], connectMediaSFU: [{
                type: Input
            }], credentials: [{
                type: Input
            }], useLocalUIMode: [{
                type: Input
            }], seedData: [{
                type: Input
            }], useSeed: [{
                type: Input
            }], imgSrc: [{
                type: Input
            }], sourceParameters: [{
                type: Input
            }], updateSourceParameters: [{
                type: Input
            }], returnUI: [{
                type: Input
            }], noUIPreJoinOptions: [{
                type: Input
            }], joinMediaSFURoom: [{
                type: Input
            }], createMediaSFURoom: [{
                type: Input
            }], handleResize: [{
                type: HostListener,
                args: ['window:resize']
            }, {
                type: HostListener,
                args: ['window:orientationchange']
            }] } });

/**
 * MediasfuBroadcast component provides a streaming broadcast interface with various UI components and settings.
 * It handles conditional rendering of a prejoin page or main broadcast content, along with integrated modals and controls.
 *
 * @component
 * @selector app-mediasfu-broadcast
 * @standalone true
 * @imports [RouterOutlet, CommonModule, AlertComponent, AudioGrid, ControlButtonsComponentTouch, FlexibleVideo, LoadingModal, ConfirmExitModal, MessagesModal, ConfirmHereModal, ShareEventModal, WelcomePage, ParticipantsModal, RecordingModal, MainAspectComponent, MainContainerComponent, MainGridComponent, MainScreenComponent, MessageWidget, MenuRecordWidget, RecordTimerWidget, MenuParticipantsWidget]
 *
 * @template
 * The component's template contains:
 * - Conditional rendering of the PrejoinPage component if the user is not validated.
 * - The main broadcast content, including video, controls, and optional modals.
 * - The `app-main-container-component` manages the main display.
 * - Controls for video and audio grid display and interactive modals (Participants, Messages, Recording, etc.)
 *
 * @input {any} PrejoinPage - Component for the prejoin page, defaults to `WelcomePage`.
 * @input {MediasfuBroadcastOptions} options - Configuration options for the component.
 * @input {boolean} connectMediaSFU - Flag to enable/disable connection to the MediaSFU server.
 * @input {string} localLink - Local link for the Community Edition server.
 * @input {{ apiUserName: string; apiKey: string }} credentials - API credentials for secure access.
 * @input {boolean} useLocalUIMode - Flag to toggle local UI settings.
 * @input {SeedData} seedData - Seed data for initializing the component with specific configurations.
 * @input {boolean} useSeed - Enable/disable use of seed data.
 * @input {string} imgSrc - URL for branding images or logos.
 * @input {object} sourceParameters - Additional parameters for the source.
 * @input {Function} updateSourceParameters - Function to update the source parameters.
 * @input {boolean} returnUI - Flag to return the UI elements.
 * @input {CreateMediaSFURoomOptions | JoinMediaSFURoomOptions} noUIPreJoinOptions - Options for the prejoin page without UI.
 * @input {JoinRoomOnMediaSFUType} joinMediaSFURoom - Function to join a room on MediaSFU.
 * @input {CreateRoomOnMediaSFUType} createMediaSFURoom - Function to create a room on MediaSFU.
 *
 * @property {string} title - The title of the component, defaults to "MediaSFU-Broadcast".
 *
 * @styles
 * Custom styles specific to MediaSFU layout and interactions.
 *
 * @constructor
 * @class MediasfuBroadcast
 * @implements OnInit, OnDestroy
 *
 * @method ngOnInit - Initializes the component, sets up necessary configurations, and event listeners.
 * @method ngOnDestroy - Cleanup on component destruction, including removal of event listeners and active intervals.
 *
 * @example
 * ```html
 * <app-mediasfu-broadcast
 *   [PrejoinPage]="CustomPrejoinComponent"
 *   [localLink]="'https://localhost:3000'"
 *   [connectMediaSFU]="true"
 *   [credentials]="{ apiUserName: 'username', apiKey: 'apikey' }"
 *   [useLocalUIMode]="true"
 *   [seedData]="seedDataObject"
 *   [useSeed]="true"
 *   [imgSrc]="https://example.com/logo.png">
 *   [sourceParameters]="{ source: 'camera', width: 640, height: 480 }"
 *   [updateSourceParameters]="updateSourceParameters"
 *   [returnUI]="true"
 *   [noUIPreJoinOptions]="{ roomName: 'room1', userName: 'user1' }"
 *   [joinMediaSFURoom]="joinMediaSFURoom"
 *   [createMediaSFURoom]="createMediaSFURoom">
 * </app-mediasfu-broadcast>
 * ```
 */
class MediasfuBroadcast {
    cdr;
    injector;
    updateMiniCardsGrid;
    mixStreams;
    dispStreams;
    stopShareScreen;
    checkScreenShare;
    startShareScreen;
    requestScreenShare;
    reorderStreams;
    prepopulateUserMedia;
    getVideos;
    rePort;
    trigger;
    consumerResume;
    connectSendTransport;
    connectSendTransportAudio;
    connectSendTransportVideo;
    connectSendTransportScreen;
    processConsumerTransports;
    resumePauseStreams;
    readjust;
    checkGrid;
    getEstimate;
    calculateRowsAndColumns;
    addVideosGrid;
    onScreenChanges;
    changeVids;
    compareActiveNames;
    compareScreenStates;
    createSendTransport;
    resumeSendTransportAudio;
    receiveAllPipedTransports;
    disconnectSendTransportVideo;
    disconnectSendTransportAudio;
    disconnectSendTransportScreen;
    getPipedProducersAlt;
    signalNewConsumerTransport;
    connectRecvTransport;
    reUpdateInter;
    updateParticipantAudioDecibels;
    closeAndResize;
    autoAdjust;
    switchUserVideoAlt;
    switchUserVideo;
    switchUserAudio;
    getDomains;
    formatNumber;
    connectIps;
    connectLocalIps;
    createDeviceClient;
    captureCanvasStream;
    resumePauseAudioStreams;
    processConsumerTransportsAudio;
    launchRecording;
    startRecording;
    confirmRecording;
    launchParticipants;
    launchMessages;
    launchConfirmExit;
    startMeetingProgressTimer;
    updateRecording;
    stopRecording;
    personJoined;
    roomRecordParams;
    banParticipant;
    producerMediaPaused;
    producerMediaResumed;
    producerMediaClosed;
    meetingEnded;
    disconnectUserSelf;
    receiveMessage;
    meetingTimeRemaining;
    meetingStillThere;
    startRecords;
    reInitiateRecording;
    recordingNotice;
    timeLeftRecording;
    stoppedRecording;
    allMembers;
    allMembersRest;
    disconnect;
    socketManager;
    joinRoomClient;
    joinLocalRoom;
    updateRoomParametersClient;
    clickVideo;
    clickAudio;
    clickScreenShare;
    switchVideoAlt;
    streamSuccessVideo;
    streamSuccessAudio;
    streamSuccessScreen;
    streamSuccessAudioSwitch;
    checkPermission;
    updateConsumingDomains;
    receiveRoomMessages;
    PrejoinPage = WelcomePage;
    localLink = '';
    connectMediaSFU = true;
    credentials = { apiUserName: '', apiKey: '' };
    useLocalUIMode = false;
    seedData;
    useSeed = false;
    imgSrc = 'https://mediasfu.com/images/logo192.png';
    sourceParameters = {};
    updateSourceParameters = (data) => { };
    returnUI = true;
    noUIPreJoinOptions;
    joinMediaSFURoom;
    createMediaSFURoom;
    title = 'MediaSFU-Broadcast';
    mainHeightWidthSubscription;
    validatedSubscription;
    islevelSubscription;
    coHostSubscription;
    buttonSubscriptions = [];
    ScreenboardSubscription;
    recordingSubscription;
    constructor(cdr, injector, updateMiniCardsGrid, mixStreams, dispStreams, stopShareScreen, checkScreenShare, startShareScreen, requestScreenShare, reorderStreams, prepopulateUserMedia, getVideos, rePort, trigger, consumerResume, connectSendTransport, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, processConsumerTransports, resumePauseStreams, readjust, checkGrid, getEstimate, calculateRowsAndColumns, addVideosGrid, onScreenChanges, changeVids, compareActiveNames, compareScreenStates, createSendTransport, resumeSendTransportAudio, receiveAllPipedTransports, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, getPipedProducersAlt, signalNewConsumerTransport, connectRecvTransport, reUpdateInter, updateParticipantAudioDecibels, closeAndResize, autoAdjust, switchUserVideoAlt, switchUserVideo, switchUserAudio, getDomains, formatNumber, connectIps, connectLocalIps, createDeviceClient, captureCanvasStream, resumePauseAudioStreams, processConsumerTransportsAudio, launchRecording, startRecording, confirmRecording, launchParticipants, launchMessages, launchConfirmExit, startMeetingProgressTimer, updateRecording, stopRecording, personJoined, roomRecordParams, banParticipant, producerMediaPaused, producerMediaResumed, producerMediaClosed, meetingEnded, disconnectUserSelf, receiveMessage, meetingTimeRemaining, meetingStillThere, startRecords, reInitiateRecording, recordingNotice, timeLeftRecording, stoppedRecording, allMembers, allMembersRest, disconnect, socketManager, joinRoomClient, joinLocalRoom, updateRoomParametersClient, clickVideo, clickAudio, clickScreenShare, switchVideoAlt, streamSuccessVideo, streamSuccessAudio, streamSuccessScreen, streamSuccessAudioSwitch, checkPermission, updateConsumingDomains, receiveRoomMessages) {
        this.cdr = cdr;
        this.injector = injector;
        this.updateMiniCardsGrid = updateMiniCardsGrid;
        this.mixStreams = mixStreams;
        this.dispStreams = dispStreams;
        this.stopShareScreen = stopShareScreen;
        this.checkScreenShare = checkScreenShare;
        this.startShareScreen = startShareScreen;
        this.requestScreenShare = requestScreenShare;
        this.reorderStreams = reorderStreams;
        this.prepopulateUserMedia = prepopulateUserMedia;
        this.getVideos = getVideos;
        this.rePort = rePort;
        this.trigger = trigger;
        this.consumerResume = consumerResume;
        this.connectSendTransport = connectSendTransport;
        this.connectSendTransportAudio = connectSendTransportAudio;
        this.connectSendTransportVideo = connectSendTransportVideo;
        this.connectSendTransportScreen = connectSendTransportScreen;
        this.processConsumerTransports = processConsumerTransports;
        this.resumePauseStreams = resumePauseStreams;
        this.readjust = readjust;
        this.checkGrid = checkGrid;
        this.getEstimate = getEstimate;
        this.calculateRowsAndColumns = calculateRowsAndColumns;
        this.addVideosGrid = addVideosGrid;
        this.onScreenChanges = onScreenChanges;
        this.changeVids = changeVids;
        this.compareActiveNames = compareActiveNames;
        this.compareScreenStates = compareScreenStates;
        this.createSendTransport = createSendTransport;
        this.resumeSendTransportAudio = resumeSendTransportAudio;
        this.receiveAllPipedTransports = receiveAllPipedTransports;
        this.disconnectSendTransportVideo = disconnectSendTransportVideo;
        this.disconnectSendTransportAudio = disconnectSendTransportAudio;
        this.disconnectSendTransportScreen = disconnectSendTransportScreen;
        this.getPipedProducersAlt = getPipedProducersAlt;
        this.signalNewConsumerTransport = signalNewConsumerTransport;
        this.connectRecvTransport = connectRecvTransport;
        this.reUpdateInter = reUpdateInter;
        this.updateParticipantAudioDecibels = updateParticipantAudioDecibels;
        this.closeAndResize = closeAndResize;
        this.autoAdjust = autoAdjust;
        this.switchUserVideoAlt = switchUserVideoAlt;
        this.switchUserVideo = switchUserVideo;
        this.switchUserAudio = switchUserAudio;
        this.getDomains = getDomains;
        this.formatNumber = formatNumber;
        this.connectIps = connectIps;
        this.connectLocalIps = connectLocalIps;
        this.createDeviceClient = createDeviceClient;
        this.captureCanvasStream = captureCanvasStream;
        this.resumePauseAudioStreams = resumePauseAudioStreams;
        this.processConsumerTransportsAudio = processConsumerTransportsAudio;
        this.launchRecording = launchRecording;
        this.startRecording = startRecording;
        this.confirmRecording = confirmRecording;
        this.launchParticipants = launchParticipants;
        this.launchMessages = launchMessages;
        this.launchConfirmExit = launchConfirmExit;
        this.startMeetingProgressTimer = startMeetingProgressTimer;
        this.updateRecording = updateRecording;
        this.stopRecording = stopRecording;
        this.personJoined = personJoined;
        this.roomRecordParams = roomRecordParams;
        this.banParticipant = banParticipant;
        this.producerMediaPaused = producerMediaPaused;
        this.producerMediaResumed = producerMediaResumed;
        this.producerMediaClosed = producerMediaClosed;
        this.meetingEnded = meetingEnded;
        this.disconnectUserSelf = disconnectUserSelf;
        this.receiveMessage = receiveMessage;
        this.meetingTimeRemaining = meetingTimeRemaining;
        this.meetingStillThere = meetingStillThere;
        this.startRecords = startRecords;
        this.reInitiateRecording = reInitiateRecording;
        this.recordingNotice = recordingNotice;
        this.timeLeftRecording = timeLeftRecording;
        this.stoppedRecording = stoppedRecording;
        this.allMembers = allMembers;
        this.allMembersRest = allMembersRest;
        this.disconnect = disconnect;
        this.socketManager = socketManager;
        this.joinRoomClient = joinRoomClient;
        this.joinLocalRoom = joinLocalRoom;
        this.updateRoomParametersClient = updateRoomParametersClient;
        this.clickVideo = clickVideo;
        this.clickAudio = clickAudio;
        this.clickScreenShare = clickScreenShare;
        this.switchVideoAlt = switchVideoAlt;
        this.streamSuccessVideo = streamSuccessVideo;
        this.streamSuccessAudio = streamSuccessAudio;
        this.streamSuccessScreen = streamSuccessScreen;
        this.streamSuccessAudioSwitch = streamSuccessAudioSwitch;
        this.checkPermission = checkPermission;
        this.updateConsumingDomains = updateConsumingDomains;
        this.receiveRoomMessages = receiveRoomMessages;
    }
    createInjector(inputs) {
        const inj = Injector.create({
            providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
            parent: this.injector,
        });
        return inj;
    }
    // Initial values
    mediaSFUFunctions = () => {
        return {
            updateMiniCardsGrid: this.updateMiniCardsGrid?.updateMiniCardsGrid ||
                (() => {
                    console.log('none');
                }),
            mixStreams: this.mixStreams?.mixStreams ||
                (() => {
                    console.log('none');
                }),
            dispStreams: this.dispStreams?.dispStreams ||
                (() => {
                    console.log('none');
                }),
            stopShareScreen: this.stopShareScreen?.stopShareScreen ||
                (() => {
                    console.log('none');
                }),
            checkScreenShare: this.checkScreenShare?.checkScreenShare ||
                (() => {
                    console.log('none');
                }),
            startShareScreen: this.startShareScreen?.startShareScreen ||
                (() => {
                    console.log('none');
                }),
            requestScreenShare: this.requestScreenShare?.requestScreenShare ||
                (() => {
                    console.log('none');
                }),
            reorderStreams: this.reorderStreams?.reorderStreams ||
                (() => {
                    console.log('none');
                }),
            prepopulateUserMedia: this.prepopulateUserMedia?.prepopulateUserMedia ||
                (() => {
                    console.log('none');
                }),
            getVideos: this.getVideos?.getVideos ||
                (() => {
                    console.log('none');
                }),
            rePort: this.rePort?.rePort ||
                (() => {
                    console.log('none');
                }),
            trigger: this.trigger?.trigger ||
                (() => {
                    console.log('none');
                }),
            consumerResume: this.consumerResume?.consumerResume ||
                (() => {
                    console.log('none');
                }),
            connectSendTransport: this.connectSendTransport?.connectSendTransport ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportAudio: this.connectSendTransportAudio?.connectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportVideo: this.connectSendTransportVideo?.connectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportScreen: this.connectSendTransportScreen?.connectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransports: this.processConsumerTransports?.processConsumerTransports ||
                (() => {
                    console.log('none');
                }),
            resumePauseStreams: this.resumePauseStreams?.resumePauseStreams ||
                (() => {
                    console.log('none');
                }),
            readjust: this.readjust?.readjust ||
                (() => {
                    console.log('none');
                }),
            checkGrid: this.checkGrid?.checkGrid ||
                (() => {
                    console.log('none');
                }),
            getEstimate: this.getEstimate?.getEstimate ||
                (() => {
                    console.log('none');
                }),
            calculateRowsAndColumns: this.calculateRowsAndColumns?.calculateRowsAndColumns ||
                (() => {
                    console.log('none');
                }),
            addVideosGrid: this.addVideosGrid?.addVideosGrid ||
                (() => {
                    console.log('none');
                }),
            onScreenChanges: this.onScreenChanges?.onScreenChanges ||
                (() => {
                    console.log('none');
                }),
            sleep: sleep ||
                (() => {
                    console.log('none');
                }),
            changeVids: this.changeVids?.changeVids ||
                (() => {
                    console.log('none');
                }),
            compareActiveNames: this.compareActiveNames?.compareActiveNames ||
                (() => {
                    console.log('none');
                }),
            compareScreenStates: this.compareScreenStates?.compareScreenStates ||
                (() => {
                    console.log('none');
                }),
            createSendTransport: this.createSendTransport?.createSendTransport ||
                (() => {
                    console.log('none');
                }),
            resumeSendTransportAudio: this.resumeSendTransportAudio?.resumeSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            receiveAllPipedTransports: this.receiveAllPipedTransports?.receiveAllPipedTransports ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportVideo: this.disconnectSendTransportVideo?.disconnectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportAudio: this.disconnectSendTransportAudio?.disconnectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportScreen: this.disconnectSendTransportScreen?.disconnectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            getPipedProducersAlt: this.getPipedProducersAlt?.getPipedProducersAlt ||
                (() => {
                    console.log('none');
                }),
            signalNewConsumerTransport: this.signalNewConsumerTransport?.signalNewConsumerTransport ||
                (() => {
                    console.log('none');
                }),
            connectRecvTransport: this.connectRecvTransport?.connectRecvTransport ||
                (() => {
                    console.log('none');
                }),
            reUpdateInter: this.reUpdateInter?.reUpdateInter ||
                (() => {
                    console.log('none');
                }),
            updateParticipantAudioDecibels: this.updateParticipantAudioDecibels?.updateParticipantAudioDecibels ||
                (() => {
                    console.log('none');
                }),
            closeAndResize: this.closeAndResize?.closeAndResize ||
                (() => {
                    console.log('none');
                }),
            autoAdjust: this.autoAdjust?.autoAdjust ||
                (() => {
                    console.log('none');
                }),
            switchUserVideoAlt: this.switchUserVideoAlt?.switchUserVideoAlt ||
                (() => {
                    console.log('none');
                }),
            switchUserVideo: this.switchUserVideo?.switchUserVideo ||
                (() => {
                    console.log('none');
                }),
            switchUserAudio: this.switchUserAudio?.switchUserAudio ||
                (() => {
                    console.log('none');
                }),
            getDomains: this.getDomains?.getDomains ||
                (() => {
                    console.log('none');
                }),
            formatNumber: this.formatNumber?.formatNumber ||
                (() => {
                    console.log('none');
                }),
            connectIps: this.connectIps?.connectIps ||
                (() => {
                    console.log('none');
                }),
            connectLocalIps: this.connectLocalIps?.connectLocalIps ||
                (() => {
                    console.log('none');
                }),
            createDeviceClient: this.createDeviceClient?.createDeviceClient ||
                (() => {
                    console.log('none');
                }),
            captureCanvasStream: this.captureCanvasStream?.captureCanvasStream ||
                (() => {
                    console.log('none');
                }),
            resumePauseAudioStreams: this.resumePauseAudioStreams?.resumePauseAudioStreams ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransportsAudio: this.processConsumerTransportsAudio?.processConsumerTransportsAudio ||
                (() => {
                    console.log('none');
                }),
            checkPermission: this.checkPermission?.checkPermission ||
                (() => {
                    console.log('none');
                }),
            streamSuccessVideo: this.streamSuccessVideo?.streamSuccessVideo ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudio: this.streamSuccessAudio?.streamSuccessAudio ||
                (() => {
                    console.log('none');
                }),
            streamSuccessScreen: this.streamSuccessScreen?.streamSuccessScreen ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudioSwitch: this.streamSuccessAudioSwitch?.streamSuccessAudioSwitch ||
                (() => {
                    console.log('none');
                }),
            clickVideo: this.clickVideo?.clickVideo ||
                (() => {
                    console.log('none');
                }),
            clickAudio: this.clickAudio?.clickAudio ||
                (() => {
                    console.log('none');
                }),
            clickScreenShare: this.clickScreenShare?.clickScreenShare ||
                (() => {
                    console.log('none');
                }),
            switchVideoAlt: this.switchVideoAlt?.switchVideoAlt ||
                (() => {
                    console.log('none');
                }),
            requestPermissionCamera: this.requestPermissionCamera ||
                (() => {
                    console.log('none');
                }),
            requestPermissionAudio: this.requestPermissionAudio ||
                (() => {
                    console.log('none');
                }),
        };
    };
    validated = new BehaviorSubject$1(false);
    localUIMode = new BehaviorSubject$1(false);
    socket = new BehaviorSubject$1({});
    localSocket = new BehaviorSubject$1(undefined);
    roomData = new BehaviorSubject$1(null);
    device = new BehaviorSubject$1(null);
    apiKey = new BehaviorSubject$1('');
    apiUserName = new BehaviorSubject$1('');
    apiToken = new BehaviorSubject$1('');
    link = new BehaviorSubject$1('');
    roomName = new BehaviorSubject$1('');
    member = new BehaviorSubject$1('');
    adminPasscode = new BehaviorSubject$1('');
    islevel = new BehaviorSubject$1('1');
    coHost = new BehaviorSubject$1('No coHost');
    coHostResponsibility = new BehaviorSubject$1([
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ]);
    youAreCoHost = new BehaviorSubject$1(false);
    youAreHost = new BehaviorSubject$1(false);
    confirmedToRecord = new BehaviorSubject$1(false);
    meetingDisplayType = new BehaviorSubject$1('media');
    meetingVideoOptimized = new BehaviorSubject$1(false);
    eventType = new BehaviorSubject$1('broadcast');
    participants = new BehaviorSubject$1([]);
    filteredParticipants = new BehaviorSubject$1([]);
    participantsCounter = new BehaviorSubject$1(0);
    participantsFilter = new BehaviorSubject$1('');
    consume_sockets = new BehaviorSubject$1([]);
    rtpCapabilities = new BehaviorSubject$1(null);
    roomRecvIPs = new BehaviorSubject$1([]);
    meetingRoomParams = new BehaviorSubject$1(null);
    itemPageLimit = new BehaviorSubject$1(4);
    audioOnlyRoom = new BehaviorSubject$1(false);
    addForBasic = new BehaviorSubject$1(false);
    screenPageLimit = new BehaviorSubject$1(4);
    shareScreenStarted = new BehaviorSubject$1(false);
    shared = new BehaviorSubject$1(false);
    targetOrientation = new BehaviorSubject$1('landscape');
    targetResolution = new BehaviorSubject$1('sd');
    targetResolutionHost = new BehaviorSubject$1('sd');
    vidCons = new BehaviorSubject$1({ width: 640, height: 360 });
    frameRate = new BehaviorSubject$1(10);
    hParams = new BehaviorSubject$1({});
    vParams = new BehaviorSubject$1({});
    screenParams = new BehaviorSubject$1({});
    aParams = new BehaviorSubject$1({});
    recordingAudioPausesLimit = new BehaviorSubject$1(0);
    recordingAudioPausesCount = new BehaviorSubject$1(0);
    recordingAudioSupport = new BehaviorSubject$1(false);
    recordingAudioPeopleLimit = new BehaviorSubject$1(0);
    recordingAudioParticipantsTimeLimit = new BehaviorSubject$1(0);
    recordingVideoPausesCount = new BehaviorSubject$1(0);
    recordingVideoPausesLimit = new BehaviorSubject$1(0);
    recordingVideoSupport = new BehaviorSubject$1(false);
    recordingVideoPeopleLimit = new BehaviorSubject$1(0);
    recordingVideoParticipantsTimeLimit = new BehaviorSubject$1(0);
    recordingAllParticipantsSupport = new BehaviorSubject$1(false);
    recordingVideoParticipantsSupport = new BehaviorSubject$1(false);
    recordingAllParticipantsFullRoomSupport = new BehaviorSubject$1(false);
    recordingVideoParticipantsFullRoomSupport = new BehaviorSubject$1(false);
    recordingPreferredOrientation = new BehaviorSubject$1('landscape');
    recordingSupportForOtherOrientation = new BehaviorSubject$1(false);
    recordingMultiFormatsSupport = new BehaviorSubject$1(false);
    userRecordingParams = new BehaviorSubject$1({
        mainSpecs: {
            mediaOptions: 'video', // 'audio', 'video'
            audioOptions: 'all', // 'all', 'onScreen', 'host'
            videoOptions: 'all', // 'all', 'mainScreen'
            videoType: 'fullDisplay', // 'all', 'bestDisplay', 'fullDisplay'
            videoOptimized: false, // true, false
            recordingDisplayType: 'media', // 'media', 'video', 'all'
            addHLS: false, // true, false
        },
        dispSpecs: {
            nameTags: true, // true, false
            backgroundColor: '#000000', // '#000000', '#ffffff'
            nameTagsColor: '#ffffff', // '#000000', '#ffffff'
            orientationVideo: 'portrait', // 'landscape', 'portrait', 'all'
        },
    });
    canRecord = new BehaviorSubject$1(false);
    startReport = new BehaviorSubject$1(false);
    endReport = new BehaviorSubject$1(false);
    recordTimerInterval = new BehaviorSubject$1(null);
    recordStartTime = new BehaviorSubject$1(0);
    recordElapsedTime = new BehaviorSubject$1(0);
    isTimerRunning = new BehaviorSubject$1(false);
    canPauseResume = new BehaviorSubject$1(false);
    recordChangeSeconds = new BehaviorSubject$1(15000);
    pauseLimit = new BehaviorSubject$1(0);
    pauseRecordCount = new BehaviorSubject$1(0);
    canLaunchRecord = new BehaviorSubject$1(true);
    stopLaunchRecord = new BehaviorSubject$1(false);
    participantsAll = new BehaviorSubject$1([]);
    firstAll = new BehaviorSubject$1(false);
    updateMainWindow = new BehaviorSubject$1(false);
    first_round = new BehaviorSubject$1(false);
    landScaped = new BehaviorSubject$1(false);
    lock_screen = new BehaviorSubject$1(false);
    screenId = new BehaviorSubject$1('');
    allVideoStreams = new BehaviorSubject$1([]);
    newLimitedStreams = new BehaviorSubject$1([]);
    newLimitedStreamsIDs = new BehaviorSubject$1([]);
    activeSounds = new BehaviorSubject$1([]);
    screenShareIDStream = new BehaviorSubject$1('');
    screenShareNameStream = new BehaviorSubject$1('');
    adminIDStream = new BehaviorSubject$1('');
    adminNameStream = new BehaviorSubject$1('');
    youYouStream = new BehaviorSubject$1([]);
    youYouStreamIDs = new BehaviorSubject$1([]);
    localStream = new BehaviorSubject$1(null);
    recordStarted = new BehaviorSubject$1(false);
    recordResumed = new BehaviorSubject$1(false);
    recordPaused = new BehaviorSubject$1(false);
    recordStopped = new BehaviorSubject$1(false);
    adminRestrictSetting = new BehaviorSubject$1(false);
    videoRequestState = new BehaviorSubject$1(null);
    videoRequestTime = new BehaviorSubject$1(0);
    videoAction = new BehaviorSubject$1(false);
    localStreamVideo = new BehaviorSubject$1(null);
    userDefaultVideoInputDevice = new BehaviorSubject$1('');
    currentFacingMode = new BehaviorSubject$1('user');
    prevFacingMode = new BehaviorSubject$1('user');
    defVideoID = new BehaviorSubject$1('');
    allowed = new BehaviorSubject$1(false);
    dispActiveNames = new BehaviorSubject$1([]);
    p_dispActiveNames = new BehaviorSubject$1([]);
    activeNames = new BehaviorSubject$1([]);
    prevActiveNames = new BehaviorSubject$1([]);
    p_activeNames = new BehaviorSubject$1([]);
    membersReceived = new BehaviorSubject$1(false);
    deferScreenReceived = new BehaviorSubject$1(false);
    hostFirstSwitch = new BehaviorSubject$1(false);
    micAction = new BehaviorSubject$1(false);
    screenAction = new BehaviorSubject$1(false);
    chatAction = new BehaviorSubject$1(false);
    audioRequestState = new BehaviorSubject$1(null);
    screenRequestState = new BehaviorSubject$1(null);
    chatRequestState = new BehaviorSubject$1(null);
    audioRequestTime = new BehaviorSubject$1(0);
    screenRequestTime = new BehaviorSubject$1(0);
    chatRequestTime = new BehaviorSubject$1(0);
    updateRequestIntervalSeconds = new BehaviorSubject$1(240);
    oldSoundIds = new BehaviorSubject$1([]);
    hostLabel = new BehaviorSubject$1('Host');
    mainScreenFilled = new BehaviorSubject$1(false);
    localStreamScreen = new BehaviorSubject$1(null);
    screenAlreadyOn = new BehaviorSubject$1(false);
    chatAlreadyOn = new BehaviorSubject$1(false);
    redirectURL = new BehaviorSubject$1('');
    oldAllStreams = new BehaviorSubject$1([]);
    adminVidID = new BehaviorSubject$1('');
    streamNames = new BehaviorSubject$1([]);
    non_alVideoStreams = new BehaviorSubject$1([]);
    sortAudioLoudness = new BehaviorSubject$1(false);
    audioDecibels = new BehaviorSubject$1([]);
    mixed_alVideoStreams = new BehaviorSubject$1([]);
    non_alVideoStreams_muted = new BehaviorSubject$1([]);
    paginatedStreams = new BehaviorSubject$1([]);
    localStreamAudio = new BehaviorSubject$1(null);
    defAudioID = new BehaviorSubject$1('');
    userDefaultAudioInputDevice = new BehaviorSubject$1('');
    userDefaultAudioOutputDevice = new BehaviorSubject$1('');
    prevAudioInputDevice = new BehaviorSubject$1('');
    prevVideoInputDevice = new BehaviorSubject$1('');
    audioPaused = new BehaviorSubject$1(false);
    mainScreenPerson = new BehaviorSubject$1('');
    adminOnMainScreen = new BehaviorSubject$1(false);
    screenStates = new BehaviorSubject$1([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    prevScreenStates = new BehaviorSubject$1([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    updateDateState = new BehaviorSubject$1(null);
    lastUpdate = new BehaviorSubject$1(null);
    nForReadjustRecord = new BehaviorSubject$1(0);
    fixedPageLimit = new BehaviorSubject$1(4);
    removeAltGrid = new BehaviorSubject$1(false);
    nForReadjust = new BehaviorSubject$1(0);
    reorderInterval = new BehaviorSubject$1(30000);
    fastReorderInterval = new BehaviorSubject$1(10000);
    lastReorderTime = new BehaviorSubject$1(0);
    audStreamNames = new BehaviorSubject$1([]);
    currentUserPage = new BehaviorSubject$1(0);
    mainHeightWidth = new BehaviorSubject$1(100);
    prevMainHeightWidth = new BehaviorSubject$1(this.mainHeightWidth.value);
    prevDoPaginate = new BehaviorSubject$1(false);
    doPaginate = new BehaviorSubject$1(false);
    shareEnded = new BehaviorSubject$1(false);
    lStreams = new BehaviorSubject$1([]);
    chatRefStreams = new BehaviorSubject$1([]);
    controlHeight = new BehaviorSubject$1(this.eventType.value === 'webinar' || this.eventType.value === 'conference' ? 0 : 0.06);
    isWideScreen = new BehaviorSubject$1(false);
    isMediumScreen = new BehaviorSubject$1(false);
    isSmallScreen = new BehaviorSubject$1(false);
    addGrid = new BehaviorSubject$1(false);
    addAltGrid = new BehaviorSubject$1(false);
    gridRows = new BehaviorSubject$1(0);
    gridCols = new BehaviorSubject$1(0);
    altGridRows = new BehaviorSubject$1(0);
    altGridCols = new BehaviorSubject$1(0);
    numberPages = new BehaviorSubject$1(0);
    currentStreams = new BehaviorSubject$1([]);
    showMiniView = new BehaviorSubject$1(false);
    nStream = new BehaviorSubject$1(null);
    defer_receive = new BehaviorSubject$1(false);
    allAudioStreams = new BehaviorSubject$1([]);
    remoteScreenStream = new BehaviorSubject$1([]);
    screenProducer = new BehaviorSubject$1(null);
    localScreenProducer = new BehaviorSubject$1(null);
    gotAllVids = new BehaviorSubject$1(false);
    paginationHeightWidth = new BehaviorSubject$1(40);
    paginationDirection = new BehaviorSubject$1('horizontal');
    gridSizes = new BehaviorSubject$1({
        gridWidth: 0,
        gridHeight: 0,
        altGridWidth: 0,
        altGridHeight: 0,
    });
    screenForceFullDisplay = new BehaviorSubject$1(false);
    mainGridStream = new BehaviorSubject$1([]);
    otherGridStreams = new BehaviorSubject$1([]);
    audioOnlyStreams = new BehaviorSubject$1([]);
    videoInputs = new BehaviorSubject$1([]);
    audioInputs = new BehaviorSubject$1([]);
    meetingProgressTime = new BehaviorSubject$1('00:00:00');
    meetingElapsedTime = new BehaviorSubject$1(0);
    ref_participants = new BehaviorSubject$1([]);
    updateValidated = (value) => {
        this.validated.next(value);
    };
    updateSocket = (value) => {
        this.socket.next(value);
    };
    updateLocalSocket = (value) => {
        this.localSocket.next(value);
    };
    updateDevice = (value) => {
        this.device.next(value);
    };
    updateRoomData = (value) => {
        this.roomData.next(value);
    };
    updateApiKey = (value) => {
        this.apiKey.next(value);
    };
    updateApiUserName = (value) => {
        this.apiUserName.next(value);
    };
    updateApiToken = (value) => {
        this.apiToken.next(value);
    };
    updateLink = (value) => {
        this.link.next(value);
    };
    updateRoomName = (value) => {
        this.roomName.next(value);
        if (value.length > 0 && value.includes("_")) {
            this.updateIslevel(value.split("_")[1]);
            value = value.split("_")[0];
        }
    };
    updateMember = (value) => {
        this.member.next(value);
    };
    updateAdminPasscode = (value) => {
        this.adminPasscode.next(value);
    };
    updateIslevel = (value) => {
        this.islevel.next(value);
    };
    updateCoHost = (value) => {
        this.coHost.next(value);
    };
    updateCoHostResponsibility = (value) => {
        this.coHostResponsibility.next(value);
    };
    updateYouAreCoHost = (value) => {
        this.youAreCoHost.next(value);
    };
    updateYouAreHost = (value) => {
        this.youAreHost.next(value);
    };
    updateConfirmedToRecord = (value) => {
        this.confirmedToRecord.next(value);
    };
    updateMeetingDisplayType = (value) => {
        this.meetingDisplayType.next(value);
    };
    updateMeetingVideoOptimized = (value) => {
        this.meetingVideoOptimized.next(value);
    };
    updateEventType = (value) => {
        this.eventType.next(value);
    };
    updateParticipants = (value) => {
        this.participants.next(value);
        this.participantsCounter.next(value.length);
        this.filteredParticipants.next(this.participants.value);
    };
    updateFilteredParticipants = (value) => {
        this.filteredParticipants.next(value);
    };
    updateParticipantsCounter = (value) => {
        this.participantsCounter.next(value);
    };
    updateParticipantsFilter = (value) => {
        this.participantsFilter.next(value);
    };
    updateConsume_sockets = (value) => {
        this.consume_sockets.next(value);
    };
    updateRtpCapabilities = (value) => {
        this.rtpCapabilities.next(value);
    };
    updateRoomRecvIPs = (value) => {
        this.roomRecvIPs.next(value);
    };
    updateMeetingRoomParams = (value) => {
        this.meetingRoomParams.next(value);
    };
    updateItemPageLimit = (value) => {
        this.itemPageLimit.next(value);
    };
    updateAudioOnlyRoom = (value) => {
        this.audioOnlyRoom.next(value);
    };
    updateAddForBasic = (value) => {
        this.addForBasic.next(value);
    };
    updateScreenPageLimit = (value) => {
        this.screenPageLimit.next(value);
    };
    updateShareScreenStarted = (value) => {
        this.shareScreenStarted.next(value);
    };
    updateShared = (value) => {
        this.shared.next(value);
        this.screenShareActive.next(value);
        if (value) {
            setTimeout(async () => {
                window.dispatchEvent(new Event('resize'));
            }, 2000);
        }
    };
    updateTargetOrientation = (value) => {
        this.targetOrientation.next(value);
    };
    updateTargetResolution = (value) => {
        this.targetResolution.next(value);
    };
    updateTargetResolutionHost = (value) => {
        this.targetResolutionHost.next(value);
    };
    updateVidCons = (value) => {
        this.vidCons.next(value);
    };
    updateFrameRate = (value) => {
        this.frameRate.next(value);
    };
    updateHParams = (value) => {
        this.hParams.next(value);
    };
    updateVParams = (value) => {
        this.vParams.next(value);
    };
    updateScreenParams = (value) => {
        this.screenParams.next(value);
    };
    updateAParams = (value) => {
        this.aParams.next(value);
    };
    updateRecordingAudioPausesLimit = (value) => {
        this.recordingAudioPausesLimit.next(value);
    };
    updateRecordingAudioPausesCount = (value) => {
        this.recordingAudioPausesCount.next(value);
    };
    updateRecordingAudioSupport = (value) => {
        this.recordingAudioSupport.next(value);
    };
    updateRecordingAudioPeopleLimit = (value) => {
        this.recordingAudioPeopleLimit.next(value);
    };
    updateRecordingAudioParticipantsTimeLimit = (value) => {
        this.recordingAudioParticipantsTimeLimit.next(value);
    };
    updateRecordingVideoPausesCount = (value) => {
        this.recordingVideoPausesCount.next(value);
    };
    updateRecordingVideoPausesLimit = (value) => {
        this.recordingVideoPausesLimit.next(value);
    };
    updateRecordingVideoSupport = (value) => {
        this.recordingVideoSupport.next(value);
    };
    updateRecordingVideoPeopleLimit = (value) => {
        this.recordingVideoPeopleLimit.next(value);
    };
    updateRecordingVideoParticipantsTimeLimit = (value) => {
        this.recordingVideoParticipantsTimeLimit.next(value);
    };
    updateRecordingAllParticipantsSupport = (value) => {
        this.recordingAllParticipantsSupport.next(value);
    };
    updateRecordingVideoParticipantsSupport = (value) => {
        this.recordingVideoParticipantsSupport.next(value);
    };
    updateRecordingAllParticipantsFullRoomSupport = (value) => {
        this.recordingAllParticipantsFullRoomSupport.next(value);
    };
    updateRecordingVideoParticipantsFullRoomSupport = (value) => {
        this.recordingVideoParticipantsFullRoomSupport.next(value);
    };
    updateRecordingPreferredOrientation = (value) => {
        this.recordingPreferredOrientation.next(value);
    };
    updateRecordingSupportForOtherOrientation = (value) => {
        this.recordingSupportForOtherOrientation.next(value);
    };
    updateRecordingMultiFormatsSupport = (value) => {
        this.recordingMultiFormatsSupport.next(value);
    };
    updateUserRecordingParams = (value) => {
        this.userRecordingParams.next(value);
    };
    updateCanRecord = (value) => {
        this.canRecord.next(value);
    };
    updateStartReport = (value) => {
        this.startReport.next(value);
    };
    updateEndReport = (value) => {
        this.endReport.next(value);
    };
    updateRecordTimerInterval = (value) => {
        this.recordTimerInterval.next(value);
    };
    updateRecordStartTime = (value) => {
        this.recordStartTime.next(value);
    };
    updateRecordElapsedTime = (value) => {
        this.recordElapsedTime.next(value);
    };
    updateIsTimerRunning = (value) => {
        this.isTimerRunning.next(value);
    };
    updateCanPauseResume = (value) => {
        this.canPauseResume.next(value);
    };
    updateRecordChangeSeconds = (value) => {
        this.recordChangeSeconds.next(value);
    };
    updatePauseLimit = (value) => {
        this.pauseLimit.next(value);
    };
    updatePauseRecordCount = (value) => {
        this.pauseRecordCount.next(value);
    };
    updateCanLaunchRecord = (value) => {
        this.canLaunchRecord.next(value);
    };
    updateStopLaunchRecord = (value) => {
        this.stopLaunchRecord.next(value);
    };
    updateParticipantsAll = (value) => {
        this.participantsAll.next(value);
    };
    updateFirstAll = (value) => {
        this.firstAll.next(value);
    };
    updateUpdateMainWindow = (value) => {
        this.updateMainWindow.next(value);
    };
    updateFirst_round = (value) => {
        this.first_round.next(value);
    };
    updateLandScaped = (value) => {
        this.landScaped.next(value);
    };
    updateLock_screen = (value) => {
        this.lock_screen.next(value);
    };
    updateScreenId = (value) => {
        this.screenId.next(value);
    };
    updateAllVideoStreams = (value) => {
        this.allVideoStreams.next(value);
    };
    updateNewLimitedStreams = (value) => {
        this.newLimitedStreams.next(value);
    };
    updateNewLimitedStreamsIDs = (value) => {
        this.newLimitedStreamsIDs.next(value);
    };
    updateActiveSounds = (value) => {
        this.activeSounds.next(value);
    };
    updateScreenShareIDStream = (value) => {
        this.screenShareIDStream.next(value);
    };
    updateScreenShareNameStream = (value) => {
        this.screenShareNameStream.next(value);
    };
    updateAdminIDStream = (value) => {
        this.adminIDStream.next(value);
    };
    updateAdminNameStream = (value) => {
        this.adminNameStream.next(value);
    };
    updateYouYouStream = (value) => {
        this.youYouStream.next(value);
    };
    updateYouYouStreamIDs = (value) => {
        this.youYouStreamIDs.next(value);
    };
    updateLocalStream = (value) => {
        this.localStream.next(value);
    };
    updateRecordStarted = (value) => {
        this.recordStarted.next(value);
    };
    updateRecordResumed = (value) => {
        this.recordResumed.next(value);
    };
    updateRecordPaused = (value) => {
        this.recordPaused.next(value);
    };
    updateRecordStopped = (value) => {
        this.recordStopped.next(value);
    };
    updateAdminRestrictSetting = (value) => {
        this.adminRestrictSetting.next(value);
    };
    updateVideoRequestState = (value) => {
        this.videoRequestState.next(value);
    };
    updateVideoRequestTime = (value) => {
        this.videoRequestTime.next(value);
    };
    updateVideoAction = (value) => {
        this.videoAction.next(value);
    };
    updateLocalStreamVideo = (value) => {
        this.localStreamVideo.next(value);
    };
    updateUserDefaultVideoInputDevice = (value) => {
        this.userDefaultVideoInputDevice.next(value);
    };
    updateCurrentFacingMode = (value) => {
        this.currentFacingMode.next(value);
    };
    updatePrevFacingMode = (value) => {
        this.prevFacingMode.next(value);
    };
    updateDefVideoID = (value) => {
        this.defVideoID.next(value);
    };
    updateAllowed = (value) => {
        this.allowed.next(value);
    };
    updateDispActiveNames = (value) => {
        this.dispActiveNames.next(value);
    };
    updateP_dispActiveNames = (value) => {
        this.p_dispActiveNames.next(value);
    };
    updateActiveNames = (value) => {
        this.activeNames.next(value);
    };
    updatePrevActiveNames = (value) => {
        this.prevActiveNames.next(value);
    };
    updateP_activeNames = (value) => {
        this.p_activeNames.next(value);
    };
    updateMembersReceived = (value) => {
        this.membersReceived.next(value);
    };
    updateDeferScreenReceived = (value) => {
        this.deferScreenReceived.next(value);
    };
    updateHostFirstSwitch = (value) => {
        this.hostFirstSwitch.next(value);
    };
    updateMicAction = (value) => {
        this.micAction.next(value);
    };
    updateScreenAction = (value) => {
        this.screenAction.next(value);
    };
    updateChatAction = (value) => {
        this.chatAction.next(value);
    };
    updateAudioRequestState = (value) => {
        this.audioRequestState.next(value);
    };
    updateScreenRequestState = (value) => {
        this.screenRequestState.next(value);
    };
    updateChatRequestState = (value) => {
        this.chatRequestState.next(value);
    };
    updateAudioRequestTime = (value) => {
        this.audioRequestTime.next(value);
    };
    updateScreenRequestTime = (value) => {
        this.screenRequestTime.next(value);
    };
    updateChatRequestTime = (value) => {
        this.chatRequestTime.next(value);
    };
    updateOldSoundIds = (value) => {
        this.oldSoundIds.next(value);
    };
    updateHostLabel = (value) => {
        this.hostLabel.next(value);
    };
    updateMainScreenFilled = (value) => {
        this.mainScreenFilled.next(value);
    };
    updateLocalStreamScreen = (value) => {
        this.localStreamScreen.next(value);
    };
    updateScreenAlreadyOn = (value) => {
        this.screenAlreadyOn.next(value);
    };
    updateChatAlreadyOn = (value) => {
        this.chatAlreadyOn.next(value);
    };
    updateRedirectURL = (value) => {
        this.redirectURL.next(value);
    };
    updateOldAllStreams = (value) => {
        this.oldAllStreams.next(value);
    };
    updateAdminVidID = (value) => {
        this.adminVidID.next(value);
    };
    updateStreamNames = (value) => {
        this.streamNames.next(value);
    };
    updateNon_alVideoStreams = (value) => {
        this.non_alVideoStreams.next(value);
    };
    updateSortAudioLoudness = (value) => {
        this.sortAudioLoudness.next(value);
    };
    updateAudioDecibels = (value) => {
        this.audioDecibels.next(value);
    };
    updateMixed_alVideoStreams = (value) => {
        this.mixed_alVideoStreams.next(value);
    };
    updateNon_alVideoStreams_muted = (value) => {
        this.non_alVideoStreams_muted.next(value);
    };
    updatePaginatedStreams = (value) => {
        this.paginatedStreams.next(value);
    };
    updateLocalStreamAudio = (value) => {
        this.localStreamAudio.next(value);
    };
    updateDefAudioID = (value) => {
        this.defAudioID.next(value);
    };
    updateUserDefaultAudioInputDevice = (value) => {
        this.userDefaultAudioInputDevice.next(value);
    };
    updateUserDefaultAudioOutputDevice = (value) => {
        this.userDefaultAudioOutputDevice.next(value);
    };
    updatePrevAudioInputDevice = (value) => {
        this.prevAudioInputDevice.next(value);
    };
    updatePrevVideoInputDevice = (value) => {
        this.prevVideoInputDevice.next(value);
    };
    updateAudioPaused = (value) => {
        this.audioPaused.next(value);
    };
    updateMainScreenPerson = (value) => {
        this.mainScreenPerson.next(value);
    };
    updateAdminOnMainScreen = (value) => {
        this.adminOnMainScreen.next(value);
    };
    updateScreenStates = (value) => {
        this.screenStates.next(value);
    };
    updatePrevScreenStates = (value) => {
        this.prevScreenStates.next(value);
    };
    updateUpdateDateState = (value) => {
        this.updateDateState.next(value);
    };
    updateLastUpdate = (value) => {
        this.lastUpdate.next(value);
    };
    updateNForReadjustRecord = (value) => {
        this.nForReadjustRecord.next(value);
    };
    updateFixedPageLimit = (value) => {
        this.fixedPageLimit.next(value);
    };
    updateRemoveAltGrid = (value) => {
        this.removeAltGrid.next(value);
    };
    updateNForReadjust = (value) => {
        this.nForReadjust.next(value);
    };
    updateLastReorderTime = (value) => {
        this.lastReorderTime.next(value);
    };
    updateAudStreamNames = (value) => {
        this.audStreamNames.next(value);
    };
    updateCurrentUserPage = (value) => {
        this.currentUserPage.next(value);
    };
    updateMainHeightWidth = (value) => {
        this.mainHeightWidth.next(value);
    };
    updatePrevMainHeightWidth = (value) => {
        this.prevMainHeightWidth.next(value);
    };
    updatePrevDoPaginate = (value) => {
        this.prevDoPaginate.next(value);
    };
    updateDoPaginate = (value) => {
        this.doPaginate.next(value);
    };
    updateShareEnded = (value) => {
        this.shareEnded.next(value);
    };
    updateLStreams = (value) => {
        this.lStreams.next(value);
    };
    updateChatRefStreams = (value) => {
        this.chatRefStreams.next(value);
    };
    updateControlHeight = (value) => {
        this.controlHeight.next(value);
    };
    updateIsWideScreen = (value) => {
        this.isWideScreen.next(value);
    };
    updateIsMediumScreen = (value) => {
        this.isMediumScreen.next(value);
    };
    updateIsSmallScreen = (value) => {
        this.isSmallScreen.next(value);
    };
    updateAddGrid = (value) => {
        this.addGrid.next(value);
    };
    updateAddAltGrid = (value) => {
        this.addAltGrid.next(value);
    };
    updateGridRows = (value) => {
        this.gridRows.next(value);
    };
    updateGridCols = (value) => {
        this.gridCols.next(value);
    };
    updateAltGridRows = (value) => {
        this.altGridRows.next(value);
    };
    updateAltGridCols = (value) => {
        this.altGridCols.next(value);
    };
    updateNumberPages = (value) => {
        this.numberPages.next(value);
    };
    updateCurrentStreams = (value) => {
        this.currentStreams.next(value);
    };
    updateShowMiniView = (value) => {
        this.showMiniView.next(value);
    };
    updateNStream = (value) => {
        this.nStream.next(value);
    };
    updateDefer_receive = (value) => {
        this.defer_receive.next(value);
    };
    updateAllAudioStreams = (value) => {
        this.allAudioStreams.next(value);
    };
    updateRemoteScreenStream = (value) => {
        this.remoteScreenStream.next(value);
    };
    updateScreenProducer = (value) => {
        this.screenProducer.next(value);
    };
    updateLocalScreenProducer = (value) => {
        this.localScreenProducer.next(value);
    };
    updateGotAllVids = (value) => {
        this.gotAllVids.next(value);
    };
    updatePaginationHeightWidth = (value) => {
        this.paginationHeightWidth.next(value);
    };
    updatePaginationDirection = (value) => {
        this.paginationDirection.next(value);
    };
    updateGridSizes = (value) => {
        this.gridSizes.next(value);
    };
    updateScreenForceFullDisplay = (value) => {
        this.screenForceFullDisplay.next(value);
    };
    updateMainGridStream = (value) => {
        this.mainGridStream.next(value);
    };
    updateOtherGridStreams = (value) => {
        this.otherGridStreams.next(value);
    };
    updateAudioOnlyStreams = (value) => {
        this.audioOnlyStreams.next(value);
    };
    updateVideoInputs = (value) => {
        this.videoInputs.next(value);
    };
    updateAudioInputs = (value) => {
        this.audioInputs.next(value);
    };
    updateMeetingProgressTime = (value) => {
        this.meetingProgressTime.next(value);
    };
    updateMeetingElapsedTime = (value) => {
        this.meetingElapsedTime.next(value);
    };
    updateRef_participants = (value) => {
        this.ref_participants.next(value);
    };
    // Messages
    messages = new BehaviorSubject$1([]);
    startDirectMessage = new BehaviorSubject$1(false);
    directMessageDetails = new BehaviorSubject$1(null);
    showMessagesBadge = new BehaviorSubject$1(false);
    // Event Settings
    audioSetting = new BehaviorSubject$1('allow');
    videoSetting = new BehaviorSubject$1('allow');
    screenshareSetting = new BehaviorSubject$1('allow');
    chatSetting = new BehaviorSubject$1('allow');
    // Display Settings
    displayOption = new BehaviorSubject$1('media');
    autoWave = new BehaviorSubject$1(true);
    forceFullDisplay = new BehaviorSubject$1(true);
    prevForceFullDisplay = new BehaviorSubject$1(false);
    prevMeetingDisplayType = new BehaviorSubject$1('video');
    // Waiting Room
    waitingRoomFilter = new BehaviorSubject$1('');
    waitingRoomList = new BehaviorSubject$1([]);
    waitingRoomCounter = new BehaviorSubject$1(0);
    filteredWaitingRoomList = new BehaviorSubject$1([]);
    // Requests
    requestFilter = new BehaviorSubject$1('');
    requestList = new BehaviorSubject$1([]);
    requestCounter = new BehaviorSubject$1(0);
    filteredRequestList = new BehaviorSubject$1([]);
    // Total Requests and Waiting Room
    totalReqWait = new BehaviorSubject$1(0);
    // Alerts
    alertVisible = new BehaviorSubject$1(false);
    alertMessage = new BehaviorSubject$1('');
    alertType = new BehaviorSubject$1('success');
    alertDuration = new BehaviorSubject$1(3000);
    // Progress Timer
    progressTimerVisible = new BehaviorSubject$1(true);
    progressTimerValue = new BehaviorSubject$1(0);
    // Menu Modals
    isMenuModalVisible = new BehaviorSubject$1(false);
    isRecordingModalVisible = new BehaviorSubject$1(false);
    isSettingsModalVisible = new BehaviorSubject$1(false);
    isRequestsModalVisible = new BehaviorSubject$1(false);
    isWaitingModalVisible = new BehaviorSubject$1(false);
    isCoHostModalVisible = new BehaviorSubject$1(false);
    isMediaSettingsModalVisible = new BehaviorSubject$1(false);
    isDisplaySettingsModalVisible = new BehaviorSubject$1(false);
    // Other Modals
    isParticipantsModalVisible = new BehaviorSubject$1(false);
    isMessagesModalVisible = new BehaviorSubject$1(false);
    isConfirmExitModalVisible = new BehaviorSubject$1(false);
    isConfirmHereModalVisible = new BehaviorSubject$1(false);
    isShareEventModalVisible = new BehaviorSubject$1(false);
    isLoadingModalVisible = new BehaviorSubject$1(false);
    // Recording Options
    recordingMediaOptions = new BehaviorSubject$1('video');
    recordingAudioOptions = new BehaviorSubject$1('all');
    recordingVideoOptions = new BehaviorSubject$1('all');
    recordingVideoType = new BehaviorSubject$1('fullDisplay');
    recordingVideoOptimized = new BehaviorSubject$1(false);
    recordingDisplayType = new BehaviorSubject$1('video');
    recordingAddHLS = new BehaviorSubject$1(true);
    recordingNameTags = new BehaviorSubject$1(true);
    recordingBackgroundColor = new BehaviorSubject$1('#83c0e9');
    recordingNameTagsColor = new BehaviorSubject$1('#ffffff');
    recordingAddText = new BehaviorSubject$1(false);
    recordingCustomText = new BehaviorSubject$1('Add Text');
    recordingCustomTextPosition = new BehaviorSubject$1('top');
    recordingCustomTextColor = new BehaviorSubject$1('#ffffff');
    recordingOrientationVideo = new BehaviorSubject$1('landscape');
    clearedToResume = new BehaviorSubject$1(true);
    clearedToRecord = new BehaviorSubject$1(true);
    recordState = new BehaviorSubject$1('green');
    showRecordButtons = new BehaviorSubject$1(false);
    recordingProgressTime = new BehaviorSubject$1('00:00:00');
    audioSwitching = new BehaviorSubject$1(false);
    videoSwitching = new BehaviorSubject$1(false);
    // Media States
    videoAlreadyOn = new BehaviorSubject$1(false);
    audioAlreadyOn = new BehaviorSubject$1(false);
    componentSizes = new BehaviorSubject$1({
        mainHeight: 0,
        otherHeight: 0,
        mainWidth: 0,
        otherWidth: 0,
    });
    // Permissions
    hasCameraPermission = new BehaviorSubject$1(false);
    hasAudioPermission = new BehaviorSubject$1(false);
    // Transports
    transportCreated = new BehaviorSubject$1(false);
    localTransportCreated = new BehaviorSubject$1(false);
    transportCreatedVideo = new BehaviorSubject$1(false);
    transportCreatedAudio = new BehaviorSubject$1(false);
    transportCreatedScreen = new BehaviorSubject$1(false);
    producerTransport = new BehaviorSubject$1(null);
    localProducerTransport = new BehaviorSubject$1(null);
    videoProducer = new BehaviorSubject$1(null);
    localVideoProducer = new BehaviorSubject$1(null);
    params = new BehaviorSubject$1({});
    videoParams = new BehaviorSubject$1({});
    audioParams = new BehaviorSubject$1({});
    audioProducer = new BehaviorSubject$1(null);
    audioLevel = new BehaviorSubject$1(0);
    localAudioProducer = new BehaviorSubject$1(null);
    consumerTransports = new BehaviorSubject$1([]);
    consumingTransports = new BehaviorSubject$1([]);
    // Polls
    polls = new BehaviorSubject$1([]);
    poll = new BehaviorSubject$1(null);
    isPollModalVisible = new BehaviorSubject$1(false);
    // Background
    customImage = new BehaviorSubject$1('');
    selectedImage = new BehaviorSubject$1('');
    segmentVideo = new BehaviorSubject$1(null);
    selfieSegmentation = new BehaviorSubject$1(null);
    pauseSegmentation = new BehaviorSubject$1(false);
    processedStream = new BehaviorSubject$1(null);
    keepBackground = new BehaviorSubject$1(false);
    backgroundHasChanged = new BehaviorSubject$1(false);
    virtualStream = new BehaviorSubject$1(null);
    mainCanvas = new BehaviorSubject$1(null);
    prevKeepBackground = new BehaviorSubject$1(false);
    appliedBackground = new BehaviorSubject$1(false);
    isBackgroundModalVisible = new BehaviorSubject$1(false);
    autoClickBackground = new BehaviorSubject$1(false);
    // Breakout Rooms
    breakoutRooms = new BehaviorSubject$1([]);
    currentRoomIndex = new BehaviorSubject$1(0);
    canStartBreakout = new BehaviorSubject$1(false);
    breakOutRoomStarted = new BehaviorSubject$1(false);
    breakOutRoomEnded = new BehaviorSubject$1(false);
    hostNewRoom = new BehaviorSubject$1(-1);
    limitedBreakRoom = new BehaviorSubject$1([]);
    mainRoomsLength = new BehaviorSubject$1(0);
    memberRoom = new BehaviorSubject$1(-1);
    isBreakoutRoomsModalVisible = new BehaviorSubject$1(false);
    // Whiteboard
    whiteboardUsers = new BehaviorSubject$1([]);
    currentWhiteboardIndex = new BehaviorSubject$1(0);
    canStartWhiteboard = new BehaviorSubject$1(false);
    whiteboardStarted = new BehaviorSubject$1(false);
    whiteboardEnded = new BehaviorSubject$1(false);
    whiteboardLimit = new BehaviorSubject$1(4);
    isWhiteboardModalVisible = new BehaviorSubject$1(false);
    isConfigureWhiteboardModalVisible = new BehaviorSubject$1(false);
    shapes = new BehaviorSubject$1([]);
    useImageBackground = new BehaviorSubject$1(true);
    redoStack = new BehaviorSubject$1([]);
    undoStack = new BehaviorSubject$1([]);
    canvasStream = new BehaviorSubject$1(null);
    canvasWhiteboard = new BehaviorSubject$1(null);
    // Screenboard
    canvasScreenboard = new BehaviorSubject$1(null);
    processedScreenStream = new BehaviorSubject$1(null);
    annotateScreenStream = new BehaviorSubject$1(false);
    mainScreenCanvas = new BehaviorSubject$1(null);
    isScreenboardModalVisible = new BehaviorSubject$1(false);
    //state variables for the control buttons
    micActive = new BehaviorSubject$1(this.audioAlreadyOn.value ? this.audioAlreadyOn.value : false);
    videoActive = new BehaviorSubject$1(this.videoAlreadyOn.value ? this.videoAlreadyOn.value : false);
    screenShareActive = new BehaviorSubject$1(false);
    endCallActive = new BehaviorSubject$1(false);
    participantsActive = new BehaviorSubject$1(false);
    menuActive = new BehaviorSubject$1(false);
    commentsActive = new BehaviorSubject$1(false);
    // Update functions
    updateMessages = (value) => {
        this.messages.next(value);
    };
    updateStartDirectMessage = (value) => {
        this.startDirectMessage.next(value);
    };
    updateDirectMessageDetails = (value) => {
        this.directMessageDetails.next(value);
    };
    updateShowMessagesBadge = (value) => {
        this.showMessagesBadge.next(value);
    };
    updateAudioSetting = (value) => {
        this.audioSetting.next(value);
    };
    updateVideoSetting = (value) => {
        this.videoSetting.next(value);
    };
    updateScreenshareSetting = (value) => {
        this.screenshareSetting.next(value);
    };
    updateChatSetting = (value) => {
        this.chatSetting.next(value);
    };
    updateDisplayOption = (value) => {
        this.displayOption.next(value);
    };
    updateAutoWave = (value) => {
        this.autoWave.next(value);
    };
    updateForceFullDisplay = (value) => {
        this.forceFullDisplay.next(value);
    };
    updatePrevForceFullDisplay = (value) => {
        this.prevForceFullDisplay.next(value);
    };
    updatePrevMeetingDisplayType = (value) => {
        this.prevMeetingDisplayType.next(value);
    };
    updateWaitingRoomCounter = (value) => {
        this.waitingRoomCounter.next(value);
    };
    updateWaitingRoomFilter = (value) => {
        this.waitingRoomFilter.next(value);
    };
    updateWaitingRoomList = (value) => {
        this.waitingRoomList.next(value);
        this.filteredWaitingRoomList.next(value);
        this.waitingRoomCounter.next(value.length);
    };
    onWaitingRoomClose = () => {
        this.updateIsWaitingModalVisible(false);
    };
    updateRequestCounter = (value) => {
        this.requestCounter.next(value);
    };
    updateRequestFilter = (value) => {
        this.requestFilter.next(value);
    };
    updateRequestList = (value) => {
        this.requestList.next(value);
        this.filteredRequestList.next(value);
        this.requestCounter.next(value.length);
    };
    onRequestClose = () => {
        this.updateIsRequestsModalVisible(false);
    };
    updateTotalReqWait = (value) => {
        this.totalReqWait.next(value);
    };
    updateAlertVisible = (value) => {
        this.alertVisible.next(value);
    };
    updateAlertMessage = (value) => {
        this.alertMessage.next(value);
    };
    updateAlertType = (value) => {
        this.alertType.next(value);
    };
    updateAlertDuration = (value) => {
        this.alertDuration.next(value);
    };
    updateProgressTimerVisible = (value) => {
        this.progressTimerVisible.next(value);
    };
    updateProgressTimerValue = (value) => {
        this.progressTimerValue.next(value);
    };
    updateIsMenuModalVisible = (value) => {
        this.isMenuModalVisible.next(value);
    };
    updateIsRecordingModalVisible = (value) => {
        this.isRecordingModalVisible.next(value);
        if (value) {
            this.updateConfirmedToRecord(false);
        }
        else {
            if (this.clearedToRecord.getValue() &&
                this.clearedToResume.getValue() &&
                this.recordStarted.getValue()) {
                this.updateShowRecordButtons(true);
            }
        }
    };
    updateIsSettingsModalVisible = (value) => {
        this.isSettingsModalVisible.next(value);
    };
    updateIsRequestsModalVisible = (value) => {
        this.isRequestsModalVisible.next(value);
    };
    updateIsWaitingModalVisible = (value) => {
        this.isWaitingModalVisible.next(value);
    };
    updateIsCoHostModalVisible = (value) => {
        this.isCoHostModalVisible.next(value);
    };
    updateIsMediaSettingsModalVisible = (value) => {
        this.isMediaSettingsModalVisible.next(value);
    };
    updateIsDisplaySettingsModalVisible = (value) => {
        this.isDisplaySettingsModalVisible.next(value);
    };
    updateIsParticipantsModalVisible = (value) => {
        this.isParticipantsModalVisible.next(value);
    };
    updateIsMessagesModalVisible = (value) => {
        this.isMessagesModalVisible.next(value);
        if (!value) {
            this.updateShowMessagesBadge(false);
        }
    };
    updateIsConfirmExitModalVisible = (value) => {
        this.isConfirmExitModalVisible.next(value);
    };
    updateIsConfirmHereModalVisible = (value) => {
        this.isConfirmHereModalVisible.next(value);
    };
    updateIsLoadingModalVisible = (value) => {
        this.isLoadingModalVisible.next(value);
    };
    updateIsShareEventModalVisible = (value) => {
        this.isShareEventModalVisible.next(value);
    };
    updateRecordingMediaOptions = (value) => {
        this.recordingMediaOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAudioOptions = (value) => {
        this.recordingAudioOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptions = (value) => {
        this.recordingVideoOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoType = (value) => {
        this.recordingVideoType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptimized = (value) => {
        this.recordingVideoOptimized.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingDisplayType = (value) => {
        this.recordingDisplayType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddHLS = (value) => {
        this.recordingAddHLS.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddText = (value) => {
        this.recordingAddText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomText = (value) => {
        this.recordingCustomText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextPosition = (value) => {
        this.recordingCustomTextPosition.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextColor = (value) => {
        this.recordingCustomTextColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTags = (value) => {
        this.recordingNameTags.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingBackgroundColor = (value) => {
        this.recordingBackgroundColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTagsColor = (value) => {
        this.recordingNameTagsColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingOrientationVideo = (value) => {
        this.recordingOrientationVideo.next(value);
        this.clearedToRecord.next(false);
    };
    updateClearedToResume = (value) => {
        this.clearedToResume.next(value);
    };
    updateClearedToRecord = (value) => {
        this.clearedToRecord.next(value);
    };
    updateRecordState = (value) => {
        if (this.recordStarted.value && !this.recordStopped.value) {
            if (!this.recordPaused.value) {
                this.recordState.next('red');
            }
            else {
                this.recordState.next('yellow');
            }
        }
        else {
            this.recordState.next(value);
        }
        this.recordState.next(value);
    };
    updateShowRecordButtons = (value) => {
        this.showRecordButtons.next(value);
    };
    updateRecordingProgressTime = (value) => {
        this.recordingProgressTime.next(value);
        this.updateRecordTimerWidget();
    };
    updateAudioSwitching = (value) => {
        this.audioSwitching.next(value);
    };
    updateVideoSwitching = (value) => {
        this.videoSwitching.next(value);
    };
    updateVideoAlreadyOn = (value) => {
        this.videoAlreadyOn.next(value);
        this.videoActive.next(value);
    };
    updateAudioAlreadyOn = (value) => {
        this.audioAlreadyOn.next(value);
        this.micActive.next(value);
    };
    updateComponentSizes = (sizes) => {
        this.componentSizes.next(sizes);
    };
    updateHasCameraPermission = (value) => {
        this.hasCameraPermission.next(value);
    };
    updateHasAudioPermission = (value) => {
        this.hasAudioPermission.next(value);
    };
    requestPermissionCamera() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    requestPermissionAudio() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    updateTransportCreated = (value) => {
        this.transportCreated.next(value);
    };
    updateLocalTransportCreated = (value) => {
        this.localTransportCreated.next(value);
    };
    updateTransportCreatedVideo = (value) => {
        this.transportCreatedVideo.next(value);
    };
    updateTransportCreatedAudio = (value) => {
        this.transportCreatedAudio.next(value);
    };
    updateTransportCreatedScreen = (value) => {
        this.transportCreatedScreen.next(value);
    };
    updateProducerTransport = (value) => {
        this.producerTransport.next(value);
    };
    updateLocalProducerTransport = (value) => {
        this.localProducerTransport.next(value);
    };
    updateVideoProducer = (value) => {
        this.videoProducer.next(value);
    };
    updateLocalVideoProducer = (value) => {
        this.localVideoProducer.next(value);
    };
    updateParams = (value) => {
        this.params.next(value);
    };
    updateVideoParams = (value) => {
        this.videoParams.next(value);
    };
    updateAudioParams = (value) => {
        this.audioParams.next(value);
    };
    updateAudioProducer = (value) => {
        this.audioProducer.next(value);
    };
    updateAudioLevel = (value) => {
        this.audioLevel.next(value);
    };
    updateLocalAudioProducer = (value) => {
        this.localAudioProducer.next(value);
    };
    updateConsumerTransports = (value) => {
        this.consumerTransports.next(value);
    };
    updateConsumingTransports = (value) => {
        this.consumingTransports.next(value);
    };
    updatePolls = (value) => {
        this.polls.next(value);
    };
    updatePoll = (value) => {
        this.poll.next(value);
    };
    updateIsPollModalVisible = (value) => {
        this.isPollModalVisible.next(value);
    };
    updateCustomImage = (value) => {
        this.customImage.next(value);
    };
    updateSelectedImage = (value) => {
        this.selectedImage.next(value);
    };
    updateSegmentVideo = (value) => {
        this.segmentVideo.next(value);
    };
    updateSelfieSegmentation = (value) => {
        this.selfieSegmentation.next(value);
    };
    updatePauseSegmentation = (value) => {
        this.pauseSegmentation.next(value);
    };
    updateProcessedStream = (value) => {
        this.processedStream.next(value);
    };
    updateKeepBackground = (value) => {
        this.keepBackground.next(value);
    };
    updateBackgroundHasChanged = (value) => {
        this.backgroundHasChanged.next(value);
    };
    updateVirtualStream = (value) => {
        this.virtualStream.next(value);
    };
    updateMainCanvas = (value) => {
        this.mainCanvas.next(value);
    };
    updatePrevKeepBackground = (value) => {
        this.prevKeepBackground.next(value);
    };
    updateAppliedBackground = (value) => {
        this.appliedBackground.next(value);
    };
    updateIsBackgroundModalVisible = (value) => {
        this.isBackgroundModalVisible.next(value);
    };
    updateAutoClickBackground = (value) => {
        this.autoClickBackground.next(value);
    };
    updateBreakoutRooms = (value) => {
        this.breakoutRooms.next(value);
    };
    updateCurrentRoomIndex = (value) => {
        this.currentRoomIndex.next(value);
    };
    updateCanStartBreakout = (value) => {
        this.canStartBreakout.next(value);
    };
    updateBreakOutRoomStarted = (value) => {
        this.breakOutRoomStarted.next(value);
    };
    updateBreakOutRoomEnded = (value) => {
        this.breakOutRoomEnded.next(value);
    };
    updateHostNewRoom = (value) => {
        this.hostNewRoom.next(value);
    };
    updateLimitedBreakRoom = (value) => {
        this.limitedBreakRoom.next(value);
    };
    updateMainRoomsLength = (value) => {
        this.mainRoomsLength.next(value);
    };
    updateMemberRoom = (value) => {
        this.memberRoom.next(value);
    };
    updateIsBreakoutRoomsModalVisible = (value) => {
        this.isBreakoutRoomsModalVisible.next(value);
    };
    updateWhiteboardUsers = (value) => {
        this.whiteboardUsers.next(value);
    };
    updateCurrentWhiteboardIndex = (value) => {
        this.currentWhiteboardIndex.next(value);
    };
    updateCanStartWhiteboard = (value) => {
        this.canStartWhiteboard.next(value);
    };
    updateWhiteboardStarted = (value) => {
        this.whiteboardStarted.next(value);
    };
    updateWhiteboardEnded = (value) => {
        this.whiteboardEnded.next(value);
    };
    updateWhiteboardLimit = (value) => {
        this.whiteboardLimit.next(value);
    };
    updateIsWhiteboardModalVisible = (value) => {
        this.isWhiteboardModalVisible.next(value);
    };
    updateIsConfigureWhiteboardModalVisible = (value) => {
        this.isConfigureWhiteboardModalVisible.next(value);
    };
    updateShapes = (value) => {
        this.shapes.next(value);
    };
    updateUseImageBackground = (value) => {
        this.useImageBackground.next(value);
    };
    updateRedoStack = (value) => {
        this.redoStack.next(value);
    };
    updateUndoStack = (value) => {
        this.undoStack.next(value);
    };
    updateCanvasStream = (value) => {
        this.canvasStream.next(value);
    };
    updateCanvasWhiteboard = (value) => {
        this.canvasWhiteboard.next(value);
    };
    updateCanvasScreenboard = (value) => {
        this.canvasScreenboard.next(value);
    };
    updateProcessedScreenStream = (value) => {
        this.processedScreenStream.next(value);
    };
    updateAnnotateScreenStream = (value) => {
        this.annotateScreenStream.next(value);
    };
    updateMainScreenCanvas = (value) => {
        this.mainScreenCanvas.next(value);
    };
    updateIsScreenboardModalVisible = (value) => {
        this.isScreenboardModalVisible.next(value);
    };
    checkOrientation = () => {
        const isPortrait = window.matchMedia('(orientation: portrait)').matches;
        return isPortrait ? 'portrait' : 'landscape';
    };
    showAlert = ({ message, type, duration = 3000, }) => {
        this.updateAlertMessage(message);
        this.updateAlertType(type);
        this.updateAlertDuration(duration);
        this.updateAlertVisible(true);
    };
    getAllParams() {
        return {
            localUIMode: this.localUIMode.value, // Local UI mode
            // Room Details
            roomName: this.roomName.value,
            member: this.member.value,
            adminPasscode: this.adminPasscode.value,
            youAreCoHost: this.youAreCoHost.value,
            youAreHost: this.youAreHost.value,
            islevel: this.islevel.value,
            confirmedToRecord: this.confirmedToRecord.value,
            meetingDisplayType: this.meetingDisplayType.value,
            meetingVideoOptimized: this.meetingVideoOptimized.value,
            eventType: this.eventType.value,
            participants: this.participants.value,
            filteredParticipants: this.filteredParticipants.value,
            participantsCounter: this.participantsCounter.value,
            participantsFilter: this.participantsFilter.value,
            // More room details - media
            consume_sockets: this.consume_sockets.value,
            rtpCapabilities: this.rtpCapabilities.value,
            roomRecvIPs: this.roomRecvIPs.value,
            meetingRoomParams: this.meetingRoomParams.value,
            itemPageLimit: this.itemPageLimit.value,
            audioOnlyRoom: this.audioOnlyRoom.value,
            addForBasic: this.addForBasic.value,
            screenPageLimit: this.screenPageLimit.value,
            shareScreenStarted: this.shareScreenStarted.value,
            shared: this.shared.value,
            targetOrientation: this.targetOrientation.value,
            targetResolution: this.targetResolution.value,
            targetResolutionHost: this.targetResolutionHost.value,
            vidCons: this.vidCons.value,
            frameRate: this.frameRate.value,
            hParams: this.hParams.value,
            vParams: this.vParams.value,
            screenParams: this.screenParams.value,
            aParams: this.aParams.value,
            // More room details - recording
            recordingAudioPausesLimit: this.recordingAudioPausesLimit.value,
            recordingAudioPausesCount: this.recordingAudioPausesCount.value,
            recordingAudioSupport: this.recordingAudioSupport.value,
            recordingAudioPeopleLimit: this.recordingAudioPeopleLimit.value,
            recordingAudioParticipantsTimeLimit: this.recordingAudioParticipantsTimeLimit.value,
            recordingVideoPausesCount: this.recordingVideoPausesCount.value,
            recordingVideoPausesLimit: this.recordingVideoPausesLimit.value,
            recordingVideoSupport: this.recordingVideoSupport.value,
            recordingVideoPeopleLimit: this.recordingVideoPeopleLimit.value,
            recordingVideoParticipantsTimeLimit: this.recordingVideoParticipantsTimeLimit.value,
            recordingAllParticipantsSupport: this.recordingAllParticipantsSupport.value,
            recordingVideoParticipantsSupport: this.recordingVideoParticipantsSupport.value,
            recordingAllParticipantsFullRoomSupport: this.recordingAllParticipantsFullRoomSupport.value,
            recordingVideoParticipantsFullRoomSupport: this.recordingVideoParticipantsFullRoomSupport.value,
            recordingPreferredOrientation: this.recordingPreferredOrientation.value,
            recordingSupportForOtherOrientation: this.recordingSupportForOtherOrientation.value,
            recordingMultiFormatsSupport: this.recordingMultiFormatsSupport.value,
            userRecordingParams: this.userRecordingParams.value,
            canRecord: this.canRecord.value,
            startReport: this.startReport.value,
            endReport: this.endReport.value,
            recordStartTime: this.recordStartTime.value,
            recordElapsedTime: this.recordElapsedTime.value,
            isTimerRunning: this.isTimerRunning.value,
            canPauseResume: this.canPauseResume.value,
            recordChangeSeconds: this.recordChangeSeconds.value,
            pauseLimit: this.pauseLimit.value,
            pauseRecordCount: this.pauseRecordCount.value,
            canLaunchRecord: this.canLaunchRecord.value,
            stopLaunchRecord: this.stopLaunchRecord.value,
            participantsAll: this.participantsAll.value,
            firstAll: this.firstAll.value,
            updateMainWindow: this.updateMainWindow.value,
            first_round: this.first_round.value,
            landScaped: this.landScaped.value,
            lock_screen: this.lock_screen.value,
            screenId: this.screenId.value,
            allVideoStreams: this.allVideoStreams.value,
            newLimitedStreams: this.newLimitedStreams.value,
            newLimitedStreamsIDs: this.newLimitedStreamsIDs.value,
            activeSounds: this.activeSounds.value,
            screenShareIDStream: this.screenShareIDStream.value,
            screenShareNameStream: this.screenShareNameStream.value,
            adminIDStream: this.adminIDStream.value,
            adminNameStream: this.adminNameStream.value,
            youYouStream: this.youYouStream.value,
            youYouStreamIDs: this.youYouStreamIDs.value,
            localStream: this.localStream.value,
            recordStarted: this.recordStarted.value,
            recordResumed: this.recordResumed.value,
            recordPaused: this.recordPaused.value,
            recordStopped: this.recordStopped.value,
            adminRestrictSetting: this.adminRestrictSetting.value,
            videoRequestState: this.videoRequestState.value,
            videoRequestTime: this.videoRequestTime.value,
            videoAction: this.videoAction.value,
            localStreamVideo: this.localStreamVideo.value,
            userDefaultVideoInputDevice: this.userDefaultVideoInputDevice.value,
            currentFacingMode: this.currentFacingMode.value,
            prevFacingMode: this.prevFacingMode.value,
            defVideoID: this.defVideoID.value,
            allowed: this.allowed.value,
            dispActiveNames: this.dispActiveNames.value,
            p_dispActiveNames: this.p_dispActiveNames.value,
            activeNames: this.activeNames.value,
            prevActiveNames: this.prevActiveNames.value,
            p_activeNames: this.p_activeNames.value,
            membersReceived: this.membersReceived.value,
            deferScreenReceived: this.deferScreenReceived.value,
            hostFirstSwitch: this.hostFirstSwitch.value,
            micAction: this.micAction.value,
            screenAction: this.screenAction.value,
            chatAction: this.chatAction.value,
            audioRequestState: this.audioRequestState.value,
            screenRequestState: this.screenRequestState.value,
            chatRequestState: this.chatRequestState.value,
            audioRequestTime: this.audioRequestTime.value,
            screenRequestTime: this.screenRequestTime.value,
            chatRequestTime: this.chatRequestTime.value,
            updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
            oldSoundIds: this.oldSoundIds.value,
            hostLabel: this.hostLabel.value,
            mainScreenFilled: this.mainScreenFilled.value,
            localStreamScreen: this.localStreamScreen.value,
            screenAlreadyOn: this.screenAlreadyOn.value,
            chatAlreadyOn: this.chatAlreadyOn.value,
            redirectURL: this.redirectURL.value,
            oldAllStreams: this.oldAllStreams.value,
            adminVidID: this.adminVidID.value,
            streamNames: this.streamNames.value,
            non_alVideoStreams: this.non_alVideoStreams.value,
            sortAudioLoudness: this.sortAudioLoudness.value,
            audioDecibels: this.audioDecibels.value,
            mixed_alVideoStreams: this.mixed_alVideoStreams.value,
            non_alVideoStreams_muted: this.non_alVideoStreams_muted.value,
            paginatedStreams: this.paginatedStreams.value,
            localStreamAudio: this.localStreamAudio.value,
            defAudioID: this.defAudioID.value,
            userDefaultAudioInputDevice: this.userDefaultAudioInputDevice.value,
            userDefaultAudioOutputDevice: this.userDefaultAudioOutputDevice.value,
            prevAudioInputDevice: this.prevAudioInputDevice.value,
            prevVideoInputDevice: this.prevVideoInputDevice.value,
            audioPaused: this.audioPaused.value,
            mainScreenPerson: this.mainScreenPerson.value,
            adminOnMainScreen: this.adminOnMainScreen.value,
            screenStates: this.screenStates.value,
            prevScreenStates: this.prevScreenStates.value,
            updateDateState: this.updateDateState.value,
            lastUpdate: this.lastUpdate.value,
            nForReadjustRecord: this.nForReadjustRecord.value,
            fixedPageLimit: this.fixedPageLimit.value,
            removeAltGrid: this.removeAltGrid.value,
            nForReadjust: this.nForReadjust.value,
            lastReorderTime: this.lastReorderTime.value,
            reorderInterval: this.reorderInterval.value,
            fastReorderInterval: this.fastReorderInterval.value,
            audStreamNames: this.audStreamNames.value,
            currentUserPage: this.currentUserPage.value,
            mainHeightWidth: this.mainHeightWidth.value,
            prevMainHeightWidth: this.prevMainHeightWidth.value,
            prevDoPaginate: this.prevDoPaginate.value,
            doPaginate: this.doPaginate.value,
            shareEnded: this.shareEnded.value,
            lStreams: this.lStreams.value,
            chatRefStreams: this.chatRefStreams.value,
            controlHeight: this.controlHeight.value,
            isWideScreen: this.isWideScreen.value,
            isMediumScreen: this.isMediumScreen.value,
            isSmallScreen: this.isSmallScreen.value,
            addGrid: this.addGrid.value,
            addAltGrid: this.addAltGrid.value,
            gridRows: this.gridRows.value,
            gridCols: this.gridCols.value,
            altGridRows: this.altGridRows.value,
            altGridCols: this.altGridCols.value,
            numberPages: this.numberPages.value,
            currentStreams: this.currentStreams.value,
            showMiniView: this.showMiniView.value,
            nStream: this.nStream.value,
            defer_receive: this.defer_receive.value,
            allAudioStreams: this.allAudioStreams.value,
            screenProducer: this.screenProducer.value,
            remoteScreenStream: this.remoteScreenStream.value,
            gotAllVids: this.gotAllVids.value,
            paginationHeightWidth: this.paginationHeightWidth.value,
            paginationDirection: this.paginationDirection.value,
            gridSizes: this.gridSizes.value,
            screenForceFullDisplay: this.screenForceFullDisplay.value,
            mainGridStream: this.mainGridStream.value,
            otherGridStreams: this.otherGridStreams.value,
            audioOnlyStreams: this.audioOnlyStreams.value,
            videoInputs: this.videoInputs.value,
            audioInputs: this.audioInputs.value,
            meetingProgressTime: this.meetingProgressTime.value,
            meetingElapsedTime: this.meetingElapsedTime.value,
            ref_participants: this.ref_participants.value,
            messages: this.messages.value,
            startDirectMessage: this.startDirectMessage.value,
            directMessageDetails: this.directMessageDetails.value,
            coHost: this.coHost.value,
            coHostResponsibility: this.coHostResponsibility.value,
            // Event settings
            audioSetting: this.audioSetting.value,
            videoSetting: this.videoSetting.value,
            screenshareSetting: this.screenshareSetting.value,
            chatSetting: this.chatSetting.value,
            // Display settings
            autoWave: this.autoWave.value,
            forceFullDisplay: this.forceFullDisplay.value,
            prevForceFullDisplay: this.prevForceFullDisplay.value,
            prevMeetingDisplayType: this.prevMeetingDisplayType.value,
            // Waiting room
            waitingRoomFilter: this.waitingRoomFilter.value,
            waitingRoomList: this.waitingRoomList.value,
            waitingRoomCounter: this.waitingRoomCounter.value,
            filteredWaitingRoomList: this.filteredWaitingRoomList.value,
            // Requests
            requestFilter: this.requestFilter.value,
            requestList: this.requestList.value,
            requestCounter: this.requestCounter.value,
            filteredRequestList: this.filteredRequestList.value,
            // Total requests and waiting room
            totalReqWait: this.totalReqWait.value,
            // Alerts
            alertVisible: this.alertVisible.value,
            alertMessage: this.alertMessage.value,
            alertType: this.alertType.value,
            alertDuration: this.alertDuration.value,
            // Progress Timer
            progressTimerVisible: this.progressTimerVisible.value,
            progressTimerValue: this.progressTimerValue.value,
            // Menu modals
            isMenuModalVisible: this.isMenuModalVisible.value,
            isRecordingModalVisible: this.isRecordingModalVisible.value,
            isSettingsModalVisible: this.isSettingsModalVisible.value,
            isRequestsModalVisible: this.isRequestsModalVisible.value,
            isWaitingModalVisible: this.isWaitingModalVisible.value,
            isCoHostModalVisible: this.isCoHostModalVisible.value,
            isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
            isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            // Other Modals
            isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            isMessagesModalVisible: this.isMessagesModalVisible.value,
            isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            isConfirmHereModalVisible: this.isConfirmHereModalVisible.value,
            isLoadingModalVisible: this.isLoadingModalVisible.value,
            // Recording Options
            recordingMediaOptions: this.recordingMediaOptions.value,
            recordingAudioOptions: this.recordingAudioOptions.value,
            recordingVideoOptions: this.recordingVideoOptions.value,
            recordingVideoType: this.recordingVideoType.value,
            recordingVideoOptimized: this.recordingVideoOptimized.value,
            recordingDisplayType: this.recordingDisplayType.value,
            recordingAddHLS: this.recordingAddHLS.value,
            recordingAddText: this.recordingAddText.value,
            recordingCustomText: this.recordingCustomText.value,
            recordingCustomTextPosition: this.recordingCustomTextPosition.value,
            recordingCustomTextColor: this.recordingCustomTextColor.value,
            recordingNameTags: this.recordingNameTags.value,
            recordingBackgroundColor: this.recordingBackgroundColor.value,
            recordingNameTagsColor: this.recordingNameTagsColor.value,
            recordingOrientationVideo: this.recordingOrientationVideo.value,
            clearedToResume: this.clearedToResume.value,
            clearedToRecord: this.clearedToRecord.value,
            recordState: this.recordState.value,
            showRecordButtons: this.showRecordButtons.value,
            recordingProgressTime: this.recordingProgressTime.value,
            audioSwitching: this.audioSwitching.value,
            videoSwitching: this.videoSwitching.value,
            // Media states
            videoAlreadyOn: this.videoAlreadyOn.value,
            audioAlreadyOn: this.audioAlreadyOn.value,
            componentSizes: this.componentSizes.value,
            // Permissions
            hasCameraPermission: this.hasCameraPermission.value,
            hasAudioPermission: this.hasAudioPermission.value,
            // Transports
            transportCreated: this.transportCreated.value,
            localTransportCreated: this.localTransportCreated.value,
            transportCreatedVideo: this.transportCreatedVideo.value,
            transportCreatedAudio: this.transportCreatedAudio.value,
            transportCreatedScreen: this.transportCreatedScreen.value,
            producerTransport: this.producerTransport.value,
            localProducerTransport: this.localProducerTransport.value,
            videoProducer: this.videoProducer.value,
            localVideoProducer: this.localVideoProducer.value,
            params: this.params.value,
            videoParams: this.videoParams.value,
            audioParams: this.audioParams.value,
            audioProducer: this.audioProducer.value,
            audioLevel: this.audioLevel.value,
            localAudioProducer: this.localAudioProducer.value,
            consumerTransports: this.consumerTransports.value,
            consumingTransports: this.consumingTransports.value,
            // Polls
            polls: this.polls.value,
            poll: this.poll.value,
            isPollModalVisible: this.isPollModalVisible.value,
            // Background
            customImage: this.customImage.value,
            selectedImage: this.selectedImage.value,
            segmentVideo: this.segmentVideo.value,
            selfieSegmentation: this.selfieSegmentation.value,
            pauseSegmentation: this.pauseSegmentation.value,
            processedStream: this.processedStream.value,
            keepBackground: this.keepBackground.value,
            backgroundHasChanged: this.backgroundHasChanged.value,
            virtualStream: this.virtualStream.value,
            mainCanvas: this.mainCanvas.value,
            prevKeepBackground: this.prevKeepBackground.value,
            appliedBackground: this.appliedBackground.value,
            isBackgroundModalVisible: this.isBackgroundModalVisible.value,
            autoClickBackground: this.autoClickBackground.value,
            // Breakout rooms
            breakoutRooms: this.breakoutRooms.value,
            currentRoomIndex: this.currentRoomIndex.value,
            canStartBreakout: this.canStartBreakout.value,
            breakOutRoomStarted: this.breakOutRoomStarted.value,
            breakOutRoomEnded: this.breakOutRoomEnded.value,
            hostNewRoom: this.hostNewRoom.value,
            limitedBreakRoom: this.limitedBreakRoom.value,
            mainRoomsLength: this.mainRoomsLength.value,
            memberRoom: this.memberRoom.value,
            isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            // Whiteboard
            whiteboardUsers: this.whiteboardUsers.value,
            currentWhiteboardIndex: this.currentWhiteboardIndex.value,
            canStartWhiteboard: this.canStartWhiteboard.value,
            whiteboardStarted: this.whiteboardStarted.value,
            whiteboardEnded: this.whiteboardEnded.value,
            whiteboardLimit: this.whiteboardLimit.value,
            isWhiteboardModalVisible: this.isWhiteboardModalVisible.value,
            isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            shapes: this.shapes.value,
            useImageBackground: this.useImageBackground.value,
            redoStack: this.redoStack.value,
            undoStack: this.undoStack.value,
            canvasStream: this.canvasStream.value,
            canvasWhiteboard: this.canvasWhiteboard.value,
            // Screenboard
            canvasScreenboard: this.canvasScreenboard.value,
            processedScreenStream: this.processedScreenStream.value,
            annotateScreenStream: this.annotateScreenStream.value,
            mainScreenCanvas: this.mainScreenCanvas.value,
            isScreenboardModalVisible: this.isScreenboardModalVisible.value,
            validated: this.validated.value,
            device: this.device.value,
            socket: this.socket.value,
            localSocket: this.localSocket.value,
            checkMediaPermission: false,
            onWeb: true,
            // Update functions
            updateRoomName: this.updateRoomName.bind(this),
            updateMember: this.updateMember.bind(this),
            updateAdminPasscode: this.updateAdminPasscode.bind(this),
            updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
            updateYouAreHost: this.updateYouAreHost.bind(this),
            updateIslevel: this.updateIslevel.bind(this),
            updateCoHost: this.updateCoHost.bind(this),
            updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
            updateConfirmedToRecord: this.updateConfirmedToRecord.bind(this),
            updateMeetingDisplayType: this.updateMeetingDisplayType.bind(this),
            updateMeetingVideoOptimized: this.updateMeetingVideoOptimized.bind(this),
            updateEventType: this.updateEventType.bind(this),
            updateParticipants: this.updateParticipants.bind(this),
            updateParticipantsCounter: this.updateParticipantsCounter.bind(this),
            updateParticipantsFilter: this.updateParticipantsFilter.bind(this),
            // More update functions for media details
            updateConsume_sockets: this.updateConsume_sockets.bind(this),
            updateRtpCapabilities: this.updateRtpCapabilities.bind(this),
            updateRoomRecvIPs: this.updateRoomRecvIPs.bind(this),
            updateMeetingRoomParams: this.updateMeetingRoomParams.bind(this),
            updateItemPageLimit: this.updateItemPageLimit.bind(this),
            updateAudioOnlyRoom: this.updateAudioOnlyRoom.bind(this),
            updateAddForBasic: this.updateAddForBasic.bind(this),
            updateScreenPageLimit: this.updateScreenPageLimit.bind(this),
            updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
            updateShared: this.updateShared.bind(this),
            updateTargetOrientation: this.updateTargetOrientation.bind(this),
            updateTargetResolution: this.updateTargetResolution.bind(this),
            updateTargetResolutionHost: this.updateTargetResolutionHost.bind(this),
            updateVidCons: this.updateVidCons.bind(this),
            updateFrameRate: this.updateFrameRate.bind(this),
            updateHParams: this.updateHParams.bind(this),
            updateVParams: this.updateVParams.bind(this),
            updateScreenParams: this.updateScreenParams.bind(this),
            updateAParams: this.updateAParams.bind(this),
            // More update functions for recording details
            updateRecordingAudioPausesLimit: this.updateRecordingAudioPausesLimit.bind(this),
            updateRecordingAudioPausesCount: this.updateRecordingAudioPausesCount.bind(this),
            updateRecordingAudioSupport: this.updateRecordingAudioSupport.bind(this),
            updateRecordingAudioPeopleLimit: this.updateRecordingAudioPeopleLimit.bind(this),
            updateRecordingAudioParticipantsTimeLimit: this.updateRecordingAudioParticipantsTimeLimit.bind(this),
            updateRecordingVideoPausesCount: this.updateRecordingVideoPausesCount.bind(this),
            updateRecordingVideoPausesLimit: this.updateRecordingVideoPausesLimit.bind(this),
            updateRecordingVideoSupport: this.updateRecordingVideoSupport.bind(this),
            updateRecordingVideoPeopleLimit: this.updateRecordingVideoPeopleLimit.bind(this),
            updateRecordingVideoParticipantsTimeLimit: this.updateRecordingVideoParticipantsTimeLimit.bind(this),
            updateRecordingAllParticipantsSupport: this.updateRecordingAllParticipantsSupport.bind(this),
            updateRecordingVideoParticipantsSupport: this.updateRecordingVideoParticipantsSupport.bind(this),
            updateRecordingAllParticipantsFullRoomSupport: this.updateRecordingAllParticipantsFullRoomSupport.bind(this),
            updateRecordingVideoParticipantsFullRoomSupport: this.updateRecordingVideoParticipantsFullRoomSupport.bind(this),
            updateRecordingPreferredOrientation: this.updateRecordingPreferredOrientation.bind(this),
            updateRecordingSupportForOtherOrientation: this.updateRecordingSupportForOtherOrientation.bind(this),
            updateRecordingMultiFormatsSupport: this.updateRecordingMultiFormatsSupport.bind(this),
            updateUserRecordingParams: this.updateUserRecordingParams.bind(this),
            updateCanRecord: this.updateCanRecord.bind(this),
            updateStartReport: this.updateStartReport.bind(this),
            updateEndReport: this.updateEndReport.bind(this),
            updateRecordTimerInterval: this.updateRecordTimerInterval.bind(this),
            updateRecordStartTime: this.updateRecordStartTime.bind(this),
            updateRecordElapsedTime: this.updateRecordElapsedTime.bind(this),
            updateIsTimerRunning: this.updateIsTimerRunning.bind(this),
            updateCanPauseResume: this.updateCanPauseResume.bind(this),
            updateRecordChangeSeconds: this.updateRecordChangeSeconds.bind(this),
            updatePauseLimit: this.updatePauseLimit.bind(this),
            updatePauseRecordCount: this.updatePauseRecordCount.bind(this),
            updateCanLaunchRecord: this.updateCanLaunchRecord.bind(this),
            updateStopLaunchRecord: this.updateStopLaunchRecord.bind(this),
            updateParticipantsAll: this.updateParticipantsAll.bind(this),
            updateFirstAll: this.updateFirstAll.bind(this),
            updateUpdateMainWindow: this.updateUpdateMainWindow.bind(this),
            updateFirst_round: this.updateFirst_round.bind(this),
            updateLandScaped: this.updateLandScaped.bind(this),
            updateLock_screen: this.updateLock_screen.bind(this),
            updateScreenId: this.updateScreenId.bind(this),
            updateAllVideoStreams: this.updateAllVideoStreams.bind(this),
            updateNewLimitedStreams: this.updateNewLimitedStreams.bind(this),
            updateNewLimitedStreamsIDs: this.updateNewLimitedStreamsIDs.bind(this),
            updateActiveSounds: this.updateActiveSounds.bind(this),
            updateScreenShareIDStream: this.updateScreenShareIDStream.bind(this),
            updateScreenShareNameStream: this.updateScreenShareNameStream.bind(this),
            updateAdminIDStream: this.updateAdminIDStream.bind(this),
            updateAdminNameStream: this.updateAdminNameStream.bind(this),
            updateYouYouStream: this.updateYouYouStream.bind(this),
            updateYouYouStreamIDs: this.updateYouYouStreamIDs.bind(this),
            updateLocalStream: this.updateLocalStream.bind(this),
            updateRecordStarted: this.updateRecordStarted.bind(this),
            updateRecordResumed: this.updateRecordResumed.bind(this),
            updateRecordPaused: this.updateRecordPaused.bind(this),
            updateRecordStopped: this.updateRecordStopped.bind(this),
            updateAdminRestrictSetting: this.updateAdminRestrictSetting.bind(this),
            updateVideoRequestState: this.updateVideoRequestState.bind(this),
            updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
            updateVideoAction: this.updateVideoAction.bind(this),
            updateLocalStreamVideo: this.updateLocalStreamVideo.bind(this),
            updateUserDefaultVideoInputDevice: this.updateUserDefaultVideoInputDevice.bind(this),
            updateCurrentFacingMode: this.updateCurrentFacingMode.bind(this),
            updatePrevFacingMode: this.updatePrevFacingMode.bind(this),
            updateDefVideoID: this.updateDefVideoID.bind(this),
            updateAllowed: this.updateAllowed.bind(this),
            updateDispActiveNames: this.updateDispActiveNames.bind(this),
            updateP_dispActiveNames: this.updateP_dispActiveNames.bind(this),
            updateActiveNames: this.updateActiveNames.bind(this),
            updatePrevActiveNames: this.updatePrevActiveNames.bind(this),
            updateP_activeNames: this.updateP_activeNames.bind(this),
            updateMembersReceived: this.updateMembersReceived.bind(this),
            updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
            updateHostFirstSwitch: this.updateHostFirstSwitch.bind(this),
            updateMicAction: this.updateMicAction.bind(this),
            updateScreenAction: this.updateScreenAction.bind(this),
            updateChatAction: this.updateChatAction.bind(this),
            updateAudioRequestState: this.updateAudioRequestState.bind(this),
            updateScreenRequestState: this.updateScreenRequestState.bind(this),
            updateChatRequestState: this.updateChatRequestState.bind(this),
            updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
            updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
            updateChatRequestTime: this.updateChatRequestTime.bind(this),
            updateOldSoundIds: this.updateOldSoundIds.bind(this),
            updateHostLabel: this.updateHostLabel.bind(this),
            updateMainScreenFilled: this.updateMainScreenFilled.bind(this),
            updateLocalStreamScreen: this.updateLocalStreamScreen.bind(this),
            updateScreenAlreadyOn: this.updateScreenAlreadyOn.bind(this),
            updateChatAlreadyOn: this.updateChatAlreadyOn.bind(this),
            updateRedirectURL: this.updateRedirectURL.bind(this),
            updateOldAllStreams: this.updateOldAllStreams.bind(this),
            updateAdminVidID: this.updateAdminVidID.bind(this),
            updateStreamNames: this.updateStreamNames.bind(this),
            updateNon_alVideoStreams: this.updateNon_alVideoStreams.bind(this),
            updateSortAudioLoudness: this.updateSortAudioLoudness.bind(this),
            updateAudioDecibels: this.updateAudioDecibels.bind(this),
            updateMixed_alVideoStreams: this.updateMixed_alVideoStreams.bind(this),
            updateNon_alVideoStreams_muted: this.updateNon_alVideoStreams_muted.bind(this),
            updatePaginatedStreams: this.updatePaginatedStreams.bind(this),
            updateLocalStreamAudio: this.updateLocalStreamAudio.bind(this),
            updateDefAudioID: this.updateDefAudioID.bind(this),
            updateUserDefaultAudioInputDevice: this.updateUserDefaultAudioInputDevice.bind(this),
            updateUserDefaultAudioOutputDevice: this.updateUserDefaultAudioOutputDevice.bind(this),
            updatePrevAudioInputDevice: this.updatePrevAudioInputDevice.bind(this),
            updatePrevVideoInputDevice: this.updatePrevVideoInputDevice.bind(this),
            updateAudioPaused: this.updateAudioPaused.bind(this),
            updateMainScreenPerson: this.updateMainScreenPerson.bind(this),
            updateAdminOnMainScreen: this.updateAdminOnMainScreen.bind(this),
            updateScreenStates: this.updateScreenStates.bind(this),
            updatePrevScreenStates: this.updatePrevScreenStates.bind(this),
            updateUpdateDateState: this.updateUpdateDateState.bind(this),
            updateLastUpdate: this.updateLastUpdate.bind(this),
            updateNForReadjustRecord: this.updateNForReadjustRecord.bind(this),
            updateFixedPageLimit: this.updateFixedPageLimit.bind(this),
            updateRemoveAltGrid: this.updateRemoveAltGrid.bind(this),
            updateNForReadjust: this.updateNForReadjust.bind(this),
            updateLastReorderTime: this.updateLastReorderTime.bind(this),
            updateAudStreamNames: this.updateAudStreamNames.bind(this),
            updateCurrentUserPage: this.updateCurrentUserPage.bind(this),
            updateMainHeightWidth: this.updateMainHeightWidth.bind(this),
            updatePrevMainHeightWidth: this.updatePrevMainHeightWidth.bind(this),
            updatePrevDoPaginate: this.updatePrevDoPaginate.bind(this),
            updateDoPaginate: this.updateDoPaginate.bind(this),
            updateShareEnded: this.updateShareEnded.bind(this),
            updateLStreams: this.updateLStreams.bind(this),
            updateChatRefStreams: this.updateChatRefStreams.bind(this),
            updateControlHeight: this.updateControlHeight.bind(this),
            updateIsWideScreen: this.updateIsWideScreen.bind(this),
            updateIsMediumScreen: this.updateIsMediumScreen.bind(this),
            updateIsSmallScreen: this.updateIsSmallScreen.bind(this),
            updateAddGrid: this.updateAddGrid.bind(this),
            updateAddAltGrid: this.updateAddAltGrid.bind(this),
            updateGridRows: this.updateGridRows.bind(this),
            updateGridCols: this.updateGridCols.bind(this),
            updateAltGridRows: this.updateAltGridRows.bind(this),
            updateAltGridCols: this.updateAltGridCols.bind(this),
            updateNumberPages: this.updateNumberPages.bind(this),
            updateCurrentStreams: this.updateCurrentStreams.bind(this),
            updateShowMiniView: this.updateShowMiniView.bind(this),
            updateNStream: this.updateNStream.bind(this),
            updateDefer_receive: this.updateDefer_receive.bind(this),
            updateAllAudioStreams: this.updateAllAudioStreams.bind(this),
            updateRemoteScreenStream: this.updateRemoteScreenStream.bind(this),
            updateScreenProducer: this.updateScreenProducer.bind(this),
            updateGotAllVids: this.updateGotAllVids.bind(this),
            updatePaginationHeightWidth: this.updatePaginationHeightWidth.bind(this),
            updatePaginationDirection: this.updatePaginationDirection.bind(this),
            updateGridSizes: this.updateGridSizes.bind(this),
            updateScreenForceFullDisplay: this.updateScreenForceFullDisplay.bind(this),
            updateMainGridStream: this.updateMainGridStream.bind(this),
            updateOtherGridStreams: this.updateOtherGridStreams.bind(this),
            updateAudioOnlyStreams: this.updateAudioOnlyStreams.bind(this),
            updateVideoInputs: this.updateVideoInputs.bind(this),
            updateAudioInputs: this.updateAudioInputs.bind(this),
            updateMeetingProgressTime: this.updateMeetingProgressTime.bind(this),
            updateMeetingElapsedTime: this.updateMeetingElapsedTime.bind(this),
            updateRef_participants: this.updateRef_participants.bind(this),
            updateMessages: this.updateMessages.bind(this),
            updateStartDirectMessage: this.updateStartDirectMessage.bind(this),
            updateDirectMessageDetails: this.updateDirectMessageDetails.bind(this),
            updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
            // Event settings
            updateAudioSetting: this.updateAudioSetting.bind(this),
            updateVideoSetting: this.updateVideoSetting.bind(this),
            updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
            updateChatSetting: this.updateChatSetting.bind(this),
            // Display settings
            updateAutoWave: this.updateAutoWave.bind(this),
            updateForceFullDisplay: this.updateForceFullDisplay.bind(this),
            updatePrevForceFullDisplay: this.updatePrevForceFullDisplay.bind(this),
            updatePrevMeetingDisplayType: this.updatePrevMeetingDisplayType.bind(this),
            // Waiting room
            updateWaitingRoomFilter: this.updateWaitingRoomFilter.bind(this),
            updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
            updateWaitingRoomCounter: this.updateWaitingRoomCounter.bind(this),
            // Requests
            updateRequestFilter: this.updateRequestFilter.bind(this),
            updateRequestList: this.updateRequestList.bind(this),
            updateRequestCounter: this.updateRequestCounter.bind(this),
            // Total requests and waiting room
            updateTotalReqWait: this.updateTotalReqWait.bind(this),
            // Menu modals
            updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
            updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
            updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
            updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
            updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
            updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
            // Other modals
            updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
            updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
            updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
            updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
            updateIsLoadingModalVisible: this.updateIsLoadingModalVisible.bind(this),
            // Recording Options
            updateRecordingMediaOptions: this.updateRecordingMediaOptions.bind(this),
            updateRecordingAudioOptions: this.updateRecordingAudioOptions.bind(this),
            updateRecordingVideoOptions: this.updateRecordingVideoOptions.bind(this),
            updateRecordingVideoType: this.updateRecordingVideoType.bind(this),
            updateRecordingVideoOptimized: this.updateRecordingVideoOptimized.bind(this),
            updateRecordingDisplayType: this.updateRecordingDisplayType.bind(this),
            updateRecordingAddHLS: this.updateRecordingAddHLS.bind(this),
            updateRecordingAddText: this.updateRecordingAddText.bind(this),
            updateRecordingCustomText: this.updateRecordingCustomText.bind(this),
            updateRecordingCustomTextPosition: this.updateRecordingCustomTextPosition.bind(this),
            updateRecordingCustomTextColor: this.updateRecordingCustomTextColor.bind(this),
            updateRecordingNameTags: this.updateRecordingNameTags.bind(this),
            updateRecordingBackgroundColor: this.updateRecordingBackgroundColor.bind(this),
            updateRecordingNameTagsColor: this.updateRecordingNameTagsColor.bind(this),
            updateRecordingOrientationVideo: this.updateRecordingOrientationVideo.bind(this),
            updateClearedToResume: this.updateClearedToResume.bind(this),
            updateClearedToRecord: this.updateClearedToRecord.bind(this),
            updateRecordState: this.updateRecordState.bind(this),
            updateShowRecordButtons: this.updateShowRecordButtons.bind(this),
            updateRecordingProgressTime: this.updateRecordingProgressTime.bind(this),
            updateAudioSwitching: this.updateAudioSwitching.bind(this),
            updateVideoSwitching: this.updateVideoSwitching.bind(this),
            // Media states
            updateVideoAlreadyOn: this.updateVideoAlreadyOn.bind(this),
            updateAudioAlreadyOn: this.updateAudioAlreadyOn.bind(this),
            updateComponentSizes: this.updateComponentSizes.bind(this),
            // Permissions
            updateHasCameraPermission: this.updateHasCameraPermission.bind(this),
            updateHasAudioPermission: this.updateHasAudioPermission.bind(this),
            // Transports
            updateTransportCreated: this.updateTransportCreated.bind(this),
            updateLocalTransportCreated: this.updateLocalTransportCreated.bind(this),
            updateTransportCreatedVideo: this.updateTransportCreatedVideo.bind(this),
            updateTransportCreatedAudio: this.updateTransportCreatedAudio.bind(this),
            updateTransportCreatedScreen: this.updateTransportCreatedScreen.bind(this),
            updateProducerTransport: this.updateProducerTransport.bind(this),
            updateLocalProducerTransport: this.updateLocalProducerTransport.bind(this),
            updateVideoProducer: this.updateVideoProducer.bind(this),
            updateLocalVideoProducer: this.updateLocalVideoProducer.bind(this),
            updateParams: this.updateParams.bind(this),
            updateVideoParams: this.updateVideoParams.bind(this),
            updateAudioParams: this.updateAudioParams.bind(this),
            updateAudioProducer: this.updateAudioProducer.bind(this),
            updateAudioLevel: this.updateAudioLevel.bind(this),
            updateLocalAudioProducer: this.updateLocalAudioProducer.bind(this),
            updateConsumerTransports: this.updateConsumerTransports.bind(this),
            updateConsumingTransports: this.updateConsumingTransports.bind(this),
            // Polls
            updatePolls: this.updatePolls.bind(this),
            updatePoll: this.updatePoll.bind(this),
            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
            // Background
            updateCustomImage: this.updateCustomImage.bind(this),
            updateSelectedImage: this.updateSelectedImage.bind(this),
            updateSegmentVideo: this.updateSegmentVideo.bind(this),
            updateSelfieSegmentation: this.updateSelfieSegmentation.bind(this),
            updatePauseSegmentation: this.updatePauseSegmentation.bind(this),
            updateProcessedStream: this.updateProcessedStream.bind(this),
            updateKeepBackground: this.updateKeepBackground.bind(this),
            updateBackgroundHasChanged: this.updateBackgroundHasChanged.bind(this),
            updateVirtualStream: this.updateVirtualStream.bind(this),
            updateMainCanvas: this.updateMainCanvas.bind(this),
            updatePrevKeepBackground: this.updatePrevKeepBackground.bind(this),
            updateAppliedBackground: this.updateAppliedBackground.bind(this),
            updateIsBackgroundModalVisible: this.updateIsBackgroundModalVisible.bind(this),
            updateAutoClickBackground: this.updateAutoClickBackground.bind(this),
            // Breakout rooms
            updateBreakoutRooms: this.updateBreakoutRooms.bind(this),
            updateCurrentRoomIndex: this.updateCurrentRoomIndex.bind(this),
            updateCanStartBreakout: this.updateCanStartBreakout.bind(this),
            updateBreakOutRoomStarted: this.updateBreakOutRoomStarted.bind(this),
            updateBreakOutRoomEnded: this.updateBreakOutRoomEnded.bind(this),
            updateHostNewRoom: this.updateHostNewRoom.bind(this),
            updateLimitedBreakRoom: this.updateLimitedBreakRoom.bind(this),
            updateMainRoomsLength: this.updateMainRoomsLength.bind(this),
            updateMemberRoom: this.updateMemberRoom.bind(this),
            updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
            // Whiteboard
            updateWhiteboardUsers: this.updateWhiteboardUsers.bind(this),
            updateCurrentWhiteboardIndex: this.updateCurrentWhiteboardIndex.bind(this),
            updateCanStartWhiteboard: this.updateCanStartWhiteboard.bind(this),
            updateWhiteboardStarted: this.updateWhiteboardStarted.bind(this),
            updateWhiteboardEnded: this.updateWhiteboardEnded.bind(this),
            updateWhiteboardLimit: this.updateWhiteboardLimit.bind(this),
            updateIsWhiteboardModalVisible: this.updateIsWhiteboardModalVisible.bind(this),
            updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
            updateShapes: this.updateShapes.bind(this),
            updateUseImageBackground: this.updateUseImageBackground.bind(this),
            updateRedoStack: this.updateRedoStack.bind(this),
            updateUndoStack: this.updateUndoStack.bind(this),
            updateCanvasStream: this.updateCanvasStream.bind(this),
            updateCanvasWhiteboard: this.updateCanvasWhiteboard.bind(this),
            // Screenboard
            updateCanvasScreenboard: this.updateCanvasScreenboard.bind(this),
            updateProcessedScreenStream: this.updateProcessedScreenStream.bind(this),
            updateAnnotateScreenStream: this.updateAnnotateScreenStream.bind(this),
            updateMainScreenCanvas: this.updateMainScreenCanvas.bind(this),
            updateIsScreenboardModalVisible: this.updateIsScreenboardModalVisible.bind(this),
            // Other functions
            checkOrientation: this.checkOrientation.bind(this),
            updateDevice: this.updateDevice.bind(this),
            updateSocket: this.updateSocket.bind(this),
            updateLocalSocket: this.updateLocalSocket.bind(this),
            updateValidated: this.updateValidated.bind(this),
            showAlert: this.showAlert.bind(this),
            getUpdatedAllParams: () => {
                try {
                    if (this.sourceParameters !== null) {
                        this.sourceParameters = {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        };
                        if (this.updateSourceParameters) {
                            this.updateSourceParameters(this.sourceParameters);
                        }
                    }
                }
                catch {
                    console.log('error updateSourceParameters');
                }
                return {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                };
            },
        };
    }
    mediaSFUParameters = {
        ...this.getAllParams(),
        ...this.mediaSFUFunctions(),
    };
    getUpdatedAllParams = () => {
        return {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    };
    PrejoinPageComponent = {
        component: this.PrejoinPage,
        injector: null,
    };
    updatePrejoinPageComponent = () => {
        const PrejoinComp = {
            component: this.PrejoinPage,
            injector: this.createInjector({
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    connectLocalSocket: this.socketManager.connectLocalSocket,
                    updateSocket: this.updateSocket,
                    updateLocalSocket: this.updateLocalSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                credentials: this.credentials,
                localLink: this.localLink,
                connectMediaSFU: this.connectMediaSFU,
                returnUI: this.returnUI,
                noUIPreJoinOptions: this.noUIPreJoinOptions,
                joinMediaSFURoom: this.joinMediaSFURoom,
                createMediaSFURoom: this.createMediaSFURoom,
            }),
        };
        this.PrejoinPageComponent = { ...PrejoinComp };
        this.cdr.detectChanges();
    };
    ngOnInit() {
        if (this.PrejoinPage) {
            this.updatePrejoinPageComponent();
        }
        this.setupResizeListener();
        if (this.validated) {
            this.connectAndAddSocketMethods();
        }
        this.mainHeightWidthSubscription = this.mainHeightWidth.subscribe(() => {
            this.updateMainVideoSize();
        });
        this.recordingSubscription = combineLatest([
            this.recordPaused,
            this.recordStarted,
            this.recordStopped,
            this.recordResumed,
            this.recordingProgressTime,
            this.showRecordButtons,
            this.islevel,
        ]).subscribe(([recordPaused, recordStarted, recordStopped, recordResumed, recordingProgressTime, showRecordButtons, islevel,]) => {
            if (recordPaused ||
                recordStarted ||
                recordStopped ||
                recordResumed ||
                recordingProgressTime ||
                showRecordButtons ||
                islevel) {
                this.updateRecordButtons();
            }
        });
        this.validatedSubscription = this.validated.subscribe((validated) => {
            if (validated) {
                this.handleValidated();
            }
        });
        this.islevelSubscription = this.islevel.subscribe((islevel) => {
            if (islevel) {
                this.updateControlBroadcastButtons();
            }
        });
        this.coHostSubscription = combineLatest([this.coHost, this.coHostResponsibility]).subscribe(([coHost, coHostResponsibility]) => {
            if (coHost || coHostResponsibility) {
                this.updateControlBroadcastButtons();
            }
        });
        // Subscribe to changes in BehaviorSubject and update the buttons accordingly
        this.buttonSubscriptions.push(this.micActive.subscribe(() => {
            this.updateControlBroadcastButtons();
        }));
        this.buttonSubscriptions.push(this.videoActive.subscribe(() => {
            this.updateControlBroadcastButtons();
        }));
        this.buttonSubscriptions.push(this.participantsCounter.subscribe((value) => {
            this.updateMenuParticipantsWidget(value);
        }));
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.handleResize);
        window.removeEventListener('orientationchange', this.handleResize);
        if (this.mainHeightWidthSubscription) {
            this.mainHeightWidthSubscription.unsubscribe();
        }
        if (this.validatedSubscription) {
            this.validatedSubscription.unsubscribe();
        }
        if (this.islevelSubscription) {
            this.islevelSubscription.unsubscribe();
        }
        if (this.coHostSubscription) {
            this.coHostSubscription.unsubscribe();
        }
        if (this.ScreenboardSubscription) {
            this.ScreenboardSubscription.unsubscribe();
        }
        if (this.recordingSubscription) {
            this.recordingSubscription.unsubscribe();
        }
    }
    updateMainVideoSize = async () => {
        if (!this.lock_screen.value && !this.shared.value) {
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
        }
        else {
            if (!this.first_round.value) {
                this.prepopulateUserMedia.prepopulateUserMedia({
                    name: this.hostLabel.value,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            }
        }
    };
    async connectAndAddSocketMethods() {
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
        const socket_ = await this.connect_Socket(this.apiUserName.value, this.apiToken.value);
        if (socket_) {
            this.updateSocket(socket_);
        }
    }
    async handleValidated() {
        this.updateAllVideoStreams([
            { producerId: 'youyou', stream: undefined, id: 'youyou', name: 'youyou' },
        ]);
        this.updateStreamNames([{ id: 'youyou', name: 'youyou', producerId: '' }]);
        if (this.validated.value) {
            try {
                if (!this.localUIMode.value) {
                    this.updateIsLoadingModalVisible(true);
                    await this.connectAndAddSocketMethods();
                }
                else {
                    this.updateIsLoadingModalVisible(false);
                }
            }
            catch (error) {
                console.log('error connectAndaAddSocketMethods', error);
            }
            this.startMeetingProgressTimer.startMeetingProgressTimer({
                startTime: Date.now() / 1000,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            try {
                if (this.sourceParameters !== null) {
                    this.sourceParameters = {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                    };
                    if (this.updateSourceParameters) {
                        this.updateSourceParameters(this.sourceParameters);
                    }
                }
            }
            catch {
                console.log('error updateSourceParameters');
            }
        }
    }
    async handleResize() {
        let fraction = 0;
        if (window.innerHeight < window.innerWidth &&
            (this.eventType.value == 'webinar' || this.eventType.value == 'conference')) {
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        else {
            // Set default control button height for portrait mode or other event types
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            fraction = Number(fraction);
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        const dimensions = this.computeDimensionsMethod({
            containerWidthFraction: 1,
            containerHeightFraction: 1,
            mainSize: this.mainHeightWidth.value,
            doStack: true,
            defaultFraction: this.eventType.value == 'webinar' || this.eventType.value == 'conference'
                ? 1 - fraction
                : 1,
        });
        this.updateComponentSizes(dimensions);
        const orientation = this.checkOrientation();
        if (orientation == 'portrait') {
            if (!this.isWideScreen.value) {
                if (this.shareScreenStarted.value || this.shared.value) {
                    this.updateScreenForceFullDisplay(true);
                }
            }
        }
        // Updates the main grid view
        await this.prepopulateUserMedia.prepopulateUserMedia({
            name: this.hostLabel.value,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
        // Updates the mini grid view
        await this.onScreenChanges.onScreenChanges({
            changed: true,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
    }
    async disconnectAllSockets(consume_sockets) {
        for (const socket of consume_sockets) {
            try {
                const ip = Object.keys(socket)[0];
                await socket[ip].disconnect();
            }
            catch (error) {
                console.log(`Error disconnecting socket with IP: ${Object.keys(socket)[0]}`, error);
            }
        }
    }
    async closeAndReset() {
        //close and clean up all sockets, modals,... and reset all states to initial values
        this.updateIsMessagesModalVisible(false);
        this.updateIsParticipantsModalVisible(false);
        this.updateIsWaitingModalVisible(false);
        this.updateIsRequestsModalVisible(false);
        this.updateIsCoHostModalVisible(false);
        this.updateIsSettingsModalVisible(false);
        this.updateIsDisplaySettingsModalVisible(false);
        this.updateIsMediaSettingsModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsShareEventModalVisible(false);
        this.updateIsConfirmExitModalVisible(false);
        await this.disconnectAllSockets(this.consume_sockets.value);
        await this.updateStatesToInitialValues();
        this.updateMeetingProgressTime('00:00:00');
        this.updateMeetingElapsedTime(0);
        this.updateRecordingProgressTime('00:00:00');
        this.updateRecordElapsedTime(0);
        this.updateShowRecordButtons(false);
        this.updateIsConfigureWhiteboardModalVisible(false);
        this.updateIsWhiteboardModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsRecordingModalVisible(false);
        this.updateIsPollModalVisible(false);
        this.updateIsBreakoutRoomsModalVisible(false);
        this.updateIsBackgroundModalVisible(false);
        this.updateIsLoadingModalVisible(false);
        this.updateIsConfirmHereModalVisible(false);
        await sleep({ ms: 500 });
        this.updateValidated(false);
        //if on web, reload the page
        window.location.reload();
    }
    computeDimensionsMethod = ({ containerWidthFraction = 1, containerHeightFraction = 1, mainSize, doStack = true, defaultFraction, }) => {
        const parentWidth = window.innerWidth * containerWidthFraction;
        const parentHeight = window.innerHeight * containerHeightFraction * defaultFraction;
        let isWideScreen = parentWidth >= 768;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        const dimensions = this.calculateDimensions({
            parentWidth,
            parentHeight,
            isWideScreen,
            mainSize,
            doStack,
        });
        return dimensions;
    };
    calculateDimensions({ parentWidth, parentHeight, isWideScreen, mainSize, doStack, }) {
        if (doStack) {
            return isWideScreen
                ? {
                    mainHeight: Math.floor(parentHeight),
                    otherHeight: Math.floor(parentHeight),
                    mainWidth: Math.floor((mainSize / 100) * parentWidth),
                    otherWidth: Math.floor(((100 - mainSize) / 100) * parentWidth),
                }
                : {
                    mainHeight: Math.floor((mainSize / 100) * parentHeight),
                    otherHeight: Math.floor(((100 - mainSize) / 100) * parentHeight),
                    mainWidth: Math.floor(parentWidth),
                    otherWidth: Math.floor(parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(parentHeight),
                otherHeight: Math.floor(parentHeight),
                mainWidth: Math.floor(parentWidth),
                otherWidth: Math.floor(parentWidth),
            };
        }
    }
    handleOrientationChange() {
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('orientationchange', this.handleResize.bind(this));
    }
    setupResizeListener() {
        this.handleResize();
    }
    orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    async joinRoom(data) {
        const { socket, roomName, islevel, member, sec, apiUserName } = data;
        try {
            const response = await this.joinRoomClient.joinRoomClient({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
            return response;
        }
        catch (error) {
            console.log('Error joining room:', error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    async join_Room({ socket, roomName, islevel, member, sec, apiUserName, isLocal = false, }) {
        let data;
        if (!isLocal) {
            data = await this.joinRoom({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
        }
        else {
            const localData = await this.joinLocalRoom.joinLocalRoom({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    connectLocalSocket: this.socketManager.connectLocalSocket,
                    updateSocket: this.updateSocket,
                    updateLocalSocket: this.updateLocalSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                checkConnect: this.localLink.length > 0 &&
                    this.connectMediaSFU === true &&
                    !this.link.value.includes('mediasfu.com'),
                localLink: this.localLink,
                joinMediaSFURoom: this.joinMediaSFURoom,
            });
            data = await createResponseJoinRoom({ localRoom: localData });
        }
        const updateAndComplete = async (data) => {
            // Update room parameters
            try {
                // Check if roomRecvIPs is not empty
                if (!data.roomRecvIPs || data.roomRecvIPs.length === 0) {
                    data.roomRecvIPs = ['none'];
                    if (this.link.value !== "" &&
                        this.link.value.includes("mediasfu.com") &&
                        !isLocal) {
                        // Community Edition Only
                        await this.receiveAllPipedTransports.receiveAllPipedTransports({
                            community: true,
                            nsock: this.getUpdatedAllParams().socket,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                }
                this.updateRoomParametersClient.updateRoomParametersClient({
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                        data: data,
                    },
                });
                if (data.isHost) {
                    this.updateIslevel('2');
                }
                else {
                    // Issue with isHost for local room
                    if (islevel !== '2') {
                        this.updateIslevel('1');
                    }
                }
                if (data.secureCode && data.secureCode !== '') {
                    this.updateAdminPasscode(data.secureCode);
                }
                if (data.rtpCapabilities) {
                    try {
                        const device_ = await this.createDeviceClient.createDeviceClient({
                            rtpCapabilities: data.rtpCapabilities,
                        });
                        if (device_) {
                            this.device.next(device_);
                        }
                    }
                    catch (error) {
                        console.error('Error creating device:', error);
                    }
                }
            }
            catch (error) {
                console.error('Error in updateAndComplete:', error);
            }
        };
        if (data && data.success) {
            if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && isLocal) {
                this.roomData.next(data);
                return;
            }
            else if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && !isLocal) {
                // Update roomData
                if (this.roomData.value) {
                    // Updating only the recording and meeting room parameters
                    this.roomData.value.recordingParams = data.recordingParams;
                    this.roomData.value.meetingRoomParams = data.meetingRoomParams;
                    this.roomData.next(this.roomData.value);
                }
                else {
                    this.roomData.next(data);
                }
            }
            else {
                // Update roomData
                this.roomData.next(data);
                if (!this.link.value.includes('mediasfu.com')) {
                    this.roomData.value.meetingRoomParams = data.meetingRoomParams;
                }
            }
            await updateAndComplete(data);
        }
        else {
            if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && !isLocal) {
                // Join local room only
                if (this.roomData.value) {
                    await updateAndComplete(this.roomData.value);
                }
                return;
            }
            // Might be a wrong room name or room is full or other error; check reason in data object if available
            try {
                if (this.showAlert && data?.reason) {
                    this.showAlert({
                        message: data.reason,
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
            catch (error) {
                /* handle error */
            }
        }
    }
    onParticipantsFilterChange = (value) => {
        if (value && value.length > 0) {
            this.filteredParticipants.next(this.participants.value.filter((participant) => participant.name.toLowerCase().includes(value.toLowerCase())));
            this.participantsCounter.next(this.filteredParticipants.value.length);
        }
        else {
            this.filteredParticipants.next(this.participants.value);
            this.participantsCounter.next(this.participants.value.length);
        }
    };
    updateStatesToInitialValues = async () => {
        const initialValues = initialValuesState;
        const updateFunctions = this.getAllParams();
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                const updateFunctionName = `update${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const updateFunction = updateFunctions[updateFunctionName];
                if (typeof updateFunction === 'function') {
                    try {
                        updateFunction(initialValues[key]);
                    }
                    catch {
                        /* handle error */
                    }
                }
            }
        }
    };
    faRecordVinyl = faRecordVinyl;
    faPlayCircle = faPlayCircle;
    faPauseCircle = faPauseCircle;
    faStopCircle = faStopCircle;
    faDotCircle = faDotCircle;
    faCog = faCog;
    faUsers = faUsers;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faSync = faSync;
    faPhone = faPhone;
    faShareAlt = faShareAlt;
    faComments = faComments;
    faChartBar = faChartBar;
    onCloseMenuModal = () => {
        this.updateIsMenuModalVisible(false);
    };
    onEventSettingsClose = () => {
        this.updateIsSettingsModalVisible(false);
    };
    onCoHostClose = () => {
        this.updateIsCoHostModalVisible(false);
    };
    onMediaSettingsClose = () => {
        this.updateIsMediaSettingsModalVisible(false);
    };
    onDisplaySettingsClose = () => {
        this.updateIsDisplaySettingsModalVisible(false);
    };
    onPollClose = () => {
        this.updateIsPollModalVisible(false);
    };
    onBreakoutRoomsClose = () => {
        this.updateIsBreakoutRoomsModalVisible(false);
    };
    onConfigureWhiteboardClose = () => {
        this.updateIsConfigureWhiteboardModalVisible(false);
    };
    onMessagesClose = () => {
        this.updateIsMessagesModalVisible(false);
    };
    onRecordingClose = () => {
        this.updateIsRecordingModalVisible(false);
    };
    onParticipantsClose = () => {
        this.updateIsParticipantsModalVisible(false);
    };
    onBackgroundClose = () => {
        this.updateIsBackgroundModalVisible(false);
    };
    onConfirmExitClose = () => {
        this.updateIsConfirmExitModalVisible(false);
    };
    onConfirmHereClose = () => {
        this.updateIsConfirmHereModalVisible(false);
    };
    onScreenboardClose = () => {
        this.updateIsScreenboardModalVisible(false);
    };
    onShareEventClose = () => {
        this.updateIsShareEventModalVisible(false);
    };
    onAlertHide = () => {
        this.updateAlertVisible(false);
    };
    recordTimerWidget = {
        component: RecordTimerWidget,
        injector: this.createInjector({ recordingProgressTime: this.recordingProgressTime.value }),
    };
    updateRecordTimerWidget = (recordingProgressTime = this.recordingProgressTime.value) => {
        const recordTimerWidget = {
            component: RecordTimerWidget,
            injector: this.createInjector({ recordingProgressTime: recordingProgressTime }),
        };
        this.recordTimerWidget = { ...recordTimerWidget };
        this.cdr.markForCheck();
        return recordTimerWidget;
    };
    recordButton = [
        {
            icon: this.faRecordVinyl,
            text: 'Record',
            onPress: () => {
                this.launchRecording.launchRecording({
                    updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                    isRecordingModalVisible: this.isRecordingModalVisible.value,
                    showAlert: this.showAlert.bind(this),
                    stopLaunchRecord: this.stopLaunchRecord.value,
                    canLaunchRecord: this.canLaunchRecord.value,
                    recordingAudioSupport: this.recordingAudioSupport.value,
                    recordingVideoSupport: this.recordingVideoSupport.value,
                    updateCanRecord: this.updateCanRecord.bind(this),
                    updateClearedToRecord: this.updateClearedToRecord.bind(this),
                    recordStarted: this.recordStarted.value,
                    recordPaused: this.recordPaused.value,
                    localUIMode: this.localUIMode.value,
                });
            },
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
    ];
    recordButtons = [];
    recordButtonsArray = [
        {
            icon: this.faPlayCircle,
            active: () => !this.recordPaused.value,
            onPress: () => this.updateRecording.updateRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            alternateIcon: this.faPauseCircle,
            show: () => true,
        },
        {
            icon: this.faStopCircle,
            active: () => false,
            onPress: () => this.stopRecording.stopRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: () => this.updateRecordTimerWidget(),
            show: () => true,
            active: () => false,
        },
        {
            icon: this.faDotCircle,
            active: () => false,
            onPress: () => console.log('Status pressed'),
            activeColor: 'black',
            inActiveColor: () => (this.recordPaused.value ? 'yellow' : 'red'),
            show: () => true,
        },
        {
            icon: this.faCog,
            active: () => false,
            onPress: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
    ];
    async updateRecordButtons() {
        const recordButtons = this.recordButtonsArray.map((button) => {
            return {
                ...button,
                active: typeof button.active === 'function' ? button.active() : button.active,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
                activeColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
                inActiveColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
            };
        });
        this.recordButtons = [...recordButtons];
        await this.updateMenuRecordWidget(recordButtons);
        this.updateControlBroadcastButtons();
        this.cdr.markForCheck();
    }
    // Create instances of the custom widgets
    messageWidget = {
        component: MessageWidget,
        injector: this.createInjector({
            icon: this.faComments,
            showBadge: this.showMessagesBadge.value,
            badgeValue: 1,
            iconColor: 'black',
        }),
    };
    menuRecordWidget = {
        component: MenuRecordWidget,
        injector: this.createInjector({
            buttons: this.recordButtons,
            showAspect: true,
            direction: 'horizontal',
        }),
    };
    updateMenuRecordWidget = (recordButtons = this.recordButtons) => {
        const menuRecordWidget = {
            component: MenuRecordWidget,
            injector: this.createInjector({
                buttons: recordButtons,
                showAspect: true,
                direction: 'horizontal',
            }),
        };
        this.menuRecordWidget = { ...menuRecordWidget };
        this.cdr.markForCheck();
        return menuRecordWidget;
    };
    menuParticipantsWidget = {
        component: MenuParticipantsWidget,
        injector: this.createInjector({
            icon: this.faChartBar,
            participantsCounter: this.participantsCounter.value,
            iconColor: 'black',
        }),
    };
    updateMenuParticipantsWidget = (count = this.participantsCounter.value) => {
        const menuParticipantsWidget = {
            component: MenuParticipantsWidget,
            injector: this.createInjector({
                icon: this.faChartBar,
                participantsCounter: count,
                iconColor: 'black',
            }),
        };
        this.menuParticipantsWidget = { ...menuParticipantsWidget };
        this.cdr.markForCheck();
        return menuParticipantsWidget;
    };
    controlBroadcastButtons = [];
    updateControlBroadcastButtons() {
        this.controlBroadcastButtons = this.controlBroadcastButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                active: typeof button.active === 'function' ? button.active() : button.active,
            };
        });
    }
    controlBroadcastButtonsArray = [
        {
            icon: this.faUsers,
            active: true,
            alternateIcon: this.faUsers,
            onPress: () => this.launchParticipants.launchParticipants({
                updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
                isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faShareAlt,
            active: true,
            alternateIcon: this.faShareAlt,
            onPress: () => this.updateIsShareEventModalVisible(!this.isShareEventModalVisible.value),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: this.messageWidget,
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faSync,
            active: true,
            alternateIcon: this.faSync,
            onPress: () => this.switchVideoAlt.switchVideoAlt({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: () => this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            show: () => this.islevel.value == '2',
            activeColor: 'green',
            inActiveColor: 'red',
        },
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: () => this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: () => this.islevel.value == '2',
        },
        {
            customComponent: () => this.menuParticipantsWidget,
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: () => true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => console.log('End Call pressed'),
            activeColor: 'transparent',
            inActiveColor: 'transparent',
            backgroundColor: { default: 'transparent' },
            show: () => false,
        },
    ];
    async connect_Socket(apiUserName, token, skipSockets = false) {
        const socketDefault = this.socket.value;
        const socketAlt = this.connectMediaSFU && this.localSocket.value && this.localSocket.value.id
            ? this.localSocket.value
            : socketDefault;
        if (this.socket.value && this.socket.value.id) {
            if (!skipSockets) {
                // Event listeners on socketDefault
                socketDefault.on('disconnect', async () => {
                    await this.disconnect.disconnect({
                        showAlert: this.showAlert.bind(this),
                        redirectURL: this.redirectURL.value,
                        onWeb: true,
                        updateValidated: this.updateValidated.bind(this),
                    });
                    if (this.videoAlreadyOn.value) {
                        await this.clickVideo.clickVideo({
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    if (this.audioAlreadyOn.value) {
                        await this.clickAudio.clickAudio({
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    await this.closeAndReset();
                });
                socketDefault.on('allMembers', async (membersData) => {
                    if (membersData) {
                        await this.allMembers.allMembers({
                            apiUserName: apiUserName,
                            apiKey: '', //not recommended - use apiToken instead. Use for testing/development only
                            apiToken: token,
                            members: membersData.members,
                            requestss: membersData.requests ? membersData.requests : this.requestList.value,
                            coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                            coHostRes: membersData.coHostResponsibilities
                                ? membersData.coHostResponsibilities
                                : this.coHostResponsibility.value,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                            consume_sockets: this.consume_sockets.value,
                        });
                    }
                });
                socketDefault.on('allMembersRest', async (membersData) => {
                    if (membersData) {
                        await this.allMembersRest.allMembersRest({
                            apiUserName: apiUserName,
                            apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                            members: membersData.members,
                            apiToken: token,
                            settings: membersData.settings,
                            coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                            coHostRes: membersData.coHostResponsibilities
                                ? membersData.coHostResponsibilities
                                : this.coHostResponsibility.value,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                            consume_sockets: this.consume_sockets.value,
                        });
                    }
                });
                socketDefault.on('personJoined', async ({ name }) => {
                    this.personJoined.personJoined({
                        name,
                        showAlert: this.showAlert.bind(this),
                    });
                });
                socketDefault.on('ban', async ({ name }) => {
                    await this.banParticipant.banParticipant({
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('producer-media-paused', async ({ producerId, kind, name, }) => {
                    await this.producerMediaPaused.producerMediaPaused({
                        producerId,
                        kind,
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('producer-media-resumed', async ({ kind, name }) => {
                    await this.producerMediaResumed.producerMediaResumed({
                        kind,
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('producer-media-closed', async ({ producerId, kind, }) => {
                    if (producerId && kind) {
                        await this.producerMediaClosed.producerMediaClosed({
                            producerId,
                            kind,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                });
                socketDefault.on('meetingEnded', async () => {
                    await this.meetingEnded.meetingEnded({
                        showAlert: this.showAlert.bind(this),
                        redirectURL: this.redirectURL.value,
                        onWeb: true,
                        eventType: this.eventType.value,
                        updateValidated: this.updateValidated.bind(this),
                    });
                    if (this.videoAlreadyOn.value) {
                        await this.clickVideo.clickVideo({
                            parameters: {
                                ...this.getAllParams(),
                                ...this.mediaSFUFunctions(),
                            },
                        });
                    }
                    if (this.audioAlreadyOn.value) {
                        await this.clickAudio.clickAudio({
                            parameters: {
                                ...this.getAllParams(),
                                ...this.mediaSFUFunctions(),
                            },
                        });
                    }
                    await this.closeAndReset();
                });
                socketDefault.on('disconnectUserSelf', async () => {
                    await this.disconnectUserSelf.disconnectUserSelf({
                        socket: socketDefault,
                        member: this.member.value,
                        roomName: this.roomName.value,
                    });
                });
                socketDefault.on('receiveMessage', async ({ message }) => {
                    await this.receiveMessage.receiveMessage({
                        message,
                        messages: this.messages.value,
                        participantsAll: this.participantsAll.value,
                        member: this.member.value,
                        eventType: this.eventType.value,
                        islevel: this.islevel.value,
                        coHost: this.coHost.value,
                        updateMessages: this.updateMessages.bind(this),
                        updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
                    });
                });
                socketDefault.on('meetingTimeRemaining', async ({ timeRemaining }) => {
                    await this.meetingTimeRemaining.meetingTimeRemaining({
                        timeRemaining,
                        showAlert: this.showAlert.bind(this),
                        eventType: this.eventType.value,
                    });
                });
                socketDefault.on('meetingStillThere', async () => {
                    this.meetingStillThere.meetingStillThere({
                        updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
                    });
                });
                socketDefault.on('updateConsumingDomains', async ({ domains, alt_domains }) => {
                    await this.updateConsumingDomains.updateConsumingDomains({
                        domains,
                        alt_domains,
                        apiUserName,
                        apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                        apiToken: token,
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                });
            }
            if (skipSockets) {
                // Remove specific event listeners from socketDefault and socketAlt
                const events = [
                    'roomRecordParams',
                    'startRecords',
                    'reInitiateRecording',
                    'RecordingNotice',
                    'timeLeftRecording',
                    'stoppedRecording',
                ];
                events.forEach((event) => {
                    socketDefault.off(event);
                    socketAlt.off(event);
                });
            }
            socketAlt.on('roomRecordParams', async ({ recordParams }) => {
                this.roomRecordParams.roomRecordParams({
                    recordParams,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            socketAlt.on('startRecords', async () => {
                await this.startRecords.startRecords({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: socketAlt,
                });
            });
            socketAlt.on('reInitiateRecording', async () => {
                await this.reInitiateRecording.reInitiateRecording({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: socketAlt,
                    adminRestrictSetting: this.adminRestrictSetting.value,
                });
            });
            socketAlt.on('RecordingNotice', async ({ state, userRecordingParam, pauseCount, timeDone }) => {
                await this.recordingNotice.RecordingNotice({
                    state,
                    userRecordingParam,
                    pauseCount,
                    timeDone,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            socketAlt.on('timeLeftRecording', async ({ timeLeft }) => {
                this.timeLeftRecording.timeLeftRecording({
                    timeLeft,
                    showAlert: this.showAlert.bind(this),
                });
            });
            socketAlt.on('stoppedRecording', async ({ state, reason }) => {
                await this.stoppedRecording.stoppedRecording({
                    state,
                    reason,
                    showAlert: this.showAlert.bind(this),
                });
            });
            if (this.localLink !== "" && socketDefault && !skipSockets) {
                await this.join_Room({
                    socket: socketDefault,
                    roomName: this.roomName.value,
                    islevel: this.islevel.value,
                    member: this.member.value,
                    sec: token,
                    apiUserName: apiUserName,
                    isLocal: true,
                });
            }
            // Check if localSocket has changed
            const localChanged = this.localSocket.value && this.localSocket.value.id && this.localSocket.value.id !== socketAlt.id;
            if (!skipSockets && localChanged) {
                // Re-call connect_Socket with skipSockets = true
                await this.connect_Socket(apiUserName, token, true);
                await sleep({ ms: 1000 });
                this.updateIsLoadingModalVisible(false);
                return socketDefault;
            }
            else {
                if (this.link.value !== '' && this.link.value.includes('mediasfu.com')) {
                    // Token might be different for local room
                    const token = this.apiToken.value;
                    await this.join_Room({
                        socket: this.connectMediaSFU && socketAlt && socketAlt.id ? socketAlt : socketDefault,
                        roomName: this.roomName.value,
                        islevel: this.islevel.value,
                        member: this.member.value,
                        sec: token,
                        apiUserName: apiUserName,
                    });
                }
                await this.receiveRoomMessages.receiveRoomMessages({
                    socket: socketDefault,
                    roomName: this.roomName.value,
                    updateMessages: this.updateMessages.bind(this),
                });
                if (!skipSockets) {
                    await this.prepopulateUserMedia.prepopulateUserMedia({
                        name: this.hostLabel.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                return socketDefault;
            }
        }
        else {
            return null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediasfuBroadcast, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.Injector }, { token: UpdateMiniCardsGrid }, { token: MixStreams }, { token: DispStreams }, { token: StopShareScreen }, { token: CheckScreenShare }, { token: StartShareScreen }, { token: RequestScreenShare }, { token: ReorderStreams }, { token: PrepopulateUserMedia }, { token: GetVideos }, { token: RePort }, { token: Trigger }, { token: ConsumerResume }, { token: ConnectSendTransport }, { token: ConnectSendTransportAudio }, { token: ConnectSendTransportVideo }, { token: ConnectSendTransportScreen }, { token: ProcessConsumerTransports }, { token: ResumePauseStreams }, { token: Readjust }, { token: CheckGrid }, { token: GetEstimate }, { token: CalculateRowsAndColumns }, { token: AddVideosGrid }, { token: OnScreenChanges }, { token: ChangeVids }, { token: CompareActiveNames }, { token: CompareScreenStates }, { token: CreateSendTransport }, { token: ResumeSendTransportAudio }, { token: ReceiveAllPipedTransports }, { token: DisconnectSendTransportVideo }, { token: DisconnectSendTransportAudio }, { token: DisconnectSendTransportScreen }, { token: GetPipedProducersAlt }, { token: SignalNewConsumerTransport }, { token: ConnectRecvTransport }, { token: ReUpdateInter }, { token: UpdateParticipantAudioDecibels }, { token: CloseAndResize }, { token: AutoAdjust }, { token: SwitchUserVideoAlt }, { token: SwitchUserVideo }, { token: SwitchUserAudio }, { token: GetDomains }, { token: FormatNumber }, { token: ConnectIps }, { token: ConnectLocalIps }, { token: CreateDeviceClient }, { token: CaptureCanvasStream }, { token: ResumePauseAudioStreams }, { token: ProcessConsumerTransportsAudio }, { token: LaunchRecording }, { token: StartRecording }, { token: ConfirmRecording }, { token: LaunchParticipants }, { token: LaunchMessages }, { token: LaunchConfirmExit }, { token: StartMeetingProgressTimer }, { token: UpdateRecording }, { token: StopRecording }, { token: PersonJoined }, { token: RoomRecordParams }, { token: BanParticipant }, { token: ProducerMediaPaused }, { token: ProducerMediaResumed }, { token: ProducerMediaClosed }, { token: MeetingEnded }, { token: DisconnectUserSelf }, { token: ReceiveMessage }, { token: MeetingTimeRemaining }, { token: MeetingStillThere }, { token: StartRecords }, { token: ReInitiateRecording }, { token: RecordingNotice }, { token: TimeLeftRecording }, { token: StoppedRecording }, { token: AllMembers }, { token: AllMembersRest }, { token: Disconnect }, { token: SocketManager }, { token: JoinRoomClient }, { token: JoinLocalRoom }, { token: UpdateRoomParametersClient }, { token: ClickVideo }, { token: ClickAudio }, { token: ClickScreenShare }, { token: SwitchVideoAlt }, { token: StreamSuccessVideo }, { token: StreamSuccessAudio }, { token: StreamSuccessScreen }, { token: StreamSuccessAudioSwitch }, { token: CheckPermission }, { token: UpdateConsumingDomains }, { token: ReceiveRoomMessages }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MediasfuBroadcast, isStandalone: true, selector: "app-mediasfu-broadcast", inputs: { PrejoinPage: "PrejoinPage", localLink: "localLink", connectMediaSFU: "connectMediaSFU", credentials: "credentials", useLocalUIMode: "useLocalUIMode", seedData: "seedData", useSeed: "useSeed", imgSrc: "imgSrc", sourceParameters: "sourceParameters", updateSourceParameters: "updateSourceParameters", returnUI: "returnUI", noUIPreJoinOptions: "noUIPreJoinOptions", joinMediaSFURoom: "joinMediaSFURoom", createMediaSFURoom: "createMediaSFURoom" }, host: { listeners: { "window:resize": "handleResize()", "window:orientationchange": "handleResize()" } }, providers: [CookieService], ngImport: i0, template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <!-- Conditional Rendering: PrejoinPage or Main Content -->
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component *ngIf="returnUI">
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <!-- Main Screen Component -->
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <!-- Main Grid Component -->
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                >
                </app-flexible-video>

                <!-- Control Buttons for Broadcast -->
                <app-control-buttons-component-touch
                  [buttons]="controlBroadcastButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'broadcast'"
                ></app-control-buttons-component-touch>

                <!-- Recording Buttons -->
                <app-control-buttons-component-touch
                  [buttons]="recordButton"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    !showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>

                <app-control-buttons-component-touch
                  [buttons]="recordButtons"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>

                <!-- AudioGrid -->
                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>
              </app-main-grid-component>

              <!-- Other Grid Component is not included in MediasfuBroadcast -->
            </app-main-screen-component>
          </app-main-aspect-component>
        </app-main-container-component>
      </ng-template>

      <!-- Modals to include -->
      <ng-container *ngIf="returnUI">
      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
          updateParticipants: updateParticipants,
          updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
          updateDirectMessageDetails: updateDirectMessageDetails,
          updateStartDirectMessage: updateStartDirectMessage,
          updateIsMessagesModalVisible: updateIsMessagesModalVisible,
          showAlert: showAlert,
          filteredParticipants: filteredParticipants.value,
          participants: filteredParticipants.value,
          roomName: roomName.value,
          islevel: islevel.value,
          member: member.value,
          coHostResponsibility: coHostResponsibility.value,
          coHost: coHost.value,
          eventType: eventType.value,
          startDirectMessage: startDirectMessage.value,
          directMessageDetails: directMessageDetails.value,
          socket: socket.value,
          getUpdatedAllParams: getUpdatedAllParams,
        }"
      ></app-participants-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
        [localLink]="localLink"
      ></app-share-event-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </ng-container>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: AlertComponent, selector: "app-alert-component", inputs: ["visible", "message", "type", "duration", "textColor", "onHide"] }, { kind: "component", type: AudioGrid, selector: "app-audio-grid", inputs: ["componentsToRender"] }, { kind: "component", type: ControlButtonsComponentTouch, selector: "app-control-buttons-component-touch", inputs: ["buttons", "position", "location", "direction", "buttonsContainerStyle", "showAspect"] }, { kind: "component", type: FlexibleVideo, selector: "app-flexible-video", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "showAspect", "backgroundColor", "Screenboard", "annotateScreenStream", "localStreamScreen"] }, { kind: "component", type: LoadingModal, selector: "app-loading-modal", inputs: ["isVisible", "backgroundColor", "displayColor"] }, { kind: "component", type: ConfirmExitModal, selector: "app-confirm-exit-modal", inputs: ["isConfirmExitModalVisible", "onConfirmExitClose", "position", "backgroundColor", "exitEventOnConfirm", "member", "ban", "roomName", "socket", "islevel"] }, { kind: "component", type: MessagesModal, selector: "app-messages-modal", inputs: ["isMessagesModalVisible", "onMessagesClose", "onSendMessagePress", "messages", "position", "backgroundColor", "activeTabBackgroundColor", "eventType", "member", "islevel", "coHostResponsibility", "coHost", "startDirectMessage", "directMessageDetails", "updateStartDirectMessage", "updateDirectMessageDetails", "showAlert", "roomName", "socket", "chatSetting"] }, { kind: "component", type: ConfirmHereModal, selector: "app-confirm-here-modal", inputs: ["isConfirmHereModalVisible", "position", "backgroundColor", "displayColor", "onConfirmHereClose", "countdownDuration", "socket", "localSocket", "roomName", "member"] }, { kind: "component", type: ShareEventModal, selector: "app-share-event-modal", inputs: ["backgroundColor", "isShareEventModalVisible", "onShareEventClose", "roomName", "adminPasscode", "islevel", "position", "shareButtons", "eventType", "localLink"] }, { kind: "component", type: ParticipantsModal, selector: "app-participants-modal", inputs: ["isParticipantsModalVisible", "onParticipantsClose", "onParticipantsFilterChange", "participantsCounter", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "parameters", "position", "backgroundColor"] }, { kind: "component", type: RecordingModal, selector: "app-recording-modal", inputs: ["isRecordingModalVisible", "onClose", "backgroundColor", "position", "confirmRecording", "startRecording", "parameters"] }, { kind: "component", type: MainAspectComponent, selector: "app-main-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "updateIsWideScreen", "updateIsMediumScreen", "updateIsSmallScreen"] }, { kind: "component", type: MainContainerComponent, selector: "app-main-container-component", inputs: ["backgroundColor", "containerWidthFraction", "containerHeightFraction", "marginLeft", "marginRight", "marginTop", "marginBottom", "padding"] }, { kind: "component", type: MainGridComponent, selector: "app-main-grid-component", inputs: ["backgroundColor", "mainSize", "height", "width", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: MainScreenComponent, selector: "app-main-screen-component", inputs: ["mainSize", "doStack", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "showControls", "updateComponentSizes"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediasfuBroadcast, decorators: [{
            type: Component,
            args: [{ selector: 'app-mediasfu-broadcast', imports: [
                        CommonModule,
                        AlertComponent,
                        AudioGrid,
                        ControlButtonsComponentTouch,
                        FlexibleVideo,
                        LoadingModal,
                        ConfirmExitModal,
                        MessagesModal,
                        ConfirmHereModal,
                        ShareEventModal,
                        ParticipantsModal,
                        RecordingModal,
                        MainAspectComponent,
                        MainContainerComponent,
                        MainGridComponent,
                        MainScreenComponent,
                    ], template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <!-- Conditional Rendering: PrejoinPage or Main Content -->
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component *ngIf="returnUI">
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <!-- Main Screen Component -->
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <!-- Main Grid Component -->
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                >
                </app-flexible-video>

                <!-- Control Buttons for Broadcast -->
                <app-control-buttons-component-touch
                  [buttons]="controlBroadcastButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'broadcast'"
                ></app-control-buttons-component-touch>

                <!-- Recording Buttons -->
                <app-control-buttons-component-touch
                  [buttons]="recordButton"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    !showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>

                <app-control-buttons-component-touch
                  [buttons]="recordButtons"
                  [direction]="'horizontal'"
                  [showAspect]="
                    eventType.value === 'broadcast' &&
                    showRecordButtons.value &&
                    islevel.value === '2'
                  "
                  [location]="'bottom'"
                  [position]="'middle'"
                ></app-control-buttons-component-touch>

                <!-- AudioGrid -->
                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>
              </app-main-grid-component>

              <!-- Other Grid Component is not included in MediasfuBroadcast -->
            </app-main-screen-component>
          </app-main-aspect-component>
        </app-main-container-component>
      </ng-template>

      <!-- Modals to include -->
      <ng-container *ngIf="returnUI">
      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
          updateParticipants: updateParticipants,
          updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
          updateDirectMessageDetails: updateDirectMessageDetails,
          updateStartDirectMessage: updateStartDirectMessage,
          updateIsMessagesModalVisible: updateIsMessagesModalVisible,
          showAlert: showAlert,
          filteredParticipants: filteredParticipants.value,
          participants: filteredParticipants.value,
          roomName: roomName.value,
          islevel: islevel.value,
          member: member.value,
          coHostResponsibility: coHostResponsibility.value,
          coHost: coHost.value,
          eventType: eventType.value,
          startDirectMessage: startDirectMessage.value,
          directMessageDetails: directMessageDetails.value,
          socket: socket.value,
          getUpdatedAllParams: getUpdatedAllParams,
        }"
      ></app-participants-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
        [localLink]="localLink"
      ></app-share-event-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </ng-container>
    </div>
  `, providers: [CookieService] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: UpdateMiniCardsGrid }, { type: MixStreams }, { type: DispStreams }, { type: StopShareScreen }, { type: CheckScreenShare }, { type: StartShareScreen }, { type: RequestScreenShare }, { type: ReorderStreams }, { type: PrepopulateUserMedia }, { type: GetVideos }, { type: RePort }, { type: Trigger }, { type: ConsumerResume }, { type: ConnectSendTransport }, { type: ConnectSendTransportAudio }, { type: ConnectSendTransportVideo }, { type: ConnectSendTransportScreen }, { type: ProcessConsumerTransports }, { type: ResumePauseStreams }, { type: Readjust }, { type: CheckGrid }, { type: GetEstimate }, { type: CalculateRowsAndColumns }, { type: AddVideosGrid }, { type: OnScreenChanges }, { type: ChangeVids }, { type: CompareActiveNames }, { type: CompareScreenStates }, { type: CreateSendTransport }, { type: ResumeSendTransportAudio }, { type: ReceiveAllPipedTransports }, { type: DisconnectSendTransportVideo }, { type: DisconnectSendTransportAudio }, { type: DisconnectSendTransportScreen }, { type: GetPipedProducersAlt }, { type: SignalNewConsumerTransport }, { type: ConnectRecvTransport }, { type: ReUpdateInter }, { type: UpdateParticipantAudioDecibels }, { type: CloseAndResize }, { type: AutoAdjust }, { type: SwitchUserVideoAlt }, { type: SwitchUserVideo }, { type: SwitchUserAudio }, { type: GetDomains }, { type: FormatNumber }, { type: ConnectIps }, { type: ConnectLocalIps }, { type: CreateDeviceClient }, { type: CaptureCanvasStream }, { type: ResumePauseAudioStreams }, { type: ProcessConsumerTransportsAudio }, { type: LaunchRecording }, { type: StartRecording }, { type: ConfirmRecording }, { type: LaunchParticipants }, { type: LaunchMessages }, { type: LaunchConfirmExit }, { type: StartMeetingProgressTimer }, { type: UpdateRecording }, { type: StopRecording }, { type: PersonJoined }, { type: RoomRecordParams }, { type: BanParticipant }, { type: ProducerMediaPaused }, { type: ProducerMediaResumed }, { type: ProducerMediaClosed }, { type: MeetingEnded }, { type: DisconnectUserSelf }, { type: ReceiveMessage }, { type: MeetingTimeRemaining }, { type: MeetingStillThere }, { type: StartRecords }, { type: ReInitiateRecording }, { type: RecordingNotice }, { type: TimeLeftRecording }, { type: StoppedRecording }, { type: AllMembers }, { type: AllMembersRest }, { type: Disconnect }, { type: SocketManager }, { type: JoinRoomClient }, { type: JoinLocalRoom }, { type: UpdateRoomParametersClient }, { type: ClickVideo }, { type: ClickAudio }, { type: ClickScreenShare }, { type: SwitchVideoAlt }, { type: StreamSuccessVideo }, { type: StreamSuccessAudio }, { type: StreamSuccessScreen }, { type: StreamSuccessAudioSwitch }, { type: CheckPermission }, { type: UpdateConsumingDomains }, { type: ReceiveRoomMessages }], propDecorators: { PrejoinPage: [{
                type: Input
            }], localLink: [{
                type: Input
            }], connectMediaSFU: [{
                type: Input
            }], credentials: [{
                type: Input
            }], useLocalUIMode: [{
                type: Input
            }], seedData: [{
                type: Input
            }], useSeed: [{
                type: Input
            }], imgSrc: [{
                type: Input
            }], sourceParameters: [{
                type: Input
            }], updateSourceParameters: [{
                type: Input
            }], returnUI: [{
                type: Input
            }], noUIPreJoinOptions: [{
                type: Input
            }], joinMediaSFURoom: [{
                type: Input
            }], createMediaSFURoom: [{
                type: Input
            }], handleResize: [{
                type: HostListener,
                args: ['window:resize']
            }, {
                type: HostListener,
                args: ['window:orientationchange']
            }] } });

/**
 * Component for managing webinars in the MediaSFU environment.
 *
 * @selector app-mediasfu-webinar
 * @standalone true
 * @imports [RouterOutlet, CommonModule, BreakoutRoomsModal, BackgroundModal, CoHostModal, AlertComponent, AudioGrid, ControlButtonsAltComponent, ControlButtonsComponent, FlexibleGrid, FlexibleVideo, LoadingModal, Pagination, SubAspectComponent, DisplaySettingsModal, EventSettingsModal, ConfirmExitModal, MediaSettingsModal, MenuModal, MessagesModal, ConfirmHereModal, ShareEventModal, WelcomePage, ParticipantsModal, PollModal, RecordingModal, RequestsModal, MainAspectComponent, MainContainerComponent, MainGridComponent, MainScreenComponent, OtherGridComponent, Screenboard, ScreenboardModal, Whiteboard, ConfigureWhiteboardModal, WaitingRoomModal, MenuWidget, MessageWidget, MenuRecordWidget, RecordTimerWidget, MenuParticipantsWidget, ScreenShareWidget]
 *
 * @template
 * This component's template includes:
 * - A conditional PrejoinPage displayed before main content for user preparation.
 * - The main screen layout with flexible configurations for video, control buttons, and layout grids.
 * - Modals for participant, settings, polling, and media interactions.
 *
 * @input {any} PrejoinPage - Component for the prejoin page, defaults to `WelcomePage`.
 * @input {MediasfuWebinarOptions} options - Configuration options for the component.
 * @input {boolean} connectMediaSFU - Flag to enable/disable connection to the MediaSFU server.
 * @input {string} localLink - Local link for the Community Edition server.
 * @input {{ apiUserName: string; apiKey: string }} credentials - API credentials for secure access.
 * @input {boolean} useLocalUIMode - Flag to toggle local UI settings.
 * @input {SeedData} seedData - Seed data for initializing the component with specific configurations.
 * @input {boolean} useSeed - Enable/disable use of seed data.
 * @input {string} imgSrc - URL for branding images or logos.
 * @input {object} sourceParameters - Additional parameters for the source.
 * @input {Function} updateSourceParameters - Function to update the source parameters.
 * @input {boolean} returnUI - Flag to return the UI elements.
 * @input {CreateMediaSFURoomOptions | JoinMediaSFURoomOptions} noUIPreJoinOptions - Options for the prejoin page without UI.
 * @input {JoinRoomOnMediaSFUType} joinMediaSFURoom - Function to join a room on MediaSFU.
 * @input {CreateRoomOnMediaSFUType} createMediaSFURoom - Function to create a room on MediaSFU.
 *
 * @property {string} title - The title of the component, defaults to "MediaSFU-Webinar".
 *
 * @styles
 * Component-specific styles with full-screen properties and customizable modal colors.
 *
 * @providers [CookieService] - Utilized for session or user state management within the component.
 *
 * @class MediasfuWebinar
 * @implements OnInit, OnDestroy
 *
 * @method ngOnInit - Initializes session settings, user interfaces, and modals as necessary.
 * @method ngOnDestroy - Cleans up event listeners and intervals to prevent memory leaks.
 *
 * @example
 * ```html
 * <app-mediasfu-webinar
 *   [PrejoinPage]="CustomPrejoinComponent"
 *   [localLink]="'https://localhost:3000'"
 *   [connectMediaSFU]="true"
 *   [credentials]="{ apiUserName: 'username', apiKey: 'apikey' }"
 *   [useLocalUIMode]="true"
 *   [seedData]="seedDataObject"
 *   [useSeed]="true"
 *   [imgSrc]="https://example.com/logo.png">
 *   [sourceParameters]="{ source: 'camera', width: 640, height: 480 }"
 *   [updateSourceParameters]="updateSourceParameters"
 *   [returnUI]="true"
 *   [noUIPreJoinOptions]="{ roomName: 'room1', userName: 'user1' }"
 *   [joinMediaSFURoom]="joinMediaSFURoom"
 *   [createMediaSFURoom]="createMediaSFURoom">
 * </app-mediasfu-webinar>
 * ```
 */
class MediasfuWebinar {
    cdr;
    injector;
    updateMiniCardsGrid;
    mixStreams;
    dispStreams;
    stopShareScreen;
    checkScreenShare;
    startShareScreen;
    requestScreenShare;
    reorderStreams;
    prepopulateUserMedia;
    getVideos;
    rePort;
    trigger;
    consumerResume;
    connectSendTransport;
    connectSendTransportAudio;
    connectSendTransportVideo;
    connectSendTransportScreen;
    processConsumerTransports;
    resumePauseStreams;
    readjust;
    checkGrid;
    getEstimate;
    calculateRowsAndColumns;
    addVideosGrid;
    onScreenChanges;
    changeVids;
    compareActiveNames;
    compareScreenStates;
    createSendTransport;
    resumeSendTransportAudio;
    receiveAllPipedTransports;
    disconnectSendTransportVideo;
    disconnectSendTransportAudio;
    disconnectSendTransportScreen;
    getPipedProducersAlt;
    signalNewConsumerTransport;
    connectRecvTransport;
    reUpdateInter;
    updateParticipantAudioDecibels;
    closeAndResize;
    autoAdjust;
    switchUserVideoAlt;
    switchUserVideo;
    switchUserAudio;
    getDomains;
    formatNumber;
    connectIps;
    connectLocalIps;
    createDeviceClient;
    handleCreatePoll;
    handleEndPoll;
    handleVotePoll;
    captureCanvasStream;
    resumePauseAudioStreams;
    processConsumerTransportsAudio;
    launchMenuModal;
    launchRecording;
    startRecording;
    confirmRecording;
    launchWaiting;
    launchCoHost;
    launchMediaSettings;
    launchDisplaySettings;
    launchSettings;
    launchRequests;
    launchParticipants;
    launchMessages;
    launchConfirmExit;
    launchPoll;
    launchBreakoutRooms;
    launchConfigureWhiteboard;
    startMeetingProgressTimer;
    updateRecording;
    stopRecording;
    userWaiting;
    personJoined;
    allWaitingRoomMembers;
    roomRecordParams;
    banParticipant;
    updatedCoHost;
    participantRequested;
    screenProducerId;
    updateMediaSettings;
    producerMediaPaused;
    producerMediaResumed;
    producerMediaClosed;
    controlMediaHost;
    meetingEnded;
    disconnectUserSelf;
    receiveMessage;
    meetingTimeRemaining;
    meetingStillThere;
    startRecords;
    reInitiateRecording;
    recordingNotice;
    timeLeftRecording;
    stoppedRecording;
    hostRequestResponse;
    allMembers;
    allMembersRest;
    disconnect;
    pollUpdated;
    breakoutRoomUpdated;
    socketManager;
    joinRoomClient;
    joinLocalRoom;
    updateRoomParametersClient;
    clickVideo;
    clickAudio;
    clickScreenShare;
    streamSuccessVideo;
    streamSuccessAudio;
    streamSuccessScreen;
    streamSuccessAudioSwitch;
    checkPermission;
    updateConsumingDomains;
    receiveRoomMessages;
    PrejoinPage = WelcomePage;
    localLink = '';
    connectMediaSFU = true;
    credentials = { apiUserName: '', apiKey: '' };
    useLocalUIMode = false;
    seedData;
    useSeed = false;
    imgSrc = 'https://mediasfu.com/images/logo192.png';
    sourceParameters = {};
    updateSourceParameters = (data) => { };
    returnUI = true;
    noUIPreJoinOptions;
    joinMediaSFURoom;
    createMediaSFURoom;
    title = 'MediaSFU-Webinar';
    mainHeightWidthSubscription;
    validatedSubscription;
    islevelSubscription;
    coHostSubscription;
    buttonSubscriptions = [];
    ScreenboardSubscription;
    recordingSubscription;
    constructor(cdr, injector, updateMiniCardsGrid, mixStreams, dispStreams, stopShareScreen, checkScreenShare, startShareScreen, requestScreenShare, reorderStreams, prepopulateUserMedia, getVideos, rePort, trigger, consumerResume, connectSendTransport, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, processConsumerTransports, resumePauseStreams, readjust, checkGrid, getEstimate, calculateRowsAndColumns, addVideosGrid, onScreenChanges, changeVids, compareActiveNames, compareScreenStates, createSendTransport, resumeSendTransportAudio, receiveAllPipedTransports, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, getPipedProducersAlt, signalNewConsumerTransport, connectRecvTransport, reUpdateInter, updateParticipantAudioDecibels, closeAndResize, autoAdjust, switchUserVideoAlt, switchUserVideo, switchUserAudio, getDomains, formatNumber, connectIps, connectLocalIps, createDeviceClient, handleCreatePoll, handleEndPoll, handleVotePoll, captureCanvasStream, resumePauseAudioStreams, processConsumerTransportsAudio, launchMenuModal, launchRecording, startRecording, confirmRecording, launchWaiting, launchCoHost, launchMediaSettings, launchDisplaySettings, launchSettings, launchRequests, launchParticipants, launchMessages, launchConfirmExit, launchPoll, launchBreakoutRooms, launchConfigureWhiteboard, startMeetingProgressTimer, updateRecording, stopRecording, userWaiting, personJoined, allWaitingRoomMembers, roomRecordParams, banParticipant, updatedCoHost, participantRequested, screenProducerId, updateMediaSettings, producerMediaPaused, producerMediaResumed, producerMediaClosed, controlMediaHost, meetingEnded, disconnectUserSelf, receiveMessage, meetingTimeRemaining, meetingStillThere, startRecords, reInitiateRecording, recordingNotice, timeLeftRecording, stoppedRecording, hostRequestResponse, allMembers, allMembersRest, disconnect, pollUpdated, breakoutRoomUpdated, socketManager, joinRoomClient, joinLocalRoom, updateRoomParametersClient, clickVideo, clickAudio, clickScreenShare, streamSuccessVideo, streamSuccessAudio, streamSuccessScreen, streamSuccessAudioSwitch, checkPermission, updateConsumingDomains, receiveRoomMessages) {
        this.cdr = cdr;
        this.injector = injector;
        this.updateMiniCardsGrid = updateMiniCardsGrid;
        this.mixStreams = mixStreams;
        this.dispStreams = dispStreams;
        this.stopShareScreen = stopShareScreen;
        this.checkScreenShare = checkScreenShare;
        this.startShareScreen = startShareScreen;
        this.requestScreenShare = requestScreenShare;
        this.reorderStreams = reorderStreams;
        this.prepopulateUserMedia = prepopulateUserMedia;
        this.getVideos = getVideos;
        this.rePort = rePort;
        this.trigger = trigger;
        this.consumerResume = consumerResume;
        this.connectSendTransport = connectSendTransport;
        this.connectSendTransportAudio = connectSendTransportAudio;
        this.connectSendTransportVideo = connectSendTransportVideo;
        this.connectSendTransportScreen = connectSendTransportScreen;
        this.processConsumerTransports = processConsumerTransports;
        this.resumePauseStreams = resumePauseStreams;
        this.readjust = readjust;
        this.checkGrid = checkGrid;
        this.getEstimate = getEstimate;
        this.calculateRowsAndColumns = calculateRowsAndColumns;
        this.addVideosGrid = addVideosGrid;
        this.onScreenChanges = onScreenChanges;
        this.changeVids = changeVids;
        this.compareActiveNames = compareActiveNames;
        this.compareScreenStates = compareScreenStates;
        this.createSendTransport = createSendTransport;
        this.resumeSendTransportAudio = resumeSendTransportAudio;
        this.receiveAllPipedTransports = receiveAllPipedTransports;
        this.disconnectSendTransportVideo = disconnectSendTransportVideo;
        this.disconnectSendTransportAudio = disconnectSendTransportAudio;
        this.disconnectSendTransportScreen = disconnectSendTransportScreen;
        this.getPipedProducersAlt = getPipedProducersAlt;
        this.signalNewConsumerTransport = signalNewConsumerTransport;
        this.connectRecvTransport = connectRecvTransport;
        this.reUpdateInter = reUpdateInter;
        this.updateParticipantAudioDecibels = updateParticipantAudioDecibels;
        this.closeAndResize = closeAndResize;
        this.autoAdjust = autoAdjust;
        this.switchUserVideoAlt = switchUserVideoAlt;
        this.switchUserVideo = switchUserVideo;
        this.switchUserAudio = switchUserAudio;
        this.getDomains = getDomains;
        this.formatNumber = formatNumber;
        this.connectIps = connectIps;
        this.connectLocalIps = connectLocalIps;
        this.createDeviceClient = createDeviceClient;
        this.handleCreatePoll = handleCreatePoll;
        this.handleEndPoll = handleEndPoll;
        this.handleVotePoll = handleVotePoll;
        this.captureCanvasStream = captureCanvasStream;
        this.resumePauseAudioStreams = resumePauseAudioStreams;
        this.processConsumerTransportsAudio = processConsumerTransportsAudio;
        this.launchMenuModal = launchMenuModal;
        this.launchRecording = launchRecording;
        this.startRecording = startRecording;
        this.confirmRecording = confirmRecording;
        this.launchWaiting = launchWaiting;
        this.launchCoHost = launchCoHost;
        this.launchMediaSettings = launchMediaSettings;
        this.launchDisplaySettings = launchDisplaySettings;
        this.launchSettings = launchSettings;
        this.launchRequests = launchRequests;
        this.launchParticipants = launchParticipants;
        this.launchMessages = launchMessages;
        this.launchConfirmExit = launchConfirmExit;
        this.launchPoll = launchPoll;
        this.launchBreakoutRooms = launchBreakoutRooms;
        this.launchConfigureWhiteboard = launchConfigureWhiteboard;
        this.startMeetingProgressTimer = startMeetingProgressTimer;
        this.updateRecording = updateRecording;
        this.stopRecording = stopRecording;
        this.userWaiting = userWaiting;
        this.personJoined = personJoined;
        this.allWaitingRoomMembers = allWaitingRoomMembers;
        this.roomRecordParams = roomRecordParams;
        this.banParticipant = banParticipant;
        this.updatedCoHost = updatedCoHost;
        this.participantRequested = participantRequested;
        this.screenProducerId = screenProducerId;
        this.updateMediaSettings = updateMediaSettings;
        this.producerMediaPaused = producerMediaPaused;
        this.producerMediaResumed = producerMediaResumed;
        this.producerMediaClosed = producerMediaClosed;
        this.controlMediaHost = controlMediaHost;
        this.meetingEnded = meetingEnded;
        this.disconnectUserSelf = disconnectUserSelf;
        this.receiveMessage = receiveMessage;
        this.meetingTimeRemaining = meetingTimeRemaining;
        this.meetingStillThere = meetingStillThere;
        this.startRecords = startRecords;
        this.reInitiateRecording = reInitiateRecording;
        this.recordingNotice = recordingNotice;
        this.timeLeftRecording = timeLeftRecording;
        this.stoppedRecording = stoppedRecording;
        this.hostRequestResponse = hostRequestResponse;
        this.allMembers = allMembers;
        this.allMembersRest = allMembersRest;
        this.disconnect = disconnect;
        this.pollUpdated = pollUpdated;
        this.breakoutRoomUpdated = breakoutRoomUpdated;
        this.socketManager = socketManager;
        this.joinRoomClient = joinRoomClient;
        this.joinLocalRoom = joinLocalRoom;
        this.updateRoomParametersClient = updateRoomParametersClient;
        this.clickVideo = clickVideo;
        this.clickAudio = clickAudio;
        this.clickScreenShare = clickScreenShare;
        this.streamSuccessVideo = streamSuccessVideo;
        this.streamSuccessAudio = streamSuccessAudio;
        this.streamSuccessScreen = streamSuccessScreen;
        this.streamSuccessAudioSwitch = streamSuccessAudioSwitch;
        this.checkPermission = checkPermission;
        this.updateConsumingDomains = updateConsumingDomains;
        this.receiveRoomMessages = receiveRoomMessages;
    }
    createInjector(inputs) {
        const inj = Injector.create({
            providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
            parent: this.injector,
        });
        return inj;
    }
    // Initial values
    mediaSFUFunctions = () => {
        return {
            updateMiniCardsGrid: this.updateMiniCardsGrid?.updateMiniCardsGrid ||
                (() => {
                    console.log('none');
                }),
            mixStreams: this.mixStreams?.mixStreams ||
                (() => {
                    console.log('none');
                }),
            dispStreams: this.dispStreams?.dispStreams ||
                (() => {
                    console.log('none');
                }),
            stopShareScreen: this.stopShareScreen?.stopShareScreen ||
                (() => {
                    console.log('none');
                }),
            checkScreenShare: this.checkScreenShare?.checkScreenShare ||
                (() => {
                    console.log('none');
                }),
            startShareScreen: this.startShareScreen?.startShareScreen ||
                (() => {
                    console.log('none');
                }),
            requestScreenShare: this.requestScreenShare?.requestScreenShare ||
                (() => {
                    console.log('none');
                }),
            reorderStreams: this.reorderStreams?.reorderStreams ||
                (() => {
                    console.log('none');
                }),
            prepopulateUserMedia: this.prepopulateUserMedia?.prepopulateUserMedia ||
                (() => {
                    console.log('none');
                }),
            getVideos: this.getVideos?.getVideos ||
                (() => {
                    console.log('none');
                }),
            rePort: this.rePort?.rePort ||
                (() => {
                    console.log('none');
                }),
            trigger: this.trigger?.trigger ||
                (() => {
                    console.log('none');
                }),
            consumerResume: this.consumerResume?.consumerResume ||
                (() => {
                    console.log('none');
                }),
            connectSendTransport: this.connectSendTransport?.connectSendTransport ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportAudio: this.connectSendTransportAudio?.connectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportVideo: this.connectSendTransportVideo?.connectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportScreen: this.connectSendTransportScreen?.connectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransports: this.processConsumerTransports?.processConsumerTransports ||
                (() => {
                    console.log('none');
                }),
            resumePauseStreams: this.resumePauseStreams?.resumePauseStreams ||
                (() => {
                    console.log('none');
                }),
            readjust: this.readjust?.readjust ||
                (() => {
                    console.log('none');
                }),
            checkGrid: this.checkGrid?.checkGrid ||
                (() => {
                    console.log('none');
                }),
            getEstimate: this.getEstimate?.getEstimate ||
                (() => {
                    console.log('none');
                }),
            calculateRowsAndColumns: this.calculateRowsAndColumns?.calculateRowsAndColumns ||
                (() => {
                    console.log('none');
                }),
            addVideosGrid: this.addVideosGrid?.addVideosGrid ||
                (() => {
                    console.log('none');
                }),
            onScreenChanges: this.onScreenChanges?.onScreenChanges ||
                (() => {
                    console.log('none');
                }),
            sleep: sleep ||
                (() => {
                    console.log('none');
                }),
            changeVids: this.changeVids?.changeVids ||
                (() => {
                    console.log('none');
                }),
            compareActiveNames: this.compareActiveNames?.compareActiveNames ||
                (() => {
                    console.log('none');
                }),
            compareScreenStates: this.compareScreenStates?.compareScreenStates ||
                (() => {
                    console.log('none');
                }),
            createSendTransport: this.createSendTransport?.createSendTransport ||
                (() => {
                    console.log('none');
                }),
            resumeSendTransportAudio: this.resumeSendTransportAudio?.resumeSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            receiveAllPipedTransports: this.receiveAllPipedTransports?.receiveAllPipedTransports ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportVideo: this.disconnectSendTransportVideo?.disconnectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportAudio: this.disconnectSendTransportAudio?.disconnectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportScreen: this.disconnectSendTransportScreen?.disconnectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            getPipedProducersAlt: this.getPipedProducersAlt?.getPipedProducersAlt ||
                (() => {
                    console.log('none');
                }),
            signalNewConsumerTransport: this.signalNewConsumerTransport?.signalNewConsumerTransport ||
                (() => {
                    console.log('none');
                }),
            connectRecvTransport: this.connectRecvTransport?.connectRecvTransport ||
                (() => {
                    console.log('none');
                }),
            reUpdateInter: this.reUpdateInter?.reUpdateInter ||
                (() => {
                    console.log('none');
                }),
            updateParticipantAudioDecibels: this.updateParticipantAudioDecibels?.updateParticipantAudioDecibels ||
                (() => {
                    console.log('none');
                }),
            closeAndResize: this.closeAndResize?.closeAndResize ||
                (() => {
                    console.log('none');
                }),
            autoAdjust: this.autoAdjust?.autoAdjust ||
                (() => {
                    console.log('none');
                }),
            switchUserVideoAlt: this.switchUserVideoAlt?.switchUserVideoAlt ||
                (() => {
                    console.log('none');
                }),
            switchUserVideo: this.switchUserVideo?.switchUserVideo ||
                (() => {
                    console.log('none');
                }),
            switchUserAudio: this.switchUserAudio?.switchUserAudio ||
                (() => {
                    console.log('none');
                }),
            getDomains: this.getDomains?.getDomains ||
                (() => {
                    console.log('none');
                }),
            formatNumber: this.formatNumber?.formatNumber ||
                (() => {
                    console.log('none');
                }),
            connectIps: this.connectIps?.connectIps ||
                (() => {
                    console.log('none');
                }),
            connectLocalIps: this.connectLocalIps?.connectLocalIps ||
                (() => {
                    console.log('none');
                }),
            createDeviceClient: this.createDeviceClient?.createDeviceClient ||
                (() => {
                    console.log('none');
                }),
            handleCreatePoll: this.handleCreatePoll?.handleCreatePoll ||
                (() => {
                    console.log('none');
                }),
            handleEndPoll: this.handleEndPoll?.handleEndPoll ||
                (() => {
                    console.log('none');
                }),
            handleVotePoll: this.handleVotePoll?.handleVotePoll ||
                (() => {
                    console.log('none');
                }),
            captureCanvasStream: this.captureCanvasStream?.captureCanvasStream ||
                (() => {
                    console.log('none');
                }),
            resumePauseAudioStreams: this.resumePauseAudioStreams?.resumePauseAudioStreams ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransportsAudio: this.processConsumerTransportsAudio?.processConsumerTransportsAudio ||
                (() => {
                    console.log('none');
                }),
            checkPermission: this.checkPermission?.checkPermission ||
                (() => {
                    console.log('none');
                }),
            streamSuccessVideo: this.streamSuccessVideo?.streamSuccessVideo ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudio: this.streamSuccessAudio?.streamSuccessAudio ||
                (() => {
                    console.log('none');
                }),
            streamSuccessScreen: this.streamSuccessScreen?.streamSuccessScreen ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudioSwitch: this.streamSuccessAudioSwitch?.streamSuccessAudioSwitch ||
                (() => {
                    console.log('none');
                }),
            clickVideo: this.clickVideo?.clickVideo ||
                (() => {
                    console.log('none');
                }),
            clickAudio: this.clickAudio?.clickAudio ||
                (() => {
                    console.log('none');
                }),
            clickScreenShare: this.clickScreenShare?.clickScreenShare ||
                (() => {
                    console.log('none');
                }),
            requestPermissionCamera: this.requestPermissionCamera ||
                (() => {
                    console.log('none');
                }),
            requestPermissionAudio: this.requestPermissionAudio ||
                (() => {
                    console.log('none');
                }),
        };
    };
    validated = new BehaviorSubject$1(false);
    localUIMode = new BehaviorSubject$1(false);
    socket = new BehaviorSubject$1({});
    localSocket = new BehaviorSubject$1(undefined);
    roomData = new BehaviorSubject$1(null);
    device = new BehaviorSubject$1(null);
    apiKey = new BehaviorSubject$1('');
    apiUserName = new BehaviorSubject$1('');
    apiToken = new BehaviorSubject$1('');
    link = new BehaviorSubject$1('');
    roomName = new BehaviorSubject$1('');
    member = new BehaviorSubject$1('');
    adminPasscode = new BehaviorSubject$1('');
    islevel = new BehaviorSubject$1('1');
    coHost = new BehaviorSubject$1('No coHost');
    coHostResponsibility = new BehaviorSubject$1([
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ]);
    youAreCoHost = new BehaviorSubject$1(false);
    youAreHost = new BehaviorSubject$1(false);
    confirmedToRecord = new BehaviorSubject$1(false);
    meetingDisplayType = new BehaviorSubject$1('media');
    meetingVideoOptimized = new BehaviorSubject$1(false);
    eventType = new BehaviorSubject$1('webinar');
    participants = new BehaviorSubject$1([]);
    filteredParticipants = new BehaviorSubject$1([]);
    participantsCounter = new BehaviorSubject$1(0);
    participantsFilter = new BehaviorSubject$1('');
    consume_sockets = new BehaviorSubject$1([]);
    rtpCapabilities = new BehaviorSubject$1(null);
    roomRecvIPs = new BehaviorSubject$1([]);
    meetingRoomParams = new BehaviorSubject$1(null);
    itemPageLimit = new BehaviorSubject$1(4);
    audioOnlyRoom = new BehaviorSubject$1(false);
    addForBasic = new BehaviorSubject$1(false);
    screenPageLimit = new BehaviorSubject$1(4);
    shareScreenStarted = new BehaviorSubject$1(false);
    shared = new BehaviorSubject$1(false);
    targetOrientation = new BehaviorSubject$1('landscape');
    targetResolution = new BehaviorSubject$1('sd');
    targetResolutionHost = new BehaviorSubject$1('sd');
    vidCons = new BehaviorSubject$1({ width: 640, height: 360 });
    frameRate = new BehaviorSubject$1(10);
    hParams = new BehaviorSubject$1({});
    vParams = new BehaviorSubject$1({});
    screenParams = new BehaviorSubject$1({});
    aParams = new BehaviorSubject$1({});
    recordingAudioPausesLimit = new BehaviorSubject$1(0);
    recordingAudioPausesCount = new BehaviorSubject$1(0);
    recordingAudioSupport = new BehaviorSubject$1(false);
    recordingAudioPeopleLimit = new BehaviorSubject$1(0);
    recordingAudioParticipantsTimeLimit = new BehaviorSubject$1(0);
    recordingVideoPausesCount = new BehaviorSubject$1(0);
    recordingVideoPausesLimit = new BehaviorSubject$1(0);
    recordingVideoSupport = new BehaviorSubject$1(false);
    recordingVideoPeopleLimit = new BehaviorSubject$1(0);
    recordingVideoParticipantsTimeLimit = new BehaviorSubject$1(0);
    recordingAllParticipantsSupport = new BehaviorSubject$1(false);
    recordingVideoParticipantsSupport = new BehaviorSubject$1(false);
    recordingAllParticipantsFullRoomSupport = new BehaviorSubject$1(false);
    recordingVideoParticipantsFullRoomSupport = new BehaviorSubject$1(false);
    recordingPreferredOrientation = new BehaviorSubject$1('landscape');
    recordingSupportForOtherOrientation = new BehaviorSubject$1(false);
    recordingMultiFormatsSupport = new BehaviorSubject$1(false);
    userRecordingParams = new BehaviorSubject$1({
        mainSpecs: {
            mediaOptions: 'video', // 'audio', 'video'
            audioOptions: 'all', // 'all', 'onScreen', 'host'
            videoOptions: 'all', // 'all', 'mainScreen'
            videoType: 'fullDisplay', // 'all', 'bestDisplay', 'fullDisplay'
            videoOptimized: false, // true, false
            recordingDisplayType: 'media', // 'media', 'video', 'all'
            addHLS: false, // true, false
        },
        dispSpecs: {
            nameTags: true, // true, false
            backgroundColor: '#000000', // '#000000', '#ffffff'
            nameTagsColor: '#ffffff', // '#000000', '#ffffff'
            orientationVideo: 'portrait', // 'landscape', 'portrait', 'all'
        },
    });
    canRecord = new BehaviorSubject$1(false);
    startReport = new BehaviorSubject$1(false);
    endReport = new BehaviorSubject$1(false);
    recordTimerInterval = new BehaviorSubject$1(null);
    recordStartTime = new BehaviorSubject$1(0);
    recordElapsedTime = new BehaviorSubject$1(0);
    isTimerRunning = new BehaviorSubject$1(false);
    canPauseResume = new BehaviorSubject$1(false);
    recordChangeSeconds = new BehaviorSubject$1(15000);
    pauseLimit = new BehaviorSubject$1(0);
    pauseRecordCount = new BehaviorSubject$1(0);
    canLaunchRecord = new BehaviorSubject$1(true);
    stopLaunchRecord = new BehaviorSubject$1(false);
    participantsAll = new BehaviorSubject$1([]);
    firstAll = new BehaviorSubject$1(false);
    updateMainWindow = new BehaviorSubject$1(false);
    first_round = new BehaviorSubject$1(false);
    landScaped = new BehaviorSubject$1(false);
    lock_screen = new BehaviorSubject$1(false);
    screenId = new BehaviorSubject$1('');
    allVideoStreams = new BehaviorSubject$1([]);
    newLimitedStreams = new BehaviorSubject$1([]);
    newLimitedStreamsIDs = new BehaviorSubject$1([]);
    activeSounds = new BehaviorSubject$1([]);
    screenShareIDStream = new BehaviorSubject$1('');
    screenShareNameStream = new BehaviorSubject$1('');
    adminIDStream = new BehaviorSubject$1('');
    adminNameStream = new BehaviorSubject$1('');
    youYouStream = new BehaviorSubject$1([]);
    youYouStreamIDs = new BehaviorSubject$1([]);
    localStream = new BehaviorSubject$1(null);
    recordStarted = new BehaviorSubject$1(false);
    recordResumed = new BehaviorSubject$1(false);
    recordPaused = new BehaviorSubject$1(false);
    recordStopped = new BehaviorSubject$1(false);
    adminRestrictSetting = new BehaviorSubject$1(false);
    videoRequestState = new BehaviorSubject$1(null);
    videoRequestTime = new BehaviorSubject$1(0);
    videoAction = new BehaviorSubject$1(false);
    localStreamVideo = new BehaviorSubject$1(null);
    userDefaultVideoInputDevice = new BehaviorSubject$1('');
    currentFacingMode = new BehaviorSubject$1('user');
    prevFacingMode = new BehaviorSubject$1('user');
    defVideoID = new BehaviorSubject$1('');
    allowed = new BehaviorSubject$1(false);
    dispActiveNames = new BehaviorSubject$1([]);
    p_dispActiveNames = new BehaviorSubject$1([]);
    activeNames = new BehaviorSubject$1([]);
    prevActiveNames = new BehaviorSubject$1([]);
    p_activeNames = new BehaviorSubject$1([]);
    membersReceived = new BehaviorSubject$1(false);
    deferScreenReceived = new BehaviorSubject$1(false);
    hostFirstSwitch = new BehaviorSubject$1(false);
    micAction = new BehaviorSubject$1(false);
    screenAction = new BehaviorSubject$1(false);
    chatAction = new BehaviorSubject$1(false);
    audioRequestState = new BehaviorSubject$1(null);
    screenRequestState = new BehaviorSubject$1(null);
    chatRequestState = new BehaviorSubject$1(null);
    audioRequestTime = new BehaviorSubject$1(0);
    screenRequestTime = new BehaviorSubject$1(0);
    chatRequestTime = new BehaviorSubject$1(0);
    updateRequestIntervalSeconds = new BehaviorSubject$1(240);
    oldSoundIds = new BehaviorSubject$1([]);
    hostLabel = new BehaviorSubject$1('Host');
    mainScreenFilled = new BehaviorSubject$1(false);
    localStreamScreen = new BehaviorSubject$1(null);
    screenAlreadyOn = new BehaviorSubject$1(false);
    chatAlreadyOn = new BehaviorSubject$1(false);
    redirectURL = new BehaviorSubject$1('');
    oldAllStreams = new BehaviorSubject$1([]);
    adminVidID = new BehaviorSubject$1('');
    streamNames = new BehaviorSubject$1([]);
    non_alVideoStreams = new BehaviorSubject$1([]);
    sortAudioLoudness = new BehaviorSubject$1(false);
    audioDecibels = new BehaviorSubject$1([]);
    mixed_alVideoStreams = new BehaviorSubject$1([]);
    non_alVideoStreams_muted = new BehaviorSubject$1([]);
    paginatedStreams = new BehaviorSubject$1([]);
    localStreamAudio = new BehaviorSubject$1(null);
    defAudioID = new BehaviorSubject$1('');
    userDefaultAudioInputDevice = new BehaviorSubject$1('');
    userDefaultAudioOutputDevice = new BehaviorSubject$1('');
    prevAudioInputDevice = new BehaviorSubject$1('');
    prevVideoInputDevice = new BehaviorSubject$1('');
    audioPaused = new BehaviorSubject$1(false);
    mainScreenPerson = new BehaviorSubject$1('');
    adminOnMainScreen = new BehaviorSubject$1(false);
    screenStates = new BehaviorSubject$1([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    prevScreenStates = new BehaviorSubject$1([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    updateDateState = new BehaviorSubject$1(null);
    lastUpdate = new BehaviorSubject$1(null);
    nForReadjustRecord = new BehaviorSubject$1(0);
    fixedPageLimit = new BehaviorSubject$1(4);
    removeAltGrid = new BehaviorSubject$1(false);
    nForReadjust = new BehaviorSubject$1(0);
    reorderInterval = new BehaviorSubject$1(30000);
    fastReorderInterval = new BehaviorSubject$1(10000);
    lastReorderTime = new BehaviorSubject$1(0);
    audStreamNames = new BehaviorSubject$1([]);
    currentUserPage = new BehaviorSubject$1(0);
    mainHeightWidth = new BehaviorSubject$1(this.eventType.value == 'webinar' ? 67 : this.eventType.value == 'broadcast' ? 100 : 0);
    prevMainHeightWidth = new BehaviorSubject$1(this.mainHeightWidth.value);
    prevDoPaginate = new BehaviorSubject$1(false);
    doPaginate = new BehaviorSubject$1(false);
    shareEnded = new BehaviorSubject$1(false);
    lStreams = new BehaviorSubject$1([]);
    chatRefStreams = new BehaviorSubject$1([]);
    controlHeight = new BehaviorSubject$1(this.eventType.value === 'webinar' || this.eventType.value === 'conference' ? 0 : 0.06);
    isWideScreen = new BehaviorSubject$1(false);
    isMediumScreen = new BehaviorSubject$1(false);
    isSmallScreen = new BehaviorSubject$1(false);
    addGrid = new BehaviorSubject$1(false);
    addAltGrid = new BehaviorSubject$1(false);
    gridRows = new BehaviorSubject$1(0);
    gridCols = new BehaviorSubject$1(0);
    altGridRows = new BehaviorSubject$1(0);
    altGridCols = new BehaviorSubject$1(0);
    numberPages = new BehaviorSubject$1(0);
    currentStreams = new BehaviorSubject$1([]);
    showMiniView = new BehaviorSubject$1(false);
    nStream = new BehaviorSubject$1(null);
    defer_receive = new BehaviorSubject$1(false);
    allAudioStreams = new BehaviorSubject$1([]);
    remoteScreenStream = new BehaviorSubject$1([]);
    screenProducer = new BehaviorSubject$1(null);
    localScreenProducer = new BehaviorSubject$1(null);
    gotAllVids = new BehaviorSubject$1(false);
    paginationHeightWidth = new BehaviorSubject$1(40);
    paginationDirection = new BehaviorSubject$1('horizontal');
    gridSizes = new BehaviorSubject$1({
        gridWidth: 0,
        gridHeight: 0,
        altGridWidth: 0,
        altGridHeight: 0,
    });
    screenForceFullDisplay = new BehaviorSubject$1(false);
    mainGridStream = new BehaviorSubject$1([]);
    otherGridStreams = new BehaviorSubject$1([]);
    audioOnlyStreams = new BehaviorSubject$1([]);
    videoInputs = new BehaviorSubject$1([]);
    audioInputs = new BehaviorSubject$1([]);
    meetingProgressTime = new BehaviorSubject$1('00:00:00');
    meetingElapsedTime = new BehaviorSubject$1(0);
    ref_participants = new BehaviorSubject$1([]);
    updateValidated = (value) => {
        this.validated.next(value);
    };
    updateSocket = (value) => {
        this.socket.next(value);
    };
    updateLocalSocket = (value) => {
        this.localSocket.next(value);
    };
    updateDevice = (value) => {
        this.device.next(value);
    };
    updateRoomData = (value) => {
        this.roomData.next(value);
    };
    updateApiKey = (value) => {
        this.apiKey.next(value);
    };
    updateApiUserName = (value) => {
        this.apiUserName.next(value);
    };
    updateApiToken = (value) => {
        this.apiToken.next(value);
    };
    updateLink = (value) => {
        this.link.next(value);
    };
    updateRoomName = (value) => {
        this.roomName.next(value);
    };
    updateMember = (value) => {
        if (value.length > 0 && value.includes("_")) {
            this.updateIslevel(value.split("_")[1]);
            value = value.split("_")[0];
        }
        this.member.next(value);
    };
    updateAdminPasscode = (value) => {
        this.adminPasscode.next(value);
    };
    updateIslevel = (value) => {
        this.islevel.next(value);
    };
    updateCoHost = (value) => {
        this.coHost.next(value);
    };
    updateCoHostResponsibility = (value) => {
        this.coHostResponsibility.next(value);
    };
    updateYouAreCoHost = (value) => {
        this.youAreCoHost.next(value);
    };
    updateYouAreHost = (value) => {
        this.youAreHost.next(value);
    };
    updateConfirmedToRecord = (value) => {
        this.confirmedToRecord.next(value);
    };
    updateMeetingDisplayType = (value) => {
        this.meetingDisplayType.next(value);
    };
    updateMeetingVideoOptimized = (value) => {
        this.meetingVideoOptimized.next(value);
    };
    updateEventType = (value) => {
        this.eventType.next(value);
        if (value != 'none') {
            try {
                setTimeout(() => {
                    this.handleResize();
                }, 2000);
            }
            catch {
                /* handle error */
            }
        }
    };
    updateParticipants = (value) => {
        this.participants.next(value);
        this.participantsCounter.next(value.length);
        this.filteredParticipants.next(this.participants.value);
    };
    updateFilteredParticipants = (value) => {
        this.filteredParticipants.next(value);
    };
    updateParticipantsCounter = (value) => {
        this.participantsCounter.next(value);
    };
    updateParticipantsFilter = (value) => {
        this.participantsFilter.next(value);
    };
    updateConsume_sockets = (value) => {
        this.consume_sockets.next(value);
    };
    updateRtpCapabilities = (value) => {
        this.rtpCapabilities.next(value);
    };
    updateRoomRecvIPs = (value) => {
        this.roomRecvIPs.next(value);
    };
    updateMeetingRoomParams = (value) => {
        this.meetingRoomParams.next(value);
    };
    updateItemPageLimit = (value) => {
        this.itemPageLimit.next(value);
    };
    updateAudioOnlyRoom = (value) => {
        this.audioOnlyRoom.next(value);
    };
    updateAddForBasic = (value) => {
        this.addForBasic.next(value);
    };
    updateScreenPageLimit = (value) => {
        this.screenPageLimit.next(value);
    };
    updateShareScreenStarted = (value) => {
        this.shareScreenStarted.next(value);
    };
    updateShared = (value) => {
        this.shared.next(value);
        this.screenShareActive.next(value);
        if (value) {
            setTimeout(async () => {
                window.dispatchEvent(new Event('resize'));
            }, 2000);
        }
    };
    updateTargetOrientation = (value) => {
        this.targetOrientation.next(value);
    };
    updateTargetResolution = (value) => {
        this.targetResolution.next(value);
    };
    updateTargetResolutionHost = (value) => {
        this.targetResolutionHost.next(value);
    };
    updateVidCons = (value) => {
        this.vidCons.next(value);
    };
    updateFrameRate = (value) => {
        this.frameRate.next(value);
    };
    updateHParams = (value) => {
        this.hParams.next(value);
    };
    updateVParams = (value) => {
        this.vParams.next(value);
    };
    updateScreenParams = (value) => {
        this.screenParams.next(value);
    };
    updateAParams = (value) => {
        this.aParams.next(value);
    };
    updateRecordingAudioPausesLimit = (value) => {
        this.recordingAudioPausesLimit.next(value);
    };
    updateRecordingAudioPausesCount = (value) => {
        this.recordingAudioPausesCount.next(value);
    };
    updateRecordingAudioSupport = (value) => {
        this.recordingAudioSupport.next(value);
    };
    updateRecordingAudioPeopleLimit = (value) => {
        this.recordingAudioPeopleLimit.next(value);
    };
    updateRecordingAudioParticipantsTimeLimit = (value) => {
        this.recordingAudioParticipantsTimeLimit.next(value);
    };
    updateRecordingVideoPausesCount = (value) => {
        this.recordingVideoPausesCount.next(value);
    };
    updateRecordingVideoPausesLimit = (value) => {
        this.recordingVideoPausesLimit.next(value);
    };
    updateRecordingVideoSupport = (value) => {
        this.recordingVideoSupport.next(value);
    };
    updateRecordingVideoPeopleLimit = (value) => {
        this.recordingVideoPeopleLimit.next(value);
    };
    updateRecordingVideoParticipantsTimeLimit = (value) => {
        this.recordingVideoParticipantsTimeLimit.next(value);
    };
    updateRecordingAllParticipantsSupport = (value) => {
        this.recordingAllParticipantsSupport.next(value);
    };
    updateRecordingVideoParticipantsSupport = (value) => {
        this.recordingVideoParticipantsSupport.next(value);
    };
    updateRecordingAllParticipantsFullRoomSupport = (value) => {
        this.recordingAllParticipantsFullRoomSupport.next(value);
    };
    updateRecordingVideoParticipantsFullRoomSupport = (value) => {
        this.recordingVideoParticipantsFullRoomSupport.next(value);
    };
    updateRecordingPreferredOrientation = (value) => {
        this.recordingPreferredOrientation.next(value);
    };
    updateRecordingSupportForOtherOrientation = (value) => {
        this.recordingSupportForOtherOrientation.next(value);
    };
    updateRecordingMultiFormatsSupport = (value) => {
        this.recordingMultiFormatsSupport.next(value);
    };
    updateUserRecordingParams = (value) => {
        this.userRecordingParams.next(value);
    };
    updateCanRecord = (value) => {
        this.canRecord.next(value);
    };
    updateStartReport = (value) => {
        this.startReport.next(value);
    };
    updateEndReport = (value) => {
        this.endReport.next(value);
    };
    updateRecordTimerInterval = (value) => {
        this.recordTimerInterval.next(value);
    };
    updateRecordStartTime = (value) => {
        this.recordStartTime.next(value);
    };
    updateRecordElapsedTime = (value) => {
        this.recordElapsedTime.next(value);
    };
    updateIsTimerRunning = (value) => {
        this.isTimerRunning.next(value);
    };
    updateCanPauseResume = (value) => {
        this.canPauseResume.next(value);
    };
    updateRecordChangeSeconds = (value) => {
        this.recordChangeSeconds.next(value);
    };
    updatePauseLimit = (value) => {
        this.pauseLimit.next(value);
    };
    updatePauseRecordCount = (value) => {
        this.pauseRecordCount.next(value);
    };
    updateCanLaunchRecord = (value) => {
        this.canLaunchRecord.next(value);
    };
    updateStopLaunchRecord = (value) => {
        this.stopLaunchRecord.next(value);
    };
    updateParticipantsAll = (value) => {
        this.participantsAll.next(value);
    };
    updateFirstAll = (value) => {
        this.firstAll.next(value);
    };
    updateUpdateMainWindow = (value) => {
        this.updateMainWindow.next(value);
    };
    updateFirst_round = (value) => {
        this.first_round.next(value);
    };
    updateLandScaped = (value) => {
        this.landScaped.next(value);
    };
    updateLock_screen = (value) => {
        this.lock_screen.next(value);
    };
    updateScreenId = (value) => {
        this.screenId.next(value);
    };
    updateAllVideoStreams = (value) => {
        this.allVideoStreams.next(value);
    };
    updateNewLimitedStreams = (value) => {
        this.newLimitedStreams.next(value);
    };
    updateNewLimitedStreamsIDs = (value) => {
        this.newLimitedStreamsIDs.next(value);
    };
    updateActiveSounds = (value) => {
        this.activeSounds.next(value);
    };
    updateScreenShareIDStream = (value) => {
        this.screenShareIDStream.next(value);
    };
    updateScreenShareNameStream = (value) => {
        this.screenShareNameStream.next(value);
    };
    updateAdminIDStream = (value) => {
        this.adminIDStream.next(value);
    };
    updateAdminNameStream = (value) => {
        this.adminNameStream.next(value);
    };
    updateYouYouStream = (value) => {
        this.youYouStream.next(value);
    };
    updateYouYouStreamIDs = (value) => {
        this.youYouStreamIDs.next(value);
    };
    updateLocalStream = (value) => {
        this.localStream.next(value);
    };
    updateRecordStarted = (value) => {
        this.recordStarted.next(value);
    };
    updateRecordResumed = (value) => {
        this.recordResumed.next(value);
    };
    updateRecordPaused = (value) => {
        this.recordPaused.next(value);
    };
    updateRecordStopped = (value) => {
        this.recordStopped.next(value);
    };
    updateAdminRestrictSetting = (value) => {
        this.adminRestrictSetting.next(value);
    };
    updateVideoRequestState = (value) => {
        this.videoRequestState.next(value);
    };
    updateVideoRequestTime = (value) => {
        this.videoRequestTime.next(value);
    };
    updateVideoAction = (value) => {
        this.videoAction.next(value);
    };
    updateLocalStreamVideo = (value) => {
        this.localStreamVideo.next(value);
    };
    updateUserDefaultVideoInputDevice = (value) => {
        this.userDefaultVideoInputDevice.next(value);
    };
    updateCurrentFacingMode = (value) => {
        this.currentFacingMode.next(value);
    };
    updatePrevFacingMode = (value) => {
        this.prevFacingMode.next(value);
    };
    updateDefVideoID = (value) => {
        this.defVideoID.next(value);
    };
    updateAllowed = (value) => {
        this.allowed.next(value);
    };
    updateDispActiveNames = (value) => {
        this.dispActiveNames.next(value);
    };
    updateP_dispActiveNames = (value) => {
        this.p_dispActiveNames.next(value);
    };
    updateActiveNames = (value) => {
        this.activeNames.next(value);
    };
    updatePrevActiveNames = (value) => {
        this.prevActiveNames.next(value);
    };
    updateP_activeNames = (value) => {
        this.p_activeNames.next(value);
    };
    updateMembersReceived = (value) => {
        this.membersReceived.next(value);
    };
    updateDeferScreenReceived = (value) => {
        this.deferScreenReceived.next(value);
    };
    updateHostFirstSwitch = (value) => {
        this.hostFirstSwitch.next(value);
    };
    updateMicAction = (value) => {
        this.micAction.next(value);
    };
    updateScreenAction = (value) => {
        this.screenAction.next(value);
    };
    updateChatAction = (value) => {
        this.chatAction.next(value);
    };
    updateAudioRequestState = (value) => {
        this.audioRequestState.next(value);
    };
    updateScreenRequestState = (value) => {
        this.screenRequestState.next(value);
    };
    updateChatRequestState = (value) => {
        this.chatRequestState.next(value);
    };
    updateAudioRequestTime = (value) => {
        this.audioRequestTime.next(value);
    };
    updateScreenRequestTime = (value) => {
        this.screenRequestTime.next(value);
    };
    updateChatRequestTime = (value) => {
        this.chatRequestTime.next(value);
    };
    updateOldSoundIds = (value) => {
        this.oldSoundIds.next(value);
    };
    updateHostLabel = (value) => {
        this.hostLabel.next(value);
    };
    updateMainScreenFilled = (value) => {
        this.mainScreenFilled.next(value);
    };
    updateLocalStreamScreen = (value) => {
        this.localStreamScreen.next(value);
    };
    updateScreenAlreadyOn = (value) => {
        this.screenAlreadyOn.next(value);
    };
    updateChatAlreadyOn = (value) => {
        this.chatAlreadyOn.next(value);
    };
    updateRedirectURL = (value) => {
        this.redirectURL.next(value);
    };
    updateOldAllStreams = (value) => {
        this.oldAllStreams.next(value);
    };
    updateAdminVidID = (value) => {
        this.adminVidID.next(value);
    };
    updateStreamNames = (value) => {
        this.streamNames.next(value);
    };
    updateNon_alVideoStreams = (value) => {
        this.non_alVideoStreams.next(value);
    };
    updateSortAudioLoudness = (value) => {
        this.sortAudioLoudness.next(value);
    };
    updateAudioDecibels = (value) => {
        this.audioDecibels.next(value);
    };
    updateMixed_alVideoStreams = (value) => {
        this.mixed_alVideoStreams.next(value);
    };
    updateNon_alVideoStreams_muted = (value) => {
        this.non_alVideoStreams_muted.next(value);
    };
    updatePaginatedStreams = (value) => {
        this.paginatedStreams.next(value);
    };
    updateLocalStreamAudio = (value) => {
        this.localStreamAudio.next(value);
    };
    updateDefAudioID = (value) => {
        this.defAudioID.next(value);
    };
    updateUserDefaultAudioInputDevice = (value) => {
        this.userDefaultAudioInputDevice.next(value);
    };
    updateUserDefaultAudioOutputDevice = (value) => {
        this.userDefaultAudioOutputDevice.next(value);
    };
    updatePrevAudioInputDevice = (value) => {
        this.prevAudioInputDevice.next(value);
    };
    updatePrevVideoInputDevice = (value) => {
        this.prevVideoInputDevice.next(value);
    };
    updateAudioPaused = (value) => {
        this.audioPaused.next(value);
    };
    updateMainScreenPerson = (value) => {
        this.mainScreenPerson.next(value);
    };
    updateAdminOnMainScreen = (value) => {
        this.adminOnMainScreen.next(value);
    };
    updateScreenStates = (value) => {
        this.screenStates.next(value);
    };
    updatePrevScreenStates = (value) => {
        this.prevScreenStates.next(value);
    };
    updateUpdateDateState = (value) => {
        this.updateDateState.next(value);
    };
    updateLastUpdate = (value) => {
        this.lastUpdate.next(value);
    };
    updateNForReadjustRecord = (value) => {
        this.nForReadjustRecord.next(value);
    };
    updateFixedPageLimit = (value) => {
        this.fixedPageLimit.next(value);
    };
    updateRemoveAltGrid = (value) => {
        this.removeAltGrid.next(value);
    };
    updateNForReadjust = (value) => {
        this.nForReadjust.next(value);
    };
    updateLastReorderTime = (value) => {
        this.lastReorderTime.next(value);
    };
    updateAudStreamNames = (value) => {
        this.audStreamNames.next(value);
    };
    updateCurrentUserPage = (value) => {
        this.currentUserPage.next(value);
    };
    updateMainHeightWidth = (value) => {
        this.mainHeightWidth.next(value);
    };
    updatePrevMainHeightWidth = (value) => {
        this.prevMainHeightWidth.next(value);
    };
    updatePrevDoPaginate = (value) => {
        this.prevDoPaginate.next(value);
    };
    updateDoPaginate = (value) => {
        this.doPaginate.next(value);
    };
    updateShareEnded = (value) => {
        this.shareEnded.next(value);
    };
    updateLStreams = (value) => {
        this.lStreams.next(value);
    };
    updateChatRefStreams = (value) => {
        this.chatRefStreams.next(value);
    };
    updateControlHeight = (value) => {
        this.controlHeight.next(value);
    };
    updateIsWideScreen = (value) => {
        this.isWideScreen.next(value);
    };
    updateIsMediumScreen = (value) => {
        this.isMediumScreen.next(value);
    };
    updateIsSmallScreen = (value) => {
        this.isSmallScreen.next(value);
    };
    updateAddGrid = (value) => {
        this.addGrid.next(value);
    };
    updateAddAltGrid = (value) => {
        this.addAltGrid.next(value);
    };
    updateGridRows = (value) => {
        this.gridRows.next(value);
    };
    updateGridCols = (value) => {
        this.gridCols.next(value);
    };
    updateAltGridRows = (value) => {
        this.altGridRows.next(value);
    };
    updateAltGridCols = (value) => {
        this.altGridCols.next(value);
    };
    updateNumberPages = (value) => {
        this.numberPages.next(value);
    };
    updateCurrentStreams = (value) => {
        this.currentStreams.next(value);
    };
    updateShowMiniView = (value) => {
        this.showMiniView.next(value);
    };
    updateNStream = (value) => {
        this.nStream.next(value);
    };
    updateDefer_receive = (value) => {
        this.defer_receive.next(value);
    };
    updateAllAudioStreams = (value) => {
        this.allAudioStreams.next(value);
    };
    updateRemoteScreenStream = (value) => {
        this.remoteScreenStream.next(value);
    };
    updateScreenProducer = (value) => {
        this.screenProducer.next(value);
    };
    updateLocalScreenProducer = (value) => {
        this.localScreenProducer.next(value);
    };
    updateGotAllVids = (value) => {
        this.gotAllVids.next(value);
    };
    updatePaginationHeightWidth = (value) => {
        this.paginationHeightWidth.next(value);
    };
    updatePaginationDirection = (value) => {
        this.paginationDirection.next(value);
    };
    updateGridSizes = (value) => {
        this.gridSizes.next(value);
    };
    updateScreenForceFullDisplay = (value) => {
        this.screenForceFullDisplay.next(value);
    };
    updateMainGridStream = (value) => {
        this.mainGridStream.next(value);
    };
    updateOtherGridStreams = (value) => {
        this.otherGridStreams.next(value);
    };
    updateAudioOnlyStreams = (value) => {
        this.audioOnlyStreams.next(value);
    };
    updateVideoInputs = (value) => {
        this.videoInputs.next(value);
    };
    updateAudioInputs = (value) => {
        this.audioInputs.next(value);
    };
    updateMeetingProgressTime = (value) => {
        this.meetingProgressTime.next(value);
    };
    updateMeetingElapsedTime = (value) => {
        this.meetingElapsedTime.next(value);
    };
    updateRef_participants = (value) => {
        this.ref_participants.next(value);
    };
    // Messages
    messages = new BehaviorSubject$1([]);
    startDirectMessage = new BehaviorSubject$1(false);
    directMessageDetails = new BehaviorSubject$1(null);
    showMessagesBadge = new BehaviorSubject$1(false);
    // Event Settings
    audioSetting = new BehaviorSubject$1('allow');
    videoSetting = new BehaviorSubject$1('allow');
    screenshareSetting = new BehaviorSubject$1('allow');
    chatSetting = new BehaviorSubject$1('allow');
    // Display Settings
    displayOption = new BehaviorSubject$1('media');
    autoWave = new BehaviorSubject$1(true);
    forceFullDisplay = new BehaviorSubject$1(true);
    prevForceFullDisplay = new BehaviorSubject$1(false);
    prevMeetingDisplayType = new BehaviorSubject$1('video');
    // Waiting Room
    waitingRoomFilter = new BehaviorSubject$1('');
    waitingRoomList = new BehaviorSubject$1(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    waitingRoomCounter = new BehaviorSubject$1(0);
    filteredWaitingRoomList = new BehaviorSubject$1(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    // Requests
    requestFilter = new BehaviorSubject$1('');
    requestList = new BehaviorSubject$1(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    requestCounter = new BehaviorSubject$1(0);
    filteredRequestList = new BehaviorSubject$1(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    // Total Requests and Waiting Room
    totalReqWait = new BehaviorSubject$1(0);
    // Alerts
    alertVisible = new BehaviorSubject$1(false);
    alertMessage = new BehaviorSubject$1('');
    alertType = new BehaviorSubject$1('success');
    alertDuration = new BehaviorSubject$1(3000);
    // Progress Timer
    progressTimerVisible = new BehaviorSubject$1(true);
    progressTimerValue = new BehaviorSubject$1(0);
    // Menu Modals
    isMenuModalVisible = new BehaviorSubject$1(false);
    isRecordingModalVisible = new BehaviorSubject$1(false);
    isSettingsModalVisible = new BehaviorSubject$1(false);
    isRequestsModalVisible = new BehaviorSubject$1(false);
    isWaitingModalVisible = new BehaviorSubject$1(false);
    isCoHostModalVisible = new BehaviorSubject$1(false);
    isMediaSettingsModalVisible = new BehaviorSubject$1(false);
    isDisplaySettingsModalVisible = new BehaviorSubject$1(false);
    // Other Modals
    isParticipantsModalVisible = new BehaviorSubject$1(false);
    isMessagesModalVisible = new BehaviorSubject$1(false);
    isConfirmExitModalVisible = new BehaviorSubject$1(false);
    isConfirmHereModalVisible = new BehaviorSubject$1(false);
    isShareEventModalVisible = new BehaviorSubject$1(false);
    isLoadingModalVisible = new BehaviorSubject$1(false);
    // Recording Options
    recordingMediaOptions = new BehaviorSubject$1('video');
    recordingAudioOptions = new BehaviorSubject$1('all');
    recordingVideoOptions = new BehaviorSubject$1('all');
    recordingVideoType = new BehaviorSubject$1('fullDisplay');
    recordingVideoOptimized = new BehaviorSubject$1(false);
    recordingDisplayType = new BehaviorSubject$1('video');
    recordingAddHLS = new BehaviorSubject$1(true);
    recordingNameTags = new BehaviorSubject$1(true);
    recordingBackgroundColor = new BehaviorSubject$1('#83c0e9');
    recordingNameTagsColor = new BehaviorSubject$1('#ffffff');
    recordingAddText = new BehaviorSubject$1(false);
    recordingCustomText = new BehaviorSubject$1('Add Text');
    recordingCustomTextPosition = new BehaviorSubject$1('top');
    recordingCustomTextColor = new BehaviorSubject$1('#ffffff');
    recordingOrientationVideo = new BehaviorSubject$1('landscape');
    clearedToResume = new BehaviorSubject$1(true);
    clearedToRecord = new BehaviorSubject$1(true);
    recordState = new BehaviorSubject$1('green');
    showRecordButtons = new BehaviorSubject$1(false);
    recordingProgressTime = new BehaviorSubject$1('00:00:00');
    audioSwitching = new BehaviorSubject$1(false);
    videoSwitching = new BehaviorSubject$1(false);
    // Media States
    videoAlreadyOn = new BehaviorSubject$1(false);
    audioAlreadyOn = new BehaviorSubject$1(false);
    componentSizes = new BehaviorSubject$1({
        mainHeight: 0,
        otherHeight: 0,
        mainWidth: 0,
        otherWidth: 0,
    });
    // Permissions
    hasCameraPermission = new BehaviorSubject$1(false);
    hasAudioPermission = new BehaviorSubject$1(false);
    // Transports
    transportCreated = new BehaviorSubject$1(false);
    localTransportCreated = new BehaviorSubject$1(false);
    transportCreatedVideo = new BehaviorSubject$1(false);
    transportCreatedAudio = new BehaviorSubject$1(false);
    transportCreatedScreen = new BehaviorSubject$1(false);
    producerTransport = new BehaviorSubject$1(null);
    localProducerTransport = new BehaviorSubject$1(null);
    videoProducer = new BehaviorSubject$1(null);
    localVideoProducer = new BehaviorSubject$1(null);
    params = new BehaviorSubject$1({});
    videoParams = new BehaviorSubject$1({});
    audioParams = new BehaviorSubject$1({});
    audioProducer = new BehaviorSubject$1(null);
    audioLevel = new BehaviorSubject$1(0);
    localAudioProducer = new BehaviorSubject$1(null);
    consumerTransports = new BehaviorSubject$1([]);
    consumingTransports = new BehaviorSubject$1([]);
    // Polls
    polls = new BehaviorSubject$1(this.useSeed && this.seedData?.polls ? this.seedData.polls : []);
    poll = new BehaviorSubject$1(null);
    isPollModalVisible = new BehaviorSubject$1(false);
    // Background
    customImage = new BehaviorSubject$1('');
    selectedImage = new BehaviorSubject$1('');
    segmentVideo = new BehaviorSubject$1(null);
    selfieSegmentation = new BehaviorSubject$1(null);
    pauseSegmentation = new BehaviorSubject$1(false);
    processedStream = new BehaviorSubject$1(null);
    keepBackground = new BehaviorSubject$1(false);
    backgroundHasChanged = new BehaviorSubject$1(false);
    virtualStream = new BehaviorSubject$1(null);
    mainCanvas = new BehaviorSubject$1(null);
    prevKeepBackground = new BehaviorSubject$1(false);
    appliedBackground = new BehaviorSubject$1(false);
    isBackgroundModalVisible = new BehaviorSubject$1(false);
    autoClickBackground = new BehaviorSubject$1(false);
    // Breakout Rooms
    breakoutRooms = new BehaviorSubject$1(this.useSeed && this.seedData?.breakoutRooms ? this.seedData.breakoutRooms : []);
    currentRoomIndex = new BehaviorSubject$1(0);
    canStartBreakout = new BehaviorSubject$1(false);
    breakOutRoomStarted = new BehaviorSubject$1(false);
    breakOutRoomEnded = new BehaviorSubject$1(false);
    hostNewRoom = new BehaviorSubject$1(-1);
    limitedBreakRoom = new BehaviorSubject$1([]);
    mainRoomsLength = new BehaviorSubject$1(0);
    memberRoom = new BehaviorSubject$1(-1);
    isBreakoutRoomsModalVisible = new BehaviorSubject$1(false);
    // Whiteboard
    whiteboardUsers = new BehaviorSubject$1(this.useSeed && this.seedData?.whiteboardUsers ? this.seedData.whiteboardUsers : []);
    currentWhiteboardIndex = new BehaviorSubject$1(0);
    canStartWhiteboard = new BehaviorSubject$1(false);
    whiteboardStarted = new BehaviorSubject$1(false);
    whiteboardEnded = new BehaviorSubject$1(false);
    whiteboardLimit = new BehaviorSubject$1(4);
    isWhiteboardModalVisible = new BehaviorSubject$1(false);
    isConfigureWhiteboardModalVisible = new BehaviorSubject$1(false);
    shapes = new BehaviorSubject$1([]);
    useImageBackground = new BehaviorSubject$1(true);
    redoStack = new BehaviorSubject$1([]);
    undoStack = new BehaviorSubject$1([]);
    canvasStream = new BehaviorSubject$1(null);
    canvasWhiteboard = new BehaviorSubject$1(null);
    // Screenboard
    canvasScreenboard = new BehaviorSubject$1(null);
    processedScreenStream = new BehaviorSubject$1(null);
    annotateScreenStream = new BehaviorSubject$1(false);
    mainScreenCanvas = new BehaviorSubject$1(null);
    isScreenboardModalVisible = new BehaviorSubject$1(false);
    //state variables for the control buttons
    micActive = new BehaviorSubject$1(this.audioAlreadyOn.value ? this.audioAlreadyOn.value : false);
    videoActive = new BehaviorSubject$1(this.videoAlreadyOn.value ? this.videoAlreadyOn.value : false);
    screenShareActive = new BehaviorSubject$1(false);
    endCallActive = new BehaviorSubject$1(false);
    participantsActive = new BehaviorSubject$1(false);
    menuActive = new BehaviorSubject$1(false);
    commentsActive = new BehaviorSubject$1(false);
    // Update functions
    updateMessages = (value) => {
        this.messages.next(value);
    };
    updateStartDirectMessage = (value) => {
        this.startDirectMessage.next(value);
    };
    updateDirectMessageDetails = (value) => {
        this.directMessageDetails.next(value);
    };
    updateShowMessagesBadge = (value) => {
        this.showMessagesBadge.next(value);
    };
    updateAudioSetting = (value) => {
        this.audioSetting.next(value);
    };
    updateVideoSetting = (value) => {
        this.videoSetting.next(value);
    };
    updateScreenshareSetting = (value) => {
        this.screenshareSetting.next(value);
    };
    updateChatSetting = (value) => {
        this.chatSetting.next(value);
    };
    updateDisplayOption = (value) => {
        this.displayOption.next(value);
    };
    updateAutoWave = (value) => {
        this.autoWave.next(value);
    };
    updateForceFullDisplay = (value) => {
        this.forceFullDisplay.next(value);
    };
    updatePrevForceFullDisplay = (value) => {
        this.prevForceFullDisplay.next(value);
    };
    updatePrevMeetingDisplayType = (value) => {
        this.prevMeetingDisplayType.next(value);
    };
    updateWaitingRoomCounter = (value) => {
        this.waitingRoomCounter.next(value);
    };
    updateWaitingRoomFilter = (value) => {
        this.waitingRoomFilter.next(value);
    };
    updateWaitingRoomList = (value) => {
        this.waitingRoomList.next(value);
        this.filteredWaitingRoomList.next(value);
        this.waitingRoomCounter.next(value.length);
    };
    onWaitingRoomFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredWaitingRoom = this.waitingRoomList
                .getValue()
                .filter((waitingRoom) => {
                return waitingRoom.name.toLowerCase().includes(value.toLowerCase());
            });
            this.filteredWaitingRoomList.next(filteredWaitingRoom);
            this.waitingRoomCounter.next(filteredWaitingRoom.length);
        }
        else {
            this.filteredWaitingRoomList.next(this.waitingRoomList.getValue());
            this.waitingRoomCounter.next(this.waitingRoomList.getValue().length);
        }
    };
    onWaitingRoomClose = () => {
        this.updateIsWaitingModalVisible(false);
    };
    updateRequestCounter = (value) => {
        this.requestCounter.next(value);
    };
    updateRequestFilter = (value) => {
        this.requestFilter.next(value);
    };
    updateRequestList = (value) => {
        this.requestList.next(value);
        this.filteredRequestList.next(value);
        this.requestCounter.next(value.length);
    };
    onRequestFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredRequest = this.requestList.getValue().filter((request) => {
                return request?.name?.toLowerCase().includes(value.toLowerCase()) ?? false;
            });
            this.filteredRequestList.next(filteredRequest);
            this.requestCounter.next(filteredRequest.length);
        }
        else {
            this.filteredRequestList.next(this.requestList.getValue());
            this.requestCounter.next(this.requestList.getValue().length);
        }
    };
    onRequestClose = () => {
        this.updateIsRequestsModalVisible(false);
    };
    updateTotalReqWait = (value) => {
        this.totalReqWait.next(value);
    };
    updateAlertVisible = (value) => {
        this.alertVisible.next(value);
    };
    updateAlertMessage = (value) => {
        this.alertMessage.next(value);
    };
    updateAlertType = (value) => {
        this.alertType.next(value);
    };
    updateAlertDuration = (value) => {
        this.alertDuration.next(value);
    };
    updateProgressTimerVisible = (value) => {
        this.progressTimerVisible.next(value);
    };
    updateProgressTimerValue = (value) => {
        this.progressTimerValue.next(value);
    };
    updateIsMenuModalVisible = (value) => {
        this.isMenuModalVisible.next(value);
    };
    updateIsRecordingModalVisible = (value) => {
        this.isRecordingModalVisible.next(value);
        if (value) {
            this.updateConfirmedToRecord(false);
        }
        else {
            if (this.clearedToRecord.getValue() &&
                this.clearedToResume.getValue() &&
                this.recordStarted.getValue()) {
                this.updateShowRecordButtons(true);
            }
        }
    };
    updateIsSettingsModalVisible = (value) => {
        this.isSettingsModalVisible.next(value);
    };
    updateIsRequestsModalVisible = (value) => {
        this.isRequestsModalVisible.next(value);
    };
    updateIsWaitingModalVisible = (value) => {
        this.isWaitingModalVisible.next(value);
    };
    updateIsCoHostModalVisible = (value) => {
        this.isCoHostModalVisible.next(value);
    };
    updateIsMediaSettingsModalVisible = (value) => {
        this.isMediaSettingsModalVisible.next(value);
    };
    updateIsDisplaySettingsModalVisible = (value) => {
        this.isDisplaySettingsModalVisible.next(value);
    };
    updateIsParticipantsModalVisible = (value) => {
        this.isParticipantsModalVisible.next(value);
    };
    updateIsMessagesModalVisible = (value) => {
        this.isMessagesModalVisible.next(value);
        if (!value) {
            this.updateShowMessagesBadge(false);
        }
    };
    updateIsConfirmExitModalVisible = (value) => {
        this.isConfirmExitModalVisible.next(value);
    };
    updateIsConfirmHereModalVisible = (value) => {
        this.isConfirmHereModalVisible.next(value);
    };
    updateIsLoadingModalVisible = (value) => {
        this.isLoadingModalVisible.next(value);
    };
    updateIsShareEventModalVisible = (value) => {
        this.isShareEventModalVisible.next(value);
    };
    updateRecordingMediaOptions = (value) => {
        this.recordingMediaOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAudioOptions = (value) => {
        this.recordingAudioOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptions = (value) => {
        this.recordingVideoOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoType = (value) => {
        this.recordingVideoType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptimized = (value) => {
        this.recordingVideoOptimized.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingDisplayType = (value) => {
        this.recordingDisplayType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddHLS = (value) => {
        this.recordingAddHLS.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddText = (value) => {
        this.recordingAddText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomText = (value) => {
        this.recordingCustomText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextPosition = (value) => {
        this.recordingCustomTextPosition.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextColor = (value) => {
        this.recordingCustomTextColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTags = (value) => {
        this.recordingNameTags.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingBackgroundColor = (value) => {
        this.recordingBackgroundColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTagsColor = (value) => {
        this.recordingNameTagsColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingOrientationVideo = (value) => {
        this.recordingOrientationVideo.next(value);
        this.clearedToRecord.next(false);
    };
    updateClearedToResume = (value) => {
        this.clearedToResume.next(value);
    };
    updateClearedToRecord = (value) => {
        this.clearedToRecord.next(value);
    };
    updateRecordState = (value) => {
        if (this.recordStarted.value && !this.recordStopped.value) {
            if (!this.recordPaused.value) {
                this.recordState.next('red');
            }
            else {
                this.recordState.next('yellow');
            }
        }
        else {
            this.recordState.next(value);
        }
        this.recordState.next(value);
    };
    updateShowRecordButtons = (value) => {
        this.showRecordButtons.next(value);
    };
    updateRecordingProgressTime = (value) => {
        this.recordingProgressTime.next(value);
        this.updateRecordTimerWidget();
    };
    updateAudioSwitching = (value) => {
        this.audioSwitching.next(value);
    };
    updateVideoSwitching = (value) => {
        this.videoSwitching.next(value);
    };
    updateVideoAlreadyOn = (value) => {
        this.videoAlreadyOn.next(value);
        this.videoActive.next(value);
    };
    updateAudioAlreadyOn = (value) => {
        this.audioAlreadyOn.next(value);
        this.micActive.next(value);
    };
    updateComponentSizes = (sizes) => {
        this.componentSizes.next(sizes);
    };
    updateHasCameraPermission = (value) => {
        this.hasCameraPermission.next(value);
    };
    updateHasAudioPermission = (value) => {
        this.hasAudioPermission.next(value);
    };
    requestPermissionCamera() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    requestPermissionAudio() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    updateTransportCreated = (value) => {
        this.transportCreated.next(value);
    };
    updateLocalTransportCreated = (value) => {
        this.localTransportCreated.next(value);
    };
    updateTransportCreatedVideo = (value) => {
        this.transportCreatedVideo.next(value);
    };
    updateTransportCreatedAudio = (value) => {
        this.transportCreatedAudio.next(value);
    };
    updateTransportCreatedScreen = (value) => {
        this.transportCreatedScreen.next(value);
    };
    updateProducerTransport = (value) => {
        this.producerTransport.next(value);
    };
    updateLocalProducerTransport = (value) => {
        this.localProducerTransport.next(value);
    };
    updateVideoProducer = (value) => {
        this.videoProducer.next(value);
    };
    updateLocalVideoProducer = (value) => {
        this.localVideoProducer.next(value);
    };
    updateParams = (value) => {
        this.params.next(value);
    };
    updateVideoParams = (value) => {
        this.videoParams.next(value);
    };
    updateAudioParams = (value) => {
        this.audioParams.next(value);
    };
    updateAudioProducer = (value) => {
        this.audioProducer.next(value);
    };
    updateAudioLevel = (value) => {
        this.audioLevel.next(value);
    };
    updateLocalAudioProducer = (value) => {
        this.localAudioProducer.next(value);
    };
    updateConsumerTransports = (value) => {
        this.consumerTransports.next(value);
    };
    updateConsumingTransports = (value) => {
        this.consumingTransports.next(value);
    };
    updatePolls = (value) => {
        this.polls.next(value);
    };
    updatePoll = (value) => {
        this.poll.next(value);
    };
    updateIsPollModalVisible = (value) => {
        this.isPollModalVisible.next(value);
    };
    updateCustomImage = (value) => {
        this.customImage.next(value);
    };
    updateSelectedImage = (value) => {
        this.selectedImage.next(value);
    };
    updateSegmentVideo = (value) => {
        this.segmentVideo.next(value);
    };
    updateSelfieSegmentation = (value) => {
        this.selfieSegmentation.next(value);
    };
    updatePauseSegmentation = (value) => {
        this.pauseSegmentation.next(value);
    };
    updateProcessedStream = (value) => {
        this.processedStream.next(value);
    };
    updateKeepBackground = (value) => {
        this.keepBackground.next(value);
    };
    updateBackgroundHasChanged = (value) => {
        this.backgroundHasChanged.next(value);
    };
    updateVirtualStream = (value) => {
        this.virtualStream.next(value);
    };
    updateMainCanvas = (value) => {
        this.mainCanvas.next(value);
    };
    updatePrevKeepBackground = (value) => {
        this.prevKeepBackground.next(value);
    };
    updateAppliedBackground = (value) => {
        this.appliedBackground.next(value);
    };
    updateIsBackgroundModalVisible = (value) => {
        this.isBackgroundModalVisible.next(value);
    };
    updateAutoClickBackground = (value) => {
        this.autoClickBackground.next(value);
    };
    updateBreakoutRooms = (value) => {
        this.breakoutRooms.next(value);
    };
    updateCurrentRoomIndex = (value) => {
        this.currentRoomIndex.next(value);
    };
    updateCanStartBreakout = (value) => {
        this.canStartBreakout.next(value);
    };
    updateBreakOutRoomStarted = (value) => {
        this.breakOutRoomStarted.next(value);
    };
    updateBreakOutRoomEnded = (value) => {
        this.breakOutRoomEnded.next(value);
    };
    updateHostNewRoom = (value) => {
        this.hostNewRoom.next(value);
    };
    updateLimitedBreakRoom = (value) => {
        this.limitedBreakRoom.next(value);
    };
    updateMainRoomsLength = (value) => {
        this.mainRoomsLength.next(value);
    };
    updateMemberRoom = (value) => {
        this.memberRoom.next(value);
    };
    updateIsBreakoutRoomsModalVisible = (value) => {
        this.isBreakoutRoomsModalVisible.next(value);
    };
    updateWhiteboardUsers = (value) => {
        this.whiteboardUsers.next(value);
    };
    updateCurrentWhiteboardIndex = (value) => {
        this.currentWhiteboardIndex.next(value);
    };
    updateCanStartWhiteboard = (value) => {
        this.canStartWhiteboard.next(value);
    };
    updateWhiteboardStarted = (value) => {
        this.whiteboardStarted.next(value);
    };
    updateWhiteboardEnded = (value) => {
        this.whiteboardEnded.next(value);
    };
    updateWhiteboardLimit = (value) => {
        this.whiteboardLimit.next(value);
    };
    updateIsWhiteboardModalVisible = (value) => {
        this.isWhiteboardModalVisible.next(value);
    };
    updateIsConfigureWhiteboardModalVisible = (value) => {
        this.isConfigureWhiteboardModalVisible.next(value);
    };
    updateShapes = (value) => {
        this.shapes.next(value);
    };
    updateUseImageBackground = (value) => {
        this.useImageBackground.next(value);
    };
    updateRedoStack = (value) => {
        this.redoStack.next(value);
    };
    updateUndoStack = (value) => {
        this.undoStack.next(value);
    };
    updateCanvasStream = (value) => {
        this.canvasStream.next(value);
    };
    updateCanvasWhiteboard = (value) => {
        this.canvasWhiteboard.next(value);
    };
    updateCanvasScreenboard = (value) => {
        this.canvasScreenboard.next(value);
    };
    updateProcessedScreenStream = (value) => {
        this.processedScreenStream.next(value);
    };
    updateAnnotateScreenStream = (value) => {
        this.annotateScreenStream.next(value);
    };
    updateMainScreenCanvas = (value) => {
        this.mainScreenCanvas.next(value);
    };
    updateIsScreenboardModalVisible = (value) => {
        this.isScreenboardModalVisible.next(value);
    };
    checkOrientation = () => {
        const isPortrait = window.matchMedia('(orientation: portrait)').matches;
        return isPortrait ? 'portrait' : 'landscape';
    };
    showAlert = ({ message, type, duration = 3000, }) => {
        this.updateAlertMessage(message);
        this.updateAlertType(type);
        this.updateAlertDuration(duration);
        this.updateAlertVisible(true);
    };
    getAllParams() {
        return {
            localUIMode: this.localUIMode.value, // Local UI mode
            // Room Details
            roomName: this.roomName.value,
            member: this.member.value,
            adminPasscode: this.adminPasscode.value,
            youAreCoHost: this.youAreCoHost.value,
            youAreHost: this.youAreHost.value,
            islevel: this.islevel.value,
            confirmedToRecord: this.confirmedToRecord.value,
            meetingDisplayType: this.meetingDisplayType.value,
            meetingVideoOptimized: this.meetingVideoOptimized.value,
            eventType: this.eventType.value,
            participants: this.participants.value,
            filteredParticipants: this.filteredParticipants.value,
            participantsCounter: this.participantsCounter.value,
            participantsFilter: this.participantsFilter.value,
            // More room details - media
            consume_sockets: this.consume_sockets.value,
            rtpCapabilities: this.rtpCapabilities.value,
            roomRecvIPs: this.roomRecvIPs.value,
            meetingRoomParams: this.meetingRoomParams.value,
            itemPageLimit: this.itemPageLimit.value,
            audioOnlyRoom: this.audioOnlyRoom.value,
            addForBasic: this.addForBasic.value,
            screenPageLimit: this.screenPageLimit.value,
            shareScreenStarted: this.shareScreenStarted.value,
            shared: this.shared.value,
            targetOrientation: this.targetOrientation.value,
            targetResolution: this.targetResolution.value,
            targetResolutionHost: this.targetResolutionHost.value,
            vidCons: this.vidCons.value,
            frameRate: this.frameRate.value,
            hParams: this.hParams.value,
            vParams: this.vParams.value,
            screenParams: this.screenParams.value,
            aParams: this.aParams.value,
            // More room details - recording
            recordingAudioPausesLimit: this.recordingAudioPausesLimit.value,
            recordingAudioPausesCount: this.recordingAudioPausesCount.value,
            recordingAudioSupport: this.recordingAudioSupport.value,
            recordingAudioPeopleLimit: this.recordingAudioPeopleLimit.value,
            recordingAudioParticipantsTimeLimit: this.recordingAudioParticipantsTimeLimit.value,
            recordingVideoPausesCount: this.recordingVideoPausesCount.value,
            recordingVideoPausesLimit: this.recordingVideoPausesLimit.value,
            recordingVideoSupport: this.recordingVideoSupport.value,
            recordingVideoPeopleLimit: this.recordingVideoPeopleLimit.value,
            recordingVideoParticipantsTimeLimit: this.recordingVideoParticipantsTimeLimit.value,
            recordingAllParticipantsSupport: this.recordingAllParticipantsSupport.value,
            recordingVideoParticipantsSupport: this.recordingVideoParticipantsSupport.value,
            recordingAllParticipantsFullRoomSupport: this.recordingAllParticipantsFullRoomSupport.value,
            recordingVideoParticipantsFullRoomSupport: this.recordingVideoParticipantsFullRoomSupport.value,
            recordingPreferredOrientation: this.recordingPreferredOrientation.value,
            recordingSupportForOtherOrientation: this.recordingSupportForOtherOrientation.value,
            recordingMultiFormatsSupport: this.recordingMultiFormatsSupport.value,
            userRecordingParams: this.userRecordingParams.value,
            canRecord: this.canRecord.value,
            startReport: this.startReport.value,
            endReport: this.endReport.value,
            recordStartTime: this.recordStartTime.value,
            recordElapsedTime: this.recordElapsedTime.value,
            isTimerRunning: this.isTimerRunning.value,
            canPauseResume: this.canPauseResume.value,
            recordChangeSeconds: this.recordChangeSeconds.value,
            pauseLimit: this.pauseLimit.value,
            pauseRecordCount: this.pauseRecordCount.value,
            canLaunchRecord: this.canLaunchRecord.value,
            stopLaunchRecord: this.stopLaunchRecord.value,
            participantsAll: this.participantsAll.value,
            firstAll: this.firstAll.value,
            updateMainWindow: this.updateMainWindow.value,
            first_round: this.first_round.value,
            landScaped: this.landScaped.value,
            lock_screen: this.lock_screen.value,
            screenId: this.screenId.value,
            allVideoStreams: this.allVideoStreams.value,
            newLimitedStreams: this.newLimitedStreams.value,
            newLimitedStreamsIDs: this.newLimitedStreamsIDs.value,
            activeSounds: this.activeSounds.value,
            screenShareIDStream: this.screenShareIDStream.value,
            screenShareNameStream: this.screenShareNameStream.value,
            adminIDStream: this.adminIDStream.value,
            adminNameStream: this.adminNameStream.value,
            youYouStream: this.youYouStream.value,
            youYouStreamIDs: this.youYouStreamIDs.value,
            localStream: this.localStream.value,
            recordStarted: this.recordStarted.value,
            recordResumed: this.recordResumed.value,
            recordPaused: this.recordPaused.value,
            recordStopped: this.recordStopped.value,
            adminRestrictSetting: this.adminRestrictSetting.value,
            videoRequestState: this.videoRequestState.value,
            videoRequestTime: this.videoRequestTime.value,
            videoAction: this.videoAction.value,
            localStreamVideo: this.localStreamVideo.value,
            userDefaultVideoInputDevice: this.userDefaultVideoInputDevice.value,
            currentFacingMode: this.currentFacingMode.value,
            prevFacingMode: this.prevFacingMode.value,
            defVideoID: this.defVideoID.value,
            allowed: this.allowed.value,
            dispActiveNames: this.dispActiveNames.value,
            p_dispActiveNames: this.p_dispActiveNames.value,
            activeNames: this.activeNames.value,
            prevActiveNames: this.prevActiveNames.value,
            p_activeNames: this.p_activeNames.value,
            membersReceived: this.membersReceived.value,
            deferScreenReceived: this.deferScreenReceived.value,
            hostFirstSwitch: this.hostFirstSwitch.value,
            micAction: this.micAction.value,
            screenAction: this.screenAction.value,
            chatAction: this.chatAction.value,
            audioRequestState: this.audioRequestState.value,
            screenRequestState: this.screenRequestState.value,
            chatRequestState: this.chatRequestState.value,
            audioRequestTime: this.audioRequestTime.value,
            screenRequestTime: this.screenRequestTime.value,
            chatRequestTime: this.chatRequestTime.value,
            updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
            oldSoundIds: this.oldSoundIds.value,
            hostLabel: this.hostLabel.value,
            mainScreenFilled: this.mainScreenFilled.value,
            localStreamScreen: this.localStreamScreen.value,
            screenAlreadyOn: this.screenAlreadyOn.value,
            chatAlreadyOn: this.chatAlreadyOn.value,
            redirectURL: this.redirectURL.value,
            oldAllStreams: this.oldAllStreams.value,
            adminVidID: this.adminVidID.value,
            streamNames: this.streamNames.value,
            non_alVideoStreams: this.non_alVideoStreams.value,
            sortAudioLoudness: this.sortAudioLoudness.value,
            audioDecibels: this.audioDecibels.value,
            mixed_alVideoStreams: this.mixed_alVideoStreams.value,
            non_alVideoStreams_muted: this.non_alVideoStreams_muted.value,
            paginatedStreams: this.paginatedStreams.value,
            localStreamAudio: this.localStreamAudio.value,
            defAudioID: this.defAudioID.value,
            userDefaultAudioInputDevice: this.userDefaultAudioInputDevice.value,
            userDefaultAudioOutputDevice: this.userDefaultAudioOutputDevice.value,
            prevAudioInputDevice: this.prevAudioInputDevice.value,
            prevVideoInputDevice: this.prevVideoInputDevice.value,
            audioPaused: this.audioPaused.value,
            mainScreenPerson: this.mainScreenPerson.value,
            adminOnMainScreen: this.adminOnMainScreen.value,
            screenStates: this.screenStates.value,
            prevScreenStates: this.prevScreenStates.value,
            updateDateState: this.updateDateState.value,
            lastUpdate: this.lastUpdate.value,
            nForReadjustRecord: this.nForReadjustRecord.value,
            fixedPageLimit: this.fixedPageLimit.value,
            removeAltGrid: this.removeAltGrid.value,
            nForReadjust: this.nForReadjust.value,
            lastReorderTime: this.lastReorderTime.value,
            reorderInterval: this.reorderInterval.value,
            fastReorderInterval: this.fastReorderInterval.value,
            audStreamNames: this.audStreamNames.value,
            currentUserPage: this.currentUserPage.value,
            mainHeightWidth: this.mainHeightWidth.value,
            prevMainHeightWidth: this.prevMainHeightWidth.value,
            prevDoPaginate: this.prevDoPaginate.value,
            doPaginate: this.doPaginate.value,
            shareEnded: this.shareEnded.value,
            lStreams: this.lStreams.value,
            chatRefStreams: this.chatRefStreams.value,
            controlHeight: this.controlHeight.value,
            isWideScreen: this.isWideScreen.value,
            isMediumScreen: this.isMediumScreen.value,
            isSmallScreen: this.isSmallScreen.value,
            addGrid: this.addGrid.value,
            addAltGrid: this.addAltGrid.value,
            gridRows: this.gridRows.value,
            gridCols: this.gridCols.value,
            altGridRows: this.altGridRows.value,
            altGridCols: this.altGridCols.value,
            numberPages: this.numberPages.value,
            currentStreams: this.currentStreams.value,
            showMiniView: this.showMiniView.value,
            nStream: this.nStream.value,
            defer_receive: this.defer_receive.value,
            allAudioStreams: this.allAudioStreams.value,
            screenProducer: this.screenProducer.value,
            remoteScreenStream: this.remoteScreenStream.value,
            gotAllVids: this.gotAllVids.value,
            paginationHeightWidth: this.paginationHeightWidth.value,
            paginationDirection: this.paginationDirection.value,
            gridSizes: this.gridSizes.value,
            screenForceFullDisplay: this.screenForceFullDisplay.value,
            mainGridStream: this.mainGridStream.value,
            otherGridStreams: this.otherGridStreams.value,
            audioOnlyStreams: this.audioOnlyStreams.value,
            videoInputs: this.videoInputs.value,
            audioInputs: this.audioInputs.value,
            meetingProgressTime: this.meetingProgressTime.value,
            meetingElapsedTime: this.meetingElapsedTime.value,
            ref_participants: this.ref_participants.value,
            messages: this.messages.value,
            startDirectMessage: this.startDirectMessage.value,
            directMessageDetails: this.directMessageDetails.value,
            coHost: this.coHost.value,
            coHostResponsibility: this.coHostResponsibility.value,
            // Event settings
            audioSetting: this.audioSetting.value,
            videoSetting: this.videoSetting.value,
            screenshareSetting: this.screenshareSetting.value,
            chatSetting: this.chatSetting.value,
            // Display settings
            autoWave: this.autoWave.value,
            forceFullDisplay: this.forceFullDisplay.value,
            prevForceFullDisplay: this.prevForceFullDisplay.value,
            prevMeetingDisplayType: this.prevMeetingDisplayType.value,
            // Waiting room
            waitingRoomFilter: this.waitingRoomFilter.value,
            waitingRoomList: this.waitingRoomList.value,
            waitingRoomCounter: this.waitingRoomCounter.value,
            filteredWaitingRoomList: this.filteredWaitingRoomList.value,
            // Requests
            requestFilter: this.requestFilter.value,
            requestList: this.requestList.value,
            requestCounter: this.requestCounter.value,
            filteredRequestList: this.filteredRequestList.value,
            // Total requests and waiting room
            totalReqWait: this.totalReqWait.value,
            // Alerts
            alertVisible: this.alertVisible.value,
            alertMessage: this.alertMessage.value,
            alertType: this.alertType.value,
            alertDuration: this.alertDuration.value,
            // Progress Timer
            progressTimerVisible: this.progressTimerVisible.value,
            progressTimerValue: this.progressTimerValue.value,
            // Menu modals
            isMenuModalVisible: this.isMenuModalVisible.value,
            isRecordingModalVisible: this.isRecordingModalVisible.value,
            isSettingsModalVisible: this.isSettingsModalVisible.value,
            isRequestsModalVisible: this.isRequestsModalVisible.value,
            isWaitingModalVisible: this.isWaitingModalVisible.value,
            isCoHostModalVisible: this.isCoHostModalVisible.value,
            isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
            isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            // Other Modals
            isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            isMessagesModalVisible: this.isMessagesModalVisible.value,
            isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            isConfirmHereModalVisible: this.isConfirmHereModalVisible.value,
            isLoadingModalVisible: this.isLoadingModalVisible.value,
            // Recording Options
            recordingMediaOptions: this.recordingMediaOptions.value,
            recordingAudioOptions: this.recordingAudioOptions.value,
            recordingVideoOptions: this.recordingVideoOptions.value,
            recordingVideoType: this.recordingVideoType.value,
            recordingVideoOptimized: this.recordingVideoOptimized.value,
            recordingDisplayType: this.recordingDisplayType.value,
            recordingAddHLS: this.recordingAddHLS.value,
            recordingAddText: this.recordingAddText.value,
            recordingCustomText: this.recordingCustomText.value,
            recordingCustomTextPosition: this.recordingCustomTextPosition.value,
            recordingCustomTextColor: this.recordingCustomTextColor.value,
            recordingNameTags: this.recordingNameTags.value,
            recordingBackgroundColor: this.recordingBackgroundColor.value,
            recordingNameTagsColor: this.recordingNameTagsColor.value,
            recordingOrientationVideo: this.recordingOrientationVideo.value,
            clearedToResume: this.clearedToResume.value,
            clearedToRecord: this.clearedToRecord.value,
            recordState: this.recordState.value,
            showRecordButtons: this.showRecordButtons.value,
            recordingProgressTime: this.recordingProgressTime.value,
            audioSwitching: this.audioSwitching.value,
            videoSwitching: this.videoSwitching.value,
            // Media states
            videoAlreadyOn: this.videoAlreadyOn.value,
            audioAlreadyOn: this.audioAlreadyOn.value,
            componentSizes: this.componentSizes.value,
            // Permissions
            hasCameraPermission: this.hasCameraPermission.value,
            hasAudioPermission: this.hasAudioPermission.value,
            // Transports
            transportCreated: this.transportCreated.value,
            localTransportCreated: this.localTransportCreated.value,
            transportCreatedVideo: this.transportCreatedVideo.value,
            transportCreatedAudio: this.transportCreatedAudio.value,
            transportCreatedScreen: this.transportCreatedScreen.value,
            producerTransport: this.producerTransport.value,
            localProducerTransport: this.localProducerTransport.value,
            videoProducer: this.videoProducer.value,
            localVideoProducer: this.localVideoProducer.value,
            params: this.params.value,
            videoParams: this.videoParams.value,
            audioParams: this.audioParams.value,
            audioProducer: this.audioProducer.value,
            audioLevel: this.audioLevel.value,
            localAudioProducer: this.localAudioProducer.value,
            consumerTransports: this.consumerTransports.value,
            consumingTransports: this.consumingTransports.value,
            // Polls
            polls: this.polls.value,
            poll: this.poll.value,
            isPollModalVisible: this.isPollModalVisible.value,
            // Background
            customImage: this.customImage.value,
            selectedImage: this.selectedImage.value,
            segmentVideo: this.segmentVideo.value,
            selfieSegmentation: this.selfieSegmentation.value,
            pauseSegmentation: this.pauseSegmentation.value,
            processedStream: this.processedStream.value,
            keepBackground: this.keepBackground.value,
            backgroundHasChanged: this.backgroundHasChanged.value,
            virtualStream: this.virtualStream.value,
            mainCanvas: this.mainCanvas.value,
            prevKeepBackground: this.prevKeepBackground.value,
            appliedBackground: this.appliedBackground.value,
            isBackgroundModalVisible: this.isBackgroundModalVisible.value,
            autoClickBackground: this.autoClickBackground.value,
            // Breakout rooms
            breakoutRooms: this.breakoutRooms.value,
            currentRoomIndex: this.currentRoomIndex.value,
            canStartBreakout: this.canStartBreakout.value,
            breakOutRoomStarted: this.breakOutRoomStarted.value,
            breakOutRoomEnded: this.breakOutRoomEnded.value,
            hostNewRoom: this.hostNewRoom.value,
            limitedBreakRoom: this.limitedBreakRoom.value,
            mainRoomsLength: this.mainRoomsLength.value,
            memberRoom: this.memberRoom.value,
            isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            // Whiteboard
            whiteboardUsers: this.whiteboardUsers.value,
            currentWhiteboardIndex: this.currentWhiteboardIndex.value,
            canStartWhiteboard: this.canStartWhiteboard.value,
            whiteboardStarted: this.whiteboardStarted.value,
            whiteboardEnded: this.whiteboardEnded.value,
            whiteboardLimit: this.whiteboardLimit.value,
            isWhiteboardModalVisible: this.isWhiteboardModalVisible.value,
            isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            shapes: this.shapes.value,
            useImageBackground: this.useImageBackground.value,
            redoStack: this.redoStack.value,
            undoStack: this.undoStack.value,
            canvasStream: this.canvasStream.value,
            canvasWhiteboard: this.canvasWhiteboard.value,
            // Screenboard
            canvasScreenboard: this.canvasScreenboard.value,
            processedScreenStream: this.processedScreenStream.value,
            annotateScreenStream: this.annotateScreenStream.value,
            mainScreenCanvas: this.mainScreenCanvas.value,
            isScreenboardModalVisible: this.isScreenboardModalVisible.value,
            validated: this.validated.value,
            device: this.device.value,
            socket: this.socket.value,
            localSocket: this.localSocket.value,
            checkMediaPermission: false,
            onWeb: true,
            // Update functions
            updateRoomName: this.updateRoomName.bind(this),
            updateMember: this.updateMember.bind(this),
            updateAdminPasscode: this.updateAdminPasscode.bind(this),
            updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
            updateYouAreHost: this.updateYouAreHost.bind(this),
            updateIslevel: this.updateIslevel.bind(this),
            updateCoHost: this.updateCoHost.bind(this),
            updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
            updateConfirmedToRecord: this.updateConfirmedToRecord.bind(this),
            updateMeetingDisplayType: this.updateMeetingDisplayType.bind(this),
            updateMeetingVideoOptimized: this.updateMeetingVideoOptimized.bind(this),
            updateEventType: this.updateEventType.bind(this),
            updateParticipants: this.updateParticipants.bind(this),
            updateParticipantsCounter: this.updateParticipantsCounter.bind(this),
            updateParticipantsFilter: this.updateParticipantsFilter.bind(this),
            // More update functions for media details
            updateConsume_sockets: this.updateConsume_sockets.bind(this),
            updateRtpCapabilities: this.updateRtpCapabilities.bind(this),
            updateRoomRecvIPs: this.updateRoomRecvIPs.bind(this),
            updateMeetingRoomParams: this.updateMeetingRoomParams.bind(this),
            updateItemPageLimit: this.updateItemPageLimit.bind(this),
            updateAudioOnlyRoom: this.updateAudioOnlyRoom.bind(this),
            updateAddForBasic: this.updateAddForBasic.bind(this),
            updateScreenPageLimit: this.updateScreenPageLimit.bind(this),
            updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
            updateShared: this.updateShared.bind(this),
            updateTargetOrientation: this.updateTargetOrientation.bind(this),
            updateTargetResolution: this.updateTargetResolution.bind(this),
            updateTargetResolutionHost: this.updateTargetResolutionHost.bind(this),
            updateVidCons: this.updateVidCons.bind(this),
            updateFrameRate: this.updateFrameRate.bind(this),
            updateHParams: this.updateHParams.bind(this),
            updateVParams: this.updateVParams.bind(this),
            updateScreenParams: this.updateScreenParams.bind(this),
            updateAParams: this.updateAParams.bind(this),
            // More update functions for recording details
            updateRecordingAudioPausesLimit: this.updateRecordingAudioPausesLimit.bind(this),
            updateRecordingAudioPausesCount: this.updateRecordingAudioPausesCount.bind(this),
            updateRecordingAudioSupport: this.updateRecordingAudioSupport.bind(this),
            updateRecordingAudioPeopleLimit: this.updateRecordingAudioPeopleLimit.bind(this),
            updateRecordingAudioParticipantsTimeLimit: this.updateRecordingAudioParticipantsTimeLimit.bind(this),
            updateRecordingVideoPausesCount: this.updateRecordingVideoPausesCount.bind(this),
            updateRecordingVideoPausesLimit: this.updateRecordingVideoPausesLimit.bind(this),
            updateRecordingVideoSupport: this.updateRecordingVideoSupport.bind(this),
            updateRecordingVideoPeopleLimit: this.updateRecordingVideoPeopleLimit.bind(this),
            updateRecordingVideoParticipantsTimeLimit: this.updateRecordingVideoParticipantsTimeLimit.bind(this),
            updateRecordingAllParticipantsSupport: this.updateRecordingAllParticipantsSupport.bind(this),
            updateRecordingVideoParticipantsSupport: this.updateRecordingVideoParticipantsSupport.bind(this),
            updateRecordingAllParticipantsFullRoomSupport: this.updateRecordingAllParticipantsFullRoomSupport.bind(this),
            updateRecordingVideoParticipantsFullRoomSupport: this.updateRecordingVideoParticipantsFullRoomSupport.bind(this),
            updateRecordingPreferredOrientation: this.updateRecordingPreferredOrientation.bind(this),
            updateRecordingSupportForOtherOrientation: this.updateRecordingSupportForOtherOrientation.bind(this),
            updateRecordingMultiFormatsSupport: this.updateRecordingMultiFormatsSupport.bind(this),
            updateUserRecordingParams: this.updateUserRecordingParams.bind(this),
            updateCanRecord: this.updateCanRecord.bind(this),
            updateStartReport: this.updateStartReport.bind(this),
            updateEndReport: this.updateEndReport.bind(this),
            updateRecordTimerInterval: this.updateRecordTimerInterval.bind(this),
            updateRecordStartTime: this.updateRecordStartTime.bind(this),
            updateRecordElapsedTime: this.updateRecordElapsedTime.bind(this),
            updateIsTimerRunning: this.updateIsTimerRunning.bind(this),
            updateCanPauseResume: this.updateCanPauseResume.bind(this),
            updateRecordChangeSeconds: this.updateRecordChangeSeconds.bind(this),
            updatePauseLimit: this.updatePauseLimit.bind(this),
            updatePauseRecordCount: this.updatePauseRecordCount.bind(this),
            updateCanLaunchRecord: this.updateCanLaunchRecord.bind(this),
            updateStopLaunchRecord: this.updateStopLaunchRecord.bind(this),
            updateParticipantsAll: this.updateParticipantsAll.bind(this),
            updateFirstAll: this.updateFirstAll.bind(this),
            updateUpdateMainWindow: this.updateUpdateMainWindow.bind(this),
            updateFirst_round: this.updateFirst_round.bind(this),
            updateLandScaped: this.updateLandScaped.bind(this),
            updateLock_screen: this.updateLock_screen.bind(this),
            updateScreenId: this.updateScreenId.bind(this),
            updateAllVideoStreams: this.updateAllVideoStreams.bind(this),
            updateNewLimitedStreams: this.updateNewLimitedStreams.bind(this),
            updateNewLimitedStreamsIDs: this.updateNewLimitedStreamsIDs.bind(this),
            updateActiveSounds: this.updateActiveSounds.bind(this),
            updateScreenShareIDStream: this.updateScreenShareIDStream.bind(this),
            updateScreenShareNameStream: this.updateScreenShareNameStream.bind(this),
            updateAdminIDStream: this.updateAdminIDStream.bind(this),
            updateAdminNameStream: this.updateAdminNameStream.bind(this),
            updateYouYouStream: this.updateYouYouStream.bind(this),
            updateYouYouStreamIDs: this.updateYouYouStreamIDs.bind(this),
            updateLocalStream: this.updateLocalStream.bind(this),
            updateRecordStarted: this.updateRecordStarted.bind(this),
            updateRecordResumed: this.updateRecordResumed.bind(this),
            updateRecordPaused: this.updateRecordPaused.bind(this),
            updateRecordStopped: this.updateRecordStopped.bind(this),
            updateAdminRestrictSetting: this.updateAdminRestrictSetting.bind(this),
            updateVideoRequestState: this.updateVideoRequestState.bind(this),
            updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
            updateVideoAction: this.updateVideoAction.bind(this),
            updateLocalStreamVideo: this.updateLocalStreamVideo.bind(this),
            updateUserDefaultVideoInputDevice: this.updateUserDefaultVideoInputDevice.bind(this),
            updateCurrentFacingMode: this.updateCurrentFacingMode.bind(this),
            updatePrevFacingMode: this.updatePrevFacingMode.bind(this),
            updateDefVideoID: this.updateDefVideoID.bind(this),
            updateAllowed: this.updateAllowed.bind(this),
            updateDispActiveNames: this.updateDispActiveNames.bind(this),
            updateP_dispActiveNames: this.updateP_dispActiveNames.bind(this),
            updateActiveNames: this.updateActiveNames.bind(this),
            updatePrevActiveNames: this.updatePrevActiveNames.bind(this),
            updateP_activeNames: this.updateP_activeNames.bind(this),
            updateMembersReceived: this.updateMembersReceived.bind(this),
            updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
            updateHostFirstSwitch: this.updateHostFirstSwitch.bind(this),
            updateMicAction: this.updateMicAction.bind(this),
            updateScreenAction: this.updateScreenAction.bind(this),
            updateChatAction: this.updateChatAction.bind(this),
            updateAudioRequestState: this.updateAudioRequestState.bind(this),
            updateScreenRequestState: this.updateScreenRequestState.bind(this),
            updateChatRequestState: this.updateChatRequestState.bind(this),
            updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
            updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
            updateChatRequestTime: this.updateChatRequestTime.bind(this),
            updateOldSoundIds: this.updateOldSoundIds.bind(this),
            updateHostLabel: this.updateHostLabel.bind(this),
            updateMainScreenFilled: this.updateMainScreenFilled.bind(this),
            updateLocalStreamScreen: this.updateLocalStreamScreen.bind(this),
            updateScreenAlreadyOn: this.updateScreenAlreadyOn.bind(this),
            updateChatAlreadyOn: this.updateChatAlreadyOn.bind(this),
            updateRedirectURL: this.updateRedirectURL.bind(this),
            updateOldAllStreams: this.updateOldAllStreams.bind(this),
            updateAdminVidID: this.updateAdminVidID.bind(this),
            updateStreamNames: this.updateStreamNames.bind(this),
            updateNon_alVideoStreams: this.updateNon_alVideoStreams.bind(this),
            updateSortAudioLoudness: this.updateSortAudioLoudness.bind(this),
            updateAudioDecibels: this.updateAudioDecibels.bind(this),
            updateMixed_alVideoStreams: this.updateMixed_alVideoStreams.bind(this),
            updateNon_alVideoStreams_muted: this.updateNon_alVideoStreams_muted.bind(this),
            updatePaginatedStreams: this.updatePaginatedStreams.bind(this),
            updateLocalStreamAudio: this.updateLocalStreamAudio.bind(this),
            updateDefAudioID: this.updateDefAudioID.bind(this),
            updateUserDefaultAudioInputDevice: this.updateUserDefaultAudioInputDevice.bind(this),
            updateUserDefaultAudioOutputDevice: this.updateUserDefaultAudioOutputDevice.bind(this),
            updatePrevAudioInputDevice: this.updatePrevAudioInputDevice.bind(this),
            updatePrevVideoInputDevice: this.updatePrevVideoInputDevice.bind(this),
            updateAudioPaused: this.updateAudioPaused.bind(this),
            updateMainScreenPerson: this.updateMainScreenPerson.bind(this),
            updateAdminOnMainScreen: this.updateAdminOnMainScreen.bind(this),
            updateScreenStates: this.updateScreenStates.bind(this),
            updatePrevScreenStates: this.updatePrevScreenStates.bind(this),
            updateUpdateDateState: this.updateUpdateDateState.bind(this),
            updateLastUpdate: this.updateLastUpdate.bind(this),
            updateNForReadjustRecord: this.updateNForReadjustRecord.bind(this),
            updateFixedPageLimit: this.updateFixedPageLimit.bind(this),
            updateRemoveAltGrid: this.updateRemoveAltGrid.bind(this),
            updateNForReadjust: this.updateNForReadjust.bind(this),
            updateLastReorderTime: this.updateLastReorderTime.bind(this),
            updateAudStreamNames: this.updateAudStreamNames.bind(this),
            updateCurrentUserPage: this.updateCurrentUserPage.bind(this),
            updateMainHeightWidth: this.updateMainHeightWidth.bind(this),
            updatePrevMainHeightWidth: this.updatePrevMainHeightWidth.bind(this),
            updatePrevDoPaginate: this.updatePrevDoPaginate.bind(this),
            updateDoPaginate: this.updateDoPaginate.bind(this),
            updateShareEnded: this.updateShareEnded.bind(this),
            updateLStreams: this.updateLStreams.bind(this),
            updateChatRefStreams: this.updateChatRefStreams.bind(this),
            updateControlHeight: this.updateControlHeight.bind(this),
            updateIsWideScreen: this.updateIsWideScreen.bind(this),
            updateIsMediumScreen: this.updateIsMediumScreen.bind(this),
            updateIsSmallScreen: this.updateIsSmallScreen.bind(this),
            updateAddGrid: this.updateAddGrid.bind(this),
            updateAddAltGrid: this.updateAddAltGrid.bind(this),
            updateGridRows: this.updateGridRows.bind(this),
            updateGridCols: this.updateGridCols.bind(this),
            updateAltGridRows: this.updateAltGridRows.bind(this),
            updateAltGridCols: this.updateAltGridCols.bind(this),
            updateNumberPages: this.updateNumberPages.bind(this),
            updateCurrentStreams: this.updateCurrentStreams.bind(this),
            updateShowMiniView: this.updateShowMiniView.bind(this),
            updateNStream: this.updateNStream.bind(this),
            updateDefer_receive: this.updateDefer_receive.bind(this),
            updateAllAudioStreams: this.updateAllAudioStreams.bind(this),
            updateRemoteScreenStream: this.updateRemoteScreenStream.bind(this),
            updateScreenProducer: this.updateScreenProducer.bind(this),
            updateGotAllVids: this.updateGotAllVids.bind(this),
            updatePaginationHeightWidth: this.updatePaginationHeightWidth.bind(this),
            updatePaginationDirection: this.updatePaginationDirection.bind(this),
            updateGridSizes: this.updateGridSizes.bind(this),
            updateScreenForceFullDisplay: this.updateScreenForceFullDisplay.bind(this),
            updateMainGridStream: this.updateMainGridStream.bind(this),
            updateOtherGridStreams: this.updateOtherGridStreams.bind(this),
            updateAudioOnlyStreams: this.updateAudioOnlyStreams.bind(this),
            updateVideoInputs: this.updateVideoInputs.bind(this),
            updateAudioInputs: this.updateAudioInputs.bind(this),
            updateMeetingProgressTime: this.updateMeetingProgressTime.bind(this),
            updateMeetingElapsedTime: this.updateMeetingElapsedTime.bind(this),
            updateRef_participants: this.updateRef_participants.bind(this),
            updateMessages: this.updateMessages.bind(this),
            updateStartDirectMessage: this.updateStartDirectMessage.bind(this),
            updateDirectMessageDetails: this.updateDirectMessageDetails.bind(this),
            updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
            // Event settings
            updateAudioSetting: this.updateAudioSetting.bind(this),
            updateVideoSetting: this.updateVideoSetting.bind(this),
            updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
            updateChatSetting: this.updateChatSetting.bind(this),
            // Display settings
            updateAutoWave: this.updateAutoWave.bind(this),
            updateForceFullDisplay: this.updateForceFullDisplay.bind(this),
            updatePrevForceFullDisplay: this.updatePrevForceFullDisplay.bind(this),
            updatePrevMeetingDisplayType: this.updatePrevMeetingDisplayType.bind(this),
            // Waiting room
            updateWaitingRoomFilter: this.updateWaitingRoomFilter.bind(this),
            updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
            updateWaitingRoomCounter: this.updateWaitingRoomCounter.bind(this),
            // Requests
            updateRequestFilter: this.updateRequestFilter.bind(this),
            updateRequestList: this.updateRequestList.bind(this),
            updateRequestCounter: this.updateRequestCounter.bind(this),
            // Total requests and waiting room
            updateTotalReqWait: this.updateTotalReqWait.bind(this),
            // Menu modals
            updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
            updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
            updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
            updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
            updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
            updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
            // Other modals
            updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
            updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
            updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
            updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
            updateIsLoadingModalVisible: this.updateIsLoadingModalVisible.bind(this),
            // Recording Options
            updateRecordingMediaOptions: this.updateRecordingMediaOptions.bind(this),
            updateRecordingAudioOptions: this.updateRecordingAudioOptions.bind(this),
            updateRecordingVideoOptions: this.updateRecordingVideoOptions.bind(this),
            updateRecordingVideoType: this.updateRecordingVideoType.bind(this),
            updateRecordingVideoOptimized: this.updateRecordingVideoOptimized.bind(this),
            updateRecordingDisplayType: this.updateRecordingDisplayType.bind(this),
            updateRecordingAddHLS: this.updateRecordingAddHLS.bind(this),
            updateRecordingAddText: this.updateRecordingAddText.bind(this),
            updateRecordingCustomText: this.updateRecordingCustomText.bind(this),
            updateRecordingCustomTextPosition: this.updateRecordingCustomTextPosition.bind(this),
            updateRecordingCustomTextColor: this.updateRecordingCustomTextColor.bind(this),
            updateRecordingNameTags: this.updateRecordingNameTags.bind(this),
            updateRecordingBackgroundColor: this.updateRecordingBackgroundColor.bind(this),
            updateRecordingNameTagsColor: this.updateRecordingNameTagsColor.bind(this),
            updateRecordingOrientationVideo: this.updateRecordingOrientationVideo.bind(this),
            updateClearedToResume: this.updateClearedToResume.bind(this),
            updateClearedToRecord: this.updateClearedToRecord.bind(this),
            updateRecordState: this.updateRecordState.bind(this),
            updateShowRecordButtons: this.updateShowRecordButtons.bind(this),
            updateRecordingProgressTime: this.updateRecordingProgressTime.bind(this),
            updateAudioSwitching: this.updateAudioSwitching.bind(this),
            updateVideoSwitching: this.updateVideoSwitching.bind(this),
            // Media states
            updateVideoAlreadyOn: this.updateVideoAlreadyOn.bind(this),
            updateAudioAlreadyOn: this.updateAudioAlreadyOn.bind(this),
            updateComponentSizes: this.updateComponentSizes.bind(this),
            // Permissions
            updateHasCameraPermission: this.updateHasCameraPermission.bind(this),
            updateHasAudioPermission: this.updateHasAudioPermission.bind(this),
            // Transports
            updateTransportCreated: this.updateTransportCreated.bind(this),
            updateLocalTransportCreated: this.updateLocalTransportCreated.bind(this),
            updateTransportCreatedVideo: this.updateTransportCreatedVideo.bind(this),
            updateTransportCreatedAudio: this.updateTransportCreatedAudio.bind(this),
            updateTransportCreatedScreen: this.updateTransportCreatedScreen.bind(this),
            updateProducerTransport: this.updateProducerTransport.bind(this),
            updateLocalProducerTransport: this.updateLocalProducerTransport.bind(this),
            updateVideoProducer: this.updateVideoProducer.bind(this),
            updateLocalVideoProducer: this.updateLocalVideoProducer.bind(this),
            updateParams: this.updateParams.bind(this),
            updateVideoParams: this.updateVideoParams.bind(this),
            updateAudioParams: this.updateAudioParams.bind(this),
            updateAudioProducer: this.updateAudioProducer.bind(this),
            updateAudioLevel: this.updateAudioLevel.bind(this),
            updateLocalAudioProducer: this.updateLocalAudioProducer.bind(this),
            updateConsumerTransports: this.updateConsumerTransports.bind(this),
            updateConsumingTransports: this.updateConsumingTransports.bind(this),
            // Polls
            updatePolls: this.updatePolls.bind(this),
            updatePoll: this.updatePoll.bind(this),
            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
            // Background
            updateCustomImage: this.updateCustomImage.bind(this),
            updateSelectedImage: this.updateSelectedImage.bind(this),
            updateSegmentVideo: this.updateSegmentVideo.bind(this),
            updateSelfieSegmentation: this.updateSelfieSegmentation.bind(this),
            updatePauseSegmentation: this.updatePauseSegmentation.bind(this),
            updateProcessedStream: this.updateProcessedStream.bind(this),
            updateKeepBackground: this.updateKeepBackground.bind(this),
            updateBackgroundHasChanged: this.updateBackgroundHasChanged.bind(this),
            updateVirtualStream: this.updateVirtualStream.bind(this),
            updateMainCanvas: this.updateMainCanvas.bind(this),
            updatePrevKeepBackground: this.updatePrevKeepBackground.bind(this),
            updateAppliedBackground: this.updateAppliedBackground.bind(this),
            updateIsBackgroundModalVisible: this.updateIsBackgroundModalVisible.bind(this),
            updateAutoClickBackground: this.updateAutoClickBackground.bind(this),
            // Breakout rooms
            updateBreakoutRooms: this.updateBreakoutRooms.bind(this),
            updateCurrentRoomIndex: this.updateCurrentRoomIndex.bind(this),
            updateCanStartBreakout: this.updateCanStartBreakout.bind(this),
            updateBreakOutRoomStarted: this.updateBreakOutRoomStarted.bind(this),
            updateBreakOutRoomEnded: this.updateBreakOutRoomEnded.bind(this),
            updateHostNewRoom: this.updateHostNewRoom.bind(this),
            updateLimitedBreakRoom: this.updateLimitedBreakRoom.bind(this),
            updateMainRoomsLength: this.updateMainRoomsLength.bind(this),
            updateMemberRoom: this.updateMemberRoom.bind(this),
            updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
            // Whiteboard
            updateWhiteboardUsers: this.updateWhiteboardUsers.bind(this),
            updateCurrentWhiteboardIndex: this.updateCurrentWhiteboardIndex.bind(this),
            updateCanStartWhiteboard: this.updateCanStartWhiteboard.bind(this),
            updateWhiteboardStarted: this.updateWhiteboardStarted.bind(this),
            updateWhiteboardEnded: this.updateWhiteboardEnded.bind(this),
            updateWhiteboardLimit: this.updateWhiteboardLimit.bind(this),
            updateIsWhiteboardModalVisible: this.updateIsWhiteboardModalVisible.bind(this),
            updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
            updateShapes: this.updateShapes.bind(this),
            updateUseImageBackground: this.updateUseImageBackground.bind(this),
            updateRedoStack: this.updateRedoStack.bind(this),
            updateUndoStack: this.updateUndoStack.bind(this),
            updateCanvasStream: this.updateCanvasStream.bind(this),
            updateCanvasWhiteboard: this.updateCanvasWhiteboard.bind(this),
            // Screenboard
            updateCanvasScreenboard: this.updateCanvasScreenboard.bind(this),
            updateProcessedScreenStream: this.updateProcessedScreenStream.bind(this),
            updateAnnotateScreenStream: this.updateAnnotateScreenStream.bind(this),
            updateMainScreenCanvas: this.updateMainScreenCanvas.bind(this),
            updateIsScreenboardModalVisible: this.updateIsScreenboardModalVisible.bind(this),
            // Other functions
            checkOrientation: this.checkOrientation.bind(this),
            updateDevice: this.updateDevice.bind(this),
            updateSocket: this.updateSocket.bind(this),
            updateLocalSocket: this.updateLocalSocket.bind(this),
            updateValidated: this.updateValidated.bind(this),
            showAlert: this.showAlert.bind(this),
            getUpdatedAllParams: () => {
                try {
                    if (this.sourceParameters !== null) {
                        this.sourceParameters = {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        };
                        if (this.updateSourceParameters) {
                            this.updateSourceParameters(this.sourceParameters);
                        }
                    }
                }
                catch {
                    console.log('error updateSourceParameters');
                }
                return {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                };
            },
        };
    }
    mediaSFUParameters = {
        ...this.getAllParams(),
        ...this.mediaSFUFunctions(),
    };
    getUpdatedAllParams = () => {
        return {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    };
    updateButtonState(buttonType, value) {
        this.controlButtons = this.controlButtons.map((button) => {
            if (buttonType === 'micActive' && button.icon === this.faMicrophoneSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'videoActive' && button.icon === this.faVideoSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'screenShareActive' && button.icon === this.faDesktop) {
                if (button.alternateIconComponent) {
                    const updatedInjector = this.createInjector({
                        disabled: !value,
                    });
                    return {
                        ...button,
                        active: true,
                        alternateIconComponent: { ...this.screenShareWidget, injector: updatedInjector },
                    }; //always default to true for active
                }
                else {
                    return { ...button, active: true }; //always default to true for active
                }
            }
            if (buttonType === 'endCallActive' && button.icon === this.faPhone) {
                return { ...button, active: value };
            }
            if (buttonType === 'participantsActive' && button.icon === this.faUsers) {
                return { ...button, active: value };
            }
            if (buttonType === 'showMessagesBadge' &&
                button.customName &&
                button.customName === 'Messages') {
                const updatedInjector = this.createInjector({
                    icon: this.faComments,
                    badgeValue: value ? '*' : '',
                    iconColor: 'black',
                    showBadge: value,
                });
                return { ...button, customComponent: { ...this.messageWidget, injector: updatedInjector } };
            }
            if (buttonType === 'showMenuBadge' && button.customName && button.customName === 'Menu') {
                const updatedInjector = this.createInjector({
                    icon: this.faBars,
                    badgeValue: this.totalReqWait.value,
                    iconColor: 'black',
                    showBadge: true,
                });
                return { ...button, customComponent: { ...this.menuWidget, injector: updatedInjector } };
            }
            return button;
        });
        this.cdr.detectChanges();
    }
    PrejoinPageComponent = {
        component: this.PrejoinPage,
        injector: null,
    };
    updatePrejoinPageComponent = () => {
        const PrejoinComp = {
            component: this.PrejoinPage,
            injector: this.createInjector({
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    connectLocalSocket: this.socketManager.connectLocalSocket,
                    updateSocket: this.updateSocket,
                    updateLocalSocket: this.updateLocalSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                credentials: this.credentials,
                localLink: this.localLink,
                connectMediaSFU: this.connectMediaSFU,
                returnUI: this.returnUI,
                noUIPreJoinOptions: this.noUIPreJoinOptions,
                joinMediaSFURoom: this.joinMediaSFURoom,
                createMediaSFURoom: this.createMediaSFURoom,
            }),
        };
        this.PrejoinPageComponent = { ...PrejoinComp };
        this.cdr.detectChanges();
    };
    ngOnInit() {
        if (this.PrejoinPage) {
            this.updatePrejoinPageComponent();
        }
        this.setupResizeListener();
        if (this.validated) {
            this.connectAndAddSocketMethods();
        }
        this.mainHeightWidthSubscription = this.mainHeightWidth.subscribe(() => {
            this.updateMainVideoSize();
        });
        this.recordingSubscription = combineLatest([
            this.recordPaused,
            this.recordStarted,
            this.recordStopped,
            this.recordResumed,
            this.recordingProgressTime,
            this.showRecordButtons,
            this.islevel,
        ]).subscribe(([recordPaused, recordStarted, recordStopped, recordResumed, recordingProgressTime, showRecordButtons, islevel,]) => {
            if (recordPaused ||
                recordStarted ||
                recordStopped ||
                recordResumed ||
                recordingProgressTime ||
                showRecordButtons ||
                islevel) {
                this.updateRecordButtons();
            }
        });
        this.ScreenboardSubscription = combineLatest([
            this.shared,
            this.componentSizes,
            this.annotateScreenStream,
        ]).subscribe(([shared, componentSizes]) => {
            this.ScreenboardWidget = {
                component: Screenboard,
                inputs: {
                    customWidth: componentSizes.mainWidth,
                    customHeight: componentSizes.mainHeight,
                    parameters: this.mediaSFUParameters,
                    showAspect: shared,
                },
            };
        });
        this.validatedSubscription = this.validated.subscribe((validated) => {
            if (validated) {
                this.handleValidated();
            }
        });
        this.islevelSubscription = this.islevel.subscribe((islevel) => {
            if (islevel) {
                this.updateCustomMenuButtons();
            }
        });
        this.coHostSubscription = combineLatest([this.coHost, this.coHostResponsibility]).subscribe(([coHost, coHostResponsibility]) => {
            if (coHost || coHostResponsibility) {
                this.updateCustomMenuButtons();
            }
        });
        // Subscribe to changes in BehaviorSubject and update the buttons accordingly
        this.buttonSubscriptions.push(this.micActive.subscribe((value) => {
            this.updateButtonState('micActive', value);
        }));
        this.buttonSubscriptions.push(this.videoActive.subscribe((value) => {
            this.updateButtonState('videoActive', value);
        }));
        this.buttonSubscriptions.push(this.screenShareActive.subscribe((value) => {
            this.updateButtonState('screenShareActive', value);
        }));
        this.buttonSubscriptions.push(this.showMessagesBadge.subscribe((value) => {
            this.updateButtonState('showMessagesBadge', value);
        }));
        this.buttonSubscriptions.push(this.totalReqWait.subscribe(() => {
            this.updateButtonState('showMenuBadge', true);
        }));
        this.buttonSubscriptions.push(this.participantsCounter.subscribe((value) => {
            this.updateMenuParticipantsWidget(value);
        }));
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.handleResize);
        window.removeEventListener('orientationchange', this.handleResize);
        if (this.mainHeightWidthSubscription) {
            this.mainHeightWidthSubscription.unsubscribe();
        }
        if (this.validatedSubscription) {
            this.validatedSubscription.unsubscribe();
        }
        if (this.islevelSubscription) {
            this.islevelSubscription.unsubscribe();
        }
        if (this.coHostSubscription) {
            this.coHostSubscription.unsubscribe();
        }
        if (this.ScreenboardSubscription) {
            this.ScreenboardSubscription.unsubscribe();
        }
        if (this.recordingSubscription) {
            this.recordingSubscription.unsubscribe();
        }
    }
    updateMainVideoSize = async () => {
        if (!this.lock_screen.value && !this.shared.value) {
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
        }
        else {
            if (!this.first_round.value) {
                this.prepopulateUserMedia.prepopulateUserMedia({
                    name: this.hostLabel.value,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            }
        }
    };
    async connectAndAddSocketMethods() {
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
        const socket_ = await this.connect_Socket(this.apiUserName.value, this.apiToken.value);
        if (socket_) {
            this.updateSocket(socket_);
        }
    }
    async handleValidated() {
        this.updateAllVideoStreams([
            { producerId: 'youyou', stream: undefined, id: 'youyou', name: 'youyou' },
        ]);
        this.updateStreamNames([{ id: 'youyou', name: 'youyou', producerId: '' }]);
        if (this.validated.value) {
            try {
                if (!this.localUIMode.value) {
                    this.updateIsLoadingModalVisible(true);
                    await this.connectAndAddSocketMethods();
                }
                else {
                    this.updateIsLoadingModalVisible(false);
                }
            }
            catch (error) {
                console.log('error connectAndaAddSocketMethods', error);
            }
            this.startMeetingProgressTimer.startMeetingProgressTimer({
                startTime: Date.now() / 1000,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            try {
                if (this.sourceParameters !== null) {
                    this.sourceParameters = {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                    };
                    if (this.updateSourceParameters) {
                        this.updateSourceParameters(this.sourceParameters);
                    }
                }
            }
            catch {
                console.log('error updateSourceParameters');
            }
        }
    }
    async handleResize() {
        let fraction = 0;
        if (window.innerHeight < window.innerWidth &&
            (this.eventType.value == 'webinar' || this.eventType.value == 'conference')) {
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        else {
            // Set default control button height for portrait mode or other event types
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            fraction = Number(fraction);
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        const dimensions = this.computeDimensionsMethod({
            containerWidthFraction: 1,
            containerHeightFraction: 1,
            mainSize: this.mainHeightWidth.value,
            doStack: true,
            defaultFraction: this.eventType.value == 'webinar' || this.eventType.value == 'conference'
                ? 1 - fraction
                : 1,
        });
        this.updateComponentSizes(dimensions);
        const orientation = this.checkOrientation();
        if (orientation == 'portrait') {
            if (!this.isWideScreen.value) {
                if (this.shareScreenStarted.value || this.shared.value) {
                    this.updateScreenForceFullDisplay(true);
                }
            }
        }
        // Updates the main grid view
        await this.prepopulateUserMedia.prepopulateUserMedia({
            name: this.hostLabel.value,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
        // Updates the mini grid view
        await this.onScreenChanges.onScreenChanges({
            changed: true,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
    }
    async disconnectAllSockets(consume_sockets) {
        for (const socket of consume_sockets) {
            try {
                const ip = Object.keys(socket)[0];
                await socket[ip].disconnect();
            }
            catch (error) {
                console.log(`Error disconnecting socket with IP: ${Object.keys(socket)[0]}`, error);
            }
        }
    }
    async closeAndReset() {
        //close and clean up all sockets, modals,... and reset all states to initial values
        this.updateIsMessagesModalVisible(false);
        this.updateIsParticipantsModalVisible(false);
        this.updateIsWaitingModalVisible(false);
        this.updateIsRequestsModalVisible(false);
        this.updateIsCoHostModalVisible(false);
        this.updateIsSettingsModalVisible(false);
        this.updateIsDisplaySettingsModalVisible(false);
        this.updateIsMediaSettingsModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsShareEventModalVisible(false);
        this.updateIsConfirmExitModalVisible(false);
        await this.disconnectAllSockets(this.consume_sockets.value);
        await this.updateStatesToInitialValues();
        this.updateMeetingProgressTime('00:00:00');
        this.updateMeetingElapsedTime(0);
        this.updateRecordingProgressTime('00:00:00');
        this.updateRecordElapsedTime(0);
        this.updateShowRecordButtons(false);
        this.updateIsConfigureWhiteboardModalVisible(false);
        this.updateIsWhiteboardModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsRecordingModalVisible(false);
        this.updateIsPollModalVisible(false);
        this.updateIsBreakoutRoomsModalVisible(false);
        this.updateIsBackgroundModalVisible(false);
        this.updateIsLoadingModalVisible(false);
        this.updateIsConfirmHereModalVisible(false);
        await sleep({ ms: 500 });
        this.updateValidated(false);
        //if on web, reload the page
        window.location.reload();
    }
    computeDimensionsMethod = ({ containerWidthFraction = 1, containerHeightFraction = 1, mainSize, doStack = true, defaultFraction, }) => {
        const parentWidth = window.innerWidth * containerWidthFraction;
        const parentHeight = window.innerHeight * containerHeightFraction * defaultFraction;
        let isWideScreen = parentWidth >= 768;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        const dimensions = this.calculateDimensions({
            parentWidth,
            parentHeight,
            isWideScreen,
            mainSize,
            doStack,
        });
        return dimensions;
    };
    calculateDimensions({ parentWidth, parentHeight, isWideScreen, mainSize, doStack, }) {
        if (doStack) {
            return isWideScreen
                ? {
                    mainHeight: Math.floor(parentHeight),
                    otherHeight: Math.floor(parentHeight),
                    mainWidth: Math.floor((mainSize / 100) * parentWidth),
                    otherWidth: Math.floor(((100 - mainSize) / 100) * parentWidth),
                }
                : {
                    mainHeight: Math.floor((mainSize / 100) * parentHeight),
                    otherHeight: Math.floor(((100 - mainSize) / 100) * parentHeight),
                    mainWidth: Math.floor(parentWidth),
                    otherWidth: Math.floor(parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(parentHeight),
                otherHeight: Math.floor(parentHeight),
                mainWidth: Math.floor(parentWidth),
                otherWidth: Math.floor(parentWidth),
            };
        }
    }
    handleOrientationChange() {
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('orientationchange', this.handleResize.bind(this));
    }
    setupResizeListener() {
        this.handleResize();
    }
    orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    async joinRoom(data) {
        const { socket, roomName, islevel, member, sec, apiUserName } = data;
        try {
            const response = await this.joinRoomClient.joinRoomClient({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
            return response;
        }
        catch (error) {
            console.log('Error joining room:', error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    async join_Room({ socket, roomName, islevel, member, sec, apiUserName, isLocal = false, }) {
        let data;
        if (!isLocal) {
            data = await this.joinRoom({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
        }
        else {
            const localData = await this.joinLocalRoom.joinLocalRoom({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    connectLocalSocket: this.socketManager.connectLocalSocket,
                    updateSocket: this.updateSocket,
                    updateLocalSocket: this.updateLocalSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                checkConnect: this.localLink.length > 0 &&
                    this.connectMediaSFU === true &&
                    !this.link.value.includes('mediasfu.com'),
                localLink: this.localLink,
                joinMediaSFURoom: this.joinMediaSFURoom,
            });
            data = await createResponseJoinRoom({ localRoom: localData });
        }
        const updateAndComplete = async (data) => {
            // Update room parameters
            try {
                // Check if roomRecvIPs is not empty
                if (!data.roomRecvIPs || data.roomRecvIPs.length === 0) {
                    data.roomRecvIPs = ['none'];
                    if (this.link.value !== "" &&
                        this.link.value.includes("mediasfu.com") &&
                        !isLocal) {
                        // Community Edition Only
                        await this.receiveAllPipedTransports.receiveAllPipedTransports({
                            community: true,
                            nsock: this.getUpdatedAllParams().socket,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                }
                this.updateRoomParametersClient.updateRoomParametersClient({
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                        data: data,
                    },
                });
                if (data.isHost) {
                    this.updateIslevel('2');
                }
                else {
                    // Issue with isHost for local room
                    if (islevel !== '2') {
                        this.updateIslevel('1');
                    }
                }
                if (data.secureCode && data.secureCode !== '') {
                    this.updateAdminPasscode(data.secureCode);
                }
                if (data.rtpCapabilities) {
                    try {
                        const device_ = await this.createDeviceClient.createDeviceClient({
                            rtpCapabilities: data.rtpCapabilities,
                        });
                        if (device_) {
                            this.device.next(device_);
                        }
                    }
                    catch (error) {
                        console.error('Error creating device:', error);
                    }
                }
            }
            catch (error) {
                console.error('Error in updateAndComplete:', error);
            }
        };
        if (data && data.success) {
            if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && isLocal) {
                this.roomData.next(data);
                return;
            }
            else if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && !isLocal) {
                // Update roomData
                if (this.roomData.value) {
                    // Updating only the recording and meeting room parameters
                    this.roomData.value.recordingParams = data.recordingParams;
                    this.roomData.value.meetingRoomParams = data.meetingRoomParams;
                    this.roomData.next(this.roomData.value);
                }
                else {
                    this.roomData.next(data);
                }
            }
            else {
                // Update roomData
                this.roomData.next(data);
                if (!this.link.value.includes('mediasfu.com')) {
                    this.roomData.value.meetingRoomParams = data.meetingRoomParams;
                }
            }
            await updateAndComplete(data);
        }
        else {
            if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && !isLocal) {
                // Join local room only
                if (this.roomData.value) {
                    await updateAndComplete(this.roomData.value);
                }
                return;
            }
            // Might be a wrong room name or room is full or other error; check reason in data object if available
            try {
                if (this.showAlert && data?.reason) {
                    this.showAlert({
                        message: data.reason,
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
            catch (error) {
                /* handle error */
            }
        }
    }
    onParticipantsFilterChange = (value) => {
        if (value && value.length > 0) {
            this.filteredParticipants.next(this.participants.value.filter((participant) => participant.name.toLowerCase().includes(value.toLowerCase())));
            this.participantsCounter.next(this.filteredParticipants.value.length);
        }
        else {
            this.filteredParticipants.next(this.participants.value);
            this.participantsCounter.next(this.participants.value.length);
        }
    };
    updateStatesToInitialValues = async () => {
        const initialValues = initialValuesState;
        const updateFunctions = this.getAllParams();
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                const updateFunctionName = `update${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const updateFunction = updateFunctions[updateFunctionName];
                if (typeof updateFunction === 'function') {
                    try {
                        updateFunction(initialValues[key]);
                    }
                    catch {
                        /* handle error */
                    }
                }
            }
        }
    };
    faRecordVinyl = faRecordVinyl;
    faPlayCircle = faPlayCircle;
    faPauseCircle = faPauseCircle;
    faStopCircle = faStopCircle;
    faDotCircle = faDotCircle;
    faCog = faCog;
    faUsers = faUsers;
    faClock = faClock;
    faUserPlus = faUserPlus;
    faTools = faTools;
    faDesktop = faDesktop;
    faPoll = faPoll;
    faUserFriends = faUserFriends;
    faChalkboardTeacher = faChalkboardTeacher;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faPhone = faPhone;
    faBars = faBars;
    faComments = faComments;
    faChartBar = faChartBar;
    onCloseMenuModal = () => {
        this.updateIsMenuModalVisible(false);
    };
    onEventSettingsClose = () => {
        this.updateIsSettingsModalVisible(false);
    };
    onCoHostClose = () => {
        this.updateIsCoHostModalVisible(false);
    };
    onMediaSettingsClose = () => {
        this.updateIsMediaSettingsModalVisible(false);
    };
    onDisplaySettingsClose = () => {
        this.updateIsDisplaySettingsModalVisible(false);
    };
    onPollClose = () => {
        this.updateIsPollModalVisible(false);
    };
    onBreakoutRoomsClose = () => {
        this.updateIsBreakoutRoomsModalVisible(false);
    };
    onConfigureWhiteboardClose = () => {
        this.updateIsConfigureWhiteboardModalVisible(false);
    };
    onMessagesClose = () => {
        this.updateIsMessagesModalVisible(false);
    };
    onRecordingClose = () => {
        this.updateIsRecordingModalVisible(false);
    };
    onParticipantsClose = () => {
        this.updateIsParticipantsModalVisible(false);
    };
    onBackgroundClose = () => {
        this.updateIsBackgroundModalVisible(false);
    };
    onConfirmExitClose = () => {
        this.updateIsConfirmExitModalVisible(false);
    };
    onConfirmHereClose = () => {
        this.updateIsConfirmHereModalVisible(false);
    };
    onScreenboardClose = () => {
        this.updateIsScreenboardModalVisible(false);
    };
    onShareEventClose = () => {
        this.updateIsShareEventModalVisible(false);
    };
    onAlertHide = () => {
        this.updateAlertVisible(false);
    };
    ScreenboardWidget = {
        component: Screenboard,
        inputs: {
            customWidth: this.componentSizes.value.mainWidth,
            customHeight: this.componentSizes.value.mainHeight,
            parameters: this.mediaSFUParameters,
            showAspect: this.shared.value,
        },
    };
    recordTimerWidget = {
        component: RecordTimerWidget,
        injector: this.createInjector({ recordingProgressTime: this.recordingProgressTime.value }),
    };
    updateRecordTimerWidget = (recordingProgressTime = this.recordingProgressTime.value) => {
        const recordTimerWidget = {
            component: RecordTimerWidget,
            injector: this.createInjector({ recordingProgressTime: recordingProgressTime }),
        };
        this.recordTimerWidget = { ...recordTimerWidget };
        this.cdr.markForCheck();
        return recordTimerWidget;
    };
    recordButtons = [];
    recordButtonsArray = [
        {
            icon: this.faPlayCircle,
            active: () => !this.recordPaused.value,
            onPress: () => this.updateRecording.updateRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            alternateIcon: this.faPauseCircle,
            show: () => true,
        },
        {
            icon: this.faStopCircle,
            active: () => false,
            onPress: () => this.stopRecording.stopRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: () => this.updateRecordTimerWidget(),
            show: () => true,
            active: () => false,
        },
        {
            icon: this.faDotCircle,
            active: () => false,
            onPress: () => console.log('Status pressed'),
            activeColor: 'black',
            inActiveColor: () => (this.recordPaused.value ? 'yellow' : 'red'),
            show: () => true,
        },
        {
            icon: this.faCog,
            active: () => false,
            onPress: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
    ];
    async updateRecordButtons() {
        const recordButtons = this.recordButtonsArray.map((button) => {
            return {
                ...button,
                active: typeof button.active === 'function' ? button.active() : button.active,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
                activeColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
                inActiveColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
            };
        });
        this.recordButtons = [...recordButtons];
        await this.updateMenuRecordWidget(recordButtons);
        this.updateCustomMenuButtons();
        this.cdr.markForCheck();
    }
    // Create instances of the custom widgets
    menuWidget = {
        component: MenuWidget,
        injector: this.createInjector({
            icon: this.faBars,
            badgeValue: this.totalReqWait.value,
            iconColor: 'black',
            showBadge: true,
        }),
    };
    messageWidget = {
        component: MessageWidget,
        injector: this.createInjector({
            icon: this.faComments,
            showBadge: this.showMessagesBadge.value,
            badgeValue: 1,
            iconColor: 'black',
        }),
    };
    menuRecordWidget = {
        component: MenuRecordWidget,
        injector: this.createInjector({
            buttons: this.recordButtons,
            showAspect: true,
            direction: 'horizontal',
        }),
    };
    updateMenuRecordWidget = (recordButtons = this.recordButtons) => {
        const menuRecordWidget = {
            component: MenuRecordWidget,
            injector: this.createInjector({
                buttons: recordButtons,
                showAspect: true,
                direction: 'horizontal',
            }),
        };
        this.menuRecordWidget = { ...menuRecordWidget };
        this.cdr.markForCheck();
        return menuRecordWidget;
    };
    menuParticipantsWidget = {
        component: MenuParticipantsWidget,
        injector: this.createInjector({
            icon: this.faChartBar,
            participantsCounter: this.participantsCounter.value,
            iconColor: 'black',
        }),
    };
    updateMenuParticipantsWidget = (count = this.participantsCounter.value) => {
        const menuParticipantsWidget = {
            component: MenuParticipantsWidget,
            injector: this.createInjector({
                icon: this.faChartBar,
                participantsCounter: count,
                iconColor: 'black',
            }),
        };
        this.menuParticipantsWidget = { ...menuParticipantsWidget };
        this.cdr.markForCheck();
        return menuParticipantsWidget;
    };
    customMenuButtonsArray = [
        {
            icon: this.faRecordVinyl,
            text: 'Record',
            action: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            show: () => !this.showRecordButtons.value && this.islevel.value == '2',
        },
        {
            customComponent: () => this.updateMenuRecordWidget(),
            show: () => this.showRecordButtons.value && this.islevel.value == '2',
            action: () => console.log('record buttons pressed'),
        },
        {
            icon: this.faCog,
            text: 'Event Settings',
            action: () => this.launchSettings.launchSettings({
                updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
                isSettingsModalVisible: this.isSettingsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faUsers,
            text: 'Requests',
            action: () => this.launchRequests.launchRequests({
                updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
                isRequestsModalVisible: this.isRequestsModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                (this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    !!this.coHostResponsibility?.value?.find((item) => item.name === 'media')?.value) ||
                false,
        },
        {
            icon: this.faClock,
            text: 'Waiting',
            action: () => this.launchWaiting.launchWaiting({
                updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
                isWaitingModalVisible: this.isWaitingModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                (this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    this.coHostResponsibility?.value?.find((item) => item.name === 'waiting')?.value ===
                        true) ||
                false,
        },
        {
            icon: this.faUserPlus,
            text: 'Co-host',
            action: () => this.launchCoHost.launchCoHost({
                updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
                isCoHostModalVisible: this.isCoHostModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faTools,
            text: 'Set Media',
            action: () => this.launchMediaSettings.launchMediaSettings({
                updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
                isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
                audioInputs: this.audioInputs.value,
                videoInputs: this.videoInputs.value,
                updateAudioInputs: this.updateAudioInputs.bind(this),
                updateVideoInputs: this.updateVideoInputs.bind(this),
            }),
            show: () => true,
        },
        {
            icon: this.faDesktop,
            text: 'Display',
            action: () => this.launchDisplaySettings.launchDisplaySettings({
                updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
                isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faPoll,
            text: 'Poll',
            action: () => this.launchPoll.launchPoll({
                updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                isPollModalVisible: this.isPollModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faUserFriends,
            text: 'Breakout Rooms',
            action: () => this.launchBreakoutRooms.launchBreakoutRooms({
                updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
                isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faChalkboardTeacher,
            text: 'Whiteboard',
            action: () => this.launchConfigureWhiteboard.launchConfigureWhiteboard({
                updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
                isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
    ];
    customMenuButtons = [];
    updateCustomMenuButtons() {
        this.customMenuButtons = this.customMenuButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
            };
        });
    }
    screenShareWidget = {
        component: ScreenShareWidget,
        injector: this.createInjector({ disabled: !this.screenShareActive.value }),
    };
    controlButtons = [
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.audioSwitching.value,
            show: true,
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                    MediaStream,
                    MediaStreamTrack,
                    mediaDevices: MediaDevices,
                    device: this.device.value,
                    socket: this.socket.value,
                    showAlert: this.showAlert.bind(this),
                    checkPermission: this.checkPermission.checkPermission,
                    streamSuccessVideo: this.streamSuccessVideo.streamSuccessVideo,
                    hasCameraPermission: this.hasCameraPermission.value,
                    requestPermissionCamera: this.requestPermissionCamera.bind(this),
                    checkMediaPermission: 'web' !== 'web',
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.videoSwitching.value,
            show: true,
        },
        {
            //inverted active for inactive state
            icon: faDesktop,
            alternateIconComponent: this.screenShareWidget,
            active: true,
            onPress: () => this.clickScreenShare.clickScreenShare({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faUsers,
            active: this.participantsActive.value,
            onPress: () => this.launchParticipants.launchParticipants({
                updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
                isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            disabled: false,
            show: true,
        },
        {
            customComponent: this.menuWidget,
            customName: 'Menu',
            onPress: () => this.launchMenuModal.launchMenuModal({
                updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
                isMenuModalVisible: this.isMenuModalVisible.value,
            }),
            show: true,
        },
        {
            customComponent: this.messageWidget,
            customName: 'Messages',
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: true,
        },
    ];
    async connect_Socket(apiUserName, token, skipSockets = false) {
        const socketDefault = this.socket.value;
        const socketAlt = this.connectMediaSFU && this.localSocket.value && this.localSocket.value.id
            ? this.localSocket.value
            : socketDefault;
        if (this.socket.value && this.socket.value.id) {
            if (!skipSockets) {
                // Event listeners on socketDefault
                socketDefault.on('disconnect', async () => {
                    await this.disconnect.disconnect({
                        showAlert: this.showAlert.bind(this),
                        redirectURL: this.redirectURL.value,
                        onWeb: true,
                        updateValidated: this.updateValidated.bind(this),
                    });
                    if (this.videoAlreadyOn.value) {
                        await this.clickVideo.clickVideo({
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    if (this.audioAlreadyOn.value) {
                        await this.clickAudio.clickAudio({
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    await this.closeAndReset();
                });
                socketDefault.on('allMembers', async (membersData) => {
                    if (membersData) {
                        await this.allMembers.allMembers({
                            apiUserName: apiUserName,
                            apiKey: '', //not recommended - use apiToken instead. Use for testing/development only
                            apiToken: token,
                            members: membersData.members,
                            requestss: membersData.requests ? membersData.requests : this.requestList.value,
                            coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                            coHostRes: membersData.coHostResponsibilities
                                ? membersData.coHostResponsibilities
                                : this.coHostResponsibility.value,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                            consume_sockets: this.consume_sockets.value,
                        });
                    }
                });
                socketDefault.on('allMembersRest', async (membersData) => {
                    if (membersData) {
                        await this.allMembersRest.allMembersRest({
                            apiUserName: apiUserName,
                            apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                            members: membersData.members,
                            apiToken: token,
                            settings: membersData.settings,
                            coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                            coHostRes: membersData.coHostResponsibilities
                                ? membersData.coHostResponsibilities
                                : this.coHostResponsibility.value,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                            consume_sockets: this.consume_sockets.value,
                        });
                    }
                });
                socketDefault.on('userWaiting', async ({ name }) => {
                    await this.userWaiting.userWaiting({
                        name,
                        showAlert: this.showAlert.bind(this),
                        totalReqWait: this.totalReqWait.value,
                        updateTotalReqWait: this.updateTotalReqWait.bind(this),
                    });
                });
                socketDefault.on('personJoined', async ({ name }) => {
                    this.personJoined.personJoined({
                        name,
                        showAlert: this.showAlert.bind(this),
                    });
                });
                socketDefault.on('allWaitingRoomMembers', async (waiting_data) => {
                    await this.allWaitingRoomMembers.allWaitingRoomMembers({
                        waitingParticipants: waiting_data.waitingParticipants
                            ? waiting_data.waitingParticipants
                            : waiting_data.waitingParticipantss
                                ? waiting_data.waitingParticipantss
                                : this.waitingRoomList.value,
                        updateTotalReqWait: this.updateTotalReqWait.bind(this),
                        updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
                    });
                });
                socketDefault.on('ban', async ({ name }) => {
                    await this.banParticipant.banParticipant({
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('updatedCoHost', async (cohost_data) => {
                    await this.updatedCoHost.updatedCoHost({
                        coHost: cohost_data.coHost ? cohost_data.coHost : this.coHost.value,
                        coHostResponsibility: cohost_data.coHostResponsibilities
                            ? cohost_data.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        youAreCoHost: this.youAreCoHost.value,
                        updateCoHost: this.updateCoHost.bind(this),
                        updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
                        updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
                        showAlert: this.showAlert.bind(this),
                        eventType: this.eventType.value,
                        islevel: this.islevel.value,
                        member: this.member.value,
                    });
                });
                socketDefault.on('participantRequested', async ({ userRequest }) => {
                    await this.participantRequested.participantRequested({
                        userRequest,
                        requestList: this.requestList.value,
                        waitingRoomList: this.waitingRoomList.value,
                        updateTotalReqWait: this.updateTotalReqWait.bind(this),
                        updateRequestList: this.updateRequestList.bind(this),
                    });
                });
                socketDefault.on('screenProducerId', async ({ producerId }) => {
                    this.screenProducerId.screenProducerId({
                        producerId,
                        screenId: this.screenId.value,
                        membersReceived: this.membersReceived.value,
                        shareScreenStarted: this.shareScreenStarted.value,
                        deferScreenReceived: this.deferScreenReceived.value,
                        participants: this.participants.value,
                        updateScreenId: this.updateScreenId.bind(this),
                        updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
                        updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
                    });
                });
                socketDefault.on('updateMediaSettings', async ({ settings }) => {
                    this.updateMediaSettings.updateMediaSettings({
                        settings,
                        updateAudioSetting: this.updateAudioSetting.bind(this),
                        updateVideoSetting: this.updateVideoSetting.bind(this),
                        updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
                        updateChatSetting: this.updateChatSetting.bind(this),
                    });
                });
                socketDefault.on('producer-media-paused', async ({ producerId, kind, name, }) => {
                    await this.producerMediaPaused.producerMediaPaused({
                        producerId,
                        kind,
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('producer-media-resumed', async ({ kind, name }) => {
                    await this.producerMediaResumed.producerMediaResumed({
                        kind,
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('producer-media-closed', async ({ producerId, kind, }) => {
                    if (producerId && kind) {
                        await this.producerMediaClosed.producerMediaClosed({
                            producerId,
                            kind,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                });
                socketDefault.on('controlMediaHost', async ({ type }) => {
                    await this.controlMediaHost.controlMediaHost({
                        type,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('meetingEnded', async () => {
                    await this.meetingEnded.meetingEnded({
                        showAlert: this.showAlert.bind(this),
                        redirectURL: this.redirectURL.value,
                        onWeb: true,
                        eventType: this.eventType.value,
                        updateValidated: this.updateValidated.bind(this),
                    });
                    if (this.videoAlreadyOn.value) {
                        await this.clickVideo.clickVideo({
                            parameters: {
                                ...this.getAllParams(),
                                ...this.mediaSFUFunctions(),
                            },
                        });
                    }
                    if (this.audioAlreadyOn.value) {
                        await this.clickAudio.clickAudio({
                            parameters: {
                                ...this.getAllParams(),
                                ...this.mediaSFUFunctions(),
                            },
                        });
                    }
                    await this.closeAndReset();
                });
                socketDefault.on('disconnectUserSelf', async () => {
                    await this.disconnectUserSelf.disconnectUserSelf({
                        socket: socketDefault,
                        member: this.member.value,
                        roomName: this.roomName.value,
                    });
                });
                socketDefault.on('receiveMessage', async ({ message }) => {
                    await this.receiveMessage.receiveMessage({
                        message,
                        messages: this.messages.value,
                        participantsAll: this.participantsAll.value,
                        member: this.member.value,
                        eventType: this.eventType.value,
                        islevel: this.islevel.value,
                        coHost: this.coHost.value,
                        updateMessages: this.updateMessages.bind(this),
                        updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
                    });
                });
                socketDefault.on('meetingTimeRemaining', async ({ timeRemaining }) => {
                    await this.meetingTimeRemaining.meetingTimeRemaining({
                        timeRemaining,
                        showAlert: this.showAlert.bind(this),
                        eventType: this.eventType.value,
                    });
                });
                socketDefault.on('meetingStillThere', async () => {
                    this.meetingStillThere.meetingStillThere({
                        updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
                    });
                });
                socketDefault.on('updateConsumingDomains', async ({ domains, alt_domains }) => {
                    await this.updateConsumingDomains.updateConsumingDomains({
                        domains,
                        alt_domains,
                        apiUserName,
                        apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                        apiToken: token,
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                });
                socketDefault.on('hostRequestResponse', ({ requestResponse }) => {
                    this.hostRequestResponse.hostRequestResponse({
                        requestResponse,
                        showAlert: this.showAlert.bind(this),
                        requestList: this.requestList.value,
                        updateRequestList: this.updateRequestList.bind(this),
                        updateMicAction: this.updateMicAction.bind(this),
                        updateVideoAction: this.updateVideoAction.bind(this),
                        updateScreenAction: this.updateScreenAction.bind(this),
                        updateChatAction: this.updateChatAction.bind(this),
                        updateAudioRequestState: this.updateAudioRequestState.bind(this),
                        updateVideoRequestState: this.updateVideoRequestState.bind(this),
                        updateScreenRequestState: this.updateScreenRequestState.bind(this),
                        updateChatRequestState: this.updateChatRequestState.bind(this),
                        updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
                        updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
                        updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
                        updateChatRequestTime: this.updateChatRequestTime.bind(this),
                        updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
                    });
                });
                socketDefault.on('pollUpdated', async (data) => {
                    try {
                        await this.pollUpdated.pollUpdated({
                            data,
                            polls: this.polls.value,
                            poll: this.poll.value ? this.poll.value : {},
                            member: this.member.value,
                            islevel: this.islevel.value,
                            showAlert: this.showAlert.bind(this),
                            updatePolls: this.updatePolls.bind(this),
                            updatePoll: this.updatePoll.bind(this),
                            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                        });
                    }
                    catch {
                        /* handle error */
                    }
                });
                socketDefault.on('breakoutRoomUpdated', async (data) => {
                    try {
                        await this.breakoutRoomUpdated.breakoutRoomUpdated({
                            data,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    catch {
                        /* handle error */
                    }
                });
            }
            if (skipSockets) {
                // Remove specific event listeners from socketDefault and socketAlt
                const events = [
                    'roomRecordParams',
                    'startRecords',
                    'reInitiateRecording',
                    'RecordingNotice',
                    'timeLeftRecording',
                    'stoppedRecording',
                ];
                events.forEach((event) => {
                    socketDefault.off(event);
                    socketAlt.off(event);
                });
            }
            socketAlt.on('roomRecordParams', async ({ recordParams }) => {
                this.roomRecordParams.roomRecordParams({
                    recordParams,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            socketAlt.on('startRecords', async () => {
                await this.startRecords.startRecords({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: socketAlt,
                });
            });
            socketAlt.on('reInitiateRecording', async () => {
                await this.reInitiateRecording.reInitiateRecording({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: socketAlt,
                    adminRestrictSetting: this.adminRestrictSetting.value,
                });
            });
            socketAlt.on('RecordingNotice', async ({ state, userRecordingParam, pauseCount, timeDone }) => {
                await this.recordingNotice.RecordingNotice({
                    state,
                    userRecordingParam,
                    pauseCount,
                    timeDone,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            socketAlt.on('timeLeftRecording', async ({ timeLeft }) => {
                this.timeLeftRecording.timeLeftRecording({
                    timeLeft,
                    showAlert: this.showAlert.bind(this),
                });
            });
            socketAlt.on('stoppedRecording', async ({ state, reason }) => {
                await this.stoppedRecording.stoppedRecording({
                    state,
                    reason,
                    showAlert: this.showAlert.bind(this),
                });
            });
            if (this.localLink !== "" && socketDefault && !skipSockets) {
                await this.join_Room({
                    socket: socketDefault,
                    roomName: this.roomName.value,
                    islevel: this.islevel.value,
                    member: this.member.value,
                    sec: token,
                    apiUserName: apiUserName,
                    isLocal: true,
                });
            }
            // Check if localSocket has changed
            const localChanged = this.localSocket.value && this.localSocket.value.id && this.localSocket.value.id !== socketAlt.id;
            if (!skipSockets && localChanged) {
                // Re-call connect_Socket with skipSockets = true
                await this.connect_Socket(apiUserName, token, true);
                await sleep({ ms: 1000 });
                this.updateIsLoadingModalVisible(false);
                return socketDefault;
            }
            else {
                if (this.link.value !== '' && this.link.value.includes('mediasfu.com')) {
                    // Token might be different for local room
                    const token = this.apiToken.value;
                    await this.join_Room({
                        socket: this.connectMediaSFU && socketAlt && socketAlt.id ? socketAlt : socketDefault,
                        roomName: this.roomName.value,
                        islevel: this.islevel.value,
                        member: this.member.value,
                        sec: token,
                        apiUserName: apiUserName,
                    });
                }
                await this.receiveRoomMessages.receiveRoomMessages({
                    socket: socketDefault,
                    roomName: this.roomName.value,
                    updateMessages: this.updateMessages.bind(this),
                });
                if (!skipSockets) {
                    await this.prepopulateUserMedia.prepopulateUserMedia({
                        name: this.hostLabel.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                return socketDefault;
            }
        }
        else {
            return null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediasfuWebinar, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.Injector }, { token: UpdateMiniCardsGrid }, { token: MixStreams }, { token: DispStreams }, { token: StopShareScreen }, { token: CheckScreenShare }, { token: StartShareScreen }, { token: RequestScreenShare }, { token: ReorderStreams }, { token: PrepopulateUserMedia }, { token: GetVideos }, { token: RePort }, { token: Trigger }, { token: ConsumerResume }, { token: ConnectSendTransport }, { token: ConnectSendTransportAudio }, { token: ConnectSendTransportVideo }, { token: ConnectSendTransportScreen }, { token: ProcessConsumerTransports }, { token: ResumePauseStreams }, { token: Readjust }, { token: CheckGrid }, { token: GetEstimate }, { token: CalculateRowsAndColumns }, { token: AddVideosGrid }, { token: OnScreenChanges }, { token: ChangeVids }, { token: CompareActiveNames }, { token: CompareScreenStates }, { token: CreateSendTransport }, { token: ResumeSendTransportAudio }, { token: ReceiveAllPipedTransports }, { token: DisconnectSendTransportVideo }, { token: DisconnectSendTransportAudio }, { token: DisconnectSendTransportScreen }, { token: GetPipedProducersAlt }, { token: SignalNewConsumerTransport }, { token: ConnectRecvTransport }, { token: ReUpdateInter }, { token: UpdateParticipantAudioDecibels }, { token: CloseAndResize }, { token: AutoAdjust }, { token: SwitchUserVideoAlt }, { token: SwitchUserVideo }, { token: SwitchUserAudio }, { token: GetDomains }, { token: FormatNumber }, { token: ConnectIps }, { token: ConnectLocalIps }, { token: CreateDeviceClient }, { token: HandleCreatePoll }, { token: HandleEndPoll }, { token: HandleVotePoll }, { token: CaptureCanvasStream }, { token: ResumePauseAudioStreams }, { token: ProcessConsumerTransportsAudio }, { token: LaunchMenuModal }, { token: LaunchRecording }, { token: StartRecording }, { token: ConfirmRecording }, { token: LaunchWaiting }, { token: launchCoHost }, { token: LaunchMediaSettings }, { token: LaunchDisplaySettings }, { token: LaunchSettings }, { token: LaunchRequests }, { token: LaunchParticipants }, { token: LaunchMessages }, { token: LaunchConfirmExit }, { token: LaunchPoll }, { token: LaunchBreakoutRooms }, { token: LaunchConfigureWhiteboard }, { token: StartMeetingProgressTimer }, { token: UpdateRecording }, { token: StopRecording }, { token: UserWaiting }, { token: PersonJoined }, { token: AllWaitingRoomMembers }, { token: RoomRecordParams }, { token: BanParticipant }, { token: UpdatedCoHost }, { token: ParticipantRequested }, { token: ScreenProducerId }, { token: UpdateMediaSettings }, { token: ProducerMediaPaused }, { token: ProducerMediaResumed }, { token: ProducerMediaClosed }, { token: ControlMediaHost }, { token: MeetingEnded }, { token: DisconnectUserSelf }, { token: ReceiveMessage }, { token: MeetingTimeRemaining }, { token: MeetingStillThere }, { token: StartRecords }, { token: ReInitiateRecording }, { token: RecordingNotice }, { token: TimeLeftRecording }, { token: StoppedRecording }, { token: HostRequestResponse }, { token: AllMembers }, { token: AllMembersRest }, { token: Disconnect }, { token: PollUpdated }, { token: BreakoutRoomUpdated }, { token: SocketManager }, { token: JoinRoomClient }, { token: JoinLocalRoom }, { token: UpdateRoomParametersClient }, { token: ClickVideo }, { token: ClickAudio }, { token: ClickScreenShare }, { token: StreamSuccessVideo }, { token: StreamSuccessAudio }, { token: StreamSuccessScreen }, { token: StreamSuccessAudioSwitch }, { token: CheckPermission }, { token: UpdateConsumingDomains }, { token: ReceiveRoomMessages }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MediasfuWebinar, isStandalone: true, selector: "app-mediasfu-webinar", inputs: { PrejoinPage: "PrejoinPage", localLink: "localLink", connectMediaSFU: "connectMediaSFU", credentials: "credentials", useLocalUIMode: "useLocalUIMode", seedData: "seedData", useSeed: "useSeed", imgSrc: "imgSrc", sourceParameters: "sourceParameters", updateSourceParameters: "updateSourceParameters", returnUI: "returnUI", noUIPreJoinOptions: "noUIPreJoinOptions", joinMediaSFURoom: "joinMediaSFURoom", createMediaSFURoom: "createMediaSFURoom" }, host: { listeners: { "window:resize": "handleResize()", "window:orientationchange": "handleResize()" } }, providers: [CookieService], ngImport: i0, template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component *ngIf="returnUI">
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <ng-container *ngIf="returnUI">
      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
        [localLink]="localLink"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
        [localLink]="localLink"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </ng-container>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: BreakoutRoomsModal, selector: "app-breakout-rooms-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onBreakoutRoomsClose"] }, { kind: "component", type: BackgroundModal, selector: "app-background-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onClose"] }, { kind: "component", type: CoHostModal, selector: "app-co-host-modal", inputs: ["isCoHostModalVisible", "currentCohost", "participants", "coHostResponsibility", "position", "backgroundColor", "roomName", "showAlert", "updateCoHostResponsibility", "updateCoHost", "updateIsCoHostModalVisible", "socket", "onCoHostClose", "onModifyCoHost"] }, { kind: "component", type: AlertComponent, selector: "app-alert-component", inputs: ["visible", "message", "type", "duration", "textColor", "onHide"] }, { kind: "component", type: AudioGrid, selector: "app-audio-grid", inputs: ["componentsToRender"] }, { kind: "component", type: ControlButtonsComponent, selector: "app-control-buttons-component", inputs: ["buttons", "buttonColor", "buttonBackgroundColor", "alignment", "vertical", "buttonsContainerStyle"] }, { kind: "component", type: FlexibleGrid, selector: "app-flexible-grid", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "backgroundColor"] }, { kind: "component", type: FlexibleVideo, selector: "app-flexible-video", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "showAspect", "backgroundColor", "Screenboard", "annotateScreenStream", "localStreamScreen"] }, { kind: "component", type: LoadingModal, selector: "app-loading-modal", inputs: ["isVisible", "backgroundColor", "displayColor"] }, { kind: "component", type: Pagination, selector: "app-pagination", inputs: ["totalPages", "currentUserPage", "handlePageChange", "position", "location", "direction", "buttonsContainerStyle", "activePageStyle", "inactivePageStyle", "backgroundColor", "paginationHeight", "showAspect", "parameters"] }, { kind: "component", type: SubAspectComponent, selector: "app-sub-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFractionSub"] }, { kind: "component", type: DisplaySettingsModal, selector: "app-display-settings-modal", inputs: ["isDisplaySettingsModalVisible", "onDisplaySettingsClose", "onModifyDisplaySettings", "parameters", "position", "backgroundColor"] }, { kind: "component", type: EventSettingsModal, selector: "app-event-settings-modal", inputs: ["isEventSettingsModalVisible", "onEventSettingsClose", "onModifyEventSettings", "position", "backgroundColor", "audioSetting", "videoSetting", "screenshareSetting", "chatSetting", "updateAudioSetting", "updateVideoSetting", "updateScreenshareSetting", "updateChatSetting", "updateIsSettingsModalVisible", "roomName", "socket", "showAlert"] }, { kind: "component", type: ConfirmExitModal, selector: "app-confirm-exit-modal", inputs: ["isConfirmExitModalVisible", "onConfirmExitClose", "position", "backgroundColor", "exitEventOnConfirm", "member", "ban", "roomName", "socket", "islevel"] }, { kind: "component", type: MediaSettingsModal, selector: "app-media-settings-modal", inputs: ["isMediaSettingsModalVisible", "onMediaSettingsClose", "switchCameraOnPress", "switchVideoOnPress", "switchAudioOnPress", "parameters", "position", "backgroundColor"] }, { kind: "component", type: MenuModal, selector: "app-menu-modal", inputs: ["backgroundColor", "isVisible", "customButtons", "shareButtons", "position", "roomName", "adminPasscode", "islevel", "eventType", "localLink", "onClose"] }, { kind: "component", type: MessagesModal, selector: "app-messages-modal", inputs: ["isMessagesModalVisible", "onMessagesClose", "onSendMessagePress", "messages", "position", "backgroundColor", "activeTabBackgroundColor", "eventType", "member", "islevel", "coHostResponsibility", "coHost", "startDirectMessage", "directMessageDetails", "updateStartDirectMessage", "updateDirectMessageDetails", "showAlert", "roomName", "socket", "chatSetting"] }, { kind: "component", type: ConfirmHereModal, selector: "app-confirm-here-modal", inputs: ["isConfirmHereModalVisible", "position", "backgroundColor", "displayColor", "onConfirmHereClose", "countdownDuration", "socket", "localSocket", "roomName", "member"] }, { kind: "component", type: ShareEventModal, selector: "app-share-event-modal", inputs: ["backgroundColor", "isShareEventModalVisible", "onShareEventClose", "roomName", "adminPasscode", "islevel", "position", "shareButtons", "eventType", "localLink"] }, { kind: "component", type: ParticipantsModal, selector: "app-participants-modal", inputs: ["isParticipantsModalVisible", "onParticipantsClose", "onParticipantsFilterChange", "participantsCounter", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "parameters", "position", "backgroundColor"] }, { kind: "component", type: PollModal, selector: "app-poll-modal", inputs: ["isPollModalVisible", "onClose", "position", "backgroundColor", "member", "islevel", "polls", "poll", "socket", "roomName", "showAlert", "updateIsPollModalVisible", "handleCreatePoll", "handleEndPoll", "handleVotePoll"] }, { kind: "component", type: RecordingModal, selector: "app-recording-modal", inputs: ["isRecordingModalVisible", "onClose", "backgroundColor", "position", "confirmRecording", "startRecording", "parameters"] }, { kind: "component", type: RequestsModal, selector: "app-requests-modal", inputs: ["isRequestsModalVisible", "requestCounter", "requestList", "roomName", "socket", "backgroundColor", "position", "parameters", "onRequestClose", "onRequestFilterChange", "onRequestItemPress", "updateRequestList"] }, { kind: "component", type: MainAspectComponent, selector: "app-main-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "updateIsWideScreen", "updateIsMediumScreen", "updateIsSmallScreen"] }, { kind: "component", type: MainContainerComponent, selector: "app-main-container-component", inputs: ["backgroundColor", "containerWidthFraction", "containerHeightFraction", "marginLeft", "marginRight", "marginTop", "marginBottom", "padding"] }, { kind: "component", type: MainGridComponent, selector: "app-main-grid-component", inputs: ["backgroundColor", "mainSize", "height", "width", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: MainScreenComponent, selector: "app-main-screen-component", inputs: ["mainSize", "doStack", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "showControls", "updateComponentSizes"] }, { kind: "component", type: OtherGridComponent, selector: "app-other-grid-component", inputs: ["backgroundColor", "width", "height", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: ScreenboardModal, selector: "app-screenboard-modal", inputs: ["parameters", "isVisible", "onClose", "position", "backgroundColor"] }, { kind: "component", type: Whiteboard, selector: "app-whiteboard", inputs: ["customWidth", "customHeight", "parameters", "showAspect"] }, { kind: "component", type: ConfigureWhiteboardModal, selector: "app-configure-whiteboard-modal", inputs: ["isVisible", "parameters", "backgroundColor", "position", "onConfigureWhiteboardClose"] }, { kind: "component", type: WaitingRoomModal, selector: "app-waiting-room-modal", inputs: ["isWaitingModalVisible", "waitingRoomCounter", "waitingRoomList", "roomName", "socket", "position", "backgroundColor", "parameters", "onWaitingRoomClose", "onWaitingRoomFilterChange", "updateWaitingList", "onWaitingRoomItemPress"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediasfuWebinar, decorators: [{
            type: Component,
            args: [{ selector: 'app-mediasfu-webinar', imports: [
                        CommonModule,
                        BreakoutRoomsModal,
                        BackgroundModal,
                        CoHostModal,
                        AlertComponent,
                        AudioGrid,
                        ControlButtonsComponent,
                        FlexibleGrid,
                        FlexibleVideo,
                        LoadingModal,
                        Pagination,
                        SubAspectComponent,
                        DisplaySettingsModal,
                        EventSettingsModal,
                        ConfirmExitModal,
                        MediaSettingsModal,
                        MenuModal,
                        MessagesModal,
                        ConfirmHereModal,
                        ShareEventModal,
                        ParticipantsModal,
                        PollModal,
                        RecordingModal,
                        RequestsModal,
                        MainAspectComponent,
                        MainContainerComponent,
                        MainGridComponent,
                        MainScreenComponent,
                        OtherGridComponent,
                        ScreenboardModal,
                        Whiteboard,
                        ConfigureWhiteboardModal,
                        WaitingRoomModal,
                    ], template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component *ngIf="returnUI">
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <ng-container *ngIf="returnUI">
      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
        [localLink]="localLink"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
        [localLink]="localLink"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </ng-container>
    </div>
  `, providers: [CookieService] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: UpdateMiniCardsGrid }, { type: MixStreams }, { type: DispStreams }, { type: StopShareScreen }, { type: CheckScreenShare }, { type: StartShareScreen }, { type: RequestScreenShare }, { type: ReorderStreams }, { type: PrepopulateUserMedia }, { type: GetVideos }, { type: RePort }, { type: Trigger }, { type: ConsumerResume }, { type: ConnectSendTransport }, { type: ConnectSendTransportAudio }, { type: ConnectSendTransportVideo }, { type: ConnectSendTransportScreen }, { type: ProcessConsumerTransports }, { type: ResumePauseStreams }, { type: Readjust }, { type: CheckGrid }, { type: GetEstimate }, { type: CalculateRowsAndColumns }, { type: AddVideosGrid }, { type: OnScreenChanges }, { type: ChangeVids }, { type: CompareActiveNames }, { type: CompareScreenStates }, { type: CreateSendTransport }, { type: ResumeSendTransportAudio }, { type: ReceiveAllPipedTransports }, { type: DisconnectSendTransportVideo }, { type: DisconnectSendTransportAudio }, { type: DisconnectSendTransportScreen }, { type: GetPipedProducersAlt }, { type: SignalNewConsumerTransport }, { type: ConnectRecvTransport }, { type: ReUpdateInter }, { type: UpdateParticipantAudioDecibels }, { type: CloseAndResize }, { type: AutoAdjust }, { type: SwitchUserVideoAlt }, { type: SwitchUserVideo }, { type: SwitchUserAudio }, { type: GetDomains }, { type: FormatNumber }, { type: ConnectIps }, { type: ConnectLocalIps }, { type: CreateDeviceClient }, { type: HandleCreatePoll }, { type: HandleEndPoll }, { type: HandleVotePoll }, { type: CaptureCanvasStream }, { type: ResumePauseAudioStreams }, { type: ProcessConsumerTransportsAudio }, { type: LaunchMenuModal }, { type: LaunchRecording }, { type: StartRecording }, { type: ConfirmRecording }, { type: LaunchWaiting }, { type: launchCoHost }, { type: LaunchMediaSettings }, { type: LaunchDisplaySettings }, { type: LaunchSettings }, { type: LaunchRequests }, { type: LaunchParticipants }, { type: LaunchMessages }, { type: LaunchConfirmExit }, { type: LaunchPoll }, { type: LaunchBreakoutRooms }, { type: LaunchConfigureWhiteboard }, { type: StartMeetingProgressTimer }, { type: UpdateRecording }, { type: StopRecording }, { type: UserWaiting }, { type: PersonJoined }, { type: AllWaitingRoomMembers }, { type: RoomRecordParams }, { type: BanParticipant }, { type: UpdatedCoHost }, { type: ParticipantRequested }, { type: ScreenProducerId }, { type: UpdateMediaSettings }, { type: ProducerMediaPaused }, { type: ProducerMediaResumed }, { type: ProducerMediaClosed }, { type: ControlMediaHost }, { type: MeetingEnded }, { type: DisconnectUserSelf }, { type: ReceiveMessage }, { type: MeetingTimeRemaining }, { type: MeetingStillThere }, { type: StartRecords }, { type: ReInitiateRecording }, { type: RecordingNotice }, { type: TimeLeftRecording }, { type: StoppedRecording }, { type: HostRequestResponse }, { type: AllMembers }, { type: AllMembersRest }, { type: Disconnect }, { type: PollUpdated }, { type: BreakoutRoomUpdated }, { type: SocketManager }, { type: JoinRoomClient }, { type: JoinLocalRoom }, { type: UpdateRoomParametersClient }, { type: ClickVideo }, { type: ClickAudio }, { type: ClickScreenShare }, { type: StreamSuccessVideo }, { type: StreamSuccessAudio }, { type: StreamSuccessScreen }, { type: StreamSuccessAudioSwitch }, { type: CheckPermission }, { type: UpdateConsumingDomains }, { type: ReceiveRoomMessages }], propDecorators: { PrejoinPage: [{
                type: Input
            }], localLink: [{
                type: Input
            }], connectMediaSFU: [{
                type: Input
            }], credentials: [{
                type: Input
            }], useLocalUIMode: [{
                type: Input
            }], seedData: [{
                type: Input
            }], useSeed: [{
                type: Input
            }], imgSrc: [{
                type: Input
            }], sourceParameters: [{
                type: Input
            }], updateSourceParameters: [{
                type: Input
            }], returnUI: [{
                type: Input
            }], noUIPreJoinOptions: [{
                type: Input
            }], joinMediaSFURoom: [{
                type: Input
            }], createMediaSFURoom: [{
                type: Input
            }], handleResize: [{
                type: HostListener,
                args: ['window:resize']
            }, {
                type: HostListener,
                args: ['window:orientationchange']
            }] } });

/**
 * MediasfuConference component creates an interactive conference interface, supporting breakout rooms, chat, video and audio management, and custom controls.
 *
 * @component
 * @selector app-mediasfu-conference
 * @standalone true
 * @imports [RouterOutlet, CommonModule, BreakoutRoomsModal, BackgroundModal, CoHostModal, AlertComponent, AudioGrid, ControlButtonsAltComponent, ControlButtonsComponent, FlexibleGrid, FlexibleVideo, LoadingModal, Pagination, SubAspectComponent, DisplaySettingsModal, EventSettingsModal, ConfirmExitModal, MediaSettingsModal, MenuModal, MessagesModal, ConfirmHereModal, ShareEventModal, WelcomePage, ParticipantsModal, PollModal, RecordingModal, RequestsModal, MainAspectComponent, MainContainerComponent, MainGridComponent, MainScreenComponent, OtherGridComponent, Screenboard, ScreenboardModal, Whiteboard, ConfigureWhiteboardModal, WaitingRoomModal, MenuWidget, MessageWidget, MenuRecordWidget, RecordTimerWidget, MenuParticipantsWidget, ScreenShareWidget]
 *
 * @template
 * The template includes:
 * - Conditional rendering for PrejoinPage or WelcomePage component.
 * - A main content area with modular components for grid layouts, video streaming, and sub-aspect controls.
 * - Modals for participants, settings, recording, breakout rooms, and more, to enhance interactivity and customization in conference settings.
 *
 * @input {any} PrejoinPage - Component for the prejoin page, defaults to `WelcomePage`.
 * @input {MediasfuConferenceOptions} options - Configuration options for the component.
 * @input {boolean} connectMediaSFU - Flag to enable/disable connection to the MediaSFU server.
 * @input {string} localLink - Local link for the Community Edition server.
 * @input {{ apiUserName: string; apiKey: string }} credentials - API credentials for secure access.
 * @input {boolean} useLocalUIMode - Flag to toggle local UI settings.
 * @input {SeedData} seedData - Seed data for initializing the component with specific configurations.
 * @input {boolean} useSeed - Enable/disable use of seed data.
 * @input {string} imgSrc - URL for branding images or logos.
 * @input {object} sourceParameters - Additional parameters for the source.
 * @input {Function} updateSourceParameters - Function to update the source parameters.
 * @input {boolean} returnUI - Flag to return the UI elements.
 * @input {CreateMediaSFURoomOptions | JoinMediaSFURoomOptions} noUIPreJoinOptions - Options for the prejoin page without UI.
 * @input {JoinRoomOnMediaSFUType} joinMediaSFURoom - Function to join a room on MediaSFU.
 * @input {CreateRoomOnMediaSFUType} createMediaSFURoom - Function to create a room on MediaSFU.
 *
 * @property {string} title - The title of the component, defaults to "MediaSFU-Conference".
 *
 * @styles
 * Customizable styles for component layout, overflow, and specific modal appearances.
 *
 * @providers [CookieService] - Service for managing cookies within the component.
 *
 * @constructor
 * @class MediasfuConference
 * @implements OnInit, OnDestroy
 *
 * @method ngOnInit - Initializes configurations and input parameters.
 * @method ngOnDestroy - Handles cleanup of event listeners or intervals.
 *
 * @example
 * ```html
 * <app-mediasfu-conference
 *   [PrejoinPage]="CustomPrejoinComponent"
 *   [localLink]="'https://localhost:3000'"
 *   [connectMediaSFU]="true"
 *   [credentials]="{ apiUserName: 'username', apiKey: 'apikey' }"
 *   [useLocalUIMode]="true"
 *   [seedData]="seedDataObject"
 *   [useSeed]="true"
 *   [imgSrc]="https://example.com/logo.png">
 *   [sourceParameters]="{ source: 'camera', width: 640, height: 480 }"
 *   [updateSourceParameters]="updateSourceParameters"
 *   [returnUI]="true"
 *   [noUIPreJoinOptions]="{ roomName: 'room1', userName: 'user1' }"
 *   [joinMediaSFURoom]="joinMediaSFURoom"
 *   [createMediaSFURoom]="createMediaSFURoom">
 * </app-mediasfu-conference>
 * ```
 */
class MediasfuConference {
    cdr;
    injector;
    updateMiniCardsGrid;
    mixStreams;
    dispStreams;
    stopShareScreen;
    checkScreenShare;
    startShareScreen;
    requestScreenShare;
    reorderStreams;
    prepopulateUserMedia;
    getVideos;
    rePort;
    trigger;
    consumerResume;
    connectSendTransport;
    connectSendTransportAudio;
    connectSendTransportVideo;
    connectSendTransportScreen;
    processConsumerTransports;
    resumePauseStreams;
    readjust;
    checkGrid;
    getEstimate;
    calculateRowsAndColumns;
    addVideosGrid;
    onScreenChanges;
    changeVids;
    compareActiveNames;
    compareScreenStates;
    createSendTransport;
    resumeSendTransportAudio;
    receiveAllPipedTransports;
    disconnectSendTransportVideo;
    disconnectSendTransportAudio;
    disconnectSendTransportScreen;
    getPipedProducersAlt;
    signalNewConsumerTransport;
    connectRecvTransport;
    reUpdateInter;
    updateParticipantAudioDecibels;
    closeAndResize;
    autoAdjust;
    switchUserVideoAlt;
    switchUserVideo;
    switchUserAudio;
    getDomains;
    formatNumber;
    connectIps;
    connectLocalIps;
    createDeviceClient;
    handleCreatePoll;
    handleEndPoll;
    handleVotePoll;
    captureCanvasStream;
    resumePauseAudioStreams;
    processConsumerTransportsAudio;
    launchMenuModal;
    launchRecording;
    startRecording;
    confirmRecording;
    launchWaiting;
    launchCoHost;
    launchMediaSettings;
    launchDisplaySettings;
    launchSettings;
    launchRequests;
    launchParticipants;
    launchMessages;
    launchConfirmExit;
    launchPoll;
    launchBreakoutRooms;
    launchConfigureWhiteboard;
    startMeetingProgressTimer;
    updateRecording;
    stopRecording;
    userWaiting;
    personJoined;
    allWaitingRoomMembers;
    roomRecordParams;
    banParticipant;
    updatedCoHost;
    participantRequested;
    screenProducerId;
    updateMediaSettings;
    producerMediaPaused;
    producerMediaResumed;
    producerMediaClosed;
    controlMediaHost;
    meetingEnded;
    disconnectUserSelf;
    receiveMessage;
    meetingTimeRemaining;
    meetingStillThere;
    startRecords;
    reInitiateRecording;
    recordingNotice;
    timeLeftRecording;
    stoppedRecording;
    hostRequestResponse;
    allMembers;
    allMembersRest;
    disconnect;
    pollUpdated;
    breakoutRoomUpdated;
    socketManager;
    joinRoomClient;
    joinLocalRoom;
    updateRoomParametersClient;
    clickVideo;
    clickAudio;
    clickScreenShare;
    streamSuccessVideo;
    streamSuccessAudio;
    streamSuccessScreen;
    streamSuccessAudioSwitch;
    checkPermission;
    updateConsumingDomains;
    receiveRoomMessages;
    PrejoinPage = WelcomePage;
    localLink = '';
    connectMediaSFU = true;
    credentials = { apiUserName: '', apiKey: '' };
    useLocalUIMode = false;
    seedData;
    useSeed = false;
    imgSrc = 'https://mediasfu.com/images/logo192.png';
    sourceParameters = {};
    updateSourceParameters = (data) => { };
    returnUI = true;
    noUIPreJoinOptions;
    joinMediaSFURoom;
    createMediaSFURoom;
    title = 'MediaSFU-Conference';
    mainHeightWidthSubscription;
    validatedSubscription;
    islevelSubscription;
    coHostSubscription;
    buttonSubscriptions = [];
    ScreenboardSubscription;
    recordingSubscription;
    constructor(cdr, injector, updateMiniCardsGrid, mixStreams, dispStreams, stopShareScreen, checkScreenShare, startShareScreen, requestScreenShare, reorderStreams, prepopulateUserMedia, getVideos, rePort, trigger, consumerResume, connectSendTransport, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, processConsumerTransports, resumePauseStreams, readjust, checkGrid, getEstimate, calculateRowsAndColumns, addVideosGrid, onScreenChanges, changeVids, compareActiveNames, compareScreenStates, createSendTransport, resumeSendTransportAudio, receiveAllPipedTransports, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, getPipedProducersAlt, signalNewConsumerTransport, connectRecvTransport, reUpdateInter, updateParticipantAudioDecibels, closeAndResize, autoAdjust, switchUserVideoAlt, switchUserVideo, switchUserAudio, getDomains, formatNumber, connectIps, connectLocalIps, createDeviceClient, handleCreatePoll, handleEndPoll, handleVotePoll, captureCanvasStream, resumePauseAudioStreams, processConsumerTransportsAudio, launchMenuModal, launchRecording, startRecording, confirmRecording, launchWaiting, launchCoHost, launchMediaSettings, launchDisplaySettings, launchSettings, launchRequests, launchParticipants, launchMessages, launchConfirmExit, launchPoll, launchBreakoutRooms, launchConfigureWhiteboard, startMeetingProgressTimer, updateRecording, stopRecording, userWaiting, personJoined, allWaitingRoomMembers, roomRecordParams, banParticipant, updatedCoHost, participantRequested, screenProducerId, updateMediaSettings, producerMediaPaused, producerMediaResumed, producerMediaClosed, controlMediaHost, meetingEnded, disconnectUserSelf, receiveMessage, meetingTimeRemaining, meetingStillThere, startRecords, reInitiateRecording, recordingNotice, timeLeftRecording, stoppedRecording, hostRequestResponse, allMembers, allMembersRest, disconnect, pollUpdated, breakoutRoomUpdated, socketManager, joinRoomClient, joinLocalRoom, updateRoomParametersClient, clickVideo, clickAudio, clickScreenShare, streamSuccessVideo, streamSuccessAudio, streamSuccessScreen, streamSuccessAudioSwitch, checkPermission, updateConsumingDomains, receiveRoomMessages) {
        this.cdr = cdr;
        this.injector = injector;
        this.updateMiniCardsGrid = updateMiniCardsGrid;
        this.mixStreams = mixStreams;
        this.dispStreams = dispStreams;
        this.stopShareScreen = stopShareScreen;
        this.checkScreenShare = checkScreenShare;
        this.startShareScreen = startShareScreen;
        this.requestScreenShare = requestScreenShare;
        this.reorderStreams = reorderStreams;
        this.prepopulateUserMedia = prepopulateUserMedia;
        this.getVideos = getVideos;
        this.rePort = rePort;
        this.trigger = trigger;
        this.consumerResume = consumerResume;
        this.connectSendTransport = connectSendTransport;
        this.connectSendTransportAudio = connectSendTransportAudio;
        this.connectSendTransportVideo = connectSendTransportVideo;
        this.connectSendTransportScreen = connectSendTransportScreen;
        this.processConsumerTransports = processConsumerTransports;
        this.resumePauseStreams = resumePauseStreams;
        this.readjust = readjust;
        this.checkGrid = checkGrid;
        this.getEstimate = getEstimate;
        this.calculateRowsAndColumns = calculateRowsAndColumns;
        this.addVideosGrid = addVideosGrid;
        this.onScreenChanges = onScreenChanges;
        this.changeVids = changeVids;
        this.compareActiveNames = compareActiveNames;
        this.compareScreenStates = compareScreenStates;
        this.createSendTransport = createSendTransport;
        this.resumeSendTransportAudio = resumeSendTransportAudio;
        this.receiveAllPipedTransports = receiveAllPipedTransports;
        this.disconnectSendTransportVideo = disconnectSendTransportVideo;
        this.disconnectSendTransportAudio = disconnectSendTransportAudio;
        this.disconnectSendTransportScreen = disconnectSendTransportScreen;
        this.getPipedProducersAlt = getPipedProducersAlt;
        this.signalNewConsumerTransport = signalNewConsumerTransport;
        this.connectRecvTransport = connectRecvTransport;
        this.reUpdateInter = reUpdateInter;
        this.updateParticipantAudioDecibels = updateParticipantAudioDecibels;
        this.closeAndResize = closeAndResize;
        this.autoAdjust = autoAdjust;
        this.switchUserVideoAlt = switchUserVideoAlt;
        this.switchUserVideo = switchUserVideo;
        this.switchUserAudio = switchUserAudio;
        this.getDomains = getDomains;
        this.formatNumber = formatNumber;
        this.connectIps = connectIps;
        this.connectLocalIps = connectLocalIps;
        this.createDeviceClient = createDeviceClient;
        this.handleCreatePoll = handleCreatePoll;
        this.handleEndPoll = handleEndPoll;
        this.handleVotePoll = handleVotePoll;
        this.captureCanvasStream = captureCanvasStream;
        this.resumePauseAudioStreams = resumePauseAudioStreams;
        this.processConsumerTransportsAudio = processConsumerTransportsAudio;
        this.launchMenuModal = launchMenuModal;
        this.launchRecording = launchRecording;
        this.startRecording = startRecording;
        this.confirmRecording = confirmRecording;
        this.launchWaiting = launchWaiting;
        this.launchCoHost = launchCoHost;
        this.launchMediaSettings = launchMediaSettings;
        this.launchDisplaySettings = launchDisplaySettings;
        this.launchSettings = launchSettings;
        this.launchRequests = launchRequests;
        this.launchParticipants = launchParticipants;
        this.launchMessages = launchMessages;
        this.launchConfirmExit = launchConfirmExit;
        this.launchPoll = launchPoll;
        this.launchBreakoutRooms = launchBreakoutRooms;
        this.launchConfigureWhiteboard = launchConfigureWhiteboard;
        this.startMeetingProgressTimer = startMeetingProgressTimer;
        this.updateRecording = updateRecording;
        this.stopRecording = stopRecording;
        this.userWaiting = userWaiting;
        this.personJoined = personJoined;
        this.allWaitingRoomMembers = allWaitingRoomMembers;
        this.roomRecordParams = roomRecordParams;
        this.banParticipant = banParticipant;
        this.updatedCoHost = updatedCoHost;
        this.participantRequested = participantRequested;
        this.screenProducerId = screenProducerId;
        this.updateMediaSettings = updateMediaSettings;
        this.producerMediaPaused = producerMediaPaused;
        this.producerMediaResumed = producerMediaResumed;
        this.producerMediaClosed = producerMediaClosed;
        this.controlMediaHost = controlMediaHost;
        this.meetingEnded = meetingEnded;
        this.disconnectUserSelf = disconnectUserSelf;
        this.receiveMessage = receiveMessage;
        this.meetingTimeRemaining = meetingTimeRemaining;
        this.meetingStillThere = meetingStillThere;
        this.startRecords = startRecords;
        this.reInitiateRecording = reInitiateRecording;
        this.recordingNotice = recordingNotice;
        this.timeLeftRecording = timeLeftRecording;
        this.stoppedRecording = stoppedRecording;
        this.hostRequestResponse = hostRequestResponse;
        this.allMembers = allMembers;
        this.allMembersRest = allMembersRest;
        this.disconnect = disconnect;
        this.pollUpdated = pollUpdated;
        this.breakoutRoomUpdated = breakoutRoomUpdated;
        this.socketManager = socketManager;
        this.joinRoomClient = joinRoomClient;
        this.joinLocalRoom = joinLocalRoom;
        this.updateRoomParametersClient = updateRoomParametersClient;
        this.clickVideo = clickVideo;
        this.clickAudio = clickAudio;
        this.clickScreenShare = clickScreenShare;
        this.streamSuccessVideo = streamSuccessVideo;
        this.streamSuccessAudio = streamSuccessAudio;
        this.streamSuccessScreen = streamSuccessScreen;
        this.streamSuccessAudioSwitch = streamSuccessAudioSwitch;
        this.checkPermission = checkPermission;
        this.updateConsumingDomains = updateConsumingDomains;
        this.receiveRoomMessages = receiveRoomMessages;
    }
    createInjector(inputs) {
        const inj = Injector.create({
            providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
            parent: this.injector,
        });
        return inj;
    }
    // Initial values
    mediaSFUFunctions = () => {
        return {
            updateMiniCardsGrid: this.updateMiniCardsGrid?.updateMiniCardsGrid ||
                (() => {
                    console.log('none');
                }),
            mixStreams: this.mixStreams?.mixStreams ||
                (() => {
                    console.log('none');
                }),
            dispStreams: this.dispStreams?.dispStreams ||
                (() => {
                    console.log('none');
                }),
            stopShareScreen: this.stopShareScreen?.stopShareScreen ||
                (() => {
                    console.log('none');
                }),
            checkScreenShare: this.checkScreenShare?.checkScreenShare ||
                (() => {
                    console.log('none');
                }),
            startShareScreen: this.startShareScreen?.startShareScreen ||
                (() => {
                    console.log('none');
                }),
            requestScreenShare: this.requestScreenShare?.requestScreenShare ||
                (() => {
                    console.log('none');
                }),
            reorderStreams: this.reorderStreams?.reorderStreams ||
                (() => {
                    console.log('none');
                }),
            prepopulateUserMedia: this.prepopulateUserMedia?.prepopulateUserMedia ||
                (() => {
                    console.log('none');
                }),
            getVideos: this.getVideos?.getVideos ||
                (() => {
                    console.log('none');
                }),
            rePort: this.rePort?.rePort ||
                (() => {
                    console.log('none');
                }),
            trigger: this.trigger?.trigger ||
                (() => {
                    console.log('none');
                }),
            consumerResume: this.consumerResume?.consumerResume ||
                (() => {
                    console.log('none');
                }),
            connectSendTransport: this.connectSendTransport?.connectSendTransport ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportAudio: this.connectSendTransportAudio?.connectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportVideo: this.connectSendTransportVideo?.connectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportScreen: this.connectSendTransportScreen?.connectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransports: this.processConsumerTransports?.processConsumerTransports ||
                (() => {
                    console.log('none');
                }),
            resumePauseStreams: this.resumePauseStreams?.resumePauseStreams ||
                (() => {
                    console.log('none');
                }),
            readjust: this.readjust?.readjust ||
                (() => {
                    console.log('none');
                }),
            checkGrid: this.checkGrid?.checkGrid ||
                (() => {
                    console.log('none');
                }),
            getEstimate: this.getEstimate?.getEstimate ||
                (() => {
                    console.log('none');
                }),
            calculateRowsAndColumns: this.calculateRowsAndColumns?.calculateRowsAndColumns ||
                (() => {
                    console.log('none');
                }),
            addVideosGrid: this.addVideosGrid?.addVideosGrid ||
                (() => {
                    console.log('none');
                }),
            onScreenChanges: this.onScreenChanges?.onScreenChanges ||
                (() => {
                    console.log('none');
                }),
            sleep: sleep ||
                (() => {
                    console.log('none');
                }),
            changeVids: this.changeVids?.changeVids ||
                (() => {
                    console.log('none');
                }),
            compareActiveNames: this.compareActiveNames?.compareActiveNames ||
                (() => {
                    console.log('none');
                }),
            compareScreenStates: this.compareScreenStates?.compareScreenStates ||
                (() => {
                    console.log('none');
                }),
            createSendTransport: this.createSendTransport?.createSendTransport ||
                (() => {
                    console.log('none');
                }),
            resumeSendTransportAudio: this.resumeSendTransportAudio?.resumeSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            receiveAllPipedTransports: this.receiveAllPipedTransports?.receiveAllPipedTransports ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportVideo: this.disconnectSendTransportVideo?.disconnectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportAudio: this.disconnectSendTransportAudio?.disconnectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportScreen: this.disconnectSendTransportScreen?.disconnectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            getPipedProducersAlt: this.getPipedProducersAlt?.getPipedProducersAlt ||
                (() => {
                    console.log('none');
                }),
            signalNewConsumerTransport: this.signalNewConsumerTransport?.signalNewConsumerTransport ||
                (() => {
                    console.log('none');
                }),
            connectRecvTransport: this.connectRecvTransport?.connectRecvTransport ||
                (() => {
                    console.log('none');
                }),
            reUpdateInter: this.reUpdateInter?.reUpdateInter ||
                (() => {
                    console.log('none');
                }),
            updateParticipantAudioDecibels: this.updateParticipantAudioDecibels?.updateParticipantAudioDecibels ||
                (() => {
                    console.log('none');
                }),
            closeAndResize: this.closeAndResize?.closeAndResize ||
                (() => {
                    console.log('none');
                }),
            autoAdjust: this.autoAdjust?.autoAdjust ||
                (() => {
                    console.log('none');
                }),
            switchUserVideoAlt: this.switchUserVideoAlt?.switchUserVideoAlt ||
                (() => {
                    console.log('none');
                }),
            switchUserVideo: this.switchUserVideo?.switchUserVideo ||
                (() => {
                    console.log('none');
                }),
            switchUserAudio: this.switchUserAudio?.switchUserAudio ||
                (() => {
                    console.log('none');
                }),
            getDomains: this.getDomains?.getDomains ||
                (() => {
                    console.log('none');
                }),
            formatNumber: this.formatNumber?.formatNumber ||
                (() => {
                    console.log('none');
                }),
            connectIps: this.connectIps?.connectIps ||
                (() => {
                    console.log('none');
                }),
            connectLocalIps: this.connectLocalIps?.connectLocalIps ||
                (() => {
                    console.log('none');
                }),
            createDeviceClient: this.createDeviceClient?.createDeviceClient ||
                (() => {
                    console.log('none');
                }),
            handleCreatePoll: this.handleCreatePoll?.handleCreatePoll ||
                (() => {
                    console.log('none');
                }),
            handleEndPoll: this.handleEndPoll?.handleEndPoll ||
                (() => {
                    console.log('none');
                }),
            handleVotePoll: this.handleVotePoll?.handleVotePoll ||
                (() => {
                    console.log('none');
                }),
            captureCanvasStream: this.captureCanvasStream?.captureCanvasStream ||
                (() => {
                    console.log('none');
                }),
            resumePauseAudioStreams: this.resumePauseAudioStreams?.resumePauseAudioStreams ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransportsAudio: this.processConsumerTransportsAudio?.processConsumerTransportsAudio ||
                (() => {
                    console.log('none');
                }),
            checkPermission: this.checkPermission?.checkPermission ||
                (() => {
                    console.log('none');
                }),
            streamSuccessVideo: this.streamSuccessVideo?.streamSuccessVideo ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudio: this.streamSuccessAudio?.streamSuccessAudio ||
                (() => {
                    console.log('none');
                }),
            streamSuccessScreen: this.streamSuccessScreen?.streamSuccessScreen ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudioSwitch: this.streamSuccessAudioSwitch?.streamSuccessAudioSwitch ||
                (() => {
                    console.log('none');
                }),
            clickVideo: this.clickVideo?.clickVideo ||
                (() => {
                    console.log('none');
                }),
            clickAudio: this.clickAudio?.clickAudio ||
                (() => {
                    console.log('none');
                }),
            clickScreenShare: this.clickScreenShare?.clickScreenShare ||
                (() => {
                    console.log('none');
                }),
            requestPermissionCamera: this.requestPermissionCamera ||
                (() => {
                    console.log('none');
                }),
            requestPermissionAudio: this.requestPermissionAudio ||
                (() => {
                    console.log('none');
                }),
        };
    };
    validated = new BehaviorSubject$1(false);
    localUIMode = new BehaviorSubject$1(false);
    socket = new BehaviorSubject$1({});
    localSocket = new BehaviorSubject$1(undefined);
    roomData = new BehaviorSubject$1(null);
    device = new BehaviorSubject$1(null);
    apiKey = new BehaviorSubject$1('');
    apiUserName = new BehaviorSubject$1('');
    apiToken = new BehaviorSubject$1('');
    link = new BehaviorSubject$1('');
    roomName = new BehaviorSubject$1('');
    member = new BehaviorSubject$1('');
    adminPasscode = new BehaviorSubject$1('');
    islevel = new BehaviorSubject$1('1');
    coHost = new BehaviorSubject$1('No coHost');
    coHostResponsibility = new BehaviorSubject$1([
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ]);
    youAreCoHost = new BehaviorSubject$1(false);
    youAreHost = new BehaviorSubject$1(false);
    confirmedToRecord = new BehaviorSubject$1(false);
    meetingDisplayType = new BehaviorSubject$1('media');
    meetingVideoOptimized = new BehaviorSubject$1(false);
    eventType = new BehaviorSubject$1('conference');
    participants = new BehaviorSubject$1([]);
    filteredParticipants = new BehaviorSubject$1([]);
    participantsCounter = new BehaviorSubject$1(0);
    participantsFilter = new BehaviorSubject$1('');
    consume_sockets = new BehaviorSubject$1([]);
    rtpCapabilities = new BehaviorSubject$1(null);
    roomRecvIPs = new BehaviorSubject$1([]);
    meetingRoomParams = new BehaviorSubject$1(null);
    itemPageLimit = new BehaviorSubject$1(4);
    audioOnlyRoom = new BehaviorSubject$1(false);
    addForBasic = new BehaviorSubject$1(false);
    screenPageLimit = new BehaviorSubject$1(4);
    shareScreenStarted = new BehaviorSubject$1(false);
    shared = new BehaviorSubject$1(false);
    targetOrientation = new BehaviorSubject$1('landscape');
    targetResolution = new BehaviorSubject$1('sd');
    targetResolutionHost = new BehaviorSubject$1('sd');
    vidCons = new BehaviorSubject$1({ width: 640, height: 360 });
    frameRate = new BehaviorSubject$1(10);
    hParams = new BehaviorSubject$1({});
    vParams = new BehaviorSubject$1({});
    screenParams = new BehaviorSubject$1({});
    aParams = new BehaviorSubject$1({});
    recordingAudioPausesLimit = new BehaviorSubject$1(0);
    recordingAudioPausesCount = new BehaviorSubject$1(0);
    recordingAudioSupport = new BehaviorSubject$1(false);
    recordingAudioPeopleLimit = new BehaviorSubject$1(0);
    recordingAudioParticipantsTimeLimit = new BehaviorSubject$1(0);
    recordingVideoPausesCount = new BehaviorSubject$1(0);
    recordingVideoPausesLimit = new BehaviorSubject$1(0);
    recordingVideoSupport = new BehaviorSubject$1(false);
    recordingVideoPeopleLimit = new BehaviorSubject$1(0);
    recordingVideoParticipantsTimeLimit = new BehaviorSubject$1(0);
    recordingAllParticipantsSupport = new BehaviorSubject$1(false);
    recordingVideoParticipantsSupport = new BehaviorSubject$1(false);
    recordingAllParticipantsFullRoomSupport = new BehaviorSubject$1(false);
    recordingVideoParticipantsFullRoomSupport = new BehaviorSubject$1(false);
    recordingPreferredOrientation = new BehaviorSubject$1('landscape');
    recordingSupportForOtherOrientation = new BehaviorSubject$1(false);
    recordingMultiFormatsSupport = new BehaviorSubject$1(false);
    userRecordingParams = new BehaviorSubject$1({
        mainSpecs: {
            mediaOptions: 'video', // 'audio', 'video'
            audioOptions: 'all', // 'all', 'onScreen', 'host'
            videoOptions: 'all', // 'all', 'mainScreen'
            videoType: 'fullDisplay', // 'all', 'bestDisplay', 'fullDisplay'
            videoOptimized: false, // true, false
            recordingDisplayType: 'media', // 'media', 'video', 'all'
            addHLS: false, // true, false
        },
        dispSpecs: {
            nameTags: true, // true, false
            backgroundColor: '#000000', // '#000000', '#ffffff'
            nameTagsColor: '#ffffff', // '#000000', '#ffffff'
            orientationVideo: 'portrait', // 'landscape', 'portrait', 'all'
        },
    });
    canRecord = new BehaviorSubject$1(false);
    startReport = new BehaviorSubject$1(false);
    endReport = new BehaviorSubject$1(false);
    recordTimerInterval = new BehaviorSubject$1(null);
    recordStartTime = new BehaviorSubject$1(0);
    recordElapsedTime = new BehaviorSubject$1(0);
    isTimerRunning = new BehaviorSubject$1(false);
    canPauseResume = new BehaviorSubject$1(false);
    recordChangeSeconds = new BehaviorSubject$1(15000);
    pauseLimit = new BehaviorSubject$1(0);
    pauseRecordCount = new BehaviorSubject$1(0);
    canLaunchRecord = new BehaviorSubject$1(true);
    stopLaunchRecord = new BehaviorSubject$1(false);
    participantsAll = new BehaviorSubject$1([]);
    firstAll = new BehaviorSubject$1(false);
    updateMainWindow = new BehaviorSubject$1(false);
    first_round = new BehaviorSubject$1(false);
    landScaped = new BehaviorSubject$1(false);
    lock_screen = new BehaviorSubject$1(false);
    screenId = new BehaviorSubject$1('');
    allVideoStreams = new BehaviorSubject$1([]);
    newLimitedStreams = new BehaviorSubject$1([]);
    newLimitedStreamsIDs = new BehaviorSubject$1([]);
    activeSounds = new BehaviorSubject$1([]);
    screenShareIDStream = new BehaviorSubject$1('');
    screenShareNameStream = new BehaviorSubject$1('');
    adminIDStream = new BehaviorSubject$1('');
    adminNameStream = new BehaviorSubject$1('');
    youYouStream = new BehaviorSubject$1([]);
    youYouStreamIDs = new BehaviorSubject$1([]);
    localStream = new BehaviorSubject$1(null);
    recordStarted = new BehaviorSubject$1(false);
    recordResumed = new BehaviorSubject$1(false);
    recordPaused = new BehaviorSubject$1(false);
    recordStopped = new BehaviorSubject$1(false);
    adminRestrictSetting = new BehaviorSubject$1(false);
    videoRequestState = new BehaviorSubject$1(null);
    videoRequestTime = new BehaviorSubject$1(0);
    videoAction = new BehaviorSubject$1(false);
    localStreamVideo = new BehaviorSubject$1(null);
    userDefaultVideoInputDevice = new BehaviorSubject$1('');
    currentFacingMode = new BehaviorSubject$1('user');
    prevFacingMode = new BehaviorSubject$1('user');
    defVideoID = new BehaviorSubject$1('');
    allowed = new BehaviorSubject$1(false);
    dispActiveNames = new BehaviorSubject$1([]);
    p_dispActiveNames = new BehaviorSubject$1([]);
    activeNames = new BehaviorSubject$1([]);
    prevActiveNames = new BehaviorSubject$1([]);
    p_activeNames = new BehaviorSubject$1([]);
    membersReceived = new BehaviorSubject$1(false);
    deferScreenReceived = new BehaviorSubject$1(false);
    hostFirstSwitch = new BehaviorSubject$1(false);
    micAction = new BehaviorSubject$1(false);
    screenAction = new BehaviorSubject$1(false);
    chatAction = new BehaviorSubject$1(false);
    audioRequestState = new BehaviorSubject$1(null);
    screenRequestState = new BehaviorSubject$1(null);
    chatRequestState = new BehaviorSubject$1(null);
    audioRequestTime = new BehaviorSubject$1(0);
    screenRequestTime = new BehaviorSubject$1(0);
    chatRequestTime = new BehaviorSubject$1(0);
    updateRequestIntervalSeconds = new BehaviorSubject$1(240);
    oldSoundIds = new BehaviorSubject$1([]);
    hostLabel = new BehaviorSubject$1('Host');
    mainScreenFilled = new BehaviorSubject$1(false);
    localStreamScreen = new BehaviorSubject$1(null);
    screenAlreadyOn = new BehaviorSubject$1(false);
    chatAlreadyOn = new BehaviorSubject$1(false);
    redirectURL = new BehaviorSubject$1('');
    oldAllStreams = new BehaviorSubject$1([]);
    adminVidID = new BehaviorSubject$1('');
    streamNames = new BehaviorSubject$1([]);
    non_alVideoStreams = new BehaviorSubject$1([]);
    sortAudioLoudness = new BehaviorSubject$1(false);
    audioDecibels = new BehaviorSubject$1([]);
    mixed_alVideoStreams = new BehaviorSubject$1([]);
    non_alVideoStreams_muted = new BehaviorSubject$1([]);
    paginatedStreams = new BehaviorSubject$1([]);
    localStreamAudio = new BehaviorSubject$1(null);
    defAudioID = new BehaviorSubject$1('');
    userDefaultAudioInputDevice = new BehaviorSubject$1('');
    userDefaultAudioOutputDevice = new BehaviorSubject$1('');
    prevAudioInputDevice = new BehaviorSubject$1('');
    prevVideoInputDevice = new BehaviorSubject$1('');
    audioPaused = new BehaviorSubject$1(false);
    mainScreenPerson = new BehaviorSubject$1('');
    adminOnMainScreen = new BehaviorSubject$1(false);
    screenStates = new BehaviorSubject$1([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    prevScreenStates = new BehaviorSubject$1([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    updateDateState = new BehaviorSubject$1(null);
    lastUpdate = new BehaviorSubject$1(null);
    nForReadjustRecord = new BehaviorSubject$1(0);
    fixedPageLimit = new BehaviorSubject$1(4);
    removeAltGrid = new BehaviorSubject$1(false);
    nForReadjust = new BehaviorSubject$1(0);
    reorderInterval = new BehaviorSubject$1(30000);
    fastReorderInterval = new BehaviorSubject$1(10000);
    lastReorderTime = new BehaviorSubject$1(0);
    audStreamNames = new BehaviorSubject$1([]);
    currentUserPage = new BehaviorSubject$1(0);
    mainHeightWidth = new BehaviorSubject$1(this.eventType.value == 'webinar' ? 67 : this.eventType.value == 'broadcast' ? 100 : 0);
    prevMainHeightWidth = new BehaviorSubject$1(this.mainHeightWidth.value);
    prevDoPaginate = new BehaviorSubject$1(false);
    doPaginate = new BehaviorSubject$1(false);
    shareEnded = new BehaviorSubject$1(false);
    lStreams = new BehaviorSubject$1([]);
    chatRefStreams = new BehaviorSubject$1([]);
    controlHeight = new BehaviorSubject$1(this.eventType.value === 'webinar' || this.eventType.value === 'conference' ? 0 : 0.06);
    isWideScreen = new BehaviorSubject$1(false);
    isMediumScreen = new BehaviorSubject$1(false);
    isSmallScreen = new BehaviorSubject$1(false);
    addGrid = new BehaviorSubject$1(false);
    addAltGrid = new BehaviorSubject$1(false);
    gridRows = new BehaviorSubject$1(0);
    gridCols = new BehaviorSubject$1(0);
    altGridRows = new BehaviorSubject$1(0);
    altGridCols = new BehaviorSubject$1(0);
    numberPages = new BehaviorSubject$1(0);
    currentStreams = new BehaviorSubject$1([]);
    showMiniView = new BehaviorSubject$1(false);
    nStream = new BehaviorSubject$1(null);
    defer_receive = new BehaviorSubject$1(false);
    allAudioStreams = new BehaviorSubject$1([]);
    remoteScreenStream = new BehaviorSubject$1([]);
    screenProducer = new BehaviorSubject$1(null);
    localScreenProducer = new BehaviorSubject$1(null);
    gotAllVids = new BehaviorSubject$1(false);
    paginationHeightWidth = new BehaviorSubject$1(40);
    paginationDirection = new BehaviorSubject$1('horizontal');
    gridSizes = new BehaviorSubject$1({
        gridWidth: 0,
        gridHeight: 0,
        altGridWidth: 0,
        altGridHeight: 0,
    });
    screenForceFullDisplay = new BehaviorSubject$1(false);
    mainGridStream = new BehaviorSubject$1([]);
    otherGridStreams = new BehaviorSubject$1([]);
    audioOnlyStreams = new BehaviorSubject$1([]);
    videoInputs = new BehaviorSubject$1([]);
    audioInputs = new BehaviorSubject$1([]);
    meetingProgressTime = new BehaviorSubject$1('00:00:00');
    meetingElapsedTime = new BehaviorSubject$1(0);
    ref_participants = new BehaviorSubject$1([]);
    updateValidated = (value) => {
        this.validated.next(value);
    };
    updateSocket = (value) => {
        this.socket.next(value);
    };
    updateLocalSocket = (value) => {
        this.localSocket.next(value);
    };
    updateDevice = (value) => {
        this.device.next(value);
    };
    updateRoomData = (value) => {
        this.roomData.next(value);
    };
    updateApiKey = (value) => {
        this.apiKey.next(value);
    };
    updateApiUserName = (value) => {
        this.apiUserName.next(value);
    };
    updateApiToken = (value) => {
        this.apiToken.next(value);
    };
    updateLink = (value) => {
        this.link.next(value);
    };
    updateRoomName = (value) => {
        this.roomName.next(value);
    };
    updateMember = (value) => {
        if (value.length > 0 && value.includes("_")) {
            this.updateIslevel(value.split("_")[1]);
            value = value.split("_")[0];
        }
        this.member.next(value);
    };
    updateAdminPasscode = (value) => {
        this.adminPasscode.next(value);
    };
    updateIslevel = (value) => {
        this.islevel.next(value);
    };
    updateCoHost = (value) => {
        this.coHost.next(value);
    };
    updateCoHostResponsibility = (value) => {
        this.coHostResponsibility.next(value);
    };
    updateYouAreCoHost = (value) => {
        this.youAreCoHost.next(value);
    };
    updateYouAreHost = (value) => {
        this.youAreHost.next(value);
    };
    updateConfirmedToRecord = (value) => {
        this.confirmedToRecord.next(value);
    };
    updateMeetingDisplayType = (value) => {
        this.meetingDisplayType.next(value);
    };
    updateMeetingVideoOptimized = (value) => {
        this.meetingVideoOptimized.next(value);
    };
    updateEventType = (value) => {
        this.eventType.next(value);
        if (value != 'none') {
            try {
                setTimeout(() => {
                    this.handleResize();
                }, 2000);
            }
            catch {
                /* handle error */
            }
        }
    };
    updateParticipants = (value) => {
        this.participants.next(value);
        this.participantsCounter.next(value.length);
        this.filteredParticipants.next(this.participants.value);
    };
    updateFilteredParticipants = (value) => {
        this.filteredParticipants.next(value);
    };
    updateParticipantsCounter = (value) => {
        this.participantsCounter.next(value);
    };
    updateParticipantsFilter = (value) => {
        this.participantsFilter.next(value);
    };
    updateConsume_sockets = (value) => {
        this.consume_sockets.next(value);
    };
    updateRtpCapabilities = (value) => {
        this.rtpCapabilities.next(value);
    };
    updateRoomRecvIPs = (value) => {
        this.roomRecvIPs.next(value);
    };
    updateMeetingRoomParams = (value) => {
        this.meetingRoomParams.next(value);
    };
    updateItemPageLimit = (value) => {
        this.itemPageLimit.next(value);
    };
    updateAudioOnlyRoom = (value) => {
        this.audioOnlyRoom.next(value);
    };
    updateAddForBasic = (value) => {
        this.addForBasic.next(value);
    };
    updateScreenPageLimit = (value) => {
        this.screenPageLimit.next(value);
    };
    updateShareScreenStarted = (value) => {
        this.shareScreenStarted.next(value);
    };
    updateShared = (value) => {
        this.shared.next(value);
        this.screenShareActive.next(value);
        if (value) {
            setTimeout(async () => {
                window.dispatchEvent(new Event('resize'));
            }, 2000);
        }
    };
    updateTargetOrientation = (value) => {
        this.targetOrientation.next(value);
    };
    updateTargetResolution = (value) => {
        this.targetResolution.next(value);
    };
    updateTargetResolutionHost = (value) => {
        this.targetResolutionHost.next(value);
    };
    updateVidCons = (value) => {
        this.vidCons.next(value);
    };
    updateFrameRate = (value) => {
        this.frameRate.next(value);
    };
    updateHParams = (value) => {
        this.hParams.next(value);
    };
    updateVParams = (value) => {
        this.vParams.next(value);
    };
    updateScreenParams = (value) => {
        this.screenParams.next(value);
    };
    updateAParams = (value) => {
        this.aParams.next(value);
    };
    updateRecordingAudioPausesLimit = (value) => {
        this.recordingAudioPausesLimit.next(value);
    };
    updateRecordingAudioPausesCount = (value) => {
        this.recordingAudioPausesCount.next(value);
    };
    updateRecordingAudioSupport = (value) => {
        this.recordingAudioSupport.next(value);
    };
    updateRecordingAudioPeopleLimit = (value) => {
        this.recordingAudioPeopleLimit.next(value);
    };
    updateRecordingAudioParticipantsTimeLimit = (value) => {
        this.recordingAudioParticipantsTimeLimit.next(value);
    };
    updateRecordingVideoPausesCount = (value) => {
        this.recordingVideoPausesCount.next(value);
    };
    updateRecordingVideoPausesLimit = (value) => {
        this.recordingVideoPausesLimit.next(value);
    };
    updateRecordingVideoSupport = (value) => {
        this.recordingVideoSupport.next(value);
    };
    updateRecordingVideoPeopleLimit = (value) => {
        this.recordingVideoPeopleLimit.next(value);
    };
    updateRecordingVideoParticipantsTimeLimit = (value) => {
        this.recordingVideoParticipantsTimeLimit.next(value);
    };
    updateRecordingAllParticipantsSupport = (value) => {
        this.recordingAllParticipantsSupport.next(value);
    };
    updateRecordingVideoParticipantsSupport = (value) => {
        this.recordingVideoParticipantsSupport.next(value);
    };
    updateRecordingAllParticipantsFullRoomSupport = (value) => {
        this.recordingAllParticipantsFullRoomSupport.next(value);
    };
    updateRecordingVideoParticipantsFullRoomSupport = (value) => {
        this.recordingVideoParticipantsFullRoomSupport.next(value);
    };
    updateRecordingPreferredOrientation = (value) => {
        this.recordingPreferredOrientation.next(value);
    };
    updateRecordingSupportForOtherOrientation = (value) => {
        this.recordingSupportForOtherOrientation.next(value);
    };
    updateRecordingMultiFormatsSupport = (value) => {
        this.recordingMultiFormatsSupport.next(value);
    };
    updateUserRecordingParams = (value) => {
        this.userRecordingParams.next(value);
    };
    updateCanRecord = (value) => {
        this.canRecord.next(value);
    };
    updateStartReport = (value) => {
        this.startReport.next(value);
    };
    updateEndReport = (value) => {
        this.endReport.next(value);
    };
    updateRecordTimerInterval = (value) => {
        this.recordTimerInterval.next(value);
    };
    updateRecordStartTime = (value) => {
        this.recordStartTime.next(value);
    };
    updateRecordElapsedTime = (value) => {
        this.recordElapsedTime.next(value);
    };
    updateIsTimerRunning = (value) => {
        this.isTimerRunning.next(value);
    };
    updateCanPauseResume = (value) => {
        this.canPauseResume.next(value);
    };
    updateRecordChangeSeconds = (value) => {
        this.recordChangeSeconds.next(value);
    };
    updatePauseLimit = (value) => {
        this.pauseLimit.next(value);
    };
    updatePauseRecordCount = (value) => {
        this.pauseRecordCount.next(value);
    };
    updateCanLaunchRecord = (value) => {
        this.canLaunchRecord.next(value);
    };
    updateStopLaunchRecord = (value) => {
        this.stopLaunchRecord.next(value);
    };
    updateParticipantsAll = (value) => {
        this.participantsAll.next(value);
    };
    updateFirstAll = (value) => {
        this.firstAll.next(value);
    };
    updateUpdateMainWindow = (value) => {
        this.updateMainWindow.next(value);
    };
    updateFirst_round = (value) => {
        this.first_round.next(value);
    };
    updateLandScaped = (value) => {
        this.landScaped.next(value);
    };
    updateLock_screen = (value) => {
        this.lock_screen.next(value);
    };
    updateScreenId = (value) => {
        this.screenId.next(value);
    };
    updateAllVideoStreams = (value) => {
        this.allVideoStreams.next(value);
    };
    updateNewLimitedStreams = (value) => {
        this.newLimitedStreams.next(value);
    };
    updateNewLimitedStreamsIDs = (value) => {
        this.newLimitedStreamsIDs.next(value);
    };
    updateActiveSounds = (value) => {
        this.activeSounds.next(value);
    };
    updateScreenShareIDStream = (value) => {
        this.screenShareIDStream.next(value);
    };
    updateScreenShareNameStream = (value) => {
        this.screenShareNameStream.next(value);
    };
    updateAdminIDStream = (value) => {
        this.adminIDStream.next(value);
    };
    updateAdminNameStream = (value) => {
        this.adminNameStream.next(value);
    };
    updateYouYouStream = (value) => {
        this.youYouStream.next(value);
    };
    updateYouYouStreamIDs = (value) => {
        this.youYouStreamIDs.next(value);
    };
    updateLocalStream = (value) => {
        this.localStream.next(value);
    };
    updateRecordStarted = (value) => {
        this.recordStarted.next(value);
    };
    updateRecordResumed = (value) => {
        this.recordResumed.next(value);
    };
    updateRecordPaused = (value) => {
        this.recordPaused.next(value);
    };
    updateRecordStopped = (value) => {
        this.recordStopped.next(value);
    };
    updateAdminRestrictSetting = (value) => {
        this.adminRestrictSetting.next(value);
    };
    updateVideoRequestState = (value) => {
        this.videoRequestState.next(value);
    };
    updateVideoRequestTime = (value) => {
        this.videoRequestTime.next(value);
    };
    updateVideoAction = (value) => {
        this.videoAction.next(value);
    };
    updateLocalStreamVideo = (value) => {
        this.localStreamVideo.next(value);
    };
    updateUserDefaultVideoInputDevice = (value) => {
        this.userDefaultVideoInputDevice.next(value);
    };
    updateCurrentFacingMode = (value) => {
        this.currentFacingMode.next(value);
    };
    updatePrevFacingMode = (value) => {
        this.prevFacingMode.next(value);
    };
    updateDefVideoID = (value) => {
        this.defVideoID.next(value);
    };
    updateAllowed = (value) => {
        this.allowed.next(value);
    };
    updateDispActiveNames = (value) => {
        this.dispActiveNames.next(value);
    };
    updateP_dispActiveNames = (value) => {
        this.p_dispActiveNames.next(value);
    };
    updateActiveNames = (value) => {
        this.activeNames.next(value);
    };
    updatePrevActiveNames = (value) => {
        this.prevActiveNames.next(value);
    };
    updateP_activeNames = (value) => {
        this.p_activeNames.next(value);
    };
    updateMembersReceived = (value) => {
        this.membersReceived.next(value);
    };
    updateDeferScreenReceived = (value) => {
        this.deferScreenReceived.next(value);
    };
    updateHostFirstSwitch = (value) => {
        this.hostFirstSwitch.next(value);
    };
    updateMicAction = (value) => {
        this.micAction.next(value);
    };
    updateScreenAction = (value) => {
        this.screenAction.next(value);
    };
    updateChatAction = (value) => {
        this.chatAction.next(value);
    };
    updateAudioRequestState = (value) => {
        this.audioRequestState.next(value);
    };
    updateScreenRequestState = (value) => {
        this.screenRequestState.next(value);
    };
    updateChatRequestState = (value) => {
        this.chatRequestState.next(value);
    };
    updateAudioRequestTime = (value) => {
        this.audioRequestTime.next(value);
    };
    updateScreenRequestTime = (value) => {
        this.screenRequestTime.next(value);
    };
    updateChatRequestTime = (value) => {
        this.chatRequestTime.next(value);
    };
    updateOldSoundIds = (value) => {
        this.oldSoundIds.next(value);
    };
    updateHostLabel = (value) => {
        this.hostLabel.next(value);
    };
    updateMainScreenFilled = (value) => {
        this.mainScreenFilled.next(value);
    };
    updateLocalStreamScreen = (value) => {
        this.localStreamScreen.next(value);
    };
    updateScreenAlreadyOn = (value) => {
        this.screenAlreadyOn.next(value);
    };
    updateChatAlreadyOn = (value) => {
        this.chatAlreadyOn.next(value);
    };
    updateRedirectURL = (value) => {
        this.redirectURL.next(value);
    };
    updateOldAllStreams = (value) => {
        this.oldAllStreams.next(value);
    };
    updateAdminVidID = (value) => {
        this.adminVidID.next(value);
    };
    updateStreamNames = (value) => {
        this.streamNames.next(value);
    };
    updateNon_alVideoStreams = (value) => {
        this.non_alVideoStreams.next(value);
    };
    updateSortAudioLoudness = (value) => {
        this.sortAudioLoudness.next(value);
    };
    updateAudioDecibels = (value) => {
        this.audioDecibels.next(value);
    };
    updateMixed_alVideoStreams = (value) => {
        this.mixed_alVideoStreams.next(value);
    };
    updateNon_alVideoStreams_muted = (value) => {
        this.non_alVideoStreams_muted.next(value);
    };
    updatePaginatedStreams = (value) => {
        this.paginatedStreams.next(value);
    };
    updateLocalStreamAudio = (value) => {
        this.localStreamAudio.next(value);
    };
    updateDefAudioID = (value) => {
        this.defAudioID.next(value);
    };
    updateUserDefaultAudioInputDevice = (value) => {
        this.userDefaultAudioInputDevice.next(value);
    };
    updateUserDefaultAudioOutputDevice = (value) => {
        this.userDefaultAudioOutputDevice.next(value);
    };
    updatePrevAudioInputDevice = (value) => {
        this.prevAudioInputDevice.next(value);
    };
    updatePrevVideoInputDevice = (value) => {
        this.prevVideoInputDevice.next(value);
    };
    updateAudioPaused = (value) => {
        this.audioPaused.next(value);
    };
    updateMainScreenPerson = (value) => {
        this.mainScreenPerson.next(value);
    };
    updateAdminOnMainScreen = (value) => {
        this.adminOnMainScreen.next(value);
    };
    updateScreenStates = (value) => {
        this.screenStates.next(value);
    };
    updatePrevScreenStates = (value) => {
        this.prevScreenStates.next(value);
    };
    updateUpdateDateState = (value) => {
        this.updateDateState.next(value);
    };
    updateLastUpdate = (value) => {
        this.lastUpdate.next(value);
    };
    updateNForReadjustRecord = (value) => {
        this.nForReadjustRecord.next(value);
    };
    updateFixedPageLimit = (value) => {
        this.fixedPageLimit.next(value);
    };
    updateRemoveAltGrid = (value) => {
        this.removeAltGrid.next(value);
    };
    updateNForReadjust = (value) => {
        this.nForReadjust.next(value);
    };
    updateLastReorderTime = (value) => {
        this.lastReorderTime.next(value);
    };
    updateAudStreamNames = (value) => {
        this.audStreamNames.next(value);
    };
    updateCurrentUserPage = (value) => {
        this.currentUserPage.next(value);
    };
    updateMainHeightWidth = (value) => {
        this.mainHeightWidth.next(value);
    };
    updatePrevMainHeightWidth = (value) => {
        this.prevMainHeightWidth.next(value);
    };
    updatePrevDoPaginate = (value) => {
        this.prevDoPaginate.next(value);
    };
    updateDoPaginate = (value) => {
        this.doPaginate.next(value);
    };
    updateShareEnded = (value) => {
        this.shareEnded.next(value);
    };
    updateLStreams = (value) => {
        this.lStreams.next(value);
    };
    updateChatRefStreams = (value) => {
        this.chatRefStreams.next(value);
    };
    updateControlHeight = (value) => {
        this.controlHeight.next(value);
    };
    updateIsWideScreen = (value) => {
        this.isWideScreen.next(value);
    };
    updateIsMediumScreen = (value) => {
        this.isMediumScreen.next(value);
    };
    updateIsSmallScreen = (value) => {
        this.isSmallScreen.next(value);
    };
    updateAddGrid = (value) => {
        this.addGrid.next(value);
    };
    updateAddAltGrid = (value) => {
        this.addAltGrid.next(value);
    };
    updateGridRows = (value) => {
        this.gridRows.next(value);
    };
    updateGridCols = (value) => {
        this.gridCols.next(value);
    };
    updateAltGridRows = (value) => {
        this.altGridRows.next(value);
    };
    updateAltGridCols = (value) => {
        this.altGridCols.next(value);
    };
    updateNumberPages = (value) => {
        this.numberPages.next(value);
    };
    updateCurrentStreams = (value) => {
        this.currentStreams.next(value);
    };
    updateShowMiniView = (value) => {
        this.showMiniView.next(value);
    };
    updateNStream = (value) => {
        this.nStream.next(value);
    };
    updateDefer_receive = (value) => {
        this.defer_receive.next(value);
    };
    updateAllAudioStreams = (value) => {
        this.allAudioStreams.next(value);
    };
    updateRemoteScreenStream = (value) => {
        this.remoteScreenStream.next(value);
    };
    updateScreenProducer = (value) => {
        this.screenProducer.next(value);
    };
    updateLocalScreenProducer = (value) => {
        this.localScreenProducer.next(value);
    };
    updateGotAllVids = (value) => {
        this.gotAllVids.next(value);
    };
    updatePaginationHeightWidth = (value) => {
        this.paginationHeightWidth.next(value);
    };
    updatePaginationDirection = (value) => {
        this.paginationDirection.next(value);
    };
    updateGridSizes = (value) => {
        this.gridSizes.next(value);
    };
    updateScreenForceFullDisplay = (value) => {
        this.screenForceFullDisplay.next(value);
    };
    updateMainGridStream = (value) => {
        this.mainGridStream.next(value);
    };
    updateOtherGridStreams = (value) => {
        this.otherGridStreams.next(value);
    };
    updateAudioOnlyStreams = (value) => {
        this.audioOnlyStreams.next(value);
    };
    updateVideoInputs = (value) => {
        this.videoInputs.next(value);
    };
    updateAudioInputs = (value) => {
        this.audioInputs.next(value);
    };
    updateMeetingProgressTime = (value) => {
        this.meetingProgressTime.next(value);
    };
    updateMeetingElapsedTime = (value) => {
        this.meetingElapsedTime.next(value);
    };
    updateRef_participants = (value) => {
        this.ref_participants.next(value);
    };
    // Messages
    messages = new BehaviorSubject$1([]);
    startDirectMessage = new BehaviorSubject$1(false);
    directMessageDetails = new BehaviorSubject$1(null);
    showMessagesBadge = new BehaviorSubject$1(false);
    // Event Settings
    audioSetting = new BehaviorSubject$1('allow');
    videoSetting = new BehaviorSubject$1('allow');
    screenshareSetting = new BehaviorSubject$1('allow');
    chatSetting = new BehaviorSubject$1('allow');
    // Display Settings
    displayOption = new BehaviorSubject$1('media');
    autoWave = new BehaviorSubject$1(true);
    forceFullDisplay = new BehaviorSubject$1(true);
    prevForceFullDisplay = new BehaviorSubject$1(false);
    prevMeetingDisplayType = new BehaviorSubject$1('video');
    // Waiting Room
    waitingRoomFilter = new BehaviorSubject$1('');
    waitingRoomList = new BehaviorSubject$1(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    waitingRoomCounter = new BehaviorSubject$1(0);
    filteredWaitingRoomList = new BehaviorSubject$1(this.useSeed && this.seedData?.waitingList ? this.seedData.waitingList : []);
    // Requests
    requestFilter = new BehaviorSubject$1('');
    requestList = new BehaviorSubject$1(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    requestCounter = new BehaviorSubject$1(0);
    filteredRequestList = new BehaviorSubject$1(this.useSeed && this.seedData?.requests ? this.seedData.requests : []);
    // Total Requests and Waiting Room
    totalReqWait = new BehaviorSubject$1(0);
    // Alerts
    alertVisible = new BehaviorSubject$1(false);
    alertMessage = new BehaviorSubject$1('');
    alertType = new BehaviorSubject$1('success');
    alertDuration = new BehaviorSubject$1(3000);
    // Progress Timer
    progressTimerVisible = new BehaviorSubject$1(true);
    progressTimerValue = new BehaviorSubject$1(0);
    // Menu Modals
    isMenuModalVisible = new BehaviorSubject$1(false);
    isRecordingModalVisible = new BehaviorSubject$1(false);
    isSettingsModalVisible = new BehaviorSubject$1(false);
    isRequestsModalVisible = new BehaviorSubject$1(false);
    isWaitingModalVisible = new BehaviorSubject$1(false);
    isCoHostModalVisible = new BehaviorSubject$1(false);
    isMediaSettingsModalVisible = new BehaviorSubject$1(false);
    isDisplaySettingsModalVisible = new BehaviorSubject$1(false);
    // Other Modals
    isParticipantsModalVisible = new BehaviorSubject$1(false);
    isMessagesModalVisible = new BehaviorSubject$1(false);
    isConfirmExitModalVisible = new BehaviorSubject$1(false);
    isConfirmHereModalVisible = new BehaviorSubject$1(false);
    isShareEventModalVisible = new BehaviorSubject$1(false);
    isLoadingModalVisible = new BehaviorSubject$1(false);
    // Recording Options
    recordingMediaOptions = new BehaviorSubject$1('video');
    recordingAudioOptions = new BehaviorSubject$1('all');
    recordingVideoOptions = new BehaviorSubject$1('all');
    recordingVideoType = new BehaviorSubject$1('fullDisplay');
    recordingVideoOptimized = new BehaviorSubject$1(false);
    recordingDisplayType = new BehaviorSubject$1('video');
    recordingAddHLS = new BehaviorSubject$1(true);
    recordingNameTags = new BehaviorSubject$1(true);
    recordingBackgroundColor = new BehaviorSubject$1('#83c0e9');
    recordingNameTagsColor = new BehaviorSubject$1('#ffffff');
    recordingAddText = new BehaviorSubject$1(false);
    recordingCustomText = new BehaviorSubject$1('Add Text');
    recordingCustomTextPosition = new BehaviorSubject$1('top');
    recordingCustomTextColor = new BehaviorSubject$1('#ffffff');
    recordingOrientationVideo = new BehaviorSubject$1('landscape');
    clearedToResume = new BehaviorSubject$1(true);
    clearedToRecord = new BehaviorSubject$1(true);
    recordState = new BehaviorSubject$1('green');
    showRecordButtons = new BehaviorSubject$1(false);
    recordingProgressTime = new BehaviorSubject$1('00:00:00');
    audioSwitching = new BehaviorSubject$1(false);
    videoSwitching = new BehaviorSubject$1(false);
    // Media States
    videoAlreadyOn = new BehaviorSubject$1(false);
    audioAlreadyOn = new BehaviorSubject$1(false);
    componentSizes = new BehaviorSubject$1({
        mainHeight: 0,
        otherHeight: 0,
        mainWidth: 0,
        otherWidth: 0,
    });
    // Permissions
    hasCameraPermission = new BehaviorSubject$1(false);
    hasAudioPermission = new BehaviorSubject$1(false);
    // Transports
    transportCreated = new BehaviorSubject$1(false);
    localTransportCreated = new BehaviorSubject$1(false);
    transportCreatedVideo = new BehaviorSubject$1(false);
    transportCreatedAudio = new BehaviorSubject$1(false);
    transportCreatedScreen = new BehaviorSubject$1(false);
    producerTransport = new BehaviorSubject$1(null);
    localProducerTransport = new BehaviorSubject$1(null);
    videoProducer = new BehaviorSubject$1(null);
    localVideoProducer = new BehaviorSubject$1(null);
    params = new BehaviorSubject$1({});
    videoParams = new BehaviorSubject$1({});
    audioParams = new BehaviorSubject$1({});
    audioProducer = new BehaviorSubject$1(null);
    audioLevel = new BehaviorSubject$1(0);
    localAudioProducer = new BehaviorSubject$1(null);
    consumerTransports = new BehaviorSubject$1([]);
    consumingTransports = new BehaviorSubject$1([]);
    // Polls
    polls = new BehaviorSubject$1(this.useSeed && this.seedData?.polls ? this.seedData.polls : []);
    poll = new BehaviorSubject$1(null);
    isPollModalVisible = new BehaviorSubject$1(false);
    // Background
    customImage = new BehaviorSubject$1('');
    selectedImage = new BehaviorSubject$1('');
    segmentVideo = new BehaviorSubject$1(null);
    selfieSegmentation = new BehaviorSubject$1(null);
    pauseSegmentation = new BehaviorSubject$1(false);
    processedStream = new BehaviorSubject$1(null);
    keepBackground = new BehaviorSubject$1(false);
    backgroundHasChanged = new BehaviorSubject$1(false);
    virtualStream = new BehaviorSubject$1(null);
    mainCanvas = new BehaviorSubject$1(null);
    prevKeepBackground = new BehaviorSubject$1(false);
    appliedBackground = new BehaviorSubject$1(false);
    isBackgroundModalVisible = new BehaviorSubject$1(false);
    autoClickBackground = new BehaviorSubject$1(false);
    // Breakout Rooms
    breakoutRooms = new BehaviorSubject$1(this.useSeed && this.seedData?.breakoutRooms ? this.seedData.breakoutRooms : []);
    currentRoomIndex = new BehaviorSubject$1(0);
    canStartBreakout = new BehaviorSubject$1(false);
    breakOutRoomStarted = new BehaviorSubject$1(false);
    breakOutRoomEnded = new BehaviorSubject$1(false);
    hostNewRoom = new BehaviorSubject$1(-1);
    limitedBreakRoom = new BehaviorSubject$1([]);
    mainRoomsLength = new BehaviorSubject$1(0);
    memberRoom = new BehaviorSubject$1(-1);
    isBreakoutRoomsModalVisible = new BehaviorSubject$1(false);
    // Whiteboard
    whiteboardUsers = new BehaviorSubject$1(this.useSeed && this.seedData?.whiteboardUsers ? this.seedData.whiteboardUsers : []);
    currentWhiteboardIndex = new BehaviorSubject$1(0);
    canStartWhiteboard = new BehaviorSubject$1(false);
    whiteboardStarted = new BehaviorSubject$1(false);
    whiteboardEnded = new BehaviorSubject$1(false);
    whiteboardLimit = new BehaviorSubject$1(4);
    isWhiteboardModalVisible = new BehaviorSubject$1(false);
    isConfigureWhiteboardModalVisible = new BehaviorSubject$1(false);
    shapes = new BehaviorSubject$1([]);
    useImageBackground = new BehaviorSubject$1(true);
    redoStack = new BehaviorSubject$1([]);
    undoStack = new BehaviorSubject$1([]);
    canvasStream = new BehaviorSubject$1(null);
    canvasWhiteboard = new BehaviorSubject$1(null);
    // Screenboard
    canvasScreenboard = new BehaviorSubject$1(null);
    processedScreenStream = new BehaviorSubject$1(null);
    annotateScreenStream = new BehaviorSubject$1(false);
    mainScreenCanvas = new BehaviorSubject$1(null);
    isScreenboardModalVisible = new BehaviorSubject$1(false);
    //state variables for the control buttons
    micActive = new BehaviorSubject$1(this.audioAlreadyOn.value ? this.audioAlreadyOn.value : false);
    videoActive = new BehaviorSubject$1(this.videoAlreadyOn.value ? this.videoAlreadyOn.value : false);
    screenShareActive = new BehaviorSubject$1(false);
    endCallActive = new BehaviorSubject$1(false);
    participantsActive = new BehaviorSubject$1(false);
    menuActive = new BehaviorSubject$1(false);
    commentsActive = new BehaviorSubject$1(false);
    // Update functions
    updateMessages = (value) => {
        this.messages.next(value);
    };
    updateStartDirectMessage = (value) => {
        this.startDirectMessage.next(value);
    };
    updateDirectMessageDetails = (value) => {
        this.directMessageDetails.next(value);
    };
    updateShowMessagesBadge = (value) => {
        this.showMessagesBadge.next(value);
    };
    updateAudioSetting = (value) => {
        this.audioSetting.next(value);
    };
    updateVideoSetting = (value) => {
        this.videoSetting.next(value);
    };
    updateScreenshareSetting = (value) => {
        this.screenshareSetting.next(value);
    };
    updateChatSetting = (value) => {
        this.chatSetting.next(value);
    };
    updateDisplayOption = (value) => {
        this.displayOption.next(value);
    };
    updateAutoWave = (value) => {
        this.autoWave.next(value);
    };
    updateForceFullDisplay = (value) => {
        this.forceFullDisplay.next(value);
    };
    updatePrevForceFullDisplay = (value) => {
        this.prevForceFullDisplay.next(value);
    };
    updatePrevMeetingDisplayType = (value) => {
        this.prevMeetingDisplayType.next(value);
    };
    updateWaitingRoomCounter = (value) => {
        this.waitingRoomCounter.next(value);
    };
    updateWaitingRoomFilter = (value) => {
        this.waitingRoomFilter.next(value);
    };
    updateWaitingRoomList = (value) => {
        this.waitingRoomList.next(value);
        this.filteredWaitingRoomList.next(value);
        this.waitingRoomCounter.next(value.length);
    };
    onWaitingRoomFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredWaitingRoom = this.waitingRoomList
                .getValue()
                .filter((waitingRoom) => {
                return waitingRoom.name.toLowerCase().includes(value.toLowerCase());
            });
            this.filteredWaitingRoomList.next(filteredWaitingRoom);
            this.waitingRoomCounter.next(filteredWaitingRoom.length);
        }
        else {
            this.filteredWaitingRoomList.next(this.waitingRoomList.getValue());
            this.waitingRoomCounter.next(this.waitingRoomList.getValue().length);
        }
    };
    onWaitingRoomClose = () => {
        this.updateIsWaitingModalVisible(false);
    };
    updateRequestCounter = (value) => {
        this.requestCounter.next(value);
    };
    updateRequestFilter = (value) => {
        this.requestFilter.next(value);
    };
    updateRequestList = (value) => {
        this.requestList.next(value);
        this.filteredRequestList.next(value);
        this.requestCounter.next(value.length);
    };
    onRequestFilterChange = (value) => {
        if (value !== '' && value.length > 0) {
            const filteredRequest = this.requestList.getValue().filter((request) => {
                return request?.name?.toLowerCase().includes(value.toLowerCase());
            });
            this.filteredRequestList.next(filteredRequest);
            this.requestCounter.next(filteredRequest.length);
        }
        else {
            this.filteredRequestList.next(this.requestList.getValue());
            this.requestCounter.next(this.requestList.getValue().length);
        }
    };
    onRequestClose = () => {
        this.updateIsRequestsModalVisible(false);
    };
    updateTotalReqWait = (value) => {
        this.totalReqWait.next(value);
    };
    updateAlertVisible = (value) => {
        this.alertVisible.next(value);
    };
    updateAlertMessage = (value) => {
        this.alertMessage.next(value);
    };
    updateAlertType = (value) => {
        this.alertType.next(value);
    };
    updateAlertDuration = (value) => {
        this.alertDuration.next(value);
    };
    updateProgressTimerVisible = (value) => {
        this.progressTimerVisible.next(value);
    };
    updateProgressTimerValue = (value) => {
        this.progressTimerValue.next(value);
    };
    updateIsMenuModalVisible = (value) => {
        this.isMenuModalVisible.next(value);
    };
    updateIsRecordingModalVisible = (value) => {
        this.isRecordingModalVisible.next(value);
        if (value) {
            this.updateConfirmedToRecord(false);
        }
        else {
            if (this.clearedToRecord.getValue() &&
                this.clearedToResume.getValue() &&
                this.recordStarted.getValue()) {
                this.updateShowRecordButtons(true);
            }
        }
    };
    updateIsSettingsModalVisible = (value) => {
        this.isSettingsModalVisible.next(value);
    };
    updateIsRequestsModalVisible = (value) => {
        this.isRequestsModalVisible.next(value);
    };
    updateIsWaitingModalVisible = (value) => {
        this.isWaitingModalVisible.next(value);
    };
    updateIsCoHostModalVisible = (value) => {
        this.isCoHostModalVisible.next(value);
    };
    updateIsMediaSettingsModalVisible = (value) => {
        this.isMediaSettingsModalVisible.next(value);
    };
    updateIsDisplaySettingsModalVisible = (value) => {
        this.isDisplaySettingsModalVisible.next(value);
    };
    updateIsParticipantsModalVisible = (value) => {
        this.isParticipantsModalVisible.next(value);
    };
    updateIsMessagesModalVisible = (value) => {
        this.isMessagesModalVisible.next(value);
        if (!value) {
            this.updateShowMessagesBadge(false);
        }
    };
    updateIsConfirmExitModalVisible = (value) => {
        this.isConfirmExitModalVisible.next(value);
    };
    updateIsConfirmHereModalVisible = (value) => {
        this.isConfirmHereModalVisible.next(value);
    };
    updateIsLoadingModalVisible = (value) => {
        this.isLoadingModalVisible.next(value);
    };
    updateIsShareEventModalVisible = (value) => {
        this.isShareEventModalVisible.next(value);
    };
    updateRecordingMediaOptions = (value) => {
        this.recordingMediaOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAudioOptions = (value) => {
        this.recordingAudioOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptions = (value) => {
        this.recordingVideoOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoType = (value) => {
        this.recordingVideoType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptimized = (value) => {
        this.recordingVideoOptimized.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingDisplayType = (value) => {
        this.recordingDisplayType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddHLS = (value) => {
        this.recordingAddHLS.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddText = (value) => {
        this.recordingAddText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomText = (value) => {
        this.recordingCustomText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextPosition = (value) => {
        this.recordingCustomTextPosition.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextColor = (value) => {
        this.recordingCustomTextColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTags = (value) => {
        this.recordingNameTags.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingBackgroundColor = (value) => {
        this.recordingBackgroundColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTagsColor = (value) => {
        this.recordingNameTagsColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingOrientationVideo = (value) => {
        this.recordingOrientationVideo.next(value);
        this.clearedToRecord.next(false);
    };
    updateClearedToResume = (value) => {
        this.clearedToResume.next(value);
    };
    updateClearedToRecord = (value) => {
        this.clearedToRecord.next(value);
    };
    updateRecordState = (value) => {
        if (this.recordStarted.value && !this.recordStopped.value) {
            if (!this.recordPaused.value) {
                this.recordState.next('red');
            }
            else {
                this.recordState.next('yellow');
            }
        }
        else {
            this.recordState.next(value);
        }
        this.recordState.next(value);
    };
    updateShowRecordButtons = (value) => {
        this.showRecordButtons.next(value);
    };
    updateRecordingProgressTime = (value) => {
        this.recordingProgressTime.next(value);
        this.updateRecordTimerWidget();
    };
    updateAudioSwitching = (value) => {
        this.audioSwitching.next(value);
    };
    updateVideoSwitching = (value) => {
        this.videoSwitching.next(value);
    };
    updateVideoAlreadyOn = (value) => {
        this.videoAlreadyOn.next(value);
        this.videoActive.next(value);
    };
    updateAudioAlreadyOn = (value) => {
        this.audioAlreadyOn.next(value);
        this.micActive.next(value);
    };
    updateComponentSizes = (sizes) => {
        this.componentSizes.next(sizes);
    };
    updateHasCameraPermission = (value) => {
        this.hasCameraPermission.next(value);
    };
    updateHasAudioPermission = (value) => {
        this.hasAudioPermission.next(value);
    };
    requestPermissionCamera() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    requestPermissionAudio() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    updateTransportCreated = (value) => {
        this.transportCreated.next(value);
    };
    updateLocalTransportCreated = (value) => {
        this.localTransportCreated.next(value);
    };
    updateTransportCreatedVideo = (value) => {
        this.transportCreatedVideo.next(value);
    };
    updateTransportCreatedAudio = (value) => {
        this.transportCreatedAudio.next(value);
    };
    updateTransportCreatedScreen = (value) => {
        this.transportCreatedScreen.next(value);
    };
    updateProducerTransport = (value) => {
        this.producerTransport.next(value);
    };
    updateLocalProducerTransport = (value) => {
        this.localProducerTransport.next(value);
    };
    updateVideoProducer = (value) => {
        this.videoProducer.next(value);
    };
    updateLocalVideoProducer = (value) => {
        this.localVideoProducer.next(value);
    };
    updateParams = (value) => {
        this.params.next(value);
    };
    updateVideoParams = (value) => {
        this.videoParams.next(value);
    };
    updateAudioParams = (value) => {
        this.audioParams.next(value);
    };
    updateAudioProducer = (value) => {
        this.audioProducer.next(value);
    };
    updateAudioLevel = (value) => {
        this.audioLevel.next(value);
    };
    updateLocalAudioProducer = (value) => {
        this.localAudioProducer.next(value);
    };
    updateConsumerTransports = (value) => {
        this.consumerTransports.next(value);
    };
    updateConsumingTransports = (value) => {
        this.consumingTransports.next(value);
    };
    updatePolls = (value) => {
        this.polls.next(value);
    };
    updatePoll = (value) => {
        this.poll.next(value);
    };
    updateIsPollModalVisible = (value) => {
        this.isPollModalVisible.next(value);
    };
    updateCustomImage = (value) => {
        this.customImage.next(value);
    };
    updateSelectedImage = (value) => {
        this.selectedImage.next(value);
    };
    updateSegmentVideo = (value) => {
        this.segmentVideo.next(value);
    };
    updateSelfieSegmentation = (value) => {
        this.selfieSegmentation.next(value);
    };
    updatePauseSegmentation = (value) => {
        this.pauseSegmentation.next(value);
    };
    updateProcessedStream = (value) => {
        this.processedStream.next(value);
    };
    updateKeepBackground = (value) => {
        this.keepBackground.next(value);
    };
    updateBackgroundHasChanged = (value) => {
        this.backgroundHasChanged.next(value);
    };
    updateVirtualStream = (value) => {
        this.virtualStream.next(value);
    };
    updateMainCanvas = (value) => {
        this.mainCanvas.next(value);
    };
    updatePrevKeepBackground = (value) => {
        this.prevKeepBackground.next(value);
    };
    updateAppliedBackground = (value) => {
        this.appliedBackground.next(value);
    };
    updateIsBackgroundModalVisible = (value) => {
        this.isBackgroundModalVisible.next(value);
    };
    updateAutoClickBackground = (value) => {
        this.autoClickBackground.next(value);
    };
    updateBreakoutRooms = (value) => {
        this.breakoutRooms.next(value);
    };
    updateCurrentRoomIndex = (value) => {
        this.currentRoomIndex.next(value);
    };
    updateCanStartBreakout = (value) => {
        this.canStartBreakout.next(value);
    };
    updateBreakOutRoomStarted = (value) => {
        this.breakOutRoomStarted.next(value);
    };
    updateBreakOutRoomEnded = (value) => {
        this.breakOutRoomEnded.next(value);
    };
    updateHostNewRoom = (value) => {
        this.hostNewRoom.next(value);
    };
    updateLimitedBreakRoom = (value) => {
        this.limitedBreakRoom.next(value);
    };
    updateMainRoomsLength = (value) => {
        this.mainRoomsLength.next(value);
    };
    updateMemberRoom = (value) => {
        this.memberRoom.next(value);
    };
    updateIsBreakoutRoomsModalVisible = (value) => {
        this.isBreakoutRoomsModalVisible.next(value);
    };
    updateWhiteboardUsers = (value) => {
        this.whiteboardUsers.next(value);
    };
    updateCurrentWhiteboardIndex = (value) => {
        this.currentWhiteboardIndex.next(value);
    };
    updateCanStartWhiteboard = (value) => {
        this.canStartWhiteboard.next(value);
    };
    updateWhiteboardStarted = (value) => {
        this.whiteboardStarted.next(value);
    };
    updateWhiteboardEnded = (value) => {
        this.whiteboardEnded.next(value);
    };
    updateWhiteboardLimit = (value) => {
        this.whiteboardLimit.next(value);
    };
    updateIsWhiteboardModalVisible = (value) => {
        this.isWhiteboardModalVisible.next(value);
    };
    updateIsConfigureWhiteboardModalVisible = (value) => {
        this.isConfigureWhiteboardModalVisible.next(value);
    };
    updateShapes = (value) => {
        this.shapes.next(value);
    };
    updateUseImageBackground = (value) => {
        this.useImageBackground.next(value);
    };
    updateRedoStack = (value) => {
        this.redoStack.next(value);
    };
    updateUndoStack = (value) => {
        this.undoStack.next(value);
    };
    updateCanvasStream = (value) => {
        this.canvasStream.next(value);
    };
    updateCanvasWhiteboard = (value) => {
        this.canvasWhiteboard.next(value);
    };
    updateCanvasScreenboard = (value) => {
        this.canvasScreenboard.next(value);
    };
    updateProcessedScreenStream = (value) => {
        this.processedScreenStream.next(value);
    };
    updateAnnotateScreenStream = (value) => {
        this.annotateScreenStream.next(value);
    };
    updateMainScreenCanvas = (value) => {
        this.mainScreenCanvas.next(value);
    };
    updateIsScreenboardModalVisible = (value) => {
        this.isScreenboardModalVisible.next(value);
    };
    checkOrientation = () => {
        const isPortrait = window.matchMedia('(orientation: portrait)').matches;
        return isPortrait ? 'portrait' : 'landscape';
    };
    showAlert = ({ message, type, duration = 3000, }) => {
        this.updateAlertMessage(message);
        this.updateAlertType(type);
        this.updateAlertDuration(duration);
        this.updateAlertVisible(true);
    };
    getAllParams() {
        return {
            localUIMode: this.localUIMode.value, // Local UI mode
            // Room Details
            roomName: this.roomName.value,
            member: this.member.value,
            adminPasscode: this.adminPasscode.value,
            youAreCoHost: this.youAreCoHost.value,
            youAreHost: this.youAreHost.value,
            islevel: this.islevel.value,
            confirmedToRecord: this.confirmedToRecord.value,
            meetingDisplayType: this.meetingDisplayType.value,
            meetingVideoOptimized: this.meetingVideoOptimized.value,
            eventType: this.eventType.value,
            participants: this.participants.value,
            filteredParticipants: this.filteredParticipants.value,
            participantsCounter: this.participantsCounter.value,
            participantsFilter: this.participantsFilter.value,
            // More room details - media
            consume_sockets: this.consume_sockets.value,
            rtpCapabilities: this.rtpCapabilities.value,
            roomRecvIPs: this.roomRecvIPs.value,
            meetingRoomParams: this.meetingRoomParams.value,
            itemPageLimit: this.itemPageLimit.value,
            audioOnlyRoom: this.audioOnlyRoom.value,
            addForBasic: this.addForBasic.value,
            screenPageLimit: this.screenPageLimit.value,
            shareScreenStarted: this.shareScreenStarted.value,
            shared: this.shared.value,
            targetOrientation: this.targetOrientation.value,
            targetResolution: this.targetResolution.value,
            targetResolutionHost: this.targetResolutionHost.value,
            vidCons: this.vidCons.value,
            frameRate: this.frameRate.value,
            hParams: this.hParams.value,
            vParams: this.vParams.value,
            screenParams: this.screenParams.value,
            aParams: this.aParams.value,
            // More room details - recording
            recordingAudioPausesLimit: this.recordingAudioPausesLimit.value,
            recordingAudioPausesCount: this.recordingAudioPausesCount.value,
            recordingAudioSupport: this.recordingAudioSupport.value,
            recordingAudioPeopleLimit: this.recordingAudioPeopleLimit.value,
            recordingAudioParticipantsTimeLimit: this.recordingAudioParticipantsTimeLimit.value,
            recordingVideoPausesCount: this.recordingVideoPausesCount.value,
            recordingVideoPausesLimit: this.recordingVideoPausesLimit.value,
            recordingVideoSupport: this.recordingVideoSupport.value,
            recordingVideoPeopleLimit: this.recordingVideoPeopleLimit.value,
            recordingVideoParticipantsTimeLimit: this.recordingVideoParticipantsTimeLimit.value,
            recordingAllParticipantsSupport: this.recordingAllParticipantsSupport.value,
            recordingVideoParticipantsSupport: this.recordingVideoParticipantsSupport.value,
            recordingAllParticipantsFullRoomSupport: this.recordingAllParticipantsFullRoomSupport.value,
            recordingVideoParticipantsFullRoomSupport: this.recordingVideoParticipantsFullRoomSupport.value,
            recordingPreferredOrientation: this.recordingPreferredOrientation.value,
            recordingSupportForOtherOrientation: this.recordingSupportForOtherOrientation.value,
            recordingMultiFormatsSupport: this.recordingMultiFormatsSupport.value,
            userRecordingParams: this.userRecordingParams.value,
            canRecord: this.canRecord.value,
            startReport: this.startReport.value,
            endReport: this.endReport.value,
            recordStartTime: this.recordStartTime.value,
            recordElapsedTime: this.recordElapsedTime.value,
            isTimerRunning: this.isTimerRunning.value,
            canPauseResume: this.canPauseResume.value,
            recordChangeSeconds: this.recordChangeSeconds.value,
            pauseLimit: this.pauseLimit.value,
            pauseRecordCount: this.pauseRecordCount.value,
            canLaunchRecord: this.canLaunchRecord.value,
            stopLaunchRecord: this.stopLaunchRecord.value,
            participantsAll: this.participantsAll.value,
            firstAll: this.firstAll.value,
            updateMainWindow: this.updateMainWindow.value,
            first_round: this.first_round.value,
            landScaped: this.landScaped.value,
            lock_screen: this.lock_screen.value,
            screenId: this.screenId.value,
            allVideoStreams: this.allVideoStreams.value,
            newLimitedStreams: this.newLimitedStreams.value,
            newLimitedStreamsIDs: this.newLimitedStreamsIDs.value,
            activeSounds: this.activeSounds.value,
            screenShareIDStream: this.screenShareIDStream.value,
            screenShareNameStream: this.screenShareNameStream.value,
            adminIDStream: this.adminIDStream.value,
            adminNameStream: this.adminNameStream.value,
            youYouStream: this.youYouStream.value,
            youYouStreamIDs: this.youYouStreamIDs.value,
            localStream: this.localStream.value,
            recordStarted: this.recordStarted.value,
            recordResumed: this.recordResumed.value,
            recordPaused: this.recordPaused.value,
            recordStopped: this.recordStopped.value,
            adminRestrictSetting: this.adminRestrictSetting.value,
            videoRequestState: this.videoRequestState.value,
            videoRequestTime: this.videoRequestTime.value,
            videoAction: this.videoAction.value,
            localStreamVideo: this.localStreamVideo.value,
            userDefaultVideoInputDevice: this.userDefaultVideoInputDevice.value,
            currentFacingMode: this.currentFacingMode.value,
            prevFacingMode: this.prevFacingMode.value,
            defVideoID: this.defVideoID.value,
            allowed: this.allowed.value,
            dispActiveNames: this.dispActiveNames.value,
            p_dispActiveNames: this.p_dispActiveNames.value,
            activeNames: this.activeNames.value,
            prevActiveNames: this.prevActiveNames.value,
            p_activeNames: this.p_activeNames.value,
            membersReceived: this.membersReceived.value,
            deferScreenReceived: this.deferScreenReceived.value,
            hostFirstSwitch: this.hostFirstSwitch.value,
            micAction: this.micAction.value,
            screenAction: this.screenAction.value,
            chatAction: this.chatAction.value,
            audioRequestState: this.audioRequestState.value,
            screenRequestState: this.screenRequestState.value,
            chatRequestState: this.chatRequestState.value,
            audioRequestTime: this.audioRequestTime.value,
            screenRequestTime: this.screenRequestTime.value,
            chatRequestTime: this.chatRequestTime.value,
            updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
            oldSoundIds: this.oldSoundIds.value,
            hostLabel: this.hostLabel.value,
            mainScreenFilled: this.mainScreenFilled.value,
            localStreamScreen: this.localStreamScreen.value,
            screenAlreadyOn: this.screenAlreadyOn.value,
            chatAlreadyOn: this.chatAlreadyOn.value,
            redirectURL: this.redirectURL.value,
            oldAllStreams: this.oldAllStreams.value,
            adminVidID: this.adminVidID.value,
            streamNames: this.streamNames.value,
            non_alVideoStreams: this.non_alVideoStreams.value,
            sortAudioLoudness: this.sortAudioLoudness.value,
            audioDecibels: this.audioDecibels.value,
            mixed_alVideoStreams: this.mixed_alVideoStreams.value,
            non_alVideoStreams_muted: this.non_alVideoStreams_muted.value,
            paginatedStreams: this.paginatedStreams.value,
            localStreamAudio: this.localStreamAudio.value,
            defAudioID: this.defAudioID.value,
            userDefaultAudioInputDevice: this.userDefaultAudioInputDevice.value,
            userDefaultAudioOutputDevice: this.userDefaultAudioOutputDevice.value,
            prevAudioInputDevice: this.prevAudioInputDevice.value,
            prevVideoInputDevice: this.prevVideoInputDevice.value,
            audioPaused: this.audioPaused.value,
            mainScreenPerson: this.mainScreenPerson.value,
            adminOnMainScreen: this.adminOnMainScreen.value,
            screenStates: this.screenStates.value,
            prevScreenStates: this.prevScreenStates.value,
            updateDateState: this.updateDateState.value,
            lastUpdate: this.lastUpdate.value,
            nForReadjustRecord: this.nForReadjustRecord.value,
            fixedPageLimit: this.fixedPageLimit.value,
            removeAltGrid: this.removeAltGrid.value,
            nForReadjust: this.nForReadjust.value,
            lastReorderTime: this.lastReorderTime.value,
            reorderInterval: this.reorderInterval.value,
            fastReorderInterval: this.fastReorderInterval.value,
            audStreamNames: this.audStreamNames.value,
            currentUserPage: this.currentUserPage.value,
            mainHeightWidth: this.mainHeightWidth.value,
            prevMainHeightWidth: this.prevMainHeightWidth.value,
            prevDoPaginate: this.prevDoPaginate.value,
            doPaginate: this.doPaginate.value,
            shareEnded: this.shareEnded.value,
            lStreams: this.lStreams.value,
            chatRefStreams: this.chatRefStreams.value,
            controlHeight: this.controlHeight.value,
            isWideScreen: this.isWideScreen.value,
            isMediumScreen: this.isMediumScreen.value,
            isSmallScreen: this.isSmallScreen.value,
            addGrid: this.addGrid.value,
            addAltGrid: this.addAltGrid.value,
            gridRows: this.gridRows.value,
            gridCols: this.gridCols.value,
            altGridRows: this.altGridRows.value,
            altGridCols: this.altGridCols.value,
            numberPages: this.numberPages.value,
            currentStreams: this.currentStreams.value,
            showMiniView: this.showMiniView.value,
            nStream: this.nStream.value,
            defer_receive: this.defer_receive.value,
            allAudioStreams: this.allAudioStreams.value,
            screenProducer: this.screenProducer.value,
            remoteScreenStream: this.remoteScreenStream.value,
            gotAllVids: this.gotAllVids.value,
            paginationHeightWidth: this.paginationHeightWidth.value,
            paginationDirection: this.paginationDirection.value,
            gridSizes: this.gridSizes.value,
            screenForceFullDisplay: this.screenForceFullDisplay.value,
            mainGridStream: this.mainGridStream.value,
            otherGridStreams: this.otherGridStreams.value,
            audioOnlyStreams: this.audioOnlyStreams.value,
            videoInputs: this.videoInputs.value,
            audioInputs: this.audioInputs.value,
            meetingProgressTime: this.meetingProgressTime.value,
            meetingElapsedTime: this.meetingElapsedTime.value,
            ref_participants: this.ref_participants.value,
            messages: this.messages.value,
            startDirectMessage: this.startDirectMessage.value,
            directMessageDetails: this.directMessageDetails.value,
            coHost: this.coHost.value,
            coHostResponsibility: this.coHostResponsibility.value,
            // Event settings
            audioSetting: this.audioSetting.value,
            videoSetting: this.videoSetting.value,
            screenshareSetting: this.screenshareSetting.value,
            chatSetting: this.chatSetting.value,
            // Display settings
            autoWave: this.autoWave.value,
            forceFullDisplay: this.forceFullDisplay.value,
            prevForceFullDisplay: this.prevForceFullDisplay.value,
            prevMeetingDisplayType: this.prevMeetingDisplayType.value,
            // Waiting room
            waitingRoomFilter: this.waitingRoomFilter.value,
            waitingRoomList: this.waitingRoomList.value,
            waitingRoomCounter: this.waitingRoomCounter.value,
            filteredWaitingRoomList: this.filteredWaitingRoomList.value,
            // Requests
            requestFilter: this.requestFilter.value,
            requestList: this.requestList.value,
            requestCounter: this.requestCounter.value,
            filteredRequestList: this.filteredRequestList.value,
            // Total requests and waiting room
            totalReqWait: this.totalReqWait.value,
            // Alerts
            alertVisible: this.alertVisible.value,
            alertMessage: this.alertMessage.value,
            alertType: this.alertType.value,
            alertDuration: this.alertDuration.value,
            // Progress Timer
            progressTimerVisible: this.progressTimerVisible.value,
            progressTimerValue: this.progressTimerValue.value,
            // Menu modals
            isMenuModalVisible: this.isMenuModalVisible.value,
            isRecordingModalVisible: this.isRecordingModalVisible.value,
            isSettingsModalVisible: this.isSettingsModalVisible.value,
            isRequestsModalVisible: this.isRequestsModalVisible.value,
            isWaitingModalVisible: this.isWaitingModalVisible.value,
            isCoHostModalVisible: this.isCoHostModalVisible.value,
            isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
            isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            // Other Modals
            isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            isMessagesModalVisible: this.isMessagesModalVisible.value,
            isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            isConfirmHereModalVisible: this.isConfirmHereModalVisible.value,
            isLoadingModalVisible: this.isLoadingModalVisible.value,
            // Recording Options
            recordingMediaOptions: this.recordingMediaOptions.value,
            recordingAudioOptions: this.recordingAudioOptions.value,
            recordingVideoOptions: this.recordingVideoOptions.value,
            recordingVideoType: this.recordingVideoType.value,
            recordingVideoOptimized: this.recordingVideoOptimized.value,
            recordingDisplayType: this.recordingDisplayType.value,
            recordingAddHLS: this.recordingAddHLS.value,
            recordingAddText: this.recordingAddText.value,
            recordingCustomText: this.recordingCustomText.value,
            recordingCustomTextPosition: this.recordingCustomTextPosition.value,
            recordingCustomTextColor: this.recordingCustomTextColor.value,
            recordingNameTags: this.recordingNameTags.value,
            recordingBackgroundColor: this.recordingBackgroundColor.value,
            recordingNameTagsColor: this.recordingNameTagsColor.value,
            recordingOrientationVideo: this.recordingOrientationVideo.value,
            clearedToResume: this.clearedToResume.value,
            clearedToRecord: this.clearedToRecord.value,
            recordState: this.recordState.value,
            showRecordButtons: this.showRecordButtons.value,
            recordingProgressTime: this.recordingProgressTime.value,
            audioSwitching: this.audioSwitching.value,
            videoSwitching: this.videoSwitching.value,
            // Media states
            videoAlreadyOn: this.videoAlreadyOn.value,
            audioAlreadyOn: this.audioAlreadyOn.value,
            componentSizes: this.componentSizes.value,
            // Permissions
            hasCameraPermission: this.hasCameraPermission.value,
            hasAudioPermission: this.hasAudioPermission.value,
            // Transports
            transportCreated: this.transportCreated.value,
            localTransportCreated: this.localTransportCreated.value,
            transportCreatedVideo: this.transportCreatedVideo.value,
            transportCreatedAudio: this.transportCreatedAudio.value,
            transportCreatedScreen: this.transportCreatedScreen.value,
            producerTransport: this.producerTransport.value,
            localProducerTransport: this.localProducerTransport.value,
            videoProducer: this.videoProducer.value,
            localVideoProducer: this.localVideoProducer.value,
            params: this.params.value,
            videoParams: this.videoParams.value,
            audioParams: this.audioParams.value,
            audioProducer: this.audioProducer.value,
            audioLevel: this.audioLevel.value,
            localAudioProducer: this.localAudioProducer.value,
            consumerTransports: this.consumerTransports.value,
            consumingTransports: this.consumingTransports.value,
            // Polls
            polls: this.polls.value,
            poll: this.poll.value,
            isPollModalVisible: this.isPollModalVisible.value,
            // Background
            customImage: this.customImage.value,
            selectedImage: this.selectedImage.value,
            segmentVideo: this.segmentVideo.value,
            selfieSegmentation: this.selfieSegmentation.value,
            pauseSegmentation: this.pauseSegmentation.value,
            processedStream: this.processedStream.value,
            keepBackground: this.keepBackground.value,
            backgroundHasChanged: this.backgroundHasChanged.value,
            virtualStream: this.virtualStream.value,
            mainCanvas: this.mainCanvas.value,
            prevKeepBackground: this.prevKeepBackground.value,
            appliedBackground: this.appliedBackground.value,
            isBackgroundModalVisible: this.isBackgroundModalVisible.value,
            autoClickBackground: this.autoClickBackground.value,
            // Breakout rooms
            breakoutRooms: this.breakoutRooms.value,
            currentRoomIndex: this.currentRoomIndex.value,
            canStartBreakout: this.canStartBreakout.value,
            breakOutRoomStarted: this.breakOutRoomStarted.value,
            breakOutRoomEnded: this.breakOutRoomEnded.value,
            hostNewRoom: this.hostNewRoom.value,
            limitedBreakRoom: this.limitedBreakRoom.value,
            mainRoomsLength: this.mainRoomsLength.value,
            memberRoom: this.memberRoom.value,
            isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            // Whiteboard
            whiteboardUsers: this.whiteboardUsers.value,
            currentWhiteboardIndex: this.currentWhiteboardIndex.value,
            canStartWhiteboard: this.canStartWhiteboard.value,
            whiteboardStarted: this.whiteboardStarted.value,
            whiteboardEnded: this.whiteboardEnded.value,
            whiteboardLimit: this.whiteboardLimit.value,
            isWhiteboardModalVisible: this.isWhiteboardModalVisible.value,
            isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            shapes: this.shapes.value,
            useImageBackground: this.useImageBackground.value,
            redoStack: this.redoStack.value,
            undoStack: this.undoStack.value,
            canvasStream: this.canvasStream.value,
            canvasWhiteboard: this.canvasWhiteboard.value,
            // Screenboard
            canvasScreenboard: this.canvasScreenboard.value,
            processedScreenStream: this.processedScreenStream.value,
            annotateScreenStream: this.annotateScreenStream.value,
            mainScreenCanvas: this.mainScreenCanvas.value,
            isScreenboardModalVisible: this.isScreenboardModalVisible.value,
            validated: this.validated.value,
            device: this.device.value,
            socket: this.socket.value,
            localSocket: this.localSocket.value,
            checkMediaPermission: false,
            onWeb: true,
            // Update functions
            updateRoomName: this.updateRoomName.bind(this),
            updateMember: this.updateMember.bind(this),
            updateAdminPasscode: this.updateAdminPasscode.bind(this),
            updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
            updateYouAreHost: this.updateYouAreHost.bind(this),
            updateIslevel: this.updateIslevel.bind(this),
            updateCoHost: this.updateCoHost.bind(this),
            updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
            updateConfirmedToRecord: this.updateConfirmedToRecord.bind(this),
            updateMeetingDisplayType: this.updateMeetingDisplayType.bind(this),
            updateMeetingVideoOptimized: this.updateMeetingVideoOptimized.bind(this),
            updateEventType: this.updateEventType.bind(this),
            updateParticipants: this.updateParticipants.bind(this),
            updateParticipantsCounter: this.updateParticipantsCounter.bind(this),
            updateParticipantsFilter: this.updateParticipantsFilter.bind(this),
            // More update functions for media details
            updateConsume_sockets: this.updateConsume_sockets.bind(this),
            updateRtpCapabilities: this.updateRtpCapabilities.bind(this),
            updateRoomRecvIPs: this.updateRoomRecvIPs.bind(this),
            updateMeetingRoomParams: this.updateMeetingRoomParams.bind(this),
            updateItemPageLimit: this.updateItemPageLimit.bind(this),
            updateAudioOnlyRoom: this.updateAudioOnlyRoom.bind(this),
            updateAddForBasic: this.updateAddForBasic.bind(this),
            updateScreenPageLimit: this.updateScreenPageLimit.bind(this),
            updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
            updateShared: this.updateShared.bind(this),
            updateTargetOrientation: this.updateTargetOrientation.bind(this),
            updateTargetResolution: this.updateTargetResolution.bind(this),
            updateTargetResolutionHost: this.updateTargetResolutionHost.bind(this),
            updateVidCons: this.updateVidCons.bind(this),
            updateFrameRate: this.updateFrameRate.bind(this),
            updateHParams: this.updateHParams.bind(this),
            updateVParams: this.updateVParams.bind(this),
            updateScreenParams: this.updateScreenParams.bind(this),
            updateAParams: this.updateAParams.bind(this),
            // More update functions for recording details
            updateRecordingAudioPausesLimit: this.updateRecordingAudioPausesLimit.bind(this),
            updateRecordingAudioPausesCount: this.updateRecordingAudioPausesCount.bind(this),
            updateRecordingAudioSupport: this.updateRecordingAudioSupport.bind(this),
            updateRecordingAudioPeopleLimit: this.updateRecordingAudioPeopleLimit.bind(this),
            updateRecordingAudioParticipantsTimeLimit: this.updateRecordingAudioParticipantsTimeLimit.bind(this),
            updateRecordingVideoPausesCount: this.updateRecordingVideoPausesCount.bind(this),
            updateRecordingVideoPausesLimit: this.updateRecordingVideoPausesLimit.bind(this),
            updateRecordingVideoSupport: this.updateRecordingVideoSupport.bind(this),
            updateRecordingVideoPeopleLimit: this.updateRecordingVideoPeopleLimit.bind(this),
            updateRecordingVideoParticipantsTimeLimit: this.updateRecordingVideoParticipantsTimeLimit.bind(this),
            updateRecordingAllParticipantsSupport: this.updateRecordingAllParticipantsSupport.bind(this),
            updateRecordingVideoParticipantsSupport: this.updateRecordingVideoParticipantsSupport.bind(this),
            updateRecordingAllParticipantsFullRoomSupport: this.updateRecordingAllParticipantsFullRoomSupport.bind(this),
            updateRecordingVideoParticipantsFullRoomSupport: this.updateRecordingVideoParticipantsFullRoomSupport.bind(this),
            updateRecordingPreferredOrientation: this.updateRecordingPreferredOrientation.bind(this),
            updateRecordingSupportForOtherOrientation: this.updateRecordingSupportForOtherOrientation.bind(this),
            updateRecordingMultiFormatsSupport: this.updateRecordingMultiFormatsSupport.bind(this),
            updateUserRecordingParams: this.updateUserRecordingParams.bind(this),
            updateCanRecord: this.updateCanRecord.bind(this),
            updateStartReport: this.updateStartReport.bind(this),
            updateEndReport: this.updateEndReport.bind(this),
            updateRecordTimerInterval: this.updateRecordTimerInterval.bind(this),
            updateRecordStartTime: this.updateRecordStartTime.bind(this),
            updateRecordElapsedTime: this.updateRecordElapsedTime.bind(this),
            updateIsTimerRunning: this.updateIsTimerRunning.bind(this),
            updateCanPauseResume: this.updateCanPauseResume.bind(this),
            updateRecordChangeSeconds: this.updateRecordChangeSeconds.bind(this),
            updatePauseLimit: this.updatePauseLimit.bind(this),
            updatePauseRecordCount: this.updatePauseRecordCount.bind(this),
            updateCanLaunchRecord: this.updateCanLaunchRecord.bind(this),
            updateStopLaunchRecord: this.updateStopLaunchRecord.bind(this),
            updateParticipantsAll: this.updateParticipantsAll.bind(this),
            updateFirstAll: this.updateFirstAll.bind(this),
            updateUpdateMainWindow: this.updateUpdateMainWindow.bind(this),
            updateFirst_round: this.updateFirst_round.bind(this),
            updateLandScaped: this.updateLandScaped.bind(this),
            updateLock_screen: this.updateLock_screen.bind(this),
            updateScreenId: this.updateScreenId.bind(this),
            updateAllVideoStreams: this.updateAllVideoStreams.bind(this),
            updateNewLimitedStreams: this.updateNewLimitedStreams.bind(this),
            updateNewLimitedStreamsIDs: this.updateNewLimitedStreamsIDs.bind(this),
            updateActiveSounds: this.updateActiveSounds.bind(this),
            updateScreenShareIDStream: this.updateScreenShareIDStream.bind(this),
            updateScreenShareNameStream: this.updateScreenShareNameStream.bind(this),
            updateAdminIDStream: this.updateAdminIDStream.bind(this),
            updateAdminNameStream: this.updateAdminNameStream.bind(this),
            updateYouYouStream: this.updateYouYouStream.bind(this),
            updateYouYouStreamIDs: this.updateYouYouStreamIDs.bind(this),
            updateLocalStream: this.updateLocalStream.bind(this),
            updateRecordStarted: this.updateRecordStarted.bind(this),
            updateRecordResumed: this.updateRecordResumed.bind(this),
            updateRecordPaused: this.updateRecordPaused.bind(this),
            updateRecordStopped: this.updateRecordStopped.bind(this),
            updateAdminRestrictSetting: this.updateAdminRestrictSetting.bind(this),
            updateVideoRequestState: this.updateVideoRequestState.bind(this),
            updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
            updateVideoAction: this.updateVideoAction.bind(this),
            updateLocalStreamVideo: this.updateLocalStreamVideo.bind(this),
            updateUserDefaultVideoInputDevice: this.updateUserDefaultVideoInputDevice.bind(this),
            updateCurrentFacingMode: this.updateCurrentFacingMode.bind(this),
            updatePrevFacingMode: this.updatePrevFacingMode.bind(this),
            updateDefVideoID: this.updateDefVideoID.bind(this),
            updateAllowed: this.updateAllowed.bind(this),
            updateDispActiveNames: this.updateDispActiveNames.bind(this),
            updateP_dispActiveNames: this.updateP_dispActiveNames.bind(this),
            updateActiveNames: this.updateActiveNames.bind(this),
            updatePrevActiveNames: this.updatePrevActiveNames.bind(this),
            updateP_activeNames: this.updateP_activeNames.bind(this),
            updateMembersReceived: this.updateMembersReceived.bind(this),
            updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
            updateHostFirstSwitch: this.updateHostFirstSwitch.bind(this),
            updateMicAction: this.updateMicAction.bind(this),
            updateScreenAction: this.updateScreenAction.bind(this),
            updateChatAction: this.updateChatAction.bind(this),
            updateAudioRequestState: this.updateAudioRequestState.bind(this),
            updateScreenRequestState: this.updateScreenRequestState.bind(this),
            updateChatRequestState: this.updateChatRequestState.bind(this),
            updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
            updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
            updateChatRequestTime: this.updateChatRequestTime.bind(this),
            updateOldSoundIds: this.updateOldSoundIds.bind(this),
            updateHostLabel: this.updateHostLabel.bind(this),
            updateMainScreenFilled: this.updateMainScreenFilled.bind(this),
            updateLocalStreamScreen: this.updateLocalStreamScreen.bind(this),
            updateScreenAlreadyOn: this.updateScreenAlreadyOn.bind(this),
            updateChatAlreadyOn: this.updateChatAlreadyOn.bind(this),
            updateRedirectURL: this.updateRedirectURL.bind(this),
            updateOldAllStreams: this.updateOldAllStreams.bind(this),
            updateAdminVidID: this.updateAdminVidID.bind(this),
            updateStreamNames: this.updateStreamNames.bind(this),
            updateNon_alVideoStreams: this.updateNon_alVideoStreams.bind(this),
            updateSortAudioLoudness: this.updateSortAudioLoudness.bind(this),
            updateAudioDecibels: this.updateAudioDecibels.bind(this),
            updateMixed_alVideoStreams: this.updateMixed_alVideoStreams.bind(this),
            updateNon_alVideoStreams_muted: this.updateNon_alVideoStreams_muted.bind(this),
            updatePaginatedStreams: this.updatePaginatedStreams.bind(this),
            updateLocalStreamAudio: this.updateLocalStreamAudio.bind(this),
            updateDefAudioID: this.updateDefAudioID.bind(this),
            updateUserDefaultAudioInputDevice: this.updateUserDefaultAudioInputDevice.bind(this),
            updateUserDefaultAudioOutputDevice: this.updateUserDefaultAudioOutputDevice.bind(this),
            updatePrevAudioInputDevice: this.updatePrevAudioInputDevice.bind(this),
            updatePrevVideoInputDevice: this.updatePrevVideoInputDevice.bind(this),
            updateAudioPaused: this.updateAudioPaused.bind(this),
            updateMainScreenPerson: this.updateMainScreenPerson.bind(this),
            updateAdminOnMainScreen: this.updateAdminOnMainScreen.bind(this),
            updateScreenStates: this.updateScreenStates.bind(this),
            updatePrevScreenStates: this.updatePrevScreenStates.bind(this),
            updateUpdateDateState: this.updateUpdateDateState.bind(this),
            updateLastUpdate: this.updateLastUpdate.bind(this),
            updateNForReadjustRecord: this.updateNForReadjustRecord.bind(this),
            updateFixedPageLimit: this.updateFixedPageLimit.bind(this),
            updateRemoveAltGrid: this.updateRemoveAltGrid.bind(this),
            updateNForReadjust: this.updateNForReadjust.bind(this),
            updateLastReorderTime: this.updateLastReorderTime.bind(this),
            updateAudStreamNames: this.updateAudStreamNames.bind(this),
            updateCurrentUserPage: this.updateCurrentUserPage.bind(this),
            updateMainHeightWidth: this.updateMainHeightWidth.bind(this),
            updatePrevMainHeightWidth: this.updatePrevMainHeightWidth.bind(this),
            updatePrevDoPaginate: this.updatePrevDoPaginate.bind(this),
            updateDoPaginate: this.updateDoPaginate.bind(this),
            updateShareEnded: this.updateShareEnded.bind(this),
            updateLStreams: this.updateLStreams.bind(this),
            updateChatRefStreams: this.updateChatRefStreams.bind(this),
            updateControlHeight: this.updateControlHeight.bind(this),
            updateIsWideScreen: this.updateIsWideScreen.bind(this),
            updateIsMediumScreen: this.updateIsMediumScreen.bind(this),
            updateIsSmallScreen: this.updateIsSmallScreen.bind(this),
            updateAddGrid: this.updateAddGrid.bind(this),
            updateAddAltGrid: this.updateAddAltGrid.bind(this),
            updateGridRows: this.updateGridRows.bind(this),
            updateGridCols: this.updateGridCols.bind(this),
            updateAltGridRows: this.updateAltGridRows.bind(this),
            updateAltGridCols: this.updateAltGridCols.bind(this),
            updateNumberPages: this.updateNumberPages.bind(this),
            updateCurrentStreams: this.updateCurrentStreams.bind(this),
            updateShowMiniView: this.updateShowMiniView.bind(this),
            updateNStream: this.updateNStream.bind(this),
            updateDefer_receive: this.updateDefer_receive.bind(this),
            updateAllAudioStreams: this.updateAllAudioStreams.bind(this),
            updateRemoteScreenStream: this.updateRemoteScreenStream.bind(this),
            updateScreenProducer: this.updateScreenProducer.bind(this),
            updateGotAllVids: this.updateGotAllVids.bind(this),
            updatePaginationHeightWidth: this.updatePaginationHeightWidth.bind(this),
            updatePaginationDirection: this.updatePaginationDirection.bind(this),
            updateGridSizes: this.updateGridSizes.bind(this),
            updateScreenForceFullDisplay: this.updateScreenForceFullDisplay.bind(this),
            updateMainGridStream: this.updateMainGridStream.bind(this),
            updateOtherGridStreams: this.updateOtherGridStreams.bind(this),
            updateAudioOnlyStreams: this.updateAudioOnlyStreams.bind(this),
            updateVideoInputs: this.updateVideoInputs.bind(this),
            updateAudioInputs: this.updateAudioInputs.bind(this),
            updateMeetingProgressTime: this.updateMeetingProgressTime.bind(this),
            updateMeetingElapsedTime: this.updateMeetingElapsedTime.bind(this),
            updateRef_participants: this.updateRef_participants.bind(this),
            updateMessages: this.updateMessages.bind(this),
            updateStartDirectMessage: this.updateStartDirectMessage.bind(this),
            updateDirectMessageDetails: this.updateDirectMessageDetails.bind(this),
            updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
            // Event settings
            updateAudioSetting: this.updateAudioSetting.bind(this),
            updateVideoSetting: this.updateVideoSetting.bind(this),
            updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
            updateChatSetting: this.updateChatSetting.bind(this),
            // Display settings
            updateAutoWave: this.updateAutoWave.bind(this),
            updateForceFullDisplay: this.updateForceFullDisplay.bind(this),
            updatePrevForceFullDisplay: this.updatePrevForceFullDisplay.bind(this),
            updatePrevMeetingDisplayType: this.updatePrevMeetingDisplayType.bind(this),
            // Waiting room
            updateWaitingRoomFilter: this.updateWaitingRoomFilter.bind(this),
            updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
            updateWaitingRoomCounter: this.updateWaitingRoomCounter.bind(this),
            // Requests
            updateRequestFilter: this.updateRequestFilter.bind(this),
            updateRequestList: this.updateRequestList.bind(this),
            updateRequestCounter: this.updateRequestCounter.bind(this),
            // Total requests and waiting room
            updateTotalReqWait: this.updateTotalReqWait.bind(this),
            // Menu modals
            updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
            updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
            updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
            updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
            updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
            updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
            // Other modals
            updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
            updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
            updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
            updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
            updateIsLoadingModalVisible: this.updateIsLoadingModalVisible.bind(this),
            // Recording Options
            updateRecordingMediaOptions: this.updateRecordingMediaOptions.bind(this),
            updateRecordingAudioOptions: this.updateRecordingAudioOptions.bind(this),
            updateRecordingVideoOptions: this.updateRecordingVideoOptions.bind(this),
            updateRecordingVideoType: this.updateRecordingVideoType.bind(this),
            updateRecordingVideoOptimized: this.updateRecordingVideoOptimized.bind(this),
            updateRecordingDisplayType: this.updateRecordingDisplayType.bind(this),
            updateRecordingAddHLS: this.updateRecordingAddHLS.bind(this),
            updateRecordingAddText: this.updateRecordingAddText.bind(this),
            updateRecordingCustomText: this.updateRecordingCustomText.bind(this),
            updateRecordingCustomTextPosition: this.updateRecordingCustomTextPosition.bind(this),
            updateRecordingCustomTextColor: this.updateRecordingCustomTextColor.bind(this),
            updateRecordingNameTags: this.updateRecordingNameTags.bind(this),
            updateRecordingBackgroundColor: this.updateRecordingBackgroundColor.bind(this),
            updateRecordingNameTagsColor: this.updateRecordingNameTagsColor.bind(this),
            updateRecordingOrientationVideo: this.updateRecordingOrientationVideo.bind(this),
            updateClearedToResume: this.updateClearedToResume.bind(this),
            updateClearedToRecord: this.updateClearedToRecord.bind(this),
            updateRecordState: this.updateRecordState.bind(this),
            updateShowRecordButtons: this.updateShowRecordButtons.bind(this),
            updateRecordingProgressTime: this.updateRecordingProgressTime.bind(this),
            updateAudioSwitching: this.updateAudioSwitching.bind(this),
            updateVideoSwitching: this.updateVideoSwitching.bind(this),
            // Media states
            updateVideoAlreadyOn: this.updateVideoAlreadyOn.bind(this),
            updateAudioAlreadyOn: this.updateAudioAlreadyOn.bind(this),
            updateComponentSizes: this.updateComponentSizes.bind(this),
            // Permissions
            updateHasCameraPermission: this.updateHasCameraPermission.bind(this),
            updateHasAudioPermission: this.updateHasAudioPermission.bind(this),
            // Transports
            updateTransportCreated: this.updateTransportCreated.bind(this),
            updateLocalTransportCreated: this.updateLocalTransportCreated.bind(this),
            updateTransportCreatedVideo: this.updateTransportCreatedVideo.bind(this),
            updateTransportCreatedAudio: this.updateTransportCreatedAudio.bind(this),
            updateTransportCreatedScreen: this.updateTransportCreatedScreen.bind(this),
            updateProducerTransport: this.updateProducerTransport.bind(this),
            updateLocalProducerTransport: this.updateLocalProducerTransport.bind(this),
            updateVideoProducer: this.updateVideoProducer.bind(this),
            updateLocalVideoProducer: this.updateLocalVideoProducer.bind(this),
            updateParams: this.updateParams.bind(this),
            updateVideoParams: this.updateVideoParams.bind(this),
            updateAudioParams: this.updateAudioParams.bind(this),
            updateAudioProducer: this.updateAudioProducer.bind(this),
            updateAudioLevel: this.updateAudioLevel.bind(this),
            updateLocalAudioProducer: this.updateLocalAudioProducer.bind(this),
            updateConsumerTransports: this.updateConsumerTransports.bind(this),
            updateConsumingTransports: this.updateConsumingTransports.bind(this),
            // Polls
            updatePolls: this.updatePolls.bind(this),
            updatePoll: this.updatePoll.bind(this),
            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
            // Background
            updateCustomImage: this.updateCustomImage.bind(this),
            updateSelectedImage: this.updateSelectedImage.bind(this),
            updateSegmentVideo: this.updateSegmentVideo.bind(this),
            updateSelfieSegmentation: this.updateSelfieSegmentation.bind(this),
            updatePauseSegmentation: this.updatePauseSegmentation.bind(this),
            updateProcessedStream: this.updateProcessedStream.bind(this),
            updateKeepBackground: this.updateKeepBackground.bind(this),
            updateBackgroundHasChanged: this.updateBackgroundHasChanged.bind(this),
            updateVirtualStream: this.updateVirtualStream.bind(this),
            updateMainCanvas: this.updateMainCanvas.bind(this),
            updatePrevKeepBackground: this.updatePrevKeepBackground.bind(this),
            updateAppliedBackground: this.updateAppliedBackground.bind(this),
            updateIsBackgroundModalVisible: this.updateIsBackgroundModalVisible.bind(this),
            updateAutoClickBackground: this.updateAutoClickBackground.bind(this),
            // Breakout rooms
            updateBreakoutRooms: this.updateBreakoutRooms.bind(this),
            updateCurrentRoomIndex: this.updateCurrentRoomIndex.bind(this),
            updateCanStartBreakout: this.updateCanStartBreakout.bind(this),
            updateBreakOutRoomStarted: this.updateBreakOutRoomStarted.bind(this),
            updateBreakOutRoomEnded: this.updateBreakOutRoomEnded.bind(this),
            updateHostNewRoom: this.updateHostNewRoom.bind(this),
            updateLimitedBreakRoom: this.updateLimitedBreakRoom.bind(this),
            updateMainRoomsLength: this.updateMainRoomsLength.bind(this),
            updateMemberRoom: this.updateMemberRoom.bind(this),
            updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
            // Whiteboard
            updateWhiteboardUsers: this.updateWhiteboardUsers.bind(this),
            updateCurrentWhiteboardIndex: this.updateCurrentWhiteboardIndex.bind(this),
            updateCanStartWhiteboard: this.updateCanStartWhiteboard.bind(this),
            updateWhiteboardStarted: this.updateWhiteboardStarted.bind(this),
            updateWhiteboardEnded: this.updateWhiteboardEnded.bind(this),
            updateWhiteboardLimit: this.updateWhiteboardLimit.bind(this),
            updateIsWhiteboardModalVisible: this.updateIsWhiteboardModalVisible.bind(this),
            updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
            updateShapes: this.updateShapes.bind(this),
            updateUseImageBackground: this.updateUseImageBackground.bind(this),
            updateRedoStack: this.updateRedoStack.bind(this),
            updateUndoStack: this.updateUndoStack.bind(this),
            updateCanvasStream: this.updateCanvasStream.bind(this),
            updateCanvasWhiteboard: this.updateCanvasWhiteboard.bind(this),
            // Screenboard
            updateCanvasScreenboard: this.updateCanvasScreenboard.bind(this),
            updateProcessedScreenStream: this.updateProcessedScreenStream.bind(this),
            updateAnnotateScreenStream: this.updateAnnotateScreenStream.bind(this),
            updateMainScreenCanvas: this.updateMainScreenCanvas.bind(this),
            updateIsScreenboardModalVisible: this.updateIsScreenboardModalVisible.bind(this),
            // Other functions
            checkOrientation: this.checkOrientation.bind(this),
            updateDevice: this.updateDevice.bind(this),
            updateSocket: this.updateSocket.bind(this),
            updateLocalSocket: this.updateLocalSocket.bind(this),
            updateValidated: this.updateValidated.bind(this),
            showAlert: this.showAlert.bind(this),
            getUpdatedAllParams: () => {
                try {
                    if (this.sourceParameters !== null) {
                        this.sourceParameters = {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        };
                        if (this.updateSourceParameters) {
                            this.updateSourceParameters(this.sourceParameters);
                        }
                    }
                }
                catch {
                    console.log('error updateSourceParameters');
                }
                return {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                };
            },
        };
    }
    mediaSFUParameters = {
        ...this.getAllParams(),
        ...this.mediaSFUFunctions(),
    };
    getUpdatedAllParams = () => {
        return {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    };
    updateButtonState(buttonType, value) {
        this.controlButtons = this.controlButtons.map((button) => {
            if (buttonType === 'micActive' && button.icon === this.faMicrophoneSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'videoActive' && button.icon === this.faVideoSlash) {
                return { ...button, active: value };
            }
            if (buttonType === 'screenShareActive' && button.icon === this.faDesktop) {
                if (button.alternateIconComponent) {
                    const updatedInjector = this.createInjector({
                        disabled: !value,
                    });
                    return {
                        ...button,
                        active: true,
                        alternateIconComponent: { ...this.screenShareWidget, injector: updatedInjector },
                    }; //always default to true for active
                }
                else {
                    return { ...button, active: true }; //always default to true for active
                }
            }
            if (buttonType === 'endCallActive' && button.icon === this.faPhone) {
                return { ...button, active: value };
            }
            if (buttonType === 'participantsActive' && button.icon === this.faUsers) {
                return { ...button, active: value };
            }
            if (buttonType === 'showMessagesBadge' &&
                button.customName &&
                button.customName === 'Messages') {
                const updatedInjector = this.createInjector({
                    icon: this.faComments,
                    badgeValue: value ? '*' : '',
                    iconColor: 'black',
                    showBadge: value,
                });
                return { ...button, customComponent: { ...this.messageWidget, injector: updatedInjector } };
            }
            if (buttonType === 'showMenuBadge' && button.customName && button.customName === 'Menu') {
                const updatedInjector = this.createInjector({
                    icon: this.faBars,
                    badgeValue: this.totalReqWait.value,
                    iconColor: 'black',
                    showBadge: true,
                });
                return { ...button, customComponent: { ...this.menuWidget, injector: updatedInjector } };
            }
            return button;
        });
        this.cdr.detectChanges();
    }
    PrejoinPageComponent = {
        component: this.PrejoinPage,
        injector: null,
    };
    updatePrejoinPageComponent = () => {
        const PrejoinComp = {
            component: this.PrejoinPage,
            injector: this.createInjector({
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    connectLocalSocket: this.socketManager.connectLocalSocket,
                    updateSocket: this.updateSocket,
                    updateLocalSocket: this.updateLocalSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                credentials: this.credentials,
                localLink: this.localLink,
                connectMediaSFU: this.connectMediaSFU,
                returnUI: this.returnUI,
                noUIPreJoinOptions: this.noUIPreJoinOptions,
                joinMediaSFURoom: this.joinMediaSFURoom,
                createMediaSFURoom: this.createMediaSFURoom,
            }),
        };
        this.PrejoinPageComponent = { ...PrejoinComp };
        this.cdr.detectChanges();
    };
    ngOnInit() {
        if (this.PrejoinPage) {
            this.updatePrejoinPageComponent();
        }
        this.setupResizeListener();
        if (this.validated) {
            this.connectAndAddSocketMethods();
        }
        this.mainHeightWidthSubscription = this.mainHeightWidth.subscribe(() => {
            this.updateMainVideoSize();
        });
        this.recordingSubscription = combineLatest([
            this.recordPaused,
            this.recordStarted,
            this.recordStopped,
            this.recordResumed,
            this.recordingProgressTime,
            this.showRecordButtons,
            this.islevel,
        ]).subscribe(([recordPaused, recordStarted, recordStopped, recordResumed, recordingProgressTime, showRecordButtons, islevel,]) => {
            if (recordPaused ||
                recordStarted ||
                recordStopped ||
                recordResumed ||
                recordingProgressTime ||
                showRecordButtons ||
                islevel) {
                this.updateRecordButtons();
            }
        });
        this.ScreenboardSubscription = combineLatest([
            this.shared,
            this.componentSizes,
            this.annotateScreenStream,
        ]).subscribe(([shared, componentSizes]) => {
            this.ScreenboardWidget = {
                component: Screenboard,
                inputs: {
                    customWidth: componentSizes.mainWidth,
                    customHeight: componentSizes.mainHeight,
                    parameters: this.mediaSFUParameters,
                    showAspect: shared,
                },
            };
        });
        this.validatedSubscription = this.validated.subscribe((validated) => {
            if (validated) {
                this.handleValidated();
            }
        });
        this.islevelSubscription = this.islevel.subscribe((islevel) => {
            if (islevel) {
                this.updateCustomMenuButtons();
            }
        });
        this.coHostSubscription = combineLatest([this.coHost, this.coHostResponsibility]).subscribe(([coHost, coHostResponsibility]) => {
            if (coHost || coHostResponsibility) {
                this.updateCustomMenuButtons();
            }
        });
        // Subscribe to changes in BehaviorSubject and update the buttons accordingly
        this.buttonSubscriptions.push(this.micActive.subscribe((value) => {
            this.updateButtonState('micActive', value);
        }));
        this.buttonSubscriptions.push(this.videoActive.subscribe((value) => {
            this.updateButtonState('videoActive', value);
        }));
        this.buttonSubscriptions.push(this.screenShareActive.subscribe((value) => {
            this.updateButtonState('screenShareActive', value);
        }));
        this.buttonSubscriptions.push(this.showMessagesBadge.subscribe((value) => {
            this.updateButtonState('showMessagesBadge', value);
        }));
        this.buttonSubscriptions.push(this.totalReqWait.subscribe(() => {
            this.updateButtonState('showMenuBadge', true);
        }));
        this.buttonSubscriptions.push(this.participantsCounter.subscribe((value) => {
            this.updateMenuParticipantsWidget(value);
        }));
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.handleResize);
        window.removeEventListener('orientationchange', this.handleResize);
        if (this.mainHeightWidthSubscription) {
            this.mainHeightWidthSubscription.unsubscribe();
        }
        if (this.validatedSubscription) {
            this.validatedSubscription.unsubscribe();
        }
        if (this.islevelSubscription) {
            this.islevelSubscription.unsubscribe();
        }
        if (this.coHostSubscription) {
            this.coHostSubscription.unsubscribe();
        }
        if (this.ScreenboardSubscription) {
            this.ScreenboardSubscription.unsubscribe();
        }
        if (this.recordingSubscription) {
            this.recordingSubscription.unsubscribe();
        }
    }
    updateMainVideoSize = async () => {
        if (!this.lock_screen.value && !this.shared.value) {
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
        }
        else {
            if (!this.first_round.value) {
                this.prepopulateUserMedia.prepopulateUserMedia({
                    name: this.hostLabel.value,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            }
        }
    };
    async connectAndAddSocketMethods() {
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
        const socket_ = await this.connect_Socket(this.apiUserName.value, this.apiToken.value);
        if (socket_) {
            this.updateSocket(socket_);
        }
    }
    async handleValidated() {
        this.updateAllVideoStreams([
            { producerId: 'youyou', stream: undefined, id: 'youyou', name: 'youyou' },
        ]);
        this.updateStreamNames([{ id: 'youyou', name: 'youyou', producerId: '' }]);
        if (this.validated.value) {
            try {
                if (!this.localUIMode.value) {
                    this.updateIsLoadingModalVisible(true);
                    await this.connectAndAddSocketMethods();
                }
                else {
                    this.updateIsLoadingModalVisible(false);
                }
            }
            catch (error) {
                console.log('error connectAndaAddSocketMethods', error);
            }
            this.startMeetingProgressTimer.startMeetingProgressTimer({
                startTime: Date.now() / 1000,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            try {
                if (this.sourceParameters !== null) {
                    this.sourceParameters = {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                    };
                    if (this.updateSourceParameters) {
                        this.updateSourceParameters(this.sourceParameters);
                    }
                }
            }
            catch {
                console.log('error updateSourceParameters');
            }
        }
    }
    async handleResize() {
        let fraction = 0;
        if (window.innerHeight < window.innerWidth &&
            (this.eventType.value == 'webinar' || this.eventType.value == 'conference')) {
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        else {
            // Set default control button height for portrait mode or other event types
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            fraction = Number(fraction);
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        const dimensions = this.computeDimensionsMethod({
            containerWidthFraction: 1,
            containerHeightFraction: 1,
            mainSize: this.mainHeightWidth.value,
            doStack: true,
            defaultFraction: this.eventType.value == 'webinar' || this.eventType.value == 'conference'
                ? 1 - fraction
                : 1,
        });
        this.updateComponentSizes(dimensions);
        const orientation = this.checkOrientation();
        if (orientation == 'portrait') {
            if (!this.isWideScreen.value) {
                if (this.shareScreenStarted.value || this.shared.value) {
                    this.updateScreenForceFullDisplay(true);
                }
            }
        }
        // Updates the main grid view
        await this.prepopulateUserMedia.prepopulateUserMedia({
            name: this.hostLabel.value,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
        // Updates the mini grid view
        await this.onScreenChanges.onScreenChanges({
            changed: true,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
    }
    async disconnectAllSockets(consume_sockets) {
        for (const socket of consume_sockets) {
            try {
                const ip = Object.keys(socket)[0];
                await socket[ip].disconnect();
            }
            catch (error) {
                console.log(`Error disconnecting socket with IP: ${Object.keys(socket)[0]}`, error);
            }
        }
    }
    async closeAndReset() {
        //close and clean up all sockets, modals,... and reset all states to initial values
        this.updateIsMessagesModalVisible(false);
        this.updateIsParticipantsModalVisible(false);
        this.updateIsWaitingModalVisible(false);
        this.updateIsRequestsModalVisible(false);
        this.updateIsCoHostModalVisible(false);
        this.updateIsSettingsModalVisible(false);
        this.updateIsDisplaySettingsModalVisible(false);
        this.updateIsMediaSettingsModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsShareEventModalVisible(false);
        this.updateIsConfirmExitModalVisible(false);
        await this.disconnectAllSockets(this.consume_sockets.value);
        await this.updateStatesToInitialValues();
        this.updateMeetingProgressTime('00:00:00');
        this.updateMeetingElapsedTime(0);
        this.updateRecordingProgressTime('00:00:00');
        this.updateRecordElapsedTime(0);
        this.updateShowRecordButtons(false);
        this.updateIsConfigureWhiteboardModalVisible(false);
        this.updateIsWhiteboardModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsRecordingModalVisible(false);
        this.updateIsPollModalVisible(false);
        this.updateIsBreakoutRoomsModalVisible(false);
        this.updateIsBackgroundModalVisible(false);
        this.updateIsLoadingModalVisible(false);
        this.updateIsConfirmHereModalVisible(false);
        await sleep({ ms: 500 });
        this.updateValidated(false);
        //if on web, reload the page
        window.location.reload();
    }
    computeDimensionsMethod = ({ containerWidthFraction = 1, containerHeightFraction = 1, mainSize, doStack = true, defaultFraction, }) => {
        const parentWidth = window.innerWidth * containerWidthFraction;
        const parentHeight = window.innerHeight * containerHeightFraction * defaultFraction;
        let isWideScreen = parentWidth >= 768;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        const dimensions = this.calculateDimensions({
            parentWidth,
            parentHeight,
            isWideScreen,
            mainSize,
            doStack,
        });
        return dimensions;
    };
    calculateDimensions({ parentWidth, parentHeight, isWideScreen, mainSize, doStack, }) {
        if (doStack) {
            return isWideScreen
                ? {
                    mainHeight: Math.floor(parentHeight),
                    otherHeight: Math.floor(parentHeight),
                    mainWidth: Math.floor((mainSize / 100) * parentWidth),
                    otherWidth: Math.floor(((100 - mainSize) / 100) * parentWidth),
                }
                : {
                    mainHeight: Math.floor((mainSize / 100) * parentHeight),
                    otherHeight: Math.floor(((100 - mainSize) / 100) * parentHeight),
                    mainWidth: Math.floor(parentWidth),
                    otherWidth: Math.floor(parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(parentHeight),
                otherHeight: Math.floor(parentHeight),
                mainWidth: Math.floor(parentWidth),
                otherWidth: Math.floor(parentWidth),
            };
        }
    }
    handleOrientationChange() {
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('orientationchange', this.handleResize.bind(this));
    }
    setupResizeListener() {
        this.handleResize();
    }
    orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    async joinRoom(data) {
        const { socket, roomName, islevel, member, sec, apiUserName } = data;
        try {
            const response = await this.joinRoomClient.joinRoomClient({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
            return response;
        }
        catch (error) {
            console.log('Error joining room:', error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    async join_Room({ socket, roomName, islevel, member, sec, apiUserName, isLocal = false, }) {
        let data;
        if (!isLocal) {
            data = await this.joinRoom({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
        }
        else {
            const localData = await this.joinLocalRoom.joinLocalRoom({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    connectLocalSocket: this.socketManager.connectLocalSocket,
                    updateSocket: this.updateSocket,
                    updateLocalSocket: this.updateLocalSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                checkConnect: this.localLink.length > 0 &&
                    this.connectMediaSFU === true &&
                    !this.link.value.includes('mediasfu.com'),
                localLink: this.localLink,
                joinMediaSFURoom: this.joinMediaSFURoom,
            });
            data = await createResponseJoinRoom({ localRoom: localData });
        }
        const updateAndComplete = async (data) => {
            // Update room parameters
            try {
                // Check if roomRecvIPs is not empty
                if (!data.roomRecvIPs || data.roomRecvIPs.length === 0) {
                    data.roomRecvIPs = ['none'];
                    if (this.link.value !== "" &&
                        this.link.value.includes("mediasfu.com") &&
                        !isLocal) {
                        // Community Edition Only
                        await this.receiveAllPipedTransports.receiveAllPipedTransports({
                            community: true,
                            nsock: this.getUpdatedAllParams().socket,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                }
                this.updateRoomParametersClient.updateRoomParametersClient({
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                        data: data,
                    },
                });
                if (data.isHost) {
                    this.updateIslevel('2');
                }
                else {
                    // Issue with isHost for local room
                    if (islevel !== '2') {
                        this.updateIslevel('1');
                    }
                }
                if (data.secureCode && data.secureCode !== '') {
                    this.updateAdminPasscode(data.secureCode);
                }
                if (data.rtpCapabilities) {
                    try {
                        const device_ = await this.createDeviceClient.createDeviceClient({
                            rtpCapabilities: data.rtpCapabilities,
                        });
                        if (device_) {
                            this.device.next(device_);
                        }
                    }
                    catch (error) {
                        console.error('Error creating device:', error);
                    }
                }
            }
            catch (error) {
                console.error('Error in updateAndComplete:', error);
            }
        };
        if (data && data.success) {
            if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && isLocal) {
                this.roomData.next(data);
                return;
            }
            else if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && !isLocal) {
                // Update roomData
                if (this.roomData.value) {
                    // Updating only the recording and meeting room parameters
                    this.roomData.value.recordingParams = data.recordingParams;
                    this.roomData.value.meetingRoomParams = data.meetingRoomParams;
                    this.roomData.next(this.roomData.value);
                }
                else {
                    this.roomData.next(data);
                }
            }
            else {
                // Update roomData
                this.roomData.next(data);
                if (!this.link.value.includes('mediasfu.com')) {
                    this.roomData.value.meetingRoomParams = data.meetingRoomParams;
                }
            }
            await updateAndComplete(data);
        }
        else {
            if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && !isLocal) {
                // Join local room only
                if (this.roomData.value) {
                    await updateAndComplete(this.roomData.value);
                }
                return;
            }
            // Might be a wrong room name or room is full or other error; check reason in data object if available
            try {
                if (this.showAlert && data?.reason) {
                    this.showAlert({
                        message: data.reason,
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
            catch (error) {
                /* handle error */
            }
        }
    }
    onParticipantsFilterChange = (value) => {
        if (value && value.length > 0) {
            this.filteredParticipants.next(this.participants.value.filter((participant) => participant.name.toLowerCase().includes(value.toLowerCase())));
            this.participantsCounter.next(this.filteredParticipants.value.length);
        }
        else {
            this.filteredParticipants.next(this.participants.value);
            this.participantsCounter.next(this.participants.value.length);
        }
    };
    updateStatesToInitialValues = async () => {
        const initialValues = initialValuesState;
        const updateFunctions = this.getAllParams();
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                const updateFunctionName = `update${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const updateFunction = updateFunctions[updateFunctionName];
                if (typeof updateFunction === 'function') {
                    try {
                        updateFunction(initialValues[key]);
                    }
                    catch {
                        /* handle error */
                    }
                }
            }
        }
    };
    faRecordVinyl = faRecordVinyl;
    faPlayCircle = faPlayCircle;
    faPauseCircle = faPauseCircle;
    faStopCircle = faStopCircle;
    faDotCircle = faDotCircle;
    faCog = faCog;
    faUsers = faUsers;
    faClock = faClock;
    faUserPlus = faUserPlus;
    faTools = faTools;
    faDesktop = faDesktop;
    faPoll = faPoll;
    faUserFriends = faUserFriends;
    faChalkboardTeacher = faChalkboardTeacher;
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faPhone = faPhone;
    faBars = faBars;
    faComments = faComments;
    faChartBar = faChartBar;
    onCloseMenuModal = () => {
        this.updateIsMenuModalVisible(false);
    };
    onEventSettingsClose = () => {
        this.updateIsSettingsModalVisible(false);
    };
    onCoHostClose = () => {
        this.updateIsCoHostModalVisible(false);
    };
    onMediaSettingsClose = () => {
        this.updateIsMediaSettingsModalVisible(false);
    };
    onDisplaySettingsClose = () => {
        this.updateIsDisplaySettingsModalVisible(false);
    };
    onPollClose = () => {
        this.updateIsPollModalVisible(false);
    };
    onBreakoutRoomsClose = () => {
        this.updateIsBreakoutRoomsModalVisible(false);
    };
    onConfigureWhiteboardClose = () => {
        this.updateIsConfigureWhiteboardModalVisible(false);
    };
    onMessagesClose = () => {
        this.updateIsMessagesModalVisible(false);
    };
    onRecordingClose = () => {
        this.updateIsRecordingModalVisible(false);
    };
    onParticipantsClose = () => {
        this.updateIsParticipantsModalVisible(false);
    };
    onBackgroundClose = () => {
        this.updateIsBackgroundModalVisible(false);
    };
    onConfirmExitClose = () => {
        this.updateIsConfirmExitModalVisible(false);
    };
    onConfirmHereClose = () => {
        this.updateIsConfirmHereModalVisible(false);
    };
    onScreenboardClose = () => {
        this.updateIsScreenboardModalVisible(false);
    };
    onShareEventClose = () => {
        this.updateIsShareEventModalVisible(false);
    };
    onAlertHide = () => {
        this.updateAlertVisible(false);
    };
    ScreenboardWidget = {
        component: Screenboard,
        inputs: {
            customWidth: this.componentSizes.value.mainWidth,
            customHeight: this.componentSizes.value.mainHeight,
            parameters: this.mediaSFUParameters,
            showAspect: this.shared.value,
        },
    };
    recordTimerWidget = {
        component: RecordTimerWidget,
        injector: this.createInjector({ recordingProgressTime: this.recordingProgressTime.value }),
    };
    updateRecordTimerWidget = (recordingProgressTime = this.recordingProgressTime.value) => {
        const recordTimerWidget = {
            component: RecordTimerWidget,
            injector: this.createInjector({ recordingProgressTime: recordingProgressTime }),
        };
        this.recordTimerWidget = { ...recordTimerWidget };
        this.cdr.markForCheck();
        return recordTimerWidget;
    };
    recordButtons = [];
    recordButtonsArray = [
        {
            icon: this.faPlayCircle,
            active: () => !this.recordPaused.value,
            onPress: () => this.updateRecording.updateRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            alternateIcon: this.faPauseCircle,
            show: () => true,
        },
        {
            icon: this.faStopCircle,
            active: () => false,
            onPress: () => this.stopRecording.stopRecording({
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
        {
            customComponent: () => this.updateRecordTimerWidget(),
            show: () => true,
            active: () => false,
        },
        {
            icon: this.faDotCircle,
            active: () => false,
            onPress: () => console.log('Status pressed'),
            activeColor: 'black',
            inActiveColor: () => (this.recordPaused.value ? 'yellow' : 'red'),
            show: () => true,
        },
        {
            icon: this.faCog,
            active: () => false,
            onPress: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            activeColor: 'green',
            inActiveColor: 'black',
            show: () => true,
        },
    ];
    async updateRecordButtons() {
        const recordButtons = this.recordButtonsArray.map((button) => {
            return {
                ...button,
                active: typeof button.active === 'function' ? button.active() : button.active,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
                activeColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
                inActiveColor: typeof button.inActiveColor === 'function'
                    ? button.inActiveColor()
                    : button.inActiveColor,
            };
        });
        this.recordButtons = [...recordButtons];
        await this.updateMenuRecordWidget(recordButtons);
        this.updateCustomMenuButtons();
        this.cdr.markForCheck();
    }
    // Create instances of the custom widgets
    menuWidget = {
        component: MenuWidget,
        injector: this.createInjector({
            icon: this.faBars,
            badgeValue: this.totalReqWait.value,
            iconColor: 'black',
            showBadge: true,
        }),
    };
    messageWidget = {
        component: MessageWidget,
        injector: this.createInjector({
            icon: this.faComments,
            showBadge: this.showMessagesBadge.value,
            badgeValue: 1,
            iconColor: 'black',
        }),
    };
    menuRecordWidget = {
        component: MenuRecordWidget,
        injector: this.createInjector({
            buttons: this.recordButtons,
            showAspect: true,
            direction: 'horizontal',
        }),
    };
    updateMenuRecordWidget = (recordButtons = this.recordButtons) => {
        const menuRecordWidget = {
            component: MenuRecordWidget,
            injector: this.createInjector({
                buttons: recordButtons,
                showAspect: true,
                direction: 'horizontal',
            }),
        };
        this.menuRecordWidget = { ...menuRecordWidget };
        this.cdr.markForCheck();
        return menuRecordWidget;
    };
    menuParticipantsWidget = {
        component: MenuParticipantsWidget,
        injector: this.createInjector({
            icon: this.faChartBar,
            participantsCounter: this.participantsCounter.value,
            iconColor: 'black',
        }),
    };
    updateMenuParticipantsWidget = (count = this.participantsCounter.value) => {
        const menuParticipantsWidget = {
            component: MenuParticipantsWidget,
            injector: this.createInjector({
                icon: this.faChartBar,
                participantsCounter: count,
                iconColor: 'black',
            }),
        };
        this.menuParticipantsWidget = { ...menuParticipantsWidget };
        this.cdr.markForCheck();
        return menuParticipantsWidget;
    };
    customMenuButtonsArray = [
        {
            icon: this.faRecordVinyl,
            text: 'Record',
            action: () => this.launchRecording.launchRecording({
                updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
                isRecordingModalVisible: this.isRecordingModalVisible.value,
                showAlert: this.showAlert.bind(this),
                stopLaunchRecord: this.stopLaunchRecord.value,
                canLaunchRecord: this.canLaunchRecord.value,
                recordingAudioSupport: this.recordingAudioSupport.value,
                recordingVideoSupport: this.recordingVideoSupport.value,
                updateCanRecord: this.updateCanRecord.bind(this),
                updateClearedToRecord: this.updateClearedToRecord.bind(this),
                recordStarted: this.recordStarted.value,
                recordPaused: this.recordPaused.value,
                localUIMode: this.localUIMode.value,
            }),
            show: () => !this.showRecordButtons.value && this.islevel.value == '2',
        },
        {
            customComponent: () => this.updateMenuRecordWidget(),
            show: () => this.showRecordButtons.value && this.islevel.value == '2',
            action: () => console.log('record buttons pressed'),
        },
        {
            icon: this.faCog,
            text: 'Event Settings',
            action: () => this.launchSettings.launchSettings({
                updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
                isSettingsModalVisible: this.isSettingsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faUsers,
            text: 'Requests',
            action: () => this.launchRequests.launchRequests({
                updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
                isRequestsModalVisible: this.isRequestsModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                ((this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    !!this.coHostResponsibility?.value?.find((item) => item.name === 'media')?.value) ??
                    false) ||
                false,
        },
        {
            icon: this.faClock,
            text: 'Waiting',
            action: () => this.launchWaiting.launchWaiting({
                updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
                isWaitingModalVisible: this.isWaitingModalVisible.value,
            }),
            show: () => this.islevel.value == '2' ||
                (this.coHostResponsibility.value &&
                    this.coHost.value &&
                    this.coHost.value === this.member.value &&
                    this.coHostResponsibility?.value?.find((item) => item.name === 'waiting')?.value ===
                        true) ||
                false,
        },
        {
            icon: this.faUserPlus,
            text: 'Co-host',
            action: () => this.launchCoHost.launchCoHost({
                updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
                isCoHostModalVisible: this.isCoHostModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faTools,
            text: 'Set Media',
            action: () => this.launchMediaSettings.launchMediaSettings({
                updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
                isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
                audioInputs: this.audioInputs.value,
                videoInputs: this.videoInputs.value,
                updateAudioInputs: this.updateAudioInputs.bind(this),
                updateVideoInputs: this.updateVideoInputs.bind(this),
            }),
            show: () => true,
        },
        {
            icon: this.faDesktop,
            text: 'Display',
            action: () => this.launchDisplaySettings.launchDisplaySettings({
                updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
                isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faPoll,
            text: 'Poll',
            action: () => this.launchPoll.launchPoll({
                updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                isPollModalVisible: this.isPollModalVisible.value,
            }),
            show: () => true,
        },
        {
            icon: this.faUserFriends,
            text: 'Breakout Rooms',
            action: () => this.launchBreakoutRooms.launchBreakoutRooms({
                updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
                isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
        {
            icon: this.faChalkboardTeacher,
            text: 'Whiteboard',
            action: () => this.launchConfigureWhiteboard.launchConfigureWhiteboard({
                updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
                isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            }),
            show: () => this.islevel.value == '2',
        },
    ];
    customMenuButtons = [];
    updateCustomMenuButtons() {
        this.customMenuButtons = this.customMenuButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                customComponent: button.customComponent
                    ? typeof button.customComponent === 'function'
                        ? button.customComponent()
                        : button.customComponent
                    : undefined,
            };
        });
    }
    screenShareWidget = {
        component: ScreenShareWidget,
        injector: this.createInjector({ disabled: !this.screenShareActive.value }),
    };
    controlButtons = [
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.audioSwitching.value,
            show: true,
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                    MediaStream,
                    MediaStreamTrack,
                    mediaDevices: MediaDevices,
                    device: this.device.value,
                    socket: this.socket.value,
                    showAlert: this.showAlert.bind(this),
                    checkPermission: this.checkPermission.checkPermission,
                    streamSuccessVideo: this.streamSuccessVideo.streamSuccessVideo,
                    hasCameraPermission: this.hasCameraPermission.value,
                    requestPermissionCamera: this.requestPermissionCamera.bind(this),
                    checkMediaPermission: 'web' !== 'web',
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: this.videoSwitching.value,
            show: true,
        },
        {
            //inverted active for inactive state
            icon: faDesktop,
            alternateIconComponent: this.screenShareWidget,
            active: true,
            onPress: () => this.clickScreenShare.clickScreenShare({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            disabled: false,
            show: true,
        },
        {
            icon: this.faUsers,
            active: this.participantsActive.value,
            onPress: () => this.launchParticipants.launchParticipants({
                updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
                isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            disabled: false,
            show: true,
        },
        {
            customComponent: this.menuWidget,
            customName: 'Menu',
            onPress: () => this.launchMenuModal.launchMenuModal({
                updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
                isMenuModalVisible: this.isMenuModalVisible.value,
            }),
            show: true,
        },
        {
            customComponent: this.messageWidget,
            customName: 'Messages',
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: true,
        },
    ];
    async connect_Socket(apiUserName, token, skipSockets = false) {
        const socketDefault = this.socket.value;
        const socketAlt = this.connectMediaSFU && this.localSocket.value && this.localSocket.value.id
            ? this.localSocket.value
            : socketDefault;
        if (this.socket.value && this.socket.value.id) {
            if (!skipSockets) {
                // Event listeners on socketDefault
                socketDefault.on('disconnect', async () => {
                    await this.disconnect.disconnect({
                        showAlert: this.showAlert.bind(this),
                        redirectURL: this.redirectURL.value,
                        onWeb: true,
                        updateValidated: this.updateValidated.bind(this),
                    });
                    if (this.videoAlreadyOn.value) {
                        await this.clickVideo.clickVideo({
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    if (this.audioAlreadyOn.value) {
                        await this.clickAudio.clickAudio({
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    await this.closeAndReset();
                });
                socketDefault.on('allMembers', async (membersData) => {
                    if (membersData) {
                        await this.allMembers.allMembers({
                            apiUserName: apiUserName,
                            apiKey: '', //not recommended - use apiToken instead. Use for testing/development only
                            apiToken: token,
                            members: membersData.members,
                            requestss: membersData.requests ? membersData.requests : this.requestList.value,
                            coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                            coHostRes: membersData.coHostResponsibilities
                                ? membersData.coHostResponsibilities
                                : this.coHostResponsibility.value,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                            consume_sockets: this.consume_sockets.value,
                        });
                    }
                });
                socketDefault.on('allMembersRest', async (membersData) => {
                    if (membersData) {
                        await this.allMembersRest.allMembersRest({
                            apiUserName: apiUserName,
                            apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                            members: membersData.members,
                            apiToken: token,
                            settings: membersData.settings,
                            coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                            coHostRes: membersData.coHostResponsibilities
                                ? membersData.coHostResponsibilities
                                : this.coHostResponsibility.value,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                            consume_sockets: this.consume_sockets.value,
                        });
                    }
                });
                socketDefault.on('userWaiting', async ({ name }) => {
                    await this.userWaiting.userWaiting({
                        name,
                        showAlert: this.showAlert.bind(this),
                        totalReqWait: this.totalReqWait.value,
                        updateTotalReqWait: this.updateTotalReqWait.bind(this),
                    });
                });
                socketDefault.on('personJoined', async ({ name }) => {
                    this.personJoined.personJoined({
                        name,
                        showAlert: this.showAlert.bind(this),
                    });
                });
                socketDefault.on('allWaitingRoomMembers', async (waiting_data) => {
                    await this.allWaitingRoomMembers.allWaitingRoomMembers({
                        waitingParticipants: waiting_data.waitingParticipants
                            ? waiting_data.waitingParticipants
                            : waiting_data.waitingParticipantss
                                ? waiting_data.waitingParticipantss
                                : this.waitingRoomList.value,
                        updateTotalReqWait: this.updateTotalReqWait.bind(this),
                        updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
                    });
                });
                socketDefault.on('ban', async ({ name }) => {
                    await this.banParticipant.banParticipant({
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('updatedCoHost', async (cohost_data) => {
                    await this.updatedCoHost.updatedCoHost({
                        coHost: cohost_data.coHost ? cohost_data.coHost : this.coHost.value,
                        coHostResponsibility: cohost_data.coHostResponsibilities
                            ? cohost_data.coHostResponsibilities
                            : this.coHostResponsibility.value,
                        youAreCoHost: this.youAreCoHost.value,
                        updateCoHost: this.updateCoHost.bind(this),
                        updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
                        updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
                        showAlert: this.showAlert.bind(this),
                        eventType: this.eventType.value,
                        islevel: this.islevel.value,
                        member: this.member.value,
                    });
                });
                socketDefault.on('participantRequested', async ({ userRequest }) => {
                    await this.participantRequested.participantRequested({
                        userRequest,
                        requestList: this.requestList.value,
                        waitingRoomList: this.waitingRoomList.value,
                        updateTotalReqWait: this.updateTotalReqWait.bind(this),
                        updateRequestList: this.updateRequestList.bind(this),
                    });
                });
                socketDefault.on('screenProducerId', async ({ producerId }) => {
                    this.screenProducerId.screenProducerId({
                        producerId,
                        screenId: this.screenId.value,
                        membersReceived: this.membersReceived.value,
                        shareScreenStarted: this.shareScreenStarted.value,
                        deferScreenReceived: this.deferScreenReceived.value,
                        participants: this.participants.value,
                        updateScreenId: this.updateScreenId.bind(this),
                        updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
                        updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
                    });
                });
                socketDefault.on('updateMediaSettings', async ({ settings }) => {
                    this.updateMediaSettings.updateMediaSettings({
                        settings,
                        updateAudioSetting: this.updateAudioSetting.bind(this),
                        updateVideoSetting: this.updateVideoSetting.bind(this),
                        updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
                        updateChatSetting: this.updateChatSetting.bind(this),
                    });
                });
                socketDefault.on('producer-media-paused', async ({ producerId, kind, name, }) => {
                    await this.producerMediaPaused.producerMediaPaused({
                        producerId,
                        kind,
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('producer-media-resumed', async ({ kind, name }) => {
                    await this.producerMediaResumed.producerMediaResumed({
                        kind,
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('producer-media-closed', async ({ producerId, kind, }) => {
                    if (producerId && kind) {
                        await this.producerMediaClosed.producerMediaClosed({
                            producerId,
                            kind,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                });
                socketDefault.on('controlMediaHost', async ({ type }) => {
                    await this.controlMediaHost.controlMediaHost({
                        type,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('meetingEnded', async () => {
                    await this.meetingEnded.meetingEnded({
                        showAlert: this.showAlert.bind(this),
                        redirectURL: this.redirectURL.value,
                        onWeb: true,
                        eventType: this.eventType.value,
                        updateValidated: this.updateValidated.bind(this),
                    });
                    if (this.videoAlreadyOn.value) {
                        await this.clickVideo.clickVideo({
                            parameters: {
                                ...this.getAllParams(),
                                ...this.mediaSFUFunctions(),
                            },
                        });
                    }
                    if (this.audioAlreadyOn.value) {
                        await this.clickAudio.clickAudio({
                            parameters: {
                                ...this.getAllParams(),
                                ...this.mediaSFUFunctions(),
                            },
                        });
                    }
                    await this.closeAndReset();
                });
                socketDefault.on('disconnectUserSelf', async () => {
                    await this.disconnectUserSelf.disconnectUserSelf({
                        socket: socketDefault,
                        member: this.member.value,
                        roomName: this.roomName.value,
                    });
                });
                socketDefault.on('receiveMessage', async ({ message }) => {
                    await this.receiveMessage.receiveMessage({
                        message,
                        messages: this.messages.value,
                        participantsAll: this.participantsAll.value,
                        member: this.member.value,
                        eventType: this.eventType.value,
                        islevel: this.islevel.value,
                        coHost: this.coHost.value,
                        updateMessages: this.updateMessages.bind(this),
                        updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
                    });
                });
                socketDefault.on('meetingTimeRemaining', async ({ timeRemaining }) => {
                    await this.meetingTimeRemaining.meetingTimeRemaining({
                        timeRemaining,
                        showAlert: this.showAlert.bind(this),
                        eventType: this.eventType.value,
                    });
                });
                socketDefault.on('meetingStillThere', async () => {
                    this.meetingStillThere.meetingStillThere({
                        updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
                    });
                });
                socketDefault.on('updateConsumingDomains', async ({ domains, alt_domains }) => {
                    await this.updateConsumingDomains.updateConsumingDomains({
                        domains,
                        alt_domains,
                        apiUserName,
                        apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                        apiToken: token,
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                });
                socketDefault.on('hostRequestResponse', ({ requestResponse }) => {
                    this.hostRequestResponse.hostRequestResponse({
                        requestResponse,
                        showAlert: this.showAlert.bind(this),
                        requestList: this.requestList.value,
                        updateRequestList: this.updateRequestList.bind(this),
                        updateMicAction: this.updateMicAction.bind(this),
                        updateVideoAction: this.updateVideoAction.bind(this),
                        updateScreenAction: this.updateScreenAction.bind(this),
                        updateChatAction: this.updateChatAction.bind(this),
                        updateAudioRequestState: this.updateAudioRequestState.bind(this),
                        updateVideoRequestState: this.updateVideoRequestState.bind(this),
                        updateScreenRequestState: this.updateScreenRequestState.bind(this),
                        updateChatRequestState: this.updateChatRequestState.bind(this),
                        updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
                        updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
                        updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
                        updateChatRequestTime: this.updateChatRequestTime.bind(this),
                        updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
                    });
                });
                socketDefault.on('pollUpdated', async (data) => {
                    try {
                        await this.pollUpdated.pollUpdated({
                            data,
                            polls: this.polls.value,
                            poll: this.poll.value ? this.poll.value : {},
                            member: this.member.value,
                            islevel: this.islevel.value,
                            showAlert: this.showAlert.bind(this),
                            updatePolls: this.updatePolls.bind(this),
                            updatePoll: this.updatePoll.bind(this),
                            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
                        });
                    }
                    catch {
                        /* handle error */
                    }
                });
                socketDefault.on('breakoutRoomUpdated', async (data) => {
                    try {
                        await this.breakoutRoomUpdated.breakoutRoomUpdated({
                            data,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    catch {
                        /* handle error */
                    }
                });
            }
            if (skipSockets) {
                // Remove specific event listeners from socketDefault and socketAlt
                const events = [
                    'roomRecordParams',
                    'startRecords',
                    'reInitiateRecording',
                    'RecordingNotice',
                    'timeLeftRecording',
                    'stoppedRecording',
                ];
                events.forEach((event) => {
                    socketDefault.off(event);
                    socketAlt.off(event);
                });
            }
            socketAlt.on('roomRecordParams', async ({ recordParams }) => {
                this.roomRecordParams.roomRecordParams({
                    recordParams,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            socketAlt.on('startRecords', async () => {
                await this.startRecords.startRecords({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: socketAlt,
                });
            });
            socketAlt.on('reInitiateRecording', async () => {
                await this.reInitiateRecording.reInitiateRecording({
                    roomName: this.roomName.value,
                    member: this.member.value,
                    socket: socketAlt,
                    adminRestrictSetting: this.adminRestrictSetting.value,
                });
            });
            socketAlt.on('RecordingNotice', async ({ state, userRecordingParam, pauseCount, timeDone }) => {
                await this.recordingNotice.RecordingNotice({
                    state,
                    userRecordingParam,
                    pauseCount,
                    timeDone,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            });
            socketAlt.on('timeLeftRecording', async ({ timeLeft }) => {
                this.timeLeftRecording.timeLeftRecording({
                    timeLeft,
                    showAlert: this.showAlert.bind(this),
                });
            });
            socketAlt.on('stoppedRecording', async ({ state, reason }) => {
                await this.stoppedRecording.stoppedRecording({
                    state,
                    reason,
                    showAlert: this.showAlert.bind(this),
                });
            });
            if (this.localLink !== "" && socketDefault && !skipSockets) {
                await this.join_Room({
                    socket: socketDefault,
                    roomName: this.roomName.value,
                    islevel: this.islevel.value,
                    member: this.member.value,
                    sec: token,
                    apiUserName: apiUserName,
                    isLocal: true,
                });
            }
            // Check if localSocket has changed
            const localChanged = this.localSocket.value && this.localSocket.value.id && this.localSocket.value.id !== socketAlt.id;
            if (!skipSockets && localChanged) {
                // Re-call connect_Socket with skipSockets = true
                await this.connect_Socket(apiUserName, token, true);
                await sleep({ ms: 1000 });
                this.updateIsLoadingModalVisible(false);
                return socketDefault;
            }
            else {
                if (this.link.value !== '' && this.link.value.includes('mediasfu.com')) {
                    // Token might be different for local room
                    const token = this.apiToken.value;
                    await this.join_Room({
                        socket: this.connectMediaSFU && socketAlt && socketAlt.id ? socketAlt : socketDefault,
                        roomName: this.roomName.value,
                        islevel: this.islevel.value,
                        member: this.member.value,
                        sec: token,
                        apiUserName: apiUserName,
                    });
                }
                await this.receiveRoomMessages.receiveRoomMessages({
                    socket: socketDefault,
                    roomName: this.roomName.value,
                    updateMessages: this.updateMessages.bind(this),
                });
                if (!skipSockets) {
                    await this.prepopulateUserMedia.prepopulateUserMedia({
                        name: this.hostLabel.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                return socketDefault;
            }
        }
        else {
            return null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediasfuConference, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.Injector }, { token: UpdateMiniCardsGrid }, { token: MixStreams }, { token: DispStreams }, { token: StopShareScreen }, { token: CheckScreenShare }, { token: StartShareScreen }, { token: RequestScreenShare }, { token: ReorderStreams }, { token: PrepopulateUserMedia }, { token: GetVideos }, { token: RePort }, { token: Trigger }, { token: ConsumerResume }, { token: ConnectSendTransport }, { token: ConnectSendTransportAudio }, { token: ConnectSendTransportVideo }, { token: ConnectSendTransportScreen }, { token: ProcessConsumerTransports }, { token: ResumePauseStreams }, { token: Readjust }, { token: CheckGrid }, { token: GetEstimate }, { token: CalculateRowsAndColumns }, { token: AddVideosGrid }, { token: OnScreenChanges }, { token: ChangeVids }, { token: CompareActiveNames }, { token: CompareScreenStates }, { token: CreateSendTransport }, { token: ResumeSendTransportAudio }, { token: ReceiveAllPipedTransports }, { token: DisconnectSendTransportVideo }, { token: DisconnectSendTransportAudio }, { token: DisconnectSendTransportScreen }, { token: GetPipedProducersAlt }, { token: SignalNewConsumerTransport }, { token: ConnectRecvTransport }, { token: ReUpdateInter }, { token: UpdateParticipantAudioDecibels }, { token: CloseAndResize }, { token: AutoAdjust }, { token: SwitchUserVideoAlt }, { token: SwitchUserVideo }, { token: SwitchUserAudio }, { token: GetDomains }, { token: FormatNumber }, { token: ConnectIps }, { token: ConnectLocalIps }, { token: CreateDeviceClient }, { token: HandleCreatePoll }, { token: HandleEndPoll }, { token: HandleVotePoll }, { token: CaptureCanvasStream }, { token: ResumePauseAudioStreams }, { token: ProcessConsumerTransportsAudio }, { token: LaunchMenuModal }, { token: LaunchRecording }, { token: StartRecording }, { token: ConfirmRecording }, { token: LaunchWaiting }, { token: launchCoHost }, { token: LaunchMediaSettings }, { token: LaunchDisplaySettings }, { token: LaunchSettings }, { token: LaunchRequests }, { token: LaunchParticipants }, { token: LaunchMessages }, { token: LaunchConfirmExit }, { token: LaunchPoll }, { token: LaunchBreakoutRooms }, { token: LaunchConfigureWhiteboard }, { token: StartMeetingProgressTimer }, { token: UpdateRecording }, { token: StopRecording }, { token: UserWaiting }, { token: PersonJoined }, { token: AllWaitingRoomMembers }, { token: RoomRecordParams }, { token: BanParticipant }, { token: UpdatedCoHost }, { token: ParticipantRequested }, { token: ScreenProducerId }, { token: UpdateMediaSettings }, { token: ProducerMediaPaused }, { token: ProducerMediaResumed }, { token: ProducerMediaClosed }, { token: ControlMediaHost }, { token: MeetingEnded }, { token: DisconnectUserSelf }, { token: ReceiveMessage }, { token: MeetingTimeRemaining }, { token: MeetingStillThere }, { token: StartRecords }, { token: ReInitiateRecording }, { token: RecordingNotice }, { token: TimeLeftRecording }, { token: StoppedRecording }, { token: HostRequestResponse }, { token: AllMembers }, { token: AllMembersRest }, { token: Disconnect }, { token: PollUpdated }, { token: BreakoutRoomUpdated }, { token: SocketManager }, { token: JoinRoomClient }, { token: JoinLocalRoom }, { token: UpdateRoomParametersClient }, { token: ClickVideo }, { token: ClickAudio }, { token: ClickScreenShare }, { token: StreamSuccessVideo }, { token: StreamSuccessAudio }, { token: StreamSuccessScreen }, { token: StreamSuccessAudioSwitch }, { token: CheckPermission }, { token: UpdateConsumingDomains }, { token: ReceiveRoomMessages }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MediasfuConference, isStandalone: true, selector: "app-mediasfu-conference", inputs: { PrejoinPage: "PrejoinPage", localLink: "localLink", connectMediaSFU: "connectMediaSFU", credentials: "credentials", useLocalUIMode: "useLocalUIMode", seedData: "seedData", useSeed: "useSeed", imgSrc: "imgSrc", sourceParameters: "sourceParameters", updateSourceParameters: "updateSourceParameters", returnUI: "returnUI", noUIPreJoinOptions: "noUIPreJoinOptions", joinMediaSFURoom: "joinMediaSFURoom", createMediaSFURoom: "createMediaSFURoom" }, host: { listeners: { "window:resize": "handleResize()", "window:orientationchange": "handleResize()" } }, providers: [CookieService], ngImport: i0, template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component *ngIf="returnUI">
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <ng-container *ngIf="returnUI">
      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
        [localLink]="localLink"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
        [localLink]="localLink"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </ng-container>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: BreakoutRoomsModal, selector: "app-breakout-rooms-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onBreakoutRoomsClose"] }, { kind: "component", type: BackgroundModal, selector: "app-background-modal", inputs: ["isVisible", "parameters", "position", "backgroundColor", "onClose"] }, { kind: "component", type: CoHostModal, selector: "app-co-host-modal", inputs: ["isCoHostModalVisible", "currentCohost", "participants", "coHostResponsibility", "position", "backgroundColor", "roomName", "showAlert", "updateCoHostResponsibility", "updateCoHost", "updateIsCoHostModalVisible", "socket", "onCoHostClose", "onModifyCoHost"] }, { kind: "component", type: AlertComponent, selector: "app-alert-component", inputs: ["visible", "message", "type", "duration", "textColor", "onHide"] }, { kind: "component", type: AudioGrid, selector: "app-audio-grid", inputs: ["componentsToRender"] }, { kind: "component", type: ControlButtonsComponent, selector: "app-control-buttons-component", inputs: ["buttons", "buttonColor", "buttonBackgroundColor", "alignment", "vertical", "buttonsContainerStyle"] }, { kind: "component", type: FlexibleGrid, selector: "app-flexible-grid", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "backgroundColor"] }, { kind: "component", type: FlexibleVideo, selector: "app-flexible-video", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "showAspect", "backgroundColor", "Screenboard", "annotateScreenStream", "localStreamScreen"] }, { kind: "component", type: LoadingModal, selector: "app-loading-modal", inputs: ["isVisible", "backgroundColor", "displayColor"] }, { kind: "component", type: Pagination, selector: "app-pagination", inputs: ["totalPages", "currentUserPage", "handlePageChange", "position", "location", "direction", "buttonsContainerStyle", "activePageStyle", "inactivePageStyle", "backgroundColor", "paginationHeight", "showAspect", "parameters"] }, { kind: "component", type: SubAspectComponent, selector: "app-sub-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFractionSub"] }, { kind: "component", type: DisplaySettingsModal, selector: "app-display-settings-modal", inputs: ["isDisplaySettingsModalVisible", "onDisplaySettingsClose", "onModifyDisplaySettings", "parameters", "position", "backgroundColor"] }, { kind: "component", type: EventSettingsModal, selector: "app-event-settings-modal", inputs: ["isEventSettingsModalVisible", "onEventSettingsClose", "onModifyEventSettings", "position", "backgroundColor", "audioSetting", "videoSetting", "screenshareSetting", "chatSetting", "updateAudioSetting", "updateVideoSetting", "updateScreenshareSetting", "updateChatSetting", "updateIsSettingsModalVisible", "roomName", "socket", "showAlert"] }, { kind: "component", type: ConfirmExitModal, selector: "app-confirm-exit-modal", inputs: ["isConfirmExitModalVisible", "onConfirmExitClose", "position", "backgroundColor", "exitEventOnConfirm", "member", "ban", "roomName", "socket", "islevel"] }, { kind: "component", type: MediaSettingsModal, selector: "app-media-settings-modal", inputs: ["isMediaSettingsModalVisible", "onMediaSettingsClose", "switchCameraOnPress", "switchVideoOnPress", "switchAudioOnPress", "parameters", "position", "backgroundColor"] }, { kind: "component", type: MenuModal, selector: "app-menu-modal", inputs: ["backgroundColor", "isVisible", "customButtons", "shareButtons", "position", "roomName", "adminPasscode", "islevel", "eventType", "localLink", "onClose"] }, { kind: "component", type: MessagesModal, selector: "app-messages-modal", inputs: ["isMessagesModalVisible", "onMessagesClose", "onSendMessagePress", "messages", "position", "backgroundColor", "activeTabBackgroundColor", "eventType", "member", "islevel", "coHostResponsibility", "coHost", "startDirectMessage", "directMessageDetails", "updateStartDirectMessage", "updateDirectMessageDetails", "showAlert", "roomName", "socket", "chatSetting"] }, { kind: "component", type: ConfirmHereModal, selector: "app-confirm-here-modal", inputs: ["isConfirmHereModalVisible", "position", "backgroundColor", "displayColor", "onConfirmHereClose", "countdownDuration", "socket", "localSocket", "roomName", "member"] }, { kind: "component", type: ShareEventModal, selector: "app-share-event-modal", inputs: ["backgroundColor", "isShareEventModalVisible", "onShareEventClose", "roomName", "adminPasscode", "islevel", "position", "shareButtons", "eventType", "localLink"] }, { kind: "component", type: ParticipantsModal, selector: "app-participants-modal", inputs: ["isParticipantsModalVisible", "onParticipantsClose", "onParticipantsFilterChange", "participantsCounter", "onMuteParticipants", "onMessageParticipants", "onRemoveParticipants", "parameters", "position", "backgroundColor"] }, { kind: "component", type: PollModal, selector: "app-poll-modal", inputs: ["isPollModalVisible", "onClose", "position", "backgroundColor", "member", "islevel", "polls", "poll", "socket", "roomName", "showAlert", "updateIsPollModalVisible", "handleCreatePoll", "handleEndPoll", "handleVotePoll"] }, { kind: "component", type: RecordingModal, selector: "app-recording-modal", inputs: ["isRecordingModalVisible", "onClose", "backgroundColor", "position", "confirmRecording", "startRecording", "parameters"] }, { kind: "component", type: RequestsModal, selector: "app-requests-modal", inputs: ["isRequestsModalVisible", "requestCounter", "requestList", "roomName", "socket", "backgroundColor", "position", "parameters", "onRequestClose", "onRequestFilterChange", "onRequestItemPress", "updateRequestList"] }, { kind: "component", type: MainAspectComponent, selector: "app-main-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "updateIsWideScreen", "updateIsMediumScreen", "updateIsSmallScreen"] }, { kind: "component", type: MainContainerComponent, selector: "app-main-container-component", inputs: ["backgroundColor", "containerWidthFraction", "containerHeightFraction", "marginLeft", "marginRight", "marginTop", "marginBottom", "padding"] }, { kind: "component", type: MainGridComponent, selector: "app-main-grid-component", inputs: ["backgroundColor", "mainSize", "height", "width", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: MainScreenComponent, selector: "app-main-screen-component", inputs: ["mainSize", "doStack", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "showControls", "updateComponentSizes"] }, { kind: "component", type: OtherGridComponent, selector: "app-other-grid-component", inputs: ["backgroundColor", "width", "height", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }, { kind: "component", type: ScreenboardModal, selector: "app-screenboard-modal", inputs: ["parameters", "isVisible", "onClose", "position", "backgroundColor"] }, { kind: "component", type: Whiteboard, selector: "app-whiteboard", inputs: ["customWidth", "customHeight", "parameters", "showAspect"] }, { kind: "component", type: ConfigureWhiteboardModal, selector: "app-configure-whiteboard-modal", inputs: ["isVisible", "parameters", "backgroundColor", "position", "onConfigureWhiteboardClose"] }, { kind: "component", type: WaitingRoomModal, selector: "app-waiting-room-modal", inputs: ["isWaitingModalVisible", "waitingRoomCounter", "waitingRoomList", "roomName", "socket", "position", "backgroundColor", "parameters", "onWaitingRoomClose", "onWaitingRoomFilterChange", "updateWaitingList", "onWaitingRoomItemPress"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediasfuConference, decorators: [{
            type: Component,
            args: [{ selector: 'app-mediasfu-conference', imports: [
                        CommonModule,
                        BreakoutRoomsModal,
                        BackgroundModal,
                        CoHostModal,
                        AlertComponent,
                        AudioGrid,
                        ControlButtonsComponent,
                        FlexibleGrid,
                        FlexibleVideo,
                        LoadingModal,
                        Pagination,
                        SubAspectComponent,
                        DisplaySettingsModal,
                        EventSettingsModal,
                        ConfirmExitModal,
                        MediaSettingsModal,
                        MenuModal,
                        MessagesModal,
                        ConfirmHereModal,
                        ShareEventModal,
                        ParticipantsModal,
                        PollModal,
                        RecordingModal,
                        RequestsModal,
                        MainAspectComponent,
                        MainContainerComponent,
                        MainGridComponent,
                        MainScreenComponent,
                        OtherGridComponent,
                        ScreenboardModal,
                        Whiteboard,
                        ConfigureWhiteboardModal,
                        WaitingRoomModal,
                    ], template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component *ngIf="returnUI">
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <app-main-grid-component
                [height]="componentSizes.value.mainHeight"
                [width]="componentSizes.value.mainWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [mainSize]="mainHeightWidth.value"
                [showAspect]="mainHeightWidth.value > 0"
                [timeBackgroundColor]="recordState.value"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <app-flexible-video
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [rows]="1"
                  [columns]="1"
                  [componentsToRender]="mainGridStream.value"
                  [showAspect]="
                    mainGridStream.value.length > 0 &&
                    !(whiteboardStarted.value && !whiteboardEnded.value)
                  "
                  [localStreamScreen]="localStreamScreen.value!"
                  [annotateScreenStream]="annotateScreenStream.value"
                  [Screenboard]="shared.value ? ScreenboardWidget : undefined"
                >
                </app-flexible-video>
                <app-whiteboard
                  [customWidth]="componentSizes.value.mainWidth"
                  [customHeight]="componentSizes.value.mainHeight"
                  [parameters]="mediaSFUParameters"
                  [showAspect]="whiteboardStarted.value && !whiteboardEnded.value"
                ></app-whiteboard>
              </app-main-grid-component>

              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <div
                  *ngIf="doPaginate.value"
                  [ngStyle]="{
                    width:
                      paginationDirection.value == 'horizontal'
                        ? componentSizes.value.otherWidth
                        : paginationHeightWidth.value,
                    height:
                      paginationDirection.value == 'horizontal'
                        ? paginationHeightWidth.value
                        : componentSizes.value.otherHeight,
                    display: doPaginate.value ? 'flex' : 'none',
                    'flex-direction': paginationDirection.value == 'horizontal' ? 'row' : 'column',
                    'justify-content': 'center',
                    'align-items': 'center',
                    padding: '0',
                    margin: '0'
                  }"
                >
                  <app-pagination
                    [totalPages]="numberPages.value"
                    [currentUserPage]="currentUserPage.value"
                    [showAspect]="doPaginate.value"
                    [paginationHeight]="paginationHeightWidth.value"
                    [direction]="paginationDirection.value"
                    [parameters]="mediaSFUParameters"
                  ></app-pagination>
                </div>

                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
                <app-flexible-grid
                  [customWidth]="gridSizes.value.altGridWidth!"
                  [customHeight]="gridSizes.value.altGridHeight!"
                  [rows]="altGridRows.value"
                  [columns]="altGridCols.value"
                  [componentsToRender]="otherGridStreams.value[1]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <app-sub-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [defaultFractionSub]="controlHeight.value"
          >
            <app-control-buttons-component
              [buttons]="controlButtons"
              [buttonColor]="'black'"
              [buttonBackgroundColor]="{
                default: 'transparent',
                pressed: 'transparent'
              }"
              [alignment]="'space-between'"
              [vertical]="false"
              [buttonsContainerStyle]="{
                marginTop: '0',
                marginBottom: '0',
                backgroundColor: 'transparent'
              }"
            ></app-control-buttons-component>
          </app-sub-aspect-component>
        </app-main-container-component>
      </ng-template>

      <ng-container *ngIf="returnUI">
      <app-menu-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isVisible]="isMenuModalVisible.value"
        [onClose]="onCloseMenuModal"
        [customButtons]="customMenuButtons"
        [roomName]="roomName.value"
        [adminPasscode]="adminPasscode.value"
        [islevel]="islevel.value"
        [localLink]="localLink"
      ></app-menu-modal>

      <app-event-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isEventSettingsModalVisible]="isSettingsModalVisible.value"
        [onEventSettingsClose]="onEventSettingsClose"
        [audioSetting]="audioSetting.value"
        [videoSetting]="videoSetting.value"
        [screenshareSetting]="screenshareSetting.value"
        [chatSetting]="chatSetting.value"
        [updateAudioSetting]="updateAudioSetting"
        [updateVideoSetting]="updateVideoSetting"
        [updateScreenshareSetting]="updateScreenshareSetting"
        [updateChatSetting]="updateChatSetting"
        [updateIsSettingsModalVisible]="updateIsSettingsModalVisible"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [showAlert]="showAlert"
      ></app-event-settings-modal>

      <app-requests-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRequestsModalVisible]="isRequestsModalVisible.value"
        [onRequestClose]="onRequestClose"
        [requestCounter]="requestCounter.value"
        [onRequestFilterChange]="onRequestFilterChange"
        [updateRequestList]="updateRequestList"
        [requestList]="filteredRequestList.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="mediaSFUParameters"
      ></app-requests-modal>

      <app-waiting-room-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isWaitingModalVisible]="isWaitingModalVisible.value"
        [onWaitingRoomClose]="onWaitingRoomClose"
        [waitingRoomCounter]="waitingRoomCounter.value"
        [onWaitingRoomFilterChange]="onWaitingRoomFilterChange"
        [waitingRoomList]="filteredWaitingRoomList.value"
        [updateWaitingList]="updateWaitingRoomList"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [parameters]="{
                      filteredWaitingRoomList: waitingRoomList.value,
                      getUpdatedAllParams: getUpdatedAllParams,
                    }"
      ></app-waiting-room-modal>

      <app-co-host-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isCoHostModalVisible]="isCoHostModalVisible.value"
        [onCoHostClose]="onCoHostClose"
        [coHostResponsibility]="coHostResponsibility.value"
        [participants]="participants.value"
        [currentCohost]="coHost.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateCoHostResponsibility]="updateCoHostResponsibility"
        [updateCoHost]="updateCoHost"
        [updateIsCoHostModalVisible]="updateIsCoHostModalVisible"
        [socket]="socket.value"
      ></app-co-host-modal>

      <app-media-settings-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isMediaSettingsModalVisible]="isMediaSettingsModalVisible.value"
        [onMediaSettingsClose]="onMediaSettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-media-settings-modal>

      <app-participants-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isParticipantsModalVisible]="isParticipantsModalVisible.value"
        [onParticipantsClose]="onParticipantsClose"
        [participantsCounter]="participantsCounter.value"
        [onParticipantsFilterChange]="onParticipantsFilterChange"
        [parameters]="{
              updateParticipants: updateParticipants,
              filteredParticipants: filteredParticipants.value,
              updateIsParticipantsModalVisible: updateIsParticipantsModalVisible,
              updateDirectMessageDetails: updateDirectMessageDetails,
              updateStartDirectMessage: updateStartDirectMessage,
              updateIsMessagesModalVisible: updateIsMessagesModalVisible,
              showAlert: showAlert,
              participants: filteredParticipants.value,
              roomName: roomName.value,
              islevel: islevel.value,
              member: member.value,
              coHostResponsibility: coHostResponsibility.value,
              coHost: coHost.value,
              eventType: eventType.value,
              startDirectMessage: startDirectMessage.value,
              directMessageDetails: directMessageDetails.value,
              socket: socket.value,
              getUpdatedAllParams: getUpdatedAllParams,
            }"
      ></app-participants-modal>

      <app-display-settings-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isDisplaySettingsModalVisible]="isDisplaySettingsModalVisible.value"
        [onDisplaySettingsClose]="onDisplaySettingsClose"
        [parameters]="mediaSFUParameters"
      ></app-display-settings-modal>

      <app-recording-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isRecordingModalVisible]="isRecordingModalVisible.value"
        [onClose]="onRecordingClose"
        [startRecording]="startRecording.startRecording"
        [confirmRecording]="confirmRecording.confirmRecording"
        [parameters]="mediaSFUParameters"
      ></app-recording-modal>

      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
        [localLink]="localLink"
      ></app-share-event-modal>

      <app-poll-modal
        [isPollModalVisible]="isPollModalVisible.value"
        [onClose]="onPollClose"
        [member]="member.value"
        [islevel]="islevel.value"
        [polls]="polls.value"
        [poll]="poll.value"
        [socket]="socket.value"
        [roomName]="roomName.value"
        [showAlert]="showAlert"
        [updateIsPollModalVisible]="updateIsPollModalVisible"
        [handleCreatePoll]="handleCreatePoll.handleCreatePoll"
        [handleEndPoll]="handleEndPoll.handleEndPoll"
        [handleVotePoll]="handleVotePoll.handleVotePoll"
      ></app-poll-modal>

      <app-background-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBackgroundModalVisible.value"
        [onClose]="onBackgroundClose"
        [parameters]="mediaSFUParameters"
      ></app-background-modal>

      <app-breakout-rooms-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isBreakoutRoomsModalVisible.value"
        [onBreakoutRoomsClose]="onBreakoutRoomsClose"
        [parameters]="mediaSFUParameters"
      ></app-breakout-rooms-modal>

      <app-configure-whiteboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isConfigureWhiteboardModalVisible.value"
        [onConfigureWhiteboardClose]="onConfigureWhiteboardClose"
        [parameters]="mediaSFUParameters"
      ></app-configure-whiteboard-modal>

      <app-screenboard-modal
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        [isVisible]="isScreenboardModalVisible.value"
        [onClose]="onScreenboardClose"
        [parameters]="mediaSFUParameters"
      ></app-screenboard-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </ng-container>
    </div>
  `, providers: [CookieService] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: UpdateMiniCardsGrid }, { type: MixStreams }, { type: DispStreams }, { type: StopShareScreen }, { type: CheckScreenShare }, { type: StartShareScreen }, { type: RequestScreenShare }, { type: ReorderStreams }, { type: PrepopulateUserMedia }, { type: GetVideos }, { type: RePort }, { type: Trigger }, { type: ConsumerResume }, { type: ConnectSendTransport }, { type: ConnectSendTransportAudio }, { type: ConnectSendTransportVideo }, { type: ConnectSendTransportScreen }, { type: ProcessConsumerTransports }, { type: ResumePauseStreams }, { type: Readjust }, { type: CheckGrid }, { type: GetEstimate }, { type: CalculateRowsAndColumns }, { type: AddVideosGrid }, { type: OnScreenChanges }, { type: ChangeVids }, { type: CompareActiveNames }, { type: CompareScreenStates }, { type: CreateSendTransport }, { type: ResumeSendTransportAudio }, { type: ReceiveAllPipedTransports }, { type: DisconnectSendTransportVideo }, { type: DisconnectSendTransportAudio }, { type: DisconnectSendTransportScreen }, { type: GetPipedProducersAlt }, { type: SignalNewConsumerTransport }, { type: ConnectRecvTransport }, { type: ReUpdateInter }, { type: UpdateParticipantAudioDecibels }, { type: CloseAndResize }, { type: AutoAdjust }, { type: SwitchUserVideoAlt }, { type: SwitchUserVideo }, { type: SwitchUserAudio }, { type: GetDomains }, { type: FormatNumber }, { type: ConnectIps }, { type: ConnectLocalIps }, { type: CreateDeviceClient }, { type: HandleCreatePoll }, { type: HandleEndPoll }, { type: HandleVotePoll }, { type: CaptureCanvasStream }, { type: ResumePauseAudioStreams }, { type: ProcessConsumerTransportsAudio }, { type: LaunchMenuModal }, { type: LaunchRecording }, { type: StartRecording }, { type: ConfirmRecording }, { type: LaunchWaiting }, { type: launchCoHost }, { type: LaunchMediaSettings }, { type: LaunchDisplaySettings }, { type: LaunchSettings }, { type: LaunchRequests }, { type: LaunchParticipants }, { type: LaunchMessages }, { type: LaunchConfirmExit }, { type: LaunchPoll }, { type: LaunchBreakoutRooms }, { type: LaunchConfigureWhiteboard }, { type: StartMeetingProgressTimer }, { type: UpdateRecording }, { type: StopRecording }, { type: UserWaiting }, { type: PersonJoined }, { type: AllWaitingRoomMembers }, { type: RoomRecordParams }, { type: BanParticipant }, { type: UpdatedCoHost }, { type: ParticipantRequested }, { type: ScreenProducerId }, { type: UpdateMediaSettings }, { type: ProducerMediaPaused }, { type: ProducerMediaResumed }, { type: ProducerMediaClosed }, { type: ControlMediaHost }, { type: MeetingEnded }, { type: DisconnectUserSelf }, { type: ReceiveMessage }, { type: MeetingTimeRemaining }, { type: MeetingStillThere }, { type: StartRecords }, { type: ReInitiateRecording }, { type: RecordingNotice }, { type: TimeLeftRecording }, { type: StoppedRecording }, { type: HostRequestResponse }, { type: AllMembers }, { type: AllMembersRest }, { type: Disconnect }, { type: PollUpdated }, { type: BreakoutRoomUpdated }, { type: SocketManager }, { type: JoinRoomClient }, { type: JoinLocalRoom }, { type: UpdateRoomParametersClient }, { type: ClickVideo }, { type: ClickAudio }, { type: ClickScreenShare }, { type: StreamSuccessVideo }, { type: StreamSuccessAudio }, { type: StreamSuccessScreen }, { type: StreamSuccessAudioSwitch }, { type: CheckPermission }, { type: UpdateConsumingDomains }, { type: ReceiveRoomMessages }], propDecorators: { PrejoinPage: [{
                type: Input
            }], localLink: [{
                type: Input
            }], connectMediaSFU: [{
                type: Input
            }], credentials: [{
                type: Input
            }], useLocalUIMode: [{
                type: Input
            }], seedData: [{
                type: Input
            }], useSeed: [{
                type: Input
            }], imgSrc: [{
                type: Input
            }], sourceParameters: [{
                type: Input
            }], updateSourceParameters: [{
                type: Input
            }], returnUI: [{
                type: Input
            }], noUIPreJoinOptions: [{
                type: Input
            }], joinMediaSFURoom: [{
                type: Input
            }], createMediaSFURoom: [{
                type: Input
            }], handleResize: [{
                type: HostListener,
                args: ['window:resize']
            }, {
                type: HostListener,
                args: ['window:orientationchange']
            }] } });

/**
 * MediasfuChat component provides an interface for chat-based streaming events. It includes a conditional prejoin screen, main content with flexible grids and modals, and supports chat-related settings.
 *
 * @component
 * @selector app-mediasfu-chat
 * @standalone true
 * @imports [RouterOutlet, CommonModule, AlertComponent, AudioGrid, ControlButtonsComponentTouch, FlexibleGrid, LoadingModal, ConfirmExitModal, MessagesModal, ConfirmHereModal, ShareEventModal, WelcomePage, MainAspectComponent, MainContainerComponent, MainScreenComponent, OtherGridComponent, MessageWidget]
 *
 * @template
 * The template structure:
 * - Conditional rendering of a PrejoinPage or WelcomePage for introductory or pre-session screens.
 * - Main content area with nested components for grid layouts, flexible video, and audio grids.
 * - Modals for user interactions, including participant management, event settings, breakout rooms, whiteboarding, and media settings.
 *
 * @input {any} PrejoinPage - Component for the prejoin page, defaults to `WelcomePage`.
 * @input {MediasfuChatOptions} options - Configuration options for the component.
 * @input {boolean} connectMediaSFU - Flag to enable/disable connection to the MediaSFU server.
 * @input {string} localLink - Local link for the Community Edition server.
 * @input {{ apiUserName: string; apiKey: string }} credentials - API credentials for secure access.
 * @input {boolean} useLocalUIMode - Flag to toggle local UI settings.
 * @input {SeedData} seedData - Seed data for initializing the component with specific configurations.
 * @input {boolean} useSeed - Enable/disable use of seed data.
 * @input {string} imgSrc - URL for branding images or logos.
 * @input {object} sourceParameters - Additional parameters for the source.
 * @input {Function} updateSourceParameters - Function to update the source parameters.
 * @input {boolean} returnUI - Flag to return the UI elements.
 * @input {CreateMediaSFURoomOptions | JoinMediaSFURoomOptions} noUIPreJoinOptions - Options for the prejoin page without UI.
 * @input {JoinRoomOnMediaSFUType} joinMediaSFURoom - Function to join a room on MediaSFU.
 * @input {CreateRoomOnMediaSFUType} createMediaSFURoom - Function to create a room on MediaSFU.
 *
 * @property {string} title - The title of the component, defaults to "MediaSFU-Chat".
 *
 * @styles
 * Customizable styles for layout and overflow.
 *
 * @providers [CookieService] - Service for managing cookies within the component.
 *
 * @constructor
 * @class MediasfuChat
 * @implements OnInit, OnDestroy
 *
 * @method ngOnInit - Initializes configurations and parameters.
 * @method ngOnDestroy - Handles cleanup and removal of event listeners or intervals.
 *
 * @example
 * ```html
 * <app-mediasfu-chat
 *   [PrejoinPage]="CustomPrejoinComponent"
 *   [localLink]="'https://localhost:3000'"
 *   [connectMediaSFU]="true"
 *   [credentials]="{ apiUserName: 'username', apiKey: 'apikey' }"
 *   [useLocalUIMode]="true"
 *   [seedData]="seedDataObject"
 *   [useSeed]="true"
 *   [imgSrc]="https://example.com/logo.png">
 *   [sourceParameters]="{ source: 'camera', width: 640, height: 480 }"
 *   [updateSourceParameters]="updateSourceParameters"
 *   [returnUI]="true"
 *   [noUIPreJoinOptions]="{ roomName: 'room1', userName: 'user1' }"
 *   [joinMediaSFURoom]="joinMediaSFURoom"
 *   [createMediaSFURoom]="createMediaSFURoom">
 * </app-mediasfu-chat>
 * ```
 */
class MediasfuChat {
    cdr;
    injector;
    updateMiniCardsGrid;
    mixStreams;
    dispStreams;
    stopShareScreen;
    checkScreenShare;
    startShareScreen;
    requestScreenShare;
    reorderStreams;
    prepopulateUserMedia;
    getVideos;
    rePort;
    trigger;
    consumerResume;
    connectSendTransport;
    connectSendTransportAudio;
    connectSendTransportVideo;
    connectSendTransportScreen;
    processConsumerTransports;
    resumePauseStreams;
    readjust;
    checkGrid;
    getEstimate;
    calculateRowsAndColumns;
    addVideosGrid;
    onScreenChanges;
    changeVids;
    compareActiveNames;
    compareScreenStates;
    createSendTransport;
    resumeSendTransportAudio;
    receiveAllPipedTransports;
    disconnectSendTransportVideo;
    disconnectSendTransportAudio;
    disconnectSendTransportScreen;
    getPipedProducersAlt;
    signalNewConsumerTransport;
    connectRecvTransport;
    reUpdateInter;
    updateParticipantAudioDecibels;
    closeAndResize;
    autoAdjust;
    switchUserVideoAlt;
    switchUserVideo;
    switchUserAudio;
    getDomains;
    formatNumber;
    connectIps;
    connectLocalIps;
    createDeviceClient;
    captureCanvasStream;
    resumePauseAudioStreams;
    processConsumerTransportsAudio;
    launchMessages;
    launchConfirmExit;
    startMeetingProgressTimer;
    producerMediaPaused;
    producerMediaResumed;
    producerMediaClosed;
    meetingEnded;
    disconnectUserSelf;
    receiveMessage;
    meetingTimeRemaining;
    meetingStillThere;
    allMembers;
    allMembersRest;
    disconnect;
    socketManager;
    joinRoomClient;
    joinLocalRoom;
    updateRoomParametersClient;
    clickVideo;
    clickAudio;
    clickScreenShare;
    switchVideoAlt;
    streamSuccessVideo;
    streamSuccessAudio;
    streamSuccessScreen;
    streamSuccessAudioSwitch;
    checkPermission;
    updateConsumingDomains;
    receiveRoomMessages;
    PrejoinPage = WelcomePage;
    localLink = '';
    connectMediaSFU = true;
    credentials = { apiUserName: '', apiKey: '' };
    useLocalUIMode = false;
    seedData;
    useSeed = false;
    imgSrc = 'https://mediasfu.com/images/logo192.png';
    sourceParameters = {};
    updateSourceParameters = (data) => { };
    returnUI = true;
    noUIPreJoinOptions;
    joinMediaSFURoom;
    createMediaSFURoom;
    title = 'MediaSFU-Chat';
    mainHeightWidthSubscription;
    validatedSubscription;
    islevelSubscription;
    coHostSubscription;
    ScreenboardSubscription;
    recordingSubscription;
    constructor(cdr, injector, updateMiniCardsGrid, mixStreams, dispStreams, stopShareScreen, checkScreenShare, startShareScreen, requestScreenShare, reorderStreams, prepopulateUserMedia, getVideos, rePort, trigger, consumerResume, connectSendTransport, connectSendTransportAudio, connectSendTransportVideo, connectSendTransportScreen, processConsumerTransports, resumePauseStreams, readjust, checkGrid, getEstimate, calculateRowsAndColumns, addVideosGrid, onScreenChanges, changeVids, compareActiveNames, compareScreenStates, createSendTransport, resumeSendTransportAudio, receiveAllPipedTransports, disconnectSendTransportVideo, disconnectSendTransportAudio, disconnectSendTransportScreen, getPipedProducersAlt, signalNewConsumerTransport, connectRecvTransport, reUpdateInter, updateParticipantAudioDecibels, closeAndResize, autoAdjust, switchUserVideoAlt, switchUserVideo, switchUserAudio, getDomains, formatNumber, connectIps, connectLocalIps, createDeviceClient, captureCanvasStream, resumePauseAudioStreams, processConsumerTransportsAudio, launchMessages, launchConfirmExit, startMeetingProgressTimer, producerMediaPaused, producerMediaResumed, producerMediaClosed, meetingEnded, disconnectUserSelf, receiveMessage, meetingTimeRemaining, meetingStillThere, allMembers, allMembersRest, disconnect, socketManager, joinRoomClient, joinLocalRoom, updateRoomParametersClient, clickVideo, clickAudio, clickScreenShare, switchVideoAlt, streamSuccessVideo, streamSuccessAudio, streamSuccessScreen, streamSuccessAudioSwitch, checkPermission, updateConsumingDomains, receiveRoomMessages) {
        this.cdr = cdr;
        this.injector = injector;
        this.updateMiniCardsGrid = updateMiniCardsGrid;
        this.mixStreams = mixStreams;
        this.dispStreams = dispStreams;
        this.stopShareScreen = stopShareScreen;
        this.checkScreenShare = checkScreenShare;
        this.startShareScreen = startShareScreen;
        this.requestScreenShare = requestScreenShare;
        this.reorderStreams = reorderStreams;
        this.prepopulateUserMedia = prepopulateUserMedia;
        this.getVideos = getVideos;
        this.rePort = rePort;
        this.trigger = trigger;
        this.consumerResume = consumerResume;
        this.connectSendTransport = connectSendTransport;
        this.connectSendTransportAudio = connectSendTransportAudio;
        this.connectSendTransportVideo = connectSendTransportVideo;
        this.connectSendTransportScreen = connectSendTransportScreen;
        this.processConsumerTransports = processConsumerTransports;
        this.resumePauseStreams = resumePauseStreams;
        this.readjust = readjust;
        this.checkGrid = checkGrid;
        this.getEstimate = getEstimate;
        this.calculateRowsAndColumns = calculateRowsAndColumns;
        this.addVideosGrid = addVideosGrid;
        this.onScreenChanges = onScreenChanges;
        this.changeVids = changeVids;
        this.compareActiveNames = compareActiveNames;
        this.compareScreenStates = compareScreenStates;
        this.createSendTransport = createSendTransport;
        this.resumeSendTransportAudio = resumeSendTransportAudio;
        this.receiveAllPipedTransports = receiveAllPipedTransports;
        this.disconnectSendTransportVideo = disconnectSendTransportVideo;
        this.disconnectSendTransportAudio = disconnectSendTransportAudio;
        this.disconnectSendTransportScreen = disconnectSendTransportScreen;
        this.getPipedProducersAlt = getPipedProducersAlt;
        this.signalNewConsumerTransport = signalNewConsumerTransport;
        this.connectRecvTransport = connectRecvTransport;
        this.reUpdateInter = reUpdateInter;
        this.updateParticipantAudioDecibels = updateParticipantAudioDecibels;
        this.closeAndResize = closeAndResize;
        this.autoAdjust = autoAdjust;
        this.switchUserVideoAlt = switchUserVideoAlt;
        this.switchUserVideo = switchUserVideo;
        this.switchUserAudio = switchUserAudio;
        this.getDomains = getDomains;
        this.formatNumber = formatNumber;
        this.connectIps = connectIps;
        this.connectLocalIps = connectLocalIps;
        this.createDeviceClient = createDeviceClient;
        this.captureCanvasStream = captureCanvasStream;
        this.resumePauseAudioStreams = resumePauseAudioStreams;
        this.processConsumerTransportsAudio = processConsumerTransportsAudio;
        this.launchMessages = launchMessages;
        this.launchConfirmExit = launchConfirmExit;
        this.startMeetingProgressTimer = startMeetingProgressTimer;
        this.producerMediaPaused = producerMediaPaused;
        this.producerMediaResumed = producerMediaResumed;
        this.producerMediaClosed = producerMediaClosed;
        this.meetingEnded = meetingEnded;
        this.disconnectUserSelf = disconnectUserSelf;
        this.receiveMessage = receiveMessage;
        this.meetingTimeRemaining = meetingTimeRemaining;
        this.meetingStillThere = meetingStillThere;
        this.allMembers = allMembers;
        this.allMembersRest = allMembersRest;
        this.disconnect = disconnect;
        this.socketManager = socketManager;
        this.joinRoomClient = joinRoomClient;
        this.joinLocalRoom = joinLocalRoom;
        this.updateRoomParametersClient = updateRoomParametersClient;
        this.clickVideo = clickVideo;
        this.clickAudio = clickAudio;
        this.clickScreenShare = clickScreenShare;
        this.switchVideoAlt = switchVideoAlt;
        this.streamSuccessVideo = streamSuccessVideo;
        this.streamSuccessAudio = streamSuccessAudio;
        this.streamSuccessScreen = streamSuccessScreen;
        this.streamSuccessAudioSwitch = streamSuccessAudioSwitch;
        this.checkPermission = checkPermission;
        this.updateConsumingDomains = updateConsumingDomains;
        this.receiveRoomMessages = receiveRoomMessages;
    }
    createInjector(inputs) {
        const inj = Injector.create({
            providers: Object.keys(inputs).map((key) => ({ provide: key, useValue: inputs[key] })),
            parent: this.injector,
        });
        return inj;
    }
    // Initial values
    mediaSFUFunctions = () => {
        return {
            updateMiniCardsGrid: this.updateMiniCardsGrid?.updateMiniCardsGrid ||
                (() => {
                    console.log('none');
                }),
            mixStreams: this.mixStreams?.mixStreams ||
                (() => {
                    console.log('none');
                }),
            dispStreams: this.dispStreams?.dispStreams ||
                (() => {
                    console.log('none');
                }),
            stopShareScreen: this.stopShareScreen?.stopShareScreen ||
                (() => {
                    console.log('none');
                }),
            checkScreenShare: this.checkScreenShare?.checkScreenShare ||
                (() => {
                    console.log('none');
                }),
            startShareScreen: this.startShareScreen?.startShareScreen ||
                (() => {
                    console.log('none');
                }),
            requestScreenShare: this.requestScreenShare?.requestScreenShare ||
                (() => {
                    console.log('none');
                }),
            reorderStreams: this.reorderStreams?.reorderStreams ||
                (() => {
                    console.log('none');
                }),
            prepopulateUserMedia: this.prepopulateUserMedia?.prepopulateUserMedia ||
                (() => {
                    console.log('none');
                }),
            getVideos: this.getVideos?.getVideos ||
                (() => {
                    console.log('none');
                }),
            rePort: this.rePort?.rePort ||
                (() => {
                    console.log('none');
                }),
            trigger: this.trigger?.trigger ||
                (() => {
                    console.log('none');
                }),
            consumerResume: this.consumerResume?.consumerResume ||
                (() => {
                    console.log('none');
                }),
            connectSendTransport: this.connectSendTransport?.connectSendTransport ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportAudio: this.connectSendTransportAudio?.connectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportVideo: this.connectSendTransportVideo?.connectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            connectSendTransportScreen: this.connectSendTransportScreen?.connectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransports: this.processConsumerTransports?.processConsumerTransports ||
                (() => {
                    console.log('none');
                }),
            resumePauseStreams: this.resumePauseStreams?.resumePauseStreams ||
                (() => {
                    console.log('none');
                }),
            readjust: this.readjust?.readjust ||
                (() => {
                    console.log('none');
                }),
            checkGrid: this.checkGrid?.checkGrid ||
                (() => {
                    console.log('none');
                }),
            getEstimate: this.getEstimate?.getEstimate ||
                (() => {
                    console.log('none');
                }),
            calculateRowsAndColumns: this.calculateRowsAndColumns?.calculateRowsAndColumns ||
                (() => {
                    console.log('none');
                }),
            addVideosGrid: this.addVideosGrid?.addVideosGrid ||
                (() => {
                    console.log('none');
                }),
            onScreenChanges: this.onScreenChanges?.onScreenChanges ||
                (() => {
                    console.log('none');
                }),
            sleep: sleep ||
                (() => {
                    console.log('none');
                }),
            changeVids: this.changeVids?.changeVids ||
                (() => {
                    console.log('none');
                }),
            compareActiveNames: this.compareActiveNames?.compareActiveNames ||
                (() => {
                    console.log('none');
                }),
            compareScreenStates: this.compareScreenStates?.compareScreenStates ||
                (() => {
                    console.log('none');
                }),
            createSendTransport: this.createSendTransport?.createSendTransport ||
                (() => {
                    console.log('none');
                }),
            resumeSendTransportAudio: this.resumeSendTransportAudio?.resumeSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            receiveAllPipedTransports: this.receiveAllPipedTransports?.receiveAllPipedTransports ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportVideo: this.disconnectSendTransportVideo?.disconnectSendTransportVideo ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportAudio: this.disconnectSendTransportAudio?.disconnectSendTransportAudio ||
                (() => {
                    console.log('none');
                }),
            disconnectSendTransportScreen: this.disconnectSendTransportScreen?.disconnectSendTransportScreen ||
                (() => {
                    console.log('none');
                }),
            getPipedProducersAlt: this.getPipedProducersAlt?.getPipedProducersAlt ||
                (() => {
                    console.log('none');
                }),
            signalNewConsumerTransport: this.signalNewConsumerTransport?.signalNewConsumerTransport ||
                (() => {
                    console.log('none');
                }),
            connectRecvTransport: this.connectRecvTransport?.connectRecvTransport ||
                (() => {
                    console.log('none');
                }),
            reUpdateInter: this.reUpdateInter?.reUpdateInter ||
                (() => {
                    console.log('none');
                }),
            updateParticipantAudioDecibels: this.updateParticipantAudioDecibels?.updateParticipantAudioDecibels ||
                (() => {
                    console.log('none');
                }),
            closeAndResize: this.closeAndResize?.closeAndResize ||
                (() => {
                    console.log('none');
                }),
            autoAdjust: this.autoAdjust?.autoAdjust ||
                (() => {
                    console.log('none');
                }),
            switchUserVideoAlt: this.switchUserVideoAlt?.switchUserVideoAlt ||
                (() => {
                    console.log('none');
                }),
            switchUserVideo: this.switchUserVideo?.switchUserVideo ||
                (() => {
                    console.log('none');
                }),
            switchUserAudio: this.switchUserAudio?.switchUserAudio ||
                (() => {
                    console.log('none');
                }),
            getDomains: this.getDomains?.getDomains ||
                (() => {
                    console.log('none');
                }),
            formatNumber: this.formatNumber?.formatNumber ||
                (() => {
                    console.log('none');
                }),
            connectIps: this.connectIps?.connectIps ||
                (() => {
                    console.log('none');
                }),
            connectLocalIps: this.connectLocalIps?.connectLocalIps ||
                (() => {
                    console.log('none');
                }),
            createDeviceClient: this.createDeviceClient?.createDeviceClient ||
                (() => {
                    console.log('none');
                }),
            captureCanvasStream: this.captureCanvasStream?.captureCanvasStream ||
                (() => {
                    console.log('none');
                }),
            resumePauseAudioStreams: this.resumePauseAudioStreams?.resumePauseAudioStreams ||
                (() => {
                    console.log('none');
                }),
            processConsumerTransportsAudio: this.processConsumerTransportsAudio?.processConsumerTransportsAudio ||
                (() => {
                    console.log('none');
                }),
            checkPermission: this.checkPermission?.checkPermission ||
                (() => {
                    console.log('none');
                }),
            streamSuccessVideo: this.streamSuccessVideo?.streamSuccessVideo ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudio: this.streamSuccessAudio?.streamSuccessAudio ||
                (() => {
                    console.log('none');
                }),
            streamSuccessScreen: this.streamSuccessScreen?.streamSuccessScreen ||
                (() => {
                    console.log('none');
                }),
            streamSuccessAudioSwitch: this.streamSuccessAudioSwitch?.streamSuccessAudioSwitch ||
                (() => {
                    console.log('none');
                }),
            clickVideo: this.clickVideo?.clickVideo ||
                (() => {
                    console.log('none');
                }),
            clickAudio: this.clickAudio?.clickAudio ||
                (() => {
                    console.log('none');
                }),
            clickScreenShare: this.clickScreenShare?.clickScreenShare ||
                (() => {
                    console.log('none');
                }),
            switchVideoAlt: this.switchVideoAlt?.switchVideoAlt ||
                (() => {
                    console.log('none');
                }),
            requestPermissionCamera: this.requestPermissionCamera ||
                (() => {
                    console.log('none');
                }),
            requestPermissionAudio: this.requestPermissionAudio ||
                (() => {
                    console.log('none');
                }),
        };
    };
    validated = new BehaviorSubject$1(false);
    localUIMode = new BehaviorSubject$1(false);
    socket = new BehaviorSubject$1({});
    localSocket = new BehaviorSubject$1(undefined);
    roomData = new BehaviorSubject$1(null);
    device = new BehaviorSubject$1(null);
    apiKey = new BehaviorSubject$1('');
    apiUserName = new BehaviorSubject$1('');
    apiToken = new BehaviorSubject$1('');
    link = new BehaviorSubject$1('');
    roomName = new BehaviorSubject$1('');
    member = new BehaviorSubject$1('');
    adminPasscode = new BehaviorSubject$1('');
    islevel = new BehaviorSubject$1('1');
    coHost = new BehaviorSubject$1('No coHost');
    coHostResponsibility = new BehaviorSubject$1([
        { name: 'participants', value: false, dedicated: false },
        { name: 'media', value: false, dedicated: false },
        { name: 'waiting', value: false, dedicated: false },
        { name: 'chat', value: false, dedicated: false },
    ]);
    youAreCoHost = new BehaviorSubject$1(false);
    youAreHost = new BehaviorSubject$1(false);
    confirmedToRecord = new BehaviorSubject$1(false);
    meetingDisplayType = new BehaviorSubject$1('media');
    meetingVideoOptimized = new BehaviorSubject$1(false);
    eventType = new BehaviorSubject$1('chat');
    participants = new BehaviorSubject$1([]);
    filteredParticipants = new BehaviorSubject$1([]);
    participantsCounter = new BehaviorSubject$1(0);
    participantsFilter = new BehaviorSubject$1('');
    consume_sockets = new BehaviorSubject$1([]);
    rtpCapabilities = new BehaviorSubject$1(null);
    roomRecvIPs = new BehaviorSubject$1([]);
    meetingRoomParams = new BehaviorSubject$1(null);
    itemPageLimit = new BehaviorSubject$1(4);
    audioOnlyRoom = new BehaviorSubject$1(false);
    addForBasic = new BehaviorSubject$1(false);
    screenPageLimit = new BehaviorSubject$1(4);
    shareScreenStarted = new BehaviorSubject$1(false);
    shared = new BehaviorSubject$1(false);
    targetOrientation = new BehaviorSubject$1('landscape');
    targetResolution = new BehaviorSubject$1('sd');
    targetResolutionHost = new BehaviorSubject$1('sd');
    vidCons = new BehaviorSubject$1({ width: 640, height: 360 });
    frameRate = new BehaviorSubject$1(10);
    hParams = new BehaviorSubject$1({});
    vParams = new BehaviorSubject$1({});
    screenParams = new BehaviorSubject$1({});
    aParams = new BehaviorSubject$1({});
    recordingAudioPausesLimit = new BehaviorSubject$1(0);
    recordingAudioPausesCount = new BehaviorSubject$1(0);
    recordingAudioSupport = new BehaviorSubject$1(false);
    recordingAudioPeopleLimit = new BehaviorSubject$1(0);
    recordingAudioParticipantsTimeLimit = new BehaviorSubject$1(0);
    recordingVideoPausesCount = new BehaviorSubject$1(0);
    recordingVideoPausesLimit = new BehaviorSubject$1(0);
    recordingVideoSupport = new BehaviorSubject$1(false);
    recordingVideoPeopleLimit = new BehaviorSubject$1(0);
    recordingVideoParticipantsTimeLimit = new BehaviorSubject$1(0);
    recordingAllParticipantsSupport = new BehaviorSubject$1(false);
    recordingVideoParticipantsSupport = new BehaviorSubject$1(false);
    recordingAllParticipantsFullRoomSupport = new BehaviorSubject$1(false);
    recordingVideoParticipantsFullRoomSupport = new BehaviorSubject$1(false);
    recordingPreferredOrientation = new BehaviorSubject$1('landscape');
    recordingSupportForOtherOrientation = new BehaviorSubject$1(false);
    recordingMultiFormatsSupport = new BehaviorSubject$1(false);
    userRecordingParams = new BehaviorSubject$1({
        mainSpecs: {
            mediaOptions: 'video', // 'audio', 'video'
            audioOptions: 'all', // 'all', 'onScreen', 'host'
            videoOptions: 'all', // 'all', 'mainScreen'
            videoType: 'fullDisplay', // 'all', 'bestDisplay', 'fullDisplay'
            videoOptimized: false, // true, false
            recordingDisplayType: 'media', // 'media', 'video', 'all'
            addHLS: false, // true, false
        },
        dispSpecs: {
            nameTags: true, // true, false
            backgroundColor: '#000000', // '#000000', '#ffffff'
            nameTagsColor: '#ffffff', // '#000000', '#ffffff'
            orientationVideo: 'portrait', // 'landscape', 'portrait', 'all'
        },
    });
    canRecord = new BehaviorSubject$1(false);
    startReport = new BehaviorSubject$1(false);
    endReport = new BehaviorSubject$1(false);
    recordTimerInterval = new BehaviorSubject$1(null);
    recordStartTime = new BehaviorSubject$1(0);
    recordElapsedTime = new BehaviorSubject$1(0);
    isTimerRunning = new BehaviorSubject$1(false);
    canPauseResume = new BehaviorSubject$1(false);
    recordChangeSeconds = new BehaviorSubject$1(15000);
    pauseLimit = new BehaviorSubject$1(0);
    pauseRecordCount = new BehaviorSubject$1(0);
    canLaunchRecord = new BehaviorSubject$1(true);
    stopLaunchRecord = new BehaviorSubject$1(false);
    participantsAll = new BehaviorSubject$1([]);
    firstAll = new BehaviorSubject$1(false);
    updateMainWindow = new BehaviorSubject$1(false);
    first_round = new BehaviorSubject$1(false);
    landScaped = new BehaviorSubject$1(false);
    lock_screen = new BehaviorSubject$1(false);
    screenId = new BehaviorSubject$1('');
    allVideoStreams = new BehaviorSubject$1([]);
    newLimitedStreams = new BehaviorSubject$1([]);
    newLimitedStreamsIDs = new BehaviorSubject$1([]);
    activeSounds = new BehaviorSubject$1([]);
    screenShareIDStream = new BehaviorSubject$1('');
    screenShareNameStream = new BehaviorSubject$1('');
    adminIDStream = new BehaviorSubject$1('');
    adminNameStream = new BehaviorSubject$1('');
    youYouStream = new BehaviorSubject$1([]);
    youYouStreamIDs = new BehaviorSubject$1([]);
    localStream = new BehaviorSubject$1(null);
    recordStarted = new BehaviorSubject$1(false);
    recordResumed = new BehaviorSubject$1(false);
    recordPaused = new BehaviorSubject$1(false);
    recordStopped = new BehaviorSubject$1(false);
    adminRestrictSetting = new BehaviorSubject$1(false);
    videoRequestState = new BehaviorSubject$1(null);
    videoRequestTime = new BehaviorSubject$1(0);
    videoAction = new BehaviorSubject$1(false);
    localStreamVideo = new BehaviorSubject$1(null);
    userDefaultVideoInputDevice = new BehaviorSubject$1('');
    currentFacingMode = new BehaviorSubject$1('user');
    prevFacingMode = new BehaviorSubject$1('user');
    defVideoID = new BehaviorSubject$1('');
    allowed = new BehaviorSubject$1(false);
    dispActiveNames = new BehaviorSubject$1([]);
    p_dispActiveNames = new BehaviorSubject$1([]);
    activeNames = new BehaviorSubject$1([]);
    prevActiveNames = new BehaviorSubject$1([]);
    p_activeNames = new BehaviorSubject$1([]);
    membersReceived = new BehaviorSubject$1(false);
    deferScreenReceived = new BehaviorSubject$1(false);
    hostFirstSwitch = new BehaviorSubject$1(false);
    micAction = new BehaviorSubject$1(false);
    screenAction = new BehaviorSubject$1(false);
    chatAction = new BehaviorSubject$1(false);
    audioRequestState = new BehaviorSubject$1(null);
    screenRequestState = new BehaviorSubject$1(null);
    chatRequestState = new BehaviorSubject$1(null);
    audioRequestTime = new BehaviorSubject$1(0);
    screenRequestTime = new BehaviorSubject$1(0);
    chatRequestTime = new BehaviorSubject$1(0);
    updateRequestIntervalSeconds = new BehaviorSubject$1(240);
    oldSoundIds = new BehaviorSubject$1([]);
    hostLabel = new BehaviorSubject$1('Host');
    mainScreenFilled = new BehaviorSubject$1(false);
    localStreamScreen = new BehaviorSubject$1(null);
    screenAlreadyOn = new BehaviorSubject$1(false);
    chatAlreadyOn = new BehaviorSubject$1(false);
    redirectURL = new BehaviorSubject$1('');
    oldAllStreams = new BehaviorSubject$1([]);
    adminVidID = new BehaviorSubject$1('');
    streamNames = new BehaviorSubject$1([]);
    non_alVideoStreams = new BehaviorSubject$1([]);
    sortAudioLoudness = new BehaviorSubject$1(false);
    audioDecibels = new BehaviorSubject$1([]);
    mixed_alVideoStreams = new BehaviorSubject$1([]);
    non_alVideoStreams_muted = new BehaviorSubject$1([]);
    paginatedStreams = new BehaviorSubject$1([]);
    localStreamAudio = new BehaviorSubject$1(null);
    defAudioID = new BehaviorSubject$1('');
    userDefaultAudioInputDevice = new BehaviorSubject$1('');
    userDefaultAudioOutputDevice = new BehaviorSubject$1('');
    prevAudioInputDevice = new BehaviorSubject$1('');
    prevVideoInputDevice = new BehaviorSubject$1('');
    audioPaused = new BehaviorSubject$1(false);
    mainScreenPerson = new BehaviorSubject$1('');
    adminOnMainScreen = new BehaviorSubject$1(false);
    screenStates = new BehaviorSubject$1([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    prevScreenStates = new BehaviorSubject$1([
        {
            mainScreenPerson: '',
            mainScreenProducerId: '',
            mainScreenFilled: false,
            adminOnMainScreen: false,
        },
    ]);
    updateDateState = new BehaviorSubject$1(null);
    lastUpdate = new BehaviorSubject$1(null);
    nForReadjustRecord = new BehaviorSubject$1(0);
    fixedPageLimit = new BehaviorSubject$1(4);
    removeAltGrid = new BehaviorSubject$1(false);
    nForReadjust = new BehaviorSubject$1(0);
    reorderInterval = new BehaviorSubject$1(30000);
    fastReorderInterval = new BehaviorSubject$1(10000);
    lastReorderTime = new BehaviorSubject$1(0);
    audStreamNames = new BehaviorSubject$1([]);
    currentUserPage = new BehaviorSubject$1(0);
    mainHeightWidth = new BehaviorSubject$1(0);
    prevMainHeightWidth = new BehaviorSubject$1(this.mainHeightWidth.value);
    prevDoPaginate = new BehaviorSubject$1(false);
    doPaginate = new BehaviorSubject$1(false);
    shareEnded = new BehaviorSubject$1(false);
    lStreams = new BehaviorSubject$1([]);
    chatRefStreams = new BehaviorSubject$1([]);
    controlHeight = new BehaviorSubject$1(this.eventType.value === 'webinar' || this.eventType.value === 'conference' ? 0 : 0.06);
    isWideScreen = new BehaviorSubject$1(false);
    isMediumScreen = new BehaviorSubject$1(false);
    isSmallScreen = new BehaviorSubject$1(false);
    addGrid = new BehaviorSubject$1(false);
    addAltGrid = new BehaviorSubject$1(false);
    gridRows = new BehaviorSubject$1(0);
    gridCols = new BehaviorSubject$1(0);
    altGridRows = new BehaviorSubject$1(0);
    altGridCols = new BehaviorSubject$1(0);
    numberPages = new BehaviorSubject$1(0);
    currentStreams = new BehaviorSubject$1([]);
    showMiniView = new BehaviorSubject$1(false);
    nStream = new BehaviorSubject$1(null);
    defer_receive = new BehaviorSubject$1(false);
    allAudioStreams = new BehaviorSubject$1([]);
    remoteScreenStream = new BehaviorSubject$1([]);
    screenProducer = new BehaviorSubject$1(null);
    localScreenProducer = new BehaviorSubject$1(null);
    gotAllVids = new BehaviorSubject$1(false);
    paginationHeightWidth = new BehaviorSubject$1(40);
    paginationDirection = new BehaviorSubject$1('horizontal');
    gridSizes = new BehaviorSubject$1({
        gridWidth: 0,
        gridHeight: 0,
        altGridWidth: 0,
        altGridHeight: 0,
    });
    screenForceFullDisplay = new BehaviorSubject$1(false);
    mainGridStream = new BehaviorSubject$1([]);
    otherGridStreams = new BehaviorSubject$1([]);
    audioOnlyStreams = new BehaviorSubject$1([]);
    videoInputs = new BehaviorSubject$1([]);
    audioInputs = new BehaviorSubject$1([]);
    meetingProgressTime = new BehaviorSubject$1('00:00:00');
    meetingElapsedTime = new BehaviorSubject$1(0);
    ref_participants = new BehaviorSubject$1([]);
    updateValidated = (value) => {
        this.validated.next(value);
    };
    updateSocket = (value) => {
        this.socket.next(value);
    };
    updateLocalSocket = (value) => {
        this.localSocket.next(value);
    };
    updateDevice = (value) => {
        this.device.next(value);
    };
    updateRoomData = (value) => {
        this.roomData.next(value);
    };
    updateApiKey = (value) => {
        this.apiKey.next(value);
    };
    updateApiUserName = (value) => {
        this.apiUserName.next(value);
    };
    updateApiToken = (value) => {
        this.apiToken.next(value);
    };
    updateLink = (value) => {
        this.link.next(value);
    };
    updateRoomName = (value) => {
        this.roomName.next(value);
    };
    updateMember = (value) => {
        if (value.length > 0 && value.includes("_")) {
            this.updateIslevel(value.split("_")[1]);
            value = value.split("_")[0];
        }
        this.member.next(value);
    };
    updateAdminPasscode = (value) => {
        this.adminPasscode.next(value);
    };
    updateIslevel = (value) => {
        this.islevel.next(value);
    };
    updateCoHost = (value) => {
        this.coHost.next(value);
    };
    updateCoHostResponsibility = (value) => {
        this.coHostResponsibility.next(value);
    };
    updateYouAreCoHost = (value) => {
        this.youAreCoHost.next(value);
    };
    updateYouAreHost = (value) => {
        this.youAreHost.next(value);
    };
    updateConfirmedToRecord = (value) => {
        this.confirmedToRecord.next(value);
    };
    updateMeetingDisplayType = (value) => {
        this.meetingDisplayType.next(value);
    };
    updateMeetingVideoOptimized = (value) => {
        this.meetingVideoOptimized.next(value);
    };
    updateEventType = (value) => {
        this.eventType.next(value);
    };
    updateParticipants = (value) => {
        this.participants.next(value);
        this.participantsCounter.next(value.length);
        this.filteredParticipants.next(this.participants.value);
    };
    updateFilteredParticipants = (value) => {
        this.filteredParticipants.next(value);
    };
    updateParticipantsCounter = (value) => {
        this.participantsCounter.next(value);
    };
    updateParticipantsFilter = (value) => {
        this.participantsFilter.next(value);
    };
    updateConsume_sockets = (value) => {
        this.consume_sockets.next(value);
    };
    updateRtpCapabilities = (value) => {
        this.rtpCapabilities.next(value);
    };
    updateRoomRecvIPs = (value) => {
        this.roomRecvIPs.next(value);
    };
    updateMeetingRoomParams = (value) => {
        this.meetingRoomParams.next(value);
    };
    updateItemPageLimit = (value) => {
        this.itemPageLimit.next(value);
    };
    updateAudioOnlyRoom = (value) => {
        this.audioOnlyRoom.next(value);
    };
    updateAddForBasic = (value) => {
        this.addForBasic.next(value);
    };
    updateScreenPageLimit = (value) => {
        this.screenPageLimit.next(value);
    };
    updateShareScreenStarted = (value) => {
        this.shareScreenStarted.next(value);
    };
    updateShared = (value) => {
        this.shared.next(value);
    };
    updateTargetOrientation = (value) => {
        this.targetOrientation.next(value);
    };
    updateTargetResolution = (value) => {
        this.targetResolution.next(value);
    };
    updateTargetResolutionHost = (value) => {
        this.targetResolutionHost.next(value);
    };
    updateVidCons = (value) => {
        this.vidCons.next(value);
    };
    updateFrameRate = (value) => {
        this.frameRate.next(value);
    };
    updateHParams = (value) => {
        this.hParams.next(value);
    };
    updateVParams = (value) => {
        this.vParams.next(value);
    };
    updateScreenParams = (value) => {
        this.screenParams.next(value);
    };
    updateAParams = (value) => {
        this.aParams.next(value);
    };
    updateRecordingAudioPausesLimit = (value) => {
        this.recordingAudioPausesLimit.next(value);
    };
    updateRecordingAudioPausesCount = (value) => {
        this.recordingAudioPausesCount.next(value);
    };
    updateRecordingAudioSupport = (value) => {
        this.recordingAudioSupport.next(value);
    };
    updateRecordingAudioPeopleLimit = (value) => {
        this.recordingAudioPeopleLimit.next(value);
    };
    updateRecordingAudioParticipantsTimeLimit = (value) => {
        this.recordingAudioParticipantsTimeLimit.next(value);
    };
    updateRecordingVideoPausesCount = (value) => {
        this.recordingVideoPausesCount.next(value);
    };
    updateRecordingVideoPausesLimit = (value) => {
        this.recordingVideoPausesLimit.next(value);
    };
    updateRecordingVideoSupport = (value) => {
        this.recordingVideoSupport.next(value);
    };
    updateRecordingVideoPeopleLimit = (value) => {
        this.recordingVideoPeopleLimit.next(value);
    };
    updateRecordingVideoParticipantsTimeLimit = (value) => {
        this.recordingVideoParticipantsTimeLimit.next(value);
    };
    updateRecordingAllParticipantsSupport = (value) => {
        this.recordingAllParticipantsSupport.next(value);
    };
    updateRecordingVideoParticipantsSupport = (value) => {
        this.recordingVideoParticipantsSupport.next(value);
    };
    updateRecordingAllParticipantsFullRoomSupport = (value) => {
        this.recordingAllParticipantsFullRoomSupport.next(value);
    };
    updateRecordingVideoParticipantsFullRoomSupport = (value) => {
        this.recordingVideoParticipantsFullRoomSupport.next(value);
    };
    updateRecordingPreferredOrientation = (value) => {
        this.recordingPreferredOrientation.next(value);
    };
    updateRecordingSupportForOtherOrientation = (value) => {
        this.recordingSupportForOtherOrientation.next(value);
    };
    updateRecordingMultiFormatsSupport = (value) => {
        this.recordingMultiFormatsSupport.next(value);
    };
    updateUserRecordingParams = (value) => {
        this.userRecordingParams.next(value);
    };
    updateCanRecord = (value) => {
        this.canRecord.next(value);
    };
    updateStartReport = (value) => {
        this.startReport.next(value);
    };
    updateEndReport = (value) => {
        this.endReport.next(value);
    };
    updateRecordTimerInterval = (value) => {
        this.recordTimerInterval.next(value);
    };
    updateRecordStartTime = (value) => {
        this.recordStartTime.next(value);
    };
    updateRecordElapsedTime = (value) => {
        this.recordElapsedTime.next(value);
    };
    updateIsTimerRunning = (value) => {
        this.isTimerRunning.next(value);
    };
    updateCanPauseResume = (value) => {
        this.canPauseResume.next(value);
    };
    updateRecordChangeSeconds = (value) => {
        this.recordChangeSeconds.next(value);
    };
    updatePauseLimit = (value) => {
        this.pauseLimit.next(value);
    };
    updatePauseRecordCount = (value) => {
        this.pauseRecordCount.next(value);
    };
    updateCanLaunchRecord = (value) => {
        this.canLaunchRecord.next(value);
    };
    updateStopLaunchRecord = (value) => {
        this.stopLaunchRecord.next(value);
    };
    updateParticipantsAll = (value) => {
        this.participantsAll.next(value);
    };
    updateFirstAll = (value) => {
        this.firstAll.next(value);
    };
    updateUpdateMainWindow = (value) => {
        this.updateMainWindow.next(value);
    };
    updateFirst_round = (value) => {
        this.first_round.next(value);
    };
    updateLandScaped = (value) => {
        this.landScaped.next(value);
    };
    updateLock_screen = (value) => {
        this.lock_screen.next(value);
    };
    updateScreenId = (value) => {
        this.screenId.next(value);
    };
    updateAllVideoStreams = (value) => {
        this.allVideoStreams.next(value);
    };
    updateNewLimitedStreams = (value) => {
        this.newLimitedStreams.next(value);
    };
    updateNewLimitedStreamsIDs = (value) => {
        this.newLimitedStreamsIDs.next(value);
    };
    updateActiveSounds = (value) => {
        this.activeSounds.next(value);
    };
    updateScreenShareIDStream = (value) => {
        this.screenShareIDStream.next(value);
    };
    updateScreenShareNameStream = (value) => {
        this.screenShareNameStream.next(value);
    };
    updateAdminIDStream = (value) => {
        this.adminIDStream.next(value);
    };
    updateAdminNameStream = (value) => {
        this.adminNameStream.next(value);
    };
    updateYouYouStream = (value) => {
        this.youYouStream.next(value);
    };
    updateYouYouStreamIDs = (value) => {
        this.youYouStreamIDs.next(value);
    };
    updateLocalStream = (value) => {
        this.localStream.next(value);
    };
    updateRecordStarted = (value) => {
        this.recordStarted.next(value);
    };
    updateRecordResumed = (value) => {
        this.recordResumed.next(value);
    };
    updateRecordPaused = (value) => {
        this.recordPaused.next(value);
    };
    updateRecordStopped = (value) => {
        this.recordStopped.next(value);
    };
    updateAdminRestrictSetting = (value) => {
        this.adminRestrictSetting.next(value);
    };
    updateVideoRequestState = (value) => {
        this.videoRequestState.next(value);
    };
    updateVideoRequestTime = (value) => {
        this.videoRequestTime.next(value);
    };
    updateVideoAction = (value) => {
        this.videoAction.next(value);
    };
    updateLocalStreamVideo = (value) => {
        this.localStreamVideo.next(value);
    };
    updateUserDefaultVideoInputDevice = (value) => {
        this.userDefaultVideoInputDevice.next(value);
    };
    updateCurrentFacingMode = (value) => {
        this.currentFacingMode.next(value);
    };
    updatePrevFacingMode = (value) => {
        this.prevFacingMode.next(value);
    };
    updateDefVideoID = (value) => {
        this.defVideoID.next(value);
    };
    updateAllowed = (value) => {
        this.allowed.next(value);
    };
    updateDispActiveNames = (value) => {
        this.dispActiveNames.next(value);
    };
    updateP_dispActiveNames = (value) => {
        this.p_dispActiveNames.next(value);
    };
    updateActiveNames = (value) => {
        this.activeNames.next(value);
    };
    updatePrevActiveNames = (value) => {
        this.prevActiveNames.next(value);
    };
    updateP_activeNames = (value) => {
        this.p_activeNames.next(value);
    };
    updateMembersReceived = (value) => {
        this.membersReceived.next(value);
    };
    updateDeferScreenReceived = (value) => {
        this.deferScreenReceived.next(value);
    };
    updateHostFirstSwitch = (value) => {
        this.hostFirstSwitch.next(value);
    };
    updateMicAction = (value) => {
        this.micAction.next(value);
    };
    updateScreenAction = (value) => {
        this.screenAction.next(value);
    };
    updateChatAction = (value) => {
        this.chatAction.next(value);
    };
    updateAudioRequestState = (value) => {
        this.audioRequestState.next(value);
    };
    updateScreenRequestState = (value) => {
        this.screenRequestState.next(value);
    };
    updateChatRequestState = (value) => {
        this.chatRequestState.next(value);
    };
    updateAudioRequestTime = (value) => {
        this.audioRequestTime.next(value);
    };
    updateScreenRequestTime = (value) => {
        this.screenRequestTime.next(value);
    };
    updateChatRequestTime = (value) => {
        this.chatRequestTime.next(value);
    };
    updateOldSoundIds = (value) => {
        this.oldSoundIds.next(value);
    };
    updateHostLabel = (value) => {
        this.hostLabel.next(value);
    };
    updateMainScreenFilled = (value) => {
        this.mainScreenFilled.next(value);
    };
    updateLocalStreamScreen = (value) => {
        this.localStreamScreen.next(value);
    };
    updateScreenAlreadyOn = (value) => {
        this.screenAlreadyOn.next(value);
    };
    updateChatAlreadyOn = (value) => {
        this.chatAlreadyOn.next(value);
    };
    updateRedirectURL = (value) => {
        this.redirectURL.next(value);
    };
    updateOldAllStreams = (value) => {
        this.oldAllStreams.next(value);
    };
    updateAdminVidID = (value) => {
        this.adminVidID.next(value);
    };
    updateStreamNames = (value) => {
        this.streamNames.next(value);
    };
    updateNon_alVideoStreams = (value) => {
        this.non_alVideoStreams.next(value);
    };
    updateSortAudioLoudness = (value) => {
        this.sortAudioLoudness.next(value);
    };
    updateAudioDecibels = (value) => {
        this.audioDecibels.next(value);
    };
    updateMixed_alVideoStreams = (value) => {
        this.mixed_alVideoStreams.next(value);
    };
    updateNon_alVideoStreams_muted = (value) => {
        this.non_alVideoStreams_muted.next(value);
    };
    updatePaginatedStreams = (value) => {
        this.paginatedStreams.next(value);
    };
    updateLocalStreamAudio = (value) => {
        this.localStreamAudio.next(value);
    };
    updateDefAudioID = (value) => {
        this.defAudioID.next(value);
    };
    updateUserDefaultAudioInputDevice = (value) => {
        this.userDefaultAudioInputDevice.next(value);
    };
    updateUserDefaultAudioOutputDevice = (value) => {
        this.userDefaultAudioOutputDevice.next(value);
    };
    updatePrevAudioInputDevice = (value) => {
        this.prevAudioInputDevice.next(value);
    };
    updatePrevVideoInputDevice = (value) => {
        this.prevVideoInputDevice.next(value);
    };
    updateAudioPaused = (value) => {
        this.audioPaused.next(value);
    };
    updateMainScreenPerson = (value) => {
        this.mainScreenPerson.next(value);
    };
    updateAdminOnMainScreen = (value) => {
        this.adminOnMainScreen.next(value);
    };
    updateScreenStates = (value) => {
        this.screenStates.next(value);
    };
    updatePrevScreenStates = (value) => {
        this.prevScreenStates.next(value);
    };
    updateUpdateDateState = (value) => {
        this.updateDateState.next(value);
    };
    updateLastUpdate = (value) => {
        this.lastUpdate.next(value);
    };
    updateNForReadjustRecord = (value) => {
        this.nForReadjustRecord.next(value);
    };
    updateFixedPageLimit = (value) => {
        this.fixedPageLimit.next(value);
    };
    updateRemoveAltGrid = (value) => {
        this.removeAltGrid.next(value);
    };
    updateNForReadjust = (value) => {
        this.nForReadjust.next(value);
    };
    updateLastReorderTime = (value) => {
        this.lastReorderTime.next(value);
    };
    updateAudStreamNames = (value) => {
        this.audStreamNames.next(value);
    };
    updateCurrentUserPage = (value) => {
        this.currentUserPage.next(value);
    };
    updateMainHeightWidth = (value) => {
        this.mainHeightWidth.next(value);
    };
    updatePrevMainHeightWidth = (value) => {
        this.prevMainHeightWidth.next(value);
    };
    updatePrevDoPaginate = (value) => {
        this.prevDoPaginate.next(value);
    };
    updateDoPaginate = (value) => {
        this.doPaginate.next(value);
    };
    updateShareEnded = (value) => {
        this.shareEnded.next(value);
    };
    updateLStreams = (value) => {
        this.lStreams.next(value);
    };
    updateChatRefStreams = (value) => {
        this.chatRefStreams.next(value);
    };
    updateControlHeight = (value) => {
        this.controlHeight.next(value);
    };
    updateIsWideScreen = (value) => {
        this.isWideScreen.next(value);
    };
    updateIsMediumScreen = (value) => {
        this.isMediumScreen.next(value);
    };
    updateIsSmallScreen = (value) => {
        this.isSmallScreen.next(value);
    };
    updateAddGrid = (value) => {
        this.addGrid.next(value);
    };
    updateAddAltGrid = (value) => {
        this.addAltGrid.next(value);
    };
    updateGridRows = (value) => {
        this.gridRows.next(value);
    };
    updateGridCols = (value) => {
        this.gridCols.next(value);
    };
    updateAltGridRows = (value) => {
        this.altGridRows.next(value);
    };
    updateAltGridCols = (value) => {
        this.altGridCols.next(value);
    };
    updateNumberPages = (value) => {
        this.numberPages.next(value);
    };
    updateCurrentStreams = (value) => {
        this.currentStreams.next(value);
    };
    updateShowMiniView = (value) => {
        this.showMiniView.next(value);
    };
    updateNStream = (value) => {
        this.nStream.next(value);
    };
    updateDefer_receive = (value) => {
        this.defer_receive.next(value);
    };
    updateAllAudioStreams = (value) => {
        this.allAudioStreams.next(value);
    };
    updateRemoteScreenStream = (value) => {
        this.remoteScreenStream.next(value);
    };
    updateScreenProducer = (value) => {
        this.screenProducer.next(value);
    };
    updateLocalScreenProducer = (value) => {
        this.localScreenProducer.next(value);
    };
    updateGotAllVids = (value) => {
        this.gotAllVids.next(value);
    };
    updatePaginationHeightWidth = (value) => {
        this.paginationHeightWidth.next(value);
    };
    updatePaginationDirection = (value) => {
        this.paginationDirection.next(value);
    };
    updateGridSizes = (value) => {
        this.gridSizes.next(value);
    };
    updateScreenForceFullDisplay = (value) => {
        this.screenForceFullDisplay.next(value);
    };
    updateMainGridStream = (value) => {
        this.mainGridStream.next(value);
    };
    updateOtherGridStreams = (value) => {
        this.otherGridStreams.next(value);
    };
    updateAudioOnlyStreams = (value) => {
        this.audioOnlyStreams.next(value);
    };
    updateVideoInputs = (value) => {
        this.videoInputs.next(value);
    };
    updateAudioInputs = (value) => {
        this.audioInputs.next(value);
    };
    updateMeetingProgressTime = (value) => {
        this.meetingProgressTime.next(value);
    };
    updateMeetingElapsedTime = (value) => {
        this.meetingElapsedTime.next(value);
    };
    updateRef_participants = (value) => {
        this.ref_participants.next(value);
    };
    // Messages
    messages = new BehaviorSubject$1([]);
    startDirectMessage = new BehaviorSubject$1(false);
    directMessageDetails = new BehaviorSubject$1(null);
    showMessagesBadge = new BehaviorSubject$1(false);
    // Event Settings
    audioSetting = new BehaviorSubject$1('allow');
    videoSetting = new BehaviorSubject$1('allow');
    screenshareSetting = new BehaviorSubject$1('allow');
    chatSetting = new BehaviorSubject$1('allow');
    // Display Settings
    displayOption = new BehaviorSubject$1('media');
    autoWave = new BehaviorSubject$1(true);
    forceFullDisplay = new BehaviorSubject$1(true);
    prevForceFullDisplay = new BehaviorSubject$1(false);
    prevMeetingDisplayType = new BehaviorSubject$1('video');
    // Waiting Room
    waitingRoomFilter = new BehaviorSubject$1('');
    waitingRoomList = new BehaviorSubject$1([]);
    waitingRoomCounter = new BehaviorSubject$1(0);
    filteredWaitingRoomList = new BehaviorSubject$1([]);
    // Requests
    requestFilter = new BehaviorSubject$1('');
    requestList = new BehaviorSubject$1([]);
    requestCounter = new BehaviorSubject$1(0);
    filteredRequestList = new BehaviorSubject$1([]);
    // Total Requests and Waiting Room
    totalReqWait = new BehaviorSubject$1(0);
    // Alerts
    alertVisible = new BehaviorSubject$1(false);
    alertMessage = new BehaviorSubject$1('');
    alertType = new BehaviorSubject$1('success');
    alertDuration = new BehaviorSubject$1(3000);
    // Progress Timer
    progressTimerVisible = new BehaviorSubject$1(true);
    progressTimerValue = new BehaviorSubject$1(0);
    // Menu Modals
    isMenuModalVisible = new BehaviorSubject$1(false);
    isRecordingModalVisible = new BehaviorSubject$1(false);
    isSettingsModalVisible = new BehaviorSubject$1(false);
    isRequestsModalVisible = new BehaviorSubject$1(false);
    isWaitingModalVisible = new BehaviorSubject$1(false);
    isCoHostModalVisible = new BehaviorSubject$1(false);
    isMediaSettingsModalVisible = new BehaviorSubject$1(false);
    isDisplaySettingsModalVisible = new BehaviorSubject$1(false);
    // Other Modals
    isParticipantsModalVisible = new BehaviorSubject$1(false);
    isMessagesModalVisible = new BehaviorSubject$1(false);
    isConfirmExitModalVisible = new BehaviorSubject$1(false);
    isConfirmHereModalVisible = new BehaviorSubject$1(false);
    isShareEventModalVisible = new BehaviorSubject$1(false);
    isLoadingModalVisible = new BehaviorSubject$1(false);
    // Recording Options
    recordingMediaOptions = new BehaviorSubject$1('video');
    recordingAudioOptions = new BehaviorSubject$1('all');
    recordingVideoOptions = new BehaviorSubject$1('all');
    recordingVideoType = new BehaviorSubject$1('fullDisplay');
    recordingVideoOptimized = new BehaviorSubject$1(false);
    recordingDisplayType = new BehaviorSubject$1('video');
    recordingAddHLS = new BehaviorSubject$1(true);
    recordingNameTags = new BehaviorSubject$1(true);
    recordingBackgroundColor = new BehaviorSubject$1('#83c0e9');
    recordingNameTagsColor = new BehaviorSubject$1('#ffffff');
    recordingAddText = new BehaviorSubject$1(false);
    recordingCustomText = new BehaviorSubject$1('Add Text');
    recordingCustomTextPosition = new BehaviorSubject$1('top');
    recordingCustomTextColor = new BehaviorSubject$1('#ffffff');
    recordingOrientationVideo = new BehaviorSubject$1('landscape');
    clearedToResume = new BehaviorSubject$1(true);
    clearedToRecord = new BehaviorSubject$1(true);
    recordState = new BehaviorSubject$1('green');
    showRecordButtons = new BehaviorSubject$1(false);
    recordingProgressTime = new BehaviorSubject$1('00:00:00');
    audioSwitching = new BehaviorSubject$1(false);
    videoSwitching = new BehaviorSubject$1(false);
    // Media States
    videoAlreadyOn = new BehaviorSubject$1(false);
    audioAlreadyOn = new BehaviorSubject$1(false);
    componentSizes = new BehaviorSubject$1({
        mainHeight: 0,
        otherHeight: 0,
        mainWidth: 0,
        otherWidth: 0,
    });
    // Permissions
    hasCameraPermission = new BehaviorSubject$1(false);
    hasAudioPermission = new BehaviorSubject$1(false);
    // Transports
    transportCreated = new BehaviorSubject$1(false);
    localTransportCreated = new BehaviorSubject$1(false);
    transportCreatedVideo = new BehaviorSubject$1(false);
    transportCreatedAudio = new BehaviorSubject$1(false);
    transportCreatedScreen = new BehaviorSubject$1(false);
    producerTransport = new BehaviorSubject$1(null);
    localProducerTransport = new BehaviorSubject$1(null);
    videoProducer = new BehaviorSubject$1(null);
    localVideoProducer = new BehaviorSubject$1(null);
    params = new BehaviorSubject$1({});
    videoParams = new BehaviorSubject$1({});
    audioParams = new BehaviorSubject$1({});
    audioProducer = new BehaviorSubject$1(null);
    audioLevel = new BehaviorSubject$1(0);
    localAudioProducer = new BehaviorSubject$1(null);
    consumerTransports = new BehaviorSubject$1([]);
    consumingTransports = new BehaviorSubject$1([]);
    // Polls
    polls = new BehaviorSubject$1([]);
    poll = new BehaviorSubject$1(null);
    isPollModalVisible = new BehaviorSubject$1(false);
    // Background
    customImage = new BehaviorSubject$1('');
    selectedImage = new BehaviorSubject$1('');
    segmentVideo = new BehaviorSubject$1(null);
    selfieSegmentation = new BehaviorSubject$1(null);
    pauseSegmentation = new BehaviorSubject$1(false);
    processedStream = new BehaviorSubject$1(null);
    keepBackground = new BehaviorSubject$1(false);
    backgroundHasChanged = new BehaviorSubject$1(false);
    virtualStream = new BehaviorSubject$1(null);
    mainCanvas = new BehaviorSubject$1(null);
    prevKeepBackground = new BehaviorSubject$1(false);
    appliedBackground = new BehaviorSubject$1(false);
    isBackgroundModalVisible = new BehaviorSubject$1(false);
    autoClickBackground = new BehaviorSubject$1(false);
    // Breakout Rooms
    breakoutRooms = new BehaviorSubject$1([]);
    currentRoomIndex = new BehaviorSubject$1(0);
    canStartBreakout = new BehaviorSubject$1(false);
    breakOutRoomStarted = new BehaviorSubject$1(false);
    breakOutRoomEnded = new BehaviorSubject$1(false);
    hostNewRoom = new BehaviorSubject$1(-1);
    limitedBreakRoom = new BehaviorSubject$1([]);
    mainRoomsLength = new BehaviorSubject$1(0);
    memberRoom = new BehaviorSubject$1(-1);
    isBreakoutRoomsModalVisible = new BehaviorSubject$1(false);
    // Whiteboard
    whiteboardUsers = new BehaviorSubject$1([]);
    currentWhiteboardIndex = new BehaviorSubject$1(0);
    canStartWhiteboard = new BehaviorSubject$1(false);
    whiteboardStarted = new BehaviorSubject$1(false);
    whiteboardEnded = new BehaviorSubject$1(false);
    whiteboardLimit = new BehaviorSubject$1(4);
    isWhiteboardModalVisible = new BehaviorSubject$1(false);
    isConfigureWhiteboardModalVisible = new BehaviorSubject$1(false);
    shapes = new BehaviorSubject$1([]);
    useImageBackground = new BehaviorSubject$1(true);
    redoStack = new BehaviorSubject$1([]);
    undoStack = new BehaviorSubject$1([]);
    canvasStream = new BehaviorSubject$1(null);
    canvasWhiteboard = new BehaviorSubject$1(null);
    // Screenboard
    canvasScreenboard = new BehaviorSubject$1(null);
    processedScreenStream = new BehaviorSubject$1(null);
    annotateScreenStream = new BehaviorSubject$1(false);
    mainScreenCanvas = new BehaviorSubject$1(null);
    isScreenboardModalVisible = new BehaviorSubject$1(false);
    //state variables for the control buttons
    micActive = new BehaviorSubject$1(this.audioAlreadyOn.value ? this.audioAlreadyOn.value : false);
    videoActive = new BehaviorSubject$1(this.videoAlreadyOn.value ? this.videoAlreadyOn.value : false);
    screenShareActive = new BehaviorSubject$1(false);
    endCallActive = new BehaviorSubject$1(false);
    participantsActive = new BehaviorSubject$1(false);
    menuActive = new BehaviorSubject$1(false);
    commentsActive = new BehaviorSubject$1(false);
    // Update functions
    updateMessages = (value) => {
        this.messages.next(value);
    };
    updateStartDirectMessage = (value) => {
        this.startDirectMessage.next(value);
    };
    updateDirectMessageDetails = (value) => {
        this.directMessageDetails.next(value);
    };
    updateShowMessagesBadge = (value) => {
        this.showMessagesBadge.next(value);
    };
    updateAudioSetting = (value) => {
        this.audioSetting.next(value);
    };
    updateVideoSetting = (value) => {
        this.videoSetting.next(value);
    };
    updateScreenshareSetting = (value) => {
        this.screenshareSetting.next(value);
    };
    updateChatSetting = (value) => {
        this.chatSetting.next(value);
    };
    updateDisplayOption = (value) => {
        this.displayOption.next(value);
    };
    updateAutoWave = (value) => {
        this.autoWave.next(value);
    };
    updateForceFullDisplay = (value) => {
        this.forceFullDisplay.next(value);
    };
    updatePrevForceFullDisplay = (value) => {
        this.prevForceFullDisplay.next(value);
    };
    updatePrevMeetingDisplayType = (value) => {
        this.prevMeetingDisplayType.next(value);
    };
    updateWaitingRoomCounter = (value) => {
        this.waitingRoomCounter.next(value);
    };
    updateWaitingRoomFilter = (value) => {
        this.waitingRoomFilter.next(value);
    };
    updateWaitingRoomList = (value) => {
        this.waitingRoomList.next(value);
        this.filteredWaitingRoomList.next(value);
        this.waitingRoomCounter.next(value.length);
    };
    onWaitingRoomClose = () => {
        this.updateIsWaitingModalVisible(false);
    };
    updateRequestCounter = (value) => {
        this.requestCounter.next(value);
    };
    updateRequestFilter = (value) => {
        this.requestFilter.next(value);
    };
    updateRequestList = (value) => {
        this.requestList.next(value);
        this.filteredRequestList.next(value);
        this.requestCounter.next(value.length);
    };
    onRequestClose = () => {
        this.updateIsRequestsModalVisible(false);
    };
    updateTotalReqWait = (value) => {
        this.totalReqWait.next(value);
    };
    updateAlertVisible = (value) => {
        this.alertVisible.next(value);
    };
    updateAlertMessage = (value) => {
        this.alertMessage.next(value);
    };
    updateAlertType = (value) => {
        this.alertType.next(value);
    };
    updateAlertDuration = (value) => {
        this.alertDuration.next(value);
    };
    updateProgressTimerVisible = (value) => {
        this.progressTimerVisible.next(value);
    };
    updateProgressTimerValue = (value) => {
        this.progressTimerValue.next(value);
    };
    updateIsMenuModalVisible = (value) => {
        this.isMenuModalVisible.next(value);
    };
    updateIsRecordingModalVisible = (value) => {
        this.isRecordingModalVisible.next(value);
        if (value) {
            this.updateConfirmedToRecord(false);
        }
        else {
            if (this.clearedToRecord.getValue() &&
                this.clearedToResume.getValue() &&
                this.recordStarted.getValue()) {
                this.updateShowRecordButtons(true);
            }
        }
    };
    updateIsSettingsModalVisible = (value) => {
        this.isSettingsModalVisible.next(value);
    };
    updateIsRequestsModalVisible = (value) => {
        this.isRequestsModalVisible.next(value);
    };
    updateIsWaitingModalVisible = (value) => {
        this.isWaitingModalVisible.next(value);
    };
    updateIsCoHostModalVisible = (value) => {
        this.isCoHostModalVisible.next(value);
    };
    updateIsMediaSettingsModalVisible = (value) => {
        this.isMediaSettingsModalVisible.next(value);
    };
    updateIsDisplaySettingsModalVisible = (value) => {
        this.isDisplaySettingsModalVisible.next(value);
    };
    updateIsParticipantsModalVisible = (value) => {
        this.isParticipantsModalVisible.next(value);
    };
    updateIsMessagesModalVisible = (value) => {
        this.isMessagesModalVisible.next(value);
        if (!value) {
            this.updateShowMessagesBadge(false);
        }
    };
    updateIsConfirmExitModalVisible = (value) => {
        this.isConfirmExitModalVisible.next(value);
    };
    updateIsConfirmHereModalVisible = (value) => {
        this.isConfirmHereModalVisible.next(value);
    };
    updateIsLoadingModalVisible = (value) => {
        this.isLoadingModalVisible.next(value);
    };
    updateIsShareEventModalVisible = (value) => {
        this.isShareEventModalVisible.next(value);
    };
    updateRecordingMediaOptions = (value) => {
        this.recordingMediaOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAudioOptions = (value) => {
        this.recordingAudioOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptions = (value) => {
        this.recordingVideoOptions.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoType = (value) => {
        this.recordingVideoType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingVideoOptimized = (value) => {
        this.recordingVideoOptimized.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingDisplayType = (value) => {
        this.recordingDisplayType.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddHLS = (value) => {
        this.recordingAddHLS.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingAddText = (value) => {
        this.recordingAddText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomText = (value) => {
        this.recordingCustomText.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextPosition = (value) => {
        this.recordingCustomTextPosition.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingCustomTextColor = (value) => {
        this.recordingCustomTextColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTags = (value) => {
        this.recordingNameTags.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingBackgroundColor = (value) => {
        this.recordingBackgroundColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingNameTagsColor = (value) => {
        this.recordingNameTagsColor.next(value);
        this.clearedToRecord.next(false);
    };
    updateRecordingOrientationVideo = (value) => {
        this.recordingOrientationVideo.next(value);
        this.clearedToRecord.next(false);
    };
    updateClearedToResume = (value) => {
        this.clearedToResume.next(value);
    };
    updateClearedToRecord = (value) => {
        this.clearedToRecord.next(value);
    };
    updateRecordState = (value) => {
        if (this.recordStarted.value && !this.recordStopped.value) {
            if (!this.recordPaused.value) {
                this.recordState.next('red');
            }
            else {
                this.recordState.next('yellow');
            }
        }
        else {
            this.recordState.next(value);
        }
        this.recordState.next(value);
    };
    updateShowRecordButtons = (value) => {
        this.showRecordButtons.next(value);
    };
    updateRecordingProgressTime = (value) => {
        this.recordingProgressTime.next(value);
    };
    updateAudioSwitching = (value) => {
        this.audioSwitching.next(value);
    };
    updateVideoSwitching = (value) => {
        this.videoSwitching.next(value);
    };
    updateVideoAlreadyOn = (value) => {
        this.videoAlreadyOn.next(value);
        this.videoActive.next(value);
    };
    updateAudioAlreadyOn = (value) => {
        this.audioAlreadyOn.next(value);
        this.micActive.next(value);
    };
    updateComponentSizes = (sizes) => {
        this.componentSizes.next(sizes);
    };
    updateHasCameraPermission = (value) => {
        this.hasCameraPermission.next(value);
    };
    updateHasAudioPermission = (value) => {
        this.hasAudioPermission.next(value);
    };
    requestPermissionCamera() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    requestPermissionAudio() {
        // Implement the request permission logic here
        return Promise.resolve('granted');
    }
    updateTransportCreated = (value) => {
        this.transportCreated.next(value);
    };
    updateLocalTransportCreated = (value) => {
        this.localTransportCreated.next(value);
    };
    updateTransportCreatedVideo = (value) => {
        this.transportCreatedVideo.next(value);
    };
    updateTransportCreatedAudio = (value) => {
        this.transportCreatedAudio.next(value);
    };
    updateTransportCreatedScreen = (value) => {
        this.transportCreatedScreen.next(value);
    };
    updateProducerTransport = (value) => {
        this.producerTransport.next(value);
    };
    updateLocalProducerTransport = (value) => {
        this.localProducerTransport.next(value);
    };
    updateVideoProducer = (value) => {
        this.videoProducer.next(value);
    };
    updateLocalVideoProducer = (value) => {
        this.localVideoProducer.next(value);
    };
    updateParams = (value) => {
        this.params.next(value);
    };
    updateVideoParams = (value) => {
        this.videoParams.next(value);
    };
    updateAudioParams = (value) => {
        this.audioParams.next(value);
    };
    updateAudioProducer = (value) => {
        this.audioProducer.next(value);
    };
    updateAudioLevel = (value) => {
        this.audioLevel.next(value);
    };
    updateLocalAudioProducer = (value) => {
        this.localAudioProducer.next(value);
    };
    updateConsumerTransports = (value) => {
        this.consumerTransports.next(value);
    };
    updateConsumingTransports = (value) => {
        this.consumingTransports.next(value);
    };
    updatePolls = (value) => {
        this.polls.next(value);
    };
    updatePoll = (value) => {
        this.poll.next(value);
    };
    updateIsPollModalVisible = (value) => {
        this.isPollModalVisible.next(value);
    };
    updateCustomImage = (value) => {
        this.customImage.next(value);
    };
    updateSelectedImage = (value) => {
        this.selectedImage.next(value);
    };
    updateSegmentVideo = (value) => {
        this.segmentVideo.next(value);
    };
    updateSelfieSegmentation = (value) => {
        this.selfieSegmentation.next(value);
    };
    updatePauseSegmentation = (value) => {
        this.pauseSegmentation.next(value);
    };
    updateProcessedStream = (value) => {
        this.processedStream.next(value);
    };
    updateKeepBackground = (value) => {
        this.keepBackground.next(value);
    };
    updateBackgroundHasChanged = (value) => {
        this.backgroundHasChanged.next(value);
    };
    updateVirtualStream = (value) => {
        this.virtualStream.next(value);
    };
    updateMainCanvas = (value) => {
        this.mainCanvas.next(value);
    };
    updatePrevKeepBackground = (value) => {
        this.prevKeepBackground.next(value);
    };
    updateAppliedBackground = (value) => {
        this.appliedBackground.next(value);
    };
    updateIsBackgroundModalVisible = (value) => {
        this.isBackgroundModalVisible.next(value);
    };
    updateAutoClickBackground = (value) => {
        this.autoClickBackground.next(value);
    };
    updateBreakoutRooms = (value) => {
        this.breakoutRooms.next(value);
    };
    updateCurrentRoomIndex = (value) => {
        this.currentRoomIndex.next(value);
    };
    updateCanStartBreakout = (value) => {
        this.canStartBreakout.next(value);
    };
    updateBreakOutRoomStarted = (value) => {
        this.breakOutRoomStarted.next(value);
    };
    updateBreakOutRoomEnded = (value) => {
        this.breakOutRoomEnded.next(value);
    };
    updateHostNewRoom = (value) => {
        this.hostNewRoom.next(value);
    };
    updateLimitedBreakRoom = (value) => {
        this.limitedBreakRoom.next(value);
    };
    updateMainRoomsLength = (value) => {
        this.mainRoomsLength.next(value);
    };
    updateMemberRoom = (value) => {
        this.memberRoom.next(value);
    };
    updateIsBreakoutRoomsModalVisible = (value) => {
        this.isBreakoutRoomsModalVisible.next(value);
    };
    updateWhiteboardUsers = (value) => {
        this.whiteboardUsers.next(value);
    };
    updateCurrentWhiteboardIndex = (value) => {
        this.currentWhiteboardIndex.next(value);
    };
    updateCanStartWhiteboard = (value) => {
        this.canStartWhiteboard.next(value);
    };
    updateWhiteboardStarted = (value) => {
        this.whiteboardStarted.next(value);
    };
    updateWhiteboardEnded = (value) => {
        this.whiteboardEnded.next(value);
    };
    updateWhiteboardLimit = (value) => {
        this.whiteboardLimit.next(value);
    };
    updateIsWhiteboardModalVisible = (value) => {
        this.isWhiteboardModalVisible.next(value);
    };
    updateIsConfigureWhiteboardModalVisible = (value) => {
        this.isConfigureWhiteboardModalVisible.next(value);
    };
    updateShapes = (value) => {
        this.shapes.next(value);
    };
    updateUseImageBackground = (value) => {
        this.useImageBackground.next(value);
    };
    updateRedoStack = (value) => {
        this.redoStack.next(value);
    };
    updateUndoStack = (value) => {
        this.undoStack.next(value);
    };
    updateCanvasStream = (value) => {
        this.canvasStream.next(value);
    };
    updateCanvasWhiteboard = (value) => {
        this.canvasWhiteboard.next(value);
    };
    updateCanvasScreenboard = (value) => {
        this.canvasScreenboard.next(value);
    };
    updateProcessedScreenStream = (value) => {
        this.processedScreenStream.next(value);
    };
    updateAnnotateScreenStream = (value) => {
        this.annotateScreenStream.next(value);
    };
    updateMainScreenCanvas = (value) => {
        this.mainScreenCanvas.next(value);
    };
    updateIsScreenboardModalVisible = (value) => {
        this.isScreenboardModalVisible.next(value);
    };
    checkOrientation = () => {
        const isPortrait = window.matchMedia('(orientation: portrait)').matches;
        return isPortrait ? 'portrait' : 'landscape';
    };
    showAlert = ({ message, type, duration = 3000, }) => {
        this.updateAlertMessage(message);
        this.updateAlertType(type);
        this.updateAlertDuration(duration);
        this.updateAlertVisible(true);
    };
    getAllParams() {
        return {
            localUIMode: this.localUIMode.value, // Local UI mode
            // Room Details
            roomName: this.roomName.value,
            member: this.member.value,
            adminPasscode: this.adminPasscode.value,
            youAreCoHost: this.youAreCoHost.value,
            youAreHost: this.youAreHost.value,
            islevel: this.islevel.value,
            confirmedToRecord: this.confirmedToRecord.value,
            meetingDisplayType: this.meetingDisplayType.value,
            meetingVideoOptimized: this.meetingVideoOptimized.value,
            eventType: this.eventType.value,
            participants: this.participants.value,
            filteredParticipants: this.filteredParticipants.value,
            participantsCounter: this.participantsCounter.value,
            participantsFilter: this.participantsFilter.value,
            // More room details - media
            consume_sockets: this.consume_sockets.value,
            rtpCapabilities: this.rtpCapabilities.value,
            roomRecvIPs: this.roomRecvIPs.value,
            meetingRoomParams: this.meetingRoomParams.value,
            itemPageLimit: this.itemPageLimit.value,
            audioOnlyRoom: this.audioOnlyRoom.value,
            addForBasic: this.addForBasic.value,
            screenPageLimit: this.screenPageLimit.value,
            shareScreenStarted: this.shareScreenStarted.value,
            shared: this.shared.value,
            targetOrientation: this.targetOrientation.value,
            targetResolution: this.targetResolution.value,
            targetResolutionHost: this.targetResolutionHost.value,
            vidCons: this.vidCons.value,
            frameRate: this.frameRate.value,
            hParams: this.hParams.value,
            vParams: this.vParams.value,
            screenParams: this.screenParams.value,
            aParams: this.aParams.value,
            // More room details - recording
            recordingAudioPausesLimit: this.recordingAudioPausesLimit.value,
            recordingAudioPausesCount: this.recordingAudioPausesCount.value,
            recordingAudioSupport: this.recordingAudioSupport.value,
            recordingAudioPeopleLimit: this.recordingAudioPeopleLimit.value,
            recordingAudioParticipantsTimeLimit: this.recordingAudioParticipantsTimeLimit.value,
            recordingVideoPausesCount: this.recordingVideoPausesCount.value,
            recordingVideoPausesLimit: this.recordingVideoPausesLimit.value,
            recordingVideoSupport: this.recordingVideoSupport.value,
            recordingVideoPeopleLimit: this.recordingVideoPeopleLimit.value,
            recordingVideoParticipantsTimeLimit: this.recordingVideoParticipantsTimeLimit.value,
            recordingAllParticipantsSupport: this.recordingAllParticipantsSupport.value,
            recordingVideoParticipantsSupport: this.recordingVideoParticipantsSupport.value,
            recordingAllParticipantsFullRoomSupport: this.recordingAllParticipantsFullRoomSupport.value,
            recordingVideoParticipantsFullRoomSupport: this.recordingVideoParticipantsFullRoomSupport.value,
            recordingPreferredOrientation: this.recordingPreferredOrientation.value,
            recordingSupportForOtherOrientation: this.recordingSupportForOtherOrientation.value,
            recordingMultiFormatsSupport: this.recordingMultiFormatsSupport.value,
            userRecordingParams: this.userRecordingParams.value,
            canRecord: this.canRecord.value,
            startReport: this.startReport.value,
            endReport: this.endReport.value,
            recordStartTime: this.recordStartTime.value,
            recordElapsedTime: this.recordElapsedTime.value,
            isTimerRunning: this.isTimerRunning.value,
            canPauseResume: this.canPauseResume.value,
            recordChangeSeconds: this.recordChangeSeconds.value,
            pauseLimit: this.pauseLimit.value,
            pauseRecordCount: this.pauseRecordCount.value,
            canLaunchRecord: this.canLaunchRecord.value,
            stopLaunchRecord: this.stopLaunchRecord.value,
            participantsAll: this.participantsAll.value,
            firstAll: this.firstAll.value,
            updateMainWindow: this.updateMainWindow.value,
            first_round: this.first_round.value,
            landScaped: this.landScaped.value,
            lock_screen: this.lock_screen.value,
            screenId: this.screenId.value,
            allVideoStreams: this.allVideoStreams.value,
            newLimitedStreams: this.newLimitedStreams.value,
            newLimitedStreamsIDs: this.newLimitedStreamsIDs.value,
            activeSounds: this.activeSounds.value,
            screenShareIDStream: this.screenShareIDStream.value,
            screenShareNameStream: this.screenShareNameStream.value,
            adminIDStream: this.adminIDStream.value,
            adminNameStream: this.adminNameStream.value,
            youYouStream: this.youYouStream.value,
            youYouStreamIDs: this.youYouStreamIDs.value,
            localStream: this.localStream.value,
            recordStarted: this.recordStarted.value,
            recordResumed: this.recordResumed.value,
            recordPaused: this.recordPaused.value,
            recordStopped: this.recordStopped.value,
            adminRestrictSetting: this.adminRestrictSetting.value,
            videoRequestState: this.videoRequestState.value,
            videoRequestTime: this.videoRequestTime.value,
            videoAction: this.videoAction.value,
            localStreamVideo: this.localStreamVideo.value,
            userDefaultVideoInputDevice: this.userDefaultVideoInputDevice.value,
            currentFacingMode: this.currentFacingMode.value,
            prevFacingMode: this.prevFacingMode.value,
            defVideoID: this.defVideoID.value,
            allowed: this.allowed.value,
            dispActiveNames: this.dispActiveNames.value,
            p_dispActiveNames: this.p_dispActiveNames.value,
            activeNames: this.activeNames.value,
            prevActiveNames: this.prevActiveNames.value,
            p_activeNames: this.p_activeNames.value,
            membersReceived: this.membersReceived.value,
            deferScreenReceived: this.deferScreenReceived.value,
            hostFirstSwitch: this.hostFirstSwitch.value,
            micAction: this.micAction.value,
            screenAction: this.screenAction.value,
            chatAction: this.chatAction.value,
            audioRequestState: this.audioRequestState.value,
            screenRequestState: this.screenRequestState.value,
            chatRequestState: this.chatRequestState.value,
            audioRequestTime: this.audioRequestTime.value,
            screenRequestTime: this.screenRequestTime.value,
            chatRequestTime: this.chatRequestTime.value,
            updateRequestIntervalSeconds: this.updateRequestIntervalSeconds.value,
            oldSoundIds: this.oldSoundIds.value,
            hostLabel: this.hostLabel.value,
            mainScreenFilled: this.mainScreenFilled.value,
            localStreamScreen: this.localStreamScreen.value,
            screenAlreadyOn: this.screenAlreadyOn.value,
            chatAlreadyOn: this.chatAlreadyOn.value,
            redirectURL: this.redirectURL.value,
            oldAllStreams: this.oldAllStreams.value,
            adminVidID: this.adminVidID.value,
            streamNames: this.streamNames.value,
            non_alVideoStreams: this.non_alVideoStreams.value,
            sortAudioLoudness: this.sortAudioLoudness.value,
            audioDecibels: this.audioDecibels.value,
            mixed_alVideoStreams: this.mixed_alVideoStreams.value,
            non_alVideoStreams_muted: this.non_alVideoStreams_muted.value,
            paginatedStreams: this.paginatedStreams.value,
            localStreamAudio: this.localStreamAudio.value,
            defAudioID: this.defAudioID.value,
            userDefaultAudioInputDevice: this.userDefaultAudioInputDevice.value,
            userDefaultAudioOutputDevice: this.userDefaultAudioOutputDevice.value,
            prevAudioInputDevice: this.prevAudioInputDevice.value,
            prevVideoInputDevice: this.prevVideoInputDevice.value,
            audioPaused: this.audioPaused.value,
            mainScreenPerson: this.mainScreenPerson.value,
            adminOnMainScreen: this.adminOnMainScreen.value,
            screenStates: this.screenStates.value,
            prevScreenStates: this.prevScreenStates.value,
            updateDateState: this.updateDateState.value,
            lastUpdate: this.lastUpdate.value,
            nForReadjustRecord: this.nForReadjustRecord.value,
            fixedPageLimit: this.fixedPageLimit.value,
            removeAltGrid: this.removeAltGrid.value,
            nForReadjust: this.nForReadjust.value,
            lastReorderTime: this.lastReorderTime.value,
            reorderInterval: this.reorderInterval.value,
            fastReorderInterval: this.fastReorderInterval.value,
            audStreamNames: this.audStreamNames.value,
            currentUserPage: this.currentUserPage.value,
            mainHeightWidth: this.mainHeightWidth.value,
            prevMainHeightWidth: this.prevMainHeightWidth.value,
            prevDoPaginate: this.prevDoPaginate.value,
            doPaginate: this.doPaginate.value,
            shareEnded: this.shareEnded.value,
            lStreams: this.lStreams.value,
            chatRefStreams: this.chatRefStreams.value,
            controlHeight: this.controlHeight.value,
            isWideScreen: this.isWideScreen.value,
            isMediumScreen: this.isMediumScreen.value,
            isSmallScreen: this.isSmallScreen.value,
            addGrid: this.addGrid.value,
            addAltGrid: this.addAltGrid.value,
            gridRows: this.gridRows.value,
            gridCols: this.gridCols.value,
            altGridRows: this.altGridRows.value,
            altGridCols: this.altGridCols.value,
            numberPages: this.numberPages.value,
            currentStreams: this.currentStreams.value,
            showMiniView: this.showMiniView.value,
            nStream: this.nStream.value,
            defer_receive: this.defer_receive.value,
            allAudioStreams: this.allAudioStreams.value,
            screenProducer: this.screenProducer.value,
            remoteScreenStream: this.remoteScreenStream.value,
            gotAllVids: this.gotAllVids.value,
            paginationHeightWidth: this.paginationHeightWidth.value,
            paginationDirection: this.paginationDirection.value,
            gridSizes: this.gridSizes.value,
            screenForceFullDisplay: this.screenForceFullDisplay.value,
            mainGridStream: this.mainGridStream.value,
            otherGridStreams: this.otherGridStreams.value,
            audioOnlyStreams: this.audioOnlyStreams.value,
            videoInputs: this.videoInputs.value,
            audioInputs: this.audioInputs.value,
            meetingProgressTime: this.meetingProgressTime.value,
            meetingElapsedTime: this.meetingElapsedTime.value,
            ref_participants: this.ref_participants.value,
            messages: this.messages.value,
            startDirectMessage: this.startDirectMessage.value,
            directMessageDetails: this.directMessageDetails.value,
            coHost: this.coHost.value,
            coHostResponsibility: this.coHostResponsibility.value,
            // Event settings
            audioSetting: this.audioSetting.value,
            videoSetting: this.videoSetting.value,
            screenshareSetting: this.screenshareSetting.value,
            chatSetting: this.chatSetting.value,
            // Display settings
            autoWave: this.autoWave.value,
            forceFullDisplay: this.forceFullDisplay.value,
            prevForceFullDisplay: this.prevForceFullDisplay.value,
            prevMeetingDisplayType: this.prevMeetingDisplayType.value,
            // Waiting room
            waitingRoomFilter: this.waitingRoomFilter.value,
            waitingRoomList: this.waitingRoomList.value,
            waitingRoomCounter: this.waitingRoomCounter.value,
            filteredWaitingRoomList: this.filteredWaitingRoomList.value,
            // Requests
            requestFilter: this.requestFilter.value,
            requestList: this.requestList.value,
            requestCounter: this.requestCounter.value,
            filteredRequestList: this.filteredRequestList.value,
            // Total requests and waiting room
            totalReqWait: this.totalReqWait.value,
            // Alerts
            alertVisible: this.alertVisible.value,
            alertMessage: this.alertMessage.value,
            alertType: this.alertType.value,
            alertDuration: this.alertDuration.value,
            // Progress Timer
            progressTimerVisible: this.progressTimerVisible.value,
            progressTimerValue: this.progressTimerValue.value,
            // Menu modals
            isMenuModalVisible: this.isMenuModalVisible.value,
            isRecordingModalVisible: this.isRecordingModalVisible.value,
            isSettingsModalVisible: this.isSettingsModalVisible.value,
            isRequestsModalVisible: this.isRequestsModalVisible.value,
            isWaitingModalVisible: this.isWaitingModalVisible.value,
            isCoHostModalVisible: this.isCoHostModalVisible.value,
            isMediaSettingsModalVisible: this.isMediaSettingsModalVisible.value,
            isDisplaySettingsModalVisible: this.isDisplaySettingsModalVisible.value,
            // Other Modals
            isParticipantsModalVisible: this.isParticipantsModalVisible.value,
            isMessagesModalVisible: this.isMessagesModalVisible.value,
            isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            isConfirmHereModalVisible: this.isConfirmHereModalVisible.value,
            isLoadingModalVisible: this.isLoadingModalVisible.value,
            // Recording Options
            recordingMediaOptions: this.recordingMediaOptions.value,
            recordingAudioOptions: this.recordingAudioOptions.value,
            recordingVideoOptions: this.recordingVideoOptions.value,
            recordingVideoType: this.recordingVideoType.value,
            recordingVideoOptimized: this.recordingVideoOptimized.value,
            recordingDisplayType: this.recordingDisplayType.value,
            recordingAddHLS: this.recordingAddHLS.value,
            recordingAddText: this.recordingAddText.value,
            recordingCustomText: this.recordingCustomText.value,
            recordingCustomTextPosition: this.recordingCustomTextPosition.value,
            recordingCustomTextColor: this.recordingCustomTextColor.value,
            recordingNameTags: this.recordingNameTags.value,
            recordingBackgroundColor: this.recordingBackgroundColor.value,
            recordingNameTagsColor: this.recordingNameTagsColor.value,
            recordingOrientationVideo: this.recordingOrientationVideo.value,
            clearedToResume: this.clearedToResume.value,
            clearedToRecord: this.clearedToRecord.value,
            recordState: this.recordState.value,
            showRecordButtons: this.showRecordButtons.value,
            recordingProgressTime: this.recordingProgressTime.value,
            audioSwitching: this.audioSwitching.value,
            videoSwitching: this.videoSwitching.value,
            // Media states
            videoAlreadyOn: this.videoAlreadyOn.value,
            audioAlreadyOn: this.audioAlreadyOn.value,
            componentSizes: this.componentSizes.value,
            // Permissions
            hasCameraPermission: this.hasCameraPermission.value,
            hasAudioPermission: this.hasAudioPermission.value,
            // Transports
            transportCreated: this.transportCreated.value,
            localTransportCreated: this.localTransportCreated.value,
            transportCreatedVideo: this.transportCreatedVideo.value,
            transportCreatedAudio: this.transportCreatedAudio.value,
            transportCreatedScreen: this.transportCreatedScreen.value,
            producerTransport: this.producerTransport.value,
            localProducerTransport: this.localProducerTransport.value,
            videoProducer: this.videoProducer.value,
            localVideoProducer: this.localVideoProducer.value,
            params: this.params.value,
            videoParams: this.videoParams.value,
            audioParams: this.audioParams.value,
            audioProducer: this.audioProducer.value,
            audioLevel: this.audioLevel.value,
            localAudioProducer: this.localAudioProducer.value,
            consumerTransports: this.consumerTransports.value,
            consumingTransports: this.consumingTransports.value,
            // Polls
            polls: this.polls.value,
            poll: this.poll.value,
            isPollModalVisible: this.isPollModalVisible.value,
            // Background
            customImage: this.customImage.value,
            selectedImage: this.selectedImage.value,
            segmentVideo: this.segmentVideo.value,
            selfieSegmentation: this.selfieSegmentation.value,
            pauseSegmentation: this.pauseSegmentation.value,
            processedStream: this.processedStream.value,
            keepBackground: this.keepBackground.value,
            backgroundHasChanged: this.backgroundHasChanged.value,
            virtualStream: this.virtualStream.value,
            mainCanvas: this.mainCanvas.value,
            prevKeepBackground: this.prevKeepBackground.value,
            appliedBackground: this.appliedBackground.value,
            isBackgroundModalVisible: this.isBackgroundModalVisible.value,
            autoClickBackground: this.autoClickBackground.value,
            // Breakout rooms
            breakoutRooms: this.breakoutRooms.value,
            currentRoomIndex: this.currentRoomIndex.value,
            canStartBreakout: this.canStartBreakout.value,
            breakOutRoomStarted: this.breakOutRoomStarted.value,
            breakOutRoomEnded: this.breakOutRoomEnded.value,
            hostNewRoom: this.hostNewRoom.value,
            limitedBreakRoom: this.limitedBreakRoom.value,
            mainRoomsLength: this.mainRoomsLength.value,
            memberRoom: this.memberRoom.value,
            isBreakoutRoomsModalVisible: this.isBreakoutRoomsModalVisible.value,
            // Whiteboard
            whiteboardUsers: this.whiteboardUsers.value,
            currentWhiteboardIndex: this.currentWhiteboardIndex.value,
            canStartWhiteboard: this.canStartWhiteboard.value,
            whiteboardStarted: this.whiteboardStarted.value,
            whiteboardEnded: this.whiteboardEnded.value,
            whiteboardLimit: this.whiteboardLimit.value,
            isWhiteboardModalVisible: this.isWhiteboardModalVisible.value,
            isConfigureWhiteboardModalVisible: this.isConfigureWhiteboardModalVisible.value,
            shapes: this.shapes.value,
            useImageBackground: this.useImageBackground.value,
            redoStack: this.redoStack.value,
            undoStack: this.undoStack.value,
            canvasStream: this.canvasStream.value,
            canvasWhiteboard: this.canvasWhiteboard.value,
            // Screenboard
            canvasScreenboard: this.canvasScreenboard.value,
            processedScreenStream: this.processedScreenStream.value,
            annotateScreenStream: this.annotateScreenStream.value,
            mainScreenCanvas: this.mainScreenCanvas.value,
            isScreenboardModalVisible: this.isScreenboardModalVisible.value,
            validated: this.validated.value,
            device: this.device.value,
            socket: this.socket.value,
            localSocket: this.localSocket.value,
            checkMediaPermission: false,
            onWeb: true,
            // Update functions
            updateRoomName: this.updateRoomName.bind(this),
            updateMember: this.updateMember.bind(this),
            updateAdminPasscode: this.updateAdminPasscode.bind(this),
            updateYouAreCoHost: this.updateYouAreCoHost.bind(this),
            updateYouAreHost: this.updateYouAreHost.bind(this),
            updateIslevel: this.updateIslevel.bind(this),
            updateCoHost: this.updateCoHost.bind(this),
            updateCoHostResponsibility: this.updateCoHostResponsibility.bind(this),
            updateConfirmedToRecord: this.updateConfirmedToRecord.bind(this),
            updateMeetingDisplayType: this.updateMeetingDisplayType.bind(this),
            updateMeetingVideoOptimized: this.updateMeetingVideoOptimized.bind(this),
            updateEventType: this.updateEventType.bind(this),
            updateParticipants: this.updateParticipants.bind(this),
            updateParticipantsCounter: this.updateParticipantsCounter.bind(this),
            updateParticipantsFilter: this.updateParticipantsFilter.bind(this),
            // More update functions for media details
            updateConsume_sockets: this.updateConsume_sockets.bind(this),
            updateRtpCapabilities: this.updateRtpCapabilities.bind(this),
            updateRoomRecvIPs: this.updateRoomRecvIPs.bind(this),
            updateMeetingRoomParams: this.updateMeetingRoomParams.bind(this),
            updateItemPageLimit: this.updateItemPageLimit.bind(this),
            updateAudioOnlyRoom: this.updateAudioOnlyRoom.bind(this),
            updateAddForBasic: this.updateAddForBasic.bind(this),
            updateScreenPageLimit: this.updateScreenPageLimit.bind(this),
            updateShareScreenStarted: this.updateShareScreenStarted.bind(this),
            updateShared: this.updateShared.bind(this),
            updateTargetOrientation: this.updateTargetOrientation.bind(this),
            updateTargetResolution: this.updateTargetResolution.bind(this),
            updateTargetResolutionHost: this.updateTargetResolutionHost.bind(this),
            updateVidCons: this.updateVidCons.bind(this),
            updateFrameRate: this.updateFrameRate.bind(this),
            updateHParams: this.updateHParams.bind(this),
            updateVParams: this.updateVParams.bind(this),
            updateScreenParams: this.updateScreenParams.bind(this),
            updateAParams: this.updateAParams.bind(this),
            // More update functions for recording details
            updateRecordingAudioPausesLimit: this.updateRecordingAudioPausesLimit.bind(this),
            updateRecordingAudioPausesCount: this.updateRecordingAudioPausesCount.bind(this),
            updateRecordingAudioSupport: this.updateRecordingAudioSupport.bind(this),
            updateRecordingAudioPeopleLimit: this.updateRecordingAudioPeopleLimit.bind(this),
            updateRecordingAudioParticipantsTimeLimit: this.updateRecordingAudioParticipantsTimeLimit.bind(this),
            updateRecordingVideoPausesCount: this.updateRecordingVideoPausesCount.bind(this),
            updateRecordingVideoPausesLimit: this.updateRecordingVideoPausesLimit.bind(this),
            updateRecordingVideoSupport: this.updateRecordingVideoSupport.bind(this),
            updateRecordingVideoPeopleLimit: this.updateRecordingVideoPeopleLimit.bind(this),
            updateRecordingVideoParticipantsTimeLimit: this.updateRecordingVideoParticipantsTimeLimit.bind(this),
            updateRecordingAllParticipantsSupport: this.updateRecordingAllParticipantsSupport.bind(this),
            updateRecordingVideoParticipantsSupport: this.updateRecordingVideoParticipantsSupport.bind(this),
            updateRecordingAllParticipantsFullRoomSupport: this.updateRecordingAllParticipantsFullRoomSupport.bind(this),
            updateRecordingVideoParticipantsFullRoomSupport: this.updateRecordingVideoParticipantsFullRoomSupport.bind(this),
            updateRecordingPreferredOrientation: this.updateRecordingPreferredOrientation.bind(this),
            updateRecordingSupportForOtherOrientation: this.updateRecordingSupportForOtherOrientation.bind(this),
            updateRecordingMultiFormatsSupport: this.updateRecordingMultiFormatsSupport.bind(this),
            updateUserRecordingParams: this.updateUserRecordingParams.bind(this),
            updateCanRecord: this.updateCanRecord.bind(this),
            updateStartReport: this.updateStartReport.bind(this),
            updateEndReport: this.updateEndReport.bind(this),
            updateRecordTimerInterval: this.updateRecordTimerInterval.bind(this),
            updateRecordStartTime: this.updateRecordStartTime.bind(this),
            updateRecordElapsedTime: this.updateRecordElapsedTime.bind(this),
            updateIsTimerRunning: this.updateIsTimerRunning.bind(this),
            updateCanPauseResume: this.updateCanPauseResume.bind(this),
            updateRecordChangeSeconds: this.updateRecordChangeSeconds.bind(this),
            updatePauseLimit: this.updatePauseLimit.bind(this),
            updatePauseRecordCount: this.updatePauseRecordCount.bind(this),
            updateCanLaunchRecord: this.updateCanLaunchRecord.bind(this),
            updateStopLaunchRecord: this.updateStopLaunchRecord.bind(this),
            updateParticipantsAll: this.updateParticipantsAll.bind(this),
            updateFirstAll: this.updateFirstAll.bind(this),
            updateUpdateMainWindow: this.updateUpdateMainWindow.bind(this),
            updateFirst_round: this.updateFirst_round.bind(this),
            updateLandScaped: this.updateLandScaped.bind(this),
            updateLock_screen: this.updateLock_screen.bind(this),
            updateScreenId: this.updateScreenId.bind(this),
            updateAllVideoStreams: this.updateAllVideoStreams.bind(this),
            updateNewLimitedStreams: this.updateNewLimitedStreams.bind(this),
            updateNewLimitedStreamsIDs: this.updateNewLimitedStreamsIDs.bind(this),
            updateActiveSounds: this.updateActiveSounds.bind(this),
            updateScreenShareIDStream: this.updateScreenShareIDStream.bind(this),
            updateScreenShareNameStream: this.updateScreenShareNameStream.bind(this),
            updateAdminIDStream: this.updateAdminIDStream.bind(this),
            updateAdminNameStream: this.updateAdminNameStream.bind(this),
            updateYouYouStream: this.updateYouYouStream.bind(this),
            updateYouYouStreamIDs: this.updateYouYouStreamIDs.bind(this),
            updateLocalStream: this.updateLocalStream.bind(this),
            updateRecordStarted: this.updateRecordStarted.bind(this),
            updateRecordResumed: this.updateRecordResumed.bind(this),
            updateRecordPaused: this.updateRecordPaused.bind(this),
            updateRecordStopped: this.updateRecordStopped.bind(this),
            updateAdminRestrictSetting: this.updateAdminRestrictSetting.bind(this),
            updateVideoRequestState: this.updateVideoRequestState.bind(this),
            updateVideoRequestTime: this.updateVideoRequestTime.bind(this),
            updateVideoAction: this.updateVideoAction.bind(this),
            updateLocalStreamVideo: this.updateLocalStreamVideo.bind(this),
            updateUserDefaultVideoInputDevice: this.updateUserDefaultVideoInputDevice.bind(this),
            updateCurrentFacingMode: this.updateCurrentFacingMode.bind(this),
            updatePrevFacingMode: this.updatePrevFacingMode.bind(this),
            updateDefVideoID: this.updateDefVideoID.bind(this),
            updateAllowed: this.updateAllowed.bind(this),
            updateDispActiveNames: this.updateDispActiveNames.bind(this),
            updateP_dispActiveNames: this.updateP_dispActiveNames.bind(this),
            updateActiveNames: this.updateActiveNames.bind(this),
            updatePrevActiveNames: this.updatePrevActiveNames.bind(this),
            updateP_activeNames: this.updateP_activeNames.bind(this),
            updateMembersReceived: this.updateMembersReceived.bind(this),
            updateDeferScreenReceived: this.updateDeferScreenReceived.bind(this),
            updateHostFirstSwitch: this.updateHostFirstSwitch.bind(this),
            updateMicAction: this.updateMicAction.bind(this),
            updateScreenAction: this.updateScreenAction.bind(this),
            updateChatAction: this.updateChatAction.bind(this),
            updateAudioRequestState: this.updateAudioRequestState.bind(this),
            updateScreenRequestState: this.updateScreenRequestState.bind(this),
            updateChatRequestState: this.updateChatRequestState.bind(this),
            updateAudioRequestTime: this.updateAudioRequestTime.bind(this),
            updateScreenRequestTime: this.updateScreenRequestTime.bind(this),
            updateChatRequestTime: this.updateChatRequestTime.bind(this),
            updateOldSoundIds: this.updateOldSoundIds.bind(this),
            updateHostLabel: this.updateHostLabel.bind(this),
            updateMainScreenFilled: this.updateMainScreenFilled.bind(this),
            updateLocalStreamScreen: this.updateLocalStreamScreen.bind(this),
            updateScreenAlreadyOn: this.updateScreenAlreadyOn.bind(this),
            updateChatAlreadyOn: this.updateChatAlreadyOn.bind(this),
            updateRedirectURL: this.updateRedirectURL.bind(this),
            updateOldAllStreams: this.updateOldAllStreams.bind(this),
            updateAdminVidID: this.updateAdminVidID.bind(this),
            updateStreamNames: this.updateStreamNames.bind(this),
            updateNon_alVideoStreams: this.updateNon_alVideoStreams.bind(this),
            updateSortAudioLoudness: this.updateSortAudioLoudness.bind(this),
            updateAudioDecibels: this.updateAudioDecibels.bind(this),
            updateMixed_alVideoStreams: this.updateMixed_alVideoStreams.bind(this),
            updateNon_alVideoStreams_muted: this.updateNon_alVideoStreams_muted.bind(this),
            updatePaginatedStreams: this.updatePaginatedStreams.bind(this),
            updateLocalStreamAudio: this.updateLocalStreamAudio.bind(this),
            updateDefAudioID: this.updateDefAudioID.bind(this),
            updateUserDefaultAudioInputDevice: this.updateUserDefaultAudioInputDevice.bind(this),
            updateUserDefaultAudioOutputDevice: this.updateUserDefaultAudioOutputDevice.bind(this),
            updatePrevAudioInputDevice: this.updatePrevAudioInputDevice.bind(this),
            updatePrevVideoInputDevice: this.updatePrevVideoInputDevice.bind(this),
            updateAudioPaused: this.updateAudioPaused.bind(this),
            updateMainScreenPerson: this.updateMainScreenPerson.bind(this),
            updateAdminOnMainScreen: this.updateAdminOnMainScreen.bind(this),
            updateScreenStates: this.updateScreenStates.bind(this),
            updatePrevScreenStates: this.updatePrevScreenStates.bind(this),
            updateUpdateDateState: this.updateUpdateDateState.bind(this),
            updateLastUpdate: this.updateLastUpdate.bind(this),
            updateNForReadjustRecord: this.updateNForReadjustRecord.bind(this),
            updateFixedPageLimit: this.updateFixedPageLimit.bind(this),
            updateRemoveAltGrid: this.updateRemoveAltGrid.bind(this),
            updateNForReadjust: this.updateNForReadjust.bind(this),
            updateLastReorderTime: this.updateLastReorderTime.bind(this),
            updateAudStreamNames: this.updateAudStreamNames.bind(this),
            updateCurrentUserPage: this.updateCurrentUserPage.bind(this),
            updateMainHeightWidth: this.updateMainHeightWidth.bind(this),
            updatePrevMainHeightWidth: this.updatePrevMainHeightWidth.bind(this),
            updatePrevDoPaginate: this.updatePrevDoPaginate.bind(this),
            updateDoPaginate: this.updateDoPaginate.bind(this),
            updateShareEnded: this.updateShareEnded.bind(this),
            updateLStreams: this.updateLStreams.bind(this),
            updateChatRefStreams: this.updateChatRefStreams.bind(this),
            updateControlHeight: this.updateControlHeight.bind(this),
            updateIsWideScreen: this.updateIsWideScreen.bind(this),
            updateIsMediumScreen: this.updateIsMediumScreen.bind(this),
            updateIsSmallScreen: this.updateIsSmallScreen.bind(this),
            updateAddGrid: this.updateAddGrid.bind(this),
            updateAddAltGrid: this.updateAddAltGrid.bind(this),
            updateGridRows: this.updateGridRows.bind(this),
            updateGridCols: this.updateGridCols.bind(this),
            updateAltGridRows: this.updateAltGridRows.bind(this),
            updateAltGridCols: this.updateAltGridCols.bind(this),
            updateNumberPages: this.updateNumberPages.bind(this),
            updateCurrentStreams: this.updateCurrentStreams.bind(this),
            updateShowMiniView: this.updateShowMiniView.bind(this),
            updateNStream: this.updateNStream.bind(this),
            updateDefer_receive: this.updateDefer_receive.bind(this),
            updateAllAudioStreams: this.updateAllAudioStreams.bind(this),
            updateRemoteScreenStream: this.updateRemoteScreenStream.bind(this),
            updateScreenProducer: this.updateScreenProducer.bind(this),
            updateGotAllVids: this.updateGotAllVids.bind(this),
            updatePaginationHeightWidth: this.updatePaginationHeightWidth.bind(this),
            updatePaginationDirection: this.updatePaginationDirection.bind(this),
            updateGridSizes: this.updateGridSizes.bind(this),
            updateScreenForceFullDisplay: this.updateScreenForceFullDisplay.bind(this),
            updateMainGridStream: this.updateMainGridStream.bind(this),
            updateOtherGridStreams: this.updateOtherGridStreams.bind(this),
            updateAudioOnlyStreams: this.updateAudioOnlyStreams.bind(this),
            updateVideoInputs: this.updateVideoInputs.bind(this),
            updateAudioInputs: this.updateAudioInputs.bind(this),
            updateMeetingProgressTime: this.updateMeetingProgressTime.bind(this),
            updateMeetingElapsedTime: this.updateMeetingElapsedTime.bind(this),
            updateRef_participants: this.updateRef_participants.bind(this),
            updateMessages: this.updateMessages.bind(this),
            updateStartDirectMessage: this.updateStartDirectMessage.bind(this),
            updateDirectMessageDetails: this.updateDirectMessageDetails.bind(this),
            updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
            // Event settings
            updateAudioSetting: this.updateAudioSetting.bind(this),
            updateVideoSetting: this.updateVideoSetting.bind(this),
            updateScreenshareSetting: this.updateScreenshareSetting.bind(this),
            updateChatSetting: this.updateChatSetting.bind(this),
            // Display settings
            updateAutoWave: this.updateAutoWave.bind(this),
            updateForceFullDisplay: this.updateForceFullDisplay.bind(this),
            updatePrevForceFullDisplay: this.updatePrevForceFullDisplay.bind(this),
            updatePrevMeetingDisplayType: this.updatePrevMeetingDisplayType.bind(this),
            // Waiting room
            updateWaitingRoomFilter: this.updateWaitingRoomFilter.bind(this),
            updateWaitingRoomList: this.updateWaitingRoomList.bind(this),
            updateWaitingRoomCounter: this.updateWaitingRoomCounter.bind(this),
            // Requests
            updateRequestFilter: this.updateRequestFilter.bind(this),
            updateRequestList: this.updateRequestList.bind(this),
            updateRequestCounter: this.updateRequestCounter.bind(this),
            // Total requests and waiting room
            updateTotalReqWait: this.updateTotalReqWait.bind(this),
            // Menu modals
            updateIsMenuModalVisible: this.updateIsMenuModalVisible.bind(this),
            updateIsRecordingModalVisible: this.updateIsRecordingModalVisible.bind(this),
            updateIsSettingsModalVisible: this.updateIsSettingsModalVisible.bind(this),
            updateIsRequestsModalVisible: this.updateIsRequestsModalVisible.bind(this),
            updateIsWaitingModalVisible: this.updateIsWaitingModalVisible.bind(this),
            updateIsCoHostModalVisible: this.updateIsCoHostModalVisible.bind(this),
            updateIsMediaSettingsModalVisible: this.updateIsMediaSettingsModalVisible.bind(this),
            updateIsDisplaySettingsModalVisible: this.updateIsDisplaySettingsModalVisible.bind(this),
            // Other modals
            updateIsParticipantsModalVisible: this.updateIsParticipantsModalVisible.bind(this),
            updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
            updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
            updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
            updateIsLoadingModalVisible: this.updateIsLoadingModalVisible.bind(this),
            // Recording Options
            updateRecordingMediaOptions: this.updateRecordingMediaOptions.bind(this),
            updateRecordingAudioOptions: this.updateRecordingAudioOptions.bind(this),
            updateRecordingVideoOptions: this.updateRecordingVideoOptions.bind(this),
            updateRecordingVideoType: this.updateRecordingVideoType.bind(this),
            updateRecordingVideoOptimized: this.updateRecordingVideoOptimized.bind(this),
            updateRecordingDisplayType: this.updateRecordingDisplayType.bind(this),
            updateRecordingAddHLS: this.updateRecordingAddHLS.bind(this),
            updateRecordingAddText: this.updateRecordingAddText.bind(this),
            updateRecordingCustomText: this.updateRecordingCustomText.bind(this),
            updateRecordingCustomTextPosition: this.updateRecordingCustomTextPosition.bind(this),
            updateRecordingCustomTextColor: this.updateRecordingCustomTextColor.bind(this),
            updateRecordingNameTags: this.updateRecordingNameTags.bind(this),
            updateRecordingBackgroundColor: this.updateRecordingBackgroundColor.bind(this),
            updateRecordingNameTagsColor: this.updateRecordingNameTagsColor.bind(this),
            updateRecordingOrientationVideo: this.updateRecordingOrientationVideo.bind(this),
            updateClearedToResume: this.updateClearedToResume.bind(this),
            updateClearedToRecord: this.updateClearedToRecord.bind(this),
            updateRecordState: this.updateRecordState.bind(this),
            updateShowRecordButtons: this.updateShowRecordButtons.bind(this),
            updateRecordingProgressTime: this.updateRecordingProgressTime.bind(this),
            updateAudioSwitching: this.updateAudioSwitching.bind(this),
            updateVideoSwitching: this.updateVideoSwitching.bind(this),
            // Media states
            updateVideoAlreadyOn: this.updateVideoAlreadyOn.bind(this),
            updateAudioAlreadyOn: this.updateAudioAlreadyOn.bind(this),
            updateComponentSizes: this.updateComponentSizes.bind(this),
            // Permissions
            updateHasCameraPermission: this.updateHasCameraPermission.bind(this),
            updateHasAudioPermission: this.updateHasAudioPermission.bind(this),
            // Transports
            updateTransportCreated: this.updateTransportCreated.bind(this),
            updateLocalTransportCreated: this.updateLocalTransportCreated.bind(this),
            updateTransportCreatedVideo: this.updateTransportCreatedVideo.bind(this),
            updateTransportCreatedAudio: this.updateTransportCreatedAudio.bind(this),
            updateTransportCreatedScreen: this.updateTransportCreatedScreen.bind(this),
            updateProducerTransport: this.updateProducerTransport.bind(this),
            updateLocalProducerTransport: this.updateLocalProducerTransport.bind(this),
            updateVideoProducer: this.updateVideoProducer.bind(this),
            updateLocalVideoProducer: this.updateLocalVideoProducer.bind(this),
            updateParams: this.updateParams.bind(this),
            updateVideoParams: this.updateVideoParams.bind(this),
            updateAudioParams: this.updateAudioParams.bind(this),
            updateAudioProducer: this.updateAudioProducer.bind(this),
            updateAudioLevel: this.updateAudioLevel.bind(this),
            updateLocalAudioProducer: this.updateLocalAudioProducer.bind(this),
            updateConsumerTransports: this.updateConsumerTransports.bind(this),
            updateConsumingTransports: this.updateConsumingTransports.bind(this),
            // Polls
            updatePolls: this.updatePolls.bind(this),
            updatePoll: this.updatePoll.bind(this),
            updateIsPollModalVisible: this.updateIsPollModalVisible.bind(this),
            // Background
            updateCustomImage: this.updateCustomImage.bind(this),
            updateSelectedImage: this.updateSelectedImage.bind(this),
            updateSegmentVideo: this.updateSegmentVideo.bind(this),
            updateSelfieSegmentation: this.updateSelfieSegmentation.bind(this),
            updatePauseSegmentation: this.updatePauseSegmentation.bind(this),
            updateProcessedStream: this.updateProcessedStream.bind(this),
            updateKeepBackground: this.updateKeepBackground.bind(this),
            updateBackgroundHasChanged: this.updateBackgroundHasChanged.bind(this),
            updateVirtualStream: this.updateVirtualStream.bind(this),
            updateMainCanvas: this.updateMainCanvas.bind(this),
            updatePrevKeepBackground: this.updatePrevKeepBackground.bind(this),
            updateAppliedBackground: this.updateAppliedBackground.bind(this),
            updateIsBackgroundModalVisible: this.updateIsBackgroundModalVisible.bind(this),
            updateAutoClickBackground: this.updateAutoClickBackground.bind(this),
            // Breakout rooms
            updateBreakoutRooms: this.updateBreakoutRooms.bind(this),
            updateCurrentRoomIndex: this.updateCurrentRoomIndex.bind(this),
            updateCanStartBreakout: this.updateCanStartBreakout.bind(this),
            updateBreakOutRoomStarted: this.updateBreakOutRoomStarted.bind(this),
            updateBreakOutRoomEnded: this.updateBreakOutRoomEnded.bind(this),
            updateHostNewRoom: this.updateHostNewRoom.bind(this),
            updateLimitedBreakRoom: this.updateLimitedBreakRoom.bind(this),
            updateMainRoomsLength: this.updateMainRoomsLength.bind(this),
            updateMemberRoom: this.updateMemberRoom.bind(this),
            updateIsBreakoutRoomsModalVisible: this.updateIsBreakoutRoomsModalVisible.bind(this),
            // Whiteboard
            updateWhiteboardUsers: this.updateWhiteboardUsers.bind(this),
            updateCurrentWhiteboardIndex: this.updateCurrentWhiteboardIndex.bind(this),
            updateCanStartWhiteboard: this.updateCanStartWhiteboard.bind(this),
            updateWhiteboardStarted: this.updateWhiteboardStarted.bind(this),
            updateWhiteboardEnded: this.updateWhiteboardEnded.bind(this),
            updateWhiteboardLimit: this.updateWhiteboardLimit.bind(this),
            updateIsWhiteboardModalVisible: this.updateIsWhiteboardModalVisible.bind(this),
            updateIsConfigureWhiteboardModalVisible: this.updateIsConfigureWhiteboardModalVisible.bind(this),
            updateShapes: this.updateShapes.bind(this),
            updateUseImageBackground: this.updateUseImageBackground.bind(this),
            updateRedoStack: this.updateRedoStack.bind(this),
            updateUndoStack: this.updateUndoStack.bind(this),
            updateCanvasStream: this.updateCanvasStream.bind(this),
            updateCanvasWhiteboard: this.updateCanvasWhiteboard.bind(this),
            // Screenboard
            updateCanvasScreenboard: this.updateCanvasScreenboard.bind(this),
            updateProcessedScreenStream: this.updateProcessedScreenStream.bind(this),
            updateAnnotateScreenStream: this.updateAnnotateScreenStream.bind(this),
            updateMainScreenCanvas: this.updateMainScreenCanvas.bind(this),
            updateIsScreenboardModalVisible: this.updateIsScreenboardModalVisible.bind(this),
            // Other functions
            checkOrientation: this.checkOrientation.bind(this),
            updateDevice: this.updateDevice.bind(this),
            updateSocket: this.updateSocket.bind(this),
            updateLocalSocket: this.updateLocalSocket.bind(this),
            updateValidated: this.updateValidated.bind(this),
            showAlert: this.showAlert.bind(this),
            getUpdatedAllParams: () => {
                try {
                    if (this.sourceParameters !== null) {
                        this.sourceParameters = {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        };
                        if (this.updateSourceParameters) {
                            this.updateSourceParameters(this.sourceParameters);
                        }
                    }
                }
                catch {
                    console.log('error updateSourceParameters');
                }
                return {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                };
            },
        };
    }
    mediaSFUParameters = {
        ...this.getAllParams(),
        ...this.mediaSFUFunctions(),
    };
    getUpdatedAllParams = () => {
        return {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    };
    PrejoinPageComponent = {
        component: this.PrejoinPage,
        injector: null,
    };
    updatePrejoinPageComponent = () => {
        const PrejoinComp = {
            component: this.PrejoinPage,
            injector: this.createInjector({
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    connectLocalSocket: this.socketManager.connectLocalSocket,
                    updateSocket: this.updateSocket,
                    updateLocalSocket: this.updateLocalSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                credentials: this.credentials,
                localLink: this.localLink,
                connectMediaSFU: this.connectMediaSFU,
                returnUI: this.returnUI,
                noUIPreJoinOptions: this.noUIPreJoinOptions,
                joinMediaSFURoom: this.joinMediaSFURoom,
                createMediaSFURoom: this.createMediaSFURoom,
            }),
        };
        this.PrejoinPageComponent = { ...PrejoinComp };
        this.cdr.detectChanges();
    };
    ngOnInit() {
        if (this.PrejoinPage) {
            this.updatePrejoinPageComponent();
        }
        this.setupResizeListener();
        if (this.validated) {
            this.connectAndAddSocketMethods();
        }
        this.mainHeightWidthSubscription = this.mainHeightWidth.subscribe(() => {
            this.updateMainVideoSize();
        });
        this.validatedSubscription = this.validated.subscribe((validated) => {
            if (validated) {
                this.handleValidated();
            }
        });
        this.islevelSubscription = this.islevel.subscribe((islevel) => {
            if (islevel) {
                this.updateControlChatButtons();
            }
        });
        this.coHostSubscription = combineLatest([this.coHost, this.coHostResponsibility]).subscribe(([coHost, coHostResponsibility]) => {
            if (coHost || coHostResponsibility) {
                this.updateControlChatButtons();
            }
        });
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
    }
    ngOnDestroy() {
        window.removeEventListener('resize', this.handleResize);
        window.removeEventListener('orientationchange', this.handleResize);
        if (this.mainHeightWidthSubscription) {
            this.mainHeightWidthSubscription.unsubscribe();
        }
        if (this.validatedSubscription) {
            this.validatedSubscription.unsubscribe();
        }
        if (this.islevelSubscription) {
            this.islevelSubscription.unsubscribe();
        }
        if (this.coHostSubscription) {
            this.coHostSubscription.unsubscribe();
        }
        if (this.ScreenboardSubscription) {
            this.ScreenboardSubscription.unsubscribe();
        }
        if (this.recordingSubscription) {
            this.recordingSubscription.unsubscribe();
        }
    }
    updateMainVideoSize = async () => {
        if (!this.lock_screen.value && !this.shared.value) {
            this.prepopulateUserMedia.prepopulateUserMedia({
                name: this.hostLabel.value,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
        }
        else {
            if (!this.first_round.value) {
                this.prepopulateUserMedia.prepopulateUserMedia({
                    name: this.hostLabel.value,
                    parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                });
            }
        }
    };
    async connectAndAddSocketMethods() {
        this.mediaSFUParameters = {
            ...this.getAllParams(),
            ...this.mediaSFUFunctions(),
        };
        const socket_ = await this.connect_Socket(this.apiUserName.value, this.apiToken.value);
        if (socket_) {
            this.updateSocket(socket_);
        }
    }
    async handleValidated() {
        this.updateAllVideoStreams([
            { producerId: 'youyou', stream: undefined, id: 'youyou', name: 'youyou' },
        ]);
        this.updateStreamNames([{ id: 'youyou', name: 'youyou', producerId: '' }]);
        if (this.validated.value) {
            try {
                if (!this.localUIMode.value) {
                    this.updateIsLoadingModalVisible(true);
                    await this.connectAndAddSocketMethods();
                }
                else {
                    this.updateIsLoadingModalVisible(false);
                }
            }
            catch (error) {
                console.log('error connectAndaAddSocketMethods', error);
            }
            this.startMeetingProgressTimer.startMeetingProgressTimer({
                startTime: Date.now() / 1000,
                parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
            });
            try {
                if (this.sourceParameters !== null) {
                    this.sourceParameters = {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                    };
                    if (this.updateSourceParameters) {
                        this.updateSourceParameters(this.sourceParameters);
                    }
                }
            }
            catch {
                console.log('error updateSourceParameters');
            }
        }
    }
    async handleResize() {
        let fraction = 0;
        if (window.innerHeight < window.innerWidth &&
            (this.eventType.value == 'webinar' || this.eventType.value == 'conference')) {
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        else {
            // Set default control button height for portrait mode or other event types
            const currentHeight = window.innerHeight;
            fraction = Number((40 / currentHeight).toFixed(3));
            fraction = Number(fraction);
            if (fraction != this.controlHeight.value) {
                this.updateControlHeight(Number(fraction));
            }
        }
        const dimensions = this.computeDimensionsMethod({
            containerWidthFraction: 1,
            containerHeightFraction: 1,
            mainSize: this.mainHeightWidth.value,
            doStack: true,
            defaultFraction: this.eventType.value == 'webinar' || this.eventType.value == 'conference'
                ? 1 - fraction
                : 1,
        });
        this.updateComponentSizes(dimensions);
        const orientation = this.checkOrientation();
        if (orientation == 'portrait') {
            if (!this.isWideScreen.value) {
                if (this.shareScreenStarted.value || this.shared.value) {
                    this.updateScreenForceFullDisplay(true);
                }
            }
        }
        // Updates the main grid view
        await this.prepopulateUserMedia.prepopulateUserMedia({
            name: this.hostLabel.value,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
        // Updates the mini grid view
        await this.onScreenChanges.onScreenChanges({
            changed: true,
            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
        });
    }
    async disconnectAllSockets(consume_sockets) {
        for (const socket of consume_sockets) {
            try {
                const ip = Object.keys(socket)[0];
                await socket[ip].disconnect();
            }
            catch (error) {
                console.log(`Error disconnecting socket with IP: ${Object.keys(socket)[0]}`, error);
            }
        }
    }
    async closeAndReset() {
        //close and clean up all sockets, modals,... and reset all states to initial values
        this.updateIsMessagesModalVisible(false);
        this.updateIsParticipantsModalVisible(false);
        this.updateIsWaitingModalVisible(false);
        this.updateIsRequestsModalVisible(false);
        this.updateIsCoHostModalVisible(false);
        this.updateIsSettingsModalVisible(false);
        this.updateIsDisplaySettingsModalVisible(false);
        this.updateIsMediaSettingsModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsShareEventModalVisible(false);
        this.updateIsConfirmExitModalVisible(false);
        await this.disconnectAllSockets(this.consume_sockets.value);
        await this.updateStatesToInitialValues();
        this.updateMeetingProgressTime('00:00:00');
        this.updateMeetingElapsedTime(0);
        this.updateRecordingProgressTime('00:00:00');
        this.updateRecordElapsedTime(0);
        this.updateShowRecordButtons(false);
        this.updateIsConfigureWhiteboardModalVisible(false);
        this.updateIsWhiteboardModalVisible(false);
        this.updateIsMenuModalVisible(false);
        this.updateIsRecordingModalVisible(false);
        this.updateIsPollModalVisible(false);
        this.updateIsBreakoutRoomsModalVisible(false);
        this.updateIsBackgroundModalVisible(false);
        this.updateIsLoadingModalVisible(false);
        this.updateIsConfirmHereModalVisible(false);
        await sleep({ ms: 500 });
        this.updateValidated(false);
        //if on web, reload the page
        window.location.reload();
    }
    computeDimensionsMethod = ({ containerWidthFraction = 1, containerHeightFraction = 1, mainSize, doStack = true, defaultFraction, }) => {
        const parentWidth = window.innerWidth * containerWidthFraction;
        const parentHeight = window.innerHeight * containerHeightFraction * defaultFraction;
        let isWideScreen = parentWidth >= 768;
        if (!isWideScreen && parentWidth > 1.5 * parentHeight) {
            isWideScreen = true;
        }
        this.updateIsWideScreen(isWideScreen);
        const dimensions = this.calculateDimensions({
            parentWidth,
            parentHeight,
            isWideScreen,
            mainSize,
            doStack,
        });
        return dimensions;
    };
    calculateDimensions({ parentWidth, parentHeight, isWideScreen, mainSize, doStack, }) {
        if (doStack) {
            return isWideScreen
                ? {
                    mainHeight: Math.floor(parentHeight),
                    otherHeight: Math.floor(parentHeight),
                    mainWidth: Math.floor((mainSize / 100) * parentWidth),
                    otherWidth: Math.floor(((100 - mainSize) / 100) * parentWidth),
                }
                : {
                    mainHeight: Math.floor((mainSize / 100) * parentHeight),
                    otherHeight: Math.floor(((100 - mainSize) / 100) * parentHeight),
                    mainWidth: Math.floor(parentWidth),
                    otherWidth: Math.floor(parentWidth),
                };
        }
        else {
            return {
                mainHeight: Math.floor(parentHeight),
                otherHeight: Math.floor(parentHeight),
                mainWidth: Math.floor(parentWidth),
                otherWidth: Math.floor(parentWidth),
            };
        }
    }
    handleOrientationChange() {
        window.addEventListener('resize', this.handleResize.bind(this));
        window.addEventListener('orientationchange', this.handleResize.bind(this));
    }
    setupResizeListener() {
        this.handleResize();
    }
    orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    async joinRoom(data) {
        const { socket, roomName, islevel, member, sec, apiUserName } = data;
        try {
            const response = await this.joinRoomClient.joinRoomClient({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
            return response;
        }
        catch (error) {
            console.log('Error joining room:', error);
            throw new Error('Failed to join the room. Please check your connection and try again.');
        }
    }
    async join_Room({ socket, roomName, islevel, member, sec, apiUserName, isLocal = false, }) {
        let data;
        if (!isLocal) {
            data = await this.joinRoom({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
            });
        }
        else {
            const localData = await this.joinLocalRoom.joinLocalRoom({
                socket,
                roomName,
                islevel,
                member,
                sec,
                apiUserName,
                parameters: {
                    showAlert: this.showAlert ||
                        (() => {
                            console.log('showAlert not defined');
                        }),
                    updateIsLoadingModalVisible: this.updateIsLoadingModalVisible,
                    connectSocket: this.socketManager.connectSocket,
                    connectLocalSocket: this.socketManager.connectLocalSocket,
                    updateSocket: this.updateSocket,
                    updateLocalSocket: this.updateLocalSocket,
                    updateValidated: this.updateValidated,
                    updateApiUserName: this.updateApiUserName,
                    updateApiToken: this.updateApiToken,
                    updateLink: this.updateLink,
                    updateRoomName: this.updateRoomName,
                    updateMember: this.updateMember,
                },
                checkConnect: this.localLink.length > 0 &&
                    this.connectMediaSFU === true &&
                    !this.link.value.includes('mediasfu.com'),
                localLink: this.localLink,
                joinMediaSFURoom: this.joinMediaSFURoom,
            });
            data = await createResponseJoinRoom({ localRoom: localData });
        }
        const updateAndComplete = async (data) => {
            // Update room parameters
            try {
                // Check if roomRecvIPs is not empty
                if (!data.roomRecvIPs || data.roomRecvIPs.length === 0) {
                    data.roomRecvIPs = ['none'];
                    if (this.link.value !== "" &&
                        this.link.value.includes("mediasfu.com") &&
                        !isLocal) {
                        // Community Edition Only
                        await this.receiveAllPipedTransports.receiveAllPipedTransports({
                            community: true,
                            nsock: this.getUpdatedAllParams().socket,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                }
                this.updateRoomParametersClient.updateRoomParametersClient({
                    parameters: {
                        ...this.getAllParams(),
                        ...this.mediaSFUFunctions(),
                        data: data,
                    },
                });
                if (data.isHost) {
                    this.updateIslevel('2');
                }
                else {
                    // Issue with isHost for local room
                    if (islevel !== '2') {
                        this.updateIslevel('1');
                    }
                }
                if (data.secureCode && data.secureCode !== '') {
                    this.updateAdminPasscode(data.secureCode);
                }
                if (data.rtpCapabilities) {
                    try {
                        const device_ = await this.createDeviceClient.createDeviceClient({
                            rtpCapabilities: data.rtpCapabilities,
                        });
                        if (device_) {
                            this.device.next(device_);
                        }
                    }
                    catch (error) {
                        console.error('Error creating device:', error);
                    }
                }
            }
            catch (error) {
                console.error('Error in updateAndComplete:', error);
            }
        };
        if (data && data.success) {
            if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && isLocal) {
                this.roomData.next(data);
                return;
            }
            else if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && !isLocal) {
                // Update roomData
                if (this.roomData.value) {
                    // Updating only the recording and meeting room parameters
                    this.roomData.value.recordingParams = data.recordingParams;
                    this.roomData.value.meetingRoomParams = data.meetingRoomParams;
                    this.roomData.next(this.roomData.value);
                }
                else {
                    this.roomData.next(data);
                }
            }
            else {
                // Update roomData
                this.roomData.next(data);
                if (!this.link.value.includes('mediasfu.com')) {
                    this.roomData.value.meetingRoomParams = data.meetingRoomParams;
                }
            }
            await updateAndComplete(data);
        }
        else {
            if (this.link.value !== '' && this.link.value.includes('mediasfu.com') && !isLocal) {
                // Join local room only
                if (this.roomData.value) {
                    await updateAndComplete(this.roomData.value);
                }
                return;
            }
            // Might be a wrong room name or room is full or other error; check reason in data object if available
            try {
                if (this.showAlert && data?.reason) {
                    this.showAlert({
                        message: data.reason,
                        type: 'danger',
                        duration: 3000,
                    });
                }
            }
            catch (error) {
                /* handle error */
            }
        }
    }
    updateStatesToInitialValues = async () => {
        const initialValues = initialValuesState;
        const updateFunctions = this.getAllParams();
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                const updateFunctionName = `update${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const updateFunction = updateFunctions[updateFunctionName];
                if (typeof updateFunction === 'function') {
                    try {
                        updateFunction(initialValues[key]);
                    }
                    catch {
                        /* handle error */
                    }
                }
            }
        }
    };
    faMicrophone = faMicrophone;
    faMicrophoneSlash = faMicrophoneSlash;
    faVideo = faVideo;
    faVideoSlash = faVideoSlash;
    faSync = faSync;
    faPhone = faPhone;
    faShareAlt = faShareAlt;
    faComments = faComments;
    onCloseMenuModal = () => {
        this.updateIsMenuModalVisible(false);
    };
    onEventSettingsClose = () => {
        this.updateIsSettingsModalVisible(false);
    };
    onCoHostClose = () => {
        this.updateIsCoHostModalVisible(false);
    };
    onMediaSettingsClose = () => {
        this.updateIsMediaSettingsModalVisible(false);
    };
    onDisplaySettingsClose = () => {
        this.updateIsDisplaySettingsModalVisible(false);
    };
    onPollClose = () => {
        this.updateIsPollModalVisible(false);
    };
    onBreakoutRoomsClose = () => {
        this.updateIsBreakoutRoomsModalVisible(false);
    };
    onConfigureWhiteboardClose = () => {
        this.updateIsConfigureWhiteboardModalVisible(false);
    };
    onMessagesClose = () => {
        this.updateIsMessagesModalVisible(false);
    };
    onRecordingClose = () => {
        this.updateIsRecordingModalVisible(false);
    };
    onParticipantsClose = () => {
        this.updateIsParticipantsModalVisible(false);
    };
    onBackgroundClose = () => {
        this.updateIsBackgroundModalVisible(false);
    };
    onConfirmExitClose = () => {
        this.updateIsConfirmExitModalVisible(false);
    };
    onConfirmHereClose = () => {
        this.updateIsConfirmHereModalVisible(false);
    };
    onScreenboardClose = () => {
        this.updateIsScreenboardModalVisible(false);
    };
    onShareEventClose = () => {
        this.updateIsShareEventModalVisible(false);
    };
    onAlertHide = () => {
        this.updateAlertVisible(false);
    };
    messageWidget = {
        component: MessageWidget,
        injector: this.createInjector({
            icon: this.faComments,
            showBadge: this.showMessagesBadge.value,
            badgeValue: 1,
            iconColor: 'black',
        }),
    };
    controlChatButtons = [];
    controlChatButtonsArray = [
        {
            icon: this.faShareAlt,
            active: true,
            alternateIcon: this.faShareAlt,
            onPress: () => this.updateIsShareEventModalVisible(!this.isShareEventModalVisible.value),
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
        {
            customComponent: this.messageWidget,
            onPress: () => this.launchMessages.launchMessages({
                updateIsMessagesModalVisible: this.updateIsMessagesModalVisible.bind(this),
                isMessagesModalVisible: this.isMessagesModalVisible.value,
            }),
            show: true,
        },
        {
            icon: this.faSync,
            active: true,
            alternateIcon: this.faSync,
            onPress: () => this.switchVideoAlt.switchVideoAlt({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'black',
            inActiveColor: 'black',
            show: true,
        },
        {
            icon: this.faVideoSlash,
            alternateIcon: this.faVideo,
            active: () => this.videoActive.value,
            onPress: () => this.clickVideo.clickVideo({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
        {
            icon: this.faMicrophoneSlash,
            alternateIcon: this.faMicrophone,
            active: () => this.micActive.value,
            onPress: () => this.clickAudio.clickAudio({
                parameters: {
                    ...this.getAllParams(),
                    ...this.mediaSFUFunctions(),
                },
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
        {
            icon: this.faPhone,
            active: this.endCallActive.value,
            onPress: () => this.launchConfirmExit.launchConfirmExit({
                updateIsConfirmExitModalVisible: this.updateIsConfirmExitModalVisible.bind(this),
                isConfirmExitModalVisible: this.isConfirmExitModalVisible.value,
            }),
            activeColor: 'green',
            inActiveColor: 'red',
            show: true,
        },
    ];
    updateControlChatButtons() {
        this.controlChatButtons = this.controlChatButtonsArray.map((button) => {
            return {
                ...button,
                show: typeof button.show === 'function' ? button.show() : button.show,
                active: typeof button.active === 'function' ? button.active() : button.active,
            };
        });
    }
    async connect_Socket(apiUserName, token, skipSockets = false) {
        const socketDefault = this.socket.value;
        const socketAlt = this.connectMediaSFU && this.localSocket.value && this.localSocket.value.id
            ? this.localSocket.value
            : socketDefault;
        if (this.socket.value && this.socket.value.id) {
            if (!skipSockets) {
                // Event listeners on socketDefault
                socketDefault.on('disconnect', async () => {
                    await this.disconnect.disconnect({
                        showAlert: this.showAlert.bind(this),
                        redirectURL: this.redirectURL.value,
                        onWeb: true,
                        updateValidated: this.updateValidated.bind(this),
                    });
                    if (this.videoAlreadyOn.value) {
                        await this.clickVideo.clickVideo({
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    if (this.audioAlreadyOn.value) {
                        await this.clickAudio.clickAudio({
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                    await this.closeAndReset();
                });
                socketDefault.on('allMembers', async (membersData) => {
                    if (membersData) {
                        await this.allMembers.allMembers({
                            apiUserName: apiUserName,
                            apiKey: '', //not recommended - use apiToken instead. Use for testing/development only
                            apiToken: token,
                            members: membersData.members,
                            requestss: membersData.requests ? membersData.requests : this.requestList.value,
                            coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                            coHostRes: membersData.coHostResponsibilities
                                ? membersData.coHostResponsibilities
                                : this.coHostResponsibility.value,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                            consume_sockets: this.consume_sockets.value,
                        });
                    }
                });
                socketDefault.on('allMembersRest', async (membersData) => {
                    if (membersData) {
                        await this.allMembersRest.allMembersRest({
                            apiUserName: apiUserName,
                            apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                            members: membersData.members,
                            apiToken: token,
                            settings: membersData.settings,
                            coHoste: membersData.coHost ? membersData.coHost : this.coHost.value,
                            coHostRes: membersData.coHostResponsibilities
                                ? membersData.coHostResponsibilities
                                : this.coHostResponsibility.value,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                            consume_sockets: this.consume_sockets.value,
                        });
                    }
                });
                socketDefault.on('producer-media-paused', async ({ producerId, kind, name, }) => {
                    await this.producerMediaPaused.producerMediaPaused({
                        producerId,
                        kind,
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('producer-media-resumed', async ({ kind, name }) => {
                    await this.producerMediaResumed.producerMediaResumed({
                        kind,
                        name,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                });
                socketDefault.on('producer-media-closed', async ({ producerId, kind, }) => {
                    if (producerId && kind) {
                        await this.producerMediaClosed.producerMediaClosed({
                            producerId,
                            kind,
                            parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                        });
                    }
                });
                socketDefault.on('meetingEnded', async () => {
                    await this.meetingEnded.meetingEnded({
                        showAlert: this.showAlert.bind(this),
                        redirectURL: this.redirectURL.value,
                        onWeb: true,
                        eventType: this.eventType.value,
                        updateValidated: this.updateValidated.bind(this),
                    });
                    if (this.videoAlreadyOn.value) {
                        await this.clickVideo.clickVideo({
                            parameters: {
                                ...this.getAllParams(),
                                ...this.mediaSFUFunctions(),
                            },
                        });
                    }
                    if (this.audioAlreadyOn.value) {
                        await this.clickAudio.clickAudio({
                            parameters: {
                                ...this.getAllParams(),
                                ...this.mediaSFUFunctions(),
                            },
                        });
                    }
                    await this.closeAndReset();
                });
                socketDefault.on('disconnectUserSelf', async () => {
                    await this.disconnectUserSelf.disconnectUserSelf({
                        socket: socketDefault,
                        member: this.member.value,
                        roomName: this.roomName.value,
                    });
                });
                socketDefault.on('receiveMessage', async ({ message }) => {
                    await this.receiveMessage.receiveMessage({
                        message,
                        messages: this.messages.value,
                        participantsAll: this.participantsAll.value,
                        member: this.member.value,
                        eventType: this.eventType.value,
                        islevel: this.islevel.value,
                        coHost: this.coHost.value,
                        updateMessages: this.updateMessages.bind(this),
                        updateShowMessagesBadge: this.updateShowMessagesBadge.bind(this),
                    });
                });
                socketDefault.on('meetingTimeRemaining', async ({ timeRemaining }) => {
                    await this.meetingTimeRemaining.meetingTimeRemaining({
                        timeRemaining,
                        showAlert: this.showAlert.bind(this),
                        eventType: this.eventType.value,
                    });
                });
                socketDefault.on('meetingStillThere', async () => {
                    this.meetingStillThere.meetingStillThere({
                        updateIsConfirmHereModalVisible: this.updateIsConfirmHereModalVisible.bind(this),
                    });
                });
                socketDefault.on('updateConsumingDomains', async ({ domains, alt_domains }) => {
                    await this.updateConsumingDomains.updateConsumingDomains({
                        domains,
                        alt_domains,
                        apiUserName,
                        apiKey: '', // not recommended - use apiToken instead. Use for testing/development only
                        apiToken: token,
                        parameters: {
                            ...this.getAllParams(),
                            ...this.mediaSFUFunctions(),
                        },
                    });
                });
            }
            if (this.localLink !== "" && socketDefault && !skipSockets) {
                await this.join_Room({
                    socket: socketDefault,
                    roomName: this.roomName.value,
                    islevel: this.islevel.value,
                    member: this.member.value,
                    sec: token,
                    apiUserName: apiUserName,
                    isLocal: true,
                });
            }
            // Check if localSocket has changed
            const localChanged = this.localSocket.value && this.localSocket.value.id && this.localSocket.value.id !== socketAlt.id;
            if (!skipSockets && localChanged) {
                // Re-call connect_Socket with skipSockets = true
                await this.connect_Socket(apiUserName, token, true);
                await sleep({ ms: 1000 });
                this.updateIsLoadingModalVisible(false);
                return socketDefault;
            }
            else {
                if (this.link.value !== '' && this.link.value.includes('mediasfu.com')) {
                    // Token might be different for local room
                    const token = this.apiToken.value;
                    await this.join_Room({
                        socket: this.connectMediaSFU && socketAlt && socketAlt.id ? socketAlt : socketDefault,
                        roomName: this.roomName.value,
                        islevel: this.islevel.value,
                        member: this.member.value,
                        sec: token,
                        apiUserName: apiUserName,
                    });
                }
                await this.receiveRoomMessages.receiveRoomMessages({
                    socket: socketDefault,
                    roomName: this.roomName.value,
                    updateMessages: this.updateMessages.bind(this),
                });
                if (!skipSockets) {
                    await this.prepopulateUserMedia.prepopulateUserMedia({
                        name: this.hostLabel.value,
                        parameters: { ...this.getAllParams(), ...this.mediaSFUFunctions() },
                    });
                }
                return socketDefault;
            }
        }
        else {
            return null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediasfuChat, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.Injector }, { token: UpdateMiniCardsGrid }, { token: MixStreams }, { token: DispStreams }, { token: StopShareScreen }, { token: CheckScreenShare }, { token: StartShareScreen }, { token: RequestScreenShare }, { token: ReorderStreams }, { token: PrepopulateUserMedia }, { token: GetVideos }, { token: RePort }, { token: Trigger }, { token: ConsumerResume }, { token: ConnectSendTransport }, { token: ConnectSendTransportAudio }, { token: ConnectSendTransportVideo }, { token: ConnectSendTransportScreen }, { token: ProcessConsumerTransports }, { token: ResumePauseStreams }, { token: Readjust }, { token: CheckGrid }, { token: GetEstimate }, { token: CalculateRowsAndColumns }, { token: AddVideosGrid }, { token: OnScreenChanges }, { token: ChangeVids }, { token: CompareActiveNames }, { token: CompareScreenStates }, { token: CreateSendTransport }, { token: ResumeSendTransportAudio }, { token: ReceiveAllPipedTransports }, { token: DisconnectSendTransportVideo }, { token: DisconnectSendTransportAudio }, { token: DisconnectSendTransportScreen }, { token: GetPipedProducersAlt }, { token: SignalNewConsumerTransport }, { token: ConnectRecvTransport }, { token: ReUpdateInter }, { token: UpdateParticipantAudioDecibels }, { token: CloseAndResize }, { token: AutoAdjust }, { token: SwitchUserVideoAlt }, { token: SwitchUserVideo }, { token: SwitchUserAudio }, { token: GetDomains }, { token: FormatNumber }, { token: ConnectIps }, { token: ConnectLocalIps }, { token: CreateDeviceClient }, { token: CaptureCanvasStream }, { token: ResumePauseAudioStreams }, { token: ProcessConsumerTransportsAudio }, { token: LaunchMessages }, { token: LaunchConfirmExit }, { token: StartMeetingProgressTimer }, { token: ProducerMediaPaused }, { token: ProducerMediaResumed }, { token: ProducerMediaClosed }, { token: MeetingEnded }, { token: DisconnectUserSelf }, { token: ReceiveMessage }, { token: MeetingTimeRemaining }, { token: MeetingStillThere }, { token: AllMembers }, { token: AllMembersRest }, { token: Disconnect }, { token: SocketManager }, { token: JoinRoomClient }, { token: JoinLocalRoom }, { token: UpdateRoomParametersClient }, { token: ClickVideo }, { token: ClickAudio }, { token: ClickScreenShare }, { token: SwitchVideoAlt }, { token: StreamSuccessVideo }, { token: StreamSuccessAudio }, { token: StreamSuccessScreen }, { token: StreamSuccessAudioSwitch }, { token: CheckPermission }, { token: UpdateConsumingDomains }, { token: ReceiveRoomMessages }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.0.1", type: MediasfuChat, isStandalone: true, selector: "app-mediasfu-chat", inputs: { PrejoinPage: "PrejoinPage", localLink: "localLink", connectMediaSFU: "connectMediaSFU", credentials: "credentials", useLocalUIMode: "useLocalUIMode", seedData: "seedData", useSeed: "useSeed", imgSrc: "imgSrc", sourceParameters: "sourceParameters", updateSourceParameters: "updateSourceParameters", returnUI: "returnUI", noUIPreJoinOptions: "noUIPreJoinOptions", joinMediaSFURoom: "joinMediaSFURoom", createMediaSFURoom: "createMediaSFURoom" }, host: { listeners: { "window:resize": "handleResize()", "window:orientationchange": "handleResize()" } }, providers: [CookieService], ngImport: i0, template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component *ngIf="returnUI">
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <!-- MainGridComponent removed -->

              <!-- OtherGridComponent -->
              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <!-- AudioGrid -->
                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <!-- Control Buttons for Chat -->
                <app-control-buttons-component-touch
                  [buttons]="controlChatButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'chat'"
                ></app-control-buttons-component-touch>

                <!-- Flexible Grid -->
                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <!-- SubAspectComponent removed -->
        </app-main-container-component>
      </ng-template>

      <!-- Modals to include -->
      <ng-container *ngIf="returnUI">
      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
        [localLink]="localLink"
      ></app-share-event-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </ng-container>
    </div>
  `, isInline: true, styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: AlertComponent, selector: "app-alert-component", inputs: ["visible", "message", "type", "duration", "textColor", "onHide"] }, { kind: "component", type: AudioGrid, selector: "app-audio-grid", inputs: ["componentsToRender"] }, { kind: "component", type: ControlButtonsComponentTouch, selector: "app-control-buttons-component-touch", inputs: ["buttons", "position", "location", "direction", "buttonsContainerStyle", "showAspect"] }, { kind: "component", type: FlexibleGrid, selector: "app-flexible-grid", inputs: ["customWidth", "customHeight", "rows", "columns", "componentsToRender", "backgroundColor"] }, { kind: "component", type: LoadingModal, selector: "app-loading-modal", inputs: ["isVisible", "backgroundColor", "displayColor"] }, { kind: "component", type: ConfirmExitModal, selector: "app-confirm-exit-modal", inputs: ["isConfirmExitModalVisible", "onConfirmExitClose", "position", "backgroundColor", "exitEventOnConfirm", "member", "ban", "roomName", "socket", "islevel"] }, { kind: "component", type: MessagesModal, selector: "app-messages-modal", inputs: ["isMessagesModalVisible", "onMessagesClose", "onSendMessagePress", "messages", "position", "backgroundColor", "activeTabBackgroundColor", "eventType", "member", "islevel", "coHostResponsibility", "coHost", "startDirectMessage", "directMessageDetails", "updateStartDirectMessage", "updateDirectMessageDetails", "showAlert", "roomName", "socket", "chatSetting"] }, { kind: "component", type: ConfirmHereModal, selector: "app-confirm-here-modal", inputs: ["isConfirmHereModalVisible", "position", "backgroundColor", "displayColor", "onConfirmHereClose", "countdownDuration", "socket", "localSocket", "roomName", "member"] }, { kind: "component", type: ShareEventModal, selector: "app-share-event-modal", inputs: ["backgroundColor", "isShareEventModalVisible", "onShareEventClose", "roomName", "adminPasscode", "islevel", "position", "shareButtons", "eventType", "localLink"] }, { kind: "component", type: MainAspectComponent, selector: "app-main-aspect-component", inputs: ["backgroundColor", "showControls", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "updateIsWideScreen", "updateIsMediumScreen", "updateIsSmallScreen"] }, { kind: "component", type: MainContainerComponent, selector: "app-main-container-component", inputs: ["backgroundColor", "containerWidthFraction", "containerHeightFraction", "marginLeft", "marginRight", "marginTop", "marginBottom", "padding"] }, { kind: "component", type: MainScreenComponent, selector: "app-main-screen-component", inputs: ["mainSize", "doStack", "containerWidthFraction", "containerHeightFraction", "defaultFraction", "showControls", "updateComponentSizes"] }, { kind: "component", type: OtherGridComponent, selector: "app-other-grid-component", inputs: ["backgroundColor", "width", "height", "showAspect", "timeBackgroundColor", "showTimer", "meetingProgressTime"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.0.1", ngImport: i0, type: MediasfuChat, decorators: [{
            type: Component,
            args: [{ selector: 'app-mediasfu-chat', imports: [
                        CommonModule,
                        AlertComponent,
                        AudioGrid,
                        ControlButtonsComponentTouch,
                        FlexibleGrid,
                        LoadingModal,
                        ConfirmExitModal,
                        MessagesModal,
                        ConfirmHereModal,
                        ShareEventModal,
                        MainAspectComponent,
                        MainContainerComponent,
                        MainScreenComponent,
                        OtherGridComponent,
                    ], template: `
    <div
      class="MediaSFU"
      [ngStyle]="{
        height: '100vh',
        width: '100vw',
        maxWidth: '100vw',
        maxHeight: '100vh',
        overflow: 'hidden'
      }"
    >
      <ng-container *ngIf="!validated.value; else mainContent">
        <ng-container
          *ngComponentOutlet="
            PrejoinPageComponent.component;
            injector: PrejoinPageComponent.injector
          "
        >
        </ng-container>
      </ng-container>

      <ng-template #mainContent>
        <app-main-container-component *ngIf="returnUI">
          <app-main-aspect-component
            [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
            [defaultFraction]="1 - controlHeight.value"
            [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
            [updateIsWideScreen]="updateIsWideScreen"
            [updateIsMediumScreen]="updateIsMediumScreen"
            [updateIsSmallScreen]="updateIsSmallScreen"
          >
            <app-main-screen-component
              [doStack]="true"
              [mainSize]="mainHeightWidth.value"
              [defaultFraction]="1 - controlHeight.value"
              [showControls]="eventType.value === 'webinar' || eventType.value === 'conference'"
              [updateComponentSizes]="updateComponentSizes"
            >
              <!-- MainGridComponent removed -->

              <!-- OtherGridComponent -->
              <app-other-grid-component
                [height]="componentSizes.value.otherHeight"
                [width]="componentSizes.value.otherWidth"
                [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                [showAspect]="mainHeightWidth.value !== 100"
                [timeBackgroundColor]="recordState.value"
                [showTimer]="mainHeightWidth.value === 0"
                [meetingProgressTime]="meetingProgressTime.value"
              >
                <!-- AudioGrid -->
                <app-audio-grid [componentsToRender]="audioOnlyStreams.value"></app-audio-grid>

                <!-- Control Buttons for Chat -->
                <app-control-buttons-component-touch
                  [buttons]="controlChatButtons"
                  [position]="'right'"
                  [location]="'bottom'"
                  [direction]="'vertical'"
                  [showAspect]="eventType.value === 'chat'"
                ></app-control-buttons-component-touch>

                <!-- Flexible Grid -->
                <app-flexible-grid
                  [customWidth]="gridSizes.value.gridWidth!"
                  [customHeight]="gridSizes.value.gridHeight!"
                  [rows]="gridRows.value"
                  [columns]="gridCols.value"
                  [componentsToRender]="otherGridStreams.value[0]"
                  [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
                ></app-flexible-grid>
              </app-other-grid-component>
            </app-main-screen-component>
          </app-main-aspect-component>

          <!-- SubAspectComponent removed -->
        </app-main-container-component>
      </ng-template>

      <!-- Modals to include -->
      <ng-container *ngIf="returnUI">
      <app-messages-modal
        [backgroundColor]="
          eventType.value === 'webinar' || eventType.value === 'conference'
            ? '#f5f5f5'
            : 'rgba(255, 255, 255, 0.25)'
        "
        [isMessagesModalVisible]="isMessagesModalVisible.value"
        [onMessagesClose]="onMessagesClose"
        [messages]="messages.value"
        [eventType]="eventType.value"
        [member]="member.value"
        [islevel]="islevel.value"
        [coHostResponsibility]="coHostResponsibility.value"
        [coHost]="coHost.value"
        [startDirectMessage]="startDirectMessage.value"
        [directMessageDetails]="directMessageDetails.value"
        [updateStartDirectMessage]="updateStartDirectMessage"
        [updateDirectMessageDetails]="updateDirectMessageDetails"
        [showAlert]="showAlert"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [chatSetting]="chatSetting.value"
      ></app-messages-modal>

      <app-confirm-exit-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmExitModalVisible]="isConfirmExitModalVisible.value"
        [onConfirmExitClose]="onConfirmExitClose"
        [position]="'topRight'"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
        [islevel]="islevel.value"
      ></app-confirm-exit-modal>

      <app-confirm-here-modal
        [backgroundColor]="'rgba(181, 233, 229, 0.97)'"
        [isConfirmHereModalVisible]="isConfirmHereModalVisible.value"
        [onConfirmHereClose]="onConfirmHereClose"
        [member]="member.value"
        [roomName]="roomName.value"
        [socket]="socket.value"
      ></app-confirm-here-modal>

      <app-share-event-modal
        [isShareEventModalVisible]="isShareEventModalVisible.value"
        [onShareEventClose]="onShareEventClose"
        [roomName]="roomName.value"
        [islevel]="islevel.value"
        [adminPasscode]="adminPasscode.value"
        [eventType]="eventType.value"
        [localLink]="localLink"
      ></app-share-event-modal>

      <app-alert-component
        [visible]="alertVisible.value"
        [message]="alertMessage.value"
        [type]="alertType.value"
        [duration]="alertDuration.value"
        [onHide]="onAlertHide"
        textColor="#ffffff"
      ></app-alert-component>

      <app-loading-modal
        [isVisible]="isLoadingModalVisible.value"
        [backgroundColor]="'rgba(217, 227, 234, 0.99)'"
        displayColor="black"
      ></app-loading-modal>
    </ng-container>
    </div>
  `, providers: [CookieService] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: UpdateMiniCardsGrid }, { type: MixStreams }, { type: DispStreams }, { type: StopShareScreen }, { type: CheckScreenShare }, { type: StartShareScreen }, { type: RequestScreenShare }, { type: ReorderStreams }, { type: PrepopulateUserMedia }, { type: GetVideos }, { type: RePort }, { type: Trigger }, { type: ConsumerResume }, { type: ConnectSendTransport }, { type: ConnectSendTransportAudio }, { type: ConnectSendTransportVideo }, { type: ConnectSendTransportScreen }, { type: ProcessConsumerTransports }, { type: ResumePauseStreams }, { type: Readjust }, { type: CheckGrid }, { type: GetEstimate }, { type: CalculateRowsAndColumns }, { type: AddVideosGrid }, { type: OnScreenChanges }, { type: ChangeVids }, { type: CompareActiveNames }, { type: CompareScreenStates }, { type: CreateSendTransport }, { type: ResumeSendTransportAudio }, { type: ReceiveAllPipedTransports }, { type: DisconnectSendTransportVideo }, { type: DisconnectSendTransportAudio }, { type: DisconnectSendTransportScreen }, { type: GetPipedProducersAlt }, { type: SignalNewConsumerTransport }, { type: ConnectRecvTransport }, { type: ReUpdateInter }, { type: UpdateParticipantAudioDecibels }, { type: CloseAndResize }, { type: AutoAdjust }, { type: SwitchUserVideoAlt }, { type: SwitchUserVideo }, { type: SwitchUserAudio }, { type: GetDomains }, { type: FormatNumber }, { type: ConnectIps }, { type: ConnectLocalIps }, { type: CreateDeviceClient }, { type: CaptureCanvasStream }, { type: ResumePauseAudioStreams }, { type: ProcessConsumerTransportsAudio }, { type: LaunchMessages }, { type: LaunchConfirmExit }, { type: StartMeetingProgressTimer }, { type: ProducerMediaPaused }, { type: ProducerMediaResumed }, { type: ProducerMediaClosed }, { type: MeetingEnded }, { type: DisconnectUserSelf }, { type: ReceiveMessage }, { type: MeetingTimeRemaining }, { type: MeetingStillThere }, { type: AllMembers }, { type: AllMembersRest }, { type: Disconnect }, { type: SocketManager }, { type: JoinRoomClient }, { type: JoinLocalRoom }, { type: UpdateRoomParametersClient }, { type: ClickVideo }, { type: ClickAudio }, { type: ClickScreenShare }, { type: SwitchVideoAlt }, { type: StreamSuccessVideo }, { type: StreamSuccessAudio }, { type: StreamSuccessScreen }, { type: StreamSuccessAudioSwitch }, { type: CheckPermission }, { type: UpdateConsumingDomains }, { type: ReceiveRoomMessages }], propDecorators: { PrejoinPage: [{
                type: Input
            }], localLink: [{
                type: Input
            }], connectMediaSFU: [{
                type: Input
            }], credentials: [{
                type: Input
            }], useLocalUIMode: [{
                type: Input
            }], seedData: [{
                type: Input
            }], useSeed: [{
                type: Input
            }], imgSrc: [{
                type: Input
            }], sourceParameters: [{
                type: Input
            }], updateSourceParameters: [{
                type: Input
            }], returnUI: [{
                type: Input
            }], noUIPreJoinOptions: [{
                type: Input
            }], joinMediaSFURoom: [{
                type: Input
            }], createMediaSFURoom: [{
                type: Input
            }], handleResize: [{
                type: HostListener,
                args: ['window:resize']
            }, {
                type: HostListener,
                args: ['window:orientationchange']
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { AParams, AddVideosGrid, AlertComponent, AllMembers, AllMembersRest, AllWaitingRoomMembers, AudioCard, AudioGrid, AutoAdjust, BackgroundModal, BanParticipant, BreakoutRoomUpdated, BreakoutRoomsModal, CalculateRowsAndColumns, CaptureCanvasStream, CardVideoDisplay, ChangeVids, CheckGrid, CheckLimitsAndMakeRequest, CheckPauseState, CheckPermission, CheckResumeState, CheckScreenShare, ClickAudio, ClickChat, ClickScreenShare, ClickVideo, CloseAndResize, CoHostModal, CompareActiveNames, CompareScreenStates, ConfigureWhiteboardModal, ConfirmExit, ConfirmExitModal, ConfirmHereModal, ConfirmRecording, ConnectIps, ConnectLocalIps, ConnectRecvTransport, ConnectSendTransport, ConnectSendTransportAudio, ConnectSendTransportScreen, ConnectSendTransportVideo, ConsumerResume, ControlButtonsAltComponent, ControlButtonsComponent, ControlButtonsComponentTouch, ControlMedia, ControlMediaHost, CreateDeviceClient, CreateRoomOnMediaSFU, CreateSendTransport, CustomButtons, Disconnect, DisconnectSendTransportAudio, DisconnectSendTransportScreen, DisconnectSendTransportVideo, DisconnectUserSelf, DispStreams, DisplaySettingsModal, EventSettingsModal, FlexibleGrid, FlexibleVideo, FormatNumber, GeneratePageContent, GenerateRandomMessages, GenerateRandomParticipants, GenerateRandomPolls, GenerateRandomRequestList, GenerateRandomWaitingRoomList, GetDomains, GetEstimate, GetPipedProducersAlt, GetProducersPiped, GetVideos, HParams, HandleCreatePoll, HandleEndPoll, HandleVotePoll, HostRequestResponse, JoinConRoom, JoinConsumeRoom, JoinLocalRoom, JoinRoom, JoinRoomClient, JoinRoomOnMediaSFU, LaunchBackground, LaunchBreakoutRooms, LaunchConfigureWhiteboard, LaunchConfirmExit, LaunchDisplaySettings, LaunchMediaSettings, LaunchMenuModal, LaunchMessages, LaunchParticipants, LaunchPoll, LaunchRecording, LaunchRequests, LaunchSettings, LaunchWaiting, LoadingModal, MainAspectComponent, MainContainerComponent, MainGridComponent, MainScreenComponent, MediaSettingsModal, MediasfuBroadcast, MediasfuChat, MediasfuConference, MediasfuGeneric, MediasfuWebinar, MeetingEnded, MeetingProgressTimer, MeetingStillThere, MeetingTimeRemaining, MenuModal, MenuParticipantsWidget, MenuRecordWidget, MenuWidget, MessageParticipants, MessageWidget, MessagesModal, MiniAudio, MiniAudioPlayer, MiniCard, MiniCardAudio, MixStreams, ModifyCoHostSettings, ModifyDisplaySettings, ModifySettings, MuteParticipants, NewPipeProducer, OnScreenChanges, OtherGridComponent, Pagination, ParticipantRequested, ParticipantsModal, PersonJoined, PollModal, PollUpdated, PreJoinPage, PrepopulateUserMedia, ProcessConsumerTransports, ProcessConsumerTransportsAudio, ProducerClosed, ProducerMediaClosed, ProducerMediaPaused, ProducerMediaResumed, ReInitiateRecording, RePort, ReUpdateInter, Readjust, ReceiveAllPipedTransports, ReceiveMessage, ReceiveRoomMessages, RecordPauseTimer, RecordResumeTimer, RecordStartTimer, RecordTimerWidget, RecordUpdateTimer, RecordingModal, RecordingNotice, RemoveParticipants, ReorderStreams, RequestScreenShare, RequestsModal, RespondToRequests, RespondToWaiting, ResumePauseAudioStreams, ResumePauseStreams, ResumeSendTransportAudio, RoomRecordParams, ScreenParams, ScreenProducerId, ScreenShareWidget, Screenboard, ScreenboardModal, SendMessage, ShareEventModal, SignalNewConsumerTransport, SocketManager, SoundPlayer, StartMeetingProgressTimer, StartRecording, StartRecords, StartShareScreen, StopRecording, StopShareScreen, StoppedRecording, StreamSuccessAudio, StreamSuccessAudioSwitch, StreamSuccessScreen, StreamSuccessVideo, SubAspectComponent, SwitchAudio, SwitchUserAudio, SwitchUserVideo, SwitchUserVideoAlt, SwitchVideo, SwitchVideoAlt, TimeLeftRecording, Trigger, UpdateConsumingDomains, UpdateMediaSettings, UpdateMiniCardsGrid, UpdateParticipantAudioDecibels, UpdateRecording, UpdateRoomParametersClient, UpdatedCoHost, UserWaiting, VParams, ValidateAlphanumeric, VideoCard, WaitingRoomModal, WelcomePage, Whiteboard, connectLocalSendTransportAudio, connectLocalSendTransportScreen, connectLocalSendTransportVideo, createLocalSendTransport, createResponseJoinRoom, disconnectLocalSendTransportAudio, disconnectLocalSendTransportScreen, disconnectLocalSendTransportVideo, getModalPosition, getOverlayPosition, initialValuesState, launchCoHost, sleep, updateMicLevel };
//# sourceMappingURL=mediasfu-angular.mjs.map
